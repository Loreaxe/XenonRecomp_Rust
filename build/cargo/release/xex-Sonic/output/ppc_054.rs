pub fn sub_825EB680(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825EB680 size=196
    let mut pc: u32 = 0x825EB680;
    'dispatch: loop {
        match pc {
            0x825EB680 => {
    //   block [0x825EB680..0x825EB744)
	// 825EB680: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EB684: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825EB688: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825EB68C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825EB690: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EB694: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825EB698: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825EB69C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825EB6A0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825EB6A4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825EB6A8: 4BCD5291  bl 0x822c0938
	ctx.lr = 0x825EB6AC;
	sub_822C0938(ctx, base);
	// 825EB6AC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825EB6B0: 41820028  beq 0x825eb6d8
	if ctx.cr[0].eq {
	pc = 0x825EB6D8; continue 'dispatch;
	}
	// 825EB6B4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825EB6B8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825EB6BC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825EB6C0: 392B0178  addi r9, r11, 0x178
	ctx.r[9].s64 = ctx.r[11].s64 + 376;
	// 825EB6C4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825EB6C8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825EB6CC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825EB6D0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825EB6D4: 48000008  b 0x825eb6dc
	pc = 0x825EB6DC; continue 'dispatch;
	// 825EB6D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825EB6DC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825EB6E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825EB6E4: 409A0044  bne cr6, 0x825eb728
	if !ctx.cr[6].eq {
	pc = 0x825EB728; continue 'dispatch;
	}
	// 825EB6E8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825EB6EC: 419A001C  beq cr6, 0x825eb708
	if ctx.cr[6].eq {
	pc = 0x825EB708; continue 'dispatch;
	}
	// 825EB6F0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EB6F4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825EB6F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825EB6FC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825EB700: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825EB704: 4E800421  bctrl
	ctx.lr = 0x825EB708;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825EB708: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825EB70C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825EB710: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825EB714: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825EB718: 816BE238  lwz r11, -0x1dc8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7624 as u32) ) } as u64;
	// 825EB71C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825EB720: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825EB724: 4BCD48DD  bl 0x822c0000
	ctx.lr = 0x825EB728;
	sub_822C0000(ctx, base);
	// 825EB728: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EB72C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825EB730: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825EB734: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825EB738: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825EB73C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825EB740: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EB748(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825EB748 size=196
    let mut pc: u32 = 0x825EB748;
    'dispatch: loop {
        match pc {
            0x825EB748 => {
    //   block [0x825EB748..0x825EB80C)
	// 825EB748: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EB74C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825EB750: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825EB754: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825EB758: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EB75C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825EB760: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825EB764: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825EB768: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825EB76C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825EB770: 4BCD51C9  bl 0x822c0938
	ctx.lr = 0x825EB774;
	sub_822C0938(ctx, base);
	// 825EB774: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825EB778: 41820028  beq 0x825eb7a0
	if ctx.cr[0].eq {
	pc = 0x825EB7A0; continue 'dispatch;
	}
	// 825EB77C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825EB780: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825EB784: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825EB788: 392B018C  addi r9, r11, 0x18c
	ctx.r[9].s64 = ctx.r[11].s64 + 396;
	// 825EB78C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825EB790: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825EB794: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825EB798: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825EB79C: 48000008  b 0x825eb7a4
	pc = 0x825EB7A4; continue 'dispatch;
	// 825EB7A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825EB7A4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825EB7A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825EB7AC: 409A0044  bne cr6, 0x825eb7f0
	if !ctx.cr[6].eq {
	pc = 0x825EB7F0; continue 'dispatch;
	}
	// 825EB7B0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825EB7B4: 419A001C  beq cr6, 0x825eb7d0
	if ctx.cr[6].eq {
	pc = 0x825EB7D0; continue 'dispatch;
	}
	// 825EB7B8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EB7BC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825EB7C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825EB7C4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825EB7C8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825EB7CC: 4E800421  bctrl
	ctx.lr = 0x825EB7D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825EB7D0: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825EB7D4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825EB7D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825EB7DC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825EB7E0: 816BE238  lwz r11, -0x1dc8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7624 as u32) ) } as u64;
	// 825EB7E4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825EB7E8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825EB7EC: 4BCD4815  bl 0x822c0000
	ctx.lr = 0x825EB7F0;
	sub_822C0000(ctx, base);
	// 825EB7F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EB7F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825EB7F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825EB7FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825EB800: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825EB804: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825EB808: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EB810(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825EB810 size=196
    let mut pc: u32 = 0x825EB810;
    'dispatch: loop {
        match pc {
            0x825EB810 => {
    //   block [0x825EB810..0x825EB8D4)
	// 825EB810: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EB814: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825EB818: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825EB81C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825EB820: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EB824: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825EB828: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825EB82C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825EB830: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825EB834: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825EB838: 4BCD5101  bl 0x822c0938
	ctx.lr = 0x825EB83C;
	sub_822C0938(ctx, base);
	// 825EB83C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825EB840: 41820028  beq 0x825eb868
	if ctx.cr[0].eq {
	pc = 0x825EB868; continue 'dispatch;
	}
	// 825EB844: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825EB848: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825EB84C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825EB850: 392B01A0  addi r9, r11, 0x1a0
	ctx.r[9].s64 = ctx.r[11].s64 + 416;
	// 825EB854: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825EB858: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825EB85C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825EB860: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825EB864: 48000008  b 0x825eb86c
	pc = 0x825EB86C; continue 'dispatch;
	// 825EB868: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825EB86C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825EB870: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825EB874: 409A0044  bne cr6, 0x825eb8b8
	if !ctx.cr[6].eq {
	pc = 0x825EB8B8; continue 'dispatch;
	}
	// 825EB878: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825EB87C: 419A001C  beq cr6, 0x825eb898
	if ctx.cr[6].eq {
	pc = 0x825EB898; continue 'dispatch;
	}
	// 825EB880: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EB884: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825EB888: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825EB88C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825EB890: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825EB894: 4E800421  bctrl
	ctx.lr = 0x825EB898;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825EB898: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825EB89C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825EB8A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825EB8A4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825EB8A8: 816BE238  lwz r11, -0x1dc8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7624 as u32) ) } as u64;
	// 825EB8AC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825EB8B0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825EB8B4: 4BCD474D  bl 0x822c0000
	ctx.lr = 0x825EB8B8;
	sub_822C0000(ctx, base);
	// 825EB8B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EB8BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825EB8C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825EB8C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825EB8C8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825EB8CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825EB8D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EB8D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825EB8D8 size=196
    let mut pc: u32 = 0x825EB8D8;
    'dispatch: loop {
        match pc {
            0x825EB8D8 => {
    //   block [0x825EB8D8..0x825EB99C)
	// 825EB8D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EB8DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825EB8E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825EB8E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825EB8E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EB8EC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825EB8F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825EB8F4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825EB8F8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825EB8FC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825EB900: 4BCD5039  bl 0x822c0938
	ctx.lr = 0x825EB904;
	sub_822C0938(ctx, base);
	// 825EB904: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825EB908: 41820028  beq 0x825eb930
	if ctx.cr[0].eq {
	pc = 0x825EB930; continue 'dispatch;
	}
	// 825EB90C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825EB910: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825EB914: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825EB918: 392B01B4  addi r9, r11, 0x1b4
	ctx.r[9].s64 = ctx.r[11].s64 + 436;
	// 825EB91C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825EB920: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825EB924: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825EB928: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825EB92C: 48000008  b 0x825eb934
	pc = 0x825EB934; continue 'dispatch;
	// 825EB930: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825EB934: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825EB938: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825EB93C: 409A0044  bne cr6, 0x825eb980
	if !ctx.cr[6].eq {
	pc = 0x825EB980; continue 'dispatch;
	}
	// 825EB940: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825EB944: 419A001C  beq cr6, 0x825eb960
	if ctx.cr[6].eq {
	pc = 0x825EB960; continue 'dispatch;
	}
	// 825EB948: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EB94C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825EB950: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825EB954: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825EB958: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825EB95C: 4E800421  bctrl
	ctx.lr = 0x825EB960;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825EB960: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825EB964: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825EB968: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825EB96C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825EB970: 816BE238  lwz r11, -0x1dc8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7624 as u32) ) } as u64;
	// 825EB974: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825EB978: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825EB97C: 4BCD4685  bl 0x822c0000
	ctx.lr = 0x825EB980;
	sub_822C0000(ctx, base);
	// 825EB980: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EB984: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825EB988: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825EB98C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825EB990: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825EB994: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825EB998: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EB9A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825EB9A0 size=196
    let mut pc: u32 = 0x825EB9A0;
    'dispatch: loop {
        match pc {
            0x825EB9A0 => {
    //   block [0x825EB9A0..0x825EBA64)
	// 825EB9A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EB9A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825EB9A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825EB9AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825EB9B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EB9B4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825EB9B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825EB9BC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825EB9C0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825EB9C4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825EB9C8: 4BCD4F71  bl 0x822c0938
	ctx.lr = 0x825EB9CC;
	sub_822C0938(ctx, base);
	// 825EB9CC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825EB9D0: 41820028  beq 0x825eb9f8
	if ctx.cr[0].eq {
	pc = 0x825EB9F8; continue 'dispatch;
	}
	// 825EB9D4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825EB9D8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825EB9DC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825EB9E0: 392B01C8  addi r9, r11, 0x1c8
	ctx.r[9].s64 = ctx.r[11].s64 + 456;
	// 825EB9E4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825EB9E8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825EB9EC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825EB9F0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825EB9F4: 48000008  b 0x825eb9fc
	pc = 0x825EB9FC; continue 'dispatch;
	// 825EB9F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825EB9FC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825EBA00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825EBA04: 409A0044  bne cr6, 0x825eba48
	if !ctx.cr[6].eq {
	pc = 0x825EBA48; continue 'dispatch;
	}
	// 825EBA08: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825EBA0C: 419A001C  beq cr6, 0x825eba28
	if ctx.cr[6].eq {
	pc = 0x825EBA28; continue 'dispatch;
	}
	// 825EBA10: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EBA14: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825EBA18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825EBA1C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825EBA20: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825EBA24: 4E800421  bctrl
	ctx.lr = 0x825EBA28;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825EBA28: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825EBA2C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825EBA30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825EBA34: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825EBA38: 816BE238  lwz r11, -0x1dc8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7624 as u32) ) } as u64;
	// 825EBA3C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825EBA40: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825EBA44: 4BCD45BD  bl 0x822c0000
	ctx.lr = 0x825EBA48;
	sub_822C0000(ctx, base);
	// 825EBA48: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EBA4C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825EBA50: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825EBA54: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825EBA58: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825EBA5C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825EBA60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EBA68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825EBA68 size=280
    let mut pc: u32 = 0x825EBA68;
    'dispatch: loop {
        match pc {
            0x825EBA68 => {
    //   block [0x825EBA68..0x825EBB80)
	// 825EBA68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EBA6C: 48BBC701  bl 0x831a816c
	ctx.lr = 0x825EBA70;
	sub_831A8130(ctx, base);
	// 825EBA70: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EBA74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825EBA78: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825EBA7C: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825EBA80: 396B0334  addi r11, r11, 0x334
	ctx.r[11].s64 = ctx.r[11].s64 + 820;
	// 825EBA84: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 825EBA88: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 825EBA8C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825EBA90: 394A0320  addi r10, r10, 0x320
	ctx.r[10].s64 = ctx.r[10].s64 + 800;
	// 825EBA94: 392902D4  addi r9, r9, 0x2d4
	ctx.r[9].s64 = ctx.r[9].s64 + 724;
	// 825EBA98: 396802C4  addi r11, r8, 0x2c4
	ctx.r[11].s64 = ctx.r[8].s64 + 708;
	// 825EBA9C: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 825EBAA0: 913F0160  stw r9, 0x160(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), ctx.r[9].u32 ) };
	// 825EBAA4: 3BDF0160  addi r30, r31, 0x160
	ctx.r[30].s64 = ctx.r[31].s64 + 352;
	// 825EBAA8: 917F0164  stw r11, 0x164(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(356 as u32), ctx.r[11].u32 ) };
	// 825EBAAC: 3BBF0164  addi r29, r31, 0x164
	ctx.r[29].s64 = ctx.r[31].s64 + 356;
	// 825EBAB0: 807F0294  lwz r3, 0x294(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(660 as u32) ) } as u64;
	// 825EBAB4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EBAB8: 419A0008  beq cr6, 0x825ebac0
	if ctx.cr[6].eq {
	pc = 0x825EBAC0; continue 'dispatch;
	}
	// 825EBABC: 4BCD4DD5  bl 0x822c0890
	ctx.lr = 0x825EBAC0;
	sub_822C0890(ctx, base);
	// 825EBAC0: 807F028C  lwz r3, 0x28c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(652 as u32) ) } as u64;
	// 825EBAC4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EBAC8: 419A0018  beq cr6, 0x825ebae0
	if ctx.cr[6].eq {
	pc = 0x825EBAE0; continue 'dispatch;
	}
	// 825EBACC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EBAD0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825EBAD4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EBAD8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825EBADC: 4E800421  bctrl
	ctx.lr = 0x825EBAE0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825EBAE0: 807F0288  lwz r3, 0x288(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(648 as u32) ) } as u64;
	// 825EBAE4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EBAE8: 419A0008  beq cr6, 0x825ebaf0
	if ctx.cr[6].eq {
	pc = 0x825EBAF0; continue 'dispatch;
	}
	// 825EBAEC: 4BCD4DA5  bl 0x822c0890
	ctx.lr = 0x825EBAF0;
	sub_822C0890(ctx, base);
	// 825EBAF0: 807F0280  lwz r3, 0x280(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(640 as u32) ) } as u64;
	// 825EBAF4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EBAF8: 419A0008  beq cr6, 0x825ebb00
	if ctx.cr[6].eq {
	pc = 0x825EBB00; continue 'dispatch;
	}
	// 825EBAFC: 4BCD4D95  bl 0x822c0890
	ctx.lr = 0x825EBB00;
	sub_822C0890(ctx, base);
	// 825EBB00: 807F0278  lwz r3, 0x278(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(632 as u32) ) } as u64;
	// 825EBB04: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EBB08: 419A0008  beq cr6, 0x825ebb10
	if ctx.cr[6].eq {
	pc = 0x825EBB10; continue 'dispatch;
	}
	// 825EBB0C: 4BCD4D85  bl 0x822c0890
	ctx.lr = 0x825EBB10;
	sub_822C0890(ctx, base);
	// 825EBB10: 807F0270  lwz r3, 0x270(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(624 as u32) ) } as u64;
	// 825EBB14: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EBB18: 419A0008  beq cr6, 0x825ebb20
	if ctx.cr[6].eq {
	pc = 0x825EBB20; continue 'dispatch;
	}
	// 825EBB1C: 4BCD4D75  bl 0x822c0890
	ctx.lr = 0x825EBB20;
	sub_822C0890(ctx, base);
	// 825EBB20: 807F0268  lwz r3, 0x268(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(616 as u32) ) } as u64;
	// 825EBB24: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EBB28: 419A0008  beq cr6, 0x825ebb30
	if ctx.cr[6].eq {
	pc = 0x825EBB30; continue 'dispatch;
	}
	// 825EBB2C: 4BCD4D65  bl 0x822c0890
	ctx.lr = 0x825EBB30;
	sub_822C0890(ctx, base);
	// 825EBB30: 807F0244  lwz r3, 0x244(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(580 as u32) ) } as u64;
	// 825EBB34: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EBB38: 419A0008  beq cr6, 0x825ebb40
	if ctx.cr[6].eq {
	pc = 0x825EBB40; continue 'dispatch;
	}
	// 825EBB3C: 4BCD4D55  bl 0x822c0890
	ctx.lr = 0x825EBB40;
	sub_822C0890(ctx, base);
	// 825EBB40: 807F01D0  lwz r3, 0x1d0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(464 as u32) ) } as u64;
	// 825EBB44: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EBB48: 419A0008  beq cr6, 0x825ebb50
	if ctx.cr[6].eq {
	pc = 0x825EBB50; continue 'dispatch;
	}
	// 825EBB4C: 4BCD4D45  bl 0x822c0890
	ctx.lr = 0x825EBB50;
	sub_822C0890(ctx, base);
	// 825EBB50: 807F01C8  lwz r3, 0x1c8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(456 as u32) ) } as u64;
	// 825EBB54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EBB58: 419A0008  beq cr6, 0x825ebb60
	if ctx.cr[6].eq {
	pc = 0x825EBB60; continue 'dispatch;
	}
	// 825EBB5C: 4BCD4D35  bl 0x822c0890
	ctx.lr = 0x825EBB60;
	sub_822C0890(ctx, base);
	// 825EBB60: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825EBB64: 48871CE5  bl 0x82e5d848
	ctx.lr = 0x825EBB68;
	sub_82E5D848(ctx, base);
	// 825EBB68: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EBB6C: 481BBAED  bl 0x827a7658
	ctx.lr = 0x825EBB70;
	sub_827A7658(ctx, base);
	// 825EBB70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825EBB74: 4BF27B55  bl 0x825136c8
	ctx.lr = 0x825EBB78;
	sub_825136C8(ctx, base);
	// 825EBB78: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825EBB7C: 48BBC640  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EBB80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825EBB80 size=8
    let mut pc: u32 = 0x825EBB80;
    'dispatch: loop {
        match pc {
            0x825EBB80 => {
    //   block [0x825EBB80..0x825EBB88)
	// 825EBB80: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 825EBB84: 48000F0C  b 0x825eca90
	sub_825ECA90(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EBB88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825EBB88 size=8
    let mut pc: u32 = 0x825EBB88;
    'dispatch: loop {
        match pc {
            0x825EBB88 => {
    //   block [0x825EBB88..0x825EBB90)
	// 825EBB88: 3863FEA0  addi r3, r3, -0x160
	ctx.r[3].s64 = ctx.r[3].s64 + -352;
	// 825EBB8C: 48000F04  b 0x825eca90
	sub_825ECA90(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EBB90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825EBB90 size=8
    let mut pc: u32 = 0x825EBB90;
    'dispatch: loop {
        match pc {
            0x825EBB90 => {
    //   block [0x825EBB90..0x825EBB98)
	// 825EBB90: 3863FE9C  addi r3, r3, -0x164
	ctx.r[3].s64 = ctx.r[3].s64 + -356;
	// 825EBB94: 48000EFC  b 0x825eca90
	sub_825ECA90(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EBB98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825EBB98 size=72
    let mut pc: u32 = 0x825EBB98;
    'dispatch: loop {
        match pc {
            0x825EBB98 => {
    //   block [0x825EBB98..0x825EBBE0)
	// 825EBB98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EBB9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825EBBA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EBBA4: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825EBBA8: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 825EBBAC: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 825EBBB0: 394A0360  addi r10, r10, 0x360
	ctx.r[10].s64 = ctx.r[10].s64 + 864;
	// 825EBBB4: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 825EBBB8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825EBBBC: 13EB48C7  vcmpequd (lvx128) v31, v11, v9
	tmp.u32 = ctx.r[11].u32 + ctx.r[9].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 825EBBC0: 13C050C7  vcmpequd (lvx128) v30, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EBBE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825EBBE0 size=108
    let mut pc: u32 = 0x825EBBE0;
    'dispatch: loop {
        match pc {
            0x825EBBE0 => {
    //   block [0x825EBBE0..0x825EBC4C)
	// 825EBBE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EBBE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825EBBE8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825EBBEC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825EBBF0: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EBBF4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825EBBF8: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825EBBFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825EBC00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825EBC04: 3BC40020  addi r30, r4, 0x20
	ctx.r[30].s64 = ctx.r[4].s64 + 32;
	// 825EBC08: C06B08A4  lfs f3, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 825EBC0C: C04A0110  lfs f2, 0x110(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(272 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 825EBC10: FC201890  fmr f1, f3
	ctx.f[1].f64 = ctx.f[3].f64;
	// 825EBC14: 48890405  bl 0x82e7c018
	ctx.lr = 0x825EBC18;
	sub_82E7C018(ctx, base);
	// 825EBC18: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825EBC1C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825EBC20: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825EBC24: 4BCD8CDD  bl 0x822c4900
	ctx.lr = 0x825EBC28;
	sub_822C4900(ctx, base);
	// 825EBC28: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825EBC2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825EBC30: 4BF278F1  bl 0x82513520
	ctx.lr = 0x825EBC34;
	sub_82513520(ctx, base);
	// 825EBC34: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 825EBC38: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825EBC3C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825EBC40: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825EBC44: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825EBC48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EBC50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825EBC50 size=80
    let mut pc: u32 = 0x825EBC50;
    'dispatch: loop {
        match pc {
            0x825EBC50 => {
    //   block [0x825EBC50..0x825EBCA0)
	// 825EBC50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EBC54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825EBC58: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825EBC5C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EBC60: 80840018  lwz r4, 0x18(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 825EBC64: 4BF278D5  bl 0x82513538
	ctx.lr = 0x825EBC68;
	sub_82513538(ctx, base);
	// 825EBC68: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825EBC6C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 825EBC70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825EBC74: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825EBC78: C06B08A4  lfs f3, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 825EBC7C: C04AAC0C  lfs f2, -0x53f4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-21492 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 825EBC80: FC201890  fmr f1, f3
	ctx.f[1].f64 = ctx.f[3].f64;
	// 825EBC84: 48890395  bl 0x82e7c018
	ctx.lr = 0x825EBC88;
	sub_82E7C018(ctx, base);
	// 825EBC88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825EBC8C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825EBC90: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825EBC94: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825EBC98: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825EBC9C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EBCA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825EBCA0 size=668
    let mut pc: u32 = 0x825EBCA0;
    'dispatch: loop {
        match pc {
            0x825EBCA0 => {
    //   block [0x825EBCA0..0x825EBF3C)
	// 825EBCA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EBCA4: 48BBC4C5  bl 0x831a8168
	ctx.lr = 0x825EBCA8;
	sub_831A8130(ctx, base);
	// 825EBCA8: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EBCAC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825EBCB0: 48B68951  bl 0x83154600
	ctx.lr = 0x825EBCB4;
	sub_83154600(ctx, base);
	// 825EBCB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825EBCB8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825EBCBC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EBCC0: 481CA919  bl 0x827b65d8
	ctx.lr = 0x825EBCC4;
	sub_827B65D8(ctx, base);
	// 825EBCC4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EBCC8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825EBCCC: 386B00D0  addi r3, r11, 0xd0
	ctx.r[3].s64 = ctx.r[11].s64 + 208;
	// 825EBCD0: 488EE8A9  bl 0x82eda578
	ctx.lr = 0x825EBCD4;
	sub_82EDA578(ctx, base);
	// 825EBCD4: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825EBCD8: D03E006C  stfs f1, 0x6c(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 825EBCDC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EBCE0: 419A0008  beq cr6, 0x825ebce8
	if ctx.cr[6].eq {
	pc = 0x825EBCE8; continue 'dispatch;
	}
	// 825EBCE4: 4BCD4BAD  bl 0x822c0890
	ctx.lr = 0x825EBCE8;
	sub_822C0890(ctx, base);
	// 825EBCE8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EBCEC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825EBCF0: 481CA8E9  bl 0x827b65d8
	ctx.lr = 0x825EBCF4;
	sub_827B65D8(ctx, base);
	// 825EBCF4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EBCF8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825EBCFC: 838B0008  lwz r28, 8(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825EBD00: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 825EBD04: 419A000C  beq cr6, 0x825ebd10
	if ctx.cr[6].eq {
	pc = 0x825EBD10; continue 'dispatch;
	}
	// 825EBD08: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825EBD0C: 488E2AF5  bl 0x82ece800
	ctx.lr = 0x825EBD10;
	sub_82ECE800(ctx, base);
	// 825EBD10: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825EBD14: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EBD18: 419A0008  beq cr6, 0x825ebd20
	if ctx.cr[6].eq {
	pc = 0x825EBD20; continue 'dispatch;
	}
	// 825EBD1C: 4BCD4B75  bl 0x822c0890
	ctx.lr = 0x825EBD20;
	sub_822C0890(ctx, base);
	// 825EBD20: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EBD24: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825EBD28: 481CA8B1  bl 0x827b65d8
	ctx.lr = 0x825EBD2C;
	sub_827B65D8(ctx, base);
	// 825EBD2C: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EBD30: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825EBD34: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825EBD38: C02BCC2C  lfs f1, -0x33d4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13268 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825EBD3C: 488DF7B5  bl 0x82ecb4f0
	ctx.lr = 0x825EBD40;
	sub_82ECB4F0(ctx, base);
	// 825EBD40: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 825EBD44: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EBD48: 419A0008  beq cr6, 0x825ebd50
	if ctx.cr[6].eq {
	pc = 0x825EBD50; continue 'dispatch;
	}
	// 825EBD4C: 4BCD4B45  bl 0x822c0890
	ctx.lr = 0x825EBD50;
	sub_822C0890(ctx, base);
	// 825EBD50: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EBD54: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825EBD58: 481CA881  bl 0x827b65d8
	ctx.lr = 0x825EBD5C;
	sub_827B65D8(ctx, base);
	// 825EBD5C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EBD60: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825EBD64: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825EBD68: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 825EBD6C: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825EBD70: 488DFE21  bl 0x82ecbb90
	ctx.lr = 0x825EBD74;
	sub_82ECBB90(ctx, base);
	// 825EBD74: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825EBD78: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EBD7C: 419A0008  beq cr6, 0x825ebd84
	if ctx.cr[6].eq {
	pc = 0x825EBD84; continue 'dispatch;
	}
	// 825EBD80: 4BCD4B11  bl 0x822c0890
	ctx.lr = 0x825EBD84;
	sub_822C0890(ctx, base);
	// 825EBD84: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EBD88: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825EBD8C: 481CA84D  bl 0x827b65d8
	ctx.lr = 0x825EBD90;
	sub_827B65D8(ctx, base);
	// 825EBD90: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 825EBD94: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EBD98: 3BAB7060  addi r29, r11, 0x7060
	ctx.r[29].s64 = ctx.r[11].s64 + 28768;
	// 825EBD9C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825EBDA0: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825EBDA4: 4BCFDA1D  bl 0x822e97c0
	ctx.lr = 0x825EBDA8;
	sub_822E97C0(ctx, base);
	// 825EBDA8: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 825EBDAC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EBDB0: 419A0008  beq cr6, 0x825ebdb8
	if ctx.cr[6].eq {
	pc = 0x825EBDB8; continue 'dispatch;
	}
	// 825EBDB4: 4BCD4ADD  bl 0x822c0890
	ctx.lr = 0x825EBDB8;
	sub_822C0890(ctx, base);
	// 825EBDB8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EBDBC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825EBDC0: 481CA819  bl 0x827b65d8
	ctx.lr = 0x825EBDC4;
	sub_827B65D8(ctx, base);
	// 825EBDC4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EBDC8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825EBDCC: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825EBDD0: 4BD01129  bl 0x822ecef8
	ctx.lr = 0x825EBDD4;
	sub_822ECEF8(ctx, base);
	// 825EBDD4: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 825EBDD8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EBDDC: 419A0008  beq cr6, 0x825ebde4
	if ctx.cr[6].eq {
	pc = 0x825EBDE4; continue 'dispatch;
	}
	// 825EBDE0: 4BCD4AB1  bl 0x822c0890
	ctx.lr = 0x825EBDE4;
	sub_822C0890(ctx, base);
	// 825EBDE4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 825EBDE8: 419A000C  beq cr6, 0x825ebdf4
	if ctx.cr[6].eq {
	pc = 0x825EBDF4; continue 'dispatch;
	}
	// 825EBDEC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825EBDF0: 488E1219  bl 0x82ecd008
	ctx.lr = 0x825EBDF4;
	sub_82ECD008(ctx, base);
	// 825EBDF4: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 825EBDF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825EBDFC: 4BF2777D  bl 0x82513578
	ctx.lr = 0x825EBE00;
	sub_82513578(ctx, base);
	// 825EBE00: 39610090  addi r11, r1, 0x90
	ctx.r[11].s64 = ctx.r[1].s64 + 144;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EBF40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825EBF40 size=204
    let mut pc: u32 = 0x825EBF40;
    'dispatch: loop {
        match pc {
            0x825EBF40 => {
    //   block [0x825EBF40..0x825EC00C)
	// 825EBF40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EBF44: 48BBC229  bl 0x831a816c
	ctx.lr = 0x825EBF48;
	sub_831A8130(ctx, base);
	// 825EBF48: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EBF4C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825EBF50: 48B686B1  bl 0x83154600
	ctx.lr = 0x825EBF54;
	sub_83154600(ctx, base);
	// 825EBF54: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825EBF58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825EBF5C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EBF60: 481CA679  bl 0x827b65d8
	ctx.lr = 0x825EBF64;
	sub_827B65D8(ctx, base);
	// 825EBF64: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EBF68: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825EBF6C: 83AB0008  lwz r29, 8(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825EBF70: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825EBF74: 419A000C  beq cr6, 0x825ebf80
	if ctx.cr[6].eq {
	pc = 0x825EBF80; continue 'dispatch;
	}
	// 825EBF78: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825EBF7C: 488E2885  bl 0x82ece800
	ctx.lr = 0x825EBF80;
	sub_82ECE800(ctx, base);
	// 825EBF80: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825EBF84: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EBF88: 419A0008  beq cr6, 0x825ebf90
	if ctx.cr[6].eq {
	pc = 0x825EBF90; continue 'dispatch;
	}
	// 825EBF8C: 4BCD4905  bl 0x822c0890
	ctx.lr = 0x825EBF90;
	sub_822C0890(ctx, base);
	// 825EBF90: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EBF94: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825EBF98: 481CA641  bl 0x827b65d8
	ctx.lr = 0x825EBF9C;
	sub_827B65D8(ctx, base);
	// 825EBF9C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EBFA0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825EBFA4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825EBFA8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825EBFAC: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825EBFB0: 488DFBE1  bl 0x82ecbb90
	ctx.lr = 0x825EBFB4;
	sub_82ECBB90(ctx, base);
	// 825EBFB4: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825EBFB8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EBFBC: 419A0008  beq cr6, 0x825ebfc4
	if ctx.cr[6].eq {
	pc = 0x825EBFC4; continue 'dispatch;
	}
	// 825EBFC0: 4BCD48D1  bl 0x822c0890
	ctx.lr = 0x825EBFC4;
	sub_822C0890(ctx, base);
	// 825EBFC4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EBFC8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825EBFCC: 481CA60D  bl 0x827b65d8
	ctx.lr = 0x825EBFD0;
	sub_827B65D8(ctx, base);
	// 825EBFD0: C03E006C  lfs f1, 0x6c(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(108 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825EBFD4: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EBFD8: 4BD01B81  bl 0x822edb58
	ctx.lr = 0x825EBFDC;
	sub_822EDB58(ctx, base);
	// 825EBFDC: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825EBFE0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EBFE4: 419A0008  beq cr6, 0x825ebfec
	if ctx.cr[6].eq {
	pc = 0x825EBFEC; continue 'dispatch;
	}
	// 825EBFE8: 4BCD48A9  bl 0x822c0890
	ctx.lr = 0x825EBFEC;
	sub_822C0890(ctx, base);
	// 825EBFEC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825EBFF0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825EBFF4: 917F0250  stw r11, 0x250(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(592 as u32), ctx.r[11].u32 ) };
	// 825EBFF8: 419A000C  beq cr6, 0x825ec004
	if ctx.cr[6].eq {
	pc = 0x825EC004; continue 'dispatch;
	}
	// 825EBFFC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825EC000: 488E1009  bl 0x82ecd008
	ctx.lr = 0x825EC004;
	sub_82ECD008(ctx, base);
	// 825EC004: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825EC008: 48BBC1B4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EC010(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825EC010 size=128
    let mut pc: u32 = 0x825EC010;
    'dispatch: loop {
        match pc {
            0x825EC010 => {
    //   block [0x825EC010..0x825EC090)
	// 825EC010: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EC014: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825EC018: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825EC01C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EC020: 48B685E1  bl 0x83154600
	ctx.lr = 0x825EC024;
	sub_83154600(ctx, base);
	// 825EC024: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825EC028: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825EC02C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EC030: 481CA5A9  bl 0x827b65d8
	ctx.lr = 0x825EC034;
	sub_827B65D8(ctx, base);
	// 825EC034: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825EC038: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EC03C: 808B6830  lwz r4, 0x6830(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26672 as u32) ) } as u64;
	// 825EC040: 4BEA3361  bl 0x8248f3a0
	ctx.lr = 0x825EC044;
	sub_8248F3A0(ctx, base);
	// 825EC044: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825EC048: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EC04C: 419A0008  beq cr6, 0x825ec054
	if ctx.cr[6].eq {
	pc = 0x825EC054; continue 'dispatch;
	}
	// 825EC050: 4BCD4841  bl 0x822c0890
	ctx.lr = 0x825EC054;
	sub_822C0890(ctx, base);
	// 825EC054: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EC058: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825EC05C: 481CA57D  bl 0x827b65d8
	ctx.lr = 0x825EC060;
	sub_827B65D8(ctx, base);
	// 825EC060: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 825EC064: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EC068: 4BD019D1  bl 0x822eda38
	ctx.lr = 0x825EC06C;
	sub_822EDA38(ctx, base);
	// 825EC06C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825EC070: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EC074: 419A0008  beq cr6, 0x825ec07c
	if ctx.cr[6].eq {
	pc = 0x825EC07C; continue 'dispatch;
	}
	// 825EC078: 4BCD4819  bl 0x822c0890
	ctx.lr = 0x825EC07C;
	sub_822C0890(ctx, base);
	// 825EC07C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825EC080: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825EC084: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825EC088: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825EC08C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EC090(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825EC090 size=220
    let mut pc: u32 = 0x825EC090;
    'dispatch: loop {
        match pc {
            0x825EC090 => {
    //   block [0x825EC090..0x825EC16C)
	// 825EC090: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EC094: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825EC098: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825EC09C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825EC0A0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EC0A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825EC0A8: 48B68559  bl 0x83154600
	ctx.lr = 0x825EC0AC;
	sub_83154600(ctx, base);
	// 825EC0AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825EC0B0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825EC0B4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825EC0B8: 481CA521  bl 0x827b65d8
	ctx.lr = 0x825EC0BC;
	sub_827B65D8(ctx, base);
	// 825EC0BC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825EC0C0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825EC0C4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EC0C8: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EC0CC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825EC0D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825EC0D4: 4E800421  bctrl
	ctx.lr = 0x825EC0D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825EC0D8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825EC0DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EC0E0: 419A0008  beq cr6, 0x825ec0e8
	if ctx.cr[6].eq {
	pc = 0x825EC0E8; continue 'dispatch;
	}
	// 825EC0E4: 4BCD47AD  bl 0x822c0890
	ctx.lr = 0x825EC0E8;
	sub_822C0890(ctx, base);
	// 825EC0E8: 39600100  li r11, 0x100
	ctx.r[11].s64 = 256;
	// 825EC0EC: C1A10074  lfs f13, 0x74(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825EC0F0: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 825EC0F4: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 825EC0F8: 13FE58C7  vcmpequd (lvx128) v31, v30, v11
	tmp.u32 = ctx.r[30].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EC170(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825EC170 size=228
    let mut pc: u32 = 0x825EC170;
    'dispatch: loop {
        match pc {
            0x825EC170 => {
    //   block [0x825EC170..0x825EC254)
	// 825EC170: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EC174: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825EC178: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825EC17C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825EC180: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EC184: 48B6847D  bl 0x83154600
	ctx.lr = 0x825EC188;
	sub_83154600(ctx, base);
	// 825EC188: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825EC18C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825EC190: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EC194: 481CA445  bl 0x827b65d8
	ctx.lr = 0x825EC198;
	sub_827B65D8(ctx, base);
	// 825EC198: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EC19C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825EC1A0: 83CB0008  lwz r30, 8(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825EC1A4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825EC1A8: 419A000C  beq cr6, 0x825ec1b4
	if ctx.cr[6].eq {
	pc = 0x825EC1B4; continue 'dispatch;
	}
	// 825EC1AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EC1B0: 488E2651  bl 0x82ece800
	ctx.lr = 0x825EC1B4;
	sub_82ECE800(ctx, base);
	// 825EC1B4: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825EC1B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EC1BC: 419A0008  beq cr6, 0x825ec1c4
	if ctx.cr[6].eq {
	pc = 0x825EC1C4; continue 'dispatch;
	}
	// 825EC1C0: 4BCD46D1  bl 0x822c0890
	ctx.lr = 0x825EC1C4;
	sub_822C0890(ctx, base);
	// 825EC1C4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EC1C8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825EC1CC: 481CA40D  bl 0x827b65d8
	ctx.lr = 0x825EC1D0;
	sub_827B65D8(ctx, base);
	// 825EC1D0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825EC1D4: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EC1D8: 808B682C  lwz r4, 0x682c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26668 as u32) ) } as u64;
	// 825EC1DC: 4BEA31C5  bl 0x8248f3a0
	ctx.lr = 0x825EC1E0;
	sub_8248F3A0(ctx, base);
	// 825EC1E0: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825EC1E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EC1E8: 419A0008  beq cr6, 0x825ec1f0
	if ctx.cr[6].eq {
	pc = 0x825EC1F0; continue 'dispatch;
	}
	// 825EC1EC: 4BCD46A5  bl 0x822c0890
	ctx.lr = 0x825EC1F0;
	sub_822C0890(ctx, base);
	// 825EC1F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EC1F4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825EC1F8: 481CA3E1  bl 0x827b65d8
	ctx.lr = 0x825EC1FC;
	sub_827B65D8(ctx, base);
	// 825EC1FC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EC200: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825EC204: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825EC208: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 825EC20C: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825EC210: 488DF981  bl 0x82ecbb90
	ctx.lr = 0x825EC214;
	sub_82ECBB90(ctx, base);
	// 825EC214: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825EC218: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EC21C: 419A0008  beq cr6, 0x825ec224
	if ctx.cr[6].eq {
	pc = 0x825EC224; continue 'dispatch;
	}
	// 825EC220: 4BCD4671  bl 0x822c0890
	ctx.lr = 0x825EC224;
	sub_822C0890(ctx, base);
	// 825EC224: 807F026C  lwz r3, 0x26c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(620 as u32) ) } as u64;
	// 825EC228: 4BE403D1  bl 0x8242c5f8
	ctx.lr = 0x825EC22C;
	sub_8242C5F8(ctx, base);
	// 825EC22C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825EC230: 419A000C  beq cr6, 0x825ec23c
	if ctx.cr[6].eq {
	pc = 0x825EC23C; continue 'dispatch;
	}
	// 825EC234: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EC238: 488E0DD1  bl 0x82ecd008
	ctx.lr = 0x825EC23C;
	sub_82ECD008(ctx, base);
	// 825EC23C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825EC240: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825EC244: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825EC248: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825EC24C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825EC250: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EC258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825EC258 size=272
    let mut pc: u32 = 0x825EC258;
    'dispatch: loop {
        match pc {
            0x825EC258 => {
    //   block [0x825EC258..0x825EC368)
	// 825EC258: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EC25C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825EC260: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825EC264: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825EC268: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EC26C: 48B68395  bl 0x83154600
	ctx.lr = 0x825EC270;
	sub_83154600(ctx, base);
	// 825EC270: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825EC274: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825EC278: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EC27C: 481CA35D  bl 0x827b65d8
	ctx.lr = 0x825EC280;
	sub_827B65D8(ctx, base);
	// 825EC280: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EC284: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825EC288: 83CB0008  lwz r30, 8(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825EC28C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825EC290: 419A000C  beq cr6, 0x825ec29c
	if ctx.cr[6].eq {
	pc = 0x825EC29C; continue 'dispatch;
	}
	// 825EC294: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EC298: 488E2569  bl 0x82ece800
	ctx.lr = 0x825EC29C;
	sub_82ECE800(ctx, base);
	// 825EC29C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825EC2A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EC2A4: 419A0008  beq cr6, 0x825ec2ac
	if ctx.cr[6].eq {
	pc = 0x825EC2AC; continue 'dispatch;
	}
	// 825EC2A8: 4BCD45E9  bl 0x822c0890
	ctx.lr = 0x825EC2AC;
	sub_822C0890(ctx, base);
	// 825EC2AC: 807F026C  lwz r3, 0x26c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(620 as u32) ) } as u64;
	// 825EC2B0: 4BE40751  bl 0x8242ca00
	ctx.lr = 0x825EC2B4;
	sub_8242CA00(ctx, base);
	// 825EC2B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EC2B8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825EC2BC: 481CA31D  bl 0x827b65d8
	ctx.lr = 0x825EC2C0;
	sub_827B65D8(ctx, base);
	// 825EC2C0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825EC2C4: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EC2C8: 808B6830  lwz r4, 0x6830(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26672 as u32) ) } as u64;
	// 825EC2CC: 4BEA30D5  bl 0x8248f3a0
	ctx.lr = 0x825EC2D0;
	sub_8248F3A0(ctx, base);
	// 825EC2D0: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825EC2D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EC2D8: 419A0008  beq cr6, 0x825ec2e0
	if ctx.cr[6].eq {
	pc = 0x825EC2E0; continue 'dispatch;
	}
	// 825EC2DC: 4BCD45B5  bl 0x822c0890
	ctx.lr = 0x825EC2E0;
	sub_822C0890(ctx, base);
	// 825EC2E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EC2E4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825EC2E8: 481CA2F1  bl 0x827b65d8
	ctx.lr = 0x825EC2EC;
	sub_827B65D8(ctx, base);
	// 825EC2EC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EC2F0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825EC2F4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825EC2F8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825EC2FC: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825EC300: 488DF891  bl 0x82ecbb90
	ctx.lr = 0x825EC304;
	sub_82ECBB90(ctx, base);
	// 825EC304: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825EC308: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EC30C: 419A0008  beq cr6, 0x825ec314
	if ctx.cr[6].eq {
	pc = 0x825EC314; continue 'dispatch;
	}
	// 825EC310: 4BCD4581  bl 0x822c0890
	ctx.lr = 0x825EC314;
	sub_822C0890(ctx, base);
	// 825EC314: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EC318: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825EC31C: 481CA2BD  bl 0x827b65d8
	ctx.lr = 0x825EC320;
	sub_827B65D8(ctx, base);
	// 825EC320: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 825EC324: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EC328: 388B6910  addi r4, r11, 0x6910
	ctx.r[4].s64 = ctx.r[11].s64 + 26896;
	// 825EC32C: 4BD00E25  bl 0x822ed150
	ctx.lr = 0x825EC330;
	sub_822ED150(ctx, base);
	// 825EC330: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 825EC334: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EC338: 419A0008  beq cr6, 0x825ec340
	if ctx.cr[6].eq {
	pc = 0x825EC340; continue 'dispatch;
	}
	// 825EC33C: 4BCD4555  bl 0x822c0890
	ctx.lr = 0x825EC340;
	sub_822C0890(ctx, base);
	// 825EC340: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825EC344: 419A000C  beq cr6, 0x825ec350
	if ctx.cr[6].eq {
	pc = 0x825EC350; continue 'dispatch;
	}
	// 825EC348: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EC34C: 488E0CBD  bl 0x82ecd008
	ctx.lr = 0x825EC350;
	sub_82ECD008(ctx, base);
	// 825EC350: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825EC354: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825EC358: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825EC35C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825EC360: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825EC364: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EC368(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825EC368 size=184
    let mut pc: u32 = 0x825EC368;
    'dispatch: loop {
        match pc {
            0x825EC368 => {
    //   block [0x825EC368..0x825EC420)
	// 825EC368: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EC36C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825EC370: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825EC374: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825EC378: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EC37C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825EC380: 48B68281  bl 0x83154600
	ctx.lr = 0x825EC384;
	sub_83154600(ctx, base);
	// 825EC384: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825EC388: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825EC38C: 4886D3DD  bl 0x82e59768
	ctx.lr = 0x825EC390;
	sub_82E59768(ctx, base);
	// 825EC390: C01F0060  lfs f0, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825EC394: C1A30000  lfs f13, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825EC398: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825EC39C: EDAD002A  fadds f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 825EC3A0: D1BF0060  stfs f13, 0x60(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 825EC3A4: C00B9450  lfs f0, -0x6bb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825EC3A8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 825EC3AC: 4099005C  ble cr6, 0x825ec408
	if !ctx.cr[6].gt {
	pc = 0x825EC408; continue 'dispatch;
	}
	// 825EC3B0: 897E029C  lbz r11, 0x29c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(668 as u32) ) } as u64;
	// 825EC3B4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825EC3B8: 41820048  beq 0x825ec400
	if ctx.cr[0].eq {
	pc = 0x825EC400; continue 'dispatch;
	}
	// 825EC3BC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825EC3C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825EC3C4: 388B0378  addi r4, r11, 0x378
	ctx.r[4].s64 = ctx.r[11].s64 + 888;
	// 825EC3C8: 48807641  bl 0x82df3a08
	ctx.lr = 0x825EC3CC;
	sub_82DF3A08(ctx, base);
	// 825EC3CC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825EC3D0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825EC3D4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EC3D8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825EC3DC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825EC3E0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825EC3E4: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825EC3E8: 488726A9  bl 0x82e5ea90
	ctx.lr = 0x825EC3EC;
	sub_82E5EA90(ctx, base);
	// 825EC3EC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825EC3F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EC3F4: 419A0014  beq cr6, 0x825ec408
	if ctx.cr[6].eq {
	pc = 0x825EC408; continue 'dispatch;
	}
	// 825EC3F8: 4BCD4499  bl 0x822c0890
	ctx.lr = 0x825EC3FC;
	sub_822C0890(ctx, base);
	// 825EC3FC: 4800000C  b 0x825ec408
	pc = 0x825EC408; continue 'dispatch;
	// 825EC400: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EC404: 4BF241CD  bl 0x825105d0
	ctx.lr = 0x825EC408;
	sub_825105D0(ctx, base);
	// 825EC408: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825EC40C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825EC410: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825EC414: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825EC418: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825EC41C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EC420(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825EC420 size=232
    let mut pc: u32 = 0x825EC420;
    'dispatch: loop {
        match pc {
            0x825EC420 => {
    //   block [0x825EC420..0x825EC508)
	// 825EC420: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EC424: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825EC428: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825EC42C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825EC430: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EC434: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825EC438: 48B681C9  bl 0x83154600
	ctx.lr = 0x825EC43C;
	sub_83154600(ctx, base);
	// 825EC43C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825EC440: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825EC444: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EC448: 481CA191  bl 0x827b65d8
	ctx.lr = 0x825EC44C;
	sub_827B65D8(ctx, base);
	// 825EC44C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825EC450: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EC454: 808B666C  lwz r4, 0x666c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26220 as u32) ) } as u64;
	// 825EC458: 4BEA2F49  bl 0x8248f3a0
	ctx.lr = 0x825EC45C;
	sub_8248F3A0(ctx, base);
	// 825EC45C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825EC460: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EC464: 419A0008  beq cr6, 0x825ec46c
	if ctx.cr[6].eq {
	pc = 0x825EC46C; continue 'dispatch;
	}
	// 825EC468: 4BCD4429  bl 0x822c0890
	ctx.lr = 0x825EC46C;
	sub_822C0890(ctx, base);
	// 825EC46C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EC470: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825EC474: 481CA165  bl 0x827b65d8
	ctx.lr = 0x825EC478;
	sub_827B65D8(ctx, base);
	// 825EC478: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825EC47C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EC480: 4BD015B9  bl 0x822eda38
	ctx.lr = 0x825EC484;
	sub_822EDA38(ctx, base);
	// 825EC484: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825EC488: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EC48C: 419A0008  beq cr6, 0x825ec494
	if ctx.cr[6].eq {
	pc = 0x825EC494; continue 'dispatch;
	}
	// 825EC490: 4BCD4401  bl 0x822c0890
	ctx.lr = 0x825EC494;
	sub_822C0890(ctx, base);
	// 825EC494: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EC498: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825EC49C: 481CA13D  bl 0x827b65d8
	ctx.lr = 0x825EC4A0;
	sub_827B65D8(ctx, base);
	// 825EC4A0: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EC4A4: 4BD00C4D  bl 0x822ed0f0
	ctx.lr = 0x825EC4A8;
	sub_822ED0F0(ctx, base);
	// 825EC4A8: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825EC4AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EC4B0: 419A0008  beq cr6, 0x825ec4b8
	if ctx.cr[6].eq {
	pc = 0x825EC4B8; continue 'dispatch;
	}
	// 825EC4B4: 4BCD43DD  bl 0x822c0890
	ctx.lr = 0x825EC4B8;
	sub_822C0890(ctx, base);
	// 825EC4B8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825EC4BC: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 825EC4C0: 38BF00C8  addi r5, r31, 0xc8
	ctx.r[5].s64 = ctx.r[31].s64 + 200;
	// 825EC4C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825EC4C8: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 825EC4CC: 4BF23D25  bl 0x825101f0
	ctx.lr = 0x825EC4D0;
	sub_825101F0(ctx, base);
	// 825EC4D0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825EC4D4: 807F0284  lwz r3, 0x284(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(644 as u32) ) } as u64;
	// 825EC4D8: 4BFC9AD9  bl 0x825b5fb0
	ctx.lr = 0x825EC4DC;
	sub_825B5FB0(ctx, base);
	// 825EC4DC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825EC4E0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825EC4E4: 995E0064  stb r10, 0x64(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(100 as u32), ctx.r[10].u8 ) };
	// 825EC4E8: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825EC4EC: D01E0060  stfs f0, 0x60(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 825EC4F0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825EC4F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825EC4F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825EC4FC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825EC500: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825EC504: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EC508(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825EC508 size=476
    let mut pc: u32 = 0x825EC508;
    'dispatch: loop {
        match pc {
            0x825EC508 => {
    //   block [0x825EC508..0x825EC6E4)
	// 825EC508: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EC50C: 48BBBC59  bl 0x831a8164
	ctx.lr = 0x825EC510;
	sub_831A8130(ctx, base);
	// 825EC510: 9421FE50  stwu r1, -0x1b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-432 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EC514: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825EC518: 48B680E9  bl 0x83154600
	ctx.lr = 0x825EC51C;
	sub_83154600(ctx, base);
	// 825EC51C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825EC520: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825EC524: 4886D245  bl 0x82e59768
	ctx.lr = 0x825EC528;
	sub_82E59768(ctx, base);
	// 825EC528: C01D0060  lfs f0, 0x60(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825EC52C: C1A30000  lfs f13, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825EC530: 897D0064  lbz r11, 0x64(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(100 as u32) ) } as u64;
	// 825EC534: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 825EC538: D01D0060  stfs f0, 0x60(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 825EC53C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825EC540: 41820140  beq 0x825ec680
	if ctx.cr[0].eq {
	pc = 0x825EC680; continue 'dispatch;
	}
	// 825EC544: 39600100  li r11, 0x100
	ctx.r[11].s64 = 256;
	// 825EC548: 394100A0  addi r10, r1, 0xa0
	ctx.r[10].s64 = ctx.r[1].s64 + 160;
	// 825EC54C: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 825EC550: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825EC554: 38890388  addi r4, r9, 0x388
	ctx.r[4].s64 = ctx.r[9].s64 + 904;
	// 825EC558: 13FF58C7  vcmpequd (lvx128) v31, v31, v11
	tmp.u32 = ctx.r[31].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EC6E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825EC6E8 size=124
    let mut pc: u32 = 0x825EC6E8;
    'dispatch: loop {
        match pc {
            0x825EC6E8 => {
    //   block [0x825EC6E8..0x825EC764)
	// 825EC6E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EC6EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825EC6F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825EC6F4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EC6F8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825EC6FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825EC700: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825EC704: 388B039C  addi r4, r11, 0x39c
	ctx.r[4].s64 = ctx.r[11].s64 + 924;
	// 825EC708: 48807301  bl 0x82df3a08
	ctx.lr = 0x825EC70C;
	sub_82DF3A08(ctx, base);
	// 825EC70C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825EC710: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825EC714: 389F0164  addi r4, r31, 0x164
	ctx.r[4].s64 = ctx.r[31].s64 + 356;
	// 825EC718: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825EC71C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825EC720: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825EC724: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825EC728: 48872239  bl 0x82e5e960
	ctx.lr = 0x825EC72C;
	sub_82E5E960(ctx, base);
	// 825EC72C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825EC730: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EC734: 419A0008  beq cr6, 0x825ec73c
	if ctx.cr[6].eq {
	pc = 0x825EC73C; continue 'dispatch;
	}
	// 825EC738: 4BCD4159  bl 0x822c0890
	ctx.lr = 0x825EC73C;
	sub_822C0890(ctx, base);
	// 825EC73C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825EC740: 807F0284  lwz r3, 0x284(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(644 as u32) ) } as u64;
	// 825EC744: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825EC748: 997F02A4  stb r11, 0x2a4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(676 as u32), ctx.r[11].u8 ) };
	// 825EC74C: 4BFC9865  bl 0x825b5fb0
	ctx.lr = 0x825EC750;
	sub_825B5FB0(ctx, base);
	// 825EC750: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825EC754: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825EC758: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825EC75C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825EC760: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EC768(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825EC768 size=124
    let mut pc: u32 = 0x825EC768;
    'dispatch: loop {
        match pc {
            0x825EC768 => {
    //   block [0x825EC768..0x825EC7E4)
	// 825EC768: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EC76C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825EC770: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825EC774: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EC778: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825EC77C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825EC780: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825EC784: 388B0380  addi r4, r11, 0x380
	ctx.r[4].s64 = ctx.r[11].s64 + 896;
	// 825EC788: 48807281  bl 0x82df3a08
	ctx.lr = 0x825EC78C;
	sub_82DF3A08(ctx, base);
	// 825EC78C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825EC790: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825EC794: 389F0164  addi r4, r31, 0x164
	ctx.r[4].s64 = ctx.r[31].s64 + 356;
	// 825EC798: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825EC79C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825EC7A0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825EC7A4: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825EC7A8: 488721B9  bl 0x82e5e960
	ctx.lr = 0x825EC7AC;
	sub_82E5E960(ctx, base);
	// 825EC7AC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825EC7B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EC7B4: 419A0008  beq cr6, 0x825ec7bc
	if ctx.cr[6].eq {
	pc = 0x825EC7BC; continue 'dispatch;
	}
	// 825EC7B8: 4BCD40D9  bl 0x822c0890
	ctx.lr = 0x825EC7BC;
	sub_822C0890(ctx, base);
	// 825EC7BC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825EC7C0: 807F0284  lwz r3, 0x284(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(644 as u32) ) } as u64;
	// 825EC7C4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825EC7C8: 997F02A4  stb r11, 0x2a4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(676 as u32), ctx.r[11].u8 ) };
	// 825EC7CC: 4BFC97E5  bl 0x825b5fb0
	ctx.lr = 0x825EC7D0;
	sub_825B5FB0(ctx, base);
	// 825EC7D0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825EC7D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825EC7D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825EC7DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825EC7E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EC7E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825EC7E8 size=512
    let mut pc: u32 = 0x825EC7E8;
    'dispatch: loop {
        match pc {
            0x825EC7E8 => {
    //   block [0x825EC7E8..0x825EC9E8)
	// 825EC7E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EC7EC: 48BBB979  bl 0x831a8164
	ctx.lr = 0x825EC7F0;
	sub_831A8130(ctx, base);
	// 825EC7F0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EC7F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825EC7F8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825EC7FC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825EC800: 807F0284  lwz r3, 0x284(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(644 as u32) ) } as u64;
	// 825EC804: 4BFC97AD  bl 0x825b5fb0
	ctx.lr = 0x825EC808;
	sub_825B5FB0(ctx, base);
	// 825EC808: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825EC80C: 389F0210  addi r4, r31, 0x210
	ctx.r[4].s64 = ctx.r[31].s64 + 528;
	// 825EC810: 9BBF02A4  stb r29, 0x2a4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(676 as u32), ctx.r[29].u8 ) };
	// 825EC814: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825EC818: 4BF26D61  bl 0x82513578
	ctx.lr = 0x825EC81C;
	sub_82513578(ctx, base);
	// 825EC81C: 817F0240  lwz r11, 0x240(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(576 as u32) ) } as u64;
	// 825EC820: 3B9E0030  addi r28, r30, 0x30
	ctx.r[28].s64 = ctx.r[30].s64 + 48;
	// 825EC824: 3B7E0040  addi r27, r30, 0x40
	ctx.r[27].s64 = ctx.r[30].s64 + 64;
	// 825EC828: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 825EC82C: 93AB0068  stw r29, 0x68(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 825EC830: 93AB00D0  stw r29, 0xd0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(208 as u32), ctx.r[29].u32 ) };
	// 825EC834: C01F0210  lfs f0, 0x210(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(528 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825EC838: 817F0240  lwz r11, 0x240(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(576 as u32) ) } as u64;
	// 825EC83C: 394B0068  addi r10, r11, 0x68
	ctx.r[10].s64 = ctx.r[11].s64 + 104;
	// 825EC840: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EC844: 39280015  addi r9, r8, 0x15
	ctx.r[9].s64 = ctx.r[8].s64 + 21;
	// 825EC848: 5528103A  slwi r8, r9, 2
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825EC84C: 392B00D0  addi r9, r11, 0xd0
	ctx.r[9].s64 = ctx.r[11].s64 + 208;
	// 825EC850: 7C085D2E  stfsx f0, r8, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 825EC854: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EC858: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 825EC85C: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825EC860: C01F0214  lfs f0, 0x214(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(532 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825EC864: 810B0068  lwz r8, 0x68(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 825EC868: 39080015  addi r8, r8, 0x15
	ctx.r[8].s64 = ctx.r[8].s64 + 21;
	// 825EC86C: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825EC870: 7C08552E  stfsx f0, r8, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32), tmp.u32) };
	// 825EC874: 814B0068  lwz r10, 0x68(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 825EC878: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825EC87C: 914B0068  stw r10, 0x68(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 825EC880: C01F0218  lfs f0, 0x218(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(536 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825EC884: 814B00D0  lwz r10, 0xd0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(208 as u32) ) } as u64;
	// 825EC888: 394A0015  addi r10, r10, 0x15
	ctx.r[10].s64 = ctx.r[10].s64 + 21;
	// 825EC88C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825EC890: 7C0A4D2E  stfsx f0, r10, r9
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), tmp.u32) };
	// 825EC894: 814B00D0  lwz r10, 0xd0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(208 as u32) ) } as u64;
	// 825EC898: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825EC89C: 914B00D0  stw r10, 0xd0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(208 as u32), ctx.r[10].u32 ) };
	// 825EC8A0: C01E0030  lfs f0, 0x30(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825EC8A4: 817F0240  lwz r11, 0x240(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(576 as u32) ) } as u64;
	// 825EC8A8: 394B0068  addi r10, r11, 0x68
	ctx.r[10].s64 = ctx.r[11].s64 + 104;
	// 825EC8AC: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EC8B0: 39280015  addi r9, r8, 0x15
	ctx.r[9].s64 = ctx.r[8].s64 + 21;
	// 825EC8B4: 5528103A  slwi r8, r9, 2
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825EC8B8: 392B00D0  addi r9, r11, 0xd0
	ctx.r[9].s64 = ctx.r[11].s64 + 208;
	// 825EC8BC: 7C085D2E  stfsx f0, r8, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 825EC8C0: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EC8C4: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 825EC8C8: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825EC8CC: C01E0034  lfs f0, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825EC8D0: 810B0068  lwz r8, 0x68(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 825EC8D4: 39080015  addi r8, r8, 0x15
	ctx.r[8].s64 = ctx.r[8].s64 + 21;
	// 825EC8D8: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825EC8DC: 7C08552E  stfsx f0, r8, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32), tmp.u32) };
	// 825EC8E0: 814B0068  lwz r10, 0x68(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 825EC8E4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825EC8E8: 914B0068  stw r10, 0x68(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 825EC8EC: C01E0038  lfs f0, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825EC8F0: 814B00D0  lwz r10, 0xd0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(208 as u32) ) } as u64;
	// 825EC8F4: 394A0015  addi r10, r10, 0x15
	ctx.r[10].s64 = ctx.r[10].s64 + 21;
	// 825EC8F8: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825EC8FC: 7C0A4D2E  stfsx f0, r10, r9
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), tmp.u32) };
	// 825EC900: 814B00D0  lwz r10, 0xd0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(208 as u32) ) } as u64;
	// 825EC904: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825EC908: 914B00D0  stw r10, 0xd0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(208 as u32), ctx.r[10].u32 ) };
	// 825EC90C: C01E0040  lfs f0, 0x40(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825EC910: 817F0240  lwz r11, 0x240(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(576 as u32) ) } as u64;
	// 825EC914: 392B00D0  addi r9, r11, 0xd0
	ctx.r[9].s64 = ctx.r[11].s64 + 208;
	// 825EC918: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EC91C: 394A0015  addi r10, r10, 0x15
	ctx.r[10].s64 = ctx.r[10].s64 + 21;
	// 825EC920: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825EC924: 394B0068  addi r10, r11, 0x68
	ctx.r[10].s64 = ctx.r[11].s64 + 104;
	// 825EC928: 7C085D2E  stfsx f0, r8, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 825EC92C: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EC930: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 825EC934: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825EC938: 810B0068  lwz r8, 0x68(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 825EC93C: C01E0044  lfs f0, 0x44(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(68 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825EC940: 39080015  addi r8, r8, 0x15
	ctx.r[8].s64 = ctx.r[8].s64 + 21;
	// 825EC944: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825EC948: 7C08552E  stfsx f0, r8, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32), tmp.u32) };
	// 825EC94C: 814B0068  lwz r10, 0x68(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 825EC950: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825EC954: 914B0068  stw r10, 0x68(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 825EC958: C01E0048  lfs f0, 0x48(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825EC95C: 814B00D0  lwz r10, 0xd0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(208 as u32) ) } as u64;
	// 825EC960: 394A0015  addi r10, r10, 0x15
	ctx.r[10].s64 = ctx.r[10].s64 + 21;
	// 825EC964: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825EC968: 7C0A4D2E  stfsx f0, r10, r9
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), tmp.u32) };
	// 825EC96C: 814B00D0  lwz r10, 0xd0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(208 as u32) ) } as u64;
	// 825EC970: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825EC974: 914B00D0  stw r10, 0xd0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(208 as u32), ctx.r[10].u32 ) };
	// 825EC978: 807F0240  lwz r3, 0x240(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(576 as u32) ) } as u64;
	// 825EC97C: 4BE28995  bl 0x82415310
	ctx.lr = 0x825EC980;
	sub_82415310(ctx, base);
	// 825EC980: C01E0050  lfs f0, 0x50(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825EC984: D01F025C  stfs f0, 0x25c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(604 as u32), tmp.u32 ) };
	// 825EC988: 39600220  li r11, 0x220
	ctx.r[11].s64 = 544;
	// 825EC98C: 13E0E0C7  vcmpequd (lvx128) v31, v0, v28
	tmp.u32 = ctx.r[28].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 825EC990: 39400230  li r10, 0x230
	ctx.r[10].s64 = 560;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EC9E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825EC9E8 size=168
    let mut pc: u32 = 0x825EC9E8;
    'dispatch: loop {
        match pc {
            0x825EC9E8 => {
    //   block [0x825EC9E8..0x825ECA90)
	// 825EC9E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EC9EC: 48BBB781  bl 0x831a816c
	ctx.lr = 0x825EC9F0;
	sub_831A8130(ctx, base);
	// 825EC9F0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EC9F4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825EC9F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825EC9FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825ECA00: 388B0378  addi r4, r11, 0x378
	ctx.r[4].s64 = ctx.r[11].s64 + 888;
	// 825ECA04: 48807005  bl 0x82df3a08
	ctx.lr = 0x825ECA08;
	sub_82DF3A08(ctx, base);
	// 825ECA08: 3BDF0164  addi r30, r31, 0x164
	ctx.r[30].s64 = ctx.r[31].s64 + 356;
	// 825ECA0C: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 825ECA10: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825ECA14: 4886DCBD  bl 0x82e5a6d0
	ctx.lr = 0x825ECA18;
	sub_82E5A6D0(ctx, base);
	// 825ECA18: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825ECA1C: 488068ED  bl 0x82df3308
	ctx.lr = 0x825ECA20;
	sub_82DF3308(ctx, base);
	// 825ECA20: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825ECA24: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825ECA28: 48806A01  bl 0x82df3428
	ctx.lr = 0x825ECA2C;
	sub_82DF3428(ctx, base);
	// 825ECA2C: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825ECA30: 40820058  bne 0x825eca88
	if !ctx.cr[0].eq {
	pc = 0x825ECA88; continue 'dispatch;
	}
	// 825ECA34: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825ECA38: 807F0284  lwz r3, 0x284(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(644 as u32) ) } as u64;
	// 825ECA3C: 4BFC9575  bl 0x825b5fb0
	ctx.lr = 0x825ECA40;
	sub_825B5FB0(ctx, base);
	// 825ECA40: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825ECA44: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825ECA48: 997F02A4  stb r11, 0x2a4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(676 as u32), ctx.r[11].u8 ) };
	// 825ECA4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825ECA50: 388A0380  addi r4, r10, 0x380
	ctx.r[4].s64 = ctx.r[10].s64 + 896;
	// 825ECA54: 48806FB5  bl 0x82df3a08
	ctx.lr = 0x825ECA58;
	sub_82DF3A08(ctx, base);
	// 825ECA58: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825ECA5C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825ECA60: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825ECA64: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825ECA68: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825ECA6C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825ECA70: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825ECA74: 48871EED  bl 0x82e5e960
	ctx.lr = 0x825ECA78;
	sub_82E5E960(ctx, base);
	// 825ECA78: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825ECA7C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825ECA80: 419A0008  beq cr6, 0x825eca88
	if ctx.cr[6].eq {
	pc = 0x825ECA88; continue 'dispatch;
	}
	// 825ECA84: 4BCD3E0D  bl 0x822c0890
	ctx.lr = 0x825ECA88;
	sub_822C0890(ctx, base);
	// 825ECA88: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825ECA8C: 48BBB730  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825ECA90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825ECA90 size=76
    let mut pc: u32 = 0x825ECA90;
    'dispatch: loop {
        match pc {
            0x825ECA90 => {
    //   block [0x825ECA90..0x825ECADC)
	// 825ECA90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825ECA94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825ECA98: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825ECA9C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825ECAA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825ECAA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825ECAA8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825ECAAC: 4BFFEFBD  bl 0x825eba68
	ctx.lr = 0x825ECAB0;
	sub_825EBA68(ctx, base);
	// 825ECAB0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825ECAB4: 4182000C  beq 0x825ecac0
	if ctx.cr[0].eq {
	pc = 0x825ECAC0; continue 'dispatch;
	}
	// 825ECAB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825ECABC: 4880591D  bl 0x82df23d8
	ctx.lr = 0x825ECAC0;
	sub_82DF23D8(ctx, base);
	// 825ECAC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825ECAC4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825ECAC8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825ECACC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825ECAD0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825ECAD4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825ECAD8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825ECAE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825ECAE0 size=112
    let mut pc: u32 = 0x825ECAE0;
    'dispatch: loop {
        match pc {
            0x825ECAE0 => {
    //   block [0x825ECAE0..0x825ECB50)
	// 825ECAE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825ECAE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825ECAE8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825ECAEC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825ECAF0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825ECAF4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825ECAF8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825ECAFC: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 825ECB00: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825ECB04: 4BFFE9ED  bl 0x825eb4f0
	ctx.lr = 0x825ECB08;
	sub_825EB4F0(ctx, base);
	// 825ECB08: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825ECB0C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825ECB10: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825ECB14: 4BCD34ED  bl 0x822c0000
	ctx.lr = 0x825ECB18;
	sub_822C0000(ctx, base);
	// 825ECB18: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825ECB1C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825ECB20: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825ECB24: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825ECB28: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825ECB2C: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825ECB30: 419A0008  beq cr6, 0x825ecb38
	if ctx.cr[6].eq {
	pc = 0x825ECB38; continue 'dispatch;
	}
	// 825ECB34: 4BCD3D5D  bl 0x822c0890
	ctx.lr = 0x825ECB38;
	sub_822C0890(ctx, base);
	// 825ECB38: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825ECB3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825ECB40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825ECB44: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825ECB48: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825ECB4C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825ECB50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825ECB50 size=112
    let mut pc: u32 = 0x825ECB50;
    'dispatch: loop {
        match pc {
            0x825ECB50 => {
    //   block [0x825ECB50..0x825ECBC0)
	// 825ECB50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825ECB54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825ECB58: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825ECB5C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825ECB60: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825ECB64: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825ECB68: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825ECB6C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 825ECB70: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825ECB74: 4BFFEA45  bl 0x825eb5b8
	ctx.lr = 0x825ECB78;
	sub_825EB5B8(ctx, base);
	// 825ECB78: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825ECB7C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825ECB80: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825ECB84: 4BCD347D  bl 0x822c0000
	ctx.lr = 0x825ECB88;
	sub_822C0000(ctx, base);
	// 825ECB88: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825ECB8C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825ECB90: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825ECB94: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825ECB98: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825ECB9C: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825ECBA0: 419A0008  beq cr6, 0x825ecba8
	if ctx.cr[6].eq {
	pc = 0x825ECBA8; continue 'dispatch;
	}
	// 825ECBA4: 4BCD3CED  bl 0x822c0890
	ctx.lr = 0x825ECBA8;
	sub_822C0890(ctx, base);
	// 825ECBA8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825ECBAC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825ECBB0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825ECBB4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825ECBB8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825ECBBC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825ECBC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825ECBC0 size=124
    let mut pc: u32 = 0x825ECBC0;
    'dispatch: loop {
        match pc {
            0x825ECBC0 => {
    //   block [0x825ECBC0..0x825ECC3C)
	// 825ECBC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825ECBC4: 48BBB5A9  bl 0x831a816c
	ctx.lr = 0x825ECBC8;
	sub_831A8130(ctx, base);
	// 825ECBC8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825ECBCC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825ECBD0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825ECBD4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825ECBD8: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 825ECBDC: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 825ECBE0: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 825ECBE4: 48805805  bl 0x82df23e8
	ctx.lr = 0x825ECBE8;
	sub_82DF23E8(ctx, base);
	// 825ECBE8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825ECBEC: 4182001C  beq 0x825ecc08
	if ctx.cr[0].eq {
	pc = 0x825ECC08; continue 'dispatch;
	}
	// 825ECBF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825ECBF4: 4886FD35  bl 0x82e5c928
	ctx.lr = 0x825ECBF8;
	sub_82E5C928(ctx, base);
	// 825ECBF8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825ECBFC: 396B01FC  addi r11, r11, 0x1fc
	ctx.r[11].s64 = ctx.r[11].s64 + 508;
	// 825ECC00: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825ECC04: 48000008  b 0x825ecc0c
	pc = 0x825ECC0C; continue 'dispatch;
	// 825ECC08: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825ECC0C: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825ECC10: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 825ECC14: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825ECC18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825ECC1C: 4BFFEA65  bl 0x825eb680
	ctx.lr = 0x825ECC20;
	sub_825EB680(ctx, base);
	// 825ECC20: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825ECC24: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825ECC28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825ECC2C: 4BCD33D5  bl 0x822c0000
	ctx.lr = 0x825ECC30;
	sub_822C0000(ctx, base);
	// 825ECC30: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825ECC34: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825ECC38: 48BBB584  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825ECC40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825ECC40 size=124
    let mut pc: u32 = 0x825ECC40;
    'dispatch: loop {
        match pc {
            0x825ECC40 => {
    //   block [0x825ECC40..0x825ECCBC)
	// 825ECC40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825ECC44: 48BBB529  bl 0x831a816c
	ctx.lr = 0x825ECC48;
	sub_831A8130(ctx, base);
	// 825ECC48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825ECC4C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825ECC50: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825ECC54: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825ECC58: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 825ECC5C: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 825ECC60: 38600090  li r3, 0x90
	ctx.r[3].s64 = 144;
	// 825ECC64: 48805785  bl 0x82df23e8
	ctx.lr = 0x825ECC68;
	sub_82DF23E8(ctx, base);
	// 825ECC68: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825ECC6C: 4182001C  beq 0x825ecc88
	if ctx.cr[0].eq {
	pc = 0x825ECC88; continue 'dispatch;
	}
	// 825ECC70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825ECC74: 4886FCB5  bl 0x82e5c928
	ctx.lr = 0x825ECC78;
	sub_82E5C928(ctx, base);
	// 825ECC78: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825ECC7C: 396B0224  addi r11, r11, 0x224
	ctx.r[11].s64 = ctx.r[11].s64 + 548;
	// 825ECC80: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825ECC84: 48000008  b 0x825ecc8c
	pc = 0x825ECC8C; continue 'dispatch;
	// 825ECC88: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825ECC8C: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825ECC90: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 825ECC94: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825ECC98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825ECC9C: 4BFFEAAD  bl 0x825eb748
	ctx.lr = 0x825ECCA0;
	sub_825EB748(ctx, base);
	// 825ECCA0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825ECCA4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825ECCA8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825ECCAC: 4BCD3355  bl 0x822c0000
	ctx.lr = 0x825ECCB0;
	sub_822C0000(ctx, base);
	// 825ECCB0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825ECCB4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825ECCB8: 48BBB504  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825ECCC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825ECCC0 size=124
    let mut pc: u32 = 0x825ECCC0;
    'dispatch: loop {
        match pc {
            0x825ECCC0 => {
    //   block [0x825ECCC0..0x825ECD3C)
	// 825ECCC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825ECCC4: 48BBB4A9  bl 0x831a816c
	ctx.lr = 0x825ECCC8;
	sub_831A8130(ctx, base);
	// 825ECCC8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825ECCCC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825ECCD0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825ECCD4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825ECCD8: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 825ECCDC: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 825ECCE0: 38600090  li r3, 0x90
	ctx.r[3].s64 = 144;
	// 825ECCE4: 48805705  bl 0x82df23e8
	ctx.lr = 0x825ECCE8;
	sub_82DF23E8(ctx, base);
	// 825ECCE8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825ECCEC: 4182001C  beq 0x825ecd08
	if ctx.cr[0].eq {
	pc = 0x825ECD08; continue 'dispatch;
	}
	// 825ECCF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825ECCF4: 4886FC35  bl 0x82e5c928
	ctx.lr = 0x825ECCF8;
	sub_82E5C928(ctx, base);
	// 825ECCF8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825ECCFC: 396B024C  addi r11, r11, 0x24c
	ctx.r[11].s64 = ctx.r[11].s64 + 588;
	// 825ECD00: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825ECD04: 48000008  b 0x825ecd0c
	pc = 0x825ECD0C; continue 'dispatch;
	// 825ECD08: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825ECD0C: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825ECD10: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 825ECD14: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825ECD18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825ECD1C: 4BFFEAF5  bl 0x825eb810
	ctx.lr = 0x825ECD20;
	sub_825EB810(ctx, base);
	// 825ECD20: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825ECD24: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825ECD28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825ECD2C: 4BCD32D5  bl 0x822c0000
	ctx.lr = 0x825ECD30;
	sub_822C0000(ctx, base);
	// 825ECD30: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825ECD34: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825ECD38: 48BBB484  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825ECD40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825ECD40 size=124
    let mut pc: u32 = 0x825ECD40;
    'dispatch: loop {
        match pc {
            0x825ECD40 => {
    //   block [0x825ECD40..0x825ECDBC)
	// 825ECD40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825ECD44: 48BBB429  bl 0x831a816c
	ctx.lr = 0x825ECD48;
	sub_831A8130(ctx, base);
	// 825ECD48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825ECD4C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825ECD50: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825ECD54: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825ECD58: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 825ECD5C: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 825ECD60: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 825ECD64: 48805685  bl 0x82df23e8
	ctx.lr = 0x825ECD68;
	sub_82DF23E8(ctx, base);
	// 825ECD68: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825ECD6C: 4182001C  beq 0x825ecd88
	if ctx.cr[0].eq {
	pc = 0x825ECD88; continue 'dispatch;
	}
	// 825ECD70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825ECD74: 4886FBB5  bl 0x82e5c928
	ctx.lr = 0x825ECD78;
	sub_82E5C928(ctx, base);
	// 825ECD78: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825ECD7C: 396B0274  addi r11, r11, 0x274
	ctx.r[11].s64 = ctx.r[11].s64 + 628;
	// 825ECD80: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825ECD84: 48000008  b 0x825ecd8c
	pc = 0x825ECD8C; continue 'dispatch;
	// 825ECD88: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825ECD8C: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825ECD90: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 825ECD94: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825ECD98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825ECD9C: 4BFFEB3D  bl 0x825eb8d8
	ctx.lr = 0x825ECDA0;
	sub_825EB8D8(ctx, base);
	// 825ECDA0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825ECDA4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825ECDA8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825ECDAC: 4BCD3255  bl 0x822c0000
	ctx.lr = 0x825ECDB0;
	sub_822C0000(ctx, base);
	// 825ECDB0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825ECDB4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825ECDB8: 48BBB404  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825ECDC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825ECDC0 size=124
    let mut pc: u32 = 0x825ECDC0;
    'dispatch: loop {
        match pc {
            0x825ECDC0 => {
    //   block [0x825ECDC0..0x825ECE3C)
	// 825ECDC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825ECDC4: 48BBB3A9  bl 0x831a816c
	ctx.lr = 0x825ECDC8;
	sub_831A8130(ctx, base);
	// 825ECDC8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825ECDCC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825ECDD0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825ECDD4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825ECDD8: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 825ECDDC: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 825ECDE0: 38600068  li r3, 0x68
	ctx.r[3].s64 = 104;
	// 825ECDE4: 48805605  bl 0x82df23e8
	ctx.lr = 0x825ECDE8;
	sub_82DF23E8(ctx, base);
	// 825ECDE8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825ECDEC: 4182001C  beq 0x825ece08
	if ctx.cr[0].eq {
	pc = 0x825ECE08; continue 'dispatch;
	}
	// 825ECDF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825ECDF4: 4886FB35  bl 0x82e5c928
	ctx.lr = 0x825ECDF8;
	sub_82E5C928(ctx, base);
	// 825ECDF8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825ECDFC: 396B029C  addi r11, r11, 0x29c
	ctx.r[11].s64 = ctx.r[11].s64 + 668;
	// 825ECE00: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825ECE04: 48000008  b 0x825ece0c
	pc = 0x825ECE0C; continue 'dispatch;
	// 825ECE08: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825ECE0C: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825ECE10: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 825ECE14: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825ECE18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825ECE1C: 4BFFEB85  bl 0x825eb9a0
	ctx.lr = 0x825ECE20;
	sub_825EB9A0(ctx, base);
	// 825ECE20: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825ECE24: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825ECE28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825ECE2C: 4BCD31D5  bl 0x822c0000
	ctx.lr = 0x825ECE30;
	sub_822C0000(ctx, base);
	// 825ECE30: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825ECE34: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825ECE38: 48BBB384  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825ECE40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825ECE40 size=280
    let mut pc: u32 = 0x825ECE40;
    'dispatch: loop {
        match pc {
            0x825ECE40 => {
    //   block [0x825ECE40..0x825ECF58)
	// 825ECE40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825ECE44: 48BBB329  bl 0x831a816c
	ctx.lr = 0x825ECE48;
	sub_831A8130(ctx, base);
	// 825ECE48: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825ECE4C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825ECE50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825ECE54: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825ECE58: 419A00F8  beq cr6, 0x825ecf50
	if ctx.cr[6].eq {
	pc = 0x825ECF50; continue 'dispatch;
	}
	// 825ECE5C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825ECE60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825ECE64: 388B03DC  addi r4, r11, 0x3dc
	ctx.r[4].s64 = ctx.r[11].s64 + 988;
	// 825ECE68: 48806BA1  bl 0x82df3a08
	ctx.lr = 0x825ECE6C;
	sub_82DF3A08(ctx, base);
	// 825ECE6C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825ECE70: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825ECE74: 388B03D4  addi r4, r11, 0x3d4
	ctx.r[4].s64 = ctx.r[11].s64 + 980;
	// 825ECE78: 48806B91  bl 0x82df3a08
	ctx.lr = 0x825ECE7C;
	sub_82DF3A08(ctx, base);
	// 825ECE7C: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825ECE80: 57FE103A  slwi r30, r31, 2
	ctx.r[30].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 825ECE84: 3BEBE134  addi r31, r11, -0x1ecc
	ctx.r[31].s64 = ctx.r[11].s64 + -7884;
	// 825ECE88: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 825ECE8C: 38E003E8  li r7, 0x3e8
	ctx.r[7].s64 = 1000;
	// 825ECE90: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825ECE94: 7CBEFA14  add r5, r30, r31
	ctx.r[5].u64 = ctx.r[30].u64 + ctx.r[31].u64;
	// 825ECE98: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825ECE9C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825ECEA0: 4BFB6579  bl 0x825a3418
	ctx.lr = 0x825ECEA4;
	sub_825A3418(ctx, base);
	// 825ECEA4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825ECEA8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825ECEAC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825ECEB0: 4BFB4DB1  bl 0x825a1c60
	ctx.lr = 0x825ECEB4;
	sub_825A1C60(ctx, base);
	// 825ECEB4: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 825ECEB8: 48806571  bl 0x82df3428
	ctx.lr = 0x825ECEBC;
	sub_82DF3428(ctx, base);
	// 825ECEBC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825ECEC0: 4BCDBDF9  bl 0x822c8cb8
	ctx.lr = 0x825ECEC4;
	sub_822C8CB8(ctx, base);
	// 825ECEC4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825ECEC8: 48806561  bl 0x82df3428
	ctx.lr = 0x825ECECC;
	sub_82DF3428(ctx, base);
	// 825ECECC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825ECED0: 48806559  bl 0x82df3428
	ctx.lr = 0x825ECED4;
	sub_82DF3428(ctx, base);
	// 825ECED4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825ECED8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825ECEDC: 388B03C0  addi r4, r11, 0x3c0
	ctx.r[4].s64 = ctx.r[11].s64 + 960;
	// 825ECEE0: 48806B29  bl 0x82df3a08
	ctx.lr = 0x825ECEE4;
	sub_82DF3A08(ctx, base);
	// 825ECEE4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825ECEE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825ECEEC: 388B03AC  addi r4, r11, 0x3ac
	ctx.r[4].s64 = ctx.r[11].s64 + 940;
	// 825ECEF0: 48806B19  bl 0x82df3a08
	ctx.lr = 0x825ECEF4;
	sub_82DF3A08(ctx, base);
	// 825ECEF4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 825ECEF8: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 825ECEFC: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 825ECF00: 397F0020  addi r11, r31, 0x20
	ctx.r[11].s64 = ctx.r[31].s64 + 32;
	// 825ECF04: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825ECF08: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 825ECF0C: C06A9528  lfs f3, -0x6ad8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 825ECF10: 7CBE5A14  add r5, r30, r11
	ctx.r[5].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 825ECF14: C04908A8  lfs f2, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 825ECF18: C02808A4  lfs f1, 0x8a4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825ECF1C: 4BFB638D  bl 0x825a32a8
	ctx.lr = 0x825ECF20;
	sub_825A32A8(ctx, base);
	// 825ECF20: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825ECF24: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825ECF28: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825ECF2C: 4BFB4845  bl 0x825a1770
	ctx.lr = 0x825ECF30;
	sub_825A1770(ctx, base);
	// 825ECF30: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 825ECF34: 488064F5  bl 0x82df3428
	ctx.lr = 0x825ECF38;
	sub_82DF3428(ctx, base);
	// 825ECF38: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 825ECF3C: 4BCDBD7D  bl 0x822c8cb8
	ctx.lr = 0x825ECF40;
	sub_822C8CB8(ctx, base);
	// 825ECF40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825ECF44: 488064E5  bl 0x82df3428
	ctx.lr = 0x825ECF48;
	sub_82DF3428(ctx, base);
	// 825ECF48: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825ECF4C: 488064DD  bl 0x82df3428
	ctx.lr = 0x825ECF50;
	sub_82DF3428(ctx, base);
	// 825ECF50: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 825ECF54: 48BBB268  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825ECF58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825ECF58 size=12
    let mut pc: u32 = 0x825ECF58;
    'dispatch: loop {
        match pc {
            0x825ECF58 => {
    //   block [0x825ECF58..0x825ECF64)
	// 825ECF58: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825ECF5C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825ECF60: 4BFFFEE0  b 0x825ece40
	sub_825ECE40(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825ECF68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825ECF68 size=12
    let mut pc: u32 = 0x825ECF68;
    'dispatch: loop {
        match pc {
            0x825ECF68 => {
    //   block [0x825ECF68..0x825ECF74)
	// 825ECF68: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825ECF6C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 825ECF70: 4BFFFED0  b 0x825ece40
	sub_825ECE40(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825ECF78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825ECF78 size=12
    let mut pc: u32 = 0x825ECF78;
    'dispatch: loop {
        match pc {
            0x825ECF78 => {
    //   block [0x825ECF78..0x825ECF84)
	// 825ECF78: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825ECF7C: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 825ECF80: 4BFFFEC0  b 0x825ece40
	sub_825ECE40(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825ECF88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825ECF88 size=744
    let mut pc: u32 = 0x825ECF88;
    'dispatch: loop {
        match pc {
            0x825ECF88 => {
    //   block [0x825ECF88..0x825ED270)
	// 825ECF88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825ECF8C: 48BBB1D1  bl 0x831a815c
	ctx.lr = 0x825ECF90;
	sub_831A8130(ctx, base);
	// 825ECF90: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825ECF94: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825ECF98: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 825ECF9C: 3BCBE174  addi r30, r11, -0x1e8c
	ctx.r[30].s64 = ctx.r[11].s64 + -7820;
	// 825ECFA0: 577D103A  slwi r29, r27, 2
	ctx.r[29].u32 = ctx.r[27].u32.wrapping_shl(2);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 825ECFA4: 397E0040  addi r11, r30, 0x40
	ctx.r[11].s64 = ctx.r[30].s64 + 64;
	// 825ECFA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825ECFAC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825ECFB0: 7CF93B78  mr r25, r7
	ctx.r[25].u64 = ctx.r[7].u64;
	// 825ECFB4: 7C9D582E  lwzx r4, r29, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825ECFB8: 48806A51  bl 0x82df3a08
	ctx.lr = 0x825ECFBC;
	sub_82DF3A08(ctx, base);
	// 825ECFBC: 397E0020  addi r11, r30, 0x20
	ctx.r[11].s64 = ctx.r[30].s64 + 32;
	// 825ECFC0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825ECFC4: 7C9D582E  lwzx r4, r29, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825ECFC8: 48806A41  bl 0x82df3a08
	ctx.lr = 0x825ECFCC;
	sub_82DF3A08(ctx, base);
	// 825ECFCC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825ECFD0: 7C9DF02E  lwzx r4, r29, r30
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 825ECFD4: 48806A35  bl 0x82df3a08
	ctx.lr = 0x825ECFD8;
	sub_82DF3A08(ctx, base);
	// 825ECFD8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825ECFDC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825ECFE0: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 825ECFE4: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 825ECFE8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825ECFEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825ECFF0: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 825ECFF4: 4BF26AED  bl 0x82513ae0
	ctx.lr = 0x825ECFF8;
	sub_82513AE0(ctx, base);
	// 825ECFF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825ECFFC: 4880642D  bl 0x82df3428
	ctx.lr = 0x825ED000;
	sub_82DF3428(ctx, base);
	// 825ED000: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825ED004: 48806425  bl 0x82df3428
	ctx.lr = 0x825ED008;
	sub_82DF3428(ctx, base);
	// 825ED008: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825ED00C: 4880641D  bl 0x82df3428
	ctx.lr = 0x825ED010;
	sub_82DF3428(ctx, base);
	// 825ED010: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825ED014: 387F0164  addi r3, r31, 0x164
	ctx.r[3].s64 = ctx.r[31].s64 + 356;
	// 825ED018: 396BA214  addi r11, r11, -0x5dec
	ctx.r[11].s64 = ctx.r[11].s64 + -24044;
	// 825ED01C: 917F0160  stw r11, 0x160(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), ctx.r[11].u32 ) };
	// 825ED020: 488708B1  bl 0x82e5d8d0
	ctx.lr = 0x825ED024;
	sub_82E5D8D0(ctx, base);
	// 825ED024: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825ED028: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825ED02C: 396B0118  addi r11, r11, 0x118
	ctx.r[11].s64 = ctx.r[11].s64 + 280;
	// 825ED030: 394A0334  addi r10, r10, 0x334
	ctx.r[10].s64 = ctx.r[10].s64 + 820;
	// 825ED034: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 825ED038: 917F0164  stw r11, 0x164(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(356 as u32), ctx.r[11].u32 ) };
	// 825ED03C: 3CE08204  lis r7, -0x7dfc
	ctx.r[7].s64 = -2113667072;
	// 825ED040: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825ED044: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 825ED048: 396802D4  addi r11, r8, 0x2d4
	ctx.r[11].s64 = ctx.r[8].s64 + 724;
	// 825ED04C: 39290320  addi r9, r9, 0x320
	ctx.r[9].s64 = ctx.r[9].s64 + 800;
	// 825ED050: 394702C4  addi r10, r7, 0x2c4
	ctx.r[10].s64 = ctx.r[7].s64 + 708;
	// 825ED054: 917F0160  stw r11, 0x160(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), ctx.r[11].u32 ) };
	// 825ED058: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 825ED05C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825ED060: 915F0164  stw r10, 0x164(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(356 as u32), ctx.r[10].u32 ) };
	// 825ED064: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825ED068: 3B4B03E8  addi r26, r11, 0x3e8
	ctx.r[26].s64 = ctx.r[11].s64 + 1000;
	// 825ED06C: 38A0012A  li r5, 0x12a
	ctx.r[5].s64 = 298;
	// 825ED070: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 825ED074: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 825ED078: 48805371  bl 0x82df23e8
	ctx.lr = 0x825ED07C;
	sub_82DF23E8(ctx, base);
	// 825ED07C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825ED080: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825ED084: 41820010  beq 0x825ed094
	if ctx.cr[0].eq {
	pc = 0x825ED094; continue 'dispatch;
	}
	// 825ED088: 48825F81  bl 0x82e13008
	ctx.lr = 0x825ED08C;
	sub_82E13008(ctx, base);
	// 825ED08C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825ED090: 48000008  b 0x825ed098
	pc = 0x825ED098; continue 'dispatch;
	// 825ED094: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 825ED098: 93BF01C4  stw r29, 0x1c4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(452 as u32), ctx.r[29].u32 ) };
	// 825ED09C: 397F01C4  addi r11, r31, 0x1c4
	ctx.r[11].s64 = ctx.r[31].s64 + 452;
	// 825ED0A0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825ED0A4: 3B8B0004  addi r28, r11, 4
	ctx.r[28].s64 = ctx.r[11].s64 + 4;
	// 825ED0A8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825ED0AC: 4BCF3F6D  bl 0x822e1018
	ctx.lr = 0x825ED0B0;
	sub_822E1018(ctx, base);
	// 825ED0B0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825ED0B4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825ED0B8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825ED0BC: 4BCD2F45  bl 0x822c0000
	ctx.lr = 0x825ED0C0;
	sub_822C0000(ctx, base);
	// 825ED0C0: 93DF01CC  stw r30, 0x1cc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(460 as u32), ctx.r[30].u32 ) };
	// 825ED0C4: 93DF01D0  stw r30, 0x1d0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(464 as u32), ctx.r[30].u32 ) };
	// 825ED0C8: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 825ED0CC: 937F01D4  stw r27, 0x1d4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(468 as u32), ctx.r[27].u32 ) };
	// 825ED0D0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825ED0D4: 38A0012B  li r5, 0x12b
	ctx.r[5].s64 = 299;
	// 825ED0D8: 38600138  li r3, 0x138
	ctx.r[3].s64 = 312;
	// 825ED0DC: 4BCD32FD  bl 0x822c03d8
	ctx.lr = 0x825ED0E0;
	sub_822C03D8(ctx, base);
	// 825ED0E0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825ED0E4: 41820024  beq 0x825ed108
	if ctx.cr[0].eq {
	pc = 0x825ED108; continue 'dispatch;
	}
	// 825ED0E8: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 825ED0EC: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 825ED0F0: 93CA0000  stw r30, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 825ED0F4: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825ED0F8: 394A0068  addi r10, r10, 0x68
	ctx.r[10].s64 = ctx.r[10].s64 + 104;
	// 825ED0FC: 4080FFF4  bge 0x825ed0f0
	if !ctx.cr[0].lt {
	pc = 0x825ED0F0; continue 'dispatch;
	}
	// 825ED100: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825ED104: 48000008  b 0x825ed10c
	pc = 0x825ED10C; continue 'dispatch;
	// 825ED108: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 825ED10C: 93BF0240  stw r29, 0x240(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(576 as u32), ctx.r[29].u32 ) };
	// 825ED110: 397F0240  addi r11, r31, 0x240
	ctx.r[11].s64 = ctx.r[31].s64 + 576;
	// 825ED114: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825ED118: 3B8B0004  addi r28, r11, 4
	ctx.r[28].s64 = ctx.r[11].s64 + 4;
	// 825ED11C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825ED120: 4BDB54B1  bl 0x823a25d0
	ctx.lr = 0x825ED124;
	sub_823A25D0(ctx, base);
	// 825ED124: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825ED128: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825ED12C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825ED130: 4BCD2ED1  bl 0x822c0000
	ctx.lr = 0x825ED134;
	sub_822C0000(ctx, base);
	// 825ED134: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825ED138: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 825ED13C: 93DF0248  stw r30, 0x248(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(584 as u32), ctx.r[30].u32 ) };
	// 825ED140: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 825ED144: 93DF0250  stw r30, 0x250(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(592 as u32), ctx.r[30].u32 ) };
	// 825ED148: 38E00014  li r7, 0x14
	ctx.r[7].s64 = 20;
	// 825ED14C: 397F0264  addi r11, r31, 0x264
	ctx.r[11].s64 = ctx.r[31].s64 + 612;
	// 825ED150: C00A08A8  lfs f0, 0x8a8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825ED154: 90FF0260  stw r7, 0x260(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(608 as u32), ctx.r[7].u32 ) };
	// 825ED158: C1A99524  lfs f13, -0x6adc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825ED15C: C188D1B8  lfs f12, -0x2e48(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-11848 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825ED160: D01F024C  stfs f0, 0x24c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(588 as u32), tmp.u32 ) };
	// 825ED164: D1BF0254  stfs f13, 0x254(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(596 as u32), tmp.u32 ) };
	// 825ED168: D19F0258  stfs f12, 0x258(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(600 as u32), tmp.u32 ) };
	// 825ED16C: D01F025C  stfs f0, 0x25c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(604 as u32), tmp.u32 ) };
	// 825ED170: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 825ED174: 917F0264  stw r11, 0x264(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(612 as u32), ctx.r[11].u32 ) };
	// 825ED178: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 825ED17C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825ED180: 917F0268  stw r11, 0x268(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(616 as u32), ctx.r[11].u32 ) };
	// 825ED184: 419A0024  beq cr6, 0x825ed1a8
	if ctx.cr[6].eq {
	pc = 0x825ED1A8; continue 'dispatch;
	}
	// 825ED188: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825ED18C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825ED190: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825ED194: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825ED198: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825ED19C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825ED1A0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825ED1A4: 4082FFE8  bne 0x825ed18c
	if !ctx.cr[0].eq {
	pc = 0x825ED18C; continue 'dispatch;
	}
	// 825ED1A8: 93DF026C  stw r30, 0x26c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(620 as u32), ctx.r[30].u32 ) };
	// 825ED1AC: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 825ED1B0: 93DF0270  stw r30, 0x270(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(624 as u32), ctx.r[30].u32 ) };
	// 825ED1B4: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 825ED1B8: 93DF0274  stw r30, 0x274(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(628 as u32), ctx.r[30].u32 ) };
	// 825ED1BC: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 825ED1C0: 93DF0278  stw r30, 0x278(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(632 as u32), ctx.r[30].u32 ) };
	// 825ED1C4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825ED1C8: 93DF027C  stw r30, 0x27c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(636 as u32), ctx.r[30].u32 ) };
	// 825ED1CC: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 825ED1D0: 93DF0280  stw r30, 0x280(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(640 as u32), ctx.r[30].u32 ) };
	// 825ED1D4: C1AAA1C4  lfs f13, -0x5e3c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825ED1D8: 93DF0284  stw r30, 0x284(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(644 as u32), ctx.r[30].u32 ) };
	// 825ED1DC: C0090110  lfs f0, 0x110(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(272 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825ED1E0: 93DF0288  stw r30, 0x288(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(648 as u32), ctx.r[30].u32 ) };
	// 825ED1E4: C18803E4  lfs f12, 0x3e4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(996 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825ED1E8: 93DF028C  stw r30, 0x28c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(652 as u32), ctx.r[30].u32 ) };
	// 825ED1EC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825ED1F0: 93DF0290  stw r30, 0x290(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(656 as u32), ctx.r[30].u32 ) };
	// 825ED1F4: 38A0013D  li r5, 0x13d
	ctx.r[5].s64 = 317;
	// 825ED1F8: 93DF0294  stw r30, 0x294(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(660 as u32), ctx.r[30].u32 ) };
	// 825ED1FC: D1BF02A0  stfs f13, 0x2a0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(672 as u32), tmp.u32 ) };
	// 825ED200: D01F01D8  stfs f0, 0x1d8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(472 as u32), tmp.u32 ) };
	// 825ED204: 917F0298  stw r11, 0x298(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(664 as u32), ctx.r[11].u32 ) };
	// 825ED208: D01F01DC  stfs f0, 0x1dc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(476 as u32), tmp.u32 ) };
	// 825ED20C: 997F029C  stb r11, 0x29c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(668 as u32), ctx.r[11].u8 ) };
	// 825ED210: D19F01E0  stfs f12, 0x1e0(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(480 as u32), tmp.u32 ) };
	// 825ED214: 997F029D  stb r11, 0x29d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(669 as u32), ctx.r[11].u8 ) };
	// 825ED218: 9BDF02A4  stb r30, 0x2a4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(676 as u32), ctx.r[30].u8 ) };
	// 825ED21C: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 825ED220: 3BBF026C  addi r29, r31, 0x26c
	ctx.r[29].s64 = ctx.r[31].s64 + 620;
	// 825ED224: 4BCD31B5  bl 0x822c03d8
	ctx.lr = 0x825ED228;
	sub_822C03D8(ctx, base);
	// 825ED228: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825ED22C: 4182002C  beq 0x825ed258
	if ctx.cr[0].eq {
	pc = 0x825ED258; continue 'dispatch;
	}
	// 825ED230: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825ED234: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 825ED238: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825ED23C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825ED240: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825ED244: C04B08A4  lfs f2, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 825ED248: C02AACFC  lfs f1, -0x5304(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-21252 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825ED24C: 4BE3F1BD  bl 0x8242c408
	ctx.lr = 0x825ED250;
	sub_8242C408(ctx, base);
	// 825ED250: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825ED254: 48000008  b 0x825ed25c
	pc = 0x825ED25C; continue 'dispatch;
	// 825ED258: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825ED25C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825ED260: 4BFFF881  bl 0x825ecae0
	ctx.lr = 0x825ED264;
	sub_825ECAE0(ctx, base);
	// 825ED264: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825ED268: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825ED26C: 48BBAF40  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825ED270(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825ED270 size=740
    let mut pc: u32 = 0x825ED270;
    'dispatch: loop {
        match pc {
            0x825ED270 => {
    //   block [0x825ED270..0x825ED554)
	// 825ED270: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825ED274: 48BBAEF9  bl 0x831a816c
	ctx.lr = 0x825ED278;
	sub_831A8130(ctx, base);
	// 825ED278: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825ED27C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825ED280: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825ED284: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825ED288: 388B039C  addi r4, r11, 0x39c
	ctx.r[4].s64 = ctx.r[11].s64 + 924;
	// 825ED28C: 4880677D  bl 0x82df3a08
	ctx.lr = 0x825ED290;
	sub_82DF3A08(ctx, base);
	// 825ED290: 387E0164  addi r3, r30, 0x164
	ctx.r[3].s64 = ctx.r[30].s64 + 356;
	// 825ED294: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 825ED298: 4886D439  bl 0x82e5a6d0
	ctx.lr = 0x825ED29C;
	sub_82E5A6D0(ctx, base);
	// 825ED29C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825ED2A0: 48806069  bl 0x82df3308
	ctx.lr = 0x825ED2A4;
	sub_82DF3308(ctx, base);
	// 825ED2A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825ED2A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825ED2AC: 4880617D  bl 0x82df3428
	ctx.lr = 0x825ED2B0;
	sub_82DF3428(ctx, base);
	// 825ED2B0: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825ED2B4: 418200BC  beq 0x825ed370
	if ctx.cr[0].eq {
	pc = 0x825ED370; continue 'dispatch;
	}
	// 825ED2B8: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 825ED2BC: 4BDD1D6D  bl 0x823bf028
	ctx.lr = 0x825ED2C0;
	sub_823BF028(ctx, base);
	// 825ED2C0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825ED2C4: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825ED2C8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825ED2CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825ED2D0: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 825ED2D4: 419A0024  beq cr6, 0x825ed2f8
	if ctx.cr[6].eq {
	pc = 0x825ED2F8; continue 'dispatch;
	}
	// 825ED2D8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825ED2DC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825ED2E0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825ED2E4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825ED2E8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825ED2EC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825ED2F0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825ED2F4: 4082FFE8  bne 0x825ed2dc
	if !ctx.cr[0].eq {
	pc = 0x825ED2DC; continue 'dispatch;
	}
	// 825ED2F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825ED2FC: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 825ED300: 4BF221C9  bl 0x8250f4c8
	ctx.lr = 0x825ED304;
	sub_8250F4C8(ctx, base);
	// 825ED304: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825ED308: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825ED30C: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 825ED310: 409A0008  bne cr6, 0x825ed318
	if !ctx.cr[6].eq {
	pc = 0x825ED318; continue 'dispatch;
	}
	// 825ED314: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825ED318: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825ED31C: 3BE10060  addi r31, r1, 0x60
	ctx.r[31].s64 = ctx.r[1].s64 + 96;
	// 825ED320: 4BF1B6F9  bl 0x82508a18
	ctx.lr = 0x825ED324;
	sub_82508A18(ctx, base);
	// 825ED324: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825ED328: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825ED32C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 825ED330: 388A03E8  addi r4, r10, 0x3e8
	ctx.r[4].s64 = ctx.r[10].s64 + 1000;
	// 825ED334: 38A001BB  li r5, 0x1bb
	ctx.r[5].s64 = 443;
	// 825ED338: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 825ED33C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825ED340: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 825ED344: 4886B6FD  bl 0x82e58a40
	ctx.lr = 0x825ED348;
	sub_82E58A40(ctx, base);
	// 825ED348: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 825ED34C: 48804945  bl 0x82df1c90
	ctx.lr = 0x825ED350;
	sub_82DF1C90(ctx, base);
	// 825ED350: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825ED354: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825ED358: 419A0008  beq cr6, 0x825ed360
	if ctx.cr[6].eq {
	pc = 0x825ED360; continue 'dispatch;
	}
	// 825ED35C: 4BCD3535  bl 0x822c0890
	ctx.lr = 0x825ED360;
	sub_822C0890(ctx, base);
	// 825ED360: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 825ED364: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825ED368: 419A0008  beq cr6, 0x825ed370
	if ctx.cr[6].eq {
	pc = 0x825ED370; continue 'dispatch;
	}
	// 825ED36C: 4BCD3525  bl 0x822c0890
	ctx.lr = 0x825ED370;
	sub_822C0890(ctx, base);
	// 825ED370: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 825ED374: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825ED378: 4BF26201  bl 0x82513578
	ctx.lr = 0x825ED37C;
	sub_82513578(ctx, base);
	// 825ED37C: 388100D0  addi r4, r1, 0xd0
	ctx.r[4].s64 = ctx.r[1].s64 + 208;
	// 825ED380: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825ED384: 4BF26265  bl 0x825135e8
	ctx.lr = 0x825ED388;
	sub_825135E8(ctx, base);
	// 825ED388: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 825ED38C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825ED390: 4BF262D9  bl 0x82513668
	ctx.lr = 0x825ED394;
	sub_82513668(ctx, base);
	// 825ED394: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825ED398: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825ED39C: 4BF2212D  bl 0x8250f4c8
	ctx.lr = 0x825ED3A0;
	sub_8250F4C8(ctx, base);
	// 825ED3A0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825ED3A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825ED3A8: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 825ED3AC: 409A0008  bne cr6, 0x825ed3b4
	if !ctx.cr[6].eq {
	pc = 0x825ED3B4; continue 'dispatch;
	}
	// 825ED3B0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825ED3B4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825ED3B8: 4BF1D281  bl 0x8250a638
	ctx.lr = 0x825ED3BC;
	sub_8250A638(ctx, base);
	// 825ED3BC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825ED3C0: 488048D1  bl 0x82df1c90
	ctx.lr = 0x825ED3C4;
	sub_82DF1C90(ctx, base);
	// 825ED3C4: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 825ED3C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825ED3CC: 419A0110  beq cr6, 0x825ed4dc
	if ctx.cr[6].eq {
	pc = 0x825ED4DC; continue 'dispatch;
	}
	// 825ED3D0: 817E01D4  lwz r11, 0x1d4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(468 as u32) ) } as u64;
	// 825ED3D4: 3D408329  lis r10, -0x7cd7
	ctx.r[10].s64 = -2094465024;
	// 825ED3D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825ED3DC: 394AE1D4  addi r10, r10, -0x1e2c
	ctx.r[10].s64 = ctx.r[10].s64 + -7724;
	// 825ED3E0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825ED3E4: 7C8B502E  lwzx r4, r11, r10
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 825ED3E8: 48806621  bl 0x82df3a08
	ctx.lr = 0x825ED3EC;
	sub_82DF3A08(ctx, base);
	// 825ED3EC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825ED3F0: 80810068  lwz r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 825ED3F4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825ED3F8: 481D3C11  bl 0x827c1008
	ctx.lr = 0x825ED3FC;
	sub_827C1008(ctx, base);
	// 825ED3FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825ED400: 48806029  bl 0x82df3428
	ctx.lr = 0x825ED404;
	sub_82DF3428(ctx, base);
	// 825ED404: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825ED408: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825ED40C: 419A00C0  beq cr6, 0x825ed4cc
	if ctx.cr[6].eq {
	pc = 0x825ED4CC; continue 'dispatch;
	}
	// 825ED410: 38A100B0  addi r5, r1, 0xb0
	ctx.r[5].s64 = ctx.r[1].s64 + 176;
	// 825ED414: 388100D0  addi r4, r1, 0xd0
	ctx.r[4].s64 = ctx.r[1].s64 + 208;
	// 825ED418: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 825ED41C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 825ED420: 4BD1A359  bl 0x82307778
	ctx.lr = 0x825ED424;
	sub_82307778(ctx, base);
	// 825ED424: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825ED428: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825ED42C: 481CE8A5  bl 0x827bbcd0
	ctx.lr = 0x825ED430;
	sub_827BBCD0(ctx, base);
	// 825ED430: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825ED434: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825ED438: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825ED43C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825ED440: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825ED444: 419A0024  beq cr6, 0x825ed468
	if ctx.cr[6].eq {
	pc = 0x825ED468; continue 'dispatch;
	}
	// 825ED448: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825ED44C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825ED450: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825ED454: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825ED458: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825ED45C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825ED460: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825ED464: 4082FFE8  bne 0x825ed44c
	if !ctx.cr[0].eq {
	pc = 0x825ED44C; continue 'dispatch;
	}
	// 825ED468: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825ED46C: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 825ED470: 4BF22059  bl 0x8250f4c8
	ctx.lr = 0x825ED474;
	sub_8250F4C8(ctx, base);
	// 825ED474: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825ED478: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825ED47C: 3BEBFFFC  addi r31, r11, -4
	ctx.r[31].s64 = ctx.r[11].s64 + -4;
	// 825ED480: 409A0008  bne cr6, 0x825ed488
	if !ctx.cr[6].eq {
	pc = 0x825ED488; continue 'dispatch;
	}
	// 825ED484: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825ED488: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825ED48C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825ED490: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 825ED494: 4BF22085  bl 0x8250f518
	ctx.lr = 0x825ED498;
	sub_8250F518(ctx, base);
	// 825ED498: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825ED49C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825ED4A0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825ED4A4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825ED4A8: 4BF20061  bl 0x8250d508
	ctx.lr = 0x825ED4AC;
	sub_8250D508(ctx, base);
	// 825ED4AC: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 825ED4B0: 488047E1  bl 0x82df1c90
	ctx.lr = 0x825ED4B4;
	sub_82DF1C90(ctx, base);
	// 825ED4B4: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825ED4B8: 488047D9  bl 0x82df1c90
	ctx.lr = 0x825ED4BC;
	sub_82DF1C90(ctx, base);
	// 825ED4BC: 38A100C0  addi r5, r1, 0xc0
	ctx.r[5].s64 = ctx.r[1].s64 + 192;
	// 825ED4C0: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 825ED4C4: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825ED4C8: 481CFC99  bl 0x827bd160
	ctx.lr = 0x825ED4CC;
	sub_827BD160(ctx, base);
	// 825ED4CC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825ED4D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825ED4D4: 419A0008  beq cr6, 0x825ed4dc
	if ctx.cr[6].eq {
	pc = 0x825ED4DC; continue 'dispatch;
	}
	// 825ED4D8: 4BCD33B9  bl 0x822c0890
	ctx.lr = 0x825ED4DC;
	sub_822C0890(ctx, base);
	// 825ED4DC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825ED4E0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825ED4E4: 4BF21FE5  bl 0x8250f4c8
	ctx.lr = 0x825ED4E8;
	sub_8250F4C8(ctx, base);
	// 825ED4E8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825ED4EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825ED4F0: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 825ED4F4: 409A0008  bne cr6, 0x825ed4fc
	if !ctx.cr[6].eq {
	pc = 0x825ED4FC; continue 'dispatch;
	}
	// 825ED4F8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825ED4FC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825ED500: 4BF1B461  bl 0x82508960
	ctx.lr = 0x825ED504;
	sub_82508960(ctx, base);
	// 825ED504: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825ED508: 48804789  bl 0x82df1c90
	ctx.lr = 0x825ED50C;
	sub_82DF1C90(ctx, base);
	// 825ED50C: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 825ED510: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825ED514: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 825ED518: 409A0008  bne cr6, 0x825ed520
	if !ctx.cr[6].eq {
	pc = 0x825ED520; continue 'dispatch;
	}
	// 825ED51C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825ED520: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825ED524: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825ED528: 38AB0434  addi r5, r11, 0x434
	ctx.r[5].s64 = ctx.r[11].s64 + 1076;
	// 825ED52C: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 825ED530: 4854E5E9  bl 0x82b3bb18
	ctx.lr = 0x825ED534;
	sub_82B3BB18(ctx, base);
	// 825ED534: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825ED538: 48804759  bl 0x82df1c90
	ctx.lr = 0x825ED53C;
	sub_82DF1C90(ctx, base);
	// 825ED53C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 825ED540: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825ED544: 419A0008  beq cr6, 0x825ed54c
	if ctx.cr[6].eq {
	pc = 0x825ED54C; continue 'dispatch;
	}
	// 825ED548: 4BCD3349  bl 0x822c0890
	ctx.lr = 0x825ED54C;
	sub_822C0890(ctx, base);
	// 825ED54C: 38210160  addi r1, r1, 0x160
	ctx.r[1].s64 = ctx.r[1].s64 + 352;
	// 825ED550: 48BBAC6C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825ED558(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825ED558 size=248
    let mut pc: u32 = 0x825ED558;
    'dispatch: loop {
        match pc {
            0x825ED558 => {
    //   block [0x825ED558..0x825ED650)
	// 825ED558: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825ED55C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825ED560: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825ED564: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825ED568: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825ED56C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825ED570: 4BFFFD01  bl 0x825ed270
	ctx.lr = 0x825ED574;
	sub_825ED270(ctx, base);
	// 825ED574: 807F0290  lwz r3, 0x290(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(656 as u32) ) } as u64;
	// 825ED578: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825ED57C: 419A0064  beq cr6, 0x825ed5e0
	if ctx.cr[6].eq {
	pc = 0x825ED5E0; continue 'dispatch;
	}
	// 825ED580: 817F01D4  lwz r11, 0x1d4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(468 as u32) ) } as u64;
	// 825ED584: 3D408329  lis r10, -0x7cd7
	ctx.r[10].s64 = -2094465024;
	// 825ED588: 394AE214  addi r10, r10, -0x1dec
	ctx.r[10].s64 = ctx.r[10].s64 + -7660;
	// 825ED58C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825ED590: 7C8B502E  lwzx r4, r11, r10
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 825ED594: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 825ED598: 419A0048  beq cr6, 0x825ed5e0
	if ctx.cr[6].eq {
	pc = 0x825ED5E0; continue 'dispatch;
	}
	// 825ED59C: 48559325  bl 0x82b468c0
	ctx.lr = 0x825ED5A0;
	sub_82B468C0(ctx, base);
	// 825ED5A0: 809F00C0  lwz r4, 0xc0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 825ED5A4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825ED5A8: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825ED5AC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825ED5B0: 83DF0290  lwz r30, 0x290(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(656 as u32) ) } as u64;
	// 825ED5B4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825ED5B8: 4E800421  bctrl
	ctx.lr = 0x825ED5BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825ED5BC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825ED5C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825ED5C4: 485595E5  bl 0x82b46ba8
	ctx.lr = 0x825ED5C8;
	sub_82B46BA8(ctx, base);
	// 825ED5C8: 807F0290  lwz r3, 0x290(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(656 as u32) ) } as u64;
	// 825ED5CC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825ED5D0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825ED5D4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825ED5D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825ED5DC: 4E800421  bctrl
	ctx.lr = 0x825ED5E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825ED5E0: 897F029C  lbz r11, 0x29c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(668 as u32) ) } as u64;
	// 825ED5E4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825ED5E8: 41820048  beq 0x825ed630
	if ctx.cr[0].eq {
	pc = 0x825ED630; continue 'dispatch;
	}
	// 825ED5EC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825ED5F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825ED5F4: 388B0378  addi r4, r11, 0x378
	ctx.r[4].s64 = ctx.r[11].s64 + 888;
	// 825ED5F8: 48806411  bl 0x82df3a08
	ctx.lr = 0x825ED5FC;
	sub_82DF3A08(ctx, base);
	// 825ED5FC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825ED600: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825ED604: 389F0164  addi r4, r31, 0x164
	ctx.r[4].s64 = ctx.r[31].s64 + 356;
	// 825ED608: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825ED60C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825ED610: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825ED614: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825ED618: 48871349  bl 0x82e5e960
	ctx.lr = 0x825ED61C;
	sub_82E5E960(ctx, base);
	// 825ED61C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825ED620: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825ED624: 419A0014  beq cr6, 0x825ed638
	if ctx.cr[6].eq {
	pc = 0x825ED638; continue 'dispatch;
	}
	// 825ED628: 4BCD3269  bl 0x822c0890
	ctx.lr = 0x825ED62C;
	sub_822C0890(ctx, base);
	// 825ED62C: 4800000C  b 0x825ed638
	pc = 0x825ED638; continue 'dispatch;
	// 825ED630: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825ED634: 4BF22F9D  bl 0x825105d0
	ctx.lr = 0x825ED638;
	sub_825105D0(ctx, base);
	// 825ED638: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825ED63C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825ED640: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825ED644: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825ED648: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825ED64C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825ED650(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825ED650 size=340
    let mut pc: u32 = 0x825ED650;
    'dispatch: loop {
        match pc {
            0x825ED650 => {
    //   block [0x825ED650..0x825ED7A4)
	// 825ED650: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825ED654: 48BBAB09  bl 0x831a815c
	ctx.lr = 0x825ED658;
	sub_831A8130(ctx, base);
	// 825ED658: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825ED65C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825ED660: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825ED664: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825ED668: 3B9E0040  addi r28, r30, 0x40
	ctx.r[28].s64 = ctx.r[30].s64 + 64;
	// 825ED66C: 815F0298  lwz r10, 0x298(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(664 as u32) ) } as u64;
	// 825ED670: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825ED674: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 825ED678: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825ED67C: 917F0298  stw r11, 0x298(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(664 as u32), ctx.r[11].u32 ) };
	// 825ED680: 4888E959  bl 0x82e7bfd8
	ctx.lr = 0x825ED684;
	sub_82E7BFD8(ctx, base);
	// 825ED684: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825ED688: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825ED68C: 3BABE1F4  addi r29, r11, -0x1e0c
	ctx.r[29].s64 = ctx.r[11].s64 + -7692;
	// 825ED690: 809D0040  lwz r4, 0x40(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(64 as u32) ) } as u64;
	// 825ED694: 48806375  bl 0x82df3a08
	ctx.lr = 0x825ED698;
	sub_82DF3A08(ctx, base);
	// 825ED698: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825ED69C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825ED6A0: 3B610050  addi r27, r1, 0x50
	ctx.r[27].s64 = ctx.r[1].s64 + 80;
	// 825ED6A4: 3B410080  addi r26, r1, 0x80
	ctx.r[26].s64 = ctx.r[1].s64 + 128;
	// 825ED6A8: 833F028C  lwz r25, 0x28c(r31)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(652 as u32) ) } as u64;
	// 825ED6AC: 4BF21E1D  bl 0x8250f4c8
	ctx.lr = 0x825ED6B0;
	sub_8250F4C8(ctx, base);
	// 825ED6B0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825ED6B4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825ED6B8: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 825ED6BC: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 825ED6C0: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 825ED6C4: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 825ED6C8: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825ED6CC: 481E1A85  bl 0x827cf150
	ctx.lr = 0x825ED6D0;
	sub_827CF150(ctx, base);
	// 825ED6D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825ED6D4: 48805D55  bl 0x82df3428
	ctx.lr = 0x825ED6D8;
	sub_82DF3428(ctx, base);
	// 825ED6D8: 817F0298  lwz r11, 0x298(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(664 as u32) ) } as u64;
	// 825ED6DC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825ED6E0: 41990028  bgt cr6, 0x825ed708
	if ctx.cr[6].gt {
	pc = 0x825ED708; continue 'dispatch;
	}
	// 825ED6E4: 817F01D4  lwz r11, 0x1d4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(468 as u32) ) } as u64;
	// 825ED6E8: 395DFFE0  addi r10, r29, -0x20
	ctx.r[10].s64 = ctx.r[29].s64 + -32;
	// 825ED6EC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825ED6F0: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 825ED6F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825ED6F8: 419A0010  beq cr6, 0x825ed708
	if ctx.cr[6].eq {
	pc = 0x825ED708; continue 'dispatch;
	}
	// 825ED6FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825ED700: 4BFFFE59  bl 0x825ed558
	ctx.lr = 0x825ED704;
	sub_825ED558(ctx, base);
	// 825ED704: 48000098  b 0x825ed79c
	pc = 0x825ED79C; continue 'dispatch;
	// 825ED708: 817F01D4  lwz r11, 0x1d4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(468 as u32) ) } as u64;
	// 825ED70C: 395DFF60  addi r10, r29, -0xa0
	ctx.r[10].s64 = ctx.r[29].s64 + -160;
	// 825ED710: 39200050  li r9, 0x50
	ctx.r[9].s64 = 80;
	// 825ED714: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825ED718: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 825ED71C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825ED720: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825ED724: 13FE48C7  vcmpequd (lvx128) v31, v30, v9
	tmp.u32 = ctx.r[30].u32 + ctx.r[9].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 825ED728: 13CB5407  vcmpneb. (lvlx128) v30, v11, v10
	tmp.u32 = ctx.r[11].u32 + ctx.r[10].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825ED7A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825ED7A8 size=892
    let mut pc: u32 = 0x825ED7A8;
    'dispatch: loop {
        match pc {
            0x825ED7A8 => {
    //   block [0x825ED7A8..0x825EDB24)
	// 825ED7A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825ED7AC: 48BBA9BD  bl 0x831a8168
	ctx.lr = 0x825ED7B0;
	sub_831A8130(ctx, base);
	// 825ED7B0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825ED7B4: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 825ED7B8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825ED7BC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825ED7C0: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 825ED7C4: 41820038  beq 0x825ed7fc
	if ctx.cr[0].eq {
	pc = 0x825ED7FC; continue 'dispatch;
	}
	// 825ED7C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825ED7CC: 48BBC1BD  bl 0x831a9988
	ctx.lr = 0x825ED7D0;
	sub_831A9988(ctx, base);
	// 825ED7D0: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 825ED7D4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825ED7D8: 386B5BA8  addi r3, r11, 0x5ba8
	ctx.r[3].s64 = ctx.r[11].s64 + 23464;
	// 825ED7DC: 48BBA91D  bl 0x831a80f8
	ctx.lr = 0x825ED7E0;
	sub_831A80F8(ctx, base);
	// 825ED7E0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825ED7E4: 41820018  beq 0x825ed7fc
	if ctx.cr[0].eq {
	pc = 0x825ED7FC; continue 'dispatch;
	}
	// 825ED7E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825ED7EC: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 825ED7F0: 4BFFE3A9  bl 0x825ebb98
	ctx.lr = 0x825ED7F4;
	sub_825EBB98(ctx, base);
	// 825ED7F4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 825ED7F8: 48000324  b 0x825edb1c
	pc = 0x825EDB1C; continue 'dispatch;
	// 825ED7FC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825ED800: 419A02DC  beq cr6, 0x825edadc
	if ctx.cr[6].eq {
	pc = 0x825EDADC; continue 'dispatch;
	}
	// 825ED804: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825ED808: 48BBC181  bl 0x831a9988
	ctx.lr = 0x825ED80C;
	sub_831A9988(ctx, base);
	// 825ED80C: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 825ED810: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825ED814: 386B5C00  addi r3, r11, 0x5c00
	ctx.r[3].s64 = ctx.r[11].s64 + 23552;
	// 825ED818: 48BBA8E1  bl 0x831a80f8
	ctx.lr = 0x825ED81C;
	sub_831A80F8(ctx, base);
	// 825ED81C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825ED820: 41820014  beq 0x825ed834
	if ctx.cr[0].eq {
	pc = 0x825ED834; continue 'dispatch;
	}
	// 825ED824: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825ED828: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 825ED82C: 4BFFD8BD  bl 0x825eb0e8
	ctx.lr = 0x825ED830;
	sub_825EB0E8(ctx, base);
	// 825ED830: 480002EC  b 0x825edb1c
	pc = 0x825EDB1C; continue 'dispatch;
	// 825ED834: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825ED838: 419A02A4  beq cr6, 0x825edadc
	if ctx.cr[6].eq {
	pc = 0x825EDADC; continue 'dispatch;
	}
	// 825ED83C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825ED840: 48BBC149  bl 0x831a9988
	ctx.lr = 0x825ED844;
	sub_831A9988(ctx, base);
	// 825ED844: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 825ED848: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825ED84C: 386BCB50  addi r3, r11, -0x34b0
	ctx.r[3].s64 = ctx.r[11].s64 + -13488;
	// 825ED850: 48BBA8A9  bl 0x831a80f8
	ctx.lr = 0x825ED854;
	sub_831A80F8(ctx, base);
	// 825ED854: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825ED858: 41820014  beq 0x825ed86c
	if ctx.cr[0].eq {
	pc = 0x825ED86C; continue 'dispatch;
	}
	// 825ED85C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825ED860: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 825ED864: 4BFFE37D  bl 0x825ebbe0
	ctx.lr = 0x825ED868;
	sub_825EBBE0(ctx, base);
	// 825ED868: 4BFFFF8C  b 0x825ed7f4
	pc = 0x825ED7F4; continue 'dispatch;
	// 825ED86C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825ED870: 419A026C  beq cr6, 0x825edadc
	if ctx.cr[6].eq {
	pc = 0x825EDADC; continue 'dispatch;
	}
	// 825ED874: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825ED878: 48BBC111  bl 0x831a9988
	ctx.lr = 0x825ED87C;
	sub_831A9988(ctx, base);
	// 825ED87C: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 825ED880: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825ED884: 386B3324  addi r3, r11, 0x3324
	ctx.r[3].s64 = ctx.r[11].s64 + 13092;
	// 825ED888: 48BBA871  bl 0x831a80f8
	ctx.lr = 0x825ED88C;
	sub_831A80F8(ctx, base);
	// 825ED88C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825ED890: 41820014  beq 0x825ed8a4
	if ctx.cr[0].eq {
	pc = 0x825ED8A4; continue 'dispatch;
	}
	// 825ED894: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825ED898: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 825ED89C: 4BFFE3B5  bl 0x825ebc50
	ctx.lr = 0x825ED8A0;
	sub_825EBC50(ctx, base);
	// 825ED8A0: 4800027C  b 0x825edb1c
	pc = 0x825EDB1C; continue 'dispatch;
	// 825ED8A4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825ED8A8: 419A0234  beq cr6, 0x825edadc
	if ctx.cr[6].eq {
	pc = 0x825EDADC; continue 'dispatch;
	}
	// 825ED8AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825ED8B0: 48BBC0D9  bl 0x831a9988
	ctx.lr = 0x825ED8B4;
	sub_831A9988(ctx, base);
	// 825ED8B4: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 825ED8B8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825ED8BC: 386B1D64  addi r3, r11, 0x1d64
	ctx.r[3].s64 = ctx.r[11].s64 + 7524;
	// 825ED8C0: 48BBA839  bl 0x831a80f8
	ctx.lr = 0x825ED8C4;
	sub_831A80F8(ctx, base);
	// 825ED8C4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825ED8C8: 41820014  beq 0x825ed8dc
	if ctx.cr[0].eq {
	pc = 0x825ED8DC; continue 'dispatch;
	}
	// 825ED8CC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825ED8D0: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 825ED8D4: 4BFFD85D  bl 0x825eb130
	ctx.lr = 0x825ED8D8;
	sub_825EB130(ctx, base);
	// 825ED8D8: 4BFFFF1C  b 0x825ed7f4
	pc = 0x825ED7F4; continue 'dispatch;
	// 825ED8DC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825ED8E0: 419A01FC  beq cr6, 0x825edadc
	if ctx.cr[6].eq {
	pc = 0x825EDADC; continue 'dispatch;
	}
	// 825ED8E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825ED8E8: 48BBC0A1  bl 0x831a9988
	ctx.lr = 0x825ED8EC;
	sub_831A9988(ctx, base);
	// 825ED8EC: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 825ED8F0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825ED8F4: 386B3984  addi r3, r11, 0x3984
	ctx.r[3].s64 = ctx.r[11].s64 + 14724;
	// 825ED8F8: 48BBA801  bl 0x831a80f8
	ctx.lr = 0x825ED8FC;
	sub_831A80F8(ctx, base);
	// 825ED8FC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825ED900: 41820014  beq 0x825ed914
	if ctx.cr[0].eq {
	pc = 0x825ED914; continue 'dispatch;
	}
	// 825ED904: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825ED908: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 825ED90C: 4BFFFD45  bl 0x825ed650
	ctx.lr = 0x825ED910;
	sub_825ED650(ctx, base);
	// 825ED910: 4BFFFEE4  b 0x825ed7f4
	pc = 0x825ED7F4; continue 'dispatch;
	// 825ED914: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825ED918: 419A01C4  beq cr6, 0x825edadc
	if ctx.cr[6].eq {
	pc = 0x825EDADC; continue 'dispatch;
	}
	// 825ED91C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825ED920: 48BBC069  bl 0x831a9988
	ctx.lr = 0x825ED924;
	sub_831A9988(ctx, base);
	// 825ED924: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825ED928: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825ED92C: 386BD9D8  addi r3, r11, -0x2628
	ctx.r[3].s64 = ctx.r[11].s64 + -9768;
	// 825ED930: 48BBA7C9  bl 0x831a80f8
	ctx.lr = 0x825ED934;
	sub_831A80F8(ctx, base);
	// 825ED934: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825ED938: 41820014  beq 0x825ed94c
	if ctx.cr[0].eq {
	pc = 0x825ED94C; continue 'dispatch;
	}
	// 825ED93C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825ED940: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 825ED944: 480D4BA5  bl 0x826c24e8
	ctx.lr = 0x825ED948;
	sub_826C24E8(ctx, base);
	// 825ED948: 4BFFFEAC  b 0x825ed7f4
	pc = 0x825ED7F4; continue 'dispatch;
	// 825ED94C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825ED950: 419A018C  beq cr6, 0x825edadc
	if ctx.cr[6].eq {
	pc = 0x825EDADC; continue 'dispatch;
	}
	// 825ED954: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825ED958: 48BBC031  bl 0x831a9988
	ctx.lr = 0x825ED95C;
	sub_831A9988(ctx, base);
	// 825ED95C: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 825ED960: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825ED964: 386B1FA4  addi r3, r11, 0x1fa4
	ctx.r[3].s64 = ctx.r[11].s64 + 8100;
	// 825ED968: 48BBA791  bl 0x831a80f8
	ctx.lr = 0x825ED96C;
	sub_831A80F8(ctx, base);
	// 825ED96C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825ED970: 41820014  beq 0x825ed984
	if ctx.cr[0].eq {
	pc = 0x825ED984; continue 'dispatch;
	}
	// 825ED974: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825ED978: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 825ED97C: 4BFFD80D  bl 0x825eb188
	ctx.lr = 0x825ED980;
	sub_825EB188(ctx, base);
	// 825ED980: 4BFFFE74  b 0x825ed7f4
	pc = 0x825ED7F4; continue 'dispatch;
	// 825ED984: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825ED988: 419A0154  beq cr6, 0x825edadc
	if ctx.cr[6].eq {
	pc = 0x825EDADC; continue 'dispatch;
	}
	// 825ED98C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825ED990: 48BBBFF9  bl 0x831a9988
	ctx.lr = 0x825ED994;
	sub_831A9988(ctx, base);
	// 825ED994: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 825ED998: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825ED99C: 386B3A18  addi r3, r11, 0x3a18
	ctx.r[3].s64 = ctx.r[11].s64 + 14872;
	// 825ED9A0: 48BBA759  bl 0x831a80f8
	ctx.lr = 0x825ED9A4;
	sub_831A80F8(ctx, base);
	// 825ED9A4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825ED9A8: 41820014  beq 0x825ed9bc
	if ctx.cr[0].eq {
	pc = 0x825ED9BC; continue 'dispatch;
	}
	// 825ED9AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825ED9B0: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 825ED9B4: 4BFFED35  bl 0x825ec6e8
	ctx.lr = 0x825ED9B8;
	sub_825EC6E8(ctx, base);
	// 825ED9B8: 4BFFFE3C  b 0x825ed7f4
	pc = 0x825ED7F4; continue 'dispatch;
	// 825ED9BC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825ED9C0: 419A011C  beq cr6, 0x825edadc
	if ctx.cr[6].eq {
	pc = 0x825EDADC; continue 'dispatch;
	}
	// 825ED9C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825ED9C8: 48BBBFC1  bl 0x831a9988
	ctx.lr = 0x825ED9CC;
	sub_831A9988(ctx, base);
	// 825ED9CC: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 825ED9D0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825ED9D4: 386BFE48  addi r3, r11, -0x1b8
	ctx.r[3].s64 = ctx.r[11].s64 + -440;
	// 825ED9D8: 48BBA721  bl 0x831a80f8
	ctx.lr = 0x825ED9DC;
	sub_831A80F8(ctx, base);
	// 825ED9DC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825ED9E0: 41820014  beq 0x825ed9f4
	if ctx.cr[0].eq {
	pc = 0x825ED9F4; continue 'dispatch;
	}
	// 825ED9E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825ED9E8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 825ED9EC: 4BFFED7D  bl 0x825ec768
	ctx.lr = 0x825ED9F0;
	sub_825EC768(ctx, base);
	// 825ED9F0: 4BFFFE04  b 0x825ed7f4
	pc = 0x825ED7F4; continue 'dispatch;
	// 825ED9F4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825ED9F8: 419A00E4  beq cr6, 0x825edadc
	if ctx.cr[6].eq {
	pc = 0x825EDADC; continue 'dispatch;
	}
	// 825ED9FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825EDA00: 48BBBF89  bl 0x831a9988
	ctx.lr = 0x825EDA04;
	sub_831A9988(ctx, base);
	// 825EDA04: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 825EDA08: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825EDA0C: 386BFD00  addi r3, r11, -0x300
	ctx.r[3].s64 = ctx.r[11].s64 + -768;
	// 825EDA10: 48BBA6E9  bl 0x831a80f8
	ctx.lr = 0x825EDA14;
	sub_831A80F8(ctx, base);
	// 825EDA14: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825EDA18: 41820014  beq 0x825eda2c
	if ctx.cr[0].eq {
	pc = 0x825EDA2C; continue 'dispatch;
	}
	// 825EDA1C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EDA20: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 825EDA24: 4BFFEDC5  bl 0x825ec7e8
	ctx.lr = 0x825EDA28;
	sub_825EC7E8(ctx, base);
	// 825EDA28: 4BFFFDCC  b 0x825ed7f4
	pc = 0x825ED7F4; continue 'dispatch;
	// 825EDA2C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825EDA30: 419A00AC  beq cr6, 0x825edadc
	if ctx.cr[6].eq {
	pc = 0x825EDADC; continue 'dispatch;
	}
	// 825EDA34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825EDA38: 48BBBF51  bl 0x831a9988
	ctx.lr = 0x825EDA3C;
	sub_831A9988(ctx, base);
	// 825EDA3C: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 825EDA40: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825EDA44: 386B39EC  addi r3, r11, 0x39ec
	ctx.r[3].s64 = ctx.r[11].s64 + 14828;
	// 825EDA48: 48BBA6B1  bl 0x831a80f8
	ctx.lr = 0x825EDA4C;
	sub_831A80F8(ctx, base);
	// 825EDA4C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825EDA50: 41820014  beq 0x825eda64
	if ctx.cr[0].eq {
	pc = 0x825EDA64; continue 'dispatch;
	}
	// 825EDA54: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EDA58: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 825EDA5C: 4BFFEF8D  bl 0x825ec9e8
	ctx.lr = 0x825EDA60;
	sub_825EC9E8(ctx, base);
	// 825EDA60: 4BFFFD94  b 0x825ed7f4
	pc = 0x825ED7F4; continue 'dispatch;
	// 825EDA64: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825EDA68: 419A0074  beq cr6, 0x825edadc
	if ctx.cr[6].eq {
	pc = 0x825EDADC; continue 'dispatch;
	}
	// 825EDA6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825EDA70: 48BBBF19  bl 0x831a9988
	ctx.lr = 0x825EDA74;
	sub_831A9988(ctx, base);
	// 825EDA74: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 825EDA78: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825EDA7C: 386B3A44  addi r3, r11, 0x3a44
	ctx.r[3].s64 = ctx.r[11].s64 + 14916;
	// 825EDA80: 48BBA679  bl 0x831a80f8
	ctx.lr = 0x825EDA84;
	sub_831A80F8(ctx, base);
	// 825EDA84: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825EDA88: 41820014  beq 0x825eda9c
	if ctx.cr[0].eq {
	pc = 0x825EDA9C; continue 'dispatch;
	}
	// 825EDA8C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EDA90: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 825EDA94: 4BFFD7F5  bl 0x825eb288
	ctx.lr = 0x825EDA98;
	sub_825EB288(ctx, base);
	// 825EDA98: 4BFFFD5C  b 0x825ed7f4
	pc = 0x825ED7F4; continue 'dispatch;
	// 825EDA9C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825EDAA0: 419A003C  beq cr6, 0x825edadc
	if ctx.cr[6].eq {
	pc = 0x825EDADC; continue 'dispatch;
	}
	// 825EDAA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825EDAA8: 48BBBEE1  bl 0x831a9988
	ctx.lr = 0x825EDAAC;
	sub_831A9988(ctx, base);
	// 825EDAAC: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 825EDAB0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825EDAB4: 386B66B4  addi r3, r11, 0x66b4
	ctx.r[3].s64 = ctx.r[11].s64 + 26292;
	// 825EDAB8: 48BBA641  bl 0x831a80f8
	ctx.lr = 0x825EDABC;
	sub_831A80F8(ctx, base);
	// 825EDABC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825EDAC0: 41820014  beq 0x825edad4
	if ctx.cr[0].eq {
	pc = 0x825EDAD4; continue 'dispatch;
	}
	// 825EDAC4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EDAC8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 825EDACC: 4BFFD785  bl 0x825eb250
	ctx.lr = 0x825EDAD0;
	sub_825EB250(ctx, base);
	// 825EDAD0: 4BFFFD24  b 0x825ed7f4
	pc = 0x825ED7F4; continue 'dispatch;
	// 825EDAD4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825EDAD8: 409A0034  bne cr6, 0x825edb0c
	if !ctx.cr[6].eq {
	pc = 0x825EDB0C; continue 'dispatch;
	}
	// 825EDADC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825EDAE0: 48BBBEA9  bl 0x831a9988
	ctx.lr = 0x825EDAE4;
	sub_831A9988(ctx, base);
	// 825EDAE4: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825EDAE8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825EDAEC: 386BE6C4  addi r3, r11, -0x193c
	ctx.r[3].s64 = ctx.r[11].s64 + -6460;
	// 825EDAF0: 48BBA609  bl 0x831a80f8
	ctx.lr = 0x825EDAF4;
	sub_831A80F8(ctx, base);
	// 825EDAF4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825EDAF8: 41820014  beq 0x825edb0c
	if ctx.cr[0].eq {
	pc = 0x825EDB0C; continue 'dispatch;
	}
	// 825EDAFC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EDB00: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 825EDB04: 4BCD24FD  bl 0x822c0000
	ctx.lr = 0x825EDB08;
	sub_822C0000(ctx, base);
	// 825EDB08: 4BFFFCEC  b 0x825ed7f4
	pc = 0x825ED7F4; continue 'dispatch;
	// 825EDB0C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 825EDB10: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EDB14: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EDB18: 4BF26199  bl 0x82513cb0
	ctx.lr = 0x825EDB1C;
	sub_82513CB0(ctx, base);
	// 825EDB1C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825EDB20: 48BBA698  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EDB28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825EDB28 size=136
    let mut pc: u32 = 0x825EDB28;
    'dispatch: loop {
        match pc {
            0x825EDB28 => {
    //   block [0x825EDB28..0x825EDBB0)
	// 825EDB28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EDB2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825EDB30: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825EDB34: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825EDB38: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EDB3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825EDB40: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825EDB44: 4BF22BC5  bl 0x82510708
	ctx.lr = 0x825EDB48;
	sub_82510708(ctx, base);
	// 825EDB48: C01E0000  lfs f0, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825EDB4C: 387F0164  addi r3, r31, 0x164
	ctx.r[3].s64 = ctx.r[31].s64 + 356;
	// 825EDB50: D01F024C  stfs f0, 0x24c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(588 as u32), tmp.u32 ) };
	// 825EDB54: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825EDB58: 4886F321  bl 0x82e5ce78
	ctx.lr = 0x825EDB5C;
	sub_82E5CE78(ctx, base);
	// 825EDB5C: 817F0248  lwz r11, 0x248(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(584 as u32) ) } as u64;
	// 825EDB60: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825EDB64: 419A0034  beq cr6, 0x825edb98
	if ctx.cr[6].eq {
	pc = 0x825EDB98; continue 'dispatch;
	}
	// 825EDB68: 817F01D4  lwz r11, 0x1d4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(468 as u32) ) } as u64;
	// 825EDB6C: 3D408329  lis r10, -0x7cd7
	ctx.r[10].s64 = -2094465024;
	// 825EDB70: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825EDB74: 394AE1D4  addi r10, r10, -0x1e2c
	ctx.r[10].s64 = ctx.r[10].s64 + -7724;
	// 825EDB78: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825EDB7C: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 825EDB80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825EDB84: 419A0010  beq cr6, 0x825edb94
	if ctx.cr[6].eq {
	pc = 0x825EDB94; continue 'dispatch;
	}
	// 825EDB88: 93DF0298  stw r30, 0x298(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(664 as u32), ctx.r[30].u32 ) };
	// 825EDB8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825EDB90: 4BFFF9C9  bl 0x825ed558
	ctx.lr = 0x825EDB94;
	sub_825ED558(ctx, base);
	// 825EDB94: 93DF0248  stw r30, 0x248(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(584 as u32), ctx.r[30].u32 ) };
	// 825EDB98: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825EDB9C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825EDBA0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825EDBA4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825EDBA8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825EDBAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EDBB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825EDBB0 size=548
    let mut pc: u32 = 0x825EDBB0;
    'dispatch: loop {
        match pc {
            0x825EDBB0 => {
    //   block [0x825EDBB0..0x825EDDD4)
	// 825EDBB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EDBB4: 48BBA5AD  bl 0x831a8160
	ctx.lr = 0x825EDBB8;
	sub_831A8130(ctx, base);
	// 825EDBB8: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EDBBC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825EDBC0: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 825EDBC4: 3BCB03E8  addi r30, r11, 0x3e8
	ctx.r[30].s64 = ctx.r[11].s64 + 1000;
	// 825EDBC8: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 825EDBCC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825EDBD0: 38A000CC  li r5, 0xcc
	ctx.r[5].s64 = 204;
	// 825EDBD4: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 825EDBD8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825EDBDC: 38600090  li r3, 0x90
	ctx.r[3].s64 = 144;
	// 825EDBE0: 48804809  bl 0x82df23e8
	ctx.lr = 0x825EDBE4;
	sub_82DF23E8(ctx, base);
	// 825EDBE4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825EDBE8: 41820018  beq 0x825edc00
	if ctx.cr[0].eq {
	pc = 0x825EDC00; continue 'dispatch;
	}
	// 825EDBEC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825EDBF0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825EDBF4: 396B01DC  addi r11, r11, 0x1dc
	ctx.r[11].s64 = ctx.r[11].s64 + 476;
	// 825EDBF8: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825EDBFC: 48000008  b 0x825edc04
	pc = 0x825EDC04; continue 'dispatch;
	// 825EDC00: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825EDC04: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 825EDC08: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EDC0C: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825EDC10: 4BFFD769  bl 0x825eb378
	ctx.lr = 0x825EDC14;
	sub_825EB378(ctx, base);
	// 825EDC14: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825EDC18: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EDC1C: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825EDC20: 4BCD23E1  bl 0x822c0000
	ctx.lr = 0x825EDC24;
	sub_822C0000(ctx, base);
	// 825EDC24: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825EDC28: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825EDC2C: 38A000CD  li r5, 0xcd
	ctx.r[5].s64 = 205;
	// 825EDC30: 386002B0  li r3, 0x2b0
	ctx.r[3].s64 = 688;
	// 825EDC34: 488047B5  bl 0x82df23e8
	ctx.lr = 0x825EDC38;
	sub_82DF23E8(ctx, base);
	// 825EDC38: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 825EDC3C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825EDC40: 3B8BBA80  addi r28, r11, -0x4580
	ctx.r[28].s64 = ctx.r[11].s64 + -17792;
	// 825EDC44: 41820024  beq 0x825edc68
	if ctx.cr[0].eq {
	pc = 0x825EDC68; continue 'dispatch;
	}
	// 825EDC48: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 825EDC4C: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 825EDC50: 38AB6910  addi r5, r11, 0x6910
	ctx.r[5].s64 = ctx.r[11].s64 + 26896;
	// 825EDC54: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 825EDC58: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825EDC5C: 4BFFF32D  bl 0x825ecf88
	ctx.lr = 0x825EDC60;
	sub_825ECF88(ctx, base);
	// 825EDC60: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825EDC64: 48000008  b 0x825edc6c
	pc = 0x825EDC6C; continue 'dispatch;
	// 825EDC68: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825EDC6C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825EDC70: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EDC74: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825EDC78: 4BFFD7B1  bl 0x825eb428
	ctx.lr = 0x825EDC7C;
	sub_825EB428(ctx, base);
	// 825EDC7C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825EDC80: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EDC84: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825EDC88: 4BCD2379  bl 0x822c0000
	ctx.lr = 0x825EDC8C;
	sub_822C0000(ctx, base);
	// 825EDC8C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825EDC90: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825EDC94: 38A000CE  li r5, 0xce
	ctx.r[5].s64 = 206;
	// 825EDC98: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825EDC9C: 4BCD273D  bl 0x822c03d8
	ctx.lr = 0x825EDCA0;
	sub_822C03D8(ctx, base);
	// 825EDCA0: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825EDCA4: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825EDCA8: 418200B0  beq 0x825edd58
	if ctx.cr[0].eq {
	pc = 0x825EDD58; continue 'dispatch;
	}
	// 825EDCAC: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825EDCB0: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 825EDCB4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825EDCB8: 396A0160  addi r11, r10, 0x160
	ctx.r[11].s64 = ctx.r[10].s64 + 352;
	// 825EDCBC: 409A0008  bne cr6, 0x825edcc4
	if !ctx.cr[6].eq {
	pc = 0x825EDCC4; continue 'dispatch;
	}
	// 825EDCC0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825EDCC4: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825EDCC8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825EDCCC: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 825EDCD0: 419A0024  beq cr6, 0x825edcf4
	if ctx.cr[6].eq {
	pc = 0x825EDCF4; continue 'dispatch;
	}
	// 825EDCD4: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825EDCD8: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 825EDCDC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825EDCE0: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 825EDCE4: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 825EDCE8: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825EDCEC: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825EDCF0: 4082FFE8  bne 0x825edcd8
	if !ctx.cr[0].eq {
	pc = 0x825EDCD8; continue 'dispatch;
	}
	// 825EDCF4: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 825EDCF8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825EDCFC: 93A1006C  stw r29, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[29].u32 ) };
	// 825EDD00: 419A0024  beq cr6, 0x825edd24
	if ctx.cr[6].eq {
	pc = 0x825EDD24; continue 'dispatch;
	}
	// 825EDD04: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825EDD08: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825EDD0C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825EDD10: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825EDD14: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825EDD18: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825EDD1C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825EDD20: 4082FFE8  bne 0x825edd08
	if !ctx.cr[0].eq {
	pc = 0x825EDD08; continue 'dispatch;
	}
	// 825EDD24: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825EDD28: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 825EDD2C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 825EDD30: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 825EDD34: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 825EDD38: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825EDD3C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825EDD40: 481AB1F1  bl 0x82798f30
	ctx.lr = 0x825EDD44;
	sub_82798F30(ctx, base);
	// 825EDD44: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825EDD48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825EDD4C: 481AD91D  bl 0x8279b668
	ctx.lr = 0x825EDD50;
	sub_8279B668(ctx, base);
	// 825EDD50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825EDD54: 48000008  b 0x825edd5c
	pc = 0x825EDD5C; continue 'dispatch;
	// 825EDD58: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825EDD5C: 93FA0000  stw r31, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825EDD60: 3BDA0004  addi r30, r26, 4
	ctx.r[30].s64 = ctx.r[26].s64 + 4;
	// 825EDD64: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EDD68: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EDD6C: 4BFA9EE5  bl 0x82597c50
	ctx.lr = 0x825EDD70;
	sub_82597C50(ctx, base);
	// 825EDD70: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825EDD74: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EDD78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EDD7C: 4BCD2285  bl 0x822c0000
	ctx.lr = 0x825EDD80;
	sub_822C0000(ctx, base);
	// 825EDD80: 576B07FF  clrlwi. r11, r27, 0x1f
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825EDD84: 41820024  beq 0x825edda8
	if ctx.cr[0].eq {
	pc = 0x825EDDA8; continue 'dispatch;
	}
	// 825EDD88: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 825EDD8C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EDD90: 419A0008  beq cr6, 0x825edd98
	if ctx.cr[6].eq {
	pc = 0x825EDD98; continue 'dispatch;
	}
	// 825EDD94: 4BCD2AFD  bl 0x822c0890
	ctx.lr = 0x825EDD98;
	sub_822C0890(ctx, base);
	// 825EDD98: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825EDD9C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EDDA0: 419A0008  beq cr6, 0x825edda8
	if ctx.cr[6].eq {
	pc = 0x825EDDA8; continue 'dispatch;
	}
	// 825EDDA4: 4BCD2AED  bl 0x822c0890
	ctx.lr = 0x825EDDA8;
	sub_822C0890(ctx, base);
	// 825EDDA8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825EDDAC: 419A000C  beq cr6, 0x825eddb8
	if ctx.cr[6].eq {
	pc = 0x825EDDB8; continue 'dispatch;
	}
	// 825EDDB0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825EDDB4: 4BCD2ADD  bl 0x822c0890
	ctx.lr = 0x825EDDB8;
	sub_822C0890(ctx, base);
	// 825EDDB8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825EDDBC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EDDC0: 419A0008  beq cr6, 0x825eddc8
	if ctx.cr[6].eq {
	pc = 0x825EDDC8; continue 'dispatch;
	}
	// 825EDDC4: 4BCD2ACD  bl 0x822c0890
	ctx.lr = 0x825EDDC8;
	sub_822C0890(ctx, base);
	// 825EDDC8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825EDDCC: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 825EDDD0: 48BBA3E0  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EDDD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825EDDD8 size=548
    let mut pc: u32 = 0x825EDDD8;
    'dispatch: loop {
        match pc {
            0x825EDDD8 => {
    //   block [0x825EDDD8..0x825EDFFC)
	// 825EDDD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EDDDC: 48BBA385  bl 0x831a8160
	ctx.lr = 0x825EDDE0;
	sub_831A8130(ctx, base);
	// 825EDDE0: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EDDE4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825EDDE8: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 825EDDEC: 3BCB03E8  addi r30, r11, 0x3e8
	ctx.r[30].s64 = ctx.r[11].s64 + 1000;
	// 825EDDF0: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 825EDDF4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825EDDF8: 38A000D3  li r5, 0xd3
	ctx.r[5].s64 = 211;
	// 825EDDFC: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 825EDE00: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825EDE04: 38600090  li r3, 0x90
	ctx.r[3].s64 = 144;
	// 825EDE08: 488045E1  bl 0x82df23e8
	ctx.lr = 0x825EDE0C;
	sub_82DF23E8(ctx, base);
	// 825EDE0C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825EDE10: 41820018  beq 0x825ede28
	if ctx.cr[0].eq {
	pc = 0x825EDE28; continue 'dispatch;
	}
	// 825EDE14: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825EDE18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825EDE1C: 396B01DC  addi r11, r11, 0x1dc
	ctx.r[11].s64 = ctx.r[11].s64 + 476;
	// 825EDE20: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825EDE24: 48000008  b 0x825ede2c
	pc = 0x825EDE2C; continue 'dispatch;
	// 825EDE28: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825EDE2C: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 825EDE30: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EDE34: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825EDE38: 4BFFD541  bl 0x825eb378
	ctx.lr = 0x825EDE3C;
	sub_825EB378(ctx, base);
	// 825EDE3C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825EDE40: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EDE44: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825EDE48: 4BCD21B9  bl 0x822c0000
	ctx.lr = 0x825EDE4C;
	sub_822C0000(ctx, base);
	// 825EDE4C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825EDE50: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825EDE54: 38A000D4  li r5, 0xd4
	ctx.r[5].s64 = 212;
	// 825EDE58: 386002B0  li r3, 0x2b0
	ctx.r[3].s64 = 688;
	// 825EDE5C: 4880458D  bl 0x82df23e8
	ctx.lr = 0x825EDE60;
	sub_82DF23E8(ctx, base);
	// 825EDE60: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 825EDE64: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825EDE68: 3B8BBA80  addi r28, r11, -0x4580
	ctx.r[28].s64 = ctx.r[11].s64 + -17792;
	// 825EDE6C: 41820024  beq 0x825ede90
	if ctx.cr[0].eq {
	pc = 0x825EDE90; continue 'dispatch;
	}
	// 825EDE70: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 825EDE74: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 825EDE78: 38AB6910  addi r5, r11, 0x6910
	ctx.r[5].s64 = ctx.r[11].s64 + 26896;
	// 825EDE7C: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 825EDE80: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825EDE84: 4BFFF105  bl 0x825ecf88
	ctx.lr = 0x825EDE88;
	sub_825ECF88(ctx, base);
	// 825EDE88: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825EDE8C: 48000008  b 0x825ede94
	pc = 0x825EDE94; continue 'dispatch;
	// 825EDE90: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825EDE94: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825EDE98: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EDE9C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825EDEA0: 4BFFD589  bl 0x825eb428
	ctx.lr = 0x825EDEA4;
	sub_825EB428(ctx, base);
	// 825EDEA4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825EDEA8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EDEAC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825EDEB0: 4BCD2151  bl 0x822c0000
	ctx.lr = 0x825EDEB4;
	sub_822C0000(ctx, base);
	// 825EDEB4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825EDEB8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825EDEBC: 38A000D5  li r5, 0xd5
	ctx.r[5].s64 = 213;
	// 825EDEC0: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825EDEC4: 4BCD2515  bl 0x822c03d8
	ctx.lr = 0x825EDEC8;
	sub_822C03D8(ctx, base);
	// 825EDEC8: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825EDECC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825EDED0: 418200B0  beq 0x825edf80
	if ctx.cr[0].eq {
	pc = 0x825EDF80; continue 'dispatch;
	}
	// 825EDED4: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825EDED8: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 825EDEDC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825EDEE0: 396A0160  addi r11, r10, 0x160
	ctx.r[11].s64 = ctx.r[10].s64 + 352;
	// 825EDEE4: 409A0008  bne cr6, 0x825edeec
	if !ctx.cr[6].eq {
	pc = 0x825EDEEC; continue 'dispatch;
	}
	// 825EDEE8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825EDEEC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825EDEF0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825EDEF4: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 825EDEF8: 419A0024  beq cr6, 0x825edf1c
	if ctx.cr[6].eq {
	pc = 0x825EDF1C; continue 'dispatch;
	}
	// 825EDEFC: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825EDF00: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 825EDF04: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825EDF08: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 825EDF0C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 825EDF10: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825EDF14: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825EDF18: 4082FFE8  bne 0x825edf00
	if !ctx.cr[0].eq {
	pc = 0x825EDF00; continue 'dispatch;
	}
	// 825EDF1C: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 825EDF20: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825EDF24: 93A1006C  stw r29, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[29].u32 ) };
	// 825EDF28: 419A0024  beq cr6, 0x825edf4c
	if ctx.cr[6].eq {
	pc = 0x825EDF4C; continue 'dispatch;
	}
	// 825EDF2C: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825EDF30: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825EDF34: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825EDF38: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825EDF3C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825EDF40: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825EDF44: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825EDF48: 4082FFE8  bne 0x825edf30
	if !ctx.cr[0].eq {
	pc = 0x825EDF30; continue 'dispatch;
	}
	// 825EDF4C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825EDF50: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 825EDF54: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 825EDF58: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 825EDF5C: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 825EDF60: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825EDF64: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825EDF68: 481AAFC9  bl 0x82798f30
	ctx.lr = 0x825EDF6C;
	sub_82798F30(ctx, base);
	// 825EDF6C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825EDF70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825EDF74: 481AD6F5  bl 0x8279b668
	ctx.lr = 0x825EDF78;
	sub_8279B668(ctx, base);
	// 825EDF78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825EDF7C: 48000008  b 0x825edf84
	pc = 0x825EDF84; continue 'dispatch;
	// 825EDF80: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825EDF84: 93FA0000  stw r31, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825EDF88: 3BDA0004  addi r30, r26, 4
	ctx.r[30].s64 = ctx.r[26].s64 + 4;
	// 825EDF8C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EDF90: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EDF94: 4BFA9CBD  bl 0x82597c50
	ctx.lr = 0x825EDF98;
	sub_82597C50(ctx, base);
	// 825EDF98: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825EDF9C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EDFA0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EDFA4: 4BCD205D  bl 0x822c0000
	ctx.lr = 0x825EDFA8;
	sub_822C0000(ctx, base);
	// 825EDFA8: 576B07FF  clrlwi. r11, r27, 0x1f
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825EDFAC: 41820024  beq 0x825edfd0
	if ctx.cr[0].eq {
	pc = 0x825EDFD0; continue 'dispatch;
	}
	// 825EDFB0: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 825EDFB4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EDFB8: 419A0008  beq cr6, 0x825edfc0
	if ctx.cr[6].eq {
	pc = 0x825EDFC0; continue 'dispatch;
	}
	// 825EDFBC: 4BCD28D5  bl 0x822c0890
	ctx.lr = 0x825EDFC0;
	sub_822C0890(ctx, base);
	// 825EDFC0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825EDFC4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EDFC8: 419A0008  beq cr6, 0x825edfd0
	if ctx.cr[6].eq {
	pc = 0x825EDFD0; continue 'dispatch;
	}
	// 825EDFCC: 4BCD28C5  bl 0x822c0890
	ctx.lr = 0x825EDFD0;
	sub_822C0890(ctx, base);
	// 825EDFD0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825EDFD4: 419A000C  beq cr6, 0x825edfe0
	if ctx.cr[6].eq {
	pc = 0x825EDFE0; continue 'dispatch;
	}
	// 825EDFD8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825EDFDC: 4BCD28B5  bl 0x822c0890
	ctx.lr = 0x825EDFE0;
	sub_822C0890(ctx, base);
	// 825EDFE0: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825EDFE4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EDFE8: 419A0008  beq cr6, 0x825edff0
	if ctx.cr[6].eq {
	pc = 0x825EDFF0; continue 'dispatch;
	}
	// 825EDFEC: 4BCD28A5  bl 0x822c0890
	ctx.lr = 0x825EDFF0;
	sub_822C0890(ctx, base);
	// 825EDFF0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825EDFF4: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 825EDFF8: 48BBA1B8  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EE000(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825EE000 size=548
    let mut pc: u32 = 0x825EE000;
    'dispatch: loop {
        match pc {
            0x825EE000 => {
    //   block [0x825EE000..0x825EE224)
	// 825EE000: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EE004: 48BBA15D  bl 0x831a8160
	ctx.lr = 0x825EE008;
	sub_831A8130(ctx, base);
	// 825EE008: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EE00C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825EE010: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 825EE014: 3BCB03E8  addi r30, r11, 0x3e8
	ctx.r[30].s64 = ctx.r[11].s64 + 1000;
	// 825EE018: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 825EE01C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825EE020: 38A000DA  li r5, 0xda
	ctx.r[5].s64 = 218;
	// 825EE024: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 825EE028: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825EE02C: 38600090  li r3, 0x90
	ctx.r[3].s64 = 144;
	// 825EE030: 488043B9  bl 0x82df23e8
	ctx.lr = 0x825EE034;
	sub_82DF23E8(ctx, base);
	// 825EE034: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825EE038: 41820018  beq 0x825ee050
	if ctx.cr[0].eq {
	pc = 0x825EE050; continue 'dispatch;
	}
	// 825EE03C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825EE040: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825EE044: 396B01DC  addi r11, r11, 0x1dc
	ctx.r[11].s64 = ctx.r[11].s64 + 476;
	// 825EE048: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825EE04C: 48000008  b 0x825ee054
	pc = 0x825EE054; continue 'dispatch;
	// 825EE050: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825EE054: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 825EE058: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EE05C: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825EE060: 4BFFD319  bl 0x825eb378
	ctx.lr = 0x825EE064;
	sub_825EB378(ctx, base);
	// 825EE064: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825EE068: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EE06C: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825EE070: 4BCD1F91  bl 0x822c0000
	ctx.lr = 0x825EE074;
	sub_822C0000(ctx, base);
	// 825EE074: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825EE078: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825EE07C: 38A000DB  li r5, 0xdb
	ctx.r[5].s64 = 219;
	// 825EE080: 386002B0  li r3, 0x2b0
	ctx.r[3].s64 = 688;
	// 825EE084: 48804365  bl 0x82df23e8
	ctx.lr = 0x825EE088;
	sub_82DF23E8(ctx, base);
	// 825EE088: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 825EE08C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825EE090: 3B8BBA80  addi r28, r11, -0x4580
	ctx.r[28].s64 = ctx.r[11].s64 + -17792;
	// 825EE094: 41820024  beq 0x825ee0b8
	if ctx.cr[0].eq {
	pc = 0x825EE0B8; continue 'dispatch;
	}
	// 825EE098: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 825EE09C: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 825EE0A0: 38AB6910  addi r5, r11, 0x6910
	ctx.r[5].s64 = ctx.r[11].s64 + 26896;
	// 825EE0A4: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 825EE0A8: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 825EE0AC: 4BFFEEDD  bl 0x825ecf88
	ctx.lr = 0x825EE0B0;
	sub_825ECF88(ctx, base);
	// 825EE0B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825EE0B4: 48000008  b 0x825ee0bc
	pc = 0x825EE0BC; continue 'dispatch;
	// 825EE0B8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825EE0BC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825EE0C0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EE0C4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825EE0C8: 4BFFD361  bl 0x825eb428
	ctx.lr = 0x825EE0CC;
	sub_825EB428(ctx, base);
	// 825EE0CC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825EE0D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EE0D4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825EE0D8: 4BCD1F29  bl 0x822c0000
	ctx.lr = 0x825EE0DC;
	sub_822C0000(ctx, base);
	// 825EE0DC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825EE0E0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825EE0E4: 38A000DC  li r5, 0xdc
	ctx.r[5].s64 = 220;
	// 825EE0E8: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825EE0EC: 4BCD22ED  bl 0x822c03d8
	ctx.lr = 0x825EE0F0;
	sub_822C03D8(ctx, base);
	// 825EE0F0: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825EE0F4: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825EE0F8: 418200B0  beq 0x825ee1a8
	if ctx.cr[0].eq {
	pc = 0x825EE1A8; continue 'dispatch;
	}
	// 825EE0FC: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825EE100: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 825EE104: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825EE108: 396A0160  addi r11, r10, 0x160
	ctx.r[11].s64 = ctx.r[10].s64 + 352;
	// 825EE10C: 409A0008  bne cr6, 0x825ee114
	if !ctx.cr[6].eq {
	pc = 0x825EE114; continue 'dispatch;
	}
	// 825EE110: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825EE114: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825EE118: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825EE11C: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 825EE120: 419A0024  beq cr6, 0x825ee144
	if ctx.cr[6].eq {
	pc = 0x825EE144; continue 'dispatch;
	}
	// 825EE124: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825EE128: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 825EE12C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825EE130: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 825EE134: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 825EE138: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825EE13C: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825EE140: 4082FFE8  bne 0x825ee128
	if !ctx.cr[0].eq {
	pc = 0x825EE128; continue 'dispatch;
	}
	// 825EE144: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 825EE148: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825EE14C: 93A1006C  stw r29, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[29].u32 ) };
	// 825EE150: 419A0024  beq cr6, 0x825ee174
	if ctx.cr[6].eq {
	pc = 0x825EE174; continue 'dispatch;
	}
	// 825EE154: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825EE158: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825EE15C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825EE160: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825EE164: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825EE168: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825EE16C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825EE170: 4082FFE8  bne 0x825ee158
	if !ctx.cr[0].eq {
	pc = 0x825EE158; continue 'dispatch;
	}
	// 825EE174: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825EE178: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 825EE17C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 825EE180: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 825EE184: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 825EE188: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825EE18C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825EE190: 481AADA1  bl 0x82798f30
	ctx.lr = 0x825EE194;
	sub_82798F30(ctx, base);
	// 825EE194: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825EE198: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825EE19C: 481AD4CD  bl 0x8279b668
	ctx.lr = 0x825EE1A0;
	sub_8279B668(ctx, base);
	// 825EE1A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825EE1A4: 48000008  b 0x825ee1ac
	pc = 0x825EE1AC; continue 'dispatch;
	// 825EE1A8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825EE1AC: 93FA0000  stw r31, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825EE1B0: 3BDA0004  addi r30, r26, 4
	ctx.r[30].s64 = ctx.r[26].s64 + 4;
	// 825EE1B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EE1B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EE1BC: 4BFA9A95  bl 0x82597c50
	ctx.lr = 0x825EE1C0;
	sub_82597C50(ctx, base);
	// 825EE1C0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825EE1C4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EE1C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EE1CC: 4BCD1E35  bl 0x822c0000
	ctx.lr = 0x825EE1D0;
	sub_822C0000(ctx, base);
	// 825EE1D0: 576B07FF  clrlwi. r11, r27, 0x1f
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825EE1D4: 41820024  beq 0x825ee1f8
	if ctx.cr[0].eq {
	pc = 0x825EE1F8; continue 'dispatch;
	}
	// 825EE1D8: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 825EE1DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EE1E0: 419A0008  beq cr6, 0x825ee1e8
	if ctx.cr[6].eq {
	pc = 0x825EE1E8; continue 'dispatch;
	}
	// 825EE1E4: 4BCD26AD  bl 0x822c0890
	ctx.lr = 0x825EE1E8;
	sub_822C0890(ctx, base);
	// 825EE1E8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825EE1EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EE1F0: 419A0008  beq cr6, 0x825ee1f8
	if ctx.cr[6].eq {
	pc = 0x825EE1F8; continue 'dispatch;
	}
	// 825EE1F4: 4BCD269D  bl 0x822c0890
	ctx.lr = 0x825EE1F8;
	sub_822C0890(ctx, base);
	// 825EE1F8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825EE1FC: 419A000C  beq cr6, 0x825ee208
	if ctx.cr[6].eq {
	pc = 0x825EE208; continue 'dispatch;
	}
	// 825EE200: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825EE204: 4BCD268D  bl 0x822c0890
	ctx.lr = 0x825EE208;
	sub_822C0890(ctx, base);
	// 825EE208: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825EE20C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EE210: 419A0008  beq cr6, 0x825ee218
	if ctx.cr[6].eq {
	pc = 0x825EE218; continue 'dispatch;
	}
	// 825EE214: 4BCD267D  bl 0x822c0890
	ctx.lr = 0x825EE218;
	sub_822C0890(ctx, base);
	// 825EE218: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825EE21C: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 825EE220: 48BB9F90  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EE228(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825EE228 size=548
    let mut pc: u32 = 0x825EE228;
    'dispatch: loop {
        match pc {
            0x825EE228 => {
    //   block [0x825EE228..0x825EE44C)
	// 825EE228: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EE22C: 48BB9F35  bl 0x831a8160
	ctx.lr = 0x825EE230;
	sub_831A8130(ctx, base);
	// 825EE230: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EE234: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825EE238: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 825EE23C: 3BCB03E8  addi r30, r11, 0x3e8
	ctx.r[30].s64 = ctx.r[11].s64 + 1000;
	// 825EE240: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 825EE244: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825EE248: 38A000E1  li r5, 0xe1
	ctx.r[5].s64 = 225;
	// 825EE24C: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 825EE250: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825EE254: 38600090  li r3, 0x90
	ctx.r[3].s64 = 144;
	// 825EE258: 48804191  bl 0x82df23e8
	ctx.lr = 0x825EE25C;
	sub_82DF23E8(ctx, base);
	// 825EE25C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825EE260: 41820018  beq 0x825ee278
	if ctx.cr[0].eq {
	pc = 0x825EE278; continue 'dispatch;
	}
	// 825EE264: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825EE268: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825EE26C: 396B01DC  addi r11, r11, 0x1dc
	ctx.r[11].s64 = ctx.r[11].s64 + 476;
	// 825EE270: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825EE274: 48000008  b 0x825ee27c
	pc = 0x825EE27C; continue 'dispatch;
	// 825EE278: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825EE27C: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 825EE280: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EE284: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825EE288: 4BFFD0F1  bl 0x825eb378
	ctx.lr = 0x825EE28C;
	sub_825EB378(ctx, base);
	// 825EE28C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825EE290: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EE294: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825EE298: 4BCD1D69  bl 0x822c0000
	ctx.lr = 0x825EE29C;
	sub_822C0000(ctx, base);
	// 825EE29C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825EE2A0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825EE2A4: 38A000E2  li r5, 0xe2
	ctx.r[5].s64 = 226;
	// 825EE2A8: 386002B0  li r3, 0x2b0
	ctx.r[3].s64 = 688;
	// 825EE2AC: 4880413D  bl 0x82df23e8
	ctx.lr = 0x825EE2B0;
	sub_82DF23E8(ctx, base);
	// 825EE2B0: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 825EE2B4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825EE2B8: 3B8BBA80  addi r28, r11, -0x4580
	ctx.r[28].s64 = ctx.r[11].s64 + -17792;
	// 825EE2BC: 41820024  beq 0x825ee2e0
	if ctx.cr[0].eq {
	pc = 0x825EE2E0; continue 'dispatch;
	}
	// 825EE2C0: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 825EE2C4: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 825EE2C8: 38AB6910  addi r5, r11, 0x6910
	ctx.r[5].s64 = ctx.r[11].s64 + 26896;
	// 825EE2CC: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 825EE2D0: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 825EE2D4: 4BFFECB5  bl 0x825ecf88
	ctx.lr = 0x825EE2D8;
	sub_825ECF88(ctx, base);
	// 825EE2D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825EE2DC: 48000008  b 0x825ee2e4
	pc = 0x825EE2E4; continue 'dispatch;
	// 825EE2E0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825EE2E4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825EE2E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EE2EC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825EE2F0: 4BFFD139  bl 0x825eb428
	ctx.lr = 0x825EE2F4;
	sub_825EB428(ctx, base);
	// 825EE2F4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825EE2F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EE2FC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825EE300: 4BCD1D01  bl 0x822c0000
	ctx.lr = 0x825EE304;
	sub_822C0000(ctx, base);
	// 825EE304: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825EE308: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825EE30C: 38A000E3  li r5, 0xe3
	ctx.r[5].s64 = 227;
	// 825EE310: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825EE314: 4BCD20C5  bl 0x822c03d8
	ctx.lr = 0x825EE318;
	sub_822C03D8(ctx, base);
	// 825EE318: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825EE31C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825EE320: 418200B0  beq 0x825ee3d0
	if ctx.cr[0].eq {
	pc = 0x825EE3D0; continue 'dispatch;
	}
	// 825EE324: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825EE328: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 825EE32C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825EE330: 396A0160  addi r11, r10, 0x160
	ctx.r[11].s64 = ctx.r[10].s64 + 352;
	// 825EE334: 409A0008  bne cr6, 0x825ee33c
	if !ctx.cr[6].eq {
	pc = 0x825EE33C; continue 'dispatch;
	}
	// 825EE338: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825EE33C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825EE340: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825EE344: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 825EE348: 419A0024  beq cr6, 0x825ee36c
	if ctx.cr[6].eq {
	pc = 0x825EE36C; continue 'dispatch;
	}
	// 825EE34C: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825EE350: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 825EE354: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825EE358: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 825EE35C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 825EE360: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825EE364: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825EE368: 4082FFE8  bne 0x825ee350
	if !ctx.cr[0].eq {
	pc = 0x825EE350; continue 'dispatch;
	}
	// 825EE36C: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 825EE370: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825EE374: 93A1006C  stw r29, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[29].u32 ) };
	// 825EE378: 419A0024  beq cr6, 0x825ee39c
	if ctx.cr[6].eq {
	pc = 0x825EE39C; continue 'dispatch;
	}
	// 825EE37C: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825EE380: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825EE384: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825EE388: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825EE38C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825EE390: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825EE394: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825EE398: 4082FFE8  bne 0x825ee380
	if !ctx.cr[0].eq {
	pc = 0x825EE380; continue 'dispatch;
	}
	// 825EE39C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825EE3A0: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 825EE3A4: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 825EE3A8: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 825EE3AC: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 825EE3B0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825EE3B4: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825EE3B8: 481AAB79  bl 0x82798f30
	ctx.lr = 0x825EE3BC;
	sub_82798F30(ctx, base);
	// 825EE3BC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825EE3C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825EE3C4: 481AD2A5  bl 0x8279b668
	ctx.lr = 0x825EE3C8;
	sub_8279B668(ctx, base);
	// 825EE3C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825EE3CC: 48000008  b 0x825ee3d4
	pc = 0x825EE3D4; continue 'dispatch;
	// 825EE3D0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825EE3D4: 93FA0000  stw r31, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825EE3D8: 3BDA0004  addi r30, r26, 4
	ctx.r[30].s64 = ctx.r[26].s64 + 4;
	// 825EE3DC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EE3E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EE3E4: 4BFA986D  bl 0x82597c50
	ctx.lr = 0x825EE3E8;
	sub_82597C50(ctx, base);
	// 825EE3E8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825EE3EC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EE3F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EE3F4: 4BCD1C0D  bl 0x822c0000
	ctx.lr = 0x825EE3F8;
	sub_822C0000(ctx, base);
	// 825EE3F8: 576B07FF  clrlwi. r11, r27, 0x1f
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825EE3FC: 41820024  beq 0x825ee420
	if ctx.cr[0].eq {
	pc = 0x825EE420; continue 'dispatch;
	}
	// 825EE400: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 825EE404: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EE408: 419A0008  beq cr6, 0x825ee410
	if ctx.cr[6].eq {
	pc = 0x825EE410; continue 'dispatch;
	}
	// 825EE40C: 4BCD2485  bl 0x822c0890
	ctx.lr = 0x825EE410;
	sub_822C0890(ctx, base);
	// 825EE410: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825EE414: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EE418: 419A0008  beq cr6, 0x825ee420
	if ctx.cr[6].eq {
	pc = 0x825EE420; continue 'dispatch;
	}
	// 825EE41C: 4BCD2475  bl 0x822c0890
	ctx.lr = 0x825EE420;
	sub_822C0890(ctx, base);
	// 825EE420: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825EE424: 419A000C  beq cr6, 0x825ee430
	if ctx.cr[6].eq {
	pc = 0x825EE430; continue 'dispatch;
	}
	// 825EE428: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825EE42C: 4BCD2465  bl 0x822c0890
	ctx.lr = 0x825EE430;
	sub_822C0890(ctx, base);
	// 825EE430: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825EE434: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EE438: 419A0008  beq cr6, 0x825ee440
	if ctx.cr[6].eq {
	pc = 0x825EE440; continue 'dispatch;
	}
	// 825EE43C: 4BCD2455  bl 0x822c0890
	ctx.lr = 0x825EE440;
	sub_822C0890(ctx, base);
	// 825EE440: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825EE444: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 825EE448: 48BB9D68  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EE450(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825EE450 size=548
    let mut pc: u32 = 0x825EE450;
    'dispatch: loop {
        match pc {
            0x825EE450 => {
    //   block [0x825EE450..0x825EE674)
	// 825EE450: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EE454: 48BB9D0D  bl 0x831a8160
	ctx.lr = 0x825EE458;
	sub_831A8130(ctx, base);
	// 825EE458: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EE45C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825EE460: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 825EE464: 3BCB03E8  addi r30, r11, 0x3e8
	ctx.r[30].s64 = ctx.r[11].s64 + 1000;
	// 825EE468: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 825EE46C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825EE470: 38A000E8  li r5, 0xe8
	ctx.r[5].s64 = 232;
	// 825EE474: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 825EE478: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825EE47C: 38600090  li r3, 0x90
	ctx.r[3].s64 = 144;
	// 825EE480: 48803F69  bl 0x82df23e8
	ctx.lr = 0x825EE484;
	sub_82DF23E8(ctx, base);
	// 825EE484: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825EE488: 41820018  beq 0x825ee4a0
	if ctx.cr[0].eq {
	pc = 0x825EE4A0; continue 'dispatch;
	}
	// 825EE48C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825EE490: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825EE494: 396B01DC  addi r11, r11, 0x1dc
	ctx.r[11].s64 = ctx.r[11].s64 + 476;
	// 825EE498: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825EE49C: 48000008  b 0x825ee4a4
	pc = 0x825EE4A4; continue 'dispatch;
	// 825EE4A0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825EE4A4: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 825EE4A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EE4AC: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825EE4B0: 4BFFCEC9  bl 0x825eb378
	ctx.lr = 0x825EE4B4;
	sub_825EB378(ctx, base);
	// 825EE4B4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825EE4B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EE4BC: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825EE4C0: 4BCD1B41  bl 0x822c0000
	ctx.lr = 0x825EE4C4;
	sub_822C0000(ctx, base);
	// 825EE4C4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825EE4C8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825EE4CC: 38A000E9  li r5, 0xe9
	ctx.r[5].s64 = 233;
	// 825EE4D0: 386002B0  li r3, 0x2b0
	ctx.r[3].s64 = 688;
	// 825EE4D4: 48803F15  bl 0x82df23e8
	ctx.lr = 0x825EE4D8;
	sub_82DF23E8(ctx, base);
	// 825EE4D8: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 825EE4DC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825EE4E0: 3B8BBA80  addi r28, r11, -0x4580
	ctx.r[28].s64 = ctx.r[11].s64 + -17792;
	// 825EE4E4: 41820024  beq 0x825ee508
	if ctx.cr[0].eq {
	pc = 0x825EE508; continue 'dispatch;
	}
	// 825EE4E8: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 825EE4EC: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 825EE4F0: 38AB6910  addi r5, r11, 0x6910
	ctx.r[5].s64 = ctx.r[11].s64 + 26896;
	// 825EE4F4: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 825EE4F8: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 825EE4FC: 4BFFEA8D  bl 0x825ecf88
	ctx.lr = 0x825EE500;
	sub_825ECF88(ctx, base);
	// 825EE500: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825EE504: 48000008  b 0x825ee50c
	pc = 0x825EE50C; continue 'dispatch;
	// 825EE508: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825EE50C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825EE510: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EE514: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825EE518: 4BFFCF11  bl 0x825eb428
	ctx.lr = 0x825EE51C;
	sub_825EB428(ctx, base);
	// 825EE51C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825EE520: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EE524: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825EE528: 4BCD1AD9  bl 0x822c0000
	ctx.lr = 0x825EE52C;
	sub_822C0000(ctx, base);
	// 825EE52C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825EE530: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825EE534: 38A000EA  li r5, 0xea
	ctx.r[5].s64 = 234;
	// 825EE538: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825EE53C: 4BCD1E9D  bl 0x822c03d8
	ctx.lr = 0x825EE540;
	sub_822C03D8(ctx, base);
	// 825EE540: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825EE544: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825EE548: 418200B0  beq 0x825ee5f8
	if ctx.cr[0].eq {
	pc = 0x825EE5F8; continue 'dispatch;
	}
	// 825EE54C: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825EE550: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 825EE554: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825EE558: 396A0160  addi r11, r10, 0x160
	ctx.r[11].s64 = ctx.r[10].s64 + 352;
	// 825EE55C: 409A0008  bne cr6, 0x825ee564
	if !ctx.cr[6].eq {
	pc = 0x825EE564; continue 'dispatch;
	}
	// 825EE560: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825EE564: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825EE568: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825EE56C: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 825EE570: 419A0024  beq cr6, 0x825ee594
	if ctx.cr[6].eq {
	pc = 0x825EE594; continue 'dispatch;
	}
	// 825EE574: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825EE578: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 825EE57C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825EE580: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 825EE584: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 825EE588: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825EE58C: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825EE590: 4082FFE8  bne 0x825ee578
	if !ctx.cr[0].eq {
	pc = 0x825EE578; continue 'dispatch;
	}
	// 825EE594: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 825EE598: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825EE59C: 93A1006C  stw r29, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[29].u32 ) };
	// 825EE5A0: 419A0024  beq cr6, 0x825ee5c4
	if ctx.cr[6].eq {
	pc = 0x825EE5C4; continue 'dispatch;
	}
	// 825EE5A4: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825EE5A8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825EE5AC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825EE5B0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825EE5B4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825EE5B8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825EE5BC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825EE5C0: 4082FFE8  bne 0x825ee5a8
	if !ctx.cr[0].eq {
	pc = 0x825EE5A8; continue 'dispatch;
	}
	// 825EE5C4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825EE5C8: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 825EE5CC: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 825EE5D0: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 825EE5D4: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 825EE5D8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825EE5DC: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825EE5E0: 481AA951  bl 0x82798f30
	ctx.lr = 0x825EE5E4;
	sub_82798F30(ctx, base);
	// 825EE5E4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825EE5E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825EE5EC: 481AD07D  bl 0x8279b668
	ctx.lr = 0x825EE5F0;
	sub_8279B668(ctx, base);
	// 825EE5F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825EE5F4: 48000008  b 0x825ee5fc
	pc = 0x825EE5FC; continue 'dispatch;
	// 825EE5F8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825EE5FC: 93FA0000  stw r31, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825EE600: 3BDA0004  addi r30, r26, 4
	ctx.r[30].s64 = ctx.r[26].s64 + 4;
	// 825EE604: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EE608: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EE60C: 4BFA9645  bl 0x82597c50
	ctx.lr = 0x825EE610;
	sub_82597C50(ctx, base);
	// 825EE610: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825EE614: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EE618: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EE61C: 4BCD19E5  bl 0x822c0000
	ctx.lr = 0x825EE620;
	sub_822C0000(ctx, base);
	// 825EE620: 576B07FF  clrlwi. r11, r27, 0x1f
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825EE624: 41820024  beq 0x825ee648
	if ctx.cr[0].eq {
	pc = 0x825EE648; continue 'dispatch;
	}
	// 825EE628: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 825EE62C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EE630: 419A0008  beq cr6, 0x825ee638
	if ctx.cr[6].eq {
	pc = 0x825EE638; continue 'dispatch;
	}
	// 825EE634: 4BCD225D  bl 0x822c0890
	ctx.lr = 0x825EE638;
	sub_822C0890(ctx, base);
	// 825EE638: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825EE63C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EE640: 419A0008  beq cr6, 0x825ee648
	if ctx.cr[6].eq {
	pc = 0x825EE648; continue 'dispatch;
	}
	// 825EE644: 4BCD224D  bl 0x822c0890
	ctx.lr = 0x825EE648;
	sub_822C0890(ctx, base);
	// 825EE648: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825EE64C: 419A000C  beq cr6, 0x825ee658
	if ctx.cr[6].eq {
	pc = 0x825EE658; continue 'dispatch;
	}
	// 825EE650: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825EE654: 4BCD223D  bl 0x822c0890
	ctx.lr = 0x825EE658;
	sub_822C0890(ctx, base);
	// 825EE658: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825EE65C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EE660: 419A0008  beq cr6, 0x825ee668
	if ctx.cr[6].eq {
	pc = 0x825EE668; continue 'dispatch;
	}
	// 825EE664: 4BCD222D  bl 0x822c0890
	ctx.lr = 0x825EE668;
	sub_822C0890(ctx, base);
	// 825EE668: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825EE66C: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 825EE670: 48BB9B40  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EE678(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825EE678 size=548
    let mut pc: u32 = 0x825EE678;
    'dispatch: loop {
        match pc {
            0x825EE678 => {
    //   block [0x825EE678..0x825EE89C)
	// 825EE678: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EE67C: 48BB9AE5  bl 0x831a8160
	ctx.lr = 0x825EE680;
	sub_831A8130(ctx, base);
	// 825EE680: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EE684: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825EE688: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 825EE68C: 3BCB03E8  addi r30, r11, 0x3e8
	ctx.r[30].s64 = ctx.r[11].s64 + 1000;
	// 825EE690: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 825EE694: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825EE698: 38A000EF  li r5, 0xef
	ctx.r[5].s64 = 239;
	// 825EE69C: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 825EE6A0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825EE6A4: 38600090  li r3, 0x90
	ctx.r[3].s64 = 144;
	// 825EE6A8: 48803D41  bl 0x82df23e8
	ctx.lr = 0x825EE6AC;
	sub_82DF23E8(ctx, base);
	// 825EE6AC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825EE6B0: 41820018  beq 0x825ee6c8
	if ctx.cr[0].eq {
	pc = 0x825EE6C8; continue 'dispatch;
	}
	// 825EE6B4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825EE6B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825EE6BC: 396B01DC  addi r11, r11, 0x1dc
	ctx.r[11].s64 = ctx.r[11].s64 + 476;
	// 825EE6C0: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825EE6C4: 48000008  b 0x825ee6cc
	pc = 0x825EE6CC; continue 'dispatch;
	// 825EE6C8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825EE6CC: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 825EE6D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EE6D4: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825EE6D8: 4BFFCCA1  bl 0x825eb378
	ctx.lr = 0x825EE6DC;
	sub_825EB378(ctx, base);
	// 825EE6DC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825EE6E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EE6E4: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825EE6E8: 4BCD1919  bl 0x822c0000
	ctx.lr = 0x825EE6EC;
	sub_822C0000(ctx, base);
	// 825EE6EC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825EE6F0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825EE6F4: 38A000F0  li r5, 0xf0
	ctx.r[5].s64 = 240;
	// 825EE6F8: 386002B0  li r3, 0x2b0
	ctx.r[3].s64 = 688;
	// 825EE6FC: 48803CED  bl 0x82df23e8
	ctx.lr = 0x825EE700;
	sub_82DF23E8(ctx, base);
	// 825EE700: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 825EE704: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825EE708: 3B8BBA80  addi r28, r11, -0x4580
	ctx.r[28].s64 = ctx.r[11].s64 + -17792;
	// 825EE70C: 41820024  beq 0x825ee730
	if ctx.cr[0].eq {
	pc = 0x825EE730; continue 'dispatch;
	}
	// 825EE710: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 825EE714: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 825EE718: 38AB6910  addi r5, r11, 0x6910
	ctx.r[5].s64 = ctx.r[11].s64 + 26896;
	// 825EE71C: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 825EE720: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 825EE724: 4BFFE865  bl 0x825ecf88
	ctx.lr = 0x825EE728;
	sub_825ECF88(ctx, base);
	// 825EE728: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825EE72C: 48000008  b 0x825ee734
	pc = 0x825EE734; continue 'dispatch;
	// 825EE730: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825EE734: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825EE738: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EE73C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825EE740: 4BFFCCE9  bl 0x825eb428
	ctx.lr = 0x825EE744;
	sub_825EB428(ctx, base);
	// 825EE744: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825EE748: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EE74C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825EE750: 4BCD18B1  bl 0x822c0000
	ctx.lr = 0x825EE754;
	sub_822C0000(ctx, base);
	// 825EE754: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825EE758: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825EE75C: 38A000F1  li r5, 0xf1
	ctx.r[5].s64 = 241;
	// 825EE760: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825EE764: 4BCD1C75  bl 0x822c03d8
	ctx.lr = 0x825EE768;
	sub_822C03D8(ctx, base);
	// 825EE768: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825EE76C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825EE770: 418200B0  beq 0x825ee820
	if ctx.cr[0].eq {
	pc = 0x825EE820; continue 'dispatch;
	}
	// 825EE774: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825EE778: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 825EE77C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825EE780: 396A0160  addi r11, r10, 0x160
	ctx.r[11].s64 = ctx.r[10].s64 + 352;
	// 825EE784: 409A0008  bne cr6, 0x825ee78c
	if !ctx.cr[6].eq {
	pc = 0x825EE78C; continue 'dispatch;
	}
	// 825EE788: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825EE78C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825EE790: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825EE794: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 825EE798: 419A0024  beq cr6, 0x825ee7bc
	if ctx.cr[6].eq {
	pc = 0x825EE7BC; continue 'dispatch;
	}
	// 825EE79C: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825EE7A0: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 825EE7A4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825EE7A8: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 825EE7AC: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 825EE7B0: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825EE7B4: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825EE7B8: 4082FFE8  bne 0x825ee7a0
	if !ctx.cr[0].eq {
	pc = 0x825EE7A0; continue 'dispatch;
	}
	// 825EE7BC: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 825EE7C0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825EE7C4: 93A1006C  stw r29, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[29].u32 ) };
	// 825EE7C8: 419A0024  beq cr6, 0x825ee7ec
	if ctx.cr[6].eq {
	pc = 0x825EE7EC; continue 'dispatch;
	}
	// 825EE7CC: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825EE7D0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825EE7D4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825EE7D8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825EE7DC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825EE7E0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825EE7E4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825EE7E8: 4082FFE8  bne 0x825ee7d0
	if !ctx.cr[0].eq {
	pc = 0x825EE7D0; continue 'dispatch;
	}
	// 825EE7EC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825EE7F0: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 825EE7F4: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 825EE7F8: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 825EE7FC: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 825EE800: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825EE804: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825EE808: 481AA729  bl 0x82798f30
	ctx.lr = 0x825EE80C;
	sub_82798F30(ctx, base);
	// 825EE80C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825EE810: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825EE814: 481ACE55  bl 0x8279b668
	ctx.lr = 0x825EE818;
	sub_8279B668(ctx, base);
	// 825EE818: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825EE81C: 48000008  b 0x825ee824
	pc = 0x825EE824; continue 'dispatch;
	// 825EE820: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825EE824: 93FA0000  stw r31, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825EE828: 3BDA0004  addi r30, r26, 4
	ctx.r[30].s64 = ctx.r[26].s64 + 4;
	// 825EE82C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EE830: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EE834: 4BFA941D  bl 0x82597c50
	ctx.lr = 0x825EE838;
	sub_82597C50(ctx, base);
	// 825EE838: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825EE83C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EE840: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EE844: 4BCD17BD  bl 0x822c0000
	ctx.lr = 0x825EE848;
	sub_822C0000(ctx, base);
	// 825EE848: 576B07FF  clrlwi. r11, r27, 0x1f
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825EE84C: 41820024  beq 0x825ee870
	if ctx.cr[0].eq {
	pc = 0x825EE870; continue 'dispatch;
	}
	// 825EE850: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 825EE854: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EE858: 419A0008  beq cr6, 0x825ee860
	if ctx.cr[6].eq {
	pc = 0x825EE860; continue 'dispatch;
	}
	// 825EE85C: 4BCD2035  bl 0x822c0890
	ctx.lr = 0x825EE860;
	sub_822C0890(ctx, base);
	// 825EE860: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825EE864: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EE868: 419A0008  beq cr6, 0x825ee870
	if ctx.cr[6].eq {
	pc = 0x825EE870; continue 'dispatch;
	}
	// 825EE86C: 4BCD2025  bl 0x822c0890
	ctx.lr = 0x825EE870;
	sub_822C0890(ctx, base);
	// 825EE870: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825EE874: 419A000C  beq cr6, 0x825ee880
	if ctx.cr[6].eq {
	pc = 0x825EE880; continue 'dispatch;
	}
	// 825EE878: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825EE87C: 4BCD2015  bl 0x822c0890
	ctx.lr = 0x825EE880;
	sub_822C0890(ctx, base);
	// 825EE880: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825EE884: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EE888: 419A0008  beq cr6, 0x825ee890
	if ctx.cr[6].eq {
	pc = 0x825EE890; continue 'dispatch;
	}
	// 825EE88C: 4BCD2005  bl 0x822c0890
	ctx.lr = 0x825EE890;
	sub_822C0890(ctx, base);
	// 825EE890: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825EE894: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 825EE898: 48BB9918  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EE8A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825EE8A0 size=548
    let mut pc: u32 = 0x825EE8A0;
    'dispatch: loop {
        match pc {
            0x825EE8A0 => {
    //   block [0x825EE8A0..0x825EEAC4)
	// 825EE8A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EE8A4: 48BB98BD  bl 0x831a8160
	ctx.lr = 0x825EE8A8;
	sub_831A8130(ctx, base);
	// 825EE8A8: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EE8AC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825EE8B0: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 825EE8B4: 3BCB03E8  addi r30, r11, 0x3e8
	ctx.r[30].s64 = ctx.r[11].s64 + 1000;
	// 825EE8B8: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 825EE8BC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825EE8C0: 38A000F6  li r5, 0xf6
	ctx.r[5].s64 = 246;
	// 825EE8C4: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 825EE8C8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825EE8CC: 38600090  li r3, 0x90
	ctx.r[3].s64 = 144;
	// 825EE8D0: 48803B19  bl 0x82df23e8
	ctx.lr = 0x825EE8D4;
	sub_82DF23E8(ctx, base);
	// 825EE8D4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825EE8D8: 41820018  beq 0x825ee8f0
	if ctx.cr[0].eq {
	pc = 0x825EE8F0; continue 'dispatch;
	}
	// 825EE8DC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825EE8E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825EE8E4: 396B01DC  addi r11, r11, 0x1dc
	ctx.r[11].s64 = ctx.r[11].s64 + 476;
	// 825EE8E8: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825EE8EC: 48000008  b 0x825ee8f4
	pc = 0x825EE8F4; continue 'dispatch;
	// 825EE8F0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825EE8F4: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 825EE8F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EE8FC: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825EE900: 4BFFCA79  bl 0x825eb378
	ctx.lr = 0x825EE904;
	sub_825EB378(ctx, base);
	// 825EE904: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825EE908: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EE90C: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825EE910: 4BCD16F1  bl 0x822c0000
	ctx.lr = 0x825EE914;
	sub_822C0000(ctx, base);
	// 825EE914: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825EE918: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825EE91C: 38A000F7  li r5, 0xf7
	ctx.r[5].s64 = 247;
	// 825EE920: 386002B0  li r3, 0x2b0
	ctx.r[3].s64 = 688;
	// 825EE924: 48803AC5  bl 0x82df23e8
	ctx.lr = 0x825EE928;
	sub_82DF23E8(ctx, base);
	// 825EE928: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 825EE92C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825EE930: 3B8BBA80  addi r28, r11, -0x4580
	ctx.r[28].s64 = ctx.r[11].s64 + -17792;
	// 825EE934: 41820024  beq 0x825ee958
	if ctx.cr[0].eq {
	pc = 0x825EE958; continue 'dispatch;
	}
	// 825EE938: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 825EE93C: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 825EE940: 38AB6910  addi r5, r11, 0x6910
	ctx.r[5].s64 = ctx.r[11].s64 + 26896;
	// 825EE944: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 825EE948: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 825EE94C: 4BFFE63D  bl 0x825ecf88
	ctx.lr = 0x825EE950;
	sub_825ECF88(ctx, base);
	// 825EE950: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825EE954: 48000008  b 0x825ee95c
	pc = 0x825EE95C; continue 'dispatch;
	// 825EE958: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825EE95C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825EE960: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EE964: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825EE968: 4BFFCAC1  bl 0x825eb428
	ctx.lr = 0x825EE96C;
	sub_825EB428(ctx, base);
	// 825EE96C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825EE970: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EE974: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825EE978: 4BCD1689  bl 0x822c0000
	ctx.lr = 0x825EE97C;
	sub_822C0000(ctx, base);
	// 825EE97C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825EE980: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825EE984: 38A000F8  li r5, 0xf8
	ctx.r[5].s64 = 248;
	// 825EE988: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825EE98C: 4BCD1A4D  bl 0x822c03d8
	ctx.lr = 0x825EE990;
	sub_822C03D8(ctx, base);
	// 825EE990: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825EE994: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825EE998: 418200B0  beq 0x825eea48
	if ctx.cr[0].eq {
	pc = 0x825EEA48; continue 'dispatch;
	}
	// 825EE99C: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825EE9A0: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 825EE9A4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825EE9A8: 396A0160  addi r11, r10, 0x160
	ctx.r[11].s64 = ctx.r[10].s64 + 352;
	// 825EE9AC: 409A0008  bne cr6, 0x825ee9b4
	if !ctx.cr[6].eq {
	pc = 0x825EE9B4; continue 'dispatch;
	}
	// 825EE9B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825EE9B4: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825EE9B8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825EE9BC: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 825EE9C0: 419A0024  beq cr6, 0x825ee9e4
	if ctx.cr[6].eq {
	pc = 0x825EE9E4; continue 'dispatch;
	}
	// 825EE9C4: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825EE9C8: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 825EE9CC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825EE9D0: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 825EE9D4: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 825EE9D8: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825EE9DC: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825EE9E0: 4082FFE8  bne 0x825ee9c8
	if !ctx.cr[0].eq {
	pc = 0x825EE9C8; continue 'dispatch;
	}
	// 825EE9E4: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 825EE9E8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825EE9EC: 93A1006C  stw r29, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[29].u32 ) };
	// 825EE9F0: 419A0024  beq cr6, 0x825eea14
	if ctx.cr[6].eq {
	pc = 0x825EEA14; continue 'dispatch;
	}
	// 825EE9F4: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825EE9F8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825EE9FC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825EEA00: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825EEA04: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825EEA08: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825EEA0C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825EEA10: 4082FFE8  bne 0x825ee9f8
	if !ctx.cr[0].eq {
	pc = 0x825EE9F8; continue 'dispatch;
	}
	// 825EEA14: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825EEA18: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 825EEA1C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 825EEA20: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 825EEA24: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 825EEA28: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825EEA2C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825EEA30: 481AA501  bl 0x82798f30
	ctx.lr = 0x825EEA34;
	sub_82798F30(ctx, base);
	// 825EEA34: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825EEA38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825EEA3C: 481ACC2D  bl 0x8279b668
	ctx.lr = 0x825EEA40;
	sub_8279B668(ctx, base);
	// 825EEA40: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825EEA44: 48000008  b 0x825eea4c
	pc = 0x825EEA4C; continue 'dispatch;
	// 825EEA48: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825EEA4C: 93FA0000  stw r31, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825EEA50: 3BDA0004  addi r30, r26, 4
	ctx.r[30].s64 = ctx.r[26].s64 + 4;
	// 825EEA54: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EEA58: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EEA5C: 4BFA91F5  bl 0x82597c50
	ctx.lr = 0x825EEA60;
	sub_82597C50(ctx, base);
	// 825EEA60: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825EEA64: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EEA68: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EEA6C: 4BCD1595  bl 0x822c0000
	ctx.lr = 0x825EEA70;
	sub_822C0000(ctx, base);
	// 825EEA70: 576B07FF  clrlwi. r11, r27, 0x1f
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825EEA74: 41820024  beq 0x825eea98
	if ctx.cr[0].eq {
	pc = 0x825EEA98; continue 'dispatch;
	}
	// 825EEA78: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 825EEA7C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EEA80: 419A0008  beq cr6, 0x825eea88
	if ctx.cr[6].eq {
	pc = 0x825EEA88; continue 'dispatch;
	}
	// 825EEA84: 4BCD1E0D  bl 0x822c0890
	ctx.lr = 0x825EEA88;
	sub_822C0890(ctx, base);
	// 825EEA88: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825EEA8C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EEA90: 419A0008  beq cr6, 0x825eea98
	if ctx.cr[6].eq {
	pc = 0x825EEA98; continue 'dispatch;
	}
	// 825EEA94: 4BCD1DFD  bl 0x822c0890
	ctx.lr = 0x825EEA98;
	sub_822C0890(ctx, base);
	// 825EEA98: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825EEA9C: 419A000C  beq cr6, 0x825eeaa8
	if ctx.cr[6].eq {
	pc = 0x825EEAA8; continue 'dispatch;
	}
	// 825EEAA0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825EEAA4: 4BCD1DED  bl 0x822c0890
	ctx.lr = 0x825EEAA8;
	sub_822C0890(ctx, base);
	// 825EEAA8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825EEAAC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EEAB0: 419A0008  beq cr6, 0x825eeab8
	if ctx.cr[6].eq {
	pc = 0x825EEAB8; continue 'dispatch;
	}
	// 825EEAB4: 4BCD1DDD  bl 0x822c0890
	ctx.lr = 0x825EEAB8;
	sub_822C0890(ctx, base);
	// 825EEAB8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825EEABC: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 825EEAC0: 48BB96F0  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EEAC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825EEAC8 size=548
    let mut pc: u32 = 0x825EEAC8;
    'dispatch: loop {
        match pc {
            0x825EEAC8 => {
    //   block [0x825EEAC8..0x825EECEC)
	// 825EEAC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EEACC: 48BB9695  bl 0x831a8160
	ctx.lr = 0x825EEAD0;
	sub_831A8130(ctx, base);
	// 825EEAD0: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EEAD4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825EEAD8: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 825EEADC: 3BCB03E8  addi r30, r11, 0x3e8
	ctx.r[30].s64 = ctx.r[11].s64 + 1000;
	// 825EEAE0: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 825EEAE4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825EEAE8: 38A000FD  li r5, 0xfd
	ctx.r[5].s64 = 253;
	// 825EEAEC: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 825EEAF0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825EEAF4: 38600090  li r3, 0x90
	ctx.r[3].s64 = 144;
	// 825EEAF8: 488038F1  bl 0x82df23e8
	ctx.lr = 0x825EEAFC;
	sub_82DF23E8(ctx, base);
	// 825EEAFC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825EEB00: 41820018  beq 0x825eeb18
	if ctx.cr[0].eq {
	pc = 0x825EEB18; continue 'dispatch;
	}
	// 825EEB04: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825EEB08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825EEB0C: 396B01DC  addi r11, r11, 0x1dc
	ctx.r[11].s64 = ctx.r[11].s64 + 476;
	// 825EEB10: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825EEB14: 48000008  b 0x825eeb1c
	pc = 0x825EEB1C; continue 'dispatch;
	// 825EEB18: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825EEB1C: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 825EEB20: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EEB24: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825EEB28: 4BFFC851  bl 0x825eb378
	ctx.lr = 0x825EEB2C;
	sub_825EB378(ctx, base);
	// 825EEB2C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825EEB30: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EEB34: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825EEB38: 4BCD14C9  bl 0x822c0000
	ctx.lr = 0x825EEB3C;
	sub_822C0000(ctx, base);
	// 825EEB3C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825EEB40: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825EEB44: 38A000FE  li r5, 0xfe
	ctx.r[5].s64 = 254;
	// 825EEB48: 386002B0  li r3, 0x2b0
	ctx.r[3].s64 = 688;
	// 825EEB4C: 4880389D  bl 0x82df23e8
	ctx.lr = 0x825EEB50;
	sub_82DF23E8(ctx, base);
	// 825EEB50: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 825EEB54: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825EEB58: 3B8BBA80  addi r28, r11, -0x4580
	ctx.r[28].s64 = ctx.r[11].s64 + -17792;
	// 825EEB5C: 41820024  beq 0x825eeb80
	if ctx.cr[0].eq {
	pc = 0x825EEB80; continue 'dispatch;
	}
	// 825EEB60: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 825EEB64: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 825EEB68: 38AB6910  addi r5, r11, 0x6910
	ctx.r[5].s64 = ctx.r[11].s64 + 26896;
	// 825EEB6C: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 825EEB70: 38800007  li r4, 7
	ctx.r[4].s64 = 7;
	// 825EEB74: 4BFFE415  bl 0x825ecf88
	ctx.lr = 0x825EEB78;
	sub_825ECF88(ctx, base);
	// 825EEB78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825EEB7C: 48000008  b 0x825eeb84
	pc = 0x825EEB84; continue 'dispatch;
	// 825EEB80: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825EEB84: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825EEB88: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EEB8C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825EEB90: 4BFFC899  bl 0x825eb428
	ctx.lr = 0x825EEB94;
	sub_825EB428(ctx, base);
	// 825EEB94: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825EEB98: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EEB9C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825EEBA0: 4BCD1461  bl 0x822c0000
	ctx.lr = 0x825EEBA4;
	sub_822C0000(ctx, base);
	// 825EEBA4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825EEBA8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825EEBAC: 38A000FF  li r5, 0xff
	ctx.r[5].s64 = 255;
	// 825EEBB0: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825EEBB4: 4BCD1825  bl 0x822c03d8
	ctx.lr = 0x825EEBB8;
	sub_822C03D8(ctx, base);
	// 825EEBB8: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825EEBBC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825EEBC0: 418200B0  beq 0x825eec70
	if ctx.cr[0].eq {
	pc = 0x825EEC70; continue 'dispatch;
	}
	// 825EEBC4: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825EEBC8: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 825EEBCC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825EEBD0: 396A0160  addi r11, r10, 0x160
	ctx.r[11].s64 = ctx.r[10].s64 + 352;
	// 825EEBD4: 409A0008  bne cr6, 0x825eebdc
	if !ctx.cr[6].eq {
	pc = 0x825EEBDC; continue 'dispatch;
	}
	// 825EEBD8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825EEBDC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825EEBE0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825EEBE4: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 825EEBE8: 419A0024  beq cr6, 0x825eec0c
	if ctx.cr[6].eq {
	pc = 0x825EEC0C; continue 'dispatch;
	}
	// 825EEBEC: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825EEBF0: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 825EEBF4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825EEBF8: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 825EEBFC: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 825EEC00: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825EEC04: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825EEC08: 4082FFE8  bne 0x825eebf0
	if !ctx.cr[0].eq {
	pc = 0x825EEBF0; continue 'dispatch;
	}
	// 825EEC0C: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 825EEC10: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825EEC14: 93A1006C  stw r29, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[29].u32 ) };
	// 825EEC18: 419A0024  beq cr6, 0x825eec3c
	if ctx.cr[6].eq {
	pc = 0x825EEC3C; continue 'dispatch;
	}
	// 825EEC1C: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825EEC20: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825EEC24: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825EEC28: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825EEC2C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825EEC30: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825EEC34: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825EEC38: 4082FFE8  bne 0x825eec20
	if !ctx.cr[0].eq {
	pc = 0x825EEC20; continue 'dispatch;
	}
	// 825EEC3C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825EEC40: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 825EEC44: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 825EEC48: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 825EEC4C: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 825EEC50: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825EEC54: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825EEC58: 481AA2D9  bl 0x82798f30
	ctx.lr = 0x825EEC5C;
	sub_82798F30(ctx, base);
	// 825EEC5C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825EEC60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825EEC64: 481ACA05  bl 0x8279b668
	ctx.lr = 0x825EEC68;
	sub_8279B668(ctx, base);
	// 825EEC68: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825EEC6C: 48000008  b 0x825eec74
	pc = 0x825EEC74; continue 'dispatch;
	// 825EEC70: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825EEC74: 93FA0000  stw r31, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825EEC78: 3BDA0004  addi r30, r26, 4
	ctx.r[30].s64 = ctx.r[26].s64 + 4;
	// 825EEC7C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EEC80: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EEC84: 4BFA8FCD  bl 0x82597c50
	ctx.lr = 0x825EEC88;
	sub_82597C50(ctx, base);
	// 825EEC88: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825EEC8C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EEC90: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EEC94: 4BCD136D  bl 0x822c0000
	ctx.lr = 0x825EEC98;
	sub_822C0000(ctx, base);
	// 825EEC98: 576B07FF  clrlwi. r11, r27, 0x1f
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825EEC9C: 41820024  beq 0x825eecc0
	if ctx.cr[0].eq {
	pc = 0x825EECC0; continue 'dispatch;
	}
	// 825EECA0: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 825EECA4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EECA8: 419A0008  beq cr6, 0x825eecb0
	if ctx.cr[6].eq {
	pc = 0x825EECB0; continue 'dispatch;
	}
	// 825EECAC: 4BCD1BE5  bl 0x822c0890
	ctx.lr = 0x825EECB0;
	sub_822C0890(ctx, base);
	// 825EECB0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825EECB4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EECB8: 419A0008  beq cr6, 0x825eecc0
	if ctx.cr[6].eq {
	pc = 0x825EECC0; continue 'dispatch;
	}
	// 825EECBC: 4BCD1BD5  bl 0x822c0890
	ctx.lr = 0x825EECC0;
	sub_822C0890(ctx, base);
	// 825EECC0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825EECC4: 419A000C  beq cr6, 0x825eecd0
	if ctx.cr[6].eq {
	pc = 0x825EECD0; continue 'dispatch;
	}
	// 825EECC8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825EECCC: 4BCD1BC5  bl 0x822c0890
	ctx.lr = 0x825EECD0;
	sub_822C0890(ctx, base);
	// 825EECD0: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825EECD4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EECD8: 419A0008  beq cr6, 0x825eece0
	if ctx.cr[6].eq {
	pc = 0x825EECE0; continue 'dispatch;
	}
	// 825EECDC: 4BCD1BB5  bl 0x822c0890
	ctx.lr = 0x825EECE0;
	sub_822C0890(ctx, base);
	// 825EECE0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825EECE4: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 825EECE8: 48BB94C8  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EECF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825EECF0 size=820
    let mut pc: u32 = 0x825EECF0;
    'dispatch: loop {
        match pc {
            0x825EECF0 => {
    //   block [0x825EECF0..0x825EF024)
	// 825EECF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EECF4: 48BB9469  bl 0x831a815c
	ctx.lr = 0x825EECF8;
	sub_831A8130(ctx, base);
	// 825EECF8: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 825EECFC: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EED00: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825EED04: 48B658FD  bl 0x83154600
	ctx.lr = 0x825EED08;
	sub_83154600(ctx, base);
	// 825EED08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825EED0C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825EED10: 4886AA69  bl 0x82e59778
	ctx.lr = 0x825EED14;
	sub_82E59778(ctx, base);
	// 825EED14: C01C0068  lfs f0, 0x68(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825EED18: EDA10032  fmuls f13, f1, f0
	ctx.f[13].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 825EED1C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825EED20: C19C0064  lfs f12, 0x64(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(100 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825EED24: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825EED28: C00B093C  lfs f0, 0x93c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2364 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825EED2C: C3EA08A8  lfs f31, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825EED30: EC0D603A  fmadds f0, f13, f0, f12
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 825EED34: D01C0064  stfs f0, 0x64(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 825EED38: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 825EED3C: 41980048  blt cr6, 0x825eed84
	if ctx.cr[6].lt {
	pc = 0x825EED84; continue 'dispatch;
	}
	// 825EED40: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825EED44: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825EED48: 388B0380  addi r4, r11, 0x380
	ctx.r[4].s64 = ctx.r[11].s64 + 896;
	// 825EED4C: 48804CBD  bl 0x82df3a08
	ctx.lr = 0x825EED50;
	sub_82DF3A08(ctx, base);
	// 825EED50: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825EED54: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825EED58: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825EED5C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825EED60: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825EED64: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825EED68: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825EED6C: 4886FD25  bl 0x82e5ea90
	ctx.lr = 0x825EED70;
	sub_82E5EA90(ctx, base);
	// 825EED70: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 825EED74: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EED78: 419A02A0  beq cr6, 0x825ef018
	if ctx.cr[6].eq {
	pc = 0x825EF018; continue 'dispatch;
	}
	// 825EED7C: 4BCD1B15  bl 0x822c0890
	ctx.lr = 0x825EED80;
	sub_822C0890(ctx, base);
	// 825EED80: 48000298  b 0x825ef018
	pc = 0x825EF018; continue 'dispatch;
	// 825EED84: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EED88: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 825EED8C: 481C784D  bl 0x827b65d8
	ctx.lr = 0x825EED90;
	sub_827B65D8(ctx, base);
	// 825EED90: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825EED94: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 825EED98: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EED9C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EEDA0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825EEDA4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825EEDA8: 4E800421  bctrl
	ctx.lr = 0x825EEDAC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825EEDAC: 3BDC0080  addi r30, r28, 0x80
	ctx.r[30].s64 = ctx.r[28].s64 + 128;
	// 825EEDB0: 8161008C  lwz r11, 0x8c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 825EEDB4: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 825EEDB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EF028(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825EF028 size=92
    let mut pc: u32 = 0x825EF028;
    'dispatch: loop {
        match pc {
            0x825EF028 => {
    //   block [0x825EF028..0x825EF084)
	// 825EF028: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EF02C: 48BB9141  bl 0x831a816c
	ctx.lr = 0x825EF030;
	sub_831A8130(ctx, base);
	// 825EF030: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EF034: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825EF038: 3D40825F  lis r10, -0x7da1
	ctx.r[10].s64 = -2107703296;
	// 825EF03C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825EF040: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825EF044: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825EF048: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825EF04C: 388ACBC0  addi r4, r10, -0x3440
	ctx.r[4].s64 = ctx.r[10].s64 + -13376;
	// 825EF050: 4BD70A21  bl 0x8235fa70
	ctx.lr = 0x825EF054;
	sub_8235FA70(ctx, base);
	// 825EF054: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825EF058: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825EF05C: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 825EF060: 48804BA1  bl 0x82df3c00
	ctx.lr = 0x825EF064;
	sub_82DF3C00(ctx, base);
	// 825EF064: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825EF068: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825EF06C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825EF070: 4886D0E9  bl 0x82e5c158
	ctx.lr = 0x825EF074;
	sub_82E5C158(ctx, base);
	// 825EF074: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EF078: 488043B1  bl 0x82df3428
	ctx.lr = 0x825EF07C;
	sub_82DF3428(ctx, base);
	// 825EF07C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825EF080: 48BB913C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EF088(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825EF088 size=92
    let mut pc: u32 = 0x825EF088;
    'dispatch: loop {
        match pc {
            0x825EF088 => {
    //   block [0x825EF088..0x825EF0E4)
	// 825EF088: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EF08C: 48BB90E1  bl 0x831a816c
	ctx.lr = 0x825EF090;
	sub_831A8130(ctx, base);
	// 825EF090: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EF094: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825EF098: 3D40825F  lis r10, -0x7da1
	ctx.r[10].s64 = -2107703296;
	// 825EF09C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825EF0A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825EF0A4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825EF0A8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825EF0AC: 388ACC40  addi r4, r10, -0x33c0
	ctx.r[4].s64 = ctx.r[10].s64 + -13248;
	// 825EF0B0: 4BD709C1  bl 0x8235fa70
	ctx.lr = 0x825EF0B4;
	sub_8235FA70(ctx, base);
	// 825EF0B4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825EF0B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825EF0BC: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 825EF0C0: 48804B41  bl 0x82df3c00
	ctx.lr = 0x825EF0C4;
	sub_82DF3C00(ctx, base);
	// 825EF0C4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825EF0C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825EF0CC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825EF0D0: 4886D089  bl 0x82e5c158
	ctx.lr = 0x825EF0D4;
	sub_82E5C158(ctx, base);
	// 825EF0D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EF0D8: 48804351  bl 0x82df3428
	ctx.lr = 0x825EF0DC;
	sub_82DF3428(ctx, base);
	// 825EF0DC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825EF0E0: 48BB90DC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EF0E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825EF0E8 size=92
    let mut pc: u32 = 0x825EF0E8;
    'dispatch: loop {
        match pc {
            0x825EF0E8 => {
    //   block [0x825EF0E8..0x825EF144)
	// 825EF0E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EF0EC: 48BB9081  bl 0x831a816c
	ctx.lr = 0x825EF0F0;
	sub_831A8130(ctx, base);
	// 825EF0F0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EF0F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825EF0F8: 3D40825F  lis r10, -0x7da1
	ctx.r[10].s64 = -2107703296;
	// 825EF0FC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825EF100: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825EF104: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825EF108: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825EF10C: 388ACCC0  addi r4, r10, -0x3340
	ctx.r[4].s64 = ctx.r[10].s64 + -13120;
	// 825EF110: 4BD70961  bl 0x8235fa70
	ctx.lr = 0x825EF114;
	sub_8235FA70(ctx, base);
	// 825EF114: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825EF118: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825EF11C: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 825EF120: 48804AE1  bl 0x82df3c00
	ctx.lr = 0x825EF124;
	sub_82DF3C00(ctx, base);
	// 825EF124: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825EF128: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825EF12C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825EF130: 4886D029  bl 0x82e5c158
	ctx.lr = 0x825EF134;
	sub_82E5C158(ctx, base);
	// 825EF134: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EF138: 488042F1  bl 0x82df3428
	ctx.lr = 0x825EF13C;
	sub_82DF3428(ctx, base);
	// 825EF13C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825EF140: 48BB907C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EF148(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825EF148 size=92
    let mut pc: u32 = 0x825EF148;
    'dispatch: loop {
        match pc {
            0x825EF148 => {
    //   block [0x825EF148..0x825EF1A4)
	// 825EF148: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EF14C: 48BB9021  bl 0x831a816c
	ctx.lr = 0x825EF150;
	sub_831A8130(ctx, base);
	// 825EF150: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EF154: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825EF158: 3D40825F  lis r10, -0x7da1
	ctx.r[10].s64 = -2107703296;
	// 825EF15C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825EF160: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825EF164: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825EF168: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825EF16C: 388ACD40  addi r4, r10, -0x32c0
	ctx.r[4].s64 = ctx.r[10].s64 + -12992;
	// 825EF170: 4BD70901  bl 0x8235fa70
	ctx.lr = 0x825EF174;
	sub_8235FA70(ctx, base);
	// 825EF174: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825EF178: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825EF17C: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 825EF180: 48804A81  bl 0x82df3c00
	ctx.lr = 0x825EF184;
	sub_82DF3C00(ctx, base);
	// 825EF184: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825EF188: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825EF18C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825EF190: 4886CFC9  bl 0x82e5c158
	ctx.lr = 0x825EF194;
	sub_82E5C158(ctx, base);
	// 825EF194: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EF198: 48804291  bl 0x82df3428
	ctx.lr = 0x825EF19C;
	sub_82DF3428(ctx, base);
	// 825EF19C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825EF1A0: 48BB901C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EF1A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825EF1A8 size=92
    let mut pc: u32 = 0x825EF1A8;
    'dispatch: loop {
        match pc {
            0x825EF1A8 => {
    //   block [0x825EF1A8..0x825EF204)
	// 825EF1A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EF1AC: 48BB8FC1  bl 0x831a816c
	ctx.lr = 0x825EF1B0;
	sub_831A8130(ctx, base);
	// 825EF1B0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EF1B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825EF1B8: 3D40825F  lis r10, -0x7da1
	ctx.r[10].s64 = -2107703296;
	// 825EF1BC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825EF1C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825EF1C4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825EF1C8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825EF1CC: 388ACDC0  addi r4, r10, -0x3240
	ctx.r[4].s64 = ctx.r[10].s64 + -12864;
	// 825EF1D0: 4BD708A1  bl 0x8235fa70
	ctx.lr = 0x825EF1D4;
	sub_8235FA70(ctx, base);
	// 825EF1D4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825EF1D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825EF1DC: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 825EF1E0: 48804A21  bl 0x82df3c00
	ctx.lr = 0x825EF1E4;
	sub_82DF3C00(ctx, base);
	// 825EF1E4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825EF1E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825EF1EC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825EF1F0: 4886CF69  bl 0x82e5c158
	ctx.lr = 0x825EF1F4;
	sub_82E5C158(ctx, base);
	// 825EF1F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EF1F8: 48804231  bl 0x82df3428
	ctx.lr = 0x825EF1FC;
	sub_82DF3428(ctx, base);
	// 825EF1FC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825EF200: 48BB8FBC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EF208(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825EF208 size=1956
    let mut pc: u32 = 0x825EF208;
    'dispatch: loop {
        match pc {
            0x825EF208 => {
    //   block [0x825EF208..0x825EF9AC)
	// 825EF208: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EF20C: 48BB8F45  bl 0x831a8150
	ctx.lr = 0x825EF210;
	sub_831A8130(ctx, base);
	// 825EF210: DBC1FF98  stfd f30, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[30].u64 ) };
	// 825EF214: DBE1FFA0  stfd f31, -0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[31].u64 ) };
	// 825EF218: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EF21C: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 825EF220: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825EF224: 93410068  stw r26, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[26].u32 ) };
	// 825EF228: 7C972378  mr r23, r4
	ctx.r[23].u64 = ctx.r[4].u64;
	// 825EF22C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825EF230: 4BF25041  bl 0x82514270
	ctx.lr = 0x825EF234;
	sub_82514270(ctx, base);
	// 825EF234: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 825EF238: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825EF23C: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 825EF240: 488047C9  bl 0x82df3a08
	ctx.lr = 0x825EF244;
	sub_82DF3A08(ctx, base);
	// 825EF244: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825EF248: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825EF24C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EF250: 4BF19531  bl 0x82508780
	ctx.lr = 0x825EF254;
	sub_82508780(ctx, base);
	// 825EF254: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825EF258: 488041D1  bl 0x82df3428
	ctx.lr = 0x825EF25C;
	sub_82DF3428(ctx, base);
	// 825EF25C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825EF260: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 825EF264: 409A0008  bne cr6, 0x825ef26c
	if !ctx.cr[6].eq {
	pc = 0x825EF26C; continue 'dispatch;
	}
	// 825EF268: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825EF26C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EF270: 4BF19531  bl 0x825087a0
	ctx.lr = 0x825EF274;
	sub_825087A0(ctx, base);
	// 825EF274: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825EF278: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825EF27C: 3B0B03E8  addi r24, r11, 0x3e8
	ctx.r[24].s64 = ctx.r[11].s64 + 1000;
	// 825EF280: 38A00153  li r5, 0x153
	ctx.r[5].s64 = 339;
	// 825EF284: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 825EF288: 386000A8  li r3, 0xa8
	ctx.r[3].s64 = 168;
	// 825EF28C: 4880315D  bl 0x82df23e8
	ctx.lr = 0x825EF290;
	sub_82DF23E8(ctx, base);
	// 825EF290: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825EF294: 41820010  beq 0x825ef2a4
	if ctx.cr[0].eq {
	pc = 0x825EF2A4; continue 'dispatch;
	}
	// 825EF298: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825EF29C: 481E12B5  bl 0x827d0550
	ctx.lr = 0x825EF2A0;
	sub_827D0550(ctx, base);
	// 825EF2A0: 48000008  b 0x825ef2a8
	pc = 0x825EF2A8; continue 'dispatch;
	// 825EF2A4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825EF2A8: 817F028C  lwz r11, 0x28c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(652 as u32) ) } as u64;
	// 825EF2AC: 907F028C  stw r3, 0x28c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(652 as u32), ctx.r[3].u32 ) };
	// 825EF2B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825EF2B4: 419A001C  beq cr6, 0x825ef2d0
	if ctx.cr[6].eq {
	pc = 0x825EF2D0; continue 'dispatch;
	}
	// 825EF2B8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EF2BC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 825EF2C0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825EF2C4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EF2C8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825EF2CC: 4E800421  bctrl
	ctx.lr = 0x825EF2D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825EF2D0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 825EF2D4: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 825EF2D8: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 825EF2DC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825EF2E0: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 825EF2E4: 48557BBD  bl 0x82b46ea0
	ctx.lr = 0x825EF2E8;
	sub_82B46EA0(ctx, base);
	// 825EF2E8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825EF2EC: 395F0290  addi r10, r31, 0x290
	ctx.r[10].s64 = ctx.r[31].s64 + 656;
	// 825EF2F0: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 825EF2F4: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 825EF2F8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EF2FC: 917F0290  stw r11, 0x290(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(656 as u32), ctx.r[11].u32 ) };
	// 825EF300: 4BCD5161  bl 0x822c4460
	ctx.lr = 0x825EF304;
	sub_822C4460(ctx, base);
	// 825EF304: 806100CC  lwz r3, 0xcc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 825EF308: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EF30C: 419A0008  beq cr6, 0x825ef314
	if ctx.cr[6].eq {
	pc = 0x825EF314; continue 'dispatch;
	}
	// 825EF310: 4BCD1581  bl 0x822c0890
	ctx.lr = 0x825EF314;
	sub_822C0890(ctx, base);
	// 825EF314: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 825EF318: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825EF31C: 38A0015A  li r5, 0x15a
	ctx.r[5].s64 = 346;
	// 825EF320: 38600110  li r3, 0x110
	ctx.r[3].s64 = 272;
	// 825EF324: 488030C5  bl 0x82df23e8
	ctx.lr = 0x825EF328;
	sub_82DF23E8(ctx, base);
	// 825EF328: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 825EF32C: 41820094  beq 0x825ef3c0
	if ctx.cr[0].eq {
	pc = 0x825EF3C0; continue 'dispatch;
	}
	// 825EF330: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825EF334: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825EF338: 388B9BC9  addi r4, r11, -0x6437
	ctx.r[4].s64 = ctx.r[11].s64 + -25655;
	// 825EF33C: 488046CD  bl 0x82df3a08
	ctx.lr = 0x825EF340;
	sub_82DF3A08(ctx, base);
	// 825EF340: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 825EF344: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825EF348: 388B2E58  addi r4, r11, 0x2e58
	ctx.r[4].s64 = ctx.r[11].s64 + 11864;
	// 825EF34C: 488046BD  bl 0x82df3a08
	ctx.lr = 0x825EF350;
	sub_82DF3A08(ctx, base);
	// 825EF350: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EF354: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 825EF358: 481C7281  bl 0x827b65d8
	ctx.lr = 0x825EF35C;
	sub_827B65D8(ctx, base);
	// 825EF35C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825EF360: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EF364: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 825EF368: 3B40001F  li r26, 0x1f
	ctx.r[26].s64 = 31;
	// 825EF36C: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EF370: 481C7269  bl 0x827b65d8
	ctx.lr = 0x825EF374;
	sub_827B65D8(ctx, base);
	// 825EF374: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825EF378: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 825EF37C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EF380: 4BCFE799  bl 0x822edb18
	ctx.lr = 0x825EF384;
	sub_822EDB18(ctx, base);
	// 825EF384: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EF388: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825EF38C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825EF390: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825EF394: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825EF398: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825EF39C: 4E800421  bctrl
	ctx.lr = 0x825EF3A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825EF3A0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 825EF3A4: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 825EF3A8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825EF3AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EF3B0: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 825EF3B4: 481C483D  bl 0x827b3bf0
	ctx.lr = 0x825EF3B8;
	sub_827B3BF0(ctx, base);
	// 825EF3B8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825EF3BC: 48000008  b 0x825ef3c4
	pc = 0x825EF3C4; continue 'dispatch;
	// 825EF3C0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825EF3C4: 3BDF0284  addi r30, r31, 0x284
	ctx.r[30].s64 = ctx.r[31].s64 + 644;
	// 825EF3C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EF3CC: 4BFFD785  bl 0x825ecb50
	ctx.lr = 0x825EF3D0;
	sub_825ECB50(ctx, base);
	// 825EF3D0: 574B06F7  rlwinm. r11, r26, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825EF3D4: 41820018  beq 0x825ef3ec
	if ctx.cr[0].eq {
	pc = 0x825EF3EC; continue 'dispatch;
	}
	// 825EF3D8: 806100BC  lwz r3, 0xbc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 825EF3DC: 575A0734  rlwinm r26, r26, 0, 0x1c, 0x1a
	ctx.r[26].u64 = ctx.r[26].u32 as u64 & 0xFFFFFFFFu64;
	// 825EF3E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EF3E4: 419A0008  beq cr6, 0x825ef3ec
	if ctx.cr[6].eq {
	pc = 0x825EF3EC; continue 'dispatch;
	}
	// 825EF3E8: 4BCD14A9  bl 0x822c0890
	ctx.lr = 0x825EF3EC;
	sub_822C0890(ctx, base);
	// 825EF3EC: 574B0739  rlwinm. r11, r26, 0, 0x1c, 0x1c
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825EF3F0: 41820018  beq 0x825ef408
	if ctx.cr[0].eq {
	pc = 0x825EF408; continue 'dispatch;
	}
	// 825EF3F4: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 825EF3F8: 575A0776  rlwinm r26, r26, 0, 0x1d, 0x1b
	ctx.r[26].u64 = ctx.r[26].u32 as u64 & 0xFFFFFFFFu64;
	// 825EF3FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EF400: 419A0008  beq cr6, 0x825ef408
	if ctx.cr[6].eq {
	pc = 0x825EF408; continue 'dispatch;
	}
	// 825EF404: 4BCD148D  bl 0x822c0890
	ctx.lr = 0x825EF408;
	sub_822C0890(ctx, base);
	// 825EF408: 574B077B  rlwinm. r11, r26, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825EF40C: 41820018  beq 0x825ef424
	if ctx.cr[0].eq {
	pc = 0x825EF424; continue 'dispatch;
	}
	// 825EF410: 806100DC  lwz r3, 0xdc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) } as u64;
	// 825EF414: 575A07B8  rlwinm r26, r26, 0, 0x1e, 0x1c
	ctx.r[26].u64 = ctx.r[26].u32 as u64 & 0xFFFFFFFFu64;
	// 825EF418: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EF41C: 419A0008  beq cr6, 0x825ef424
	if ctx.cr[6].eq {
	pc = 0x825EF424; continue 'dispatch;
	}
	// 825EF420: 4BCD1471  bl 0x822c0890
	ctx.lr = 0x825EF424;
	sub_822C0890(ctx, base);
	// 825EF424: 574B07BD  rlwinm. r11, r26, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825EF428: 41820010  beq 0x825ef438
	if ctx.cr[0].eq {
	pc = 0x825EF438; continue 'dispatch;
	}
	// 825EF42C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825EF430: 575A07FA  rlwinm r26, r26, 0, 0x1f, 0x1d
	ctx.r[26].u64 = ctx.r[26].u32 as u64 & 0xFFFFFFFFu64;
	// 825EF434: 48803FF5  bl 0x82df3428
	ctx.lr = 0x825EF438;
	sub_82DF3428(ctx, base);
	// 825EF438: 574B07FF  clrlwi. r11, r26, 0x1f
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825EF43C: 41820010  beq 0x825ef44c
	if ctx.cr[0].eq {
	pc = 0x825EF44C; continue 'dispatch;
	}
	// 825EF440: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825EF444: 575A003C  rlwinm r26, r26, 0, 0, 0x1e
	ctx.r[26].u64 = ctx.r[26].u32 as u64 & 0xFFFFFFFFu64;
	// 825EF448: 48803FE1  bl 0x82df3428
	ctx.lr = 0x825EF44C;
	sub_82DF3428(ctx, base);
	// 825EF44C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825EF450: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EF454: 481C45F5  bl 0x827b3a48
	ctx.lr = 0x825EF458;
	sub_827B3A48(ctx, base);
	// 825EF458: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 825EF45C: 83BE0000  lwz r29, 0(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EF460: 48A19B59  bl 0x83008fb8
	ctx.lr = 0x825EF464;
	sub_83008FB8(ctx, base);
	// 825EF464: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825EF468: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825EF46C: 4854777D  bl 0x82b36be8
	ctx.lr = 0x825EF470;
	sub_82B36BE8(ctx, base);
	// 825EF470: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825EF474: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EF478: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825EF47C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825EF480: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 825EF484: 419A0024  beq cr6, 0x825ef4a8
	if ctx.cr[6].eq {
	pc = 0x825EF4A8; continue 'dispatch;
	}
	// 825EF488: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825EF48C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825EF490: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825EF494: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825EF498: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825EF49C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825EF4A0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825EF4A4: 4082FFE8  bne 0x825ef48c
	if !ctx.cr[0].eq {
	pc = 0x825EF48C; continue 'dispatch;
	}
	// 825EF4A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EF4AC: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 825EF4B0: 4BF20019  bl 0x8250f4c8
	ctx.lr = 0x825EF4B4;
	sub_8250F4C8(ctx, base);
	// 825EF4B4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EF4B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825EF4BC: 3BCBFFFC  addi r30, r11, -4
	ctx.r[30].s64 = ctx.r[11].s64 + -4;
	// 825EF4C0: 409A0008  bne cr6, 0x825ef4c8
	if !ctx.cr[6].eq {
	pc = 0x825EF4C8; continue 'dispatch;
	}
	// 825EF4C4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825EF4C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EF4CC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825EF4D0: 3BA10058  addi r29, r1, 0x58
	ctx.r[29].s64 = ctx.r[1].s64 + 88;
	// 825EF4D4: 4BF20045  bl 0x8250f518
	ctx.lr = 0x825EF4D8;
	sub_8250F518(ctx, base);
	// 825EF4D8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825EF4DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EF4E0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825EF4E4: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 825EF4E8: 4BF1E021  bl 0x8250d508
	ctx.lr = 0x825EF4EC;
	sub_8250D508(ctx, base);
	// 825EF4EC: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 825EF4F0: 488027A1  bl 0x82df1c90
	ctx.lr = 0x825EF4F4;
	sub_82DF1C90(ctx, base);
	// 825EF4F4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825EF4F8: 48802799  bl 0x82df1c90
	ctx.lr = 0x825EF4FC;
	sub_82DF1C90(ctx, base);
	// 825EF4FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EF500: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 825EF504: 481C70D5  bl 0x827b65d8
	ctx.lr = 0x825EF508;
	sub_827B65D8(ctx, base);
	// 825EF508: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EF50C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825EF510: 832B0008  lwz r25, 8(r11)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825EF514: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 825EF518: 419A000C  beq cr6, 0x825ef524
	if ctx.cr[6].eq {
	pc = 0x825EF524; continue 'dispatch;
	}
	// 825EF51C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 825EF520: 488DF2E1  bl 0x82ece800
	ctx.lr = 0x825EF524;
	sub_82ECE800(ctx, base);
	// 825EF524: 806100AC  lwz r3, 0xac(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 825EF528: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EF52C: 419A0008  beq cr6, 0x825ef534
	if ctx.cr[6].eq {
	pc = 0x825EF534; continue 'dispatch;
	}
	// 825EF530: 4BCD1361  bl 0x822c0890
	ctx.lr = 0x825EF534;
	sub_822C0890(ctx, base);
	// 825EF534: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EF538: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 825EF53C: 481C709D  bl 0x827b65d8
	ctx.lr = 0x825EF540;
	sub_827B65D8(ctx, base);
	// 825EF540: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825EF544: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EF548: 808B6830  lwz r4, 0x6830(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26672 as u32) ) } as u64;
	// 825EF54C: 4BE9FE55  bl 0x8248f3a0
	ctx.lr = 0x825EF550;
	sub_8248F3A0(ctx, base);
	// 825EF550: 806100EC  lwz r3, 0xec(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(236 as u32) ) } as u64;
	// 825EF554: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EF558: 419A0008  beq cr6, 0x825ef560
	if ctx.cr[6].eq {
	pc = 0x825EF560; continue 'dispatch;
	}
	// 825EF55C: 4BCD1335  bl 0x822c0890
	ctx.lr = 0x825EF560;
	sub_822C0890(ctx, base);
	// 825EF560: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EF564: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825EF568: 481C7071  bl 0x827b65d8
	ctx.lr = 0x825EF56C;
	sub_827B65D8(ctx, base);
	// 825EF56C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825EF570: 38802012  li r4, 0x2012
	ctx.r[4].s64 = 8210;
	// 825EF574: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EF578: 4BE9FFB9  bl 0x8248f530
	ctx.lr = 0x825EF57C;
	sub_8248F530(ctx, base);
	// 825EF57C: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 825EF580: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EF584: 419A0008  beq cr6, 0x825ef58c
	if ctx.cr[6].eq {
	pc = 0x825EF58C; continue 'dispatch;
	}
	// 825EF588: 4BCD1309  bl 0x822c0890
	ctx.lr = 0x825EF58C;
	sub_822C0890(ctx, base);
	// 825EF58C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EF590: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825EF594: 481C7045  bl 0x827b65d8
	ctx.lr = 0x825EF598;
	sub_827B65D8(ctx, base);
	// 825EF598: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825EF59C: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EF5A0: C3CB9450  lfs f30, -0x6bb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 825EF5A4: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825EF5A8: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 825EF5AC: 488DBF45  bl 0x82ecb4f0
	ctx.lr = 0x825EF5B0;
	sub_82ECB4F0(ctx, base);
	// 825EF5B0: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 825EF5B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EF5B8: 419A0008  beq cr6, 0x825ef5c0
	if ctx.cr[6].eq {
	pc = 0x825EF5C0; continue 'dispatch;
	}
	// 825EF5BC: 4BCD12D5  bl 0x822c0890
	ctx.lr = 0x825EF5C0;
	sub_822C0890(ctx, base);
	// 825EF5C0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EF5C4: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825EF5C8: 481C7011  bl 0x827b65d8
	ctx.lr = 0x825EF5CC;
	sub_827B65D8(ctx, base);
	// 825EF5CC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EF5D0: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 825EF5D4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825EF5D8: C3EA964C  lfs f31, -0x69b4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825EF5DC: D3EB0184  stfs f31, 0x184(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 825EF5E0: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 825EF5E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EF5E8: 419A0008  beq cr6, 0x825ef5f0
	if ctx.cr[6].eq {
	pc = 0x825EF5F0; continue 'dispatch;
	}
	// 825EF5EC: 4BCD12A5  bl 0x822c0890
	ctx.lr = 0x825EF5F0;
	sub_822C0890(ctx, base);
	// 825EF5F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EF5F4: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 825EF5F8: 481C6FE1  bl 0x827b65d8
	ctx.lr = 0x825EF5FC;
	sub_827B65D8(ctx, base);
	// 825EF5FC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EF600: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825EF604: D3EB0188  stfs f31, 0x188(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 825EF608: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 825EF60C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EF610: 419A0008  beq cr6, 0x825ef618
	if ctx.cr[6].eq {
	pc = 0x825EF618; continue 'dispatch;
	}
	// 825EF614: 4BCD127D  bl 0x822c0890
	ctx.lr = 0x825EF618;
	sub_822C0890(ctx, base);
	// 825EF618: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EF61C: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 825EF620: 481C6FB9  bl 0x827b65d8
	ctx.lr = 0x825EF624;
	sub_827B65D8(ctx, base);
	// 825EF624: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 825EF628: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EF62C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825EF630: C3EB6218  lfs f31, 0x6218(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(25112 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825EF634: D3E10060  stfs f31, 0x60(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 825EF638: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825EF63C: 386B018C  addi r3, r11, 0x18c
	ctx.r[3].s64 = ctx.r[11].s64 + 396;
	// 825EF640: 488B8411  bl 0x82ea7a50
	ctx.lr = 0x825EF644;
	sub_82EA7A50(ctx, base);
	// 825EF644: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 825EF648: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EF64C: 419A0008  beq cr6, 0x825ef654
	if ctx.cr[6].eq {
	pc = 0x825EF654; continue 'dispatch;
	}
	// 825EF650: 4BCD1241  bl 0x822c0890
	ctx.lr = 0x825EF654;
	sub_822C0890(ctx, base);
	// 825EF654: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EF658: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 825EF65C: 481C6F7D  bl 0x827b65d8
	ctx.lr = 0x825EF660;
	sub_827B65D8(ctx, base);
	// 825EF660: D3E10060  stfs f31, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 825EF664: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EF668: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825EF66C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825EF670: 386B018D  addi r3, r11, 0x18d
	ctx.r[3].s64 = ctx.r[11].s64 + 397;
	// 825EF674: 488B83DD  bl 0x82ea7a50
	ctx.lr = 0x825EF678;
	sub_82EA7A50(ctx, base);
	// 825EF678: 806100C4  lwz r3, 0xc4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 825EF67C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EF680: 419A0008  beq cr6, 0x825ef688
	if ctx.cr[6].eq {
	pc = 0x825EF688; continue 'dispatch;
	}
	// 825EF684: 4BCD120D  bl 0x822c0890
	ctx.lr = 0x825EF688;
	sub_822C0890(ctx, base);
	// 825EF688: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EF68C: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 825EF690: 481C6F49  bl 0x827b65d8
	ctx.lr = 0x825EF694;
	sub_827B65D8(ctx, base);
	// 825EF694: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EF698: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 825EF69C: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825EF6A0: 488DBE81  bl 0x82ecb520
	ctx.lr = 0x825EF6A4;
	sub_82ECB520(ctx, base);
	// 825EF6A4: 806100D4  lwz r3, 0xd4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 825EF6A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EF6AC: 419A0008  beq cr6, 0x825ef6b4
	if ctx.cr[6].eq {
	pc = 0x825EF6B4; continue 'dispatch;
	}
	// 825EF6B0: 4BCD11E1  bl 0x822c0890
	ctx.lr = 0x825EF6B4;
	sub_822C0890(ctx, base);
	// 825EF6B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EF6B8: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 825EF6BC: 481C6F1D  bl 0x827b65d8
	ctx.lr = 0x825EF6C0;
	sub_827B65D8(ctx, base);
	// 825EF6C0: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EF6C4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825EF6C8: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825EF6CC: C02B0A90  lfs f1, 0xa90(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2704 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825EF6D0: 488DBE59  bl 0x82ecb528
	ctx.lr = 0x825EF6D4;
	sub_82ECB528(ctx, base);
	// 825EF6D4: 806100E4  lwz r3, 0xe4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(228 as u32) ) } as u64;
	// 825EF6D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EF6DC: 419A0008  beq cr6, 0x825ef6e4
	if ctx.cr[6].eq {
	pc = 0x825EF6E4; continue 'dispatch;
	}
	// 825EF6E0: 4BCD11B1  bl 0x822c0890
	ctx.lr = 0x825EF6E4;
	sub_822C0890(ctx, base);
	// 825EF6E4: 817F0164  lwz r11, 0x164(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 825EF6E8: 3BDF0164  addi r30, r31, 0x164
	ctx.r[30].s64 = ctx.r[31].s64 + 356;
	// 825EF6EC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EF6F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EF6F4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825EF6F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825EF6FC: 4E800421  bctrl
	ctx.lr = 0x825EF700;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825EF700: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825EF704: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825EF708: 3BAB0380  addi r29, r11, 0x380
	ctx.r[29].s64 = ctx.r[11].s64 + 896;
	// 825EF70C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825EF710: 488042F9  bl 0x82df3a08
	ctx.lr = 0x825EF714;
	sub_82DF3A08(ctx, base);
	// 825EF714: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825EF718: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EF71C: 4BFFF90D  bl 0x825ef028
	ctx.lr = 0x825EF720;
	sub_825EF028(ctx, base);
	// 825EF720: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825EF724: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825EF728: 388B039C  addi r4, r11, 0x39c
	ctx.r[4].s64 = ctx.r[11].s64 + 924;
	// 825EF72C: 488042DD  bl 0x82df3a08
	ctx.lr = 0x825EF730;
	sub_82DF3A08(ctx, base);
	// 825EF730: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825EF734: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EF738: 4BFFF951  bl 0x825ef088
	ctx.lr = 0x825EF73C;
	sub_825EF088(ctx, base);
	// 825EF73C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825EF740: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825EF744: 388B03A4  addi r4, r11, 0x3a4
	ctx.r[4].s64 = ctx.r[11].s64 + 932;
	// 825EF748: 488042C1  bl 0x82df3a08
	ctx.lr = 0x825EF74C;
	sub_82DF3A08(ctx, base);
	// 825EF74C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825EF750: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EF754: 4BFFF995  bl 0x825ef0e8
	ctx.lr = 0x825EF758;
	sub_825EF0E8(ctx, base);
	// 825EF758: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825EF75C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825EF760: 388B0370  addi r4, r11, 0x370
	ctx.r[4].s64 = ctx.r[11].s64 + 880;
	// 825EF764: 488042A5  bl 0x82df3a08
	ctx.lr = 0x825EF768;
	sub_82DF3A08(ctx, base);
	// 825EF768: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825EF76C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EF770: 4BFFF9D9  bl 0x825ef148
	ctx.lr = 0x825EF774;
	sub_825EF148(ctx, base);
	// 825EF774: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825EF778: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825EF77C: 388B0378  addi r4, r11, 0x378
	ctx.r[4].s64 = ctx.r[11].s64 + 888;
	// 825EF780: 48804289  bl 0x82df3a08
	ctx.lr = 0x825EF784;
	sub_82DF3A08(ctx, base);
	// 825EF784: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825EF788: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EF78C: 4BFFFA1D  bl 0x825ef1a8
	ctx.lr = 0x825EF790;
	sub_825EF1A8(ctx, base);
	// 825EF790: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825EF794: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825EF798: 48804271  bl 0x82df3a08
	ctx.lr = 0x825EF79C;
	sub_82DF3A08(ctx, base);
	// 825EF79C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825EF7A0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825EF7A4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825EF7A8: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 825EF7AC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825EF7B0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825EF7B4: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825EF7B8: 4886F1A9  bl 0x82e5e960
	ctx.lr = 0x825EF7BC;
	sub_82E5E960(ctx, base);
	// 825EF7BC: 806100F4  lwz r3, 0xf4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 825EF7C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EF7C4: 419A0008  beq cr6, 0x825ef7cc
	if ctx.cr[6].eq {
	pc = 0x825EF7CC; continue 'dispatch;
	}
	// 825EF7C8: 4BCD10C9  bl 0x822c0890
	ctx.lr = 0x825EF7CC;
	sub_822C0890(ctx, base);
	// 825EF7CC: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 825EF7D0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825EF7D4: 38A00175  li r5, 0x175
	ctx.r[5].s64 = 373;
	// 825EF7D8: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 825EF7DC: 4BCD0BFD  bl 0x822c03d8
	ctx.lr = 0x825EF7E0;
	sub_822C03D8(ctx, base);
	// 825EF7E0: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 825EF7E4: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 825EF7E8: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 825EF7EC: 3B600020  li r27, 0x20
	ctx.r[27].s64 = 32;
	// 825EF7F0: 3BAB6910  addi r29, r11, 0x6910
	ctx.r[29].s64 = ctx.r[11].s64 + 26896;
	// 825EF7F4: 3B8ABA80  addi r28, r10, -0x4580
	ctx.r[28].s64 = ctx.r[10].s64 + -17792;
	// 825EF7F8: 41820090  beq 0x825ef888
	if ctx.cr[0].eq {
	pc = 0x825EF888; continue 'dispatch;
	}
	// 825EF7FC: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EF800: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 825EF804: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 825EF808: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 825EF80C: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825EF810: 488B0F21  bl 0x82ea0730
	ctx.lr = 0x825EF814;
	sub_82EA0730(ctx, base);
	// 825EF814: B3630004  sth r27, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[27].u16 ) };
	// 825EF818: C03F0254  lfs f1, 0x254(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(596 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825EF81C: 4892A9D5  bl 0x82f1a1f0
	ctx.lr = 0x825EF820;
	sub_82F1A1F0(ctx, base);
	// 825EF820: 9061006C  stw r3, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[3].u32 ) };
	// 825EF824: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825EF828: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 825EF82C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825EF830: 635A0020  ori r26, r26, 0x20
	ctx.r[26].u64 = ctx.r[26].u64 | 32;
	// 825EF834: 80AB67D4  lwz r5, 0x67d4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26580 as u32) ) } as u64;
	// 825EF838: 808A683C  lwz r4, 0x683c(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(26684 as u32) ) } as u64;
	// 825EF83C: 4BD07F65  bl 0x822f77a0
	ctx.lr = 0x825EF840;
	sub_822F77A0(ctx, base);
	// 825EF840: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 825EF844: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825EF848: 4BCF5679  bl 0x822e4ec0
	ctx.lr = 0x825EF84C;
	sub_822E4EC0(ctx, base);
	// 825EF84C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825EF850: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825EF854: E8960000  ld r4, 0(r22)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) };
	// 825EF858: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825EF85C: E8630000  ld r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 825EF860: 4BE9CA29  bl 0x8248c288
	ctx.lr = 0x825EF864;
	sub_8248C288(ctx, base);
	// 825EF864: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 825EF868: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 825EF86C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 825EF870: 38A1006C  addi r5, r1, 0x6c
	ctx.r[5].s64 = ctx.r[1].s64 + 108;
	// 825EF874: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 825EF878: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EF87C: 4BEA2925  bl 0x824921a0
	ctx.lr = 0x825EF880;
	sub_824921A0(ctx, base);
	// 825EF880: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825EF884: 48000008  b 0x825ef88c
	pc = 0x825EF88C; continue 'dispatch;
	// 825EF888: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825EF88C: 387F0274  addi r3, r31, 0x274
	ctx.r[3].s64 = ctx.r[31].s64 + 628;
	// 825EF890: 4BCF5559  bl 0x822e4de8
	ctx.lr = 0x825EF894;
	sub_822E4DE8(ctx, base);
	// 825EF894: 574B06B5  rlwinm. r11, r26, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825EF898: 41820018  beq 0x825ef8b0
	if ctx.cr[0].eq {
	pc = 0x825EF8B0; continue 'dispatch;
	}
	// 825EF89C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 825EF8A0: 575A06F2  rlwinm r26, r26, 0, 0x1b, 0x19
	ctx.r[26].u64 = ctx.r[26].u32 as u64 & 0xFFFFFFFFu64;
	// 825EF8A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EF8A8: 419A0008  beq cr6, 0x825ef8b0
	if ctx.cr[6].eq {
	pc = 0x825EF8B0; continue 'dispatch;
	}
	// 825EF8AC: 4BCF89BD  bl 0x822e8268
	ctx.lr = 0x825EF8B0;
	sub_822E8268(ctx, base);
	// 825EF8B0: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 825EF8B4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825EF8B8: 38A00177  li r5, 0x177
	ctx.r[5].s64 = 375;
	// 825EF8BC: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 825EF8C0: 4BCD0B19  bl 0x822c03d8
	ctx.lr = 0x825EF8C4;
	sub_822C03D8(ctx, base);
	// 825EF8C4: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 825EF8C8: 41820088  beq 0x825ef950
	if ctx.cr[0].eq {
	pc = 0x825EF950; continue 'dispatch;
	}
	// 825EF8CC: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EF8D0: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 825EF8D4: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 825EF8D8: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 825EF8DC: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825EF8E0: 488B0E51  bl 0x82ea0730
	ctx.lr = 0x825EF8E4;
	sub_82EA0730(ctx, base);
	// 825EF8E4: B3630004  sth r27, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[27].u16 ) };
	// 825EF8E8: C03F0258  lfs f1, 0x258(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(600 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825EF8EC: 4892A905  bl 0x82f1a1f0
	ctx.lr = 0x825EF8F0;
	sub_82F1A1F0(ctx, base);
	// 825EF8F0: 90610068  stw r3, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[3].u32 ) };
	// 825EF8F4: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825EF8F8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825EF8FC: 635A0040  ori r26, r26, 0x40
	ctx.r[26].u64 = ctx.r[26].u64 | 64;
	// 825EF900: 808B6750  lwz r4, 0x6750(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26448 as u32) ) } as u64;
	// 825EF904: 4BCF562D  bl 0x822e4f30
	ctx.lr = 0x825EF908;
	sub_822E4F30(ctx, base);
	// 825EF908: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825EF90C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825EF910: 4BCF55B1  bl 0x822e4ec0
	ctx.lr = 0x825EF914;
	sub_822E4EC0(ctx, base);
	// 825EF914: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825EF918: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825EF91C: E89B0000  ld r4, 0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	// 825EF920: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825EF924: E8630000  ld r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 825EF928: 4BE9C961  bl 0x8248c288
	ctx.lr = 0x825EF92C;
	sub_8248C288(ctx, base);
	// 825EF92C: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 825EF930: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 825EF934: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 825EF938: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 825EF93C: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 825EF940: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EF944: 4BEA285D  bl 0x824921a0
	ctx.lr = 0x825EF948;
	sub_824921A0(ctx, base);
	// 825EF948: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825EF94C: 48000008  b 0x825ef954
	pc = 0x825EF954; continue 'dispatch;
	// 825EF950: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825EF954: 387F027C  addi r3, r31, 0x27c
	ctx.r[3].s64 = ctx.r[31].s64 + 636;
	// 825EF958: 4BCF5491  bl 0x822e4de8
	ctx.lr = 0x825EF95C;
	sub_822E4DE8(ctx, base);
	// 825EF95C: 574B0673  rlwinm. r11, r26, 0, 0x19, 0x19
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825EF960: 41820014  beq 0x825ef974
	if ctx.cr[0].eq {
	pc = 0x825EF974; continue 'dispatch;
	}
	// 825EF964: 80610068  lwz r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 825EF968: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825EF96C: 419A0008  beq cr6, 0x825ef974
	if ctx.cr[6].eq {
	pc = 0x825EF974; continue 'dispatch;
	}
	// 825EF970: 4BCF88F9  bl 0x822e8268
	ctx.lr = 0x825EF974;
	sub_822E8268(ctx, base);
	// 825EF974: 817F01D4  lwz r11, 0x1d4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(468 as u32) ) } as u64;
	// 825EF978: 3D408329  lis r10, -0x7cd7
	ctx.r[10].s64 = -2094465024;
	// 825EF97C: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 825EF980: 394AE134  addi r10, r10, -0x1ecc
	ctx.r[10].s64 = ctx.r[10].s64 + -7884;
	// 825EF984: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825EF988: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 825EF98C: 917F0298  stw r11, 0x298(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(664 as u32), ctx.r[11].u32 ) };
	// 825EF990: 419A000C  beq cr6, 0x825ef99c
	if ctx.cr[6].eq {
	pc = 0x825EF99C; continue 'dispatch;
	}
	// 825EF994: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 825EF998: 488DD671  bl 0x82ecd008
	ctx.lr = 0x825EF99C;
	sub_82ECD008(ctx, base);
	// 825EF99C: 38210160  addi r1, r1, 0x160
	ctx.r[1].s64 = ctx.r[1].s64 + 352;
	// 825EF9A0: CBC1FF98  lfd f30, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-104 as u32) ) };
	// 825EF9A4: CBE1FFA0  lfd f31, -0x60(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 825EF9A8: 48BB87F8  b 0x831a81a0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EF9B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825EF9B0 size=12
    let mut pc: u32 = 0x825EF9B0;
    'dispatch: loop {
        match pc {
            0x825EF9B0 => {
    //   block [0x825EF9B0..0x825EF9BC)
	// 825EF9B0: 8163012C  lwz r11, 0x12c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(300 as u32) ) } as u64;
	// 825EF9B4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825EF9B8: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EF9BC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825EF9BC size=16
    let mut pc: u32 = 0x825EF9BC;
    'dispatch: loop {
        match pc {
            0x825EF9BC => {
    //   block [0x825EF9BC..0x825EF9CC)
	// 825EF9BC: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 825EF9C0: 40990044  ble cr6, 0x825efa04
	if !ctx.cr[6].gt {
		sub_825EFA04(ctx, base);
		return;
	}
	// 825EF9C4: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 825EF9C8: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EF9CC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825EF9CC size=16
    let mut pc: u32 = 0x825EF9CC;
    'dispatch: loop {
        match pc {
            0x825EF9CC => {
    //   block [0x825EF9CC..0x825EF9DC)
	// 825EF9CC: 2B040001  cmplwi cr6, r4, 1
	ctx.cr[6].compare_u32(ctx.r[4].u32, 1 as u32, &mut ctx.xer);
	// 825EF9D0: 419A0024  beq cr6, 0x825ef9f4
	if ctx.cr[6].eq {
		sub_825EF9F4(ctx, base);
		return;
	}
	// 825EF9D4: 2B040002  cmplwi cr6, r4, 2
	ctx.cr[6].compare_u32(ctx.r[4].u32, 2 as u32, &mut ctx.xer);
	// 825EF9D8: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EF9DC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825EF9DC size=24
    let mut pc: u32 = 0x825EF9DC;
    'dispatch: loop {
        match pc {
            0x825EF9DC => {
    //   block [0x825EF9DC..0x825EF9F4)
	// 825EF9DC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825EF9E0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825EF9E4: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825EF9E8: D0030148  stfs f0, 0x148(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(328 as u32), tmp.u32 ) };
	// 825EF9EC: 99430143  stb r10, 0x143(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(323 as u32), ctx.r[10].u8 ) };
	// 825EF9F0: 48000064  b 0x825efa54
	sub_825EFA38(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EF9F4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825EF9F4 size=16
    let mut pc: u32 = 0x825EF9F4;
    'dispatch: loop {
        match pc {
            0x825EF9F4 => {
    //   block [0x825EF9F4..0x825EFA04)
	// 825EF9F4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825EF9F8: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 825EF9FC: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825EFA00: 48000044  b 0x825efa44
	sub_825EFA38(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EFA04(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825EFA04 size=24
    let mut pc: u32 = 0x825EFA04;
    'dispatch: loop {
        match pc {
            0x825EFA04 => {
    //   block [0x825EFA04..0x825EFA1C)
	// 825EFA04: 2B040001  cmplwi cr6, r4, 1
	ctx.cr[6].compare_u32(ctx.r[4].u32, 1 as u32, &mut ctx.xer);
	// 825EFA08: 419A0030  beq cr6, 0x825efa38
	if ctx.cr[6].eq {
		sub_825EFA38(ctx, base);
		return;
	}
	// 825EFA0C: 2B040002  cmplwi cr6, r4, 2
	ctx.cr[6].compare_u32(ctx.r[4].u32, 2 as u32, &mut ctx.xer);
	// 825EFA10: 419A001C  beq cr6, 0x825efa2c
	if ctx.cr[6].eq {
		sub_825EFA2C(ctx, base);
		return;
	}
	// 825EFA14: 2B040003  cmplwi cr6, r4, 3
	ctx.cr[6].compare_u32(ctx.r[4].u32, 3 as u32, &mut ctx.xer);
	// 825EFA18: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EFA1C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825EFA1C size=16
    let mut pc: u32 = 0x825EFA1C;
    'dispatch: loop {
        match pc {
            0x825EFA1C => {
    //   block [0x825EFA1C..0x825EFA2C)
	// 825EFA1C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825EFA20: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825EFA24: C00B08A8  lfs f0, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825EFA28: 4BFFFFC0  b 0x825ef9e8
	sub_825EF9DC(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EFA2C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825EFA2C size=12
    let mut pc: u32 = 0x825EFA2C;
    'dispatch: loop {
        match pc {
            0x825EFA2C => {
    //   block [0x825EFA2C..0x825EFA38)
	// 825EFA2C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825EFA30: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825EFA34: 4800000C  b 0x825efa40
	sub_825EFA38(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EFA38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825EFA38 size=36
    let mut pc: u32 = 0x825EFA38;
    'dispatch: loop {
        match pc {
            0x825EFA38 => {
    //   block [0x825EFA38..0x825EFA5C)
	// 825EFA38: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825EFA3C: C00B08A8  lfs f0, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825EFA40: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 825EFA44: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 825EFA48: 99230143  stb r9, 0x143(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(323 as u32), ctx.r[9].u8 ) };
	// 825EFA4C: C1AA9450  lfs f13, -0x6bb0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825EFA50: D1A30148  stfs f13, 0x148(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(328 as u32), tmp.u32 ) };
	// 825EFA54: D0030144  stfs f0, 0x144(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(324 as u32), tmp.u32 ) };
	// 825EFA58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EFA60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825EFA60 size=16
    let mut pc: u32 = 0x825EFA60;
    'dispatch: loop {
        match pc {
            0x825EFA60 => {
    //   block [0x825EFA60..0x825EFA70)
	// 825EFA60: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825EFA64: 386BFF18  addi r3, r11, -0xe8
	ctx.r[3].s64 = ctx.r[11].s64 + -232;
	// 825EFA68: 808B004C  lwz r4, 0x4c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 825EFA6C: 4BFFFF44  b 0x825ef9b0
	sub_825EF9B0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EFA70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825EFA70 size=12
    let mut pc: u32 = 0x825EFA70;
    'dispatch: loop {
        match pc {
            0x825EFA70 => {
    //   block [0x825EFA70..0x825EFA7C)
	// 825EFA70: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825EFA74: 99630049  stb r11, 0x49(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(73 as u32), ctx.r[11].u8 ) };
	// 825EFA78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EFA80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825EFA80 size=12
    let mut pc: u32 = 0x825EFA80;
    'dispatch: loop {
        match pc {
            0x825EFA80 => {
    //   block [0x825EFA80..0x825EFA8C)
	// 825EFA80: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825EFA84: 99630049  stb r11, 0x49(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(73 as u32), ctx.r[11].u8 ) };
	// 825EFA88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EFA90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825EFA90 size=12
    let mut pc: u32 = 0x825EFA90;
    'dispatch: loop {
        match pc {
            0x825EFA90 => {
    //   block [0x825EFA90..0x825EFA9C)
	// 825EFA90: 89630131  lbz r11, 0x131(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(305 as u32) ) } as u64;
	// 825EFA94: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825EFA98: 4D820020  beqlr
	if ctx.cr[0].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EFA9C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825EFA9C size=12
    let mut pc: u32 = 0x825EFA9C;
    'dispatch: loop {
        match pc {
            0x825EFA9C => {
    //   block [0x825EFA9C..0x825EFAA8)
	// 825EFA9C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825EFAA0: 91630134  stw r11, 0x134(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(308 as u32), ctx.r[11].u32 ) };
	// 825EFAA4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EFAA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825EFAA8 size=136
    let mut pc: u32 = 0x825EFAA8;
    'dispatch: loop {
        match pc {
            0x825EFAA8 => {
    //   block [0x825EFAA8..0x825EFB30)
	// 825EFAA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EFAAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825EFAB0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825EFAB4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825EFAB8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EFABC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825EFAC0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825EFAC4: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 825EFAC8: 409A0020  bne cr6, 0x825efae8
	if !ctx.cr[6].eq {
	pc = 0x825EFAE8; continue 'dispatch;
	}
	// 825EFACC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825EFAD0: 419A0048  beq cr6, 0x825efb18
	if ctx.cr[6].eq {
	pc = 0x825EFB18; continue 'dispatch;
	}
	// 825EFAD4: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 825EFAD8: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 825EFADC: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 825EFAE0: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 825EFAE4: 48000034  b 0x825efb18
	pc = 0x825EFB18; continue 'dispatch;
	// 825EFAE8: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 825EFAEC: 419A002C  beq cr6, 0x825efb18
	if ctx.cr[6].eq {
	pc = 0x825EFB18; continue 'dispatch;
	}
	// 825EFAF0: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825EFAF4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EFAF8: 388BE710  addi r4, r11, -0x18f0
	ctx.r[4].s64 = ctx.r[11].s64 + -6384;
	// 825EFAFC: 48BB85FD  bl 0x831a80f8
	ctx.lr = 0x825EFB00;
	sub_831A80F8(ctx, base);
	// 825EFB00: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825EFB04: 4182000C  beq 0x825efb10
	if ctx.cr[0].eq {
	pc = 0x825EFB10; continue 'dispatch;
	}
	// 825EFB08: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 825EFB0C: 4800000C  b 0x825efb18
	pc = 0x825EFB18; continue 'dispatch;
	// 825EFB10: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825EFB14: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825EFB18: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825EFB1C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825EFB20: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825EFB24: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825EFB28: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825EFB2C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EFB30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825EFB30 size=136
    let mut pc: u32 = 0x825EFB30;
    'dispatch: loop {
        match pc {
            0x825EFB30 => {
    //   block [0x825EFB30..0x825EFBB8)
	// 825EFB30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EFB34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825EFB38: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825EFB3C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825EFB40: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EFB44: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825EFB48: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825EFB4C: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 825EFB50: 409A0020  bne cr6, 0x825efb70
	if !ctx.cr[6].eq {
	pc = 0x825EFB70; continue 'dispatch;
	}
	// 825EFB54: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825EFB58: 419A0048  beq cr6, 0x825efba0
	if ctx.cr[6].eq {
	pc = 0x825EFBA0; continue 'dispatch;
	}
	// 825EFB5C: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 825EFB60: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 825EFB64: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 825EFB68: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 825EFB6C: 48000034  b 0x825efba0
	pc = 0x825EFBA0; continue 'dispatch;
	// 825EFB70: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 825EFB74: 419A002C  beq cr6, 0x825efba0
	if ctx.cr[6].eq {
	pc = 0x825EFBA0; continue 'dispatch;
	}
	// 825EFB78: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825EFB7C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EFB80: 388BE7B8  addi r4, r11, -0x1848
	ctx.r[4].s64 = ctx.r[11].s64 + -6216;
	// 825EFB84: 48BB8575  bl 0x831a80f8
	ctx.lr = 0x825EFB88;
	sub_831A80F8(ctx, base);
	// 825EFB88: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825EFB8C: 4182000C  beq 0x825efb98
	if ctx.cr[0].eq {
	pc = 0x825EFB98; continue 'dispatch;
	}
	// 825EFB90: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 825EFB94: 4800000C  b 0x825efba0
	pc = 0x825EFBA0; continue 'dispatch;
	// 825EFB98: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825EFB9C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825EFBA0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825EFBA4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825EFBA8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825EFBAC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825EFBB0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825EFBB4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EFBB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825EFBB8 size=136
    let mut pc: u32 = 0x825EFBB8;
    'dispatch: loop {
        match pc {
            0x825EFBB8 => {
    //   block [0x825EFBB8..0x825EFC40)
	// 825EFBB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EFBBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825EFBC0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825EFBC4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825EFBC8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EFBCC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825EFBD0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825EFBD4: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 825EFBD8: 409A0020  bne cr6, 0x825efbf8
	if !ctx.cr[6].eq {
	pc = 0x825EFBF8; continue 'dispatch;
	}
	// 825EFBDC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825EFBE0: 419A0048  beq cr6, 0x825efc28
	if ctx.cr[6].eq {
	pc = 0x825EFC28; continue 'dispatch;
	}
	// 825EFBE4: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 825EFBE8: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 825EFBEC: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 825EFBF0: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 825EFBF4: 48000034  b 0x825efc28
	pc = 0x825EFC28; continue 'dispatch;
	// 825EFBF8: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 825EFBFC: 419A002C  beq cr6, 0x825efc28
	if ctx.cr[6].eq {
	pc = 0x825EFC28; continue 'dispatch;
	}
	// 825EFC00: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825EFC04: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EFC08: 388BE860  addi r4, r11, -0x17a0
	ctx.r[4].s64 = ctx.r[11].s64 + -6048;
	// 825EFC0C: 48BB84ED  bl 0x831a80f8
	ctx.lr = 0x825EFC10;
	sub_831A80F8(ctx, base);
	// 825EFC10: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825EFC14: 4182000C  beq 0x825efc20
	if ctx.cr[0].eq {
	pc = 0x825EFC20; continue 'dispatch;
	}
	// 825EFC18: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 825EFC1C: 4800000C  b 0x825efc28
	pc = 0x825EFC28; continue 'dispatch;
	// 825EFC20: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825EFC24: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825EFC28: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825EFC2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825EFC30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825EFC34: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825EFC38: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825EFC3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EFC40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825EFC40 size=248
    let mut pc: u32 = 0x825EFC40;
    'dispatch: loop {
        match pc {
            0x825EFC40 => {
    //   block [0x825EFC40..0x825EFD38)
	// 825EFC40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EFC44: 48BB8525  bl 0x831a8168
	ctx.lr = 0x825EFC48;
	sub_831A8130(ctx, base);
	// 825EFC48: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EFC4C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825EFC50: 4BF20AB9  bl 0x82510708
	ctx.lr = 0x825EFC54;
	sub_82510708(ctx, base);
	// 825EFC54: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EFC58: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825EFC5C: 4BF1F86D  bl 0x8250f4c8
	ctx.lr = 0x825EFC60;
	sub_8250F4C8(ctx, base);
	// 825EFC60: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EFC64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825EFC68: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 825EFC6C: 409A0008  bne cr6, 0x825efc74
	if !ctx.cr[6].eq {
	pc = 0x825EFC74; continue 'dispatch;
	}
	// 825EFC70: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825EFC74: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825EFC78: 4BF18D39  bl 0x825089b0
	ctx.lr = 0x825EFC7C;
	sub_825089B0(ctx, base);
	// 825EFC7C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EFC80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825EFC84: 3BCBFF34  addi r30, r11, -0xcc
	ctx.r[30].s64 = ctx.r[11].s64 + -204;
	// 825EFC88: 409A0008  bne cr6, 0x825efc90
	if !ctx.cr[6].eq {
	pc = 0x825EFC90; continue 'dispatch;
	}
	// 825EFC8C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825EFC90: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 825EFC94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825EFC98: 3BAB9FC0  addi r29, r11, -0x6040
	ctx.r[29].s64 = ctx.r[11].s64 + -24640;
	// 825EFC9C: 3B9F0150  addi r28, r31, 0x150
	ctx.r[28].s64 = ctx.r[31].s64 + 336;
	// 825EFCA0: 4BF21E49  bl 0x82511ae8
	ctx.lr = 0x825EFCA4;
	sub_82511AE8(ctx, base);
	// 825EFCA4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825EFCA8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EFCAC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 825EFCB0: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 825EFCB4: 4BCD7CED  bl 0x822c79a0
	ctx.lr = 0x825EFCB8;
	sub_822C79A0(ctx, base);
	// 825EFCB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825EFCBC: 48801FD5  bl 0x82df1c90
	ctx.lr = 0x825EFCC0;
	sub_82DF1C90(ctx, base);
	// 825EFCC0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825EFCC4: 48801FCD  bl 0x82df1c90
	ctx.lr = 0x825EFCC8;
	sub_82DF1C90(ctx, base);
	// 825EFCC8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825EFCCC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825EFCD0: 4BF1F7F9  bl 0x8250f4c8
	ctx.lr = 0x825EFCD4;
	sub_8250F4C8(ctx, base);
	// 825EFCD4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EFCD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825EFCDC: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 825EFCE0: 409A0008  bne cr6, 0x825efce8
	if !ctx.cr[6].eq {
	pc = 0x825EFCE8; continue 'dispatch;
	}
	// 825EFCE4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825EFCE8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825EFCEC: 4BF18CC5  bl 0x825089b0
	ctx.lr = 0x825EFCF0;
	sub_825089B0(ctx, base);
	// 825EFCF0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EFCF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825EFCF8: 386BFF34  addi r3, r11, -0xcc
	ctx.r[3].s64 = ctx.r[11].s64 + -204;
	// 825EFCFC: 409A0008  bne cr6, 0x825efd04
	if !ctx.cr[6].eq {
	pc = 0x825EFD04; continue 'dispatch;
	}
	// 825EFD00: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825EFD04: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825EFD08: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 825EFD0C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 825EFD10: 38EABA80  addi r7, r10, -0x4580
	ctx.r[7].s64 = ctx.r[10].s64 + -17792;
	// 825EFD14: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825EFD18: C02B9450  lfs f1, -0x6bb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825EFD1C: 4BCD7D4D  bl 0x822c7a68
	ctx.lr = 0x825EFD20;
	sub_822C7A68(ctx, base);
	// 825EFD20: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825EFD24: 48801F6D  bl 0x82df1c90
	ctx.lr = 0x825EFD28;
	sub_82DF1C90(ctx, base);
	// 825EFD28: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825EFD2C: 48801F65  bl 0x82df1c90
	ctx.lr = 0x825EFD30;
	sub_82DF1C90(ctx, base);
	// 825EFD30: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825EFD34: 48BB8484  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EFD38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825EFD38 size=192
    let mut pc: u32 = 0x825EFD38;
    'dispatch: loop {
        match pc {
            0x825EFD38 => {
    //   block [0x825EFD38..0x825EFDF8)
	// 825EFD38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EFD3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825EFD40: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825EFD44: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825EFD48: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EFD4C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825EFD50: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825EFD54: 480A4FE5  bl 0x82694d38
	ctx.lr = 0x825EFD58;
	sub_82694D38(ctx, base);
	// 825EFD58: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 825EFD5C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825EFD60: 808BE264  lwz r4, -0x1d9c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7580 as u32) ) } as u64;
	// 825EFD64: 48803CA5  bl 0x82df3a08
	ctx.lr = 0x825EFD68;
	sub_82DF3A08(ctx, base);
	// 825EFD68: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825EFD6C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825EFD70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EFD74: 4BF18A0D  bl 0x82508780
	ctx.lr = 0x825EFD78;
	sub_82508780(ctx, base);
	// 825EFD78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825EFD7C: 488036AD  bl 0x82df3428
	ctx.lr = 0x825EFD80;
	sub_82DF3428(ctx, base);
	// 825EFD80: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 825EFD84: 3BDF0150  addi r30, r31, 0x150
	ctx.r[30].s64 = ctx.r[31].s64 + 336;
	// 825EFD88: 388B6910  addi r4, r11, 0x6910
	ctx.r[4].s64 = ctx.r[11].s64 + 26896;
	// 825EFD8C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EFD90: 4BE363A1  bl 0x82426130
	ctx.lr = 0x825EFD94;
	sub_82426130(ctx, base);
	// 825EFD94: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825EFD98: 41820048  beq 0x825efde0
	if ctx.cr[0].eq {
	pc = 0x825EFDE0; continue 'dispatch;
	}
	// 825EFD9C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825EFDA0: C19F00F0  lfs f12, 0xf0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825EFDA4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825EFDA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825EFDAC: C1AB9450  lfs f13, -0x6bb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825EFDB0: C00A08A4  lfs f0, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825EFDB4: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 825EFDB8: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 825EFDBC: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 825EFDC0: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 825EFDC4: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 825EFDC8: 4BF21D21  bl 0x82511ae8
	ctx.lr = 0x825EFDCC;
	sub_82511AE8(ctx, base);
	// 825EFDCC: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 825EFDD0: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 825EFDD4: 13C058C7  vcmpequd (lvx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EFDF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825EFDF8 size=116
    let mut pc: u32 = 0x825EFDF8;
    'dispatch: loop {
        match pc {
            0x825EFDF8 => {
    //   block [0x825EFDF8..0x825EFE6C)
	// 825EFDF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EFDFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825EFE00: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825EFE04: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825EFE08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EFE0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825EFE10: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825EFE14: 897F0160  lbz r11, 0x160(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 825EFE18: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825EFE1C: 41820028  beq 0x825efe44
	if ctx.cr[0].eq {
	pc = 0x825EFE44; continue 'dispatch;
	}
	// 825EFE20: 4BF21CC9  bl 0x82511ae8
	ctx.lr = 0x825EFE24;
	sub_82511AE8(ctx, base);
	// 825EFE24: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 825EFE28: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 825EFE2C: 397F0150  addi r11, r31, 0x150
	ctx.r[11].s64 = ctx.r[31].s64 + 336;
	// 825EFE30: 13DE50C7  vcmpequd (lvx128) v30, v30, v10
	tmp.u32 = ctx.r[30].u32 + ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EFE70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825EFE70 size=160
    let mut pc: u32 = 0x825EFE70;
    'dispatch: loop {
        match pc {
            0x825EFE70 => {
    //   block [0x825EFE70..0x825EFF10)
	// 825EFE70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EFE74: 48BB82F9  bl 0x831a816c
	ctx.lr = 0x825EFE78;
	sub_831A8130(ctx, base);
	// 825EFE78: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EFE7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825EFE80: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825EFE84: 897F0160  lbz r11, 0x160(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 825EFE88: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825EFE8C: 4182006C  beq 0x825efef8
	if ctx.cr[0].eq {
	pc = 0x825EFEF8; continue 'dispatch;
	}
	// 825EFE90: 4BF21C59  bl 0x82511ae8
	ctx.lr = 0x825EFE94;
	sub_82511AE8(ctx, base);
	// 825EFE94: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825EFE98: 3BDF0150  addi r30, r31, 0x150
	ctx.r[30].s64 = ctx.r[31].s64 + 336;
	// 825EFE9C: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 825EFEA0: 389D0020  addi r4, r29, 0x20
	ctx.r[4].s64 = ctx.r[29].s64 + 32;
	// 825EFEA4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825EFEA8: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 825EFEAC: 13C0F0C7  vcmpequd (lvx128) v30, v0, v30
	tmp.u32 = ctx.r[30].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EFF10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825EFF10 size=196
    let mut pc: u32 = 0x825EFF10;
    'dispatch: loop {
        match pc {
            0x825EFF10 => {
    //   block [0x825EFF10..0x825EFFD4)
	// 825EFF10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EFF14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825EFF18: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825EFF1C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825EFF20: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EFF24: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825EFF28: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825EFF2C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825EFF30: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825EFF34: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825EFF38: 4BCD0A01  bl 0x822c0938
	ctx.lr = 0x825EFF3C;
	sub_822C0938(ctx, base);
	// 825EFF3C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825EFF40: 41820028  beq 0x825eff68
	if ctx.cr[0].eq {
	pc = 0x825EFF68; continue 'dispatch;
	}
	// 825EFF44: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825EFF48: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825EFF4C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825EFF50: 392B0480  addi r9, r11, 0x480
	ctx.r[9].s64 = ctx.r[11].s64 + 1152;
	// 825EFF54: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825EFF58: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825EFF5C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825EFF60: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825EFF64: 48000008  b 0x825eff6c
	pc = 0x825EFF6C; continue 'dispatch;
	// 825EFF68: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825EFF6C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825EFF70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825EFF74: 409A0044  bne cr6, 0x825effb8
	if !ctx.cr[6].eq {
	pc = 0x825EFFB8; continue 'dispatch;
	}
	// 825EFF78: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825EFF7C: 419A001C  beq cr6, 0x825eff98
	if ctx.cr[6].eq {
	pc = 0x825EFF98; continue 'dispatch;
	}
	// 825EFF80: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EFF84: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825EFF88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825EFF8C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825EFF90: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825EFF94: 4E800421  bctrl
	ctx.lr = 0x825EFF98;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825EFF98: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825EFF9C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825EFFA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825EFFA4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825EFFA8: 816BE70C  lwz r11, -0x18f4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6388 as u32) ) } as u64;
	// 825EFFAC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825EFFB0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825EFFB4: 4BCD004D  bl 0x822c0000
	ctx.lr = 0x825EFFB8;
	sub_822C0000(ctx, base);
	// 825EFFB8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825EFFBC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825EFFC0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825EFFC4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825EFFC8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825EFFCC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825EFFD0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825EFFD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825EFFD8 size=196
    let mut pc: u32 = 0x825EFFD8;
    'dispatch: loop {
        match pc {
            0x825EFFD8 => {
    //   block [0x825EFFD8..0x825F009C)
	// 825EFFD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825EFFDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825EFFE0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825EFFE4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825EFFE8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825EFFEC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825EFFF0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825EFFF4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825EFFF8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825EFFFC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F0000: 4BCD0939  bl 0x822c0938
	ctx.lr = 0x825F0004;
	sub_822C0938(ctx, base);
	// 825F0004: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F0008: 41820028  beq 0x825f0030
	if ctx.cr[0].eq {
	pc = 0x825F0030; continue 'dispatch;
	}
	// 825F000C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F0010: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825F0014: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825F0018: 392B0494  addi r9, r11, 0x494
	ctx.r[9].s64 = ctx.r[11].s64 + 1172;
	// 825F001C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825F0020: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825F0024: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825F0028: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825F002C: 48000008  b 0x825f0034
	pc = 0x825F0034; continue 'dispatch;
	// 825F0030: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F0034: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F0038: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F003C: 409A0044  bne cr6, 0x825f0080
	if !ctx.cr[6].eq {
	pc = 0x825F0080; continue 'dispatch;
	}
	// 825F0040: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825F0044: 419A001C  beq cr6, 0x825f0060
	if ctx.cr[6].eq {
	pc = 0x825F0060; continue 'dispatch;
	}
	// 825F0048: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F004C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825F0050: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F0054: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F0058: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825F005C: 4E800421  bctrl
	ctx.lr = 0x825F0060;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825F0060: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825F0064: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825F0068: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F006C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825F0070: 816BE70C  lwz r11, -0x18f4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6388 as u32) ) } as u64;
	// 825F0074: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825F0078: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825F007C: 4BCCFF85  bl 0x822c0000
	ctx.lr = 0x825F0080;
	sub_822C0000(ctx, base);
	// 825F0080: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F0084: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825F0088: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F008C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F0090: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825F0094: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F0098: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F00A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F00A0 size=196
    let mut pc: u32 = 0x825F00A0;
    'dispatch: loop {
        match pc {
            0x825F00A0 => {
    //   block [0x825F00A0..0x825F0164)
	// 825F00A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F00A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F00A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825F00AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F00B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F00B4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825F00B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F00BC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825F00C0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825F00C4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F00C8: 4BCD0871  bl 0x822c0938
	ctx.lr = 0x825F00CC;
	sub_822C0938(ctx, base);
	// 825F00CC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F00D0: 41820028  beq 0x825f00f8
	if ctx.cr[0].eq {
	pc = 0x825F00F8; continue 'dispatch;
	}
	// 825F00D4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F00D8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825F00DC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825F00E0: 392B04A8  addi r9, r11, 0x4a8
	ctx.r[9].s64 = ctx.r[11].s64 + 1192;
	// 825F00E4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825F00E8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825F00EC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825F00F0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825F00F4: 48000008  b 0x825f00fc
	pc = 0x825F00FC; continue 'dispatch;
	// 825F00F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F00FC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F0100: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F0104: 409A0044  bne cr6, 0x825f0148
	if !ctx.cr[6].eq {
	pc = 0x825F0148; continue 'dispatch;
	}
	// 825F0108: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825F010C: 419A001C  beq cr6, 0x825f0128
	if ctx.cr[6].eq {
	pc = 0x825F0128; continue 'dispatch;
	}
	// 825F0110: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F0114: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825F0118: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F011C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F0120: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825F0124: 4E800421  bctrl
	ctx.lr = 0x825F0128;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825F0128: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825F012C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825F0130: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F0134: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825F0138: 816BE70C  lwz r11, -0x18f4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6388 as u32) ) } as u64;
	// 825F013C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825F0140: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825F0144: 4BCCFEBD  bl 0x822c0000
	ctx.lr = 0x825F0148;
	sub_822C0000(ctx, base);
	// 825F0148: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F014C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825F0150: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F0154: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F0158: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825F015C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F0160: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F0168(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F0168 size=196
    let mut pc: u32 = 0x825F0168;
    'dispatch: loop {
        match pc {
            0x825F0168 => {
    //   block [0x825F0168..0x825F022C)
	// 825F0168: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F016C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F0170: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825F0174: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F0178: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F017C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825F0180: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F0184: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825F0188: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825F018C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F0190: 4BCD07A9  bl 0x822c0938
	ctx.lr = 0x825F0194;
	sub_822C0938(ctx, base);
	// 825F0194: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F0198: 41820028  beq 0x825f01c0
	if ctx.cr[0].eq {
	pc = 0x825F01C0; continue 'dispatch;
	}
	// 825F019C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F01A0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825F01A4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825F01A8: 392B04BC  addi r9, r11, 0x4bc
	ctx.r[9].s64 = ctx.r[11].s64 + 1212;
	// 825F01AC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825F01B0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825F01B4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825F01B8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825F01BC: 48000008  b 0x825f01c4
	pc = 0x825F01C4; continue 'dispatch;
	// 825F01C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F01C4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F01C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F01CC: 409A0044  bne cr6, 0x825f0210
	if !ctx.cr[6].eq {
	pc = 0x825F0210; continue 'dispatch;
	}
	// 825F01D0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825F01D4: 419A001C  beq cr6, 0x825f01f0
	if ctx.cr[6].eq {
	pc = 0x825F01F0; continue 'dispatch;
	}
	// 825F01D8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F01DC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825F01E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F01E4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F01E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825F01EC: 4E800421  bctrl
	ctx.lr = 0x825F01F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825F01F0: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825F01F4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825F01F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F01FC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825F0200: 816BE70C  lwz r11, -0x18f4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6388 as u32) ) } as u64;
	// 825F0204: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825F0208: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825F020C: 4BCCFDF5  bl 0x822c0000
	ctx.lr = 0x825F0210;
	sub_822C0000(ctx, base);
	// 825F0210: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F0214: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825F0218: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F021C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F0220: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825F0224: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F0228: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F0230(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F0230 size=72
    let mut pc: u32 = 0x825F0230;
    'dispatch: loop {
        match pc {
            0x825F0230 => {
    //   block [0x825F0230..0x825F0278)
	// 825F0230: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F0234: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F0238: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F023C: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 825F0240: 419A001C  beq cr6, 0x825f025c
	if ctx.cr[6].eq {
	pc = 0x825F025C; continue 'dispatch;
	}
	// 825F0244: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825F0248: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825F024C: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 825F0250: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825F0254: 4BFFF855  bl 0x825efaa8
	ctx.lr = 0x825F0258;
	sub_825EFAA8(ctx, base);
	// 825F0258: 48000010  b 0x825f0268
	pc = 0x825F0268; continue 'dispatch;
	// 825F025C: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825F0260: 396BE710  addi r11, r11, -0x18f0
	ctx.r[11].s64 = ctx.r[11].s64 + -6384;
	// 825F0264: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F0268: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825F026C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F0270: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F0274: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F0278(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F0278 size=72
    let mut pc: u32 = 0x825F0278;
    'dispatch: loop {
        match pc {
            0x825F0278 => {
    //   block [0x825F0278..0x825F02C0)
	// 825F0278: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F027C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F0280: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F0284: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 825F0288: 419A001C  beq cr6, 0x825f02a4
	if ctx.cr[6].eq {
	pc = 0x825F02A4; continue 'dispatch;
	}
	// 825F028C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825F0290: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825F0294: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 825F0298: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825F029C: 4BFFF895  bl 0x825efb30
	ctx.lr = 0x825F02A0;
	sub_825EFB30(ctx, base);
	// 825F02A0: 48000010  b 0x825f02b0
	pc = 0x825F02B0; continue 'dispatch;
	// 825F02A4: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825F02A8: 396BE7B8  addi r11, r11, -0x1848
	ctx.r[11].s64 = ctx.r[11].s64 + -6216;
	// 825F02AC: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F02B0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825F02B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F02B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F02BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F02C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F02C0 size=72
    let mut pc: u32 = 0x825F02C0;
    'dispatch: loop {
        match pc {
            0x825F02C0 => {
    //   block [0x825F02C0..0x825F0308)
	// 825F02C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F02C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F02C8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F02CC: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 825F02D0: 419A001C  beq cr6, 0x825f02ec
	if ctx.cr[6].eq {
	pc = 0x825F02EC; continue 'dispatch;
	}
	// 825F02D4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825F02D8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825F02DC: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 825F02E0: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825F02E4: 4BFFF8D5  bl 0x825efbb8
	ctx.lr = 0x825F02E8;
	sub_825EFBB8(ctx, base);
	// 825F02E8: 48000010  b 0x825f02f8
	pc = 0x825F02F8; continue 'dispatch;
	// 825F02EC: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825F02F0: 396BE860  addi r11, r11, -0x17a0
	ctx.r[11].s64 = ctx.r[11].s64 + -6048;
	// 825F02F4: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F02F8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825F02FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F0300: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F0304: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F0308(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F0308 size=164
    let mut pc: u32 = 0x825F0308;
    'dispatch: loop {
        match pc {
            0x825F0308 => {
    //   block [0x825F0308..0x825F03AC)
	// 825F0308: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F030C: 48BB7E5D  bl 0x831a8168
	ctx.lr = 0x825F0310;
	sub_831A8130(ctx, base);
	// 825F0310: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F0314: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825F0318: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825F031C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825F0320: 57BC063F  clrlwi. r28, r29, 0x18
	ctx.r[28].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 825F0324: 41820038  beq 0x825f035c
	if ctx.cr[0].eq {
	pc = 0x825F035C; continue 'dispatch;
	}
	// 825F0328: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F032C: 48BB965D  bl 0x831a9988
	ctx.lr = 0x825F0330;
	sub_831A9988(ctx, base);
	// 825F0330: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 825F0334: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825F0338: 386B5BA8  addi r3, r11, 0x5ba8
	ctx.r[3].s64 = ctx.r[11].s64 + 23464;
	// 825F033C: 48BB7DBD  bl 0x831a80f8
	ctx.lr = 0x825F0340;
	sub_831A80F8(ctx, base);
	// 825F0340: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825F0344: 41820018  beq 0x825f035c
	if ctx.cr[0].eq {
	pc = 0x825F035C; continue 'dispatch;
	}
	// 825F0348: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F034C: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 825F0350: 4BFFFAA9  bl 0x825efdf8
	ctx.lr = 0x825F0354;
	sub_825EFDF8(ctx, base);
	// 825F0354: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 825F0358: 4800004C  b 0x825f03a4
	pc = 0x825F03A4; continue 'dispatch;
	// 825F035C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 825F0360: 419A0034  beq cr6, 0x825f0394
	if ctx.cr[6].eq {
	pc = 0x825F0394; continue 'dispatch;
	}
	// 825F0364: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F0368: 48BB9621  bl 0x831a9988
	ctx.lr = 0x825F036C;
	sub_831A9988(ctx, base);
	// 825F036C: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 825F0370: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825F0374: 386BCB78  addi r3, r11, -0x3488
	ctx.r[3].s64 = ctx.r[11].s64 + -13448;
	// 825F0378: 48BB7D81  bl 0x831a80f8
	ctx.lr = 0x825F037C;
	sub_831A80F8(ctx, base);
	// 825F037C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825F0380: 41820014  beq 0x825f0394
	if ctx.cr[0].eq {
	pc = 0x825F0394; continue 'dispatch;
	}
	// 825F0384: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F0388: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 825F038C: 4BFFFAE5  bl 0x825efe70
	ctx.lr = 0x825F0390;
	sub_825EFE70(ctx, base);
	// 825F0390: 4BFFFFC4  b 0x825f0354
	pc = 0x825F0354; continue 'dispatch;
	// 825F0394: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825F0398: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F039C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F03A0: 480A47C1  bl 0x82694b60
	ctx.lr = 0x825F03A4;
	sub_82694B60(ctx, base);
	// 825F03A4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825F03A8: 48BB7E10  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F03B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F03B0 size=100
    let mut pc: u32 = 0x825F03B0;
    'dispatch: loop {
        match pc {
            0x825F03B0 => {
    //   block [0x825F03B0..0x825F0414)
	// 825F03B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F03B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F03B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F03BC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F03C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F03C4: 807F0128  lwz r3, 0x128(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(296 as u32) ) } as u64;
	// 825F03C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F03CC: 419A0008  beq cr6, 0x825f03d4
	if ctx.cr[6].eq {
	pc = 0x825F03D4; continue 'dispatch;
	}
	// 825F03D0: 4BCD04C1  bl 0x822c0890
	ctx.lr = 0x825F03D4;
	sub_822C0890(ctx, base);
	// 825F03D4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825F03D8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825F03DC: 387F0104  addi r3, r31, 0x104
	ctx.r[3].s64 = ctx.r[31].s64 + 260;
	// 825F03E0: 4BCD8A51  bl 0x822c8e30
	ctx.lr = 0x825F03E4;
	sub_822C8E30(ctx, base);
	// 825F03E4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825F03E8: 387F00E8  addi r3, r31, 0xe8
	ctx.r[3].s64 = ctx.r[31].s64 + 232;
	// 825F03EC: 409A0008  bne cr6, 0x825f03f4
	if !ctx.cr[6].eq {
	pc = 0x825F03F4; continue 'dispatch;
	}
	// 825F03F0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825F03F4: 481B7265  bl 0x827a7658
	ctx.lr = 0x825F03F8;
	sub_827A7658(ctx, base);
	// 825F03F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F03FC: 4BD5EF55  bl 0x8234f350
	ctx.lr = 0x825F0400;
	sub_8234F350(ctx, base);
	// 825F0400: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825F0404: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F0408: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F040C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F0410: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F0418(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825F0418 size=144
    let mut pc: u32 = 0x825F0418;
    'dispatch: loop {
        match pc {
            0x825F0418 => {
    //   block [0x825F0418..0x825F04A8)
	// 825F0418: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F041C: 48BB7D49  bl 0x831a8164
	ctx.lr = 0x825F0420;
	sub_831A8130(ctx, base);
	// 825F0420: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F0424: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825F0428: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825F042C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825F0430: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825F0434: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 825F0438: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F043C: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 825F0440: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 825F0444: 38600040  li r3, 0x40
	ctx.r[3].s64 = 64;
	// 825F0448: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 825F044C: 48801F9D  bl 0x82df23e8
	ctx.lr = 0x825F0450;
	sub_82DF23E8(ctx, base);
	// 825F0450: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F0454: 41820020  beq 0x825f0474
	if ctx.cr[0].eq {
	pc = 0x825F0474; continue 'dispatch;
	}
	// 825F0458: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F045C: 88FC0000  lbz r7, 0(r28)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F0460: 88DD0000  lbz r6, 0(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F0464: C03E0000  lfs f1, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825F0468: 48568671  bl 0x82b58ad8
	ctx.lr = 0x825F046C;
	sub_82B58AD8(ctx, base);
	// 825F046C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F0470: 48000008  b 0x825f0478
	pc = 0x825F0478; continue 'dispatch;
	// 825F0474: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825F0478: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825F047C: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 825F0480: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F0484: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F0488: 4BFFFCE1  bl 0x825f0168
	ctx.lr = 0x825F048C;
	sub_825F0168(ctx, base);
	// 825F048C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825F0490: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F0494: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F0498: 4BCCFB69  bl 0x822c0000
	ctx.lr = 0x825F049C;
	sub_822C0000(ctx, base);
	// 825F049C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825F04A0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825F04A4: 48BB7D10  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F04A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825F04A8 size=140
    let mut pc: u32 = 0x825F04A8;
    'dispatch: loop {
        match pc {
            0x825F04A8 => {
    //   block [0x825F04A8..0x825F0534)
	// 825F04A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F04AC: 48BB7CBD  bl 0x831a8168
	ctx.lr = 0x825F04B0;
	sub_831A8130(ctx, base);
	// 825F04B0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F04B4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825F04B8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825F04BC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825F04C0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825F04C4: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 825F04C8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F04CC: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 825F04D0: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 825F04D4: 38600040  li r3, 0x40
	ctx.r[3].s64 = 64;
	// 825F04D8: 48801F11  bl 0x82df23e8
	ctx.lr = 0x825F04DC;
	sub_82DF23E8(ctx, base);
	// 825F04DC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F04E0: 41820020  beq 0x825f0500
	if ctx.cr[0].eq {
	pc = 0x825F0500; continue 'dispatch;
	}
	// 825F04E4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825F04E8: 88DD0000  lbz r6, 0(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F04EC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F04F0: C03E0000  lfs f1, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825F04F4: 485685E5  bl 0x82b58ad8
	ctx.lr = 0x825F04F8;
	sub_82B58AD8(ctx, base);
	// 825F04F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F04FC: 48000008  b 0x825f0504
	pc = 0x825F0504; continue 'dispatch;
	// 825F0500: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825F0504: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825F0508: 3BDC0004  addi r30, r28, 4
	ctx.r[30].s64 = ctx.r[28].s64 + 4;
	// 825F050C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F0510: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F0514: 4BFFFC55  bl 0x825f0168
	ctx.lr = 0x825F0518;
	sub_825F0168(ctx, base);
	// 825F0518: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825F051C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F0520: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F0524: 4BCCFADD  bl 0x822c0000
	ctx.lr = 0x825F0528;
	sub_822C0000(ctx, base);
	// 825F0528: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825F052C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825F0530: 48BB7C88  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F0538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825F0538 size=688
    let mut pc: u32 = 0x825F0538;
    'dispatch: loop {
        match pc {
            0x825F0538 => {
    //   block [0x825F0538..0x825F07E8)
	// 825F0538: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F053C: 48BB7C2D  bl 0x831a8168
	ctx.lr = 0x825F0540;
	sub_831A8130(ctx, base);
	// 825F0540: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F0544: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F0548: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 825F054C: 897F0138  lbz r11, 0x138(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) } as u64;
	// 825F0550: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F0554: 4182028C  beq 0x825f07e0
	if ctx.cr[0].eq {
	pc = 0x825F07E0; continue 'dispatch;
	}
	// 825F0558: 817F012C  lwz r11, 0x12c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(300 as u32) ) } as u64;
	// 825F055C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 825F0560: 419801EC  blt cr6, 0x825f074c
	if ctx.cr[6].lt {
	pc = 0x825F074C; continue 'dispatch;
	}
	// 825F0564: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 825F0568: 419800FC  blt cr6, 0x825f0664
	if ctx.cr[6].lt {
	pc = 0x825F0664; continue 'dispatch;
	}
	// 825F056C: 409A0274  bne cr6, 0x825f07e0
	if !ctx.cr[6].eq {
	pc = 0x825F07E0; continue 'dispatch;
	}
	// 825F0570: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F0574: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F0578: 3BAB04D0  addi r29, r11, 0x4d0
	ctx.r[29].s64 = ctx.r[11].s64 + 1232;
	// 825F057C: 38A00116  li r5, 0x116
	ctx.r[5].s64 = 278;
	// 825F0580: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825F0584: 38600040  li r3, 0x40
	ctx.r[3].s64 = 64;
	// 825F0588: 48801E61  bl 0x82df23e8
	ctx.lr = 0x825F058C;
	sub_82DF23E8(ctx, base);
	// 825F058C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F0590: 41820018  beq 0x825f05a8
	if ctx.cr[0].eq {
	pc = 0x825F05A8; continue 'dispatch;
	}
	// 825F0594: 389F0150  addi r4, r31, 0x150
	ctx.r[4].s64 = ctx.r[31].s64 + 336;
	// 825F0598: 88BF0141  lbz r5, 0x141(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(321 as u32) ) } as u64;
	// 825F059C: 4856874D  bl 0x82b58ce8
	ctx.lr = 0x825F05A0;
	sub_82B58CE8(ctx, base);
	// 825F05A0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825F05A4: 48000008  b 0x825f05ac
	pc = 0x825F05AC; continue 'dispatch;
	// 825F05A8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825F05AC: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 825F05B0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825F05B4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F05B8: 4BFFFAE9  bl 0x825f00a0
	ctx.lr = 0x825F05BC;
	sub_825F00A0(ctx, base);
	// 825F05BC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825F05C0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825F05C4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F05C8: 4BCCFA39  bl 0x822c0000
	ctx.lr = 0x825F05CC;
	sub_822C0000(ctx, base);
	// 825F05CC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825F05D0: 895F0143  lbz r10, 0x143(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(323 as u32) ) } as u64;
	// 825F05D4: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825F05D8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825F05DC: 994B0019  stb r10, 0x19(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(25 as u32), ctx.r[10].u8 ) };
	// 825F05E0: C01F0144  lfs f0, 0x144(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(324 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825F05E4: D00B001C  stfs f0, 0x1c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 825F05E8: C01F0148  lfs f0, 0x148(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(328 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825F05EC: D00B0020  stfs f0, 0x20(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 825F05F0: 895F0130  lbz r10, 0x130(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(304 as u32) ) } as u64;
	// 825F05F4: 994B0028  stb r10, 0x28(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), ctx.r[10].u8 ) };
	// 825F05F8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825F05FC: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 825F0600: 419A0024  beq cr6, 0x825f0624
	if ctx.cr[6].eq {
	pc = 0x825F0624; continue 'dispatch;
	}
	// 825F0604: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 825F0608: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825F060C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F0610: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825F0614: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825F0618: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825F061C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F0620: 4082FFE8  bne 0x825f0608
	if !ctx.cr[0].eq {
	pc = 0x825F0608; continue 'dispatch;
	}
	// 825F0624: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825F0628: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825F062C: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 825F0630: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 825F0634: 38A0011B  li r5, 0x11b
	ctx.r[5].s64 = 283;
	// 825F0638: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 825F063C: C02B08A4  lfs f1, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825F0640: 48868401  bl 0x82e58a40
	ctx.lr = 0x825F0644;
	sub_82E58A40(ctx, base);
	// 825F0644: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825F0648: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F064C: 419A0008  beq cr6, 0x825f0654
	if ctx.cr[6].eq {
	pc = 0x825F0654; continue 'dispatch;
	}
	// 825F0650: 4BCD0241  bl 0x822c0890
	ctx.lr = 0x825F0654;
	sub_822C0890(ctx, base);
	// 825F0654: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825F0658: 419A0188  beq cr6, 0x825f07e0
	if ctx.cr[6].eq {
	pc = 0x825F07E0; continue 'dispatch;
	}
	// 825F065C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F0660: 4800017C  b 0x825f07dc
	pc = 0x825F07DC; continue 'dispatch;
	// 825F0664: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F0668: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F066C: 3BAB04D0  addi r29, r11, 0x4d0
	ctx.r[29].s64 = ctx.r[11].s64 + 1232;
	// 825F0670: 38A0010C  li r5, 0x10c
	ctx.r[5].s64 = 268;
	// 825F0674: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825F0678: 38600040  li r3, 0x40
	ctx.r[3].s64 = 64;
	// 825F067C: 48801D6D  bl 0x82df23e8
	ctx.lr = 0x825F0680;
	sub_82DF23E8(ctx, base);
	// 825F0680: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F0684: 41820014  beq 0x825f0698
	if ctx.cr[0].eq {
	pc = 0x825F0698; continue 'dispatch;
	}
	// 825F0688: 389F0150  addi r4, r31, 0x150
	ctx.r[4].s64 = ctx.r[31].s64 + 336;
	// 825F068C: 4856853D  bl 0x82b58bc8
	ctx.lr = 0x825F0690;
	sub_82B58BC8(ctx, base);
	// 825F0690: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825F0694: 48000008  b 0x825f069c
	pc = 0x825F069C; continue 'dispatch;
	// 825F0698: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825F069C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 825F06A0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825F06A4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F06A8: 4BFFF931  bl 0x825effd8
	ctx.lr = 0x825F06AC;
	sub_825EFFD8(ctx, base);
	// 825F06AC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825F06B0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825F06B4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F06B8: 4BCCF949  bl 0x822c0000
	ctx.lr = 0x825F06BC;
	sub_822C0000(ctx, base);
	// 825F06BC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825F06C0: 895F0142  lbz r10, 0x142(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(322 as u32) ) } as u64;
	// 825F06C4: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825F06C8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825F06CC: 994B0018  stb r10, 0x18(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[10].u8 ) };
	// 825F06D0: 895F0143  lbz r10, 0x143(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(323 as u32) ) } as u64;
	// 825F06D4: 994B0019  stb r10, 0x19(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(25 as u32), ctx.r[10].u8 ) };
	// 825F06D8: C01F0144  lfs f0, 0x144(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(324 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825F06DC: D00B001C  stfs f0, 0x1c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 825F06E0: C01F0148  lfs f0, 0x148(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(328 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825F06E4: D00B0024  stfs f0, 0x24(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 825F06E8: C01F014C  lfs f0, 0x14c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(332 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825F06EC: D00B0020  stfs f0, 0x20(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 825F06F0: 895F0130  lbz r10, 0x130(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(304 as u32) ) } as u64;
	// 825F06F4: 994B002C  stb r10, 0x2c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[10].u8 ) };
	// 825F06F8: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825F06FC: 93C10064  stw r30, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 825F0700: 419A0024  beq cr6, 0x825f0724
	if ctx.cr[6].eq {
	pc = 0x825F0724; continue 'dispatch;
	}
	// 825F0704: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 825F0708: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825F070C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F0710: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825F0714: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825F0718: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825F071C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F0720: 4082FFE8  bne 0x825f0708
	if !ctx.cr[0].eq {
	pc = 0x825F0708; continue 'dispatch;
	}
	// 825F0724: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825F0728: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825F072C: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 825F0730: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 825F0734: 38A00113  li r5, 0x113
	ctx.r[5].s64 = 275;
	// 825F0738: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 825F073C: C02B08A4  lfs f1, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825F0740: 48868301  bl 0x82e58a40
	ctx.lr = 0x825F0744;
	sub_82E58A40(ctx, base);
	// 825F0744: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825F0748: 4BFFFF00  b 0x825f0648
	pc = 0x825F0648; continue 'dispatch;
	// 825F074C: 38FF0140  addi r7, r31, 0x140
	ctx.r[7].s64 = ctx.r[31].s64 + 320;
	// 825F0750: 38DF0130  addi r6, r31, 0x130
	ctx.r[6].s64 = ctx.r[31].s64 + 304;
	// 825F0754: 38BF013C  addi r5, r31, 0x13c
	ctx.r[5].s64 = ctx.r[31].s64 + 316;
	// 825F0758: 389F0150  addi r4, r31, 0x150
	ctx.r[4].s64 = ctx.r[31].s64 + 336;
	// 825F075C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825F0760: 4BFFFCB9  bl 0x825f0418
	ctx.lr = 0x825F0764;
	sub_825F0418(ctx, base);
	// 825F0764: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F0768: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 825F076C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825F0770: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F0774: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 825F0778: 419A0024  beq cr6, 0x825f079c
	if ctx.cr[6].eq {
	pc = 0x825F079C; continue 'dispatch;
	}
	// 825F077C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825F0780: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825F0784: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F0788: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825F078C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825F0790: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825F0794: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F0798: 4082FFE8  bne 0x825f0780
	if !ctx.cr[0].eq {
	pc = 0x825F0780; continue 'dispatch;
	}
	// 825F079C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825F07A0: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825F07A4: 38E10068  addi r7, r1, 0x68
	ctx.r[7].s64 = ctx.r[1].s64 + 104;
	// 825F07A8: 388A04D0  addi r4, r10, 0x4d0
	ctx.r[4].s64 = ctx.r[10].s64 + 1232;
	// 825F07AC: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 825F07B0: 38A00108  li r5, 0x108
	ctx.r[5].s64 = 264;
	// 825F07B4: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825F07B8: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 825F07BC: 48868285  bl 0x82e58a40
	ctx.lr = 0x825F07C0;
	sub_82E58A40(ctx, base);
	// 825F07C0: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 825F07C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F07C8: 419A0008  beq cr6, 0x825f07d0
	if ctx.cr[6].eq {
	pc = 0x825F07D0; continue 'dispatch;
	}
	// 825F07CC: 4BCD00C5  bl 0x822c0890
	ctx.lr = 0x825F07D0;
	sub_822C0890(ctx, base);
	// 825F07D0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825F07D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F07D8: 419A0008  beq cr6, 0x825f07e0
	if ctx.cr[6].eq {
	pc = 0x825F07E0; continue 'dispatch;
	}
	// 825F07DC: 4BCD00B5  bl 0x822c0890
	ctx.lr = 0x825F07E0;
	sub_822C0890(ctx, base);
	// 825F07E0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825F07E4: 48BB79D4  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F07E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825F07E8 size=492
    let mut pc: u32 = 0x825F07E8;
    'dispatch: loop {
        match pc {
            0x825F07E8 => {
    //   block [0x825F07E8..0x825F09D4)
	// 825F07E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F07EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F07F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825F07F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F07F8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F07FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F0800: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825F0804: 897F0139  lbz r11, 0x139(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(313 as u32) ) } as u64;
	// 825F0808: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F080C: 418201B0  beq 0x825f09bc
	if ctx.cr[0].eq {
	pc = 0x825F09BC; continue 'dispatch;
	}
	// 825F0810: 817F012C  lwz r11, 0x12c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(300 as u32) ) } as u64;
	// 825F0814: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 825F0818: 4198011C  blt cr6, 0x825f0934
	if ctx.cr[6].lt {
	pc = 0x825F0934; continue 'dispatch;
	}
	// 825F081C: 419A0010  beq cr6, 0x825f082c
	if ctx.cr[6].eq {
	pc = 0x825F082C; continue 'dispatch;
	}
	// 825F0820: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 825F0824: 41980088  blt cr6, 0x825f08ac
	if ctx.cr[6].lt {
	pc = 0x825F08AC; continue 'dispatch;
	}
	// 825F0828: 409A0194  bne cr6, 0x825f09bc
	if !ctx.cr[6].eq {
	pc = 0x825F09BC; continue 'dispatch;
	}
	// 825F082C: 389F0130  addi r4, r31, 0x130
	ctx.r[4].s64 = ctx.r[31].s64 + 304;
	// 825F0830: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825F0834: 4BFA3D35  bl 0x82594568
	ctx.lr = 0x825F0838;
	sub_82594568(ctx, base);
	// 825F0838: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F083C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825F0840: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825F0844: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F0848: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825F084C: 419A0024  beq cr6, 0x825f0870
	if ctx.cr[6].eq {
	pc = 0x825F0870; continue 'dispatch;
	}
	// 825F0850: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825F0854: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825F0858: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F085C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825F0860: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825F0864: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825F0868: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F086C: 4082FFE8  bne 0x825f0854
	if !ctx.cr[0].eq {
	pc = 0x825F0854; continue 'dispatch;
	}
	// 825F0870: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825F0874: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825F0878: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 825F087C: 388A04D0  addi r4, r10, 0x4d0
	ctx.r[4].s64 = ctx.r[10].s64 + 1232;
	// 825F0880: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 825F0884: 38A00134  li r5, 0x134
	ctx.r[5].s64 = 308;
	// 825F0888: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825F088C: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 825F0890: 488681B1  bl 0x82e58a40
	ctx.lr = 0x825F0894;
	sub_82E58A40(ctx, base);
	// 825F0894: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825F0898: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F089C: 419A0008  beq cr6, 0x825f08a4
	if ctx.cr[6].eq {
	pc = 0x825F08A4; continue 'dispatch;
	}
	// 825F08A0: 4BCCFFF1  bl 0x822c0890
	ctx.lr = 0x825F08A4;
	sub_822C0890(ctx, base);
	// 825F08A4: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825F08A8: 48000108  b 0x825f09b0
	pc = 0x825F09B0; continue 'dispatch;
	// 825F08AC: 38DF0130  addi r6, r31, 0x130
	ctx.r[6].s64 = ctx.r[31].s64 + 304;
	// 825F08B0: 38BF013C  addi r5, r31, 0x13c
	ctx.r[5].s64 = ctx.r[31].s64 + 316;
	// 825F08B4: 389F0150  addi r4, r31, 0x150
	ctx.r[4].s64 = ctx.r[31].s64 + 336;
	// 825F08B8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825F08BC: 4BFFFBED  bl 0x825f04a8
	ctx.lr = 0x825F08C0;
	sub_825F04A8(ctx, base);
	// 825F08C0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F08C4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825F08C8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825F08CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F08D0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825F08D4: 419A0024  beq cr6, 0x825f08f8
	if ctx.cr[6].eq {
	pc = 0x825F08F8; continue 'dispatch;
	}
	// 825F08D8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825F08DC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825F08E0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F08E4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825F08E8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825F08EC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825F08F0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F08F4: 4082FFE8  bne 0x825f08dc
	if !ctx.cr[0].eq {
	pc = 0x825F08DC; continue 'dispatch;
	}
	// 825F08F8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825F08FC: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825F0900: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 825F0904: 388A04D0  addi r4, r10, 0x4d0
	ctx.r[4].s64 = ctx.r[10].s64 + 1232;
	// 825F0908: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 825F090C: 38A00137  li r5, 0x137
	ctx.r[5].s64 = 311;
	// 825F0910: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825F0914: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 825F0918: 48868129  bl 0x82e58a40
	ctx.lr = 0x825F091C;
	sub_82E58A40(ctx, base);
	// 825F091C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825F0920: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F0924: 419A0008  beq cr6, 0x825f092c
	if ctx.cr[6].eq {
	pc = 0x825F092C; continue 'dispatch;
	}
	// 825F0928: 4BCCFF69  bl 0x822c0890
	ctx.lr = 0x825F092C;
	sub_822C0890(ctx, base);
	// 825F092C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 825F0930: 48000080  b 0x825f09b0
	pc = 0x825F09B0; continue 'dispatch;
	// 825F0934: 389F0130  addi r4, r31, 0x130
	ctx.r[4].s64 = ctx.r[31].s64 + 304;
	// 825F0938: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825F093C: 4BFA3C2D  bl 0x82594568
	ctx.lr = 0x825F0940;
	sub_82594568(ctx, base);
	// 825F0940: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F0944: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825F0948: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825F094C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F0950: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 825F0954: 419A0024  beq cr6, 0x825f0978
	if ctx.cr[6].eq {
	pc = 0x825F0978; continue 'dispatch;
	}
	// 825F0958: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825F095C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825F0960: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F0964: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825F0968: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825F096C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825F0970: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F0974: 4082FFE8  bne 0x825f095c
	if !ctx.cr[0].eq {
	pc = 0x825F095C; continue 'dispatch;
	}
	// 825F0978: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825F097C: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825F0980: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 825F0984: 388A04D0  addi r4, r10, 0x4d0
	ctx.r[4].s64 = ctx.r[10].s64 + 1232;
	// 825F0988: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 825F098C: 38A00130  li r5, 0x130
	ctx.r[5].s64 = 304;
	// 825F0990: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825F0994: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 825F0998: 488680A9  bl 0x82e58a40
	ctx.lr = 0x825F099C;
	sub_82E58A40(ctx, base);
	// 825F099C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825F09A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F09A4: 419A0008  beq cr6, 0x825f09ac
	if ctx.cr[6].eq {
	pc = 0x825F09AC; continue 'dispatch;
	}
	// 825F09A8: 4BCCFEE9  bl 0x822c0890
	ctx.lr = 0x825F09AC;
	sub_822C0890(ctx, base);
	// 825F09AC: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 825F09B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F09B4: 419A0008  beq cr6, 0x825f09bc
	if ctx.cr[6].eq {
	pc = 0x825F09BC; continue 'dispatch;
	}
	// 825F09B8: 4BCCFED9  bl 0x822c0890
	ctx.lr = 0x825F09BC;
	sub_822C0890(ctx, base);
	// 825F09BC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825F09C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F09C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F09C8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825F09CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F09D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F09D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825F09D8 size=376
    let mut pc: u32 = 0x825F09D8;
    'dispatch: loop {
        match pc {
            0x825F09D8 => {
    //   block [0x825F09D8..0x825F0B50)
	// 825F09D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F09DC: 48BB778D  bl 0x831a8168
	ctx.lr = 0x825F09E0;
	sub_831A8130(ctx, base);
	// 825F09E0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F09E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F09E8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825F09EC: 480A38D5  bl 0x826942c0
	ctx.lr = 0x825F09F0;
	sub_826942C0(ctx, base);
	// 825F09F0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825F09F4: 93DF012C  stw r30, 0x12c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(300 as u32), ctx.r[30].u32 ) };
	// 825F09F8: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 825F09FC: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 825F0A00: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 825F0A04: 3CE08204  lis r7, -0x7dfc
	ctx.r[7].s64 = -2113667072;
	// 825F0A08: C00A08A8  lfs f0, 0x8a8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825F0A0C: 394905C4  addi r10, r9, 0x5c4
	ctx.r[10].s64 = ctx.r[9].s64 + 1476;
	// 825F0A10: 38CB6910  addi r6, r11, 0x6910
	ctx.r[6].s64 = ctx.r[11].s64 + 26896;
	// 825F0A14: D01F013C  stfs f0, 0x13c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(316 as u32), tmp.u32 ) };
	// 825F0A18: 392805B0  addi r9, r8, 0x5b0
	ctx.r[9].s64 = ctx.r[8].s64 + 1456;
	// 825F0A1C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825F0A20: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825F0A24: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825F0A28: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 825F0A2C: 39070564  addi r8, r7, 0x564
	ctx.r[8].s64 = ctx.r[7].s64 + 1380;
	// 825F0A30: 997F0130  stb r11, 0x130(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), ctx.r[11].u8 ) };
	// 825F0A34: 9BDF0131  stb r30, 0x131(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(305 as u32), ctx.r[30].u8 ) };
	// 825F0A38: 39400150  li r10, 0x150
	ctx.r[10].s64 = 336;
	// 825F0A3C: 911F00E8  stw r8, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[8].u32 ) };
	// 825F0A40: 93DF0134  stw r30, 0x134(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(308 as u32), ctx.r[30].u32 ) };
	// 825F0A44: 997F0138  stb r11, 0x138(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(312 as u32), ctx.r[11].u8 ) };
	// 825F0A48: 997F0139  stb r11, 0x139(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(313 as u32), ctx.r[11].u8 ) };
	// 825F0A4C: 997F0140  stb r11, 0x140(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(320 as u32), ctx.r[11].u8 ) };
	// 825F0A50: 9BDF0141  stb r30, 0x141(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(321 as u32), ctx.r[30].u8 ) };
	// 825F0A54: 13E030C7  vcmpequd (lvx128) v31, v0, v6
	tmp.u32 = ctx.r[6].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F0B50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825F0B50 size=12
    let mut pc: u32 = 0x825F0B50;
    'dispatch: loop {
        match pc {
            0x825F0B50 => {
    //   block [0x825F0B50..0x825F0B5C)
	// 825F0B50: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825F0B54: 9963003B  stb r11, 0x3b(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(59 as u32), ctx.r[11].u8 ) };
	// 825F0B58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F0B60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825F0B60 size=12
    let mut pc: u32 = 0x825F0B60;
    'dispatch: loop {
        match pc {
            0x825F0B60 => {
    //   block [0x825F0B60..0x825F0B6C)
	// 825F0B60: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825F0B64: 99630078  stb r11, 0x78(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(120 as u32), ctx.r[11].u8 ) };
	// 825F0B68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F0B70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F0B70 size=128
    let mut pc: u32 = 0x825F0B70;
    'dispatch: loop {
        match pc {
            0x825F0B70 => {
    //   block [0x825F0B70..0x825F0BF0)
	// 825F0B70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F0B74: 48BB75F9  bl 0x831a816c
	ctx.lr = 0x825F0B78;
	sub_831A8130(ctx, base);
	// 825F0B78: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F0B7C: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 825F0B80: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825F0B84: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825F0B88: 3BEB7EC4  addi r31, r11, 0x7ec4
	ctx.r[31].s64 = ctx.r[11].s64 + 32452;
	// 825F0B8C: 816A7ECC  lwz r11, 0x7ecc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32460 as u32) ) } as u64;
	// 825F0B90: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825F0B94: 40820024  bne 0x825f0bb8
	if !ctx.cr[0].eq {
	pc = 0x825F0BB8; continue 'dispatch;
	}
	// 825F0B98: 3D208290  lis r9, -0x7d70
	ctx.r[9].s64 = -2104492032;
	// 825F0B9C: 3D00825F  lis r8, -0x7da1
	ctx.r[8].s64 = -2107703296;
	// 825F0BA0: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 825F0BA4: 3929DD90  addi r9, r9, -0x2270
	ctx.r[9].s64 = ctx.r[9].s64 + -8816;
	// 825F0BA8: 39080230  addi r8, r8, 0x230
	ctx.r[8].s64 = ctx.r[8].s64 + 560;
	// 825F0BAC: 916A7ECC  stw r11, 0x7ecc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(32460 as u32), ctx.r[11].u32 ) };
	// 825F0BB0: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825F0BB4: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825F0BB8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825F0BBC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825F0BC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F0BC4: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 825F0BC8: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 825F0BCC: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825F0BD0: 480639F1  bl 0x826545c0
	ctx.lr = 0x825F0BD4;
	sub_826545C0(ctx, base);
	// 825F0BD4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825F0BD8: 4182000C  beq 0x825f0be4
	if ctx.cr[0].eq {
	pc = 0x825F0BE4; continue 'dispatch;
	}
	// 825F0BDC: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825F0BE0: 48000008  b 0x825f0be8
	pc = 0x825F0BE8; continue 'dispatch;
	// 825F0BE4: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 825F0BE8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825F0BEC: 48BB75D0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F0BF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F0BF0 size=128
    let mut pc: u32 = 0x825F0BF0;
    'dispatch: loop {
        match pc {
            0x825F0BF0 => {
    //   block [0x825F0BF0..0x825F0C70)
	// 825F0BF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F0BF4: 48BB7579  bl 0x831a816c
	ctx.lr = 0x825F0BF8;
	sub_831A8130(ctx, base);
	// 825F0BF8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F0BFC: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 825F0C00: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825F0C04: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825F0C08: 3BEB7ED0  addi r31, r11, 0x7ed0
	ctx.r[31].s64 = ctx.r[11].s64 + 32464;
	// 825F0C0C: 816A7ED8  lwz r11, 0x7ed8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32472 as u32) ) } as u64;
	// 825F0C10: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825F0C14: 40820024  bne 0x825f0c38
	if !ctx.cr[0].eq {
	pc = 0x825F0C38; continue 'dispatch;
	}
	// 825F0C18: 3D208290  lis r9, -0x7d70
	ctx.r[9].s64 = -2104492032;
	// 825F0C1C: 3D00825F  lis r8, -0x7da1
	ctx.r[8].s64 = -2107703296;
	// 825F0C20: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 825F0C24: 3929DD90  addi r9, r9, -0x2270
	ctx.r[9].s64 = ctx.r[9].s64 + -8816;
	// 825F0C28: 39080278  addi r8, r8, 0x278
	ctx.r[8].s64 = ctx.r[8].s64 + 632;
	// 825F0C2C: 916A7ED8  stw r11, 0x7ed8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(32472 as u32), ctx.r[11].u32 ) };
	// 825F0C30: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825F0C34: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825F0C38: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825F0C3C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825F0C40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F0C44: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 825F0C48: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 825F0C4C: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825F0C50: 48063971  bl 0x826545c0
	ctx.lr = 0x825F0C54;
	sub_826545C0(ctx, base);
	// 825F0C54: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825F0C58: 4182000C  beq 0x825f0c64
	if ctx.cr[0].eq {
	pc = 0x825F0C64; continue 'dispatch;
	}
	// 825F0C5C: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825F0C60: 48000008  b 0x825f0c68
	pc = 0x825F0C68; continue 'dispatch;
	// 825F0C64: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 825F0C68: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825F0C6C: 48BB7550  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F0C70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F0C70 size=128
    let mut pc: u32 = 0x825F0C70;
    'dispatch: loop {
        match pc {
            0x825F0C70 => {
    //   block [0x825F0C70..0x825F0CF0)
	// 825F0C70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F0C74: 48BB74F9  bl 0x831a816c
	ctx.lr = 0x825F0C78;
	sub_831A8130(ctx, base);
	// 825F0C78: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F0C7C: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 825F0C80: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825F0C84: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825F0C88: 3BEB7EDC  addi r31, r11, 0x7edc
	ctx.r[31].s64 = ctx.r[11].s64 + 32476;
	// 825F0C8C: 816A7EE4  lwz r11, 0x7ee4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32484 as u32) ) } as u64;
	// 825F0C90: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825F0C94: 40820024  bne 0x825f0cb8
	if !ctx.cr[0].eq {
	pc = 0x825F0CB8; continue 'dispatch;
	}
	// 825F0C98: 3D208290  lis r9, -0x7d70
	ctx.r[9].s64 = -2104492032;
	// 825F0C9C: 3D00825F  lis r8, -0x7da1
	ctx.r[8].s64 = -2107703296;
	// 825F0CA0: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 825F0CA4: 3929DD90  addi r9, r9, -0x2270
	ctx.r[9].s64 = ctx.r[9].s64 + -8816;
	// 825F0CA8: 390802C0  addi r8, r8, 0x2c0
	ctx.r[8].s64 = ctx.r[8].s64 + 704;
	// 825F0CAC: 916A7EE4  stw r11, 0x7ee4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(32484 as u32), ctx.r[11].u32 ) };
	// 825F0CB0: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825F0CB4: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825F0CB8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825F0CBC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825F0CC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F0CC4: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 825F0CC8: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 825F0CCC: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825F0CD0: 480638F1  bl 0x826545c0
	ctx.lr = 0x825F0CD4;
	sub_826545C0(ctx, base);
	// 825F0CD4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825F0CD8: 4182000C  beq 0x825f0ce4
	if ctx.cr[0].eq {
	pc = 0x825F0CE4; continue 'dispatch;
	}
	// 825F0CDC: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825F0CE0: 48000008  b 0x825f0ce8
	pc = 0x825F0CE8; continue 'dispatch;
	// 825F0CE4: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 825F0CE8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825F0CEC: 48BB74D0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F0CF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825F0CF0 size=428
    let mut pc: u32 = 0x825F0CF0;
    'dispatch: loop {
        match pc {
            0x825F0CF0 => {
    //   block [0x825F0CF0..0x825F0E9C)
	// 825F0CF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F0CF4: 48BB7471  bl 0x831a8164
	ctx.lr = 0x825F0CF8;
	sub_831A8130(ctx, base);
	// 825F0CF8: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F0CFC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F0D00: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825F0D04: 3BCB04D0  addi r30, r11, 0x4d0
	ctx.r[30].s64 = ctx.r[11].s64 + 1232;
	// 825F0D08: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825F0D0C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F0D10: 38A00044  li r5, 0x44
	ctx.r[5].s64 = 68;
	// 825F0D14: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 825F0D18: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825F0D1C: 38600170  li r3, 0x170
	ctx.r[3].s64 = 368;
	// 825F0D20: 488016C9  bl 0x82df23e8
	ctx.lr = 0x825F0D24;
	sub_82DF23E8(ctx, base);
	// 825F0D24: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F0D28: 41820014  beq 0x825f0d3c
	if ctx.cr[0].eq {
	pc = 0x825F0D3C; continue 'dispatch;
	}
	// 825F0D2C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825F0D30: 4BFFFCA9  bl 0x825f09d8
	ctx.lr = 0x825F0D34;
	sub_825F09D8(ctx, base);
	// 825F0D34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F0D38: 48000008  b 0x825f0d40
	pc = 0x825F0D40; continue 'dispatch;
	// 825F0D3C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825F0D40: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825F0D44: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F0D48: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F0D4C: 4BFFF1C5  bl 0x825eff10
	ctx.lr = 0x825F0D50;
	sub_825EFF10(ctx, base);
	// 825F0D50: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825F0D54: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F0D58: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F0D5C: 4BCCF2A5  bl 0x822c0000
	ctx.lr = 0x825F0D60;
	sub_822C0000(ctx, base);
	// 825F0D60: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825F0D64: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F0D68: 38A00045  li r5, 0x45
	ctx.r[5].s64 = 69;
	// 825F0D6C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825F0D70: 4BCCF669  bl 0x822c03d8
	ctx.lr = 0x825F0D74;
	sub_822C03D8(ctx, base);
	// 825F0D74: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825F0D78: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825F0D7C: 418200B4  beq 0x825f0e30
	if ctx.cr[0].eq {
	pc = 0x825F0E30; continue 'dispatch;
	}
	// 825F0D80: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825F0D84: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 825F0D88: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825F0D8C: 396A00E8  addi r11, r10, 0xe8
	ctx.r[11].s64 = ctx.r[10].s64 + 232;
	// 825F0D90: 409A0008  bne cr6, 0x825f0d98
	if !ctx.cr[6].eq {
	pc = 0x825F0D98; continue 'dispatch;
	}
	// 825F0D94: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F0D98: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825F0D9C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825F0DA0: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 825F0DA4: 419A0024  beq cr6, 0x825f0dc8
	if ctx.cr[6].eq {
	pc = 0x825F0DC8; continue 'dispatch;
	}
	// 825F0DA8: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825F0DAC: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 825F0DB0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F0DB4: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 825F0DB8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 825F0DBC: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825F0DC0: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F0DC4: 4082FFE8  bne 0x825f0dac
	if !ctx.cr[0].eq {
	pc = 0x825F0DAC; continue 'dispatch;
	}
	// 825F0DC8: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 825F0DCC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825F0DD0: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 825F0DD4: 419A0024  beq cr6, 0x825f0df8
	if ctx.cr[6].eq {
	pc = 0x825F0DF8; continue 'dispatch;
	}
	// 825F0DD8: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825F0DDC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825F0DE0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F0DE4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825F0DE8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825F0DEC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825F0DF0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F0DF4: 4082FFE8  bne 0x825f0ddc
	if !ctx.cr[0].eq {
	pc = 0x825F0DDC; continue 'dispatch;
	}
	// 825F0DF8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825F0DFC: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 825F0E00: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825F0E04: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 825F0E08: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825F0E0C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825F0E10: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825F0E14: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825F0E18: 481A8119  bl 0x82798f30
	ctx.lr = 0x825F0E1C;
	sub_82798F30(ctx, base);
	// 825F0E1C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825F0E20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F0E24: 481AA845  bl 0x8279b668
	ctx.lr = 0x825F0E28;
	sub_8279B668(ctx, base);
	// 825F0E28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F0E2C: 48000008  b 0x825f0e34
	pc = 0x825F0E34; continue 'dispatch;
	// 825F0E30: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825F0E34: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825F0E38: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 825F0E3C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F0E40: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F0E44: 4BFA6E0D  bl 0x82597c50
	ctx.lr = 0x825F0E48;
	sub_82597C50(ctx, base);
	// 825F0E48: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825F0E4C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F0E50: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F0E54: 4BCCF1AD  bl 0x822c0000
	ctx.lr = 0x825F0E58;
	sub_822C0000(ctx, base);
	// 825F0E58: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825F0E5C: 41820024  beq 0x825f0e80
	if ctx.cr[0].eq {
	pc = 0x825F0E80; continue 'dispatch;
	}
	// 825F0E60: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 825F0E64: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F0E68: 419A0008  beq cr6, 0x825f0e70
	if ctx.cr[6].eq {
	pc = 0x825F0E70; continue 'dispatch;
	}
	// 825F0E6C: 4BCCFA25  bl 0x822c0890
	ctx.lr = 0x825F0E70;
	sub_822C0890(ctx, base);
	// 825F0E70: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825F0E74: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F0E78: 419A0008  beq cr6, 0x825f0e80
	if ctx.cr[6].eq {
	pc = 0x825F0E80; continue 'dispatch;
	}
	// 825F0E7C: 4BCCFA15  bl 0x822c0890
	ctx.lr = 0x825F0E80;
	sub_822C0890(ctx, base);
	// 825F0E80: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825F0E84: 419A000C  beq cr6, 0x825f0e90
	if ctx.cr[6].eq {
	pc = 0x825F0E90; continue 'dispatch;
	}
	// 825F0E88: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825F0E8C: 4BCCFA05  bl 0x822c0890
	ctx.lr = 0x825F0E90;
	sub_822C0890(ctx, base);
	// 825F0E90: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825F0E94: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 825F0E98: 48BB731C  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F0EA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825F0EA0 size=428
    let mut pc: u32 = 0x825F0EA0;
    'dispatch: loop {
        match pc {
            0x825F0EA0 => {
    //   block [0x825F0EA0..0x825F104C)
	// 825F0EA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F0EA4: 48BB72C1  bl 0x831a8164
	ctx.lr = 0x825F0EA8;
	sub_831A8130(ctx, base);
	// 825F0EA8: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F0EAC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F0EB0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825F0EB4: 3BCB04D0  addi r30, r11, 0x4d0
	ctx.r[30].s64 = ctx.r[11].s64 + 1232;
	// 825F0EB8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825F0EBC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F0EC0: 38A00051  li r5, 0x51
	ctx.r[5].s64 = 81;
	// 825F0EC4: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 825F0EC8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825F0ECC: 38600170  li r3, 0x170
	ctx.r[3].s64 = 368;
	// 825F0ED0: 48801519  bl 0x82df23e8
	ctx.lr = 0x825F0ED4;
	sub_82DF23E8(ctx, base);
	// 825F0ED4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F0ED8: 41820014  beq 0x825f0eec
	if ctx.cr[0].eq {
	pc = 0x825F0EEC; continue 'dispatch;
	}
	// 825F0EDC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825F0EE0: 4BFFFAF9  bl 0x825f09d8
	ctx.lr = 0x825F0EE4;
	sub_825F09D8(ctx, base);
	// 825F0EE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F0EE8: 48000008  b 0x825f0ef0
	pc = 0x825F0EF0; continue 'dispatch;
	// 825F0EEC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825F0EF0: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825F0EF4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F0EF8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F0EFC: 4BFFF015  bl 0x825eff10
	ctx.lr = 0x825F0F00;
	sub_825EFF10(ctx, base);
	// 825F0F00: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825F0F04: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F0F08: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F0F0C: 4BCCF0F5  bl 0x822c0000
	ctx.lr = 0x825F0F10;
	sub_822C0000(ctx, base);
	// 825F0F10: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825F0F14: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F0F18: 38A00052  li r5, 0x52
	ctx.r[5].s64 = 82;
	// 825F0F1C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825F0F20: 4BCCF4B9  bl 0x822c03d8
	ctx.lr = 0x825F0F24;
	sub_822C03D8(ctx, base);
	// 825F0F24: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825F0F28: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825F0F2C: 418200B4  beq 0x825f0fe0
	if ctx.cr[0].eq {
	pc = 0x825F0FE0; continue 'dispatch;
	}
	// 825F0F30: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825F0F34: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 825F0F38: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825F0F3C: 396A00E8  addi r11, r10, 0xe8
	ctx.r[11].s64 = ctx.r[10].s64 + 232;
	// 825F0F40: 409A0008  bne cr6, 0x825f0f48
	if !ctx.cr[6].eq {
	pc = 0x825F0F48; continue 'dispatch;
	}
	// 825F0F44: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F0F48: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825F0F4C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825F0F50: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 825F0F54: 419A0024  beq cr6, 0x825f0f78
	if ctx.cr[6].eq {
	pc = 0x825F0F78; continue 'dispatch;
	}
	// 825F0F58: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825F0F5C: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 825F0F60: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F0F64: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 825F0F68: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 825F0F6C: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825F0F70: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F0F74: 4082FFE8  bne 0x825f0f5c
	if !ctx.cr[0].eq {
	pc = 0x825F0F5C; continue 'dispatch;
	}
	// 825F0F78: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 825F0F7C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825F0F80: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 825F0F84: 419A0024  beq cr6, 0x825f0fa8
	if ctx.cr[6].eq {
	pc = 0x825F0FA8; continue 'dispatch;
	}
	// 825F0F88: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825F0F8C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825F0F90: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F0F94: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825F0F98: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825F0F9C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825F0FA0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F0FA4: 4082FFE8  bne 0x825f0f8c
	if !ctx.cr[0].eq {
	pc = 0x825F0F8C; continue 'dispatch;
	}
	// 825F0FA8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825F0FAC: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 825F0FB0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825F0FB4: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 825F0FB8: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825F0FBC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825F0FC0: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825F0FC4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825F0FC8: 481A7F69  bl 0x82798f30
	ctx.lr = 0x825F0FCC;
	sub_82798F30(ctx, base);
	// 825F0FCC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825F0FD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F0FD4: 481AA695  bl 0x8279b668
	ctx.lr = 0x825F0FD8;
	sub_8279B668(ctx, base);
	// 825F0FD8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F0FDC: 48000008  b 0x825f0fe4
	pc = 0x825F0FE4; continue 'dispatch;
	// 825F0FE0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825F0FE4: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825F0FE8: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 825F0FEC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F0FF0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F0FF4: 4BFA6C5D  bl 0x82597c50
	ctx.lr = 0x825F0FF8;
	sub_82597C50(ctx, base);
	// 825F0FF8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825F0FFC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F1000: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F1004: 4BCCEFFD  bl 0x822c0000
	ctx.lr = 0x825F1008;
	sub_822C0000(ctx, base);
	// 825F1008: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825F100C: 41820024  beq 0x825f1030
	if ctx.cr[0].eq {
	pc = 0x825F1030; continue 'dispatch;
	}
	// 825F1010: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 825F1014: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F1018: 419A0008  beq cr6, 0x825f1020
	if ctx.cr[6].eq {
	pc = 0x825F1020; continue 'dispatch;
	}
	// 825F101C: 4BCCF875  bl 0x822c0890
	ctx.lr = 0x825F1020;
	sub_822C0890(ctx, base);
	// 825F1020: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825F1024: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F1028: 419A0008  beq cr6, 0x825f1030
	if ctx.cr[6].eq {
	pc = 0x825F1030; continue 'dispatch;
	}
	// 825F102C: 4BCCF865  bl 0x822c0890
	ctx.lr = 0x825F1030;
	sub_822C0890(ctx, base);
	// 825F1030: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825F1034: 419A000C  beq cr6, 0x825f1040
	if ctx.cr[6].eq {
	pc = 0x825F1040; continue 'dispatch;
	}
	// 825F1038: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825F103C: 4BCCF855  bl 0x822c0890
	ctx.lr = 0x825F1040;
	sub_822C0890(ctx, base);
	// 825F1040: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825F1044: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 825F1048: 48BB716C  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F1050(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825F1050 size=428
    let mut pc: u32 = 0x825F1050;
    'dispatch: loop {
        match pc {
            0x825F1050 => {
    //   block [0x825F1050..0x825F11FC)
	// 825F1050: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F1054: 48BB7111  bl 0x831a8164
	ctx.lr = 0x825F1058;
	sub_831A8130(ctx, base);
	// 825F1058: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F105C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F1060: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825F1064: 3BCB04D0  addi r30, r11, 0x4d0
	ctx.r[30].s64 = ctx.r[11].s64 + 1232;
	// 825F1068: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825F106C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F1070: 38A0005E  li r5, 0x5e
	ctx.r[5].s64 = 94;
	// 825F1074: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 825F1078: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825F107C: 38600170  li r3, 0x170
	ctx.r[3].s64 = 368;
	// 825F1080: 48801369  bl 0x82df23e8
	ctx.lr = 0x825F1084;
	sub_82DF23E8(ctx, base);
	// 825F1084: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F1088: 41820014  beq 0x825f109c
	if ctx.cr[0].eq {
	pc = 0x825F109C; continue 'dispatch;
	}
	// 825F108C: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 825F1090: 4BFFF949  bl 0x825f09d8
	ctx.lr = 0x825F1094;
	sub_825F09D8(ctx, base);
	// 825F1094: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F1098: 48000008  b 0x825f10a0
	pc = 0x825F10A0; continue 'dispatch;
	// 825F109C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825F10A0: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825F10A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F10A8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F10AC: 4BFFEE65  bl 0x825eff10
	ctx.lr = 0x825F10B0;
	sub_825EFF10(ctx, base);
	// 825F10B0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825F10B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F10B8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F10BC: 4BCCEF45  bl 0x822c0000
	ctx.lr = 0x825F10C0;
	sub_822C0000(ctx, base);
	// 825F10C0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825F10C4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F10C8: 38A0005F  li r5, 0x5f
	ctx.r[5].s64 = 95;
	// 825F10CC: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825F10D0: 4BCCF309  bl 0x822c03d8
	ctx.lr = 0x825F10D4;
	sub_822C03D8(ctx, base);
	// 825F10D4: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825F10D8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825F10DC: 418200B4  beq 0x825f1190
	if ctx.cr[0].eq {
	pc = 0x825F1190; continue 'dispatch;
	}
	// 825F10E0: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825F10E4: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 825F10E8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825F10EC: 396A00E8  addi r11, r10, 0xe8
	ctx.r[11].s64 = ctx.r[10].s64 + 232;
	// 825F10F0: 409A0008  bne cr6, 0x825f10f8
	if !ctx.cr[6].eq {
	pc = 0x825F10F8; continue 'dispatch;
	}
	// 825F10F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F10F8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825F10FC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825F1100: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 825F1104: 419A0024  beq cr6, 0x825f1128
	if ctx.cr[6].eq {
	pc = 0x825F1128; continue 'dispatch;
	}
	// 825F1108: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825F110C: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 825F1110: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F1114: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 825F1118: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 825F111C: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825F1120: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F1124: 4082FFE8  bne 0x825f110c
	if !ctx.cr[0].eq {
	pc = 0x825F110C; continue 'dispatch;
	}
	// 825F1128: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 825F112C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825F1130: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 825F1134: 419A0024  beq cr6, 0x825f1158
	if ctx.cr[6].eq {
	pc = 0x825F1158; continue 'dispatch;
	}
	// 825F1138: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825F113C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825F1140: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F1144: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825F1148: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825F114C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825F1150: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F1154: 4082FFE8  bne 0x825f113c
	if !ctx.cr[0].eq {
	pc = 0x825F113C; continue 'dispatch;
	}
	// 825F1158: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825F115C: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 825F1160: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825F1164: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 825F1168: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825F116C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825F1170: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825F1174: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825F1178: 481A7DB9  bl 0x82798f30
	ctx.lr = 0x825F117C;
	sub_82798F30(ctx, base);
	// 825F117C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825F1180: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F1184: 481AA4E5  bl 0x8279b668
	ctx.lr = 0x825F1188;
	sub_8279B668(ctx, base);
	// 825F1188: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F118C: 48000008  b 0x825f1194
	pc = 0x825F1194; continue 'dispatch;
	// 825F1190: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825F1194: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825F1198: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 825F119C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F11A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F11A4: 4BFA6AAD  bl 0x82597c50
	ctx.lr = 0x825F11A8;
	sub_82597C50(ctx, base);
	// 825F11A8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825F11AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F11B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F11B4: 4BCCEE4D  bl 0x822c0000
	ctx.lr = 0x825F11B8;
	sub_822C0000(ctx, base);
	// 825F11B8: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825F11BC: 41820024  beq 0x825f11e0
	if ctx.cr[0].eq {
	pc = 0x825F11E0; continue 'dispatch;
	}
	// 825F11C0: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 825F11C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F11C8: 419A0008  beq cr6, 0x825f11d0
	if ctx.cr[6].eq {
	pc = 0x825F11D0; continue 'dispatch;
	}
	// 825F11CC: 4BCCF6C5  bl 0x822c0890
	ctx.lr = 0x825F11D0;
	sub_822C0890(ctx, base);
	// 825F11D0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825F11D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F11D8: 419A0008  beq cr6, 0x825f11e0
	if ctx.cr[6].eq {
	pc = 0x825F11E0; continue 'dispatch;
	}
	// 825F11DC: 4BCCF6B5  bl 0x822c0890
	ctx.lr = 0x825F11E0;
	sub_822C0890(ctx, base);
	// 825F11E0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825F11E4: 419A000C  beq cr6, 0x825f11f0
	if ctx.cr[6].eq {
	pc = 0x825F11F0; continue 'dispatch;
	}
	// 825F11E8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825F11EC: 4BCCF6A5  bl 0x822c0890
	ctx.lr = 0x825F11F0;
	sub_822C0890(ctx, base);
	// 825F11F0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825F11F4: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 825F11F8: 48BB6FBC  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F1200(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825F1200 size=428
    let mut pc: u32 = 0x825F1200;
    'dispatch: loop {
        match pc {
            0x825F1200 => {
    //   block [0x825F1200..0x825F13AC)
	// 825F1200: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F1204: 48BB6F61  bl 0x831a8164
	ctx.lr = 0x825F1208;
	sub_831A8130(ctx, base);
	// 825F1208: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F120C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F1210: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825F1214: 3BCB04D0  addi r30, r11, 0x4d0
	ctx.r[30].s64 = ctx.r[11].s64 + 1232;
	// 825F1218: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825F121C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F1220: 38A0006B  li r5, 0x6b
	ctx.r[5].s64 = 107;
	// 825F1224: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 825F1228: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825F122C: 38600170  li r3, 0x170
	ctx.r[3].s64 = 368;
	// 825F1230: 488011B9  bl 0x82df23e8
	ctx.lr = 0x825F1234;
	sub_82DF23E8(ctx, base);
	// 825F1234: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F1238: 41820014  beq 0x825f124c
	if ctx.cr[0].eq {
	pc = 0x825F124C; continue 'dispatch;
	}
	// 825F123C: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 825F1240: 4BFFF799  bl 0x825f09d8
	ctx.lr = 0x825F1244;
	sub_825F09D8(ctx, base);
	// 825F1244: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F1248: 48000008  b 0x825f1250
	pc = 0x825F1250; continue 'dispatch;
	// 825F124C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825F1250: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825F1254: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F1258: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F125C: 4BFFECB5  bl 0x825eff10
	ctx.lr = 0x825F1260;
	sub_825EFF10(ctx, base);
	// 825F1260: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825F1264: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F1268: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F126C: 4BCCED95  bl 0x822c0000
	ctx.lr = 0x825F1270;
	sub_822C0000(ctx, base);
	// 825F1270: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825F1274: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F1278: 38A0006C  li r5, 0x6c
	ctx.r[5].s64 = 108;
	// 825F127C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825F1280: 4BCCF159  bl 0x822c03d8
	ctx.lr = 0x825F1284;
	sub_822C03D8(ctx, base);
	// 825F1284: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825F1288: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825F128C: 418200B4  beq 0x825f1340
	if ctx.cr[0].eq {
	pc = 0x825F1340; continue 'dispatch;
	}
	// 825F1290: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825F1294: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 825F1298: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825F129C: 396A00E8  addi r11, r10, 0xe8
	ctx.r[11].s64 = ctx.r[10].s64 + 232;
	// 825F12A0: 409A0008  bne cr6, 0x825f12a8
	if !ctx.cr[6].eq {
	pc = 0x825F12A8; continue 'dispatch;
	}
	// 825F12A4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F12A8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825F12AC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825F12B0: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 825F12B4: 419A0024  beq cr6, 0x825f12d8
	if ctx.cr[6].eq {
	pc = 0x825F12D8; continue 'dispatch;
	}
	// 825F12B8: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825F12BC: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 825F12C0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F12C4: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 825F12C8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 825F12CC: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825F12D0: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F12D4: 4082FFE8  bne 0x825f12bc
	if !ctx.cr[0].eq {
	pc = 0x825F12BC; continue 'dispatch;
	}
	// 825F12D8: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 825F12DC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825F12E0: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 825F12E4: 419A0024  beq cr6, 0x825f1308
	if ctx.cr[6].eq {
	pc = 0x825F1308; continue 'dispatch;
	}
	// 825F12E8: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825F12EC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825F12F0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F12F4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825F12F8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825F12FC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825F1300: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F1304: 4082FFE8  bne 0x825f12ec
	if !ctx.cr[0].eq {
	pc = 0x825F12EC; continue 'dispatch;
	}
	// 825F1308: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825F130C: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 825F1310: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825F1314: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 825F1318: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825F131C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825F1320: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825F1324: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825F1328: 481A7C09  bl 0x82798f30
	ctx.lr = 0x825F132C;
	sub_82798F30(ctx, base);
	// 825F132C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825F1330: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F1334: 481AA335  bl 0x8279b668
	ctx.lr = 0x825F1338;
	sub_8279B668(ctx, base);
	// 825F1338: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F133C: 48000008  b 0x825f1344
	pc = 0x825F1344; continue 'dispatch;
	// 825F1340: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825F1344: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825F1348: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 825F134C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F1350: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F1354: 4BFA68FD  bl 0x82597c50
	ctx.lr = 0x825F1358;
	sub_82597C50(ctx, base);
	// 825F1358: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825F135C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F1360: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F1364: 4BCCEC9D  bl 0x822c0000
	ctx.lr = 0x825F1368;
	sub_822C0000(ctx, base);
	// 825F1368: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825F136C: 41820024  beq 0x825f1390
	if ctx.cr[0].eq {
	pc = 0x825F1390; continue 'dispatch;
	}
	// 825F1370: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 825F1374: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F1378: 419A0008  beq cr6, 0x825f1380
	if ctx.cr[6].eq {
	pc = 0x825F1380; continue 'dispatch;
	}
	// 825F137C: 4BCCF515  bl 0x822c0890
	ctx.lr = 0x825F1380;
	sub_822C0890(ctx, base);
	// 825F1380: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825F1384: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F1388: 419A0008  beq cr6, 0x825f1390
	if ctx.cr[6].eq {
	pc = 0x825F1390; continue 'dispatch;
	}
	// 825F138C: 4BCCF505  bl 0x822c0890
	ctx.lr = 0x825F1390;
	sub_822C0890(ctx, base);
	// 825F1390: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825F1394: 419A000C  beq cr6, 0x825f13a0
	if ctx.cr[6].eq {
	pc = 0x825F13A0; continue 'dispatch;
	}
	// 825F1398: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825F139C: 4BCCF4F5  bl 0x822c0890
	ctx.lr = 0x825F13A0;
	sub_822C0890(ctx, base);
	// 825F13A0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825F13A4: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 825F13A8: 48BB6E0C  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F13B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825F13B0 size=2208
    let mut pc: u32 = 0x825F13B0;
    'dispatch: loop {
        match pc {
            0x825F13B0 => {
    //   block [0x825F13B0..0x825F1C50)
	// 825F13B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F13B4: 48BB6DA5  bl 0x831a8158
	ctx.lr = 0x825F13B8;
	sub_831A8130(ctx, base);
	// 825F13B8: DBA1FFA0  stfd f29, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[29].u64 ) };
	// 825F13BC: DBC1FFA8  stfd f30, -0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[30].u64 ) };
	// 825F13C0: DBE1FFB0  stfd f31, -0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 825F13C4: 9421FC60  stwu r1, -0x3a0(r1)
	ea = ctx.r[1].u32.wrapping_add(-928 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F13C8: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 825F13CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F13D0: 7F79DB78  mr r25, r27
	ctx.r[25].u64 = ctx.r[27].u64;
	// 825F13D4: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 825F13D8: 93210058  stw r25, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[25].u32 ) };
	// 825F13DC: 480A2FAD  bl 0x82694388
	ctx.lr = 0x825F13E0;
	sub_82694388(ctx, base);
	// 825F13E0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F13E4: 3B0B04D0  addi r24, r11, 0x4d0
	ctx.r[24].s64 = ctx.r[11].s64 + 1232;
	// 825F13E8: 817F0044  lwz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 825F13EC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825F13F0: 409902DC  ble cr6, 0x825f16cc
	if !ctx.cr[6].gt {
	pc = 0x825F16CC; continue 'dispatch;
	}
	// 825F13F4: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 825F13F8: 40990168  ble cr6, 0x825f1560
	if !ctx.cr[6].gt {
	pc = 0x825F1560; continue 'dispatch;
	}
	// 825F13FC: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 825F1400: 409A02CC  bne cr6, 0x825f16cc
	if !ctx.cr[6].eq {
	pc = 0x825F16CC; continue 'dispatch;
	}
	// 825F1404: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 825F1408: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F140C: 38A000CC  li r5, 0xcc
	ctx.r[5].s64 = 204;
	// 825F1410: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825F1414: 4BCCEFC5  bl 0x822c03d8
	ctx.lr = 0x825F1418;
	sub_822C03D8(ctx, base);
	// 825F1418: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 825F141C: 41820034  beq 0x825f1450
	if ctx.cr[0].eq {
	pc = 0x825F1450; continue 'dispatch;
	}
	// 825F1420: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F1424: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825F1428: 388B0810  addi r4, r11, 0x810
	ctx.r[4].s64 = ctx.r[11].s64 + 2064;
	// 825F142C: 488025DD  bl 0x82df3a08
	ctx.lr = 0x825F1430;
	sub_82DF3A08(ctx, base);
	// 825F1430: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F1434: 38BF004C  addi r5, r31, 0x4c
	ctx.r[5].s64 = ctx.r[31].s64 + 76;
	// 825F1438: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 825F143C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F1440: 3B200002  li r25, 2
	ctx.r[25].s64 = 2;
	// 825F1444: 4BFBAFCD  bl 0x825ac410
	ctx.lr = 0x825F1448;
	sub_825AC410(ctx, base);
	// 825F1448: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825F144C: 48000008  b 0x825f1454
	pc = 0x825F1454; continue 'dispatch;
	// 825F1450: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 825F1454: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 825F1458: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825F145C: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825F1460: 4BF01F59  bl 0x824f33b8
	ctx.lr = 0x825F1464;
	sub_824F33B8(ctx, base);
	// 825F1464: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825F1468: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825F146C: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825F1470: 4BCCEB91  bl 0x822c0000
	ctx.lr = 0x825F1474;
	sub_822C0000(ctx, base);
	// 825F1474: 572B07BD  rlwinm. r11, r25, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825F1478: 41820010  beq 0x825f1488
	if ctx.cr[0].eq {
	pc = 0x825F1488; continue 'dispatch;
	}
	// 825F147C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825F1480: 573907FA  rlwinm r25, r25, 0, 0x1f, 0x1d
	ctx.r[25].u64 = ctx.r[25].u32 as u64 & 0xFFFFFFFFu64;
	// 825F1484: 48801FA5  bl 0x82df3428
	ctx.lr = 0x825F1488;
	sub_82DF3428(ctx, base);
	// 825F1488: 3D40825F  lis r10, -0x7da1
	ctx.r[10].s64 = -2107703296;
	// 825F148C: 9361006C  stw r27, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[27].u32 ) };
	// 825F1490: 397FFF18  addi r11, r31, -0xe8
	ctx.r[11].s64 = ctx.r[31].s64 + -232;
	// 825F1494: 936100A0  stw r27, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[27].u32 ) };
	// 825F1498: 394AF9B0  addi r10, r10, -0x650
	ctx.r[10].s64 = ctx.r[10].s64 + -1616;
	// 825F149C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 825F14A0: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 825F14A4: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 825F14A8: E8810068  ld r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 825F14AC: E8A10088  ld r5, 0x88(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	// 825F14B0: 4BFFF6C1  bl 0x825f0b70
	ctx.lr = 0x825F14B4;
	sub_825F0B70(ctx, base);
	// 825F14B4: 83810058  lwz r28, 0x58(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825F14B8: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 825F14BC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825F14C0: 4BFB9CB1  bl 0x825ab170
	ctx.lr = 0x825F14C4;
	sub_825AB170(ctx, base);
	// 825F14C4: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825F14C8: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 825F14CC: 3BABE6F0  addi r29, r11, -0x1910
	ctx.r[29].s64 = ctx.r[11].s64 + -6416;
	// 825F14D0: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 825F14D4: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F14D8: 48802531  bl 0x82df3a08
	ctx.lr = 0x825F14DC;
	sub_82DF3A08(ctx, base);
	// 825F14DC: 38A10074  addi r5, r1, 0x74
	ctx.r[5].s64 = ctx.r[1].s64 + 116;
	// 825F14E0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825F14E4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825F14E8: 4BFBA8D9  bl 0x825abdc0
	ctx.lr = 0x825F14EC;
	sub_825ABDC0(ctx, base);
	// 825F14EC: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 825F14F0: 48801F39  bl 0x82df3428
	ctx.lr = 0x825F14F4;
	sub_82DF3428(ctx, base);
	// 825F14F4: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 825F14F8: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 825F14FC: 2B1E0003  cmplwi cr6, r30, 3
	ctx.cr[6].compare_u32(ctx.r[30].u32, 3 as u32, &mut ctx.xer);
	// 825F1500: 4198FFD0  blt cr6, 0x825f14d0
	if ctx.cr[6].lt {
	pc = 0x825F14D0; continue 'dispatch;
	}
	// 825F1504: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F1508: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 825F150C: 388B0804  addi r4, r11, 0x804
	ctx.r[4].s64 = ctx.r[11].s64 + 2052;
	// 825F1510: 488024F9  bl 0x82df3a08
	ctx.lr = 0x825F1514;
	sub_82DF3A08(ctx, base);
	// 825F1514: 83C1005C  lwz r30, 0x5c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825F1518: 93810078  stw r28, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[28].u32 ) };
	// 825F151C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825F1520: 93C1007C  stw r30, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[30].u32 ) };
	// 825F1524: 419A0024  beq cr6, 0x825f1548
	if ctx.cr[6].eq {
	pc = 0x825F1548; continue 'dispatch;
	}
	// 825F1528: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 825F152C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825F1530: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F1534: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825F1538: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825F153C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825F1540: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F1544: 4082FFE8  bne 0x825f152c
	if !ctx.cr[0].eq {
	pc = 0x825F152C; continue 'dispatch;
	}
	// 825F1548: 38A10078  addi r5, r1, 0x78
	ctx.r[5].s64 = ctx.r[1].s64 + 120;
	// 825F154C: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 825F1550: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825F1554: 4BFB0BBD  bl 0x825a2110
	ctx.lr = 0x825F1558;
	sub_825A2110(ctx, base);
	// 825F1558: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 825F155C: 4800015C  b 0x825f16b8
	pc = 0x825F16B8; continue 'dispatch;
	// 825F1560: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 825F1564: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F1568: 38A000C2  li r5, 0xc2
	ctx.r[5].s64 = 194;
	// 825F156C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825F1570: 4BCCEE69  bl 0x822c03d8
	ctx.lr = 0x825F1574;
	sub_822C03D8(ctx, base);
	// 825F1574: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 825F1578: 41820034  beq 0x825f15ac
	if ctx.cr[0].eq {
	pc = 0x825F15AC; continue 'dispatch;
	}
	// 825F157C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F1580: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825F1584: 388B0810  addi r4, r11, 0x810
	ctx.r[4].s64 = ctx.r[11].s64 + 2064;
	// 825F1588: 48802481  bl 0x82df3a08
	ctx.lr = 0x825F158C;
	sub_82DF3A08(ctx, base);
	// 825F158C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F1590: 38BF004C  addi r5, r31, 0x4c
	ctx.r[5].s64 = ctx.r[31].s64 + 76;
	// 825F1594: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825F1598: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F159C: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	// 825F15A0: 4BFBAE71  bl 0x825ac410
	ctx.lr = 0x825F15A4;
	sub_825AC410(ctx, base);
	// 825F15A4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825F15A8: 48000008  b 0x825f15b0
	pc = 0x825F15B0; continue 'dispatch;
	// 825F15AC: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 825F15B0: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 825F15B4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825F15B8: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825F15BC: 4BF01DFD  bl 0x824f33b8
	ctx.lr = 0x825F15C0;
	sub_824F33B8(ctx, base);
	// 825F15C0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825F15C4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825F15C8: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825F15CC: 4BCCEA35  bl 0x822c0000
	ctx.lr = 0x825F15D0;
	sub_822C0000(ctx, base);
	// 825F15D0: 572B07FF  clrlwi. r11, r25, 0x1f
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825F15D4: 41820010  beq 0x825f15e4
	if ctx.cr[0].eq {
	pc = 0x825F15E4; continue 'dispatch;
	}
	// 825F15D8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825F15DC: 5739003C  rlwinm r25, r25, 0, 0, 0x1e
	ctx.r[25].u64 = ctx.r[25].u32 as u64 & 0xFFFFFFFFu64;
	// 825F15E0: 48801E49  bl 0x82df3428
	ctx.lr = 0x825F15E4;
	sub_82DF3428(ctx, base);
	// 825F15E4: 3D40825F  lis r10, -0x7da1
	ctx.r[10].s64 = -2107703296;
	// 825F15E8: 9361006C  stw r27, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[27].u32 ) };
	// 825F15EC: 397FFF18  addi r11, r31, -0xe8
	ctx.r[11].s64 = ctx.r[31].s64 + -232;
	// 825F15F0: 936100C0  stw r27, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[27].u32 ) };
	// 825F15F4: 394AF9B0  addi r10, r10, -0x650
	ctx.r[10].s64 = ctx.r[10].s64 + -1616;
	// 825F15F8: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 825F15FC: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 825F1600: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 825F1604: E8A10088  ld r5, 0x88(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	// 825F1608: E8810068  ld r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 825F160C: 4BFFF565  bl 0x825f0b70
	ctx.lr = 0x825F1610;
	sub_825F0B70(ctx, base);
	// 825F1610: 83810058  lwz r28, 0x58(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825F1614: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 825F1618: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825F161C: 4BFB9B55  bl 0x825ab170
	ctx.lr = 0x825F1620;
	sub_825AB170(ctx, base);
	// 825F1620: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825F1624: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 825F1628: 3BABE6FC  addi r29, r11, -0x1904
	ctx.r[29].s64 = ctx.r[11].s64 + -6404;
	// 825F162C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F1630: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F1634: 488023D5  bl 0x82df3a08
	ctx.lr = 0x825F1638;
	sub_82DF3A08(ctx, base);
	// 825F1638: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 825F163C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825F1640: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825F1644: 4BFBA77D  bl 0x825abdc0
	ctx.lr = 0x825F1648;
	sub_825ABDC0(ctx, base);
	// 825F1648: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F164C: 48801DDD  bl 0x82df3428
	ctx.lr = 0x825F1650;
	sub_82DF3428(ctx, base);
	// 825F1650: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 825F1654: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 825F1658: 2B1E0004  cmplwi cr6, r30, 4
	ctx.cr[6].compare_u32(ctx.r[30].u32, 4 as u32, &mut ctx.xer);
	// 825F165C: 4198FFD0  blt cr6, 0x825f162c
	if ctx.cr[6].lt {
	pc = 0x825F162C; continue 'dispatch;
	}
	// 825F1660: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F1664: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F1668: 388B0804  addi r4, r11, 0x804
	ctx.r[4].s64 = ctx.r[11].s64 + 2052;
	// 825F166C: 4880239D  bl 0x82df3a08
	ctx.lr = 0x825F1670;
	sub_82DF3A08(ctx, base);
	// 825F1670: 83C1005C  lwz r30, 0x5c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825F1674: 93810090  stw r28, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[28].u32 ) };
	// 825F1678: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825F167C: 93C10094  stw r30, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[30].u32 ) };
	// 825F1680: 419A0024  beq cr6, 0x825f16a4
	if ctx.cr[6].eq {
	pc = 0x825F16A4; continue 'dispatch;
	}
	// 825F1684: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 825F1688: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825F168C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F1690: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825F1694: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825F1698: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825F169C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F16A0: 4082FFE8  bne 0x825f1688
	if !ctx.cr[0].eq {
	pc = 0x825F1688; continue 'dispatch;
	}
	// 825F16A4: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 825F16A8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825F16AC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825F16B0: 4BFB0A61  bl 0x825a2110
	ctx.lr = 0x825F16B4;
	sub_825A2110(ctx, base);
	// 825F16B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F16B8: 48801D71  bl 0x82df3428
	ctx.lr = 0x825F16BC;
	sub_82DF3428(ctx, base);
	// 825F16BC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825F16C0: 419A000C  beq cr6, 0x825f16cc
	if ctx.cr[6].eq {
	pc = 0x825F16CC; continue 'dispatch;
	}
	// 825F16C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F16C8: 4BCCF1C9  bl 0x822c0890
	ctx.lr = 0x825F16CC;
	sub_822C0890(ctx, base);
	// 825F16CC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F16D0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F16D4: 388B07EC  addi r4, r11, 0x7ec
	ctx.r[4].s64 = ctx.r[11].s64 + 2028;
	// 825F16D8: 48802331  bl 0x82df3a08
	ctx.lr = 0x825F16DC;
	sub_82DF3A08(ctx, base);
	// 825F16DC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F16E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F16E4: 388B07D8  addi r4, r11, 0x7d8
	ctx.r[4].s64 = ctx.r[11].s64 + 2008;
	// 825F16E8: 48802321  bl 0x82df3a08
	ctx.lr = 0x825F16EC;
	sub_82DF3A08(ctx, base);
	// 825F16EC: 38BF0048  addi r5, r31, 0x48
	ctx.r[5].s64 = ctx.r[31].s64 + 72;
	// 825F16F0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825F16F4: 386101E0  addi r3, r1, 0x1e0
	ctx.r[3].s64 = ctx.r[1].s64 + 480;
	// 825F16F8: 4BFB1959  bl 0x825a3050
	ctx.lr = 0x825F16FC;
	sub_825A3050(ctx, base);
	// 825F16FC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825F1700: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825F1704: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825F1708: 4BFB0A81  bl 0x825a2188
	ctx.lr = 0x825F170C;
	sub_825A2188(ctx, base);
	// 825F170C: 38610208  addi r3, r1, 0x208
	ctx.r[3].s64 = ctx.r[1].s64 + 520;
	// 825F1710: 48801D19  bl 0x82df3428
	ctx.lr = 0x825F1714;
	sub_82DF3428(ctx, base);
	// 825F1714: 386101E8  addi r3, r1, 0x1e8
	ctx.r[3].s64 = ctx.r[1].s64 + 488;
	// 825F1718: 4BCD75A1  bl 0x822c8cb8
	ctx.lr = 0x825F171C;
	sub_822C8CB8(ctx, base);
	// 825F171C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F1720: 48801D09  bl 0x82df3428
	ctx.lr = 0x825F1724;
	sub_82DF3428(ctx, base);
	// 825F1724: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F1728: 48801D01  bl 0x82df3428
	ctx.lr = 0x825F172C;
	sub_82DF3428(ctx, base);
	// 825F172C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 825F1730: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 825F1734: 817F0044  lwz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 825F1738: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825F173C: C3CA9528  lfs f30, -0x6ad8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 825F1740: C3E908A4  lfs f31, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825F1744: 419A000C  beq cr6, 0x825f1750
	if ctx.cr[6].eq {
	pc = 0x825F1750; continue 'dispatch;
	}
	// 825F1748: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 825F174C: 409A00D4  bne cr6, 0x825f1820
	if !ctx.cr[6].eq {
	pc = 0x825F1820; continue 'dispatch;
	}
	// 825F1750: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F1754: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F1758: 388B07C0  addi r4, r11, 0x7c0
	ctx.r[4].s64 = ctx.r[11].s64 + 1984;
	// 825F175C: 488022AD  bl 0x82df3a08
	ctx.lr = 0x825F1760;
	sub_82DF3A08(ctx, base);
	// 825F1760: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F1764: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F1768: 388B07B0  addi r4, r11, 0x7b0
	ctx.r[4].s64 = ctx.r[11].s64 + 1968;
	// 825F176C: 4880229D  bl 0x82df3a08
	ctx.lr = 0x825F1770;
	sub_82DF3A08(ctx, base);
	// 825F1770: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 825F1774: 38BF0054  addi r5, r31, 0x54
	ctx.r[5].s64 = ctx.r[31].s64 + 84;
	// 825F1778: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 825F177C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825F1780: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825F1784: 38610240  addi r3, r1, 0x240
	ctx.r[3].s64 = ctx.r[1].s64 + 576;
	// 825F1788: C04B89AC  lfs f2, -0x7654(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 825F178C: 4BFBC32D  bl 0x825adab8
	ctx.lr = 0x825F1790;
	sub_825ADAB8(ctx, base);
	// 825F1790: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825F1794: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825F1798: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825F179C: 4BFAFEB5  bl 0x825a1650
	ctx.lr = 0x825F17A0;
	sub_825A1650(ctx, base);
	// 825F17A0: 38610278  addi r3, r1, 0x278
	ctx.r[3].s64 = ctx.r[1].s64 + 632;
	// 825F17A4: 48801C85  bl 0x82df3428
	ctx.lr = 0x825F17A8;
	sub_82DF3428(ctx, base);
	// 825F17A8: 38610258  addi r3, r1, 0x258
	ctx.r[3].s64 = ctx.r[1].s64 + 600;
	// 825F17AC: 4BCD750D  bl 0x822c8cb8
	ctx.lr = 0x825F17B0;
	sub_822C8CB8(ctx, base);
	// 825F17B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F17B4: 48801C75  bl 0x82df3428
	ctx.lr = 0x825F17B8;
	sub_82DF3428(ctx, base);
	// 825F17B8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F17BC: 48801C6D  bl 0x82df3428
	ctx.lr = 0x825F17C0;
	sub_82DF3428(ctx, base);
	// 825F17C0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F17C4: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 825F17C8: 388B079C  addi r4, r11, 0x79c
	ctx.r[4].s64 = ctx.r[11].s64 + 1948;
	// 825F17CC: 4880223D  bl 0x82df3a08
	ctx.lr = 0x825F17D0;
	sub_82DF3A08(ctx, base);
	// 825F17D0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F17D4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825F17D8: 388B078C  addi r4, r11, 0x78c
	ctx.r[4].s64 = ctx.r[11].s64 + 1932;
	// 825F17DC: 4880222D  bl 0x82df3a08
	ctx.lr = 0x825F17E0;
	sub_82DF3A08(ctx, base);
	// 825F17E0: 38BF0058  addi r5, r31, 0x58
	ctx.r[5].s64 = ctx.r[31].s64 + 88;
	// 825F17E4: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 825F17E8: 38610180  addi r3, r1, 0x180
	ctx.r[3].s64 = ctx.r[1].s64 + 384;
	// 825F17EC: 4BFB1865  bl 0x825a3050
	ctx.lr = 0x825F17F0;
	sub_825A3050(ctx, base);
	// 825F17F0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825F17F4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825F17F8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825F17FC: 4BFB098D  bl 0x825a2188
	ctx.lr = 0x825F1800;
	sub_825A2188(ctx, base);
	// 825F1800: 386101A8  addi r3, r1, 0x1a8
	ctx.r[3].s64 = ctx.r[1].s64 + 424;
	// 825F1804: 48801C25  bl 0x82df3428
	ctx.lr = 0x825F1808;
	sub_82DF3428(ctx, base);
	// 825F1808: 38610188  addi r3, r1, 0x188
	ctx.r[3].s64 = ctx.r[1].s64 + 392;
	// 825F180C: 4BCD74AD  bl 0x822c8cb8
	ctx.lr = 0x825F1810;
	sub_822C8CB8(ctx, base);
	// 825F1810: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825F1814: 48801C15  bl 0x82df3428
	ctx.lr = 0x825F1818;
	sub_82DF3428(ctx, base);
	// 825F1818: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 825F181C: 48801C0D  bl 0x82df3428
	ctx.lr = 0x825F1820;
	sub_82DF3428(ctx, base);
	// 825F1820: 817F0044  lwz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 825F1824: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825F1828: 409902AC  ble cr6, 0x825f1ad4
	if !ctx.cr[6].gt {
	pc = 0x825F1AD4; continue 'dispatch;
	}
	// 825F182C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825F1830: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 825F1834: C3AA08A8  lfs f29, 0x8a8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 825F1838: 40990010  ble cr6, 0x825f1848
	if !ctx.cr[6].gt {
	pc = 0x825F1848; continue 'dispatch;
	}
	// 825F183C: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 825F1840: 419A0074  beq cr6, 0x825f18b4
	if ctx.cr[6].eq {
	pc = 0x825F18B4; continue 'dispatch;
	}
	// 825F1844: 48000290  b 0x825f1ad4
	pc = 0x825F1AD4; continue 'dispatch;
	// 825F1848: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F184C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F1850: 388B0770  addi r4, r11, 0x770
	ctx.r[4].s64 = ctx.r[11].s64 + 1904;
	// 825F1854: 488021B5  bl 0x82df3a08
	ctx.lr = 0x825F1858;
	sub_82DF3A08(ctx, base);
	// 825F1858: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F185C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F1860: 388B0758  addi r4, r11, 0x758
	ctx.r[4].s64 = ctx.r[11].s64 + 1880;
	// 825F1864: 488021A5  bl 0x82df3a08
	ctx.lr = 0x825F1868;
	sub_82DF3A08(ctx, base);
	// 825F1868: 38BF0064  addi r5, r31, 0x64
	ctx.r[5].s64 = ctx.r[31].s64 + 100;
	// 825F186C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825F1870: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 825F1874: 386102C0  addi r3, r1, 0x2c0
	ctx.r[3].s64 = ctx.r[1].s64 + 704;
	// 825F1878: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 825F187C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825F1880: 4BFBC239  bl 0x825adab8
	ctx.lr = 0x825F1884;
	sub_825ADAB8(ctx, base);
	// 825F1884: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825F1888: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825F188C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825F1890: 4BFAFDC1  bl 0x825a1650
	ctx.lr = 0x825F1894;
	sub_825A1650(ctx, base);
	// 825F1894: 386102F8  addi r3, r1, 0x2f8
	ctx.r[3].s64 = ctx.r[1].s64 + 760;
	// 825F1898: 48801B91  bl 0x82df3428
	ctx.lr = 0x825F189C;
	sub_82DF3428(ctx, base);
	// 825F189C: 386102D8  addi r3, r1, 0x2d8
	ctx.r[3].s64 = ctx.r[1].s64 + 728;
	// 825F18A0: 4BCD7419  bl 0x822c8cb8
	ctx.lr = 0x825F18A4;
	sub_822C8CB8(ctx, base);
	// 825F18A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F18A8: 48801B81  bl 0x82df3428
	ctx.lr = 0x825F18AC;
	sub_82DF3428(ctx, base);
	// 825F18AC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F18B0: 48801B79  bl 0x82df3428
	ctx.lr = 0x825F18B4;
	sub_82DF3428(ctx, base);
	// 825F18B4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F18B8: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 825F18BC: 388B0730  addi r4, r11, 0x730
	ctx.r[4].s64 = ctx.r[11].s64 + 1840;
	// 825F18C0: 48802149  bl 0x82df3a08
	ctx.lr = 0x825F18C4;
	sub_82DF3A08(ctx, base);
	// 825F18C4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F18C8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825F18CC: 388B0718  addi r4, r11, 0x718
	ctx.r[4].s64 = ctx.r[11].s64 + 1816;
	// 825F18D0: 48802139  bl 0x82df3a08
	ctx.lr = 0x825F18D4;
	sub_82DF3A08(ctx, base);
	// 825F18D4: 38BF005A  addi r5, r31, 0x5a
	ctx.r[5].s64 = ctx.r[31].s64 + 90;
	// 825F18D8: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 825F18DC: 38610210  addi r3, r1, 0x210
	ctx.r[3].s64 = ctx.r[1].s64 + 528;
	// 825F18E0: 4BFB1771  bl 0x825a3050
	ctx.lr = 0x825F18E4;
	sub_825A3050(ctx, base);
	// 825F18E4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825F18E8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825F18EC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825F18F0: 4BFB0899  bl 0x825a2188
	ctx.lr = 0x825F18F4;
	sub_825A2188(ctx, base);
	// 825F18F4: 38610238  addi r3, r1, 0x238
	ctx.r[3].s64 = ctx.r[1].s64 + 568;
	// 825F18F8: 48801B31  bl 0x82df3428
	ctx.lr = 0x825F18FC;
	sub_82DF3428(ctx, base);
	// 825F18FC: 38610218  addi r3, r1, 0x218
	ctx.r[3].s64 = ctx.r[1].s64 + 536;
	// 825F1900: 4BCD73B9  bl 0x822c8cb8
	ctx.lr = 0x825F1904;
	sub_822C8CB8(ctx, base);
	// 825F1904: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825F1908: 48801B21  bl 0x82df3428
	ctx.lr = 0x825F190C;
	sub_82DF3428(ctx, base);
	// 825F190C: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 825F1910: 48801B19  bl 0x82df3428
	ctx.lr = 0x825F1914;
	sub_82DF3428(ctx, base);
	// 825F1914: 3D60825F  lis r11, -0x7da1
	ctx.r[11].s64 = -2107703296;
	// 825F1918: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825F191C: 93610084  stw r27, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[27].u32 ) };
	// 825F1920: 396BFA90  addi r11, r11, -0x570
	ctx.r[11].s64 = ctx.r[11].s64 + -1392;
	// 825F1924: 388A06E8  addi r4, r10, 0x6e8
	ctx.r[4].s64 = ctx.r[10].s64 + 1768;
	// 825F1928: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825F192C: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 825F1930: 488020D9  bl 0x82df3a08
	ctx.lr = 0x825F1934;
	sub_82DF3A08(ctx, base);
	// 825F1934: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F1938: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 825F193C: 388B06D8  addi r4, r11, 0x6d8
	ctx.r[4].s64 = ctx.r[11].s64 + 1752;
	// 825F1940: 488020C9  bl 0x82df3a08
	ctx.lr = 0x825F1944;
	sub_82DF3A08(ctx, base);
	// 825F1944: 3BDFFF18  addi r30, r31, -0xe8
	ctx.r[30].s64 = ctx.r[31].s64 + -232;
	// 825F1948: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 825F194C: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 825F1950: 93C10088  stw r30, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[30].u32 ) };
	// 825F1954: E8A10088  ld r5, 0x88(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	// 825F1958: 936100C0  stw r27, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[27].u32 ) };
	// 825F195C: 4BFFF295  bl 0x825f0bf0
	ctx.lr = 0x825F1960;
	sub_825F0BF0(ctx, base);
	// 825F1960: 38C100C0  addi r6, r1, 0xc0
	ctx.r[6].s64 = ctx.r[1].s64 + 192;
	// 825F1964: 38BF005B  addi r5, r31, 0x5b
	ctx.r[5].s64 = ctx.r[31].s64 + 91;
	// 825F1968: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 825F196C: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 825F1970: 4BFB1749  bl 0x825a30b8
	ctx.lr = 0x825F1974;
	sub_825A30B8(ctx, base);
	// 825F1974: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825F1978: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 825F197C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825F1980: 4BFB0809  bl 0x825a2188
	ctx.lr = 0x825F1984;
	sub_825A2188(ctx, base);
	// 825F1984: 38610148  addi r3, r1, 0x148
	ctx.r[3].s64 = ctx.r[1].s64 + 328;
	// 825F1988: 48801AA1  bl 0x82df3428
	ctx.lr = 0x825F198C;
	sub_82DF3428(ctx, base);
	// 825F198C: 38610128  addi r3, r1, 0x128
	ctx.r[3].s64 = ctx.r[1].s64 + 296;
	// 825F1990: 4BCD7329  bl 0x822c8cb8
	ctx.lr = 0x825F1994;
	sub_822C8CB8(ctx, base);
	// 825F1994: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 825F1998: 48801A91  bl 0x82df3428
	ctx.lr = 0x825F199C;
	sub_82DF3428(ctx, base);
	// 825F199C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825F19A0: 48801A89  bl 0x82df3428
	ctx.lr = 0x825F19A4;
	sub_82DF3428(ctx, base);
	// 825F19A4: 3D60825F  lis r11, -0x7da1
	ctx.r[11].s64 = -2107703296;
	// 825F19A8: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825F19AC: 93610084  stw r27, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[27].u32 ) };
	// 825F19B0: 396BFA90  addi r11, r11, -0x570
	ctx.r[11].s64 = ctx.r[11].s64 + -1392;
	// 825F19B4: 388A06BC  addi r4, r10, 0x6bc
	ctx.r[4].s64 = ctx.r[10].s64 + 1724;
	// 825F19B8: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825F19BC: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 825F19C0: 48802049  bl 0x82df3a08
	ctx.lr = 0x825F19C4;
	sub_82DF3A08(ctx, base);
	// 825F19C4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F19C8: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825F19CC: 388B06A4  addi r4, r11, 0x6a4
	ctx.r[4].s64 = ctx.r[11].s64 + 1700;
	// 825F19D0: 48802039  bl 0x82df3a08
	ctx.lr = 0x825F19D4;
	sub_82DF3A08(ctx, base);
	// 825F19D4: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 825F19D8: 93C100A8  stw r30, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[30].u32 ) };
	// 825F19DC: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 825F19E0: E8A100A8  ld r5, 0xa8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 825F19E4: 936100E0  stw r27, 0xe0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[27].u32 ) };
	// 825F19E8: 4BFFF289  bl 0x825f0c70
	ctx.lr = 0x825F19EC;
	sub_825F0C70(ctx, base);
	// 825F19EC: 392100E0  addi r9, r1, 0xe0
	ctx.r[9].s64 = ctx.r[1].s64 + 224;
	// 825F19F0: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 825F19F4: 38BF005C  addi r5, r31, 0x5c
	ctx.r[5].s64 = ctx.r[31].s64 + 92;
	// 825F19F8: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 825F19FC: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 825F1A00: 38610280  addi r3, r1, 0x280
	ctx.r[3].s64 = ctx.r[1].s64 + 640;
	// 825F1A04: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825F1A08: 4BFBC041  bl 0x825ada48
	ctx.lr = 0x825F1A0C;
	sub_825ADA48(ctx, base);
	// 825F1A0C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825F1A10: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 825F1A14: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825F1A18: 4BFAFC39  bl 0x825a1650
	ctx.lr = 0x825F1A1C;
	sub_825A1650(ctx, base);
	// 825F1A1C: 386102B8  addi r3, r1, 0x2b8
	ctx.r[3].s64 = ctx.r[1].s64 + 696;
	// 825F1A20: 48801A09  bl 0x82df3428
	ctx.lr = 0x825F1A24;
	sub_82DF3428(ctx, base);
	// 825F1A24: 38610298  addi r3, r1, 0x298
	ctx.r[3].s64 = ctx.r[1].s64 + 664;
	// 825F1A28: 4BCD7291  bl 0x822c8cb8
	ctx.lr = 0x825F1A2C;
	sub_822C8CB8(ctx, base);
	// 825F1A2C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825F1A30: 488019F9  bl 0x82df3428
	ctx.lr = 0x825F1A34;
	sub_82DF3428(ctx, base);
	// 825F1A34: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825F1A38: 488019F1  bl 0x82df3428
	ctx.lr = 0x825F1A3C;
	sub_82DF3428(ctx, base);
	// 825F1A3C: 3D60825F  lis r11, -0x7da1
	ctx.r[11].s64 = -2107703296;
	// 825F1A40: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825F1A44: 93610084  stw r27, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[27].u32 ) };
	// 825F1A48: 396BFA90  addi r11, r11, -0x570
	ctx.r[11].s64 = ctx.r[11].s64 + -1392;
	// 825F1A4C: 388A0688  addi r4, r10, 0x688
	ctx.r[4].s64 = ctx.r[10].s64 + 1672;
	// 825F1A50: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825F1A54: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 825F1A58: 48801FB1  bl 0x82df3a08
	ctx.lr = 0x825F1A5C;
	sub_82DF3A08(ctx, base);
	// 825F1A5C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F1A60: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825F1A64: 388B0670  addi r4, r11, 0x670
	ctx.r[4].s64 = ctx.r[11].s64 + 1648;
	// 825F1A68: 48801FA1  bl 0x82df3a08
	ctx.lr = 0x825F1A6C;
	sub_82DF3A08(ctx, base);
	// 825F1A6C: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 825F1A70: 93C100A8  stw r30, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[30].u32 ) };
	// 825F1A74: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 825F1A78: E8A100A8  ld r5, 0xa8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 825F1A7C: 93610100  stw r27, 0x100(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), ctx.r[27].u32 ) };
	// 825F1A80: 4BFFF1F1  bl 0x825f0c70
	ctx.lr = 0x825F1A84;
	sub_825F0C70(ctx, base);
	// 825F1A84: 39210100  addi r9, r1, 0x100
	ctx.r[9].s64 = ctx.r[1].s64 + 256;
	// 825F1A88: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 825F1A8C: 38BF0060  addi r5, r31, 0x60
	ctx.r[5].s64 = ctx.r[31].s64 + 96;
	// 825F1A90: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 825F1A94: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825F1A98: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825F1A9C: 38610300  addi r3, r1, 0x300
	ctx.r[3].s64 = ctx.r[1].s64 + 768;
	// 825F1AA0: 4BFBBFA9  bl 0x825ada48
	ctx.lr = 0x825F1AA4;
	sub_825ADA48(ctx, base);
	// 825F1AA4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825F1AA8: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 825F1AAC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825F1AB0: 4BFAFBA1  bl 0x825a1650
	ctx.lr = 0x825F1AB4;
	sub_825A1650(ctx, base);
	// 825F1AB4: 38610338  addi r3, r1, 0x338
	ctx.r[3].s64 = ctx.r[1].s64 + 824;
	// 825F1AB8: 48801971  bl 0x82df3428
	ctx.lr = 0x825F1ABC;
	sub_82DF3428(ctx, base);
	// 825F1ABC: 38610318  addi r3, r1, 0x318
	ctx.r[3].s64 = ctx.r[1].s64 + 792;
	// 825F1AC0: 4BCD71F9  bl 0x822c8cb8
	ctx.lr = 0x825F1AC4;
	sub_822C8CB8(ctx, base);
	// 825F1AC4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825F1AC8: 48801961  bl 0x82df3428
	ctx.lr = 0x825F1ACC;
	sub_82DF3428(ctx, base);
	// 825F1ACC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825F1AD0: 48801959  bl 0x82df3428
	ctx.lr = 0x825F1AD4;
	sub_82DF3428(ctx, base);
	// 825F1AD4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F1AD8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825F1ADC: 388B0660  addi r4, r11, 0x660
	ctx.r[4].s64 = ctx.r[11].s64 + 1632;
	// 825F1AE0: 48801F29  bl 0x82df3a08
	ctx.lr = 0x825F1AE4;
	sub_82DF3A08(ctx, base);
	// 825F1AE4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F1AE8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825F1AEC: 388B064C  addi r4, r11, 0x64c
	ctx.r[4].s64 = ctx.r[11].s64 + 1612;
	// 825F1AF0: 48801F19  bl 0x82df3a08
	ctx.lr = 0x825F1AF4;
	sub_82DF3A08(ctx, base);
	// 825F1AF4: 38BF0050  addi r5, r31, 0x50
	ctx.r[5].s64 = ctx.r[31].s64 + 80;
	// 825F1AF8: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 825F1AFC: 386101B0  addi r3, r1, 0x1b0
	ctx.r[3].s64 = ctx.r[1].s64 + 432;
	// 825F1B00: 4BFB1551  bl 0x825a3050
	ctx.lr = 0x825F1B04;
	sub_825A3050(ctx, base);
	// 825F1B04: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825F1B08: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825F1B0C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825F1B10: 4BFB0679  bl 0x825a2188
	ctx.lr = 0x825F1B14;
	sub_825A2188(ctx, base);
	// 825F1B14: 386101D8  addi r3, r1, 0x1d8
	ctx.r[3].s64 = ctx.r[1].s64 + 472;
	// 825F1B18: 48801911  bl 0x82df3428
	ctx.lr = 0x825F1B1C;
	sub_82DF3428(ctx, base);
	// 825F1B1C: 386101B8  addi r3, r1, 0x1b8
	ctx.r[3].s64 = ctx.r[1].s64 + 440;
	// 825F1B20: 4BCD7199  bl 0x822c8cb8
	ctx.lr = 0x825F1B24;
	sub_822C8CB8(ctx, base);
	// 825F1B24: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825F1B28: 48801901  bl 0x82df3428
	ctx.lr = 0x825F1B2C;
	sub_82DF3428(ctx, base);
	// 825F1B2C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825F1B30: 488018F9  bl 0x82df3428
	ctx.lr = 0x825F1B34;
	sub_82DF3428(ctx, base);
	// 825F1B34: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F1B38: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825F1B3C: 388B063C  addi r4, r11, 0x63c
	ctx.r[4].s64 = ctx.r[11].s64 + 1596;
	// 825F1B40: 48801EC9  bl 0x82df3a08
	ctx.lr = 0x825F1B44;
	sub_82DF3A08(ctx, base);
	// 825F1B44: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F1B48: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825F1B4C: 388B0628  addi r4, r11, 0x628
	ctx.r[4].s64 = ctx.r[11].s64 + 1576;
	// 825F1B50: 48801EB9  bl 0x82df3a08
	ctx.lr = 0x825F1B54;
	sub_82DF3A08(ctx, base);
	// 825F1B54: 38BF0051  addi r5, r31, 0x51
	ctx.r[5].s64 = ctx.r[31].s64 + 81;
	// 825F1B58: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 825F1B5C: 38610150  addi r3, r1, 0x150
	ctx.r[3].s64 = ctx.r[1].s64 + 336;
	// 825F1B60: 4BFB14F1  bl 0x825a3050
	ctx.lr = 0x825F1B64;
	sub_825A3050(ctx, base);
	// 825F1B64: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825F1B68: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825F1B6C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825F1B70: 4BFB0619  bl 0x825a2188
	ctx.lr = 0x825F1B74;
	sub_825A2188(ctx, base);
	// 825F1B74: 38610178  addi r3, r1, 0x178
	ctx.r[3].s64 = ctx.r[1].s64 + 376;
	// 825F1B78: 488018B1  bl 0x82df3428
	ctx.lr = 0x825F1B7C;
	sub_82DF3428(ctx, base);
	// 825F1B7C: 38610158  addi r3, r1, 0x158
	ctx.r[3].s64 = ctx.r[1].s64 + 344;
	// 825F1B80: 4BCD7139  bl 0x822c8cb8
	ctx.lr = 0x825F1B84;
	sub_822C8CB8(ctx, base);
	// 825F1B84: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825F1B88: 488018A1  bl 0x82df3428
	ctx.lr = 0x825F1B8C;
	sub_82DF3428(ctx, base);
	// 825F1B8C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825F1B90: 48801899  bl 0x82df3428
	ctx.lr = 0x825F1B94;
	sub_82DF3428(ctx, base);
	// 825F1B94: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 825F1B98: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F1B9C: 38A000F4  li r5, 0xf4
	ctx.r[5].s64 = 244;
	// 825F1BA0: 38600080  li r3, 0x80
	ctx.r[3].s64 = 128;
	// 825F1BA4: 4BCCE835  bl 0x822c03d8
	ctx.lr = 0x825F1BA8;
	sub_822C03D8(ctx, base);
	// 825F1BA8: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 825F1BAC: 41820034  beq 0x825f1be0
	if ctx.cr[0].eq {
	pc = 0x825F1BE0; continue 'dispatch;
	}
	// 825F1BB0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F1BB4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825F1BB8: 388B0618  addi r4, r11, 0x618
	ctx.r[4].s64 = ctx.r[11].s64 + 1560;
	// 825F1BBC: 48801E4D  bl 0x82df3a08
	ctx.lr = 0x825F1BC0;
	sub_82DF3A08(ctx, base);
	// 825F1BC0: 38C0000C  li r6, 0xc
	ctx.r[6].s64 = 12;
	// 825F1BC4: 38BF0068  addi r5, r31, 0x68
	ctx.r[5].s64 = ctx.r[31].s64 + 104;
	// 825F1BC8: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 825F1BCC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F1BD0: 63390004  ori r25, r25, 4
	ctx.r[25].u64 = ctx.r[25].u64 | 4;
	// 825F1BD4: 4BFB7925  bl 0x825a94f8
	ctx.lr = 0x825F1BD8;
	sub_825A94F8(ctx, base);
	// 825F1BD8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F1BDC: 48000008  b 0x825f1be4
	pc = 0x825F1BE4; continue 'dispatch;
	// 825F1BE0: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 825F1BE4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F1BE8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825F1BEC: 388B0608  addi r4, r11, 0x608
	ctx.r[4].s64 = ctx.r[11].s64 + 1544;
	// 825F1BF0: 48801E19  bl 0x82df3a08
	ctx.lr = 0x825F1BF4;
	sub_82DF3A08(ctx, base);
	// 825F1BF4: 93E10078  stw r31, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[31].u32 ) };
	// 825F1BF8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F1BFC: 3861007C  addi r3, r1, 0x7c
	ctx.r[3].s64 = ctx.r[1].s64 + 124;
	// 825F1C00: 4BFB5BE9  bl 0x825a77e8
	ctx.lr = 0x825F1C04;
	sub_825A77E8(ctx, base);
	// 825F1C04: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825F1C08: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F1C0C: 3861007C  addi r3, r1, 0x7c
	ctx.r[3].s64 = ctx.r[1].s64 + 124;
	// 825F1C10: 4BCCE3F1  bl 0x822c0000
	ctx.lr = 0x825F1C14;
	sub_822C0000(ctx, base);
	// 825F1C14: 38A10078  addi r5, r1, 0x78
	ctx.r[5].s64 = ctx.r[1].s64 + 120;
	// 825F1C18: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825F1C1C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825F1C20: 4BFB04F1  bl 0x825a2110
	ctx.lr = 0x825F1C24;
	sub_825A2110(ctx, base);
	// 825F1C24: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825F1C28: 48801801  bl 0x82df3428
	ctx.lr = 0x825F1C2C;
	sub_82DF3428(ctx, base);
	// 825F1C2C: 572B077B  rlwinm. r11, r25, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825F1C30: 4182000C  beq 0x825f1c3c
	if ctx.cr[0].eq {
	pc = 0x825F1C3C; continue 'dispatch;
	}
	// 825F1C34: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825F1C38: 488017F1  bl 0x82df3428
	ctx.lr = 0x825F1C3C;
	sub_82DF3428(ctx, base);
	// 825F1C3C: 382103A0  addi r1, r1, 0x3a0
	ctx.r[1].s64 = ctx.r[1].s64 + 928;
	// 825F1C40: CBA1FFA0  lfd f29, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 825F1C44: CBC1FFA8  lfd f30, -0x58(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 825F1C48: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 825F1C4C: 48BB655C  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F1C50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825F1C50 size=20
    let mut pc: u32 = 0x825F1C50;
    'dispatch: loop {
        match pc {
            0x825F1C50 => {
    //   block [0x825F1C50..0x825F1C64)
	// 825F1C50: 81640018  lwz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 825F1C54: 8143012C  lwz r10, 0x12c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(300 as u32) ) } as u64;
	// 825F1C58: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F1C5C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825F1C60: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F1C64(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825F1C64 size=8
    let mut pc: u32 = 0x825F1C64;
    'dispatch: loop {
        match pc {
            0x825F1C64 => {
    //   block [0x825F1C64..0x825F1C6C)
	// 825F1C64: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825F1C68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F1C70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825F1C70 size=16
    let mut pc: u32 = 0x825F1C70;
    'dispatch: loop {
        match pc {
            0x825F1C70 => {
    //   block [0x825F1C70..0x825F1C80)
	// 825F1C70: 8164001C  lwz r11, 0x1c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) } as u64;
	// 825F1C74: 8143012C  lwz r10, 0x12c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(300 as u32) ) } as u64;
	// 825F1C78: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825F1C7C: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F1C80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825F1C80 size=12
    let mut pc: u32 = 0x825F1C80;
    'dispatch: loop {
        match pc {
            0x825F1C80 => {
    //   block [0x825F1C80..0x825F1C8C)
	// 825F1C80: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825F1C84: 99640018  stb r11, 0x18(r4)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[4].u32.wrapping_add(24 as u32), ctx.r[11].u8 ) };
	// 825F1C88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F1C90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F1C90 size=136
    let mut pc: u32 = 0x825F1C90;
    'dispatch: loop {
        match pc {
            0x825F1C90 => {
    //   block [0x825F1C90..0x825F1D18)
	// 825F1C90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F1C94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F1C98: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825F1C9C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F1CA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F1CA4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825F1CA8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825F1CAC: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 825F1CB0: 409A0020  bne cr6, 0x825f1cd0
	if !ctx.cr[6].eq {
	pc = 0x825F1CD0; continue 'dispatch;
	}
	// 825F1CB4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825F1CB8: 419A0048  beq cr6, 0x825f1d00
	if ctx.cr[6].eq {
	pc = 0x825F1D00; continue 'dispatch;
	}
	// 825F1CBC: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 825F1CC0: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 825F1CC4: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 825F1CC8: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 825F1CCC: 48000034  b 0x825f1d00
	pc = 0x825F1D00; continue 'dispatch;
	// 825F1CD0: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 825F1CD4: 419A002C  beq cr6, 0x825f1d00
	if ctx.cr[6].eq {
	pc = 0x825F1D00; continue 'dispatch;
	}
	// 825F1CD8: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825F1CDC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F1CE0: 388BECD0  addi r4, r11, -0x1330
	ctx.r[4].s64 = ctx.r[11].s64 + -4912;
	// 825F1CE4: 48BB6415  bl 0x831a80f8
	ctx.lr = 0x825F1CE8;
	sub_831A80F8(ctx, base);
	// 825F1CE8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825F1CEC: 4182000C  beq 0x825f1cf8
	if ctx.cr[0].eq {
	pc = 0x825F1CF8; continue 'dispatch;
	}
	// 825F1CF0: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 825F1CF4: 4800000C  b 0x825f1d00
	pc = 0x825F1D00; continue 'dispatch;
	// 825F1CF8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F1CFC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F1D00: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825F1D04: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F1D08: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F1D0C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825F1D10: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F1D14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F1D18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F1D18 size=84
    let mut pc: u32 = 0x825F1D18;
    'dispatch: loop {
        match pc {
            0x825F1D18 => {
    //   block [0x825F1D18..0x825F1D6C)
	// 825F1D18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F1D1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F1D20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825F1D24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F1D28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F1D2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F1D30: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825F1D34: 4886796D  bl 0x82e596a0
	ctx.lr = 0x825F1D38;
	sub_82E596A0(ctx, base);
	// 825F1D38: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F1D3C: 93DF001C  stw r30, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 825F1D40: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825F1D44: 396B08B0  addi r11, r11, 0x8b0
	ctx.r[11].s64 = ctx.r[11].s64 + 2224;
	// 825F1D48: 995F0018  stb r10, 0x18(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[10].u8 ) };
	// 825F1D4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F1D50: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F1D54: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825F1D58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F1D5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F1D60: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825F1D64: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F1D68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F1D70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F1D70 size=196
    let mut pc: u32 = 0x825F1D70;
    'dispatch: loop {
        match pc {
            0x825F1D70 => {
    //   block [0x825F1D70..0x825F1E34)
	// 825F1D70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F1D74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F1D78: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825F1D7C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F1D80: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F1D84: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825F1D88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F1D8C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825F1D90: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825F1D94: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F1D98: 4BCCEBA1  bl 0x822c0938
	ctx.lr = 0x825F1D9C;
	sub_822C0938(ctx, base);
	// 825F1D9C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F1DA0: 41820028  beq 0x825f1dc8
	if ctx.cr[0].eq {
	pc = 0x825F1DC8; continue 'dispatch;
	}
	// 825F1DA4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F1DA8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825F1DAC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825F1DB0: 392B084C  addi r9, r11, 0x84c
	ctx.r[9].s64 = ctx.r[11].s64 + 2124;
	// 825F1DB4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825F1DB8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825F1DBC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825F1DC0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825F1DC4: 48000008  b 0x825f1dcc
	pc = 0x825F1DCC; continue 'dispatch;
	// 825F1DC8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F1DCC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F1DD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F1DD4: 409A0044  bne cr6, 0x825f1e18
	if !ctx.cr[6].eq {
	pc = 0x825F1E18; continue 'dispatch;
	}
	// 825F1DD8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825F1DDC: 419A001C  beq cr6, 0x825f1df8
	if ctx.cr[6].eq {
	pc = 0x825F1DF8; continue 'dispatch;
	}
	// 825F1DE0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F1DE4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825F1DE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F1DEC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F1DF0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825F1DF4: 4E800421  bctrl
	ctx.lr = 0x825F1DF8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825F1DF8: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825F1DFC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825F1E00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F1E04: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825F1E08: 816BEAC8  lwz r11, -0x1538(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-5432 as u32) ) } as u64;
	// 825F1E0C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825F1E10: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825F1E14: 4BCCE1ED  bl 0x822c0000
	ctx.lr = 0x825F1E18;
	sub_822C0000(ctx, base);
	// 825F1E18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F1E1C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825F1E20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F1E24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F1E28: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825F1E2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F1E30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F1E38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F1E38 size=196
    let mut pc: u32 = 0x825F1E38;
    'dispatch: loop {
        match pc {
            0x825F1E38 => {
    //   block [0x825F1E38..0x825F1EFC)
	// 825F1E38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F1E3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F1E40: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825F1E44: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F1E48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F1E4C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825F1E50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F1E54: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825F1E58: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825F1E5C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F1E60: 4BCCEAD9  bl 0x822c0938
	ctx.lr = 0x825F1E64;
	sub_822C0938(ctx, base);
	// 825F1E64: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F1E68: 41820028  beq 0x825f1e90
	if ctx.cr[0].eq {
	pc = 0x825F1E90; continue 'dispatch;
	}
	// 825F1E6C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F1E70: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825F1E74: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825F1E78: 392B0860  addi r9, r11, 0x860
	ctx.r[9].s64 = ctx.r[11].s64 + 2144;
	// 825F1E7C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825F1E80: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825F1E84: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825F1E88: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825F1E8C: 48000008  b 0x825f1e94
	pc = 0x825F1E94; continue 'dispatch;
	// 825F1E90: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F1E94: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F1E98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F1E9C: 409A0044  bne cr6, 0x825f1ee0
	if !ctx.cr[6].eq {
	pc = 0x825F1EE0; continue 'dispatch;
	}
	// 825F1EA0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825F1EA4: 419A001C  beq cr6, 0x825f1ec0
	if ctx.cr[6].eq {
	pc = 0x825F1EC0; continue 'dispatch;
	}
	// 825F1EA8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F1EAC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825F1EB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F1EB4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F1EB8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825F1EBC: 4E800421  bctrl
	ctx.lr = 0x825F1EC0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825F1EC0: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825F1EC4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825F1EC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F1ECC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825F1ED0: 816BEAC8  lwz r11, -0x1538(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-5432 as u32) ) } as u64;
	// 825F1ED4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825F1ED8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825F1EDC: 4BCCE125  bl 0x822c0000
	ctx.lr = 0x825F1EE0;
	sub_822C0000(ctx, base);
	// 825F1EE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F1EE4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825F1EE8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F1EEC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F1EF0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825F1EF4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F1EF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F1F00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F1F00 size=196
    let mut pc: u32 = 0x825F1F00;
    'dispatch: loop {
        match pc {
            0x825F1F00 => {
    //   block [0x825F1F00..0x825F1FC4)
	// 825F1F00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F1F04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F1F08: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825F1F0C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F1F10: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F1F14: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825F1F18: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F1F1C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825F1F20: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825F1F24: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F1F28: 4BCCEA11  bl 0x822c0938
	ctx.lr = 0x825F1F2C;
	sub_822C0938(ctx, base);
	// 825F1F2C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F1F30: 41820028  beq 0x825f1f58
	if ctx.cr[0].eq {
	pc = 0x825F1F58; continue 'dispatch;
	}
	// 825F1F34: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F1F38: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825F1F3C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825F1F40: 392B0874  addi r9, r11, 0x874
	ctx.r[9].s64 = ctx.r[11].s64 + 2164;
	// 825F1F44: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825F1F48: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825F1F4C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825F1F50: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825F1F54: 48000008  b 0x825f1f5c
	pc = 0x825F1F5C; continue 'dispatch;
	// 825F1F58: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F1F5C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F1F60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F1F64: 409A0044  bne cr6, 0x825f1fa8
	if !ctx.cr[6].eq {
	pc = 0x825F1FA8; continue 'dispatch;
	}
	// 825F1F68: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825F1F6C: 419A001C  beq cr6, 0x825f1f88
	if ctx.cr[6].eq {
	pc = 0x825F1F88; continue 'dispatch;
	}
	// 825F1F70: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F1F74: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825F1F78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F1F7C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F1F80: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825F1F84: 4E800421  bctrl
	ctx.lr = 0x825F1F88;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825F1F88: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825F1F8C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825F1F90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F1F94: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825F1F98: 816BEAC8  lwz r11, -0x1538(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-5432 as u32) ) } as u64;
	// 825F1F9C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825F1FA0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825F1FA4: 4BCCE05D  bl 0x822c0000
	ctx.lr = 0x825F1FA8;
	sub_822C0000(ctx, base);
	// 825F1FA8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F1FAC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825F1FB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F1FB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F1FB8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825F1FBC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F1FC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F1FC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F1FC8 size=196
    let mut pc: u32 = 0x825F1FC8;
    'dispatch: loop {
        match pc {
            0x825F1FC8 => {
    //   block [0x825F1FC8..0x825F208C)
	// 825F1FC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F1FCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F1FD0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825F1FD4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F1FD8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F1FDC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825F1FE0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F1FE4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825F1FE8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825F1FEC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F1FF0: 4BCCE949  bl 0x822c0938
	ctx.lr = 0x825F1FF4;
	sub_822C0938(ctx, base);
	// 825F1FF4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F1FF8: 41820028  beq 0x825f2020
	if ctx.cr[0].eq {
	pc = 0x825F2020; continue 'dispatch;
	}
	// 825F1FFC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F2000: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825F2004: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825F2008: 392B0888  addi r9, r11, 0x888
	ctx.r[9].s64 = ctx.r[11].s64 + 2184;
	// 825F200C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825F2010: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825F2014: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825F2018: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825F201C: 48000008  b 0x825f2024
	pc = 0x825F2024; continue 'dispatch;
	// 825F2020: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F2024: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F2028: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F202C: 409A0044  bne cr6, 0x825f2070
	if !ctx.cr[6].eq {
	pc = 0x825F2070; continue 'dispatch;
	}
	// 825F2030: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825F2034: 419A001C  beq cr6, 0x825f2050
	if ctx.cr[6].eq {
	pc = 0x825F2050; continue 'dispatch;
	}
	// 825F2038: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F203C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825F2040: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F2044: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F2048: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825F204C: 4E800421  bctrl
	ctx.lr = 0x825F2050;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825F2050: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825F2054: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825F2058: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F205C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825F2060: 816BEAC8  lwz r11, -0x1538(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-5432 as u32) ) } as u64;
	// 825F2064: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825F2068: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825F206C: 4BCCDF95  bl 0x822c0000
	ctx.lr = 0x825F2070;
	sub_822C0000(ctx, base);
	// 825F2070: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F2074: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825F2078: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F207C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F2080: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825F2084: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F2088: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F2090(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F2090 size=196
    let mut pc: u32 = 0x825F2090;
    'dispatch: loop {
        match pc {
            0x825F2090 => {
    //   block [0x825F2090..0x825F2154)
	// 825F2090: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F2094: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F2098: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825F209C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F20A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F20A4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825F20A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F20AC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825F20B0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825F20B4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F20B8: 4BCCE881  bl 0x822c0938
	ctx.lr = 0x825F20BC;
	sub_822C0938(ctx, base);
	// 825F20BC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F20C0: 41820028  beq 0x825f20e8
	if ctx.cr[0].eq {
	pc = 0x825F20E8; continue 'dispatch;
	}
	// 825F20C4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F20C8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825F20CC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825F20D0: 392B089C  addi r9, r11, 0x89c
	ctx.r[9].s64 = ctx.r[11].s64 + 2204;
	// 825F20D4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825F20D8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825F20DC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825F20E0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825F20E4: 48000008  b 0x825f20ec
	pc = 0x825F20EC; continue 'dispatch;
	// 825F20E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F20EC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F20F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F20F4: 409A0044  bne cr6, 0x825f2138
	if !ctx.cr[6].eq {
	pc = 0x825F2138; continue 'dispatch;
	}
	// 825F20F8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825F20FC: 419A001C  beq cr6, 0x825f2118
	if ctx.cr[6].eq {
	pc = 0x825F2118; continue 'dispatch;
	}
	// 825F2100: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F2104: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825F2108: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F210C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F2110: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825F2114: 4E800421  bctrl
	ctx.lr = 0x825F2118;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825F2118: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825F211C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825F2120: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F2124: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825F2128: 816BEAC8  lwz r11, -0x1538(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-5432 as u32) ) } as u64;
	// 825F212C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825F2130: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825F2134: 4BCCDECD  bl 0x822c0000
	ctx.lr = 0x825F2138;
	sub_822C0000(ctx, base);
	// 825F2138: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F213C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825F2140: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F2144: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F2148: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825F214C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F2150: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F2158(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F2158 size=72
    let mut pc: u32 = 0x825F2158;
    'dispatch: loop {
        match pc {
            0x825F2158 => {
    //   block [0x825F2158..0x825F21A0)
	// 825F2158: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F215C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F2160: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F2164: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 825F2168: 419A001C  beq cr6, 0x825f2184
	if ctx.cr[6].eq {
	pc = 0x825F2184; continue 'dispatch;
	}
	// 825F216C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825F2170: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825F2174: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 825F2178: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825F217C: 4BFFFB15  bl 0x825f1c90
	ctx.lr = 0x825F2180;
	sub_825F1C90(ctx, base);
	// 825F2180: 48000010  b 0x825f2190
	pc = 0x825F2190; continue 'dispatch;
	// 825F2184: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825F2188: 396BECD0  addi r11, r11, -0x1330
	ctx.r[11].s64 = ctx.r[11].s64 + -4912;
	// 825F218C: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F2190: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825F2194: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F2198: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F219C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F21A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F21A0 size=316
    let mut pc: u32 = 0x825F21A0;
    'dispatch: loop {
        match pc {
            0x825F21A0 => {
    //   block [0x825F21A0..0x825F22DC)
	// 825F21A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F21A4: 48BB5FC5  bl 0x831a8168
	ctx.lr = 0x825F21A8;
	sub_831A8130(ctx, base);
	// 825F21A8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F21AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F21B0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825F21B4: 480A2B85  bl 0x82694d38
	ctx.lr = 0x825F21B8;
	sub_82694D38(ctx, base);
	// 825F21B8: 3FA08329  lis r29, -0x7cd7
	ctx.r[29].s64 = -2094465024;
	// 825F21BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F21C0: 809DEAC0  lwz r4, -0x1540(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-5440 as u32) ) } as u64;
	// 825F21C4: 48801845  bl 0x82df3a08
	ctx.lr = 0x825F21C8;
	sub_82DF3A08(ctx, base);
	// 825F21C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F21CC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825F21D0: 4BF1D161  bl 0x8250f330
	ctx.lr = 0x825F21D4;
	sub_8250F330(ctx, base);
	// 825F21D4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825F21D8: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F21DC: 4BEF771D  bl 0x824e98f8
	ctx.lr = 0x825F21E0;
	sub_824E98F8(ctx, base);
	// 825F21E0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825F21E4: 487FFAAD  bl 0x82df1c90
	ctx.lr = 0x825F21E8;
	sub_82DF1C90(ctx, base);
	// 825F21E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F21EC: 4880123D  bl 0x82df3428
	ctx.lr = 0x825F21F0;
	sub_82DF3428(ctx, base);
	// 825F21F0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825F21F4: 3B9F0028  addi r28, r31, 0x28
	ctx.r[28].s64 = ctx.r[31].s64 + 40;
	// 825F21F8: 409A0008  bne cr6, 0x825f2200
	if !ctx.cr[6].eq {
	pc = 0x825F2200; continue 'dispatch;
	}
	// 825F21FC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825F2200: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F2204: 809DEAC0  lwz r4, -0x1540(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-5440 as u32) ) } as u64;
	// 825F2208: 48801801  bl 0x82df3a08
	ctx.lr = 0x825F220C;
	sub_82DF3A08(ctx, base);
	// 825F220C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 825F2210: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825F2214: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F2218: 4BF165D9  bl 0x825087f0
	ctx.lr = 0x825F221C;
	sub_825087F0(ctx, base);
	// 825F221C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F2220: 48801209  bl 0x82df3428
	ctx.lr = 0x825F2224;
	sub_82DF3428(ctx, base);
	// 825F2224: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 825F2228: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F222C: 808BE268  lwz r4, -0x1d98(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7576 as u32) ) } as u64;
	// 825F2230: 488017D9  bl 0x82df3a08
	ctx.lr = 0x825F2234;
	sub_82DF3A08(ctx, base);
	// 825F2234: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825F2238: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825F223C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F2240: 4BF16541  bl 0x82508780
	ctx.lr = 0x825F2244;
	sub_82508780(ctx, base);
	// 825F2244: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F2248: 488011E1  bl 0x82df3428
	ctx.lr = 0x825F224C;
	sub_82DF3428(ctx, base);
	// 825F224C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F2250: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F2254: 388B08C0  addi r4, r11, 0x8c0
	ctx.r[4].s64 = ctx.r[11].s64 + 2240;
	// 825F2258: 38A0006C  li r5, 0x6c
	ctx.r[5].s64 = 108;
	// 825F225C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825F2260: 48800189  bl 0x82df23e8
	ctx.lr = 0x825F2264;
	sub_82DF23E8(ctx, base);
	// 825F2264: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 825F2268: 41820020  beq 0x825f2288
	if ctx.cr[0].eq {
	pc = 0x825F2288; continue 'dispatch;
	}
	// 825F226C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F2270: 4881FC69  bl 0x82e11ed8
	ctx.lr = 0x825F2274;
	sub_82E11ED8(ctx, base);
	// 825F2274: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F2278: 93FE0008  stw r31, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 825F227C: 396B083C  addi r11, r11, 0x83c
	ctx.r[11].s64 = ctx.r[11].s64 + 2108;
	// 825F2280: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F2284: 48000008  b 0x825f228c
	pc = 0x825F228C; continue 'dispatch;
	// 825F2288: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825F228C: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 825F2290: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825F2294: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825F2298: 4BFFFBA1  bl 0x825f1e38
	ctx.lr = 0x825F229C;
	sub_825F1E38(ctx, base);
	// 825F229C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825F22A0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825F22A4: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825F22A8: 4BCCDD59  bl 0x822c0000
	ctx.lr = 0x825F22AC;
	sub_822C0000(ctx, base);
	// 825F22AC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825F22B0: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 825F22B4: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825F22B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F22BC: 808B7084  lwz r4, 0x7084(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28804 as u32) ) } as u64;
	// 825F22C0: 4BF1E739  bl 0x825109f8
	ctx.lr = 0x825F22C4;
	sub_825109F8(ctx, base);
	// 825F22C4: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825F22C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F22CC: 419A0008  beq cr6, 0x825f22d4
	if ctx.cr[6].eq {
	pc = 0x825F22D4; continue 'dispatch;
	}
	// 825F22D0: 4BCCE5C1  bl 0x822c0890
	ctx.lr = 0x825F22D4;
	sub_822C0890(ctx, base);
	// 825F22D4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825F22D8: 48BB5EE0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F22E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F22E0 size=136
    let mut pc: u32 = 0x825F22E0;
    'dispatch: loop {
        match pc {
            0x825F22E0 => {
    //   block [0x825F22E0..0x825F2368)
	// 825F22E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F22E4: 48BB5E89  bl 0x831a816c
	ctx.lr = 0x825F22E8;
	sub_831A8130(ctx, base);
	// 825F22E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F22EC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825F22F0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825F22F4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825F22F8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F22FC: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 825F2300: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 825F2304: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 825F2308: 488000E1  bl 0x82df23e8
	ctx.lr = 0x825F230C;
	sub_82DF23E8(ctx, base);
	// 825F230C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825F2310: 41820024  beq 0x825f2334
	if ctx.cr[0].eq {
	pc = 0x825F2334; continue 'dispatch;
	}
	// 825F2314: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F2318: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F231C: 48867385  bl 0x82e596a0
	ctx.lr = 0x825F2320;
	sub_82E596A0(ctx, base);
	// 825F2320: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F2324: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 825F2328: 396B08B8  addi r11, r11, 0x8b8
	ctx.r[11].s64 = ctx.r[11].s64 + 2232;
	// 825F232C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F2330: 48000008  b 0x825f2338
	pc = 0x825F2338; continue 'dispatch;
	// 825F2334: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825F2338: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825F233C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 825F2340: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F2344: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F2348: 4BFFFBB9  bl 0x825f1f00
	ctx.lr = 0x825F234C;
	sub_825F1F00(ctx, base);
	// 825F234C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825F2350: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F2354: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F2358: 4BCCDCA9  bl 0x822c0000
	ctx.lr = 0x825F235C;
	sub_822C0000(ctx, base);
	// 825F235C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825F2360: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825F2364: 48BB5E58  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F2368(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F2368 size=120
    let mut pc: u32 = 0x825F2368;
    'dispatch: loop {
        match pc {
            0x825F2368 => {
    //   block [0x825F2368..0x825F23E0)
	// 825F2368: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F236C: 48BB5E01  bl 0x831a816c
	ctx.lr = 0x825F2370;
	sub_831A8130(ctx, base);
	// 825F2370: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F2374: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825F2378: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825F237C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825F2380: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F2384: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 825F2388: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 825F238C: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 825F2390: 48800059  bl 0x82df23e8
	ctx.lr = 0x825F2394;
	sub_82DF23E8(ctx, base);
	// 825F2394: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F2398: 41820014  beq 0x825f23ac
	if ctx.cr[0].eq {
	pc = 0x825F23AC; continue 'dispatch;
	}
	// 825F239C: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F23A0: 4BFFF979  bl 0x825f1d18
	ctx.lr = 0x825F23A4;
	sub_825F1D18(ctx, base);
	// 825F23A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F23A8: 48000008  b 0x825f23b0
	pc = 0x825F23B0; continue 'dispatch;
	// 825F23AC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825F23B0: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825F23B4: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 825F23B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F23BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F23C0: 4BFFFC09  bl 0x825f1fc8
	ctx.lr = 0x825F23C4;
	sub_825F1FC8(ctx, base);
	// 825F23C4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825F23C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F23CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F23D0: 4BCCDC31  bl 0x822c0000
	ctx.lr = 0x825F23D4;
	sub_822C0000(ctx, base);
	// 825F23D4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825F23D8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825F23DC: 48BB5DE0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F23E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F23E0 size=120
    let mut pc: u32 = 0x825F23E0;
    'dispatch: loop {
        match pc {
            0x825F23E0 => {
    //   block [0x825F23E0..0x825F2458)
	// 825F23E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F23E4: 48BB5D89  bl 0x831a816c
	ctx.lr = 0x825F23E8;
	sub_831A8130(ctx, base);
	// 825F23E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F23EC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825F23F0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825F23F4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825F23F8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F23FC: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 825F2400: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 825F2404: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 825F2408: 487FFFE1  bl 0x82df23e8
	ctx.lr = 0x825F240C;
	sub_82DF23E8(ctx, base);
	// 825F240C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F2410: 41820014  beq 0x825f2424
	if ctx.cr[0].eq {
	pc = 0x825F2424; continue 'dispatch;
	}
	// 825F2414: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F2418: 4855EE11  bl 0x82b51228
	ctx.lr = 0x825F241C;
	sub_82B51228(ctx, base);
	// 825F241C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F2420: 48000008  b 0x825f2428
	pc = 0x825F2428; continue 'dispatch;
	// 825F2424: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825F2428: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825F242C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 825F2430: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F2434: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F2438: 4BFFFC59  bl 0x825f2090
	ctx.lr = 0x825F243C;
	sub_825F2090(ctx, base);
	// 825F243C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825F2440: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F2444: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F2448: 4BCCDBB9  bl 0x822c0000
	ctx.lr = 0x825F244C;
	sub_822C0000(ctx, base);
	// 825F244C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825F2450: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825F2454: 48BB5D68  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F2458(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F2458 size=228
    let mut pc: u32 = 0x825F2458;
    'dispatch: loop {
        match pc {
            0x825F2458 => {
    //   block [0x825F2458..0x825F253C)
	// 825F2458: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F245C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F2460: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F2464: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F2468: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F246C: 817F012C  lwz r11, 0x12c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(300 as u32) ) } as u64;
	// 825F2470: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F2474: 409A00B4  bne cr6, 0x825f2528
	if !ctx.cr[6].eq {
	pc = 0x825F2528; continue 'dispatch;
	}
	// 825F2478: 39410054  addi r10, r1, 0x54
	ctx.r[10].s64 = ctx.r[1].s64 + 84;
	// 825F247C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825F2480: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825F2484: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 825F2488: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825F248C: 4BFFFE55  bl 0x825f22e0
	ctx.lr = 0x825F2490;
	sub_825F22E0(ctx, base);
	// 825F2490: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F2494: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825F2498: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825F249C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F24A0: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 825F24A4: 419A0024  beq cr6, 0x825f24c8
	if ctx.cr[6].eq {
	pc = 0x825F24C8; continue 'dispatch;
	}
	// 825F24A8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825F24AC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825F24B0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F24B4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825F24B8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825F24BC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825F24C0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F24C4: 4082FFE8  bne 0x825f24ac
	if !ctx.cr[0].eq {
	pc = 0x825F24AC; continue 'dispatch;
	}
	// 825F24C8: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825F24CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F24D0: 808BEAC0  lwz r4, -0x1540(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-5440 as u32) ) } as u64;
	// 825F24D4: 48801535  bl 0x82df3a08
	ctx.lr = 0x825F24D8;
	sub_82DF3A08(ctx, base);
	// 825F24D8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F24DC: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 825F24E0: 388B08C0  addi r4, r11, 0x8c0
	ctx.r[4].s64 = ctx.r[11].s64 + 2240;
	// 825F24E4: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 825F24E8: 38A0008A  li r5, 0x8a
	ctx.r[5].s64 = 138;
	// 825F24EC: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 825F24F0: 48866C31  bl 0x82e59120
	ctx.lr = 0x825F24F4;
	sub_82E59120(ctx, base);
	// 825F24F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F24F8: 48800F31  bl 0x82df3428
	ctx.lr = 0x825F24FC;
	sub_82DF3428(ctx, base);
	// 825F24FC: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825F2500: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F2504: 419A0008  beq cr6, 0x825f250c
	if ctx.cr[6].eq {
	pc = 0x825F250C; continue 'dispatch;
	}
	// 825F2508: 4BCCE389  bl 0x822c0890
	ctx.lr = 0x825F250C;
	sub_822C0890(ctx, base);
	// 825F250C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 825F2510: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F2514: 419A0008  beq cr6, 0x825f251c
	if ctx.cr[6].eq {
	pc = 0x825F251C; continue 'dispatch;
	}
	// 825F2518: 4BCCE379  bl 0x822c0890
	ctx.lr = 0x825F251C;
	sub_822C0890(ctx, base);
	// 825F251C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825F2520: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825F2524: 917F012C  stw r11, 0x12c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(300 as u32), ctx.r[11].u32 ) };
	// 825F2528: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825F252C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F2530: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F2534: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F2538: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F2540(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F2540 size=372
    let mut pc: u32 = 0x825F2540;
    'dispatch: loop {
        match pc {
            0x825F2540 => {
    //   block [0x825F2540..0x825F26B4)
	// 825F2540: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F2544: 48BB5C1D  bl 0x831a8160
	ctx.lr = 0x825F2548;
	sub_831A8130(ctx, base);
	// 825F2548: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F254C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F2550: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825F2554: 3B7F0044  addi r27, r31, 0x44
	ctx.r[27].s64 = ctx.r[31].s64 + 68;
	// 825F2558: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825F255C: 4BFFFE0D  bl 0x825f2368
	ctx.lr = 0x825F2560;
	sub_825F2368(ctx, base);
	// 825F2560: 8341005C  lwz r26, 0x5c(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825F2564: 83810058  lwz r28, 0x58(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825F2568: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 825F256C: 93410064  stw r26, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[26].u32 ) };
	// 825F2570: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 825F2574: 419A0024  beq cr6, 0x825f2598
	if ctx.cr[6].eq {
	pc = 0x825F2598; continue 'dispatch;
	}
	// 825F2578: 397A0004  addi r11, r26, 4
	ctx.r[11].s64 = ctx.r[26].s64 + 4;
	// 825F257C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825F2580: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F2584: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825F2588: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825F258C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825F2590: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F2594: 4082FFE8  bne 0x825f257c
	if !ctx.cr[0].eq {
	pc = 0x825F257C; continue 'dispatch;
	}
	// 825F2598: 3FA08329  lis r29, -0x7cd7
	ctx.r[29].s64 = -2094465024;
	// 825F259C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F25A0: 809DEAC0  lwz r4, -0x1540(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-5440 as u32) ) } as u64;
	// 825F25A4: 48801465  bl 0x82df3a08
	ctx.lr = 0x825F25A8;
	sub_82DF3A08(ctx, base);
	// 825F25A8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F25AC: 3BFFFF40  addi r31, r31, -0xc0
	ctx.r[31].s64 = ctx.r[31].s64 + -192;
	// 825F25B0: 3BCB08C0  addi r30, r11, 0x8c0
	ctx.r[30].s64 = ctx.r[11].s64 + 2240;
	// 825F25B4: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 825F25B8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825F25BC: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 825F25C0: 38A0009A  li r5, 0x9a
	ctx.r[5].s64 = 154;
	// 825F25C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F25C8: 48866B59  bl 0x82e59120
	ctx.lr = 0x825F25CC;
	sub_82E59120(ctx, base);
	// 825F25CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F25D0: 48800E59  bl 0x82df3428
	ctx.lr = 0x825F25D4;
	sub_82DF3428(ctx, base);
	// 825F25D4: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825F25D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F25DC: 419A0008  beq cr6, 0x825f25e4
	if ctx.cr[6].eq {
	pc = 0x825F25E4; continue 'dispatch;
	}
	// 825F25E0: 4BCCE2B1  bl 0x822c0890
	ctx.lr = 0x825F25E4;
	sub_822C0890(ctx, base);
	// 825F25E4: 897C0018  lbz r11, 0x18(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 825F25E8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F25EC: 418200B0  beq 0x825f269c
	if ctx.cr[0].eq {
	pc = 0x825F269C; continue 'dispatch;
	}
	// 825F25F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F25F4: 39410054  addi r10, r1, 0x54
	ctx.r[10].s64 = ctx.r[1].s64 + 84;
	// 825F25F8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825F25FC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825F2600: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 825F2604: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825F2608: 4BFFFCD9  bl 0x825f22e0
	ctx.lr = 0x825F260C;
	sub_825F22E0(ctx, base);
	// 825F260C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F2610: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 825F2614: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825F2618: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F261C: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 825F2620: 419A0024  beq cr6, 0x825f2644
	if ctx.cr[6].eq {
	pc = 0x825F2644; continue 'dispatch;
	}
	// 825F2624: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825F2628: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825F262C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F2630: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825F2634: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825F2638: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825F263C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F2640: 4082FFE8  bne 0x825f2628
	if !ctx.cr[0].eq {
	pc = 0x825F2628; continue 'dispatch;
	}
	// 825F2644: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F2648: 809DEAC0  lwz r4, -0x1540(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-5440 as u32) ) } as u64;
	// 825F264C: 488013BD  bl 0x82df3a08
	ctx.lr = 0x825F2650;
	sub_82DF3A08(ctx, base);
	// 825F2650: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825F2654: 38E10068  addi r7, r1, 0x68
	ctx.r[7].s64 = ctx.r[1].s64 + 104;
	// 825F2658: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 825F265C: 38A0009E  li r5, 0x9e
	ctx.r[5].s64 = 158;
	// 825F2660: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F2664: 48866ABD  bl 0x82e59120
	ctx.lr = 0x825F2668;
	sub_82E59120(ctx, base);
	// 825F2668: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F266C: 48800DBD  bl 0x82df3428
	ctx.lr = 0x825F2670;
	sub_82DF3428(ctx, base);
	// 825F2670: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 825F2674: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F2678: 419A0008  beq cr6, 0x825f2680
	if ctx.cr[6].eq {
	pc = 0x825F2680; continue 'dispatch;
	}
	// 825F267C: 4BCCE215  bl 0x822c0890
	ctx.lr = 0x825F2680;
	sub_822C0890(ctx, base);
	// 825F2680: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825F2684: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F2688: 419A0008  beq cr6, 0x825f2690
	if ctx.cr[6].eq {
	pc = 0x825F2690; continue 'dispatch;
	}
	// 825F268C: 4BCCE205  bl 0x822c0890
	ctx.lr = 0x825F2690;
	sub_822C0890(ctx, base);
	// 825F2690: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825F2694: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825F2698: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F269C: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 825F26A0: 419A000C  beq cr6, 0x825f26ac
	if ctx.cr[6].eq {
	pc = 0x825F26AC; continue 'dispatch;
	}
	// 825F26A4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825F26A8: 4BCCE1E9  bl 0x822c0890
	ctx.lr = 0x825F26AC;
	sub_822C0890(ctx, base);
	// 825F26AC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825F26B0: 48BB5B00  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F26B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825F26B8 size=324
    let mut pc: u32 = 0x825F26B8;
    'dispatch: loop {
        match pc {
            0x825F26B8 => {
    //   block [0x825F26B8..0x825F27FC)
	// 825F26B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F26BC: 48BB5AB1  bl 0x831a816c
	ctx.lr = 0x825F26C0;
	sub_831A8130(ctx, base);
	// 825F26C0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F26C4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F26C8: 908100AC  stw r4, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[4].u32 ) };
	// 825F26CC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825F26D0: 3BAB08C0  addi r29, r11, 0x8c0
	ctx.r[29].s64 = ctx.r[11].s64 + 2240;
	// 825F26D4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F26D8: 38A000C9  li r5, 0xc9
	ctx.r[5].s64 = 201;
	// 825F26DC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825F26E0: 386001C0  li r3, 0x1c0
	ctx.r[3].s64 = 448;
	// 825F26E4: 487FFD05  bl 0x82df23e8
	ctx.lr = 0x825F26E8;
	sub_82DF23E8(ctx, base);
	// 825F26E8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F26EC: 41820018  beq 0x825f2704
	if ctx.cr[0].eq {
	pc = 0x825F2704; continue 'dispatch;
	}
	// 825F26F0: 389E0140  addi r4, r30, 0x140
	ctx.r[4].s64 = ctx.r[30].s64 + 320;
	// 825F26F4: 80BE012C  lwz r5, 0x12c(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(300 as u32) ) } as u64;
	// 825F26F8: 4BE7FB31  bl 0x82472228
	ctx.lr = 0x825F26FC;
	sub_82472228(ctx, base);
	// 825F26FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F2700: 48000008  b 0x825f2708
	pc = 0x825F2708; continue 'dispatch;
	// 825F2704: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825F2708: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825F270C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F2710: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F2714: 4BE72BED  bl 0x82465300
	ctx.lr = 0x825F2718;
	sub_82465300(ctx, base);
	// 825F2718: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825F271C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F2720: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F2724: 4BCCD8DD  bl 0x822c0000
	ctx.lr = 0x825F2728;
	sub_822C0000(ctx, base);
	// 825F2728: 38C100AC  addi r6, r1, 0xac
	ctx.r[6].s64 = ctx.r[1].s64 + 172;
	// 825F272C: 38BE0130  addi r5, r30, 0x130
	ctx.r[5].s64 = ctx.r[30].s64 + 304;
	// 825F2730: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825F2734: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825F2738: 48077021  bl 0x82669758
	ctx.lr = 0x825F273C;
	sub_82669758(ctx, base);
	// 825F273C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F2740: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825F2744: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825F2748: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F274C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825F2750: 419A0024  beq cr6, 0x825f2774
	if ctx.cr[6].eq {
	pc = 0x825F2774; continue 'dispatch;
	}
	// 825F2754: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825F2758: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825F275C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F2760: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825F2764: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825F2768: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825F276C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F2770: 4082FFE8  bne 0x825f2758
	if !ctx.cr[0].eq {
	pc = 0x825F2758; continue 'dispatch;
	}
	// 825F2774: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825F2778: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825F277C: 4BF1CD9D  bl 0x8250f518
	ctx.lr = 0x825F2780;
	sub_8250F518(ctx, base);
	// 825F2780: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F2784: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F2788: 386BFF6C  addi r3, r11, -0x94
	ctx.r[3].s64 = ctx.r[11].s64 + -148;
	// 825F278C: 409A0008  bne cr6, 0x825f2794
	if !ctx.cr[6].eq {
	pc = 0x825F2794; continue 'dispatch;
	}
	// 825F2790: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825F2794: 3BE10058  addi r31, r1, 0x58
	ctx.r[31].s64 = ctx.r[1].s64 + 88;
	// 825F2798: 4BF358B9  bl 0x82528050
	ctx.lr = 0x825F279C;
	sub_82528050(ctx, base);
	// 825F279C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825F27A0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 825F27A4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825F27A8: 38A000CC  li r5, 0xcc
	ctx.r[5].s64 = 204;
	// 825F27AC: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 825F27B0: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 825F27B4: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825F27B8: 48866289  bl 0x82e58a40
	ctx.lr = 0x825F27BC;
	sub_82E58A40(ctx, base);
	// 825F27BC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825F27C0: 487FF4D1  bl 0x82df1c90
	ctx.lr = 0x825F27C4;
	sub_82DF1C90(ctx, base);
	// 825F27C4: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825F27C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F27CC: 419A0008  beq cr6, 0x825f27d4
	if ctx.cr[6].eq {
	pc = 0x825F27D4; continue 'dispatch;
	}
	// 825F27D0: 4BCCE0C1  bl 0x822c0890
	ctx.lr = 0x825F27D4;
	sub_822C0890(ctx, base);
	// 825F27D4: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 825F27D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F27DC: 419A0008  beq cr6, 0x825f27e4
	if ctx.cr[6].eq {
	pc = 0x825F27E4; continue 'dispatch;
	}
	// 825F27E0: 4BCCE0B1  bl 0x822c0890
	ctx.lr = 0x825F27E4;
	sub_822C0890(ctx, base);
	// 825F27E4: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825F27E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F27EC: 419A0008  beq cr6, 0x825f27f4
	if ctx.cr[6].eq {
	pc = 0x825F27F4; continue 'dispatch;
	}
	// 825F27F0: 4BCCE0A1  bl 0x822c0890
	ctx.lr = 0x825F27F4;
	sub_822C0890(ctx, base);
	// 825F27F4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825F27F8: 48BB59C4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F2800(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825F2800 size=232
    let mut pc: u32 = 0x825F2800;
    'dispatch: loop {
        match pc {
            0x825F2800 => {
    //   block [0x825F2800..0x825F28E8)
	// 825F2800: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F2804: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F2808: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825F280C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F2810: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F2814: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F2818: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825F281C: 389F0130  addi r4, r31, 0x130
	ctx.r[4].s64 = ctx.r[31].s64 + 304;
	// 825F2820: 4BFBFC49  bl 0x825b2468
	ctx.lr = 0x825F2824;
	sub_825B2468(ctx, base);
	// 825F2824: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F2828: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825F282C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825F2830: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F2834: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825F2838: 419A0024  beq cr6, 0x825f285c
	if ctx.cr[6].eq {
	pc = 0x825F285C; continue 'dispatch;
	}
	// 825F283C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825F2840: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825F2844: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F2848: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825F284C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825F2850: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825F2854: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F2858: 4082FFE8  bne 0x825f2840
	if !ctx.cr[0].eq {
	pc = 0x825F2840; continue 'dispatch;
	}
	// 825F285C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F2860: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825F2864: 4BF1CCB5  bl 0x8250f518
	ctx.lr = 0x825F2868;
	sub_8250F518(ctx, base);
	// 825F2868: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F286C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F2870: 386BFF6C  addi r3, r11, -0x94
	ctx.r[3].s64 = ctx.r[11].s64 + -148;
	// 825F2874: 409A0008  bne cr6, 0x825f287c
	if !ctx.cr[6].eq {
	pc = 0x825F287C; continue 'dispatch;
	}
	// 825F2878: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825F287C: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 825F2880: 4BF357D1  bl 0x82528050
	ctx.lr = 0x825F2884;
	sub_82528050(ctx, base);
	// 825F2884: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825F2888: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825F288C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 825F2890: 388A08C0  addi r4, r10, 0x8c0
	ctx.r[4].s64 = ctx.r[10].s64 + 2240;
	// 825F2894: 38A000D9  li r5, 0xd9
	ctx.r[5].s64 = 217;
	// 825F2898: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 825F289C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825F28A0: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 825F28A4: 4886619D  bl 0x82e58a40
	ctx.lr = 0x825F28A8;
	sub_82E58A40(ctx, base);
	// 825F28A8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825F28AC: 487FF3E5  bl 0x82df1c90
	ctx.lr = 0x825F28B0;
	sub_82DF1C90(ctx, base);
	// 825F28B0: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825F28B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F28B8: 419A0008  beq cr6, 0x825f28c0
	if ctx.cr[6].eq {
	pc = 0x825F28C0; continue 'dispatch;
	}
	// 825F28BC: 4BCCDFD5  bl 0x822c0890
	ctx.lr = 0x825F28C0;
	sub_822C0890(ctx, base);
	// 825F28C0: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825F28C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F28C8: 419A0008  beq cr6, 0x825f28d0
	if ctx.cr[6].eq {
	pc = 0x825F28D0; continue 'dispatch;
	}
	// 825F28CC: 4BCCDFC5  bl 0x822c0890
	ctx.lr = 0x825F28D0;
	sub_822C0890(ctx, base);
	// 825F28D0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825F28D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F28D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F28DC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825F28E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F28E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F28E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825F28E8 size=16
    let mut pc: u32 = 0x825F28E8;
    'dispatch: loop {
        match pc {
            0x825F28E8 => {
    //   block [0x825F28E8..0x825F28F8)
	// 825F28E8: 81640018  lwz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 825F28EC: 8143012C  lwz r10, 0x12c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(300 as u32) ) } as u64;
	// 825F28F0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825F28F4: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F28F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825F28F8 size=8
    let mut pc: u32 = 0x825F28F8;
    'dispatch: loop {
        match pc {
            0x825F28F8 => {
    //   block [0x825F28F8..0x825F2900)
	// 825F28F8: 388003EA  li r4, 0x3ea
	ctx.r[4].s64 = 1002;
	// 825F28FC: 4BFFFDBC  b 0x825f26b8
	sub_825F26B8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F2900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825F2900 size=4
    let mut pc: u32 = 0x825F2900;
    'dispatch: loop {
        match pc {
            0x825F2900 => {
    //   block [0x825F2900..0x825F2904)
	// 825F2900: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F2908(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825F2908 size=16
    let mut pc: u32 = 0x825F2908;
    'dispatch: loop {
        match pc {
            0x825F2908 => {
    //   block [0x825F2908..0x825F2918)
	// 825F2908: 81640018  lwz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 825F290C: 8143012C  lwz r10, 0x12c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(300 as u32) ) } as u64;
	// 825F2910: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825F2914: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F2918(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825F2918 size=8
    let mut pc: u32 = 0x825F2918;
    'dispatch: loop {
        match pc {
            0x825F2918 => {
    //   block [0x825F2918..0x825F2920)
	// 825F2918: 4BFFFEE8  b 0x825f2800
	sub_825F2800(ctx, base);
	return;
	// 825F291C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F2920(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825F2920 size=12
    let mut pc: u32 = 0x825F2920;
    'dispatch: loop {
        match pc {
            0x825F2920 => {
    //   block [0x825F2920..0x825F292C)
	// 825F2920: 89630088  lbz r11, 0x88(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(136 as u32) ) } as u64;
	// 825F2924: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F2928: 4D820020  beqlr
	if ctx.cr[0].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F292C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825F292C size=12
    let mut pc: u32 = 0x825F292C;
    'dispatch: loop {
        match pc {
            0x825F292C => {
    //   block [0x825F292C..0x825F2938)
	// 825F292C: 38800BBA  li r4, 0xbba
	ctx.r[4].s64 = 3002;
	// 825F2930: 3863FF18  addi r3, r3, -0xe8
	ctx.r[3].s64 = ctx.r[3].s64 + -232;
	// 825F2934: 4BFFFD84  b 0x825f26b8
	sub_825F26B8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F2938(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825F2938 size=4
    let mut pc: u32 = 0x825F2938;
    'dispatch: loop {
        match pc {
            0x825F2938 => {
    //   block [0x825F2938..0x825F293C)
	// 825F2938: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F2940(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825F2940 size=12
    let mut pc: u32 = 0x825F2940;
    'dispatch: loop {
        match pc {
            0x825F2940 => {
    //   block [0x825F2940..0x825F294C)
	// 825F2940: 89630088  lbz r11, 0x88(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(136 as u32) ) } as u64;
	// 825F2944: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F2948: 4D820020  beqlr
	if ctx.cr[0].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F294C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825F294C size=8
    let mut pc: u32 = 0x825F294C;
    'dispatch: loop {
        match pc {
            0x825F294C => {
    //   block [0x825F294C..0x825F2954)
	// 825F294C: 3863FF18  addi r3, r3, -0xe8
	ctx.r[3].s64 = ctx.r[3].s64 + -232;
	// 825F2950: 4BFFFEB0  b 0x825f2800
	sub_825F2800(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F2954(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825F2954 size=4
    let mut pc: u32 = 0x825F2954;
    'dispatch: loop {
        match pc {
            0x825F2954 => {
    //   block [0x825F2954..0x825F2958)
	// 825F2954: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F2958(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825F2958 size=480
    let mut pc: u32 = 0x825F2958;
    'dispatch: loop {
        match pc {
            0x825F2958 => {
    //   block [0x825F2958..0x825F2B38)
	// 825F2958: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F295C: 48BB5805  bl 0x831a8160
	ctx.lr = 0x825F2960;
	sub_831A8130(ctx, base);
	// 825F2960: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F2964: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825F2968: 4BCCD699  bl 0x822c0000
	ctx.lr = 0x825F296C;
	sub_822C0000(ctx, base);
	// 825F296C: 897C0088  lbz r11, 0x88(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(136 as u32) ) } as u64;
	// 825F2970: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F2974: 418201BC  beq 0x825f2b30
	if ctx.cr[0].eq {
	pc = 0x825F2B30; continue 'dispatch;
	}
	// 825F2978: 3B7C0058  addi r27, r28, 0x58
	ctx.r[27].s64 = ctx.r[28].s64 + 88;
	// 825F297C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825F2980: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825F2984: 4BFFFA5D  bl 0x825f23e0
	ctx.lr = 0x825F2988;
	sub_825F23E0(ctx, base);
	// 825F2988: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F298C: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 825F2990: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825F2994: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F2998: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 825F299C: 419A0024  beq cr6, 0x825f29c0
	if ctx.cr[6].eq {
	pc = 0x825F29C0; continue 'dispatch;
	}
	// 825F29A0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825F29A4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825F29A8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F29AC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825F29B0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825F29B4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825F29B8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F29BC: 4082FFE8  bne 0x825f29a4
	if !ctx.cr[0].eq {
	pc = 0x825F29A4; continue 'dispatch;
	}
	// 825F29C0: 3BFCFF18  addi r31, r28, -0xe8
	ctx.r[31].s64 = ctx.r[28].s64 + -232;
	// 825F29C4: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825F29C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F29CC: 4BF1CB4D  bl 0x8250f518
	ctx.lr = 0x825F29D0;
	sub_8250F518(ctx, base);
	// 825F29D0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F29D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F29D8: 386BFF6C  addi r3, r11, -0x94
	ctx.r[3].s64 = ctx.r[11].s64 + -148;
	// 825F29DC: 409A0008  bne cr6, 0x825f29e4
	if !ctx.cr[6].eq {
	pc = 0x825F29E4; continue 'dispatch;
	}
	// 825F29E0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825F29E4: 3BDCFF40  addi r30, r28, -0xc0
	ctx.r[30].s64 = ctx.r[28].s64 + -192;
	// 825F29E8: 3B410068  addi r26, r1, 0x68
	ctx.r[26].s64 = ctx.r[1].s64 + 104;
	// 825F29EC: 4BF35665  bl 0x82528050
	ctx.lr = 0x825F29F0;
	sub_82528050(ctx, base);
	// 825F29F0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F29F4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825F29F8: 3BAB08C0  addi r29, r11, 0x8c0
	ctx.r[29].s64 = ctx.r[11].s64 + 2240;
	// 825F29FC: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 825F2A00: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825F2A04: 38A00120  li r5, 0x120
	ctx.r[5].s64 = 288;
	// 825F2A08: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F2A0C: C02A08A4  lfs f1, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825F2A10: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 825F2A14: 4886602D  bl 0x82e58a40
	ctx.lr = 0x825F2A18;
	sub_82E58A40(ctx, base);
	// 825F2A18: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825F2A1C: 487FF275  bl 0x82df1c90
	ctx.lr = 0x825F2A20;
	sub_82DF1C90(ctx, base);
	// 825F2A20: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 825F2A24: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F2A28: 419A0008  beq cr6, 0x825f2a30
	if ctx.cr[6].eq {
	pc = 0x825F2A30; continue 'dispatch;
	}
	// 825F2A2C: 4BCCDE65  bl 0x822c0890
	ctx.lr = 0x825F2A30;
	sub_822C0890(ctx, base);
	// 825F2A30: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 825F2A34: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F2A38: 419A0008  beq cr6, 0x825f2a40
	if ctx.cr[6].eq {
	pc = 0x825F2A40; continue 'dispatch;
	}
	// 825F2A3C: 4BCCDE55  bl 0x822c0890
	ctx.lr = 0x825F2A40;
	sub_822C0890(ctx, base);
	// 825F2A40: 897B0000  lbz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F2A44: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F2A48: 418200E8  beq 0x825f2b30
	if ctx.cr[0].eq {
	pc = 0x825F2B30; continue 'dispatch;
	}
	// 825F2A4C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F2A50: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 825F2A54: 4BF1CA75  bl 0x8250f4c8
	ctx.lr = 0x825F2A58;
	sub_8250F4C8(ctx, base);
	// 825F2A58: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F2A5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F2A60: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 825F2A64: 409A0008  bne cr6, 0x825f2a6c
	if !ctx.cr[6].eq {
	pc = 0x825F2A6C; continue 'dispatch;
	}
	// 825F2A68: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825F2A6C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825F2A70: 4BF15FA9  bl 0x82508a18
	ctx.lr = 0x825F2A74;
	sub_82508A18(ctx, base);
	// 825F2A74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F2A78: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 825F2A7C: 487FF215  bl 0x82df1c90
	ctx.lr = 0x825F2A80;
	sub_82DF1C90(ctx, base);
	// 825F2A80: 396100A0  addi r11, r1, 0xa0
	ctx.r[11].s64 = ctx.r[1].s64 + 160;
	// 825F2A84: 394100B0  addi r10, r1, 0xb0
	ctx.r[10].s64 = ctx.r[1].s64 + 176;
	// 825F2A88: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825F2A8C: 392100C0  addi r9, r1, 0xc0
	ctx.r[9].s64 = ctx.r[1].s64 + 192;
	// 825F2A90: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 825F2A94: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825F2A98: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 825F2A9C: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 825F2AA0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825F2AA4: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 825F2AA8: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825F2AAC: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 825F2AB0: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825F2AB4: 4BE7F32D  bl 0x82471de0
	ctx.lr = 0x825F2AB8;
	sub_82471DE0(ctx, base);
	// 825F2AB8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F2ABC: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 825F2AC0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825F2AC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F2AC8: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 825F2ACC: 419A0024  beq cr6, 0x825f2af0
	if ctx.cr[6].eq {
	pc = 0x825F2AF0; continue 'dispatch;
	}
	// 825F2AD0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825F2AD4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825F2AD8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F2ADC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825F2AE0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825F2AE4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825F2AE8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F2AEC: 4082FFE8  bne 0x825f2ad4
	if !ctx.cr[0].eq {
	pc = 0x825F2AD4; continue 'dispatch;
	}
	// 825F2AF0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825F2AF4: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 825F2AF8: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 825F2AFC: 38A00126  li r5, 0x126
	ctx.r[5].s64 = 294;
	// 825F2B00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F2B04: 488644E5  bl 0x82e56fe8
	ctx.lr = 0x825F2B08;
	sub_82E56FE8(ctx, base);
	// 825F2B08: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825F2B0C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F2B10: 419A0008  beq cr6, 0x825f2b18
	if ctx.cr[6].eq {
	pc = 0x825F2B18; continue 'dispatch;
	}
	// 825F2B14: 4BCCDD7D  bl 0x822c0890
	ctx.lr = 0x825F2B18;
	sub_822C0890(ctx, base);
	// 825F2B18: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 825F2B1C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F2B20: 419A0008  beq cr6, 0x825f2b28
	if ctx.cr[6].eq {
	pc = 0x825F2B28; continue 'dispatch;
	}
	// 825F2B24: 4BCCDD6D  bl 0x822c0890
	ctx.lr = 0x825F2B28;
	sub_822C0890(ctx, base);
	// 825F2B28: C0010060  lfs f0, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825F2B2C: D01C005C  stfs f0, 0x5c(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 825F2B30: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 825F2B34: 48BB567C  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F2B38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F2B38 size=128
    let mut pc: u32 = 0x825F2B38;
    'dispatch: loop {
        match pc {
            0x825F2B38 => {
    //   block [0x825F2B38..0x825F2BB8)
	// 825F2B38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F2B3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F2B40: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825F2B44: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F2B48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F2B4C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825F2B50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F2B54: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825F2B58: 4BF1C971  bl 0x8250f4c8
	ctx.lr = 0x825F2B5C;
	sub_8250F4C8(ctx, base);
	// 825F2B5C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F2B60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F2B64: 3BEBFFFC  addi r31, r11, -4
	ctx.r[31].s64 = ctx.r[11].s64 + -4;
	// 825F2B68: 409A0008  bne cr6, 0x825f2b70
	if !ctx.cr[6].eq {
	pc = 0x825F2B70; continue 'dispatch;
	}
	// 825F2B6C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825F2B70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F2B74: 487FF11D  bl 0x82df1c90
	ctx.lr = 0x825F2B78;
	sub_82DF1C90(ctx, base);
	// 825F2B78: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825F2B7C: 419A0024  beq cr6, 0x825f2ba0
	if ctx.cr[6].eq {
	pc = 0x825F2BA0; continue 'dispatch;
	}
	// 825F2B80: 897E0170  lbz r11, 0x170(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(368 as u32) ) } as u64;
	// 825F2B84: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F2B88: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F2B8C: 41820010  beq 0x825f2b9c
	if ctx.cr[0].eq {
	pc = 0x825F2B9C; continue 'dispatch;
	}
	// 825F2B90: 38800BBA  li r4, 0xbba
	ctx.r[4].s64 = 3002;
	// 825F2B94: 4BFFFB25  bl 0x825f26b8
	ctx.lr = 0x825F2B98;
	sub_825F26B8(ctx, base);
	// 825F2B98: 48000008  b 0x825f2ba0
	pc = 0x825F2BA0; continue 'dispatch;
	// 825F2B9C: 4BFFFC65  bl 0x825f2800
	ctx.lr = 0x825F2BA0;
	sub_825F2800(ctx, base);
	// 825F2BA0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825F2BA4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F2BA8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F2BAC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825F2BB0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F2BB4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F2BB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825F2BB8 size=8
    let mut pc: u32 = 0x825F2BB8;
    'dispatch: loop {
        match pc {
            0x825F2BB8 => {
    //   block [0x825F2BB8..0x825F2BC0)
	// 825F2BB8: 388003EA  li r4, 0x3ea
	ctx.r[4].s64 = 1002;
	// 825F2BBC: 4BFFFAFC  b 0x825f26b8
	sub_825F26B8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F2BC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825F2BC0 size=4
    let mut pc: u32 = 0x825F2BC0;
    'dispatch: loop {
        match pc {
            0x825F2BC0 => {
    //   block [0x825F2BC0..0x825F2BC4)
	// 825F2BC0: 4BFFFC40  b 0x825f2800
	sub_825F2800(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F2BC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F2BC8 size=332
    let mut pc: u32 = 0x825F2BC8;
    'dispatch: loop {
        match pc {
            0x825F2BC8 => {
    //   block [0x825F2BC8..0x825F2D14)
	// 825F2BC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F2BCC: 48BB559D  bl 0x831a8168
	ctx.lr = 0x825F2BD0;
	sub_831A8130(ctx, base);
	// 825F2BD0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F2BD4: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 825F2BD8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825F2BDC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825F2BE0: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 825F2BE4: 40820038  bne 0x825f2c1c
	if !ctx.cr[0].eq {
	pc = 0x825F2C1C; continue 'dispatch;
	}
	// 825F2BE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F2BEC: 48BB6D9D  bl 0x831a9988
	ctx.lr = 0x825F2BF0;
	sub_831A9988(ctx, base);
	// 825F2BF0: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825F2BF4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825F2BF8: 386BEDAC  addi r3, r11, -0x1254
	ctx.r[3].s64 = ctx.r[11].s64 + -4692;
	// 825F2BFC: 48BB54FD  bl 0x831a80f8
	ctx.lr = 0x825F2C00;
	sub_831A80F8(ctx, base);
	// 825F2C00: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825F2C04: 41820018  beq 0x825f2c1c
	if ctx.cr[0].eq {
	pc = 0x825F2C1C; continue 'dispatch;
	}
	// 825F2C08: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F2C0C: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 825F2C10: 4BFFF041  bl 0x825f1c50
	ctx.lr = 0x825F2C14;
	sub_825F1C50(ctx, base);
	// 825F2C14: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 825F2C18: 480000F4  b 0x825f2d0c
	pc = 0x825F2D0C; continue 'dispatch;
	// 825F2C1C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825F2C20: 419A00DC  beq cr6, 0x825f2cfc
	if ctx.cr[6].eq {
	pc = 0x825F2CFC; continue 'dispatch;
	}
	// 825F2C24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F2C28: 48BB6D61  bl 0x831a9988
	ctx.lr = 0x825F2C2C;
	sub_831A9988(ctx, base);
	// 825F2C2C: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825F2C30: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825F2C34: 386BED70  addi r3, r11, -0x1290
	ctx.r[3].s64 = ctx.r[11].s64 + -4752;
	// 825F2C38: 48BB54C1  bl 0x831a80f8
	ctx.lr = 0x825F2C3C;
	sub_831A80F8(ctx, base);
	// 825F2C3C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825F2C40: 41820014  beq 0x825f2c54
	if ctx.cr[0].eq {
	pc = 0x825F2C54; continue 'dispatch;
	}
	// 825F2C44: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F2C48: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 825F2C4C: 4BFFF025  bl 0x825f1c70
	ctx.lr = 0x825F2C50;
	sub_825F1C70(ctx, base);
	// 825F2C50: 4BFFFFC4  b 0x825f2c14
	pc = 0x825F2C14; continue 'dispatch;
	// 825F2C54: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825F2C58: 419A00A4  beq cr6, 0x825f2cfc
	if ctx.cr[6].eq {
	pc = 0x825F2CFC; continue 'dispatch;
	}
	// 825F2C5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F2C60: 48BB6D29  bl 0x831a9988
	ctx.lr = 0x825F2C64;
	sub_831A9988(ctx, base);
	// 825F2C64: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825F2C68: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825F2C6C: 386BEE1C  addi r3, r11, -0x11e4
	ctx.r[3].s64 = ctx.r[11].s64 + -4580;
	// 825F2C70: 48BB5489  bl 0x831a80f8
	ctx.lr = 0x825F2C74;
	sub_831A80F8(ctx, base);
	// 825F2C74: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825F2C78: 41820014  beq 0x825f2c8c
	if ctx.cr[0].eq {
	pc = 0x825F2C8C; continue 'dispatch;
	}
	// 825F2C7C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F2C80: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 825F2C84: 4BFFFC65  bl 0x825f28e8
	ctx.lr = 0x825F2C88;
	sub_825F28E8(ctx, base);
	// 825F2C88: 4BFFFF8C  b 0x825f2c14
	pc = 0x825F2C14; continue 'dispatch;
	// 825F2C8C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825F2C90: 419A006C  beq cr6, 0x825f2cfc
	if ctx.cr[6].eq {
	pc = 0x825F2CFC; continue 'dispatch;
	}
	// 825F2C94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F2C98: 48BB6CF1  bl 0x831a9988
	ctx.lr = 0x825F2C9C;
	sub_831A9988(ctx, base);
	// 825F2C9C: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825F2CA0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825F2CA4: 386BEDE4  addi r3, r11, -0x121c
	ctx.r[3].s64 = ctx.r[11].s64 + -4636;
	// 825F2CA8: 48BB5451  bl 0x831a80f8
	ctx.lr = 0x825F2CAC;
	sub_831A80F8(ctx, base);
	// 825F2CAC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825F2CB0: 41820014  beq 0x825f2cc4
	if ctx.cr[0].eq {
	pc = 0x825F2CC4; continue 'dispatch;
	}
	// 825F2CB4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F2CB8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 825F2CBC: 4BFFFC4D  bl 0x825f2908
	ctx.lr = 0x825F2CC0;
	sub_825F2908(ctx, base);
	// 825F2CC0: 4BFFFF54  b 0x825f2c14
	pc = 0x825F2C14; continue 'dispatch;
	// 825F2CC4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825F2CC8: 419A0034  beq cr6, 0x825f2cfc
	if ctx.cr[6].eq {
	pc = 0x825F2CFC; continue 'dispatch;
	}
	// 825F2CCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F2CD0: 48BB6CB9  bl 0x831a9988
	ctx.lr = 0x825F2CD4;
	sub_831A9988(ctx, base);
	// 825F2CD4: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 825F2CD8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825F2CDC: 386BC8E4  addi r3, r11, -0x371c
	ctx.r[3].s64 = ctx.r[11].s64 + -14108;
	// 825F2CE0: 48BB5419  bl 0x831a80f8
	ctx.lr = 0x825F2CE4;
	sub_831A80F8(ctx, base);
	// 825F2CE4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825F2CE8: 41820014  beq 0x825f2cfc
	if ctx.cr[0].eq {
	pc = 0x825F2CFC; continue 'dispatch;
	}
	// 825F2CEC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F2CF0: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 825F2CF4: 48077FFD  bl 0x8266acf0
	ctx.lr = 0x825F2CF8;
	sub_8266ACF0(ctx, base);
	// 825F2CF8: 4BFFFF1C  b 0x825f2c14
	pc = 0x825F2C14; continue 'dispatch;
	// 825F2CFC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 825F2D00: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F2D04: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F2D08: 480A1E59  bl 0x82694b60
	ctx.lr = 0x825F2D0C;
	sub_82694B60(ctx, base);
	// 825F2D0C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825F2D10: 48BB54A8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F2D18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825F2D18 size=232
    let mut pc: u32 = 0x825F2D18;
    'dispatch: loop {
        match pc {
            0x825F2D18 => {
    //   block [0x825F2D18..0x825F2E00)
	// 825F2D18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F2D1C: 48BB544D  bl 0x831a8168
	ctx.lr = 0x825F2D20;
	sub_831A8130(ctx, base);
	// 825F2D20: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F2D24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F2D28: 480A1599  bl 0x826942c0
	ctx.lr = 0x825F2D2C;
	sub_826942C0(ctx, base);
	// 825F2D2C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825F2D30: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 825F2D34: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 825F2D38: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825F2D3C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825F2D40: C00B9450  lfs f0, -0x6bb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825F2D44: 396909F0  addi r11, r9, 0x9f0
	ctx.r[11].s64 = ctx.r[9].s64 + 2544;
	// 825F2D48: 394A095C  addi r10, r10, 0x95c
	ctx.r[10].s64 = ctx.r[10].s64 + 2396;
	// 825F2D4C: D01F0130  stfs f0, 0x130(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), tmp.u32 ) };
	// 825F2D50: 392809A4  addi r9, r8, 0x9a4
	ctx.r[9].s64 = ctx.r[8].s64 + 2468;
	// 825F2D54: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 825F2D58: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825F2D5C: 387F0140  addi r3, r31, 0x140
	ctx.r[3].s64 = ctx.r[31].s64 + 320;
	// 825F2D60: 913F00E8  stw r9, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[9].u32 ) };
	// 825F2D64: 93DF012C  stw r30, 0x12c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(300 as u32), ctx.r[30].u32 ) };
	// 825F2D68: 4BE819B9  bl 0x82474720
	ctx.lr = 0x825F2D6C;
	sub_82474720(ctx, base);
	// 825F2D6C: 3B800080  li r28, 0x80
	ctx.r[28].s64 = 128;
	// 825F2D70: 3BA000FF  li r29, 0xff
	ctx.r[29].s64 = 255;
	// 825F2D74: 9BDF0170  stb r30, 0x170(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(368 as u32), ctx.r[30].u8 ) };
	// 825F2D78: 9B810050  stb r28, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u8 ) };
	// 825F2D7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F2D80: 9BC10051  stb r30, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[30].u8 ) };
	// 825F2D84: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825F2D88: 9BC10052  stb r30, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[30].u8 ) };
	// 825F2D8C: 9BA10053  stb r29, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[29].u8 ) };
	// 825F2D90: 480A1079  bl 0x82693e08
	ctx.lr = 0x825F2D94;
	sub_82693E08(ctx, base);
	// 825F2D94: 9B810054  stb r28, 0x54(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u8 ) };
	// 825F2D98: 9BA10055  stb r29, 0x55(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(85 as u32), ctx.r[29].u8 ) };
	// 825F2D9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F2DA0: 9BC10056  stb r30, 0x56(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(86 as u32), ctx.r[30].u8 ) };
	// 825F2DA4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825F2DA8: 9BC10057  stb r30, 0x57(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(87 as u32), ctx.r[30].u8 ) };
	// 825F2DAC: 480A1085  bl 0x82693e30
	ctx.lr = 0x825F2DB0;
	sub_82693E30(ctx, base);
	// 825F2DB0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825F2DB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F2DB8: C02B9524  lfs f1, -0x6adc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825F2DBC: 480A10BD  bl 0x82693e78
	ctx.lr = 0x825F2DC0;
	sub_82693E78(ctx, base);
	// 825F2DC0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F2DC4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825F2DC8: 388B0924  addi r4, r11, 0x924
	ctx.r[4].s64 = ctx.r[11].s64 + 2340;
	// 825F2DCC: 4BCD6525  bl 0x822c92f0
	ctx.lr = 0x825F2DD0;
	sub_822C92F0(ctx, base);
	// 825F2DD0: 387F0104  addi r3, r31, 0x104
	ctx.r[3].s64 = ctx.r[31].s64 + 260;
	// 825F2DD4: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 825F2DD8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825F2DDC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825F2DE0: 4BCD6351  bl 0x822c9130
	ctx.lr = 0x825F2DE4;
	sub_822C9130(ctx, base);
	// 825F2DE4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825F2DE8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825F2DEC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825F2DF0: 4BCD6041  bl 0x822c8e30
	ctx.lr = 0x825F2DF4;
	sub_822C8E30(ctx, base);
	// 825F2DF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F2DF8: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825F2DFC: 48BB53BC  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F2E00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F2E00 size=128
    let mut pc: u32 = 0x825F2E00;
    'dispatch: loop {
        match pc {
            0x825F2E00 => {
    //   block [0x825F2E00..0x825F2E80)
	// 825F2E00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F2E04: 48BB5369  bl 0x831a816c
	ctx.lr = 0x825F2E08;
	sub_831A8130(ctx, base);
	// 825F2E08: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F2E0C: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 825F2E10: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825F2E14: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825F2E18: 3BEB7EE8  addi r31, r11, 0x7ee8
	ctx.r[31].s64 = ctx.r[11].s64 + 32488;
	// 825F2E1C: 816A7EF0  lwz r11, 0x7ef0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32496 as u32) ) } as u64;
	// 825F2E20: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825F2E24: 40820024  bne 0x825f2e48
	if !ctx.cr[0].eq {
	pc = 0x825F2E48; continue 'dispatch;
	}
	// 825F2E28: 3D208271  lis r9, -0x7d8f
	ctx.r[9].s64 = -2106523648;
	// 825F2E2C: 3D00825F  lis r8, -0x7da1
	ctx.r[8].s64 = -2107703296;
	// 825F2E30: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 825F2E34: 39298E48  addi r9, r9, -0x71b8
	ctx.r[9].s64 = ctx.r[9].s64 + -29112;
	// 825F2E38: 39082158  addi r8, r8, 0x2158
	ctx.r[8].s64 = ctx.r[8].s64 + 8536;
	// 825F2E3C: 916A7EF0  stw r11, 0x7ef0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(32496 as u32), ctx.r[11].u32 ) };
	// 825F2E40: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825F2E44: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825F2E48: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825F2E4C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825F2E50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F2E54: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 825F2E58: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 825F2E5C: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825F2E60: 48061761  bl 0x826545c0
	ctx.lr = 0x825F2E64;
	sub_826545C0(ctx, base);
	// 825F2E64: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825F2E68: 4182000C  beq 0x825f2e74
	if ctx.cr[0].eq {
	pc = 0x825F2E74; continue 'dispatch;
	}
	// 825F2E6C: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825F2E70: 48000008  b 0x825f2e78
	pc = 0x825F2E78; continue 'dispatch;
	// 825F2E74: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 825F2E78: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825F2E7C: 48BB5340  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F2E80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825F2E80 size=424
    let mut pc: u32 = 0x825F2E80;
    'dispatch: loop {
        match pc {
            0x825F2E80 => {
    //   block [0x825F2E80..0x825F3028)
	// 825F2E80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F2E84: 48BB52E1  bl 0x831a8164
	ctx.lr = 0x825F2E88;
	sub_831A8130(ctx, base);
	// 825F2E88: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F2E8C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F2E90: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825F2E94: 3BCB08C0  addi r30, r11, 0x8c0
	ctx.r[30].s64 = ctx.r[11].s64 + 2240;
	// 825F2E98: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825F2E9C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F2EA0: 38A00031  li r5, 0x31
	ctx.r[5].s64 = 49;
	// 825F2EA4: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 825F2EA8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825F2EAC: 38600180  li r3, 0x180
	ctx.r[3].s64 = 384;
	// 825F2EB0: 487FF539  bl 0x82df23e8
	ctx.lr = 0x825F2EB4;
	sub_82DF23E8(ctx, base);
	// 825F2EB4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F2EB8: 41820010  beq 0x825f2ec8
	if ctx.cr[0].eq {
	pc = 0x825F2EC8; continue 'dispatch;
	}
	// 825F2EBC: 4BFFFE5D  bl 0x825f2d18
	ctx.lr = 0x825F2EC0;
	sub_825F2D18(ctx, base);
	// 825F2EC0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F2EC4: 48000008  b 0x825f2ecc
	pc = 0x825F2ECC; continue 'dispatch;
	// 825F2EC8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825F2ECC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825F2ED0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F2ED4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F2ED8: 4BFFEE99  bl 0x825f1d70
	ctx.lr = 0x825F2EDC;
	sub_825F1D70(ctx, base);
	// 825F2EDC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825F2EE0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F2EE4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F2EE8: 4BCCD119  bl 0x822c0000
	ctx.lr = 0x825F2EEC;
	sub_822C0000(ctx, base);
	// 825F2EEC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825F2EF0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F2EF4: 38A00032  li r5, 0x32
	ctx.r[5].s64 = 50;
	// 825F2EF8: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825F2EFC: 4BCCD4DD  bl 0x822c03d8
	ctx.lr = 0x825F2F00;
	sub_822C03D8(ctx, base);
	// 825F2F00: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825F2F04: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825F2F08: 418200B4  beq 0x825f2fbc
	if ctx.cr[0].eq {
	pc = 0x825F2FBC; continue 'dispatch;
	}
	// 825F2F0C: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825F2F10: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 825F2F14: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825F2F18: 396A00E8  addi r11, r10, 0xe8
	ctx.r[11].s64 = ctx.r[10].s64 + 232;
	// 825F2F1C: 409A0008  bne cr6, 0x825f2f24
	if !ctx.cr[6].eq {
	pc = 0x825F2F24; continue 'dispatch;
	}
	// 825F2F20: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F2F24: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825F2F28: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825F2F2C: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 825F2F30: 419A0024  beq cr6, 0x825f2f54
	if ctx.cr[6].eq {
	pc = 0x825F2F54; continue 'dispatch;
	}
	// 825F2F34: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825F2F38: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 825F2F3C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F2F40: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 825F2F44: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 825F2F48: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825F2F4C: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F2F50: 4082FFE8  bne 0x825f2f38
	if !ctx.cr[0].eq {
	pc = 0x825F2F38; continue 'dispatch;
	}
	// 825F2F54: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 825F2F58: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825F2F5C: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 825F2F60: 419A0024  beq cr6, 0x825f2f84
	if ctx.cr[6].eq {
	pc = 0x825F2F84; continue 'dispatch;
	}
	// 825F2F64: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825F2F68: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825F2F6C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F2F70: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825F2F74: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825F2F78: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825F2F7C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F2F80: 4082FFE8  bne 0x825f2f68
	if !ctx.cr[0].eq {
	pc = 0x825F2F68; continue 'dispatch;
	}
	// 825F2F84: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825F2F88: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 825F2F8C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825F2F90: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 825F2F94: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825F2F98: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825F2F9C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825F2FA0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825F2FA4: 481A5F8D  bl 0x82798f30
	ctx.lr = 0x825F2FA8;
	sub_82798F30(ctx, base);
	// 825F2FA8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825F2FAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F2FB0: 481A86B9  bl 0x8279b668
	ctx.lr = 0x825F2FB4;
	sub_8279B668(ctx, base);
	// 825F2FB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F2FB8: 48000008  b 0x825f2fc0
	pc = 0x825F2FC0; continue 'dispatch;
	// 825F2FBC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825F2FC0: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825F2FC4: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 825F2FC8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F2FCC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F2FD0: 4BFA4C81  bl 0x82597c50
	ctx.lr = 0x825F2FD4;
	sub_82597C50(ctx, base);
	// 825F2FD4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825F2FD8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F2FDC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F2FE0: 4BCCD021  bl 0x822c0000
	ctx.lr = 0x825F2FE4;
	sub_822C0000(ctx, base);
	// 825F2FE4: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825F2FE8: 41820024  beq 0x825f300c
	if ctx.cr[0].eq {
	pc = 0x825F300C; continue 'dispatch;
	}
	// 825F2FEC: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 825F2FF0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F2FF4: 419A0008  beq cr6, 0x825f2ffc
	if ctx.cr[6].eq {
	pc = 0x825F2FFC; continue 'dispatch;
	}
	// 825F2FF8: 4BCCD899  bl 0x822c0890
	ctx.lr = 0x825F2FFC;
	sub_822C0890(ctx, base);
	// 825F2FFC: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825F3000: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F3004: 419A0008  beq cr6, 0x825f300c
	if ctx.cr[6].eq {
	pc = 0x825F300C; continue 'dispatch;
	}
	// 825F3008: 4BCCD889  bl 0x822c0890
	ctx.lr = 0x825F300C;
	sub_822C0890(ctx, base);
	// 825F300C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825F3010: 419A000C  beq cr6, 0x825f301c
	if ctx.cr[6].eq {
	pc = 0x825F301C; continue 'dispatch;
	}
	// 825F3014: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825F3018: 4BCCD879  bl 0x822c0890
	ctx.lr = 0x825F301C;
	sub_822C0890(ctx, base);
	// 825F301C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825F3020: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 825F3024: 48BB5190  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F3028(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825F3028 size=1152
    let mut pc: u32 = 0x825F3028;
    'dispatch: loop {
        match pc {
            0x825F3028 => {
    //   block [0x825F3028..0x825F34A8)
	// 825F3028: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F302C: 48BB5141  bl 0x831a816c
	ctx.lr = 0x825F3030;
	sub_831A8130(ctx, base);
	// 825F3030: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 825F3034: 48BB5A39  bl 0x831a8a6c
	ctx.lr = 0x825F3038;
	sub_831A8A40(ctx, base);
	// 825F3038: 9421FC00  stwu r1, -0x400(r1)
	ea = ctx.r[1].u32.wrapping_add(-1024 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F303C: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 825F3040: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F3044: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825F3048: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F304C: 388B6058  addi r4, r11, 0x6058
	ctx.r[4].s64 = ctx.r[11].s64 + 24664;
	// 825F3050: 488009B9  bl 0x82df3a08
	ctx.lr = 0x825F3054;
	sub_82DF3A08(ctx, base);
	// 825F3054: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825F3058: 389F0044  addi r4, r31, 0x44
	ctx.r[4].s64 = ctx.r[31].s64 + 68;
	// 825F305C: 386101A0  addi r3, r1, 0x1a0
	ctx.r[3].s64 = ctx.r[1].s64 + 416;
	// 825F3060: 4BFB0529  bl 0x825a3588
	ctx.lr = 0x825F3064;
	sub_825A3588(ctx, base);
	// 825F3064: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825F3068: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825F306C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825F3070: 4BFAEE69  bl 0x825a1ed8
	ctx.lr = 0x825F3074;
	sub_825A1ED8(ctx, base);
	// 825F3074: 386101D8  addi r3, r1, 0x1d8
	ctx.r[3].s64 = ctx.r[1].s64 + 472;
	// 825F3078: 488003B1  bl 0x82df3428
	ctx.lr = 0x825F307C;
	sub_82DF3428(ctx, base);
	// 825F307C: 386101B8  addi r3, r1, 0x1b8
	ctx.r[3].s64 = ctx.r[1].s64 + 440;
	// 825F3080: 4BCD5C39  bl 0x822c8cb8
	ctx.lr = 0x825F3084;
	sub_822C8CB8(ctx, base);
	// 825F3084: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F3088: 488003A1  bl 0x82df3428
	ctx.lr = 0x825F308C;
	sub_82DF3428(ctx, base);
	// 825F308C: 3D60825F  lis r11, -0x7da1
	ctx.r[11].s64 = -2107703296;
	// 825F3090: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825F3094: 396B2B38  addi r11, r11, 0x2b38
	ctx.r[11].s64 = ctx.r[11].s64 + 11064;
	// 825F3098: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825F309C: 388A0A88  addi r4, r10, 0xa88
	ctx.r[4].s64 = ctx.r[10].s64 + 2696;
	// 825F30A0: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825F30A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F30A8: 93C10064  stw r30, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 825F30AC: 4880095D  bl 0x82df3a08
	ctx.lr = 0x825F30B0;
	sub_82DF3A08(ctx, base);
	// 825F30B0: 397FFF18  addi r11, r31, -0xe8
	ctx.r[11].s64 = ctx.r[31].s64 + -232;
	// 825F30B4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825F30B8: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 825F30BC: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 825F30C0: E8A10068  ld r5, 0x68(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 825F30C4: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 825F30C8: 4BFFFD39  bl 0x825f2e00
	ctx.lr = 0x825F30CC;
	sub_825F2E00(ctx, base);
	// 825F30CC: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 825F30D0: 389F0088  addi r4, r31, 0x88
	ctx.r[4].s64 = ctx.r[31].s64 + 136;
	// 825F30D4: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 825F30D8: 4BFAFF01  bl 0x825a2fd8
	ctx.lr = 0x825F30DC;
	sub_825A2FD8(ctx, base);
	// 825F30DC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825F30E0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825F30E4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825F30E8: 4BFAF0A1  bl 0x825a2188
	ctx.lr = 0x825F30EC;
	sub_825A2188(ctx, base);
	// 825F30EC: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 825F30F0: 48800339  bl 0x82df3428
	ctx.lr = 0x825F30F4;
	sub_82DF3428(ctx, base);
	// 825F30F4: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 825F30F8: 4BCD5BC1  bl 0x822c8cb8
	ctx.lr = 0x825F30FC;
	sub_822C8CB8(ctx, base);
	// 825F30FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F3100: 48800329  bl 0x82df3428
	ctx.lr = 0x825F3104;
	sub_82DF3428(ctx, base);
	// 825F3104: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825F3108: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F310C: 480A127D  bl 0x82694388
	ctx.lr = 0x825F3110;
	sub_82694388(ctx, base);
	// 825F3110: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F3114: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F3118: 388B0A7C  addi r4, r11, 0xa7c
	ctx.r[4].s64 = ctx.r[11].s64 + 2684;
	// 825F311C: 488008ED  bl 0x82df3a08
	ctx.lr = 0x825F3120;
	sub_82DF3A08(ctx, base);
	// 825F3120: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825F3124: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 825F3128: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 825F312C: 389F0048  addi r4, r31, 0x48
	ctx.r[4].s64 = ctx.r[31].s64 + 72;
	// 825F3130: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 825F3134: C3CB964C  lfs f30, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 825F3138: C3EA6218  lfs f31, 0x6218(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25112 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825F313C: FC60F090  fmr f3, f30
	ctx.f[3].f64 = ctx.f[30].f64;
	// 825F3140: C36908A4  lfs f27, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 825F3144: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 825F3148: FC20D890  fmr f1, f27
	ctx.f[1].f64 = ctx.f[27].f64;
	// 825F314C: 4BFB0065  bl 0x825a31b0
	ctx.lr = 0x825F3150;
	sub_825A31B0(ctx, base);
	// 825F3150: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825F3154: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825F3158: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825F315C: 4BFAE615  bl 0x825a1770
	ctx.lr = 0x825F3160;
	sub_825A1770(ctx, base);
	// 825F3160: 38610158  addi r3, r1, 0x158
	ctx.r[3].s64 = ctx.r[1].s64 + 344;
	// 825F3164: 488002C5  bl 0x82df3428
	ctx.lr = 0x825F3168;
	sub_82DF3428(ctx, base);
	// 825F3168: 38610138  addi r3, r1, 0x138
	ctx.r[3].s64 = ctx.r[1].s64 + 312;
	// 825F316C: 4BCD5B4D  bl 0x822c8cb8
	ctx.lr = 0x825F3170;
	sub_822C8CB8(ctx, base);
	// 825F3170: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F3174: 488002B5  bl 0x82df3428
	ctx.lr = 0x825F3178;
	sub_82DF3428(ctx, base);
	// 825F3178: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F317C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F3180: 388B0A68  addi r4, r11, 0xa68
	ctx.r[4].s64 = ctx.r[11].s64 + 2664;
	// 825F3184: 48800885  bl 0x82df3a08
	ctx.lr = 0x825F3188;
	sub_82DF3A08(ctx, base);
	// 825F3188: 389F0058  addi r4, r31, 0x58
	ctx.r[4].s64 = ctx.r[31].s64 + 88;
	// 825F318C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825F3190: 4BFAFDE1  bl 0x825a2f70
	ctx.lr = 0x825F3194;
	sub_825A2F70(ctx, base);
	// 825F3194: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825F3198: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825F319C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825F31A0: 4BFAEFE9  bl 0x825a2188
	ctx.lr = 0x825F31A4;
	sub_825A2188(ctx, base);
	// 825F31A4: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 825F31A8: 48800281  bl 0x82df3428
	ctx.lr = 0x825F31AC;
	sub_82DF3428(ctx, base);
	// 825F31AC: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 825F31B0: 4BCD5B09  bl 0x822c8cb8
	ctx.lr = 0x825F31B4;
	sub_822C8CB8(ctx, base);
	// 825F31B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F31B8: 48800271  bl 0x82df3428
	ctx.lr = 0x825F31BC;
	sub_82DF3428(ctx, base);
	// 825F31BC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F31C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F31C4: 388B0A50  addi r4, r11, 0xa50
	ctx.r[4].s64 = ctx.r[11].s64 + 2640;
	// 825F31C8: 48800841  bl 0x82df3a08
	ctx.lr = 0x825F31CC;
	sub_82DF3A08(ctx, base);
	// 825F31CC: 389F0059  addi r4, r31, 0x59
	ctx.r[4].s64 = ctx.r[31].s64 + 89;
	// 825F31D0: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 825F31D4: 4BFAFD9D  bl 0x825a2f70
	ctx.lr = 0x825F31D8;
	sub_825A2F70(ctx, base);
	// 825F31D8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825F31DC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825F31E0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825F31E4: 4BFAEFA5  bl 0x825a2188
	ctx.lr = 0x825F31E8;
	sub_825A2188(ctx, base);
	// 825F31E8: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 825F31EC: 4880023D  bl 0x82df3428
	ctx.lr = 0x825F31F0;
	sub_82DF3428(ctx, base);
	// 825F31F0: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 825F31F4: 4BCD5AC5  bl 0x822c8cb8
	ctx.lr = 0x825F31F8;
	sub_822C8CB8(ctx, base);
	// 825F31F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F31FC: 4880022D  bl 0x82df3428
	ctx.lr = 0x825F3200;
	sub_82DF3428(ctx, base);
	// 825F3200: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F3204: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F3208: 388B0A38  addi r4, r11, 0xa38
	ctx.r[4].s64 = ctx.r[11].s64 + 2616;
	// 825F320C: 488007FD  bl 0x82df3a08
	ctx.lr = 0x825F3210;
	sub_82DF3A08(ctx, base);
	// 825F3210: 389F005C  addi r4, r31, 0x5c
	ctx.r[4].s64 = ctx.r[31].s64 + 92;
	// 825F3214: 386102A0  addi r3, r1, 0x2a0
	ctx.r[3].s64 = ctx.r[1].s64 + 672;
	// 825F3218: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 825F321C: 4BFB0105  bl 0x825a3320
	ctx.lr = 0x825F3220;
	sub_825A3320(ctx, base);
	// 825F3220: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825F3224: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825F3228: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825F322C: 4BFAE545  bl 0x825a1770
	ctx.lr = 0x825F3230;
	sub_825A1770(ctx, base);
	// 825F3230: 386102D8  addi r3, r1, 0x2d8
	ctx.r[3].s64 = ctx.r[1].s64 + 728;
	// 825F3234: 488001F5  bl 0x82df3428
	ctx.lr = 0x825F3238;
	sub_82DF3428(ctx, base);
	// 825F3238: 386102B8  addi r3, r1, 0x2b8
	ctx.r[3].s64 = ctx.r[1].s64 + 696;
	// 825F323C: 4BCD5A7D  bl 0x822c8cb8
	ctx.lr = 0x825F3240;
	sub_822C8CB8(ctx, base);
	// 825F3240: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F3244: 488001E5  bl 0x82df3428
	ctx.lr = 0x825F3248;
	sub_82DF3428(ctx, base);
	// 825F3248: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 825F324C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F3250: 388B8FF4  addi r4, r11, -0x700c
	ctx.r[4].s64 = ctx.r[11].s64 + -28684;
	// 825F3254: 488007B5  bl 0x82df3a08
	ctx.lr = 0x825F3258;
	sub_82DF3A08(ctx, base);
	// 825F3258: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825F325C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 825F3260: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 825F3264: 389F0068  addi r4, r31, 0x68
	ctx.r[4].s64 = ctx.r[31].s64 + 104;
	// 825F3268: 38610220  addi r3, r1, 0x220
	ctx.r[3].s64 = ctx.r[1].s64 + 544;
	// 825F326C: C3AB9528  lfs f29, -0x6ad8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 825F3270: C38A0790  lfs f28, 0x790(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(1936 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 825F3274: FC60E890  fmr f3, f29
	ctx.f[3].f64 = ctx.f[29].f64;
	// 825F3278: FC20E090  fmr f1, f28
	ctx.f[1].f64 = ctx.f[28].f64;
	// 825F327C: 4BFAFF35  bl 0x825a31b0
	ctx.lr = 0x825F3280;
	sub_825A31B0(ctx, base);
	// 825F3280: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825F3284: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825F3288: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825F328C: 4BFAE4E5  bl 0x825a1770
	ctx.lr = 0x825F3290;
	sub_825A1770(ctx, base);
	// 825F3290: 38610258  addi r3, r1, 0x258
	ctx.r[3].s64 = ctx.r[1].s64 + 600;
	// 825F3294: 48800195  bl 0x82df3428
	ctx.lr = 0x825F3298;
	sub_82DF3428(ctx, base);
	// 825F3298: 38610238  addi r3, r1, 0x238
	ctx.r[3].s64 = ctx.r[1].s64 + 568;
	// 825F329C: 4BCD5A1D  bl 0x822c8cb8
	ctx.lr = 0x825F32A0;
	sub_822C8CB8(ctx, base);
	// 825F32A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F32A4: 48800185  bl 0x82df3428
	ctx.lr = 0x825F32A8;
	sub_82DF3428(ctx, base);
	// 825F32A8: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 825F32AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F32B0: 388B977C  addi r4, r11, -0x6884
	ctx.r[4].s64 = ctx.r[11].s64 + -26756;
	// 825F32B4: 48800755  bl 0x82df3a08
	ctx.lr = 0x825F32B8;
	sub_82DF3A08(ctx, base);
	// 825F32B8: 389F006C  addi r4, r31, 0x6c
	ctx.r[4].s64 = ctx.r[31].s64 + 108;
	// 825F32BC: 38610320  addi r3, r1, 0x320
	ctx.r[3].s64 = ctx.r[1].s64 + 800;
	// 825F32C0: FC60E890  fmr f3, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[29].f64;
	// 825F32C4: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 825F32C8: 3D408203  lis r10, -0x7dfd
	ctx.r[10].s64 = -2113732608;
	// 825F32CC: C34B975C  lfs f26, -0x68a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-26788 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 825F32D0: C32A9758  lfs f25, -0x68a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-26792 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 825F32D4: FC40D090  fmr f2, f26
	ctx.f[2].f64 = ctx.f[26].f64;
	// 825F32D8: FC20C890  fmr f1, f25
	ctx.f[1].f64 = ctx.f[25].f64;
	// 825F32DC: 4BFAFED5  bl 0x825a31b0
	ctx.lr = 0x825F32E0;
	sub_825A31B0(ctx, base);
	// 825F32E0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825F32E4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825F32E8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825F32EC: 4BFAE485  bl 0x825a1770
	ctx.lr = 0x825F32F0;
	sub_825A1770(ctx, base);
	// 825F32F0: 38610358  addi r3, r1, 0x358
	ctx.r[3].s64 = ctx.r[1].s64 + 856;
	// 825F32F4: 48800135  bl 0x82df3428
	ctx.lr = 0x825F32F8;
	sub_82DF3428(ctx, base);
	// 825F32F8: 38610338  addi r3, r1, 0x338
	ctx.r[3].s64 = ctx.r[1].s64 + 824;
	// 825F32FC: 4BCD59BD  bl 0x822c8cb8
	ctx.lr = 0x825F3300;
	sub_822C8CB8(ctx, base);
	// 825F3300: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F3304: 48800125  bl 0x82df3428
	ctx.lr = 0x825F3308;
	sub_82DF3428(ctx, base);
	// 825F3308: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 825F330C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F3310: 388B974C  addi r4, r11, -0x68b4
	ctx.r[4].s64 = ctx.r[11].s64 + -26804;
	// 825F3314: 488006F5  bl 0x82df3a08
	ctx.lr = 0x825F3318;
	sub_82DF3A08(ctx, base);
	// 825F3318: 389F0070  addi r4, r31, 0x70
	ctx.r[4].s64 = ctx.r[31].s64 + 112;
	// 825F331C: 38610160  addi r3, r1, 0x160
	ctx.r[3].s64 = ctx.r[1].s64 + 352;
	// 825F3320: FC60E890  fmr f3, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[29].f64;
	// 825F3324: FC40D090  fmr f2, f26
	ctx.f[2].f64 = ctx.f[26].f64;
	// 825F3328: FC20C890  fmr f1, f25
	ctx.f[1].f64 = ctx.f[25].f64;
	// 825F332C: 4BFAFE85  bl 0x825a31b0
	ctx.lr = 0x825F3330;
	sub_825A31B0(ctx, base);
	// 825F3330: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825F3334: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825F3338: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825F333C: 4BFAE435  bl 0x825a1770
	ctx.lr = 0x825F3340;
	sub_825A1770(ctx, base);
	// 825F3340: 38610198  addi r3, r1, 0x198
	ctx.r[3].s64 = ctx.r[1].s64 + 408;
	// 825F3344: 488000E5  bl 0x82df3428
	ctx.lr = 0x825F3348;
	sub_82DF3428(ctx, base);
	// 825F3348: 38610178  addi r3, r1, 0x178
	ctx.r[3].s64 = ctx.r[1].s64 + 376;
	// 825F334C: 4BCD596D  bl 0x822c8cb8
	ctx.lr = 0x825F3350;
	sub_822C8CB8(ctx, base);
	// 825F3350: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F3354: 488000D5  bl 0x82df3428
	ctx.lr = 0x825F3358;
	sub_82DF3428(ctx, base);
	// 825F3358: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 825F335C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F3360: 388B9ED0  addi r4, r11, -0x6130
	ctx.r[4].s64 = ctx.r[11].s64 + -24880;
	// 825F3364: 488006A5  bl 0x82df3a08
	ctx.lr = 0x825F3368;
	sub_82DF3A08(ctx, base);
	// 825F3368: 389F0078  addi r4, r31, 0x78
	ctx.r[4].s64 = ctx.r[31].s64 + 120;
	// 825F336C: 386101E0  addi r3, r1, 0x1e0
	ctx.r[3].s64 = ctx.r[1].s64 + 480;
	// 825F3370: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 825F3374: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 825F3378: FC20E090  fmr f1, f28
	ctx.f[1].f64 = ctx.f[28].f64;
	// 825F337C: 4BFAFE35  bl 0x825a31b0
	ctx.lr = 0x825F3380;
	sub_825A31B0(ctx, base);
	// 825F3380: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825F3384: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825F3388: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825F338C: 4BFAE3E5  bl 0x825a1770
	ctx.lr = 0x825F3390;
	sub_825A1770(ctx, base);
	// 825F3390: 38610218  addi r3, r1, 0x218
	ctx.r[3].s64 = ctx.r[1].s64 + 536;
	// 825F3394: 48800095  bl 0x82df3428
	ctx.lr = 0x825F3398;
	sub_82DF3428(ctx, base);
	// 825F3398: 386101F8  addi r3, r1, 0x1f8
	ctx.r[3].s64 = ctx.r[1].s64 + 504;
	// 825F339C: 4BCD591D  bl 0x822c8cb8
	ctx.lr = 0x825F33A0;
	sub_822C8CB8(ctx, base);
	// 825F33A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F33A4: 48800085  bl 0x82df3428
	ctx.lr = 0x825F33A8;
	sub_82DF3428(ctx, base);
	// 825F33A8: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 825F33AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F33B0: 388B9EE4  addi r4, r11, -0x611c
	ctx.r[4].s64 = ctx.r[11].s64 + -24860;
	// 825F33B4: 48800655  bl 0x82df3a08
	ctx.lr = 0x825F33B8;
	sub_82DF3A08(ctx, base);
	// 825F33B8: 389F007C  addi r4, r31, 0x7c
	ctx.r[4].s64 = ctx.r[31].s64 + 124;
	// 825F33BC: 38610260  addi r3, r1, 0x260
	ctx.r[3].s64 = ctx.r[1].s64 + 608;
	// 825F33C0: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 825F33C4: FC60F090  fmr f3, f30
	ctx.f[3].f64 = ctx.f[30].f64;
	// 825F33C8: FC20E090  fmr f1, f28
	ctx.f[1].f64 = ctx.f[28].f64;
	// 825F33CC: 4BFAFDE5  bl 0x825a31b0
	ctx.lr = 0x825F33D0;
	sub_825A31B0(ctx, base);
	// 825F33D0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825F33D4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825F33D8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825F33DC: 4BFAE395  bl 0x825a1770
	ctx.lr = 0x825F33E0;
	sub_825A1770(ctx, base);
	// 825F33E0: 38610298  addi r3, r1, 0x298
	ctx.r[3].s64 = ctx.r[1].s64 + 664;
	// 825F33E4: 48800045  bl 0x82df3428
	ctx.lr = 0x825F33E8;
	sub_82DF3428(ctx, base);
	// 825F33E8: 38610278  addi r3, r1, 0x278
	ctx.r[3].s64 = ctx.r[1].s64 + 632;
	// 825F33EC: 4BCD58CD  bl 0x822c8cb8
	ctx.lr = 0x825F33F0;
	sub_822C8CB8(ctx, base);
	// 825F33F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F33F4: 48800035  bl 0x82df3428
	ctx.lr = 0x825F33F8;
	sub_82DF3428(ctx, base);
	// 825F33F8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F33FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F3400: 388B0A20  addi r4, r11, 0xa20
	ctx.r[4].s64 = ctx.r[11].s64 + 2592;
	// 825F3404: 48800605  bl 0x82df3a08
	ctx.lr = 0x825F3408;
	sub_82DF3A08(ctx, base);
	// 825F3408: 389F0084  addi r4, r31, 0x84
	ctx.r[4].s64 = ctx.r[31].s64 + 132;
	// 825F340C: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 825F3410: 386102E0  addi r3, r1, 0x2e0
	ctx.r[3].s64 = ctx.r[1].s64 + 736;
	// 825F3414: FC60F090  fmr f3, f30
	ctx.f[3].f64 = ctx.f[30].f64;
	// 825F3418: FC20D890  fmr f1, f27
	ctx.f[1].f64 = ctx.f[27].f64;
	// 825F341C: 4BFAFD95  bl 0x825a31b0
	ctx.lr = 0x825F3420;
	sub_825A31B0(ctx, base);
	// 825F3420: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825F3424: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825F3428: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825F342C: 4BFAE345  bl 0x825a1770
	ctx.lr = 0x825F3430;
	sub_825A1770(ctx, base);
	// 825F3430: 38610318  addi r3, r1, 0x318
	ctx.r[3].s64 = ctx.r[1].s64 + 792;
	// 825F3434: 487FFFF5  bl 0x82df3428
	ctx.lr = 0x825F3438;
	sub_82DF3428(ctx, base);
	// 825F3438: 386102F8  addi r3, r1, 0x2f8
	ctx.r[3].s64 = ctx.r[1].s64 + 760;
	// 825F343C: 4BCD587D  bl 0x822c8cb8
	ctx.lr = 0x825F3440;
	sub_822C8CB8(ctx, base);
	// 825F3440: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F3444: 487FFFE5  bl 0x82df3428
	ctx.lr = 0x825F3448;
	sub_82DF3428(ctx, base);
	// 825F3448: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F344C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F3450: 388B0A00  addi r4, r11, 0xa00
	ctx.r[4].s64 = ctx.r[11].s64 + 2560;
	// 825F3454: 488005B5  bl 0x82df3a08
	ctx.lr = 0x825F3458;
	sub_82DF3A08(ctx, base);
	// 825F3458: 389F0080  addi r4, r31, 0x80
	ctx.r[4].s64 = ctx.r[31].s64 + 128;
	// 825F345C: 38610360  addi r3, r1, 0x360
	ctx.r[3].s64 = ctx.r[1].s64 + 864;
	// 825F3460: FC60E890  fmr f3, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[29].f64;
	// 825F3464: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 825F3468: FC20E090  fmr f1, f28
	ctx.f[1].f64 = ctx.f[28].f64;
	// 825F346C: 4BFAFD45  bl 0x825a31b0
	ctx.lr = 0x825F3470;
	sub_825A31B0(ctx, base);
	// 825F3470: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825F3474: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825F3478: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825F347C: 4BFAE2F5  bl 0x825a1770
	ctx.lr = 0x825F3480;
	sub_825A1770(ctx, base);
	// 825F3480: 38610398  addi r3, r1, 0x398
	ctx.r[3].s64 = ctx.r[1].s64 + 920;
	// 825F3484: 487FFFA5  bl 0x82df3428
	ctx.lr = 0x825F3488;
	sub_82DF3428(ctx, base);
	// 825F3488: 38610378  addi r3, r1, 0x378
	ctx.r[3].s64 = ctx.r[1].s64 + 888;
	// 825F348C: 4BCD582D  bl 0x822c8cb8
	ctx.lr = 0x825F3490;
	sub_822C8CB8(ctx, base);
	// 825F3490: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F3494: 487FFF95  bl 0x82df3428
	ctx.lr = 0x825F3498;
	sub_82DF3428(ctx, base);
	// 825F3498: 38210400  addi r1, r1, 0x400
	ctx.r[1].s64 = ctx.r[1].s64 + 1024;
	// 825F349C: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 825F34A0: 48BB5619  bl 0x831a8ab8
	ctx.lr = 0x825F34A4;
	sub_831A8A8C(ctx, base);
	// 825F34A4: 48BB4D18  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F34A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F34A8 size=108
    let mut pc: u32 = 0x825F34A8;
    'dispatch: loop {
        match pc {
            0x825F34A8 => {
    //   block [0x825F34A8..0x825F3514)
	// 825F34A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F34AC: 48BB4CC1  bl 0x831a816c
	ctx.lr = 0x825F34B0;
	sub_831A8130(ctx, base);
	// 825F34B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F34B4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825F34B8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825F34BC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825F34C0: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825F34C4: 41820038  beq 0x825f34fc
	if ctx.cr[0].eq {
	pc = 0x825F34FC; continue 'dispatch;
	}
	// 825F34C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F34CC: 48BB64BD  bl 0x831a9988
	ctx.lr = 0x825F34D0;
	sub_831A9988(ctx, base);
	// 825F34D0: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 825F34D4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825F34D8: 386BC8E4  addi r3, r11, -0x371c
	ctx.r[3].s64 = ctx.r[11].s64 + -14108;
	// 825F34DC: 48BB4C1D  bl 0x831a80f8
	ctx.lr = 0x825F34E0;
	sub_831A80F8(ctx, base);
	// 825F34E0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825F34E4: 41820018  beq 0x825f34fc
	if ctx.cr[0].eq {
	pc = 0x825F34FC; continue 'dispatch;
	}
	// 825F34E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F34EC: 387DFFD8  addi r3, r29, -0x28
	ctx.r[3].s64 = ctx.r[29].s64 + -40;
	// 825F34F0: 48077801  bl 0x8266acf0
	ctx.lr = 0x825F34F4;
	sub_8266ACF0(ctx, base);
	// 825F34F4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 825F34F8: 48000014  b 0x825f350c
	pc = 0x825F350C; continue 'dispatch;
	// 825F34FC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825F3500: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F3504: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825F3508: 480A1659  bl 0x82694b60
	ctx.lr = 0x825F350C;
	sub_82694B60(ctx, base);
	// 825F350C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825F3510: 48BB4CAC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F3518(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F3518 size=200
    let mut pc: u32 = 0x825F3518;
    'dispatch: loop {
        match pc {
            0x825F3518 => {
    //   block [0x825F3518..0x825F35E0)
	// 825F3518: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F351C: 48BB4C45  bl 0x831a8160
	ctx.lr = 0x825F3520;
	sub_831A8130(ctx, base);
	// 825F3520: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F3524: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825F3528: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825F352C: 4BF1BEAD  bl 0x8250f3d8
	ctx.lr = 0x825F3530;
	sub_8250F3D8(ctx, base);
	// 825F3530: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825F3534: 418200A4  beq 0x825f35d8
	if ctx.cr[0].eq {
	pc = 0x825F35D8; continue 'dispatch;
	}
	// 825F3538: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825F353C: 809E0008  lwz r4, 8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825F3540: 4BF1BF89  bl 0x8250f4c8
	ctx.lr = 0x825F3544;
	sub_8250F4C8(ctx, base);
	// 825F3544: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F3548: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F354C: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 825F3550: 409A0008  bne cr6, 0x825f3558
	if !ctx.cr[6].eq {
	pc = 0x825F3558; continue 'dispatch;
	}
	// 825F3554: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825F3558: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F355C: 4BF15455  bl 0x825089b0
	ctx.lr = 0x825F3560;
	sub_825089B0(ctx, base);
	// 825F3560: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F3564: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F3568: 3BEBFF34  addi r31, r11, -0xcc
	ctx.r[31].s64 = ctx.r[11].s64 + -204;
	// 825F356C: 409A0008  bne cr6, 0x825f3574
	if !ctx.cr[6].eq {
	pc = 0x825F3574; continue 'dispatch;
	}
	// 825F3570: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825F3574: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825F3578: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825F357C: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 825F3580: 3BAB9698  addi r29, r11, -0x6968
	ctx.r[29].s64 = ctx.r[11].s64 + -26984;
	// 825F3584: 3B8A9FC0  addi r28, r10, -0x6040
	ctx.r[28].s64 = ctx.r[10].s64 + -24640;
	// 825F3588: 8363012C  lwz r27, 0x12c(r3)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(300 as u32) ) } as u64;
	// 825F358C: 4BF1E55D  bl 0x82511ae8
	ctx.lr = 0x825F3590;
	sub_82511AE8(ctx, base);
	// 825F3590: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 825F3594: 809E0008  lwz r4, 8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825F3598: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825F359C: 4BF1BF7D  bl 0x8250f518
	ctx.lr = 0x825F35A0;
	sub_8250F518(ctx, base);
	// 825F35A0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825F35A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F35A8: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 825F35AC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F35B0: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 825F35B4: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 825F35B8: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 825F35BC: 4BCD1925  bl 0x822c4ee0
	ctx.lr = 0x825F35C0;
	sub_822C4EE0(ctx, base);
	// 825F35C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F35C4: 487FE6CD  bl 0x82df1c90
	ctx.lr = 0x825F35C8;
	sub_82DF1C90(ctx, base);
	// 825F35C8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825F35CC: 487FE6C5  bl 0x82df1c90
	ctx.lr = 0x825F35D0;
	sub_82DF1C90(ctx, base);
	// 825F35D0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825F35D4: 487FE6BD  bl 0x82df1c90
	ctx.lr = 0x825F35D8;
	sub_82DF1C90(ctx, base);
	// 825F35D8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825F35DC: 48BB4BD4  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F35E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F35E0 size=196
    let mut pc: u32 = 0x825F35E0;
    'dispatch: loop {
        match pc {
            0x825F35E0 => {
    //   block [0x825F35E0..0x825F36A4)
	// 825F35E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F35E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F35E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825F35EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F35F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F35F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825F35F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F35FC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825F3600: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825F3604: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F3608: 4BCCD331  bl 0x822c0938
	ctx.lr = 0x825F360C;
	sub_822C0938(ctx, base);
	// 825F360C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F3610: 41820028  beq 0x825f3638
	if ctx.cr[0].eq {
	pc = 0x825F3638; continue 'dispatch;
	}
	// 825F3614: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F3618: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825F361C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825F3620: 392B0ABC  addi r9, r11, 0xabc
	ctx.r[9].s64 = ctx.r[11].s64 + 2748;
	// 825F3624: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825F3628: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825F362C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825F3630: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825F3634: 48000008  b 0x825f363c
	pc = 0x825F363C; continue 'dispatch;
	// 825F3638: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F363C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F3640: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F3644: 409A0044  bne cr6, 0x825f3688
	if !ctx.cr[6].eq {
	pc = 0x825F3688; continue 'dispatch;
	}
	// 825F3648: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825F364C: 419A001C  beq cr6, 0x825f3668
	if ctx.cr[6].eq {
	pc = 0x825F3668; continue 'dispatch;
	}
	// 825F3650: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F3654: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825F3658: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F365C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F3660: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825F3664: 4E800421  bctrl
	ctx.lr = 0x825F3668;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825F3668: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825F366C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825F3670: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F3674: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825F3678: 816BEE80  lwz r11, -0x1180(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4480 as u32) ) } as u64;
	// 825F367C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825F3680: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825F3684: 4BCCC97D  bl 0x822c0000
	ctx.lr = 0x825F3688;
	sub_822C0000(ctx, base);
	// 825F3688: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F368C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825F3690: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F3694: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F3698: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825F369C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F36A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F36A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F36A8 size=196
    let mut pc: u32 = 0x825F36A8;
    'dispatch: loop {
        match pc {
            0x825F36A8 => {
    //   block [0x825F36A8..0x825F376C)
	// 825F36A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F36AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F36B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825F36B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F36B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F36BC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825F36C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F36C4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825F36C8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825F36CC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F36D0: 4BCCD269  bl 0x822c0938
	ctx.lr = 0x825F36D4;
	sub_822C0938(ctx, base);
	// 825F36D4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F36D8: 41820028  beq 0x825f3700
	if ctx.cr[0].eq {
	pc = 0x825F3700; continue 'dispatch;
	}
	// 825F36DC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F36E0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825F36E4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825F36E8: 392B0AD0  addi r9, r11, 0xad0
	ctx.r[9].s64 = ctx.r[11].s64 + 2768;
	// 825F36EC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825F36F0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825F36F4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825F36F8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825F36FC: 48000008  b 0x825f3704
	pc = 0x825F3704; continue 'dispatch;
	// 825F3700: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F3704: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F3708: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F370C: 409A0044  bne cr6, 0x825f3750
	if !ctx.cr[6].eq {
	pc = 0x825F3750; continue 'dispatch;
	}
	// 825F3710: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825F3714: 419A001C  beq cr6, 0x825f3730
	if ctx.cr[6].eq {
	pc = 0x825F3730; continue 'dispatch;
	}
	// 825F3718: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F371C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825F3720: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F3724: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F3728: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825F372C: 4E800421  bctrl
	ctx.lr = 0x825F3730;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825F3730: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825F3734: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825F3738: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F373C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825F3740: 816BEE80  lwz r11, -0x1180(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4480 as u32) ) } as u64;
	// 825F3744: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825F3748: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825F374C: 4BCCC8B5  bl 0x822c0000
	ctx.lr = 0x825F3750;
	sub_822C0000(ctx, base);
	// 825F3750: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F3754: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825F3758: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F375C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F3760: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825F3764: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F3768: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F3770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F3770 size=196
    let mut pc: u32 = 0x825F3770;
    'dispatch: loop {
        match pc {
            0x825F3770 => {
    //   block [0x825F3770..0x825F3834)
	// 825F3770: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F3774: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F3778: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825F377C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F3780: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F3784: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825F3788: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F378C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825F3790: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825F3794: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F3798: 4BCCD1A1  bl 0x822c0938
	ctx.lr = 0x825F379C;
	sub_822C0938(ctx, base);
	// 825F379C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F37A0: 41820028  beq 0x825f37c8
	if ctx.cr[0].eq {
	pc = 0x825F37C8; continue 'dispatch;
	}
	// 825F37A4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F37A8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825F37AC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825F37B0: 392B0AE4  addi r9, r11, 0xae4
	ctx.r[9].s64 = ctx.r[11].s64 + 2788;
	// 825F37B4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825F37B8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825F37BC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825F37C0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825F37C4: 48000008  b 0x825f37cc
	pc = 0x825F37CC; continue 'dispatch;
	// 825F37C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F37CC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F37D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F37D4: 409A0044  bne cr6, 0x825f3818
	if !ctx.cr[6].eq {
	pc = 0x825F3818; continue 'dispatch;
	}
	// 825F37D8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825F37DC: 419A001C  beq cr6, 0x825f37f8
	if ctx.cr[6].eq {
	pc = 0x825F37F8; continue 'dispatch;
	}
	// 825F37E0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F37E4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825F37E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F37EC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F37F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825F37F4: 4E800421  bctrl
	ctx.lr = 0x825F37F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825F37F8: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825F37FC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825F3800: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F3804: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825F3808: 816BEE80  lwz r11, -0x1180(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4480 as u32) ) } as u64;
	// 825F380C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825F3810: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825F3814: 4BCCC7ED  bl 0x822c0000
	ctx.lr = 0x825F3818;
	sub_822C0000(ctx, base);
	// 825F3818: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F381C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825F3820: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F3824: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F3828: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825F382C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F3830: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F3838(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F3838 size=196
    let mut pc: u32 = 0x825F3838;
    'dispatch: loop {
        match pc {
            0x825F3838 => {
    //   block [0x825F3838..0x825F38FC)
	// 825F3838: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F383C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F3840: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825F3844: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F3848: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F384C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825F3850: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F3854: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825F3858: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825F385C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F3860: 4BCCD0D9  bl 0x822c0938
	ctx.lr = 0x825F3864;
	sub_822C0938(ctx, base);
	// 825F3864: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F3868: 41820028  beq 0x825f3890
	if ctx.cr[0].eq {
	pc = 0x825F3890; continue 'dispatch;
	}
	// 825F386C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F3870: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825F3874: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825F3878: 392B0AF8  addi r9, r11, 0xaf8
	ctx.r[9].s64 = ctx.r[11].s64 + 2808;
	// 825F387C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825F3880: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825F3884: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825F3888: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825F388C: 48000008  b 0x825f3894
	pc = 0x825F3894; continue 'dispatch;
	// 825F3890: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F3894: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F3898: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F389C: 409A0044  bne cr6, 0x825f38e0
	if !ctx.cr[6].eq {
	pc = 0x825F38E0; continue 'dispatch;
	}
	// 825F38A0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825F38A4: 419A001C  beq cr6, 0x825f38c0
	if ctx.cr[6].eq {
	pc = 0x825F38C0; continue 'dispatch;
	}
	// 825F38A8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F38AC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825F38B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F38B4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F38B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825F38BC: 4E800421  bctrl
	ctx.lr = 0x825F38C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825F38C0: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825F38C4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825F38C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F38CC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825F38D0: 816BEE80  lwz r11, -0x1180(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4480 as u32) ) } as u64;
	// 825F38D4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825F38D8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825F38DC: 4BCCC725  bl 0x822c0000
	ctx.lr = 0x825F38E0;
	sub_822C0000(ctx, base);
	// 825F38E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F38E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825F38E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F38EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F38F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825F38F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F38F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F3900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F3900 size=140
    let mut pc: u32 = 0x825F3900;
    'dispatch: loop {
        match pc {
            0x825F3900 => {
    //   block [0x825F3900..0x825F398C)
	// 825F3900: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F3904: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F3908: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825F390C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F3910: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F3914: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F3918: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825F391C: 480A0A6D  bl 0x82694388
	ctx.lr = 0x825F3920;
	sub_82694388(ctx, base);
	// 825F3920: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 825F3924: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F3928: 388B6058  addi r4, r11, 0x6058
	ctx.r[4].s64 = ctx.r[11].s64 + 24664;
	// 825F392C: 488000DD  bl 0x82df3a08
	ctx.lr = 0x825F3930;
	sub_82DF3A08(ctx, base);
	// 825F3930: 3CC0000F  lis r6, 0xf
	ctx.r[6].s64 = 983040;
	// 825F3934: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825F3938: 60C64240  ori r6, r6, 0x4240
	ctx.r[6].u64 = ctx.r[6].u64 | 16960;
	// 825F393C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825F3940: 389F0044  addi r4, r31, 0x44
	ctx.r[4].s64 = ctx.r[31].s64 + 68;
	// 825F3944: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825F3948: 4BFAFA61  bl 0x825a33a8
	ctx.lr = 0x825F394C;
	sub_825A33A8(ctx, base);
	// 825F394C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825F3950: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825F3954: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F3958: 4BFAE581  bl 0x825a1ed8
	ctx.lr = 0x825F395C;
	sub_825A1ED8(ctx, base);
	// 825F395C: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 825F3960: 487FFAC9  bl 0x82df3428
	ctx.lr = 0x825F3964;
	sub_82DF3428(ctx, base);
	// 825F3964: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825F3968: 4BCD5351  bl 0x822c8cb8
	ctx.lr = 0x825F396C;
	sub_822C8CB8(ctx, base);
	// 825F396C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F3970: 487FFAB9  bl 0x82df3428
	ctx.lr = 0x825F3974;
	sub_82DF3428(ctx, base);
	// 825F3974: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 825F3978: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F397C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F3980: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825F3984: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F3988: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F3990(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F3990 size=188
    let mut pc: u32 = 0x825F3990;
    'dispatch: loop {
        match pc {
            0x825F3990 => {
    //   block [0x825F3990..0x825F3A4C)
	// 825F3990: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F3994: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F3998: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825F399C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F39A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F39A4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825F39A8: 480A1391  bl 0x82694d38
	ctx.lr = 0x825F39AC;
	sub_82694D38(ctx, base);
	// 825F39AC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F39B0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F39B4: 388B0B08  addi r4, r11, 0xb08
	ctx.r[4].s64 = ctx.r[11].s64 + 2824;
	// 825F39B8: 38A00075  li r5, 0x75
	ctx.r[5].s64 = 117;
	// 825F39BC: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825F39C0: 487FEA29  bl 0x82df23e8
	ctx.lr = 0x825F39C4;
	sub_82DF23E8(ctx, base);
	// 825F39C4: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825F39C8: 41820020  beq 0x825f39e8
	if ctx.cr[0].eq {
	pc = 0x825F39E8; continue 'dispatch;
	}
	// 825F39CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F39D0: 4881E509  bl 0x82e11ed8
	ctx.lr = 0x825F39D4;
	sub_82E11ED8(ctx, base);
	// 825F39D4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F39D8: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 825F39DC: 396B0AA4  addi r11, r11, 0xaa4
	ctx.r[11].s64 = ctx.r[11].s64 + 2724;
	// 825F39E0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F39E4: 48000008  b 0x825f39ec
	pc = 0x825F39EC; continue 'dispatch;
	// 825F39E8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825F39EC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825F39F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F39F4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F39F8: 4BFFFCB1  bl 0x825f36a8
	ctx.lr = 0x825F39FC;
	sub_825F36A8(ctx, base);
	// 825F39FC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825F3A00: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F3A04: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F3A08: 4BCCC5F9  bl 0x822c0000
	ctx.lr = 0x825F3A0C;
	sub_822C0000(ctx, base);
	// 825F3A0C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825F3A10: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 825F3A14: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825F3A18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F3A1C: 808B7084  lwz r4, 0x7084(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28804 as u32) ) } as u64;
	// 825F3A20: 4BF1CFD9  bl 0x825109f8
	ctx.lr = 0x825F3A24;
	sub_825109F8(ctx, base);
	// 825F3A24: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825F3A28: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F3A2C: 419A0008  beq cr6, 0x825f3a34
	if ctx.cr[6].eq {
	pc = 0x825F3A34; continue 'dispatch;
	}
	// 825F3A30: 4BCCCE61  bl 0x822c0890
	ctx.lr = 0x825F3A34;
	sub_822C0890(ctx, base);
	// 825F3A34: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825F3A38: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F3A3C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F3A40: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825F3A44: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F3A48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F3A50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F3A50 size=136
    let mut pc: u32 = 0x825F3A50;
    'dispatch: loop {
        match pc {
            0x825F3A50 => {
    //   block [0x825F3A50..0x825F3AD8)
	// 825F3A50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F3A54: 48BB4719  bl 0x831a816c
	ctx.lr = 0x825F3A58;
	sub_831A8130(ctx, base);
	// 825F3A58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F3A5C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825F3A60: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825F3A64: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825F3A68: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F3A6C: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 825F3A70: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 825F3A74: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 825F3A78: 487FE971  bl 0x82df23e8
	ctx.lr = 0x825F3A7C;
	sub_82DF23E8(ctx, base);
	// 825F3A7C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825F3A80: 41820024  beq 0x825f3aa4
	if ctx.cr[0].eq {
	pc = 0x825F3AA4; continue 'dispatch;
	}
	// 825F3A84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F3A88: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F3A8C: 48865BF5  bl 0x82e59680
	ctx.lr = 0x825F3A90;
	sub_82E59680(ctx, base);
	// 825F3A90: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F3A94: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 825F3A98: 396B0AB4  addi r11, r11, 0xab4
	ctx.r[11].s64 = ctx.r[11].s64 + 2740;
	// 825F3A9C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F3AA0: 48000008  b 0x825f3aa8
	pc = 0x825F3AA8; continue 'dispatch;
	// 825F3AA4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825F3AA8: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825F3AAC: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 825F3AB0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F3AB4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F3AB8: 4BFFFCB9  bl 0x825f3770
	ctx.lr = 0x825F3ABC;
	sub_825F3770(ctx, base);
	// 825F3ABC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825F3AC0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F3AC4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F3AC8: 4BCCC539  bl 0x822c0000
	ctx.lr = 0x825F3ACC;
	sub_822C0000(ctx, base);
	// 825F3ACC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825F3AD0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825F3AD4: 48BB46E8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F3AD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F3AD8 size=136
    let mut pc: u32 = 0x825F3AD8;
    'dispatch: loop {
        match pc {
            0x825F3AD8 => {
    //   block [0x825F3AD8..0x825F3B60)
	// 825F3AD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F3ADC: 48BB4691  bl 0x831a816c
	ctx.lr = 0x825F3AE0;
	sub_831A8130(ctx, base);
	// 825F3AE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F3AE4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825F3AE8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825F3AEC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825F3AF0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F3AF4: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 825F3AF8: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 825F3AFC: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 825F3B00: 487FE8E9  bl 0x82df23e8
	ctx.lr = 0x825F3B04;
	sub_82DF23E8(ctx, base);
	// 825F3B04: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825F3B08: 41820024  beq 0x825f3b2c
	if ctx.cr[0].eq {
	pc = 0x825F3B2C; continue 'dispatch;
	}
	// 825F3B0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F3B10: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F3B14: 48865B6D  bl 0x82e59680
	ctx.lr = 0x825F3B18;
	sub_82E59680(ctx, base);
	// 825F3B18: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F3B1C: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 825F3B20: 396B0A9C  addi r11, r11, 0xa9c
	ctx.r[11].s64 = ctx.r[11].s64 + 2716;
	// 825F3B24: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F3B28: 48000008  b 0x825f3b30
	pc = 0x825F3B30; continue 'dispatch;
	// 825F3B2C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825F3B30: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825F3B34: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 825F3B38: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F3B3C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F3B40: 4BFFFCF9  bl 0x825f3838
	ctx.lr = 0x825F3B44;
	sub_825F3838(ctx, base);
	// 825F3B44: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825F3B48: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F3B4C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F3B50: 4BCCC4B1  bl 0x822c0000
	ctx.lr = 0x825F3B54;
	sub_822C0000(ctx, base);
	// 825F3B54: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825F3B58: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825F3B5C: 48BB4660  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F3B60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825F3B60 size=200
    let mut pc: u32 = 0x825F3B60;
    'dispatch: loop {
        match pc {
            0x825F3B60 => {
    //   block [0x825F3B60..0x825F3C28)
	// 825F3B60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F3B64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F3B68: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F3B6C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F3B70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F3B74: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825F3B78: 389F012C  addi r4, r31, 0x12c
	ctx.r[4].s64 = ctx.r[31].s64 + 300;
	// 825F3B7C: 4BFFFED5  bl 0x825f3a50
	ctx.lr = 0x825F3B80;
	sub_825F3A50(ctx, base);
	// 825F3B80: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F3B84: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825F3B88: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825F3B8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F3B90: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825F3B94: 419A0024  beq cr6, 0x825f3bb8
	if ctx.cr[6].eq {
	pc = 0x825F3BB8; continue 'dispatch;
	}
	// 825F3B98: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825F3B9C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825F3BA0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F3BA4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825F3BA8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825F3BAC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825F3BB0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F3BB4: 4082FFE8  bne 0x825f3b9c
	if !ctx.cr[0].eq {
	pc = 0x825F3B9C; continue 'dispatch;
	}
	// 825F3BB8: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825F3BBC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F3BC0: 808BEAC0  lwz r4, -0x1540(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-5440 as u32) ) } as u64;
	// 825F3BC4: 487FFE45  bl 0x82df3a08
	ctx.lr = 0x825F3BC8;
	sub_82DF3A08(ctx, base);
	// 825F3BC8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825F3BCC: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825F3BD0: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 825F3BD4: 388A0B08  addi r4, r10, 0xb08
	ctx.r[4].s64 = ctx.r[10].s64 + 2824;
	// 825F3BD8: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 825F3BDC: 38A0004D  li r5, 0x4d
	ctx.r[5].s64 = 77;
	// 825F3BE0: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825F3BE4: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 825F3BE8: 48864FC9  bl 0x82e58bb0
	ctx.lr = 0x825F3BEC;
	sub_82E58BB0(ctx, base);
	// 825F3BEC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F3BF0: 487FF839  bl 0x82df3428
	ctx.lr = 0x825F3BF4;
	sub_82DF3428(ctx, base);
	// 825F3BF4: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825F3BF8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F3BFC: 419A0008  beq cr6, 0x825f3c04
	if ctx.cr[6].eq {
	pc = 0x825F3C04; continue 'dispatch;
	}
	// 825F3C00: 4BCCCC91  bl 0x822c0890
	ctx.lr = 0x825F3C04;
	sub_822C0890(ctx, base);
	// 825F3C04: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825F3C08: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F3C0C: 419A0008  beq cr6, 0x825f3c14
	if ctx.cr[6].eq {
	pc = 0x825F3C14; continue 'dispatch;
	}
	// 825F3C10: 4BCCCC81  bl 0x822c0890
	ctx.lr = 0x825F3C14;
	sub_822C0890(ctx, base);
	// 825F3C14: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825F3C18: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F3C1C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F3C20: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F3C24: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F3C28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825F3C28 size=200
    let mut pc: u32 = 0x825F3C28;
    'dispatch: loop {
        match pc {
            0x825F3C28 => {
    //   block [0x825F3C28..0x825F3CF0)
	// 825F3C28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F3C2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F3C30: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F3C34: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F3C38: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F3C3C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825F3C40: 389F012C  addi r4, r31, 0x12c
	ctx.r[4].s64 = ctx.r[31].s64 + 300;
	// 825F3C44: 4BFFFE95  bl 0x825f3ad8
	ctx.lr = 0x825F3C48;
	sub_825F3AD8(ctx, base);
	// 825F3C48: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F3C4C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825F3C50: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825F3C54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F3C58: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825F3C5C: 419A0024  beq cr6, 0x825f3c80
	if ctx.cr[6].eq {
	pc = 0x825F3C80; continue 'dispatch;
	}
	// 825F3C60: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825F3C64: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825F3C68: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F3C6C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825F3C70: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825F3C74: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825F3C78: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F3C7C: 4082FFE8  bne 0x825f3c64
	if !ctx.cr[0].eq {
	pc = 0x825F3C64; continue 'dispatch;
	}
	// 825F3C80: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825F3C84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F3C88: 808BEAC0  lwz r4, -0x1540(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-5440 as u32) ) } as u64;
	// 825F3C8C: 487FFD7D  bl 0x82df3a08
	ctx.lr = 0x825F3C90;
	sub_82DF3A08(ctx, base);
	// 825F3C90: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825F3C94: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825F3C98: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 825F3C9C: 388A0B08  addi r4, r10, 0xb08
	ctx.r[4].s64 = ctx.r[10].s64 + 2824;
	// 825F3CA0: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 825F3CA4: 38A0005A  li r5, 0x5a
	ctx.r[5].s64 = 90;
	// 825F3CA8: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825F3CAC: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 825F3CB0: 48864F01  bl 0x82e58bb0
	ctx.lr = 0x825F3CB4;
	sub_82E58BB0(ctx, base);
	// 825F3CB4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F3CB8: 487FF771  bl 0x82df3428
	ctx.lr = 0x825F3CBC;
	sub_82DF3428(ctx, base);
	// 825F3CBC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825F3CC0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F3CC4: 419A0008  beq cr6, 0x825f3ccc
	if ctx.cr[6].eq {
	pc = 0x825F3CCC; continue 'dispatch;
	}
	// 825F3CC8: 4BCCCBC9  bl 0x822c0890
	ctx.lr = 0x825F3CCC;
	sub_822C0890(ctx, base);
	// 825F3CCC: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825F3CD0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F3CD4: 419A0008  beq cr6, 0x825f3cdc
	if ctx.cr[6].eq {
	pc = 0x825F3CDC; continue 'dispatch;
	}
	// 825F3CD8: 4BCCCBB9  bl 0x822c0890
	ctx.lr = 0x825F3CDC;
	sub_822C0890(ctx, base);
	// 825F3CDC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825F3CE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F3CE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F3CE8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F3CEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F3CF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825F3CF0 size=220
    let mut pc: u32 = 0x825F3CF0;
    'dispatch: loop {
        match pc {
            0x825F3CF0 => {
    //   block [0x825F3CF0..0x825F3DCC)
	// 825F3CF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F3CF4: 48BB4475  bl 0x831a8168
	ctx.lr = 0x825F3CF8;
	sub_831A8130(ctx, base);
	// 825F3CF8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F3CFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F3D00: 480A05C1  bl 0x826942c0
	ctx.lr = 0x825F3D04;
	sub_826942C0(ctx, base);
	// 825F3D04: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F3D08: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825F3D0C: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 825F3D10: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825F3D14: 396B0BFC  addi r11, r11, 0xbfc
	ctx.r[11].s64 = ctx.r[11].s64 + 3068;
	// 825F3D18: 394A0BE8  addi r10, r10, 0xbe8
	ctx.r[10].s64 = ctx.r[10].s64 + 3048;
	// 825F3D1C: 93DF012C  stw r30, 0x12c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(300 as u32), ctx.r[30].u32 ) };
	// 825F3D20: 39290B9C  addi r9, r9, 0xb9c
	ctx.r[9].s64 = ctx.r[9].s64 + 2972;
	// 825F3D24: 9BC10051  stb r30, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[30].u8 ) };
	// 825F3D28: 3B800080  li r28, 0x80
	ctx.r[28].s64 = 128;
	// 825F3D2C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F3D30: 3BA000FF  li r29, 0xff
	ctx.r[29].s64 = 255;
	// 825F3D34: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 825F3D38: 9B810050  stb r28, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u8 ) };
	// 825F3D3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F3D40: 913F00E8  stw r9, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[9].u32 ) };
	// 825F3D44: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825F3D48: 9BC10052  stb r30, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[30].u8 ) };
	// 825F3D4C: 9BA10053  stb r29, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[29].u8 ) };
	// 825F3D50: 480A00B9  bl 0x82693e08
	ctx.lr = 0x825F3D54;
	sub_82693E08(ctx, base);
	// 825F3D54: 9B810054  stb r28, 0x54(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u8 ) };
	// 825F3D58: 9BA10055  stb r29, 0x55(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(85 as u32), ctx.r[29].u8 ) };
	// 825F3D5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F3D60: 9BC10056  stb r30, 0x56(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(86 as u32), ctx.r[30].u8 ) };
	// 825F3D64: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825F3D68: 9BC10057  stb r30, 0x57(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(87 as u32), ctx.r[30].u8 ) };
	// 825F3D6C: 480A00C5  bl 0x82693e30
	ctx.lr = 0x825F3D70;
	sub_82693E30(ctx, base);
	// 825F3D70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F3D74: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825F3D78: 480A00E9  bl 0x82693e60
	ctx.lr = 0x825F3D7C;
	sub_82693E60(ctx, base);
	// 825F3D7C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825F3D80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F3D84: C02B9524  lfs f1, -0x6adc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825F3D88: 480A00F1  bl 0x82693e78
	ctx.lr = 0x825F3D8C;
	sub_82693E78(ctx, base);
	// 825F3D8C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F3D90: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825F3D94: 388B0B68  addi r4, r11, 0xb68
	ctx.r[4].s64 = ctx.r[11].s64 + 2920;
	// 825F3D98: 4BCD5559  bl 0x822c92f0
	ctx.lr = 0x825F3D9C;
	sub_822C92F0(ctx, base);
	// 825F3D9C: 387F0104  addi r3, r31, 0x104
	ctx.r[3].s64 = ctx.r[31].s64 + 260;
	// 825F3DA0: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 825F3DA4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825F3DA8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825F3DAC: 4BCD5385  bl 0x822c9130
	ctx.lr = 0x825F3DB0;
	sub_822C9130(ctx, base);
	// 825F3DB0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825F3DB4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825F3DB8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825F3DBC: 4BCD5075  bl 0x822c8e30
	ctx.lr = 0x825F3DC0;
	sub_822C8E30(ctx, base);
	// 825F3DC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F3DC4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825F3DC8: 48BB43F0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F3DD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825F3DD0 size=8
    let mut pc: u32 = 0x825F3DD0;
    'dispatch: loop {
        match pc {
            0x825F3DD0 => {
    //   block [0x825F3DD0..0x825F3DD8)
	// 825F3DD0: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 825F3DD4: 48000004  b 0x825f3dd8
	sub_825F3DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F3DD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F3DD8 size=76
    let mut pc: u32 = 0x825F3DD8;
    'dispatch: loop {
        match pc {
            0x825F3DD8 => {
    //   block [0x825F3DD8..0x825F3E24)
	// 825F3DD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F3DDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F3DE0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825F3DE4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F3DE8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F3DEC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F3DF0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825F3DF4: 4BFFC5BD  bl 0x825f03b0
	ctx.lr = 0x825F3DF8;
	sub_825F03B0(ctx, base);
	// 825F3DF8: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825F3DFC: 4182000C  beq 0x825f3e08
	if ctx.cr[0].eq {
	pc = 0x825F3E08; continue 'dispatch;
	}
	// 825F3E00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F3E04: 487FE5D5  bl 0x82df23d8
	ctx.lr = 0x825F3E08;
	sub_82DF23D8(ctx, base);
	// 825F3E08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F3E0C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825F3E10: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F3E14: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F3E18: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825F3E1C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F3E20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F3E28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825F3E28 size=476
    let mut pc: u32 = 0x825F3E28;
    'dispatch: loop {
        match pc {
            0x825F3E28 => {
    //   block [0x825F3E28..0x825F4004)
	// 825F3E28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F3E2C: 48BB4339  bl 0x831a8164
	ctx.lr = 0x825F3E30;
	sub_831A8130(ctx, base);
	// 825F3E30: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 825F3E34: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F3E38: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F3E3C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825F3E40: 3BCB0B08  addi r30, r11, 0xb08
	ctx.r[30].s64 = ctx.r[11].s64 + 2824;
	// 825F3E44: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825F3E48: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F3E4C: 38A00022  li r5, 0x22
	ctx.r[5].s64 = 34;
	// 825F3E50: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 825F3E54: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825F3E58: 38600130  li r3, 0x130
	ctx.r[3].s64 = 304;
	// 825F3E5C: 487FE58D  bl 0x82df23e8
	ctx.lr = 0x825F3E60;
	sub_82DF23E8(ctx, base);
	// 825F3E60: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F3E64: 41820010  beq 0x825f3e74
	if ctx.cr[0].eq {
	pc = 0x825F3E74; continue 'dispatch;
	}
	// 825F3E68: 4BFFFE89  bl 0x825f3cf0
	ctx.lr = 0x825F3E6C;
	sub_825F3CF0(ctx, base);
	// 825F3E6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F3E70: 48000008  b 0x825f3e78
	pc = 0x825F3E78; continue 'dispatch;
	// 825F3E74: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825F3E78: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825F3E7C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F3E80: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F3E84: 4BFFF75D  bl 0x825f35e0
	ctx.lr = 0x825F3E88;
	sub_825F35E0(ctx, base);
	// 825F3E88: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825F3E8C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F3E90: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F3E94: 4BCCC16D  bl 0x822c0000
	ctx.lr = 0x825F3E98;
	sub_822C0000(ctx, base);
	// 825F3E98: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825F3E9C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F3EA0: 38A00023  li r5, 0x23
	ctx.r[5].s64 = 35;
	// 825F3EA4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825F3EA8: 4BCCC531  bl 0x822c03d8
	ctx.lr = 0x825F3EAC;
	sub_822C03D8(ctx, base);
	// 825F3EAC: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825F3EB0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825F3EB4: 418200E0  beq 0x825f3f94
	if ctx.cr[0].eq {
	pc = 0x825F3F94; continue 'dispatch;
	}
	// 825F3EB8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825F3EBC: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825F3EC0: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 825F3EC4: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 825F3EC8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825F3ECC: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825F3ED0: 396A00E8  addi r11, r10, 0xe8
	ctx.r[11].s64 = ctx.r[10].s64 + 232;
	// 825F3ED4: C00908A8  lfs f0, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825F3ED8: D3E10070  stfs f31, 0x70(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 825F3EDC: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 825F3EE0: D3E10078  stfs f31, 0x78(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 825F3EE4: D3E1007C  stfs f31, 0x7c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 825F3EE8: 409A0008  bne cr6, 0x825f3ef0
	if !ctx.cr[6].eq {
	pc = 0x825F3EF0; continue 'dispatch;
	}
	// 825F3EEC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F3EF0: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825F3EF4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825F3EF8: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 825F3EFC: 419A0024  beq cr6, 0x825f3f20
	if ctx.cr[6].eq {
	pc = 0x825F3F20; continue 'dispatch;
	}
	// 825F3F00: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825F3F04: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 825F3F08: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F3F0C: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 825F3F10: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 825F3F14: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825F3F18: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F3F1C: 4082FFE8  bne 0x825f3f04
	if !ctx.cr[0].eq {
	pc = 0x825F3F04; continue 'dispatch;
	}
	// 825F3F20: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 825F3F24: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825F3F28: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 825F3F2C: 419A0024  beq cr6, 0x825f3f50
	if ctx.cr[6].eq {
	pc = 0x825F3F50; continue 'dispatch;
	}
	// 825F3F30: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825F3F34: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825F3F38: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F3F3C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825F3F40: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825F3F44: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825F3F48: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F3F4C: 4082FFE8  bne 0x825f3f34
	if !ctx.cr[0].eq {
	pc = 0x825F3F34; continue 'dispatch;
	}
	// 825F3F50: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825F3F54: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 825F3F58: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825F3F5C: C02B7590  lfs f1, 0x7590(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30096 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825F3F60: 48888CE1  bl 0x82e7cc40
	ctx.lr = 0x825F3F64;
	sub_82E7CC40(ctx, base);
	// 825F3F64: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 825F3F68: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825F3F6C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825F3F70: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825F3F74: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825F3F78: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825F3F7C: 481A4FB5  bl 0x82798f30
	ctx.lr = 0x825F3F80;
	sub_82798F30(ctx, base);
	// 825F3F80: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825F3F84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F3F88: 481A76E1  bl 0x8279b668
	ctx.lr = 0x825F3F8C;
	sub_8279B668(ctx, base);
	// 825F3F8C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F3F90: 48000008  b 0x825f3f98
	pc = 0x825F3F98; continue 'dispatch;
	// 825F3F94: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825F3F98: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825F3F9C: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 825F3FA0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F3FA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F3FA8: 4BFA3CA9  bl 0x82597c50
	ctx.lr = 0x825F3FAC;
	sub_82597C50(ctx, base);
	// 825F3FAC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825F3FB0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F3FB4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F3FB8: 4BCCC049  bl 0x822c0000
	ctx.lr = 0x825F3FBC;
	sub_822C0000(ctx, base);
	// 825F3FBC: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825F3FC0: 41820024  beq 0x825f3fe4
	if ctx.cr[0].eq {
	pc = 0x825F3FE4; continue 'dispatch;
	}
	// 825F3FC4: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 825F3FC8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F3FCC: 419A0008  beq cr6, 0x825f3fd4
	if ctx.cr[6].eq {
	pc = 0x825F3FD4; continue 'dispatch;
	}
	// 825F3FD0: 4BCCC8C1  bl 0x822c0890
	ctx.lr = 0x825F3FD4;
	sub_822C0890(ctx, base);
	// 825F3FD4: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 825F3FD8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F3FDC: 419A0008  beq cr6, 0x825f3fe4
	if ctx.cr[6].eq {
	pc = 0x825F3FE4; continue 'dispatch;
	}
	// 825F3FE0: 4BCCC8B1  bl 0x822c0890
	ctx.lr = 0x825F3FE4;
	sub_822C0890(ctx, base);
	// 825F3FE4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825F3FE8: 419A000C  beq cr6, 0x825f3ff4
	if ctx.cr[6].eq {
	pc = 0x825F3FF4; continue 'dispatch;
	}
	// 825F3FEC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825F3FF0: 4BCCC8A1  bl 0x822c0890
	ctx.lr = 0x825F3FF4;
	sub_822C0890(ctx, base);
	// 825F3FF4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825F3FF8: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 825F3FFC: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 825F4000: 48BB41B4  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F4008(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825F4008 size=20
    let mut pc: u32 = 0x825F4008;
    'dispatch: loop {
        match pc {
            0x825F4008 => {
    //   block [0x825F4008..0x825F401C)
	// 825F4008: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825F400C: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 825F4010: 816B0084  lwz r11, 0x84(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(132 as u32) ) } as u64;
	// 825F4014: 388B0010  addi r4, r11, 0x10
	ctx.r[4].s64 = ctx.r[11].s64 + 16;
	// 825F4018: 4BF1DD80  b 0x82511d98
	sub_82511D98(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F4020(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F4020 size=196
    let mut pc: u32 = 0x825F4020;
    'dispatch: loop {
        match pc {
            0x825F4020 => {
    //   block [0x825F4020..0x825F40E4)
	// 825F4020: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F4024: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F4028: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825F402C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F4030: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F4034: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825F4038: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F403C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825F4040: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825F4044: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F4048: 4BCCC8F1  bl 0x822c0938
	ctx.lr = 0x825F404C;
	sub_822C0938(ctx, base);
	// 825F404C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F4050: 41820028  beq 0x825f4078
	if ctx.cr[0].eq {
	pc = 0x825F4078; continue 'dispatch;
	}
	// 825F4054: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F4058: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825F405C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825F4060: 392B0C44  addi r9, r11, 0xc44
	ctx.r[9].s64 = ctx.r[11].s64 + 3140;
	// 825F4064: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825F4068: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825F406C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825F4070: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825F4074: 48000008  b 0x825f407c
	pc = 0x825F407C; continue 'dispatch;
	// 825F4078: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F407C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F4080: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F4084: 409A0044  bne cr6, 0x825f40c8
	if !ctx.cr[6].eq {
	pc = 0x825F40C8; continue 'dispatch;
	}
	// 825F4088: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825F408C: 419A001C  beq cr6, 0x825f40a8
	if ctx.cr[6].eq {
	pc = 0x825F40A8; continue 'dispatch;
	}
	// 825F4090: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F4094: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825F4098: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F409C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F40A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825F40A4: 4E800421  bctrl
	ctx.lr = 0x825F40A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825F40A8: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825F40AC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825F40B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F40B4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825F40B8: 816BF058  lwz r11, -0xfa8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4008 as u32) ) } as u64;
	// 825F40BC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825F40C0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825F40C4: 4BCCBF3D  bl 0x822c0000
	ctx.lr = 0x825F40C8;
	sub_822C0000(ctx, base);
	// 825F40C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F40CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825F40D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F40D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F40D8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825F40DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F40E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F40E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F40E8 size=164
    let mut pc: u32 = 0x825F40E8;
    'dispatch: loop {
        match pc {
            0x825F40E8 => {
    //   block [0x825F40E8..0x825F418C)
	// 825F40E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F40EC: 48BB4079  bl 0x831a8164
	ctx.lr = 0x825F40F0;
	sub_831A8130(ctx, base);
	// 825F40F0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F40F4: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 825F40F8: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 825F40FC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825F4100: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825F4104: 38ABBA80  addi r5, r11, -0x4580
	ctx.r[5].s64 = ctx.r[11].s64 + -17792;
	// 825F4108: 388A6910  addi r4, r10, 0x6910
	ctx.r[4].s64 = ctx.r[10].s64 + 26896;
	// 825F410C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F4110: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 825F4114: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 825F4118: 4BF1E149  bl 0x82512260
	ctx.lr = 0x825F411C;
	sub_82512260(ctx, base);
	// 825F411C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F4120: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825F4124: 396BA214  addi r11, r11, -0x5dec
	ctx.r[11].s64 = ctx.r[11].s64 + -24044;
	// 825F4128: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 825F412C: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 825F4130: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 825F4134: 394A0CBC  addi r10, r10, 0xcbc
	ctx.r[10].s64 = ctx.r[10].s64 + 3260;
	// 825F4138: 39290CA8  addi r9, r9, 0xca8
	ctx.r[9].s64 = ctx.r[9].s64 + 3240;
	// 825F413C: 39080C5C  addi r8, r8, 0xc5c
	ctx.r[8].s64 = ctx.r[8].s64 + 3164;
	// 825F4140: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825F4144: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F4148: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 825F414C: 911F00E4  stw r8, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[8].u32 ) };
	// 825F4150: 387F0140  addi r3, r31, 0x140
	ctx.r[3].s64 = ctx.r[31].s64 + 320;
	// 825F4154: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 825F4158: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825F415C: 917F00EC  stw r11, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 825F4160: 917F00F0  stw r11, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 825F4164: 917F00F4  stw r11, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 825F4168: 487FFA99  bl 0x82df3c00
	ctx.lr = 0x825F416C;
	sub_82DF3C00(ctx, base);
	// 825F416C: 387F0144  addi r3, r31, 0x144
	ctx.r[3].s64 = ctx.r[31].s64 + 324;
	// 825F4170: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825F4174: 487FFA8D  bl 0x82df3c00
	ctx.lr = 0x825F4178;
	sub_82DF3C00(ctx, base);
	// 825F4178: 939F0148  stw r28, 0x148(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(328 as u32), ctx.r[28].u32 ) };
	// 825F417C: 9B7F014C  stb r27, 0x14c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(332 as u32), ctx.r[27].u8 ) };
	// 825F4180: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F4184: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825F4188: 48BB402C  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F4190(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825F4190 size=8
    let mut pc: u32 = 0x825F4190;
    'dispatch: loop {
        match pc {
            0x825F4190 => {
    //   block [0x825F4190..0x825F4198)
	// 825F4190: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 825F4194: 48000104  b 0x825f4298
	sub_825F4298(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F4198(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825F4198 size=8
    let mut pc: u32 = 0x825F4198;
    'dispatch: loop {
        match pc {
            0x825F4198 => {
    //   block [0x825F4198..0x825F41A0)
	// 825F4198: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 825F419C: 480000FC  b 0x825f4298
	sub_825F4298(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F41A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F41A0 size=248
    let mut pc: u32 = 0x825F41A0;
    'dispatch: loop {
        match pc {
            0x825F41A0 => {
    //   block [0x825F41A0..0x825F4298)
	// 825F41A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F41A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F41A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825F41AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F41B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F41B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F41B8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F41BC: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825F41C0: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 825F41C4: 396B0CBC  addi r11, r11, 0xcbc
	ctx.r[11].s64 = ctx.r[11].s64 + 3260;
	// 825F41C8: 394A0CA8  addi r10, r10, 0xca8
	ctx.r[10].s64 = ctx.r[10].s64 + 3240;
	// 825F41CC: 39290C5C  addi r9, r9, 0xc5c
	ctx.r[9].s64 = ctx.r[9].s64 + 3164;
	// 825F41D0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F41D4: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 825F41D8: 3BDF00E4  addi r30, r31, 0xe4
	ctx.r[30].s64 = ctx.r[31].s64 + 228;
	// 825F41DC: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 825F41E0: 815F00E8  lwz r10, 0xe8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 825F41E4: 817F00EC  lwz r11, 0xec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 825F41E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F41EC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825F41F0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825F41F4: 419A0024  beq cr6, 0x825f4218
	if ctx.cr[6].eq {
	pc = 0x825F4218; continue 'dispatch;
	}
	// 825F41F8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825F41FC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825F4200: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F4204: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825F4208: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825F420C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825F4210: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F4214: 4082FFE8  bne 0x825f41fc
	if !ctx.cr[0].eq {
	pc = 0x825F41FC; continue 'dispatch;
	}
	// 825F4218: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825F421C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 825F4220: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825F4224: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F4228: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 825F422C: 4BF1BE95  bl 0x825100c0
	ctx.lr = 0x825F4230;
	sub_825100C0(ctx, base);
	// 825F4230: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825F4234: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F4238: 419A0008  beq cr6, 0x825f4240
	if ctx.cr[6].eq {
	pc = 0x825F4240; continue 'dispatch;
	}
	// 825F423C: 4BCCC655  bl 0x822c0890
	ctx.lr = 0x825F4240;
	sub_822C0890(ctx, base);
	// 825F4240: 387F0144  addi r3, r31, 0x144
	ctx.r[3].s64 = ctx.r[31].s64 + 324;
	// 825F4244: 487FF1E5  bl 0x82df3428
	ctx.lr = 0x825F4248;
	sub_82DF3428(ctx, base);
	// 825F4248: 387F0140  addi r3, r31, 0x140
	ctx.r[3].s64 = ctx.r[31].s64 + 320;
	// 825F424C: 487FF1DD  bl 0x82df3428
	ctx.lr = 0x825F4250;
	sub_82DF3428(ctx, base);
	// 825F4250: 807F00F4  lwz r3, 0xf4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 825F4254: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F4258: 419A0008  beq cr6, 0x825f4260
	if ctx.cr[6].eq {
	pc = 0x825F4260; continue 'dispatch;
	}
	// 825F425C: 4BCCC635  bl 0x822c0890
	ctx.lr = 0x825F4260;
	sub_822C0890(ctx, base);
	// 825F4260: 807F00EC  lwz r3, 0xec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 825F4264: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F4268: 419A0008  beq cr6, 0x825f4270
	if ctx.cr[6].eq {
	pc = 0x825F4270; continue 'dispatch;
	}
	// 825F426C: 4BCCC625  bl 0x822c0890
	ctx.lr = 0x825F4270;
	sub_822C0890(ctx, base);
	// 825F4270: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F4274: 481B33E5  bl 0x827a7658
	ctx.lr = 0x825F4278;
	sub_827A7658(ctx, base);
	// 825F4278: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F427C: 4BD5B0D5  bl 0x8234f350
	ctx.lr = 0x825F4280;
	sub_8234F350(ctx, base);
	// 825F4280: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825F4284: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F4288: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F428C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825F4290: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F4294: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F4298(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F4298 size=76
    let mut pc: u32 = 0x825F4298;
    'dispatch: loop {
        match pc {
            0x825F4298 => {
    //   block [0x825F4298..0x825F42E4)
	// 825F4298: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F429C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F42A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825F42A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F42A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F42AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F42B0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825F42B4: 4BFFFEED  bl 0x825f41a0
	ctx.lr = 0x825F42B8;
	sub_825F41A0(ctx, base);
	// 825F42B8: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825F42BC: 4182000C  beq 0x825f42c8
	if ctx.cr[0].eq {
	pc = 0x825F42C8; continue 'dispatch;
	}
	// 825F42C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F42C4: 487FE115  bl 0x82df23d8
	ctx.lr = 0x825F42C8;
	sub_82DF23D8(ctx, base);
	// 825F42C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F42CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825F42D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F42D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F42D8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825F42DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F42E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F42E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825F42E8 size=740
    let mut pc: u32 = 0x825F42E8;
    'dispatch: loop {
        match pc {
            0x825F42E8 => {
    //   block [0x825F42E8..0x825F45CC)
	// 825F42E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F42EC: 48BB3E71  bl 0x831a815c
	ctx.lr = 0x825F42F0;
	sub_831A8130(ctx, base);
	// 825F42F0: 9421FE40  stwu r1, -0x1c0(r1)
	ea = ctx.r[1].u32.wrapping_add(-448 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F42F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F42F8: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825F42FC: 7CD93378  mr r25, r6
	ctx.r[25].u64 = ctx.r[6].u64;
	// 825F4300: 4BF1D6D9  bl 0x825119d8
	ctx.lr = 0x825F4304;
	sub_825119D8(ctx, base);
	// 825F4304: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825F4308: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 825F430C: 409A0008  bne cr6, 0x825f4314
	if !ctx.cr[6].eq {
	pc = 0x825F4314; continue 'dispatch;
	}
	// 825F4310: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825F4314: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F4318: 4BF14489  bl 0x825087a0
	ctx.lr = 0x825F431C;
	sub_825087A0(ctx, base);
	// 825F431C: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 825F4320: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F4324: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 825F4328: 487FF6E1  bl 0x82df3a08
	ctx.lr = 0x825F432C;
	sub_82DF3A08(ctx, base);
	// 825F432C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825F4330: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825F4334: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F4338: 4BF14449  bl 0x82508780
	ctx.lr = 0x825F433C;
	sub_82508780(ctx, base);
	// 825F433C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F4340: 487FF0E9  bl 0x82df3428
	ctx.lr = 0x825F4344;
	sub_82DF3428(ctx, base);
	// 825F4344: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F4348: 80990000  lwz r4, 0(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F434C: 4883679D  bl 0x82e2aae8
	ctx.lr = 0x825F4350;
	sub_82E2AAE8(ctx, base);
	// 825F4350: 3BBF0140  addi r29, r31, 0x140
	ctx.r[29].s64 = ctx.r[31].s64 + 320;
	// 825F4354: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F4358: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825F435C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825F4360: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825F4364: 4883AB0D  bl 0x82e2ee70
	ctx.lr = 0x825F4368;
	sub_82E2EE70(ctx, base);
	// 825F4368: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F436C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F4370: 388B0CF8  addi r4, r11, 0xcf8
	ctx.r[4].s64 = ctx.r[11].s64 + 3320;
	// 825F4374: 38A0006E  li r5, 0x6e
	ctx.r[5].s64 = 110;
	// 825F4378: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 825F437C: 487FE06D  bl 0x82df23e8
	ctx.lr = 0x825F4380;
	sub_82DF23E8(ctx, base);
	// 825F4380: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F4384: 41820014  beq 0x825f4398
	if ctx.cr[0].eq {
	pc = 0x825F4398; continue 'dispatch;
	}
	// 825F4388: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825F438C: 48822505  bl 0x82e16890
	ctx.lr = 0x825F4390;
	sub_82E16890(ctx, base);
	// 825F4390: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825F4394: 48000008  b 0x825f439c
	pc = 0x825F439C; continue 'dispatch;
	// 825F4398: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825F439C: 3BDF00E8  addi r30, r31, 0xe8
	ctx.r[30].s64 = ctx.r[31].s64 + 232;
	// 825F43A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F43A4: 4BD68FCD  bl 0x8235d370
	ctx.lr = 0x825F43A8;
	sub_8235D370(ctx, base);
	// 825F43A8: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 825F43AC: 815F00E8  lwz r10, 0xe8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 825F43B0: 3B400010  li r26, 0x10
	ctx.r[26].s64 = 16;
	// 825F43B4: 396B6880  addi r11, r11, 0x6880
	ctx.r[11].s64 = ctx.r[11].s64 + 26752;
	// 825F43B8: 3B600020  li r27, 0x20
	ctx.r[27].s64 = 32;
	// 825F43BC: 3B800030  li r28, 0x30
	ctx.r[28].s64 = 48;
	// 825F43C0: 806A0084  lwz r3, 0x84(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(132 as u32) ) } as u64;
	// 825F43C4: 13FA5C07  vcmpneb. (lvlx128) v31, v26, v11
	tmp.u32 = ctx.r[26].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 825F43C8: 13DB5C07  vcmpneb. (lvlx128) v30, v27, v11
	tmp.u32 = ctx.r[27].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 825F43CC: 13BC5C07  vcmpneb. (lvlx128) v29, v28, v11
	tmp.u32 = ctx.r[28].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 825F43D0: 13805C07  vcmpneb. (lvlx128) v28, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 825F43D4: 39630010  addi r11, r3, 0x10
	ctx.r[11].s64 = ctx.r[3].s64 + 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F45D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825F45D0 size=524
    let mut pc: u32 = 0x825F45D0;
    'dispatch: loop {
        match pc {
            0x825F45D0 => {
    //   block [0x825F45D0..0x825F47DC)
	// 825F45D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F45D4: 48BB3B91  bl 0x831a8164
	ctx.lr = 0x825F45D8;
	sub_831A8130(ctx, base);
	// 825F45D8: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F45DC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825F45E0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F45E4: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 825F45E8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825F45EC: 3BCB0CF8  addi r30, r11, 0xcf8
	ctx.r[30].s64 = ctx.r[11].s64 + 3320;
	// 825F45F0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F45F4: 38A00041  li r5, 0x41
	ctx.r[5].s64 = 65;
	// 825F45F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825F45FC: 38600150  li r3, 0x150
	ctx.r[3].s64 = 336;
	// 825F4600: 487FDDE9  bl 0x82df23e8
	ctx.lr = 0x825F4604;
	sub_82DF23E8(ctx, base);
	// 825F4604: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825F4608: 4182004C  beq 0x825f4654
	if ctx.cr[0].eq {
	pc = 0x825F4654; continue 'dispatch;
	}
	// 825F460C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F4610: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825F4614: 3BAB0D48  addi r29, r11, 0xd48
	ctx.r[29].s64 = ctx.r[11].s64 + 3400;
	// 825F4618: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825F461C: 487FF3ED  bl 0x82df3a08
	ctx.lr = 0x825F4620;
	sub_82DF3A08(ctx, base);
	// 825F4620: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825F4624: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F4628: 487FF3E1  bl 0x82df3a08
	ctx.lr = 0x825F462C;
	sub_82DF3A08(ctx, base);
	// 825F462C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825F4630: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 825F4634: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825F4638: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825F463C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F4640: 80CB6744  lwz r6, 0x6744(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26436 as u32) ) } as u64;
	// 825F4644: 3BA00003  li r29, 3
	ctx.r[29].s64 = 3;
	// 825F4648: 4BFFFAA1  bl 0x825f40e8
	ctx.lr = 0x825F464C;
	sub_825F40E8(ctx, base);
	// 825F464C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F4650: 48000008  b 0x825f4658
	pc = 0x825F4658; continue 'dispatch;
	// 825F4654: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825F4658: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 825F465C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F4660: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 825F4664: 4BFFF9BD  bl 0x825f4020
	ctx.lr = 0x825F4668;
	sub_825F4020(ctx, base);
	// 825F4668: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825F466C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F4670: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 825F4674: 4BCCB98D  bl 0x822c0000
	ctx.lr = 0x825F4678;
	sub_822C0000(ctx, base);
	// 825F4678: 57AB07BD  rlwinm. r11, r29, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825F467C: 41820010  beq 0x825f468c
	if ctx.cr[0].eq {
	pc = 0x825F468C; continue 'dispatch;
	}
	// 825F4680: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F4684: 57BD07FA  rlwinm r29, r29, 0, 0x1f, 0x1d
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 825F4688: 487FEDA1  bl 0x82df3428
	ctx.lr = 0x825F468C;
	sub_82DF3428(ctx, base);
	// 825F468C: 57AB07FF  clrlwi. r11, r29, 0x1f
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825F4690: 41820010  beq 0x825f46a0
	if ctx.cr[0].eq {
	pc = 0x825F46A0; continue 'dispatch;
	}
	// 825F4694: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825F4698: 57BD003C  rlwinm r29, r29, 0, 0, 0x1e
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 825F469C: 487FED8D  bl 0x82df3428
	ctx.lr = 0x825F46A0;
	sub_82DF3428(ctx, base);
	// 825F46A0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825F46A4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F46A8: 38A00042  li r5, 0x42
	ctx.r[5].s64 = 66;
	// 825F46AC: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825F46B0: 4BCCBD29  bl 0x822c03d8
	ctx.lr = 0x825F46B4;
	sub_822C03D8(ctx, base);
	// 825F46B4: 83810064  lwz r28, 0x64(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825F46B8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825F46BC: 418200B4  beq 0x825f4770
	if ctx.cr[0].eq {
	pc = 0x825F4770; continue 'dispatch;
	}
	// 825F46C0: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825F46C4: 63BD0004  ori r29, r29, 4
	ctx.r[29].u64 = ctx.r[29].u64 | 4;
	// 825F46C8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825F46CC: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 825F46D0: 409A0008  bne cr6, 0x825f46d8
	if !ctx.cr[6].eq {
	pc = 0x825F46D8; continue 'dispatch;
	}
	// 825F46D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F46D8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825F46DC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 825F46E0: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 825F46E4: 419A0024  beq cr6, 0x825f4708
	if ctx.cr[6].eq {
	pc = 0x825F4708; continue 'dispatch;
	}
	// 825F46E8: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 825F46EC: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 825F46F0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F46F4: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 825F46F8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 825F46FC: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825F4700: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F4704: 4082FFE8  bne 0x825f46ec
	if !ctx.cr[0].eq {
	pc = 0x825F46EC; continue 'dispatch;
	}
	// 825F4708: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825F470C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 825F4710: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 825F4714: 419A0024  beq cr6, 0x825f4738
	if ctx.cr[6].eq {
	pc = 0x825F4738; continue 'dispatch;
	}
	// 825F4718: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 825F471C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825F4720: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F4724: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825F4728: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825F472C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825F4730: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F4734: 4082FFE8  bne 0x825f471c
	if !ctx.cr[0].eq {
	pc = 0x825F471C; continue 'dispatch;
	}
	// 825F4738: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825F473C: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 825F4740: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825F4744: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 825F4748: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825F474C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825F4750: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825F4754: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825F4758: 481A47D9  bl 0x82798f30
	ctx.lr = 0x825F475C;
	sub_82798F30(ctx, base);
	// 825F475C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825F4760: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F4764: 481A6F05  bl 0x8279b668
	ctx.lr = 0x825F4768;
	sub_8279B668(ctx, base);
	// 825F4768: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F476C: 48000008  b 0x825f4774
	pc = 0x825F4774; continue 'dispatch;
	// 825F4770: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825F4774: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825F4778: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 825F477C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F4780: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F4784: 4BFA34CD  bl 0x82597c50
	ctx.lr = 0x825F4788;
	sub_82597C50(ctx, base);
	// 825F4788: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825F478C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F4790: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F4794: 4BCCB86D  bl 0x822c0000
	ctx.lr = 0x825F4798;
	sub_822C0000(ctx, base);
	// 825F4798: 57AB077B  rlwinm. r11, r29, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825F479C: 41820024  beq 0x825f47c0
	if ctx.cr[0].eq {
	pc = 0x825F47C0; continue 'dispatch;
	}
	// 825F47A0: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 825F47A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F47A8: 419A0008  beq cr6, 0x825f47b0
	if ctx.cr[6].eq {
	pc = 0x825F47B0; continue 'dispatch;
	}
	// 825F47AC: 4BCCC0E5  bl 0x822c0890
	ctx.lr = 0x825F47B0;
	sub_822C0890(ctx, base);
	// 825F47B0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825F47B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F47B8: 419A0008  beq cr6, 0x825f47c0
	if ctx.cr[6].eq {
	pc = 0x825F47C0; continue 'dispatch;
	}
	// 825F47BC: 4BCCC0D5  bl 0x822c0890
	ctx.lr = 0x825F47C0;
	sub_822C0890(ctx, base);
	// 825F47C0: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 825F47C4: 419A000C  beq cr6, 0x825f47d0
	if ctx.cr[6].eq {
	pc = 0x825F47D0; continue 'dispatch;
	}
	// 825F47C8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825F47CC: 4BCCC0C5  bl 0x822c0890
	ctx.lr = 0x825F47D0;
	sub_822C0890(ctx, base);
	// 825F47D0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825F47D4: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 825F47D8: 48BB39DC  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F47E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825F47E0 size=524
    let mut pc: u32 = 0x825F47E0;
    'dispatch: loop {
        match pc {
            0x825F47E0 => {
    //   block [0x825F47E0..0x825F49EC)
	// 825F47E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F47E4: 48BB3981  bl 0x831a8164
	ctx.lr = 0x825F47E8;
	sub_831A8130(ctx, base);
	// 825F47E8: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F47EC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825F47F0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F47F4: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 825F47F8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825F47FC: 3BCB0CF8  addi r30, r11, 0xcf8
	ctx.r[30].s64 = ctx.r[11].s64 + 3320;
	// 825F4800: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F4804: 38A0004C  li r5, 0x4c
	ctx.r[5].s64 = 76;
	// 825F4808: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825F480C: 38600150  li r3, 0x150
	ctx.r[3].s64 = 336;
	// 825F4810: 487FDBD9  bl 0x82df23e8
	ctx.lr = 0x825F4814;
	sub_82DF23E8(ctx, base);
	// 825F4814: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825F4818: 4182004C  beq 0x825f4864
	if ctx.cr[0].eq {
	pc = 0x825F4864; continue 'dispatch;
	}
	// 825F481C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825F4820: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825F4824: 3BABCE7C  addi r29, r11, -0x3184
	ctx.r[29].s64 = ctx.r[11].s64 + -12676;
	// 825F4828: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825F482C: 487FF1DD  bl 0x82df3a08
	ctx.lr = 0x825F4830;
	sub_82DF3A08(ctx, base);
	// 825F4830: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825F4834: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F4838: 487FF1D1  bl 0x82df3a08
	ctx.lr = 0x825F483C;
	sub_82DF3A08(ctx, base);
	// 825F483C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825F4840: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825F4844: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825F4848: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825F484C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F4850: 80CB6744  lwz r6, 0x6744(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26436 as u32) ) } as u64;
	// 825F4854: 3BA00003  li r29, 3
	ctx.r[29].s64 = 3;
	// 825F4858: 4BFFF891  bl 0x825f40e8
	ctx.lr = 0x825F485C;
	sub_825F40E8(ctx, base);
	// 825F485C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F4860: 48000008  b 0x825f4868
	pc = 0x825F4868; continue 'dispatch;
	// 825F4864: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825F4868: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 825F486C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F4870: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 825F4874: 4BFFF7AD  bl 0x825f4020
	ctx.lr = 0x825F4878;
	sub_825F4020(ctx, base);
	// 825F4878: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825F487C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F4880: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 825F4884: 4BCCB77D  bl 0x822c0000
	ctx.lr = 0x825F4888;
	sub_822C0000(ctx, base);
	// 825F4888: 57AB07BD  rlwinm. r11, r29, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825F488C: 41820010  beq 0x825f489c
	if ctx.cr[0].eq {
	pc = 0x825F489C; continue 'dispatch;
	}
	// 825F4890: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F4894: 57BD07FA  rlwinm r29, r29, 0, 0x1f, 0x1d
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 825F4898: 487FEB91  bl 0x82df3428
	ctx.lr = 0x825F489C;
	sub_82DF3428(ctx, base);
	// 825F489C: 57AB07FF  clrlwi. r11, r29, 0x1f
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825F48A0: 41820010  beq 0x825f48b0
	if ctx.cr[0].eq {
	pc = 0x825F48B0; continue 'dispatch;
	}
	// 825F48A4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825F48A8: 57BD003C  rlwinm r29, r29, 0, 0, 0x1e
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 825F48AC: 487FEB7D  bl 0x82df3428
	ctx.lr = 0x825F48B0;
	sub_82DF3428(ctx, base);
	// 825F48B0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825F48B4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F48B8: 38A0004D  li r5, 0x4d
	ctx.r[5].s64 = 77;
	// 825F48BC: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825F48C0: 4BCCBB19  bl 0x822c03d8
	ctx.lr = 0x825F48C4;
	sub_822C03D8(ctx, base);
	// 825F48C4: 83810064  lwz r28, 0x64(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825F48C8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825F48CC: 418200B4  beq 0x825f4980
	if ctx.cr[0].eq {
	pc = 0x825F4980; continue 'dispatch;
	}
	// 825F48D0: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825F48D4: 63BD0004  ori r29, r29, 4
	ctx.r[29].u64 = ctx.r[29].u64 | 4;
	// 825F48D8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825F48DC: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 825F48E0: 409A0008  bne cr6, 0x825f48e8
	if !ctx.cr[6].eq {
	pc = 0x825F48E8; continue 'dispatch;
	}
	// 825F48E4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F48E8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825F48EC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 825F48F0: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 825F48F4: 419A0024  beq cr6, 0x825f4918
	if ctx.cr[6].eq {
	pc = 0x825F4918; continue 'dispatch;
	}
	// 825F48F8: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 825F48FC: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 825F4900: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F4904: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 825F4908: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 825F490C: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825F4910: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F4914: 4082FFE8  bne 0x825f48fc
	if !ctx.cr[0].eq {
	pc = 0x825F48FC; continue 'dispatch;
	}
	// 825F4918: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825F491C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 825F4920: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 825F4924: 419A0024  beq cr6, 0x825f4948
	if ctx.cr[6].eq {
	pc = 0x825F4948; continue 'dispatch;
	}
	// 825F4928: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 825F492C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825F4930: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F4934: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825F4938: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825F493C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825F4940: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F4944: 4082FFE8  bne 0x825f492c
	if !ctx.cr[0].eq {
	pc = 0x825F492C; continue 'dispatch;
	}
	// 825F4948: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825F494C: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 825F4950: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825F4954: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 825F4958: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825F495C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825F4960: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825F4964: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825F4968: 481A45C9  bl 0x82798f30
	ctx.lr = 0x825F496C;
	sub_82798F30(ctx, base);
	// 825F496C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825F4970: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F4974: 481A6CF5  bl 0x8279b668
	ctx.lr = 0x825F4978;
	sub_8279B668(ctx, base);
	// 825F4978: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F497C: 48000008  b 0x825f4984
	pc = 0x825F4984; continue 'dispatch;
	// 825F4980: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825F4984: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825F4988: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 825F498C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F4990: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F4994: 4BFA32BD  bl 0x82597c50
	ctx.lr = 0x825F4998;
	sub_82597C50(ctx, base);
	// 825F4998: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825F499C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F49A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F49A4: 4BCCB65D  bl 0x822c0000
	ctx.lr = 0x825F49A8;
	sub_822C0000(ctx, base);
	// 825F49A8: 57AB077B  rlwinm. r11, r29, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825F49AC: 41820024  beq 0x825f49d0
	if ctx.cr[0].eq {
	pc = 0x825F49D0; continue 'dispatch;
	}
	// 825F49B0: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 825F49B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F49B8: 419A0008  beq cr6, 0x825f49c0
	if ctx.cr[6].eq {
	pc = 0x825F49C0; continue 'dispatch;
	}
	// 825F49BC: 4BCCBED5  bl 0x822c0890
	ctx.lr = 0x825F49C0;
	sub_822C0890(ctx, base);
	// 825F49C0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825F49C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F49C8: 419A0008  beq cr6, 0x825f49d0
	if ctx.cr[6].eq {
	pc = 0x825F49D0; continue 'dispatch;
	}
	// 825F49CC: 4BCCBEC5  bl 0x822c0890
	ctx.lr = 0x825F49D0;
	sub_822C0890(ctx, base);
	// 825F49D0: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 825F49D4: 419A000C  beq cr6, 0x825f49e0
	if ctx.cr[6].eq {
	pc = 0x825F49E0; continue 'dispatch;
	}
	// 825F49D8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825F49DC: 4BCCBEB5  bl 0x822c0890
	ctx.lr = 0x825F49E0;
	sub_822C0890(ctx, base);
	// 825F49E0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825F49E4: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 825F49E8: 48BB37CC  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F49F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825F49F0 size=564
    let mut pc: u32 = 0x825F49F0;
    'dispatch: loop {
        match pc {
            0x825F49F0 => {
    //   block [0x825F49F0..0x825F4C24)
	// 825F49F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F49F4: 48BB3771  bl 0x831a8164
	ctx.lr = 0x825F49F8;
	sub_831A8130(ctx, base);
	// 825F49F8: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F49FC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825F4A00: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F4A04: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 825F4A08: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825F4A0C: 3BCB0CF8  addi r30, r11, 0xcf8
	ctx.r[30].s64 = ctx.r[11].s64 + 3320;
	// 825F4A10: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F4A14: 38A00024  li r5, 0x24
	ctx.r[5].s64 = 36;
	// 825F4A18: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825F4A1C: 38600150  li r3, 0x150
	ctx.r[3].s64 = 336;
	// 825F4A20: 487FD9C9  bl 0x82df23e8
	ctx.lr = 0x825F4A24;
	sub_82DF23E8(ctx, base);
	// 825F4A24: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825F4A28: 41820074  beq 0x825f4a9c
	if ctx.cr[0].eq {
	pc = 0x825F4A9C; continue 'dispatch;
	}
	// 825F4A2C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F4A30: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825F4A34: 388B0D54  addi r4, r11, 0xd54
	ctx.r[4].s64 = ctx.r[11].s64 + 3412;
	// 825F4A38: 487FEFD1  bl 0x82df3a08
	ctx.lr = 0x825F4A3C;
	sub_82DF3A08(ctx, base);
	// 825F4A3C: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 825F4A40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F4A44: 388B4768  addi r4, r11, 0x4768
	ctx.r[4].s64 = ctx.r[11].s64 + 18280;
	// 825F4A48: 487FEFC1  bl 0x82df3a08
	ctx.lr = 0x825F4A4C;
	sub_82DF3A08(ctx, base);
	// 825F4A4C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825F4A50: 3BA00003  li r29, 3
	ctx.r[29].s64 = 3;
	// 825F4A54: 4BCF046D  bl 0x822e4ec0
	ctx.lr = 0x825F4A58;
	sub_822E4EC0(ctx, base);
	// 825F4A58: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825F4A5C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825F4A60: 4BCF0461  bl 0x822e4ec0
	ctx.lr = 0x825F4A64;
	sub_822E4EC0(ctx, base);
	// 825F4A64: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 825F4A68: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825F4A6C: E8BC0000  ld r5, 0(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	// 825F4A70: E88A0000  ld r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 825F4A74: 806B674C  lwz r3, 0x674c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26444 as u32) ) } as u64;
	// 825F4A78: 4BE978F9  bl 0x8248c370
	ctx.lr = 0x825F4A7C;
	sub_8248C370(ctx, base);
	// 825F4A7C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 825F4A80: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825F4A84: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825F4A88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F4A8C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 825F4A90: 4BFFF659  bl 0x825f40e8
	ctx.lr = 0x825F4A94;
	sub_825F40E8(ctx, base);
	// 825F4A94: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F4A98: 48000008  b 0x825f4aa0
	pc = 0x825F4AA0; continue 'dispatch;
	// 825F4A9C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825F4AA0: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 825F4AA4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F4AA8: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 825F4AAC: 4BFFF575  bl 0x825f4020
	ctx.lr = 0x825F4AB0;
	sub_825F4020(ctx, base);
	// 825F4AB0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825F4AB4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F4AB8: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 825F4ABC: 4BCCB545  bl 0x822c0000
	ctx.lr = 0x825F4AC0;
	sub_822C0000(ctx, base);
	// 825F4AC0: 57AB07BD  rlwinm. r11, r29, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825F4AC4: 41820010  beq 0x825f4ad4
	if ctx.cr[0].eq {
	pc = 0x825F4AD4; continue 'dispatch;
	}
	// 825F4AC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F4ACC: 57BD07FA  rlwinm r29, r29, 0, 0x1f, 0x1d
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 825F4AD0: 487FE959  bl 0x82df3428
	ctx.lr = 0x825F4AD4;
	sub_82DF3428(ctx, base);
	// 825F4AD4: 57AB07FF  clrlwi. r11, r29, 0x1f
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825F4AD8: 41820010  beq 0x825f4ae8
	if ctx.cr[0].eq {
	pc = 0x825F4AE8; continue 'dispatch;
	}
	// 825F4ADC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825F4AE0: 57BD003C  rlwinm r29, r29, 0, 0, 0x1e
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 825F4AE4: 487FE945  bl 0x82df3428
	ctx.lr = 0x825F4AE8;
	sub_82DF3428(ctx, base);
	// 825F4AE8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825F4AEC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F4AF0: 38A00026  li r5, 0x26
	ctx.r[5].s64 = 38;
	// 825F4AF4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825F4AF8: 4BCCB8E1  bl 0x822c03d8
	ctx.lr = 0x825F4AFC;
	sub_822C03D8(ctx, base);
	// 825F4AFC: 83810064  lwz r28, 0x64(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825F4B00: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825F4B04: 418200B4  beq 0x825f4bb8
	if ctx.cr[0].eq {
	pc = 0x825F4BB8; continue 'dispatch;
	}
	// 825F4B08: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825F4B0C: 63BD0004  ori r29, r29, 4
	ctx.r[29].u64 = ctx.r[29].u64 | 4;
	// 825F4B10: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825F4B14: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 825F4B18: 409A0008  bne cr6, 0x825f4b20
	if !ctx.cr[6].eq {
	pc = 0x825F4B20; continue 'dispatch;
	}
	// 825F4B1C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F4B20: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825F4B24: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 825F4B28: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 825F4B2C: 419A0024  beq cr6, 0x825f4b50
	if ctx.cr[6].eq {
	pc = 0x825F4B50; continue 'dispatch;
	}
	// 825F4B30: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 825F4B34: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 825F4B38: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F4B3C: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 825F4B40: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 825F4B44: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825F4B48: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F4B4C: 4082FFE8  bne 0x825f4b34
	if !ctx.cr[0].eq {
	pc = 0x825F4B34; continue 'dispatch;
	}
	// 825F4B50: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825F4B54: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 825F4B58: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 825F4B5C: 419A0024  beq cr6, 0x825f4b80
	if ctx.cr[6].eq {
	pc = 0x825F4B80; continue 'dispatch;
	}
	// 825F4B60: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 825F4B64: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825F4B68: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F4B6C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825F4B70: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825F4B74: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825F4B78: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F4B7C: 4082FFE8  bne 0x825f4b64
	if !ctx.cr[0].eq {
	pc = 0x825F4B64; continue 'dispatch;
	}
	// 825F4B80: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825F4B84: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 825F4B88: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825F4B8C: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 825F4B90: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825F4B94: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825F4B98: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825F4B9C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825F4BA0: 481A4391  bl 0x82798f30
	ctx.lr = 0x825F4BA4;
	sub_82798F30(ctx, base);
	// 825F4BA4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825F4BA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F4BAC: 481A6ABD  bl 0x8279b668
	ctx.lr = 0x825F4BB0;
	sub_8279B668(ctx, base);
	// 825F4BB0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F4BB4: 48000008  b 0x825f4bbc
	pc = 0x825F4BBC; continue 'dispatch;
	// 825F4BB8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825F4BBC: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825F4BC0: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 825F4BC4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F4BC8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F4BCC: 4BFA3085  bl 0x82597c50
	ctx.lr = 0x825F4BD0;
	sub_82597C50(ctx, base);
	// 825F4BD0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825F4BD4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F4BD8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F4BDC: 4BCCB425  bl 0x822c0000
	ctx.lr = 0x825F4BE0;
	sub_822C0000(ctx, base);
	// 825F4BE0: 57AB077B  rlwinm. r11, r29, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825F4BE4: 41820024  beq 0x825f4c08
	if ctx.cr[0].eq {
	pc = 0x825F4C08; continue 'dispatch;
	}
	// 825F4BE8: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 825F4BEC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F4BF0: 419A0008  beq cr6, 0x825f4bf8
	if ctx.cr[6].eq {
	pc = 0x825F4BF8; continue 'dispatch;
	}
	// 825F4BF4: 4BCCBC9D  bl 0x822c0890
	ctx.lr = 0x825F4BF8;
	sub_822C0890(ctx, base);
	// 825F4BF8: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 825F4BFC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F4C00: 419A0008  beq cr6, 0x825f4c08
	if ctx.cr[6].eq {
	pc = 0x825F4C08; continue 'dispatch;
	}
	// 825F4C04: 4BCCBC8D  bl 0x822c0890
	ctx.lr = 0x825F4C08;
	sub_822C0890(ctx, base);
	// 825F4C08: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 825F4C0C: 419A000C  beq cr6, 0x825f4c18
	if ctx.cr[6].eq {
	pc = 0x825F4C18; continue 'dispatch;
	}
	// 825F4C10: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825F4C14: 4BCCBC7D  bl 0x822c0890
	ctx.lr = 0x825F4C18;
	sub_822C0890(ctx, base);
	// 825F4C18: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825F4C1C: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 825F4C20: 48BB3594  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F4C28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825F4C28 size=576
    let mut pc: u32 = 0x825F4C28;
    'dispatch: loop {
        match pc {
            0x825F4C28 => {
    //   block [0x825F4C28..0x825F4E68)
	// 825F4C28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F4C2C: 48BB3539  bl 0x831a8164
	ctx.lr = 0x825F4C30;
	sub_831A8130(ctx, base);
	// 825F4C30: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F4C34: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825F4C38: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825F4C3C: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 825F4C40: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825F4C44: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825F4C48: 808B67B0  lwz r4, 0x67b0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26544 as u32) ) } as u64;
	// 825F4C4C: 4BCF02E5  bl 0x822e4f30
	ctx.lr = 0x825F4C50;
	sub_822E4F30(ctx, base);
	// 825F4C50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F4C54: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825F4C58: 4BCF0269  bl 0x822e4ec0
	ctx.lr = 0x825F4C5C;
	sub_822E4EC0(ctx, base);
	// 825F4C5C: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 825F4C60: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825F4C64: E8BF0000  ld r5, 0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	// 825F4C68: E88A0000  ld r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 825F4C6C: 806B674C  lwz r3, 0x674c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26444 as u32) ) } as u64;
	// 825F4C70: 4BE977D1  bl 0x8248c440
	ctx.lr = 0x825F4C74;
	sub_8248C440(ctx, base);
	// 825F4C74: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F4C78: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825F4C7C: 3BAB0CF8  addi r29, r11, 0xcf8
	ctx.r[29].s64 = ctx.r[11].s64 + 3320;
	// 825F4C80: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F4C84: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825F4C88: 38A00036  li r5, 0x36
	ctx.r[5].s64 = 54;
	// 825F4C8C: 38600150  li r3, 0x150
	ctx.r[3].s64 = 336;
	// 825F4C90: 487FD759  bl 0x82df23e8
	ctx.lr = 0x825F4C94;
	sub_82DF23E8(ctx, base);
	// 825F4C94: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825F4C98: 41820048  beq 0x825f4ce0
	if ctx.cr[0].eq {
	pc = 0x825F4CE0; continue 'dispatch;
	}
	// 825F4C9C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F4CA0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825F4CA4: 388B0D5C  addi r4, r11, 0xd5c
	ctx.r[4].s64 = ctx.r[11].s64 + 3420;
	// 825F4CA8: 487FED61  bl 0x82df3a08
	ctx.lr = 0x825F4CAC;
	sub_82DF3A08(ctx, base);
	// 825F4CAC: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 825F4CB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F4CB4: 388B4768  addi r4, r11, 0x4768
	ctx.r[4].s64 = ctx.r[11].s64 + 18280;
	// 825F4CB8: 487FED51  bl 0x82df3a08
	ctx.lr = 0x825F4CBC;
	sub_82DF3A08(ctx, base);
	// 825F4CBC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 825F4CC0: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 825F4CC4: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825F4CC8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825F4CCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F4CD0: 3B800003  li r28, 3
	ctx.r[28].s64 = 3;
	// 825F4CD4: 4BFFF415  bl 0x825f40e8
	ctx.lr = 0x825F4CD8;
	sub_825F40E8(ctx, base);
	// 825F4CD8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F4CDC: 48000008  b 0x825f4ce4
	pc = 0x825F4CE4; continue 'dispatch;
	// 825F4CE0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825F4CE4: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 825F4CE8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F4CEC: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 825F4CF0: 4BFFF331  bl 0x825f4020
	ctx.lr = 0x825F4CF4;
	sub_825F4020(ctx, base);
	// 825F4CF4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825F4CF8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F4CFC: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 825F4D00: 4BCCB301  bl 0x822c0000
	ctx.lr = 0x825F4D04;
	sub_822C0000(ctx, base);
	// 825F4D04: 578B07BD  rlwinm. r11, r28, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825F4D08: 41820010  beq 0x825f4d18
	if ctx.cr[0].eq {
	pc = 0x825F4D18; continue 'dispatch;
	}
	// 825F4D0C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F4D10: 579C07FA  rlwinm r28, r28, 0, 0x1f, 0x1d
	ctx.r[28].u64 = ctx.r[28].u32 as u64 & 0xFFFFFFFFu64;
	// 825F4D14: 487FE715  bl 0x82df3428
	ctx.lr = 0x825F4D18;
	sub_82DF3428(ctx, base);
	// 825F4D18: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825F4D1C: 41820010  beq 0x825f4d2c
	if ctx.cr[0].eq {
	pc = 0x825F4D2C; continue 'dispatch;
	}
	// 825F4D20: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825F4D24: 579C003C  rlwinm r28, r28, 0, 0, 0x1e
	ctx.r[28].u64 = ctx.r[28].u32 as u64 & 0xFFFFFFFFu64;
	// 825F4D28: 487FE701  bl 0x82df3428
	ctx.lr = 0x825F4D2C;
	sub_82DF3428(ctx, base);
	// 825F4D2C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825F4D30: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F4D34: 38A00037  li r5, 0x37
	ctx.r[5].s64 = 55;
	// 825F4D38: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825F4D3C: 4BCCB69D  bl 0x822c03d8
	ctx.lr = 0x825F4D40;
	sub_822C03D8(ctx, base);
	// 825F4D40: 83A10064  lwz r29, 0x64(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825F4D44: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825F4D48: 418200B4  beq 0x825f4dfc
	if ctx.cr[0].eq {
	pc = 0x825F4DFC; continue 'dispatch;
	}
	// 825F4D4C: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825F4D50: 639C0004  ori r28, r28, 4
	ctx.r[28].u64 = ctx.r[28].u64 | 4;
	// 825F4D54: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825F4D58: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 825F4D5C: 409A0008  bne cr6, 0x825f4d64
	if !ctx.cr[6].eq {
	pc = 0x825F4D64; continue 'dispatch;
	}
	// 825F4D60: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F4D64: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825F4D68: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825F4D6C: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 825F4D70: 419A0024  beq cr6, 0x825f4d94
	if ctx.cr[6].eq {
	pc = 0x825F4D94; continue 'dispatch;
	}
	// 825F4D74: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825F4D78: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 825F4D7C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F4D80: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 825F4D84: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 825F4D88: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825F4D8C: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F4D90: 4082FFE8  bne 0x825f4d78
	if !ctx.cr[0].eq {
	pc = 0x825F4D78; continue 'dispatch;
	}
	// 825F4D94: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825F4D98: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825F4D9C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 825F4DA0: 419A0024  beq cr6, 0x825f4dc4
	if ctx.cr[6].eq {
	pc = 0x825F4DC4; continue 'dispatch;
	}
	// 825F4DA4: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825F4DA8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825F4DAC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F4DB0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825F4DB4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825F4DB8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825F4DBC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F4DC0: 4082FFE8  bne 0x825f4da8
	if !ctx.cr[0].eq {
	pc = 0x825F4DA8; continue 'dispatch;
	}
	// 825F4DC4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825F4DC8: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 825F4DCC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825F4DD0: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 825F4DD4: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825F4DD8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825F4DDC: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825F4DE0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825F4DE4: 481A414D  bl 0x82798f30
	ctx.lr = 0x825F4DE8;
	sub_82798F30(ctx, base);
	// 825F4DE8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825F4DEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F4DF0: 481A6879  bl 0x8279b668
	ctx.lr = 0x825F4DF4;
	sub_8279B668(ctx, base);
	// 825F4DF4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F4DF8: 48000008  b 0x825f4e00
	pc = 0x825F4E00; continue 'dispatch;
	// 825F4DFC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825F4E00: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825F4E04: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 825F4E08: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F4E0C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F4E10: 4BFA2E41  bl 0x82597c50
	ctx.lr = 0x825F4E14;
	sub_82597C50(ctx, base);
	// 825F4E14: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825F4E18: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F4E1C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F4E20: 4BCCB1E1  bl 0x822c0000
	ctx.lr = 0x825F4E24;
	sub_822C0000(ctx, base);
	// 825F4E24: 578B077B  rlwinm. r11, r28, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825F4E28: 41820024  beq 0x825f4e4c
	if ctx.cr[0].eq {
	pc = 0x825F4E4C; continue 'dispatch;
	}
	// 825F4E2C: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 825F4E30: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F4E34: 419A0008  beq cr6, 0x825f4e3c
	if ctx.cr[6].eq {
	pc = 0x825F4E3C; continue 'dispatch;
	}
	// 825F4E38: 4BCCBA59  bl 0x822c0890
	ctx.lr = 0x825F4E3C;
	sub_822C0890(ctx, base);
	// 825F4E3C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825F4E40: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F4E44: 419A0008  beq cr6, 0x825f4e4c
	if ctx.cr[6].eq {
	pc = 0x825F4E4C; continue 'dispatch;
	}
	// 825F4E48: 4BCCBA49  bl 0x822c0890
	ctx.lr = 0x825F4E4C;
	sub_822C0890(ctx, base);
	// 825F4E4C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825F4E50: 419A000C  beq cr6, 0x825f4e5c
	if ctx.cr[6].eq {
	pc = 0x825F4E5C; continue 'dispatch;
	}
	// 825F4E54: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825F4E58: 4BCCBA39  bl 0x822c0890
	ctx.lr = 0x825F4E5C;
	sub_822C0890(ctx, base);
	// 825F4E5C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825F4E60: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 825F4E64: 48BB3350  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F4E68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F4E68 size=196
    let mut pc: u32 = 0x825F4E68;
    'dispatch: loop {
        match pc {
            0x825F4E68 => {
    //   block [0x825F4E68..0x825F4F2C)
	// 825F4E68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F4E6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F4E70: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825F4E74: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F4E78: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F4E7C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825F4E80: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F4E84: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825F4E88: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825F4E8C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F4E90: 4BCCBAA9  bl 0x822c0938
	ctx.lr = 0x825F4E94;
	sub_822C0938(ctx, base);
	// 825F4E94: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F4E98: 41820028  beq 0x825f4ec0
	if ctx.cr[0].eq {
	pc = 0x825F4EC0; continue 'dispatch;
	}
	// 825F4E9C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F4EA0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825F4EA4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825F4EA8: 392B0D68  addi r9, r11, 0xd68
	ctx.r[9].s64 = ctx.r[11].s64 + 3432;
	// 825F4EAC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825F4EB0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825F4EB4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825F4EB8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825F4EBC: 48000008  b 0x825f4ec4
	pc = 0x825F4EC4; continue 'dispatch;
	// 825F4EC0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F4EC4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F4EC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F4ECC: 409A0044  bne cr6, 0x825f4f10
	if !ctx.cr[6].eq {
	pc = 0x825F4F10; continue 'dispatch;
	}
	// 825F4ED0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825F4ED4: 419A001C  beq cr6, 0x825f4ef0
	if ctx.cr[6].eq {
	pc = 0x825F4EF0; continue 'dispatch;
	}
	// 825F4ED8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F4EDC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825F4EE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F4EE4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F4EE8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825F4EEC: 4E800421  bctrl
	ctx.lr = 0x825F4EF0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825F4EF0: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825F4EF4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825F4EF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F4EFC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825F4F00: 816BF0CC  lwz r11, -0xf34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3892 as u32) ) } as u64;
	// 825F4F04: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825F4F08: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825F4F0C: 4BCCB0F5  bl 0x822c0000
	ctx.lr = 0x825F4F10;
	sub_822C0000(ctx, base);
	// 825F4F10: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F4F14: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825F4F18: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F4F1C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F4F20: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825F4F24: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F4F28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F4F30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F4F30 size=196
    let mut pc: u32 = 0x825F4F30;
    'dispatch: loop {
        match pc {
            0x825F4F30 => {
    //   block [0x825F4F30..0x825F4FF4)
	// 825F4F30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F4F34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F4F38: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825F4F3C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F4F40: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F4F44: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825F4F48: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F4F4C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825F4F50: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825F4F54: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F4F58: 4BCCB9E1  bl 0x822c0938
	ctx.lr = 0x825F4F5C;
	sub_822C0938(ctx, base);
	// 825F4F5C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F4F60: 41820028  beq 0x825f4f88
	if ctx.cr[0].eq {
	pc = 0x825F4F88; continue 'dispatch;
	}
	// 825F4F64: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F4F68: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825F4F6C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825F4F70: 392B0D7C  addi r9, r11, 0xd7c
	ctx.r[9].s64 = ctx.r[11].s64 + 3452;
	// 825F4F74: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825F4F78: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825F4F7C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825F4F80: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825F4F84: 48000008  b 0x825f4f8c
	pc = 0x825F4F8C; continue 'dispatch;
	// 825F4F88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F4F8C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F4F90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F4F94: 409A0044  bne cr6, 0x825f4fd8
	if !ctx.cr[6].eq {
	pc = 0x825F4FD8; continue 'dispatch;
	}
	// 825F4F98: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825F4F9C: 419A001C  beq cr6, 0x825f4fb8
	if ctx.cr[6].eq {
	pc = 0x825F4FB8; continue 'dispatch;
	}
	// 825F4FA0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F4FA4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825F4FA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F4FAC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F4FB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825F4FB4: 4E800421  bctrl
	ctx.lr = 0x825F4FB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825F4FB8: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825F4FBC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825F4FC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F4FC4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825F4FC8: 816BF0CC  lwz r11, -0xf34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3892 as u32) ) } as u64;
	// 825F4FCC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825F4FD0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825F4FD4: 4BCCB02D  bl 0x822c0000
	ctx.lr = 0x825F4FD8;
	sub_822C0000(ctx, base);
	// 825F4FD8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F4FDC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825F4FE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F4FE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F4FE8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825F4FEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F4FF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F4FF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F4FF8 size=196
    let mut pc: u32 = 0x825F4FF8;
    'dispatch: loop {
        match pc {
            0x825F4FF8 => {
    //   block [0x825F4FF8..0x825F50BC)
	// 825F4FF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F4FFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F5000: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825F5004: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F5008: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F500C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825F5010: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F5014: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825F5018: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825F501C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F5020: 4BCCB919  bl 0x822c0938
	ctx.lr = 0x825F5024;
	sub_822C0938(ctx, base);
	// 825F5024: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F5028: 41820028  beq 0x825f5050
	if ctx.cr[0].eq {
	pc = 0x825F5050; continue 'dispatch;
	}
	// 825F502C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F5030: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825F5034: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825F5038: 392B0D90  addi r9, r11, 0xd90
	ctx.r[9].s64 = ctx.r[11].s64 + 3472;
	// 825F503C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825F5040: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825F5044: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825F5048: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825F504C: 48000008  b 0x825f5054
	pc = 0x825F5054; continue 'dispatch;
	// 825F5050: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F5054: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F5058: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F505C: 409A0044  bne cr6, 0x825f50a0
	if !ctx.cr[6].eq {
	pc = 0x825F50A0; continue 'dispatch;
	}
	// 825F5060: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825F5064: 419A001C  beq cr6, 0x825f5080
	if ctx.cr[6].eq {
	pc = 0x825F5080; continue 'dispatch;
	}
	// 825F5068: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F506C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825F5070: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F5074: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F5078: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825F507C: 4E800421  bctrl
	ctx.lr = 0x825F5080;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825F5080: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825F5084: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825F5088: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F508C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825F5090: 816BF0CC  lwz r11, -0xf34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3892 as u32) ) } as u64;
	// 825F5094: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825F5098: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825F509C: 4BCCAF65  bl 0x822c0000
	ctx.lr = 0x825F50A0;
	sub_822C0000(ctx, base);
	// 825F50A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F50A4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825F50A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F50AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F50B0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825F50B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F50B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F50C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F50C0 size=136
    let mut pc: u32 = 0x825F50C0;
    'dispatch: loop {
        match pc {
            0x825F50C0 => {
    //   block [0x825F50C0..0x825F5148)
	// 825F50C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F50C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F50C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825F50CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F50D0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F50D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F50D8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825F50DC: 4809F2AD  bl 0x82694388
	ctx.lr = 0x825F50E0;
	sub_82694388(ctx, base);
	// 825F50E0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F50E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F50E8: 388B0DA0  addi r4, r11, 0xda0
	ctx.r[4].s64 = ctx.r[11].s64 + 3488;
	// 825F50EC: 487FE91D  bl 0x82df3a08
	ctx.lr = 0x825F50F0;
	sub_82DF3A08(ctx, base);
	// 825F50F0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825F50F4: 38C02710  li r6, 0x2710
	ctx.r[6].s64 = 10000;
	// 825F50F8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825F50FC: 389F0044  addi r4, r31, 0x44
	ctx.r[4].s64 = ctx.r[31].s64 + 68;
	// 825F5100: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825F5104: 4BFAE2A5  bl 0x825a33a8
	ctx.lr = 0x825F5108;
	sub_825A33A8(ctx, base);
	// 825F5108: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825F510C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825F5110: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F5114: 4BFACDC5  bl 0x825a1ed8
	ctx.lr = 0x825F5118;
	sub_825A1ED8(ctx, base);
	// 825F5118: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 825F511C: 487FE30D  bl 0x82df3428
	ctx.lr = 0x825F5120;
	sub_82DF3428(ctx, base);
	// 825F5120: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825F5124: 4BCD3B95  bl 0x822c8cb8
	ctx.lr = 0x825F5128;
	sub_822C8CB8(ctx, base);
	// 825F5128: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F512C: 487FE2FD  bl 0x82df3428
	ctx.lr = 0x825F5130;
	sub_82DF3428(ctx, base);
	// 825F5130: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 825F5134: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F5138: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F513C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825F5140: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F5144: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F5148(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F5148 size=120
    let mut pc: u32 = 0x825F5148;
    'dispatch: loop {
        match pc {
            0x825F5148 => {
    //   block [0x825F5148..0x825F51C0)
	// 825F5148: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F514C: 48BB3021  bl 0x831a816c
	ctx.lr = 0x825F5150;
	sub_831A8130(ctx, base);
	// 825F5150: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F5154: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825F5158: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825F515C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825F5160: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F5164: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 825F5168: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 825F516C: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 825F5170: 487FD279  bl 0x82df23e8
	ctx.lr = 0x825F5174;
	sub_82DF23E8(ctx, base);
	// 825F5174: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F5178: 41820014  beq 0x825f518c
	if ctx.cr[0].eq {
	pc = 0x825F518C; continue 'dispatch;
	}
	// 825F517C: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F5180: 48565D11  bl 0x82b5ae90
	ctx.lr = 0x825F5184;
	sub_82B5AE90(ctx, base);
	// 825F5184: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F5188: 48000008  b 0x825f5190
	pc = 0x825F5190; continue 'dispatch;
	// 825F518C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825F5190: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825F5194: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 825F5198: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F519C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F51A0: 4BFFFD91  bl 0x825f4f30
	ctx.lr = 0x825F51A4;
	sub_825F4F30(ctx, base);
	// 825F51A4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825F51A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F51AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F51B0: 4BCCAE51  bl 0x822c0000
	ctx.lr = 0x825F51B4;
	sub_822C0000(ctx, base);
	// 825F51B4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825F51B8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825F51BC: 48BB3000  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F51C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F51C0 size=120
    let mut pc: u32 = 0x825F51C0;
    'dispatch: loop {
        match pc {
            0x825F51C0 => {
    //   block [0x825F51C0..0x825F5238)
	// 825F51C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F51C4: 48BB2FA9  bl 0x831a816c
	ctx.lr = 0x825F51C8;
	sub_831A8130(ctx, base);
	// 825F51C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F51CC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825F51D0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825F51D4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825F51D8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F51DC: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 825F51E0: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 825F51E4: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 825F51E8: 487FD201  bl 0x82df23e8
	ctx.lr = 0x825F51EC;
	sub_82DF23E8(ctx, base);
	// 825F51EC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F51F0: 41820014  beq 0x825f5204
	if ctx.cr[0].eq {
	pc = 0x825F5204; continue 'dispatch;
	}
	// 825F51F4: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F51F8: 48565CE9  bl 0x82b5aee0
	ctx.lr = 0x825F51FC;
	sub_82B5AEE0(ctx, base);
	// 825F51FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F5200: 48000008  b 0x825f5208
	pc = 0x825F5208; continue 'dispatch;
	// 825F5204: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825F5208: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825F520C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 825F5210: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F5214: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F5218: 4BFFFDE1  bl 0x825f4ff8
	ctx.lr = 0x825F521C;
	sub_825F4FF8(ctx, base);
	// 825F521C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825F5220: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F5224: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F5228: 4BCCADD9  bl 0x822c0000
	ctx.lr = 0x825F522C;
	sub_822C0000(ctx, base);
	// 825F522C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825F5230: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825F5234: 48BB2F88  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F5238(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825F5238 size=232
    let mut pc: u32 = 0x825F5238;
    'dispatch: loop {
        match pc {
            0x825F5238 => {
    //   block [0x825F5238..0x825F5320)
	// 825F5238: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F523C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F5240: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825F5244: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F5248: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F524C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F5250: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825F5254: 389F012C  addi r4, r31, 0x12c
	ctx.r[4].s64 = ctx.r[31].s64 + 300;
	// 825F5258: 4BFFFEF1  bl 0x825f5148
	ctx.lr = 0x825F525C;
	sub_825F5148(ctx, base);
	// 825F525C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F5260: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825F5264: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825F5268: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F526C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825F5270: 419A0024  beq cr6, 0x825f5294
	if ctx.cr[6].eq {
	pc = 0x825F5294; continue 'dispatch;
	}
	// 825F5274: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825F5278: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825F527C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F5280: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825F5284: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825F5288: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825F528C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F5290: 4082FFE8  bne 0x825f5278
	if !ctx.cr[0].eq {
	pc = 0x825F5278; continue 'dispatch;
	}
	// 825F5294: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F5298: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825F529C: 4BF1A22D  bl 0x8250f4c8
	ctx.lr = 0x825F52A0;
	sub_8250F4C8(ctx, base);
	// 825F52A0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F52A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F52A8: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 825F52AC: 409A0008  bne cr6, 0x825f52b4
	if !ctx.cr[6].eq {
	pc = 0x825F52B4; continue 'dispatch;
	}
	// 825F52B0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825F52B4: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 825F52B8: 4BF131F9  bl 0x825084b0
	ctx.lr = 0x825F52BC;
	sub_825084B0(ctx, base);
	// 825F52BC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825F52C0: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825F52C4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 825F52C8: 388A0DB0  addi r4, r10, 0xdb0
	ctx.r[4].s64 = ctx.r[10].s64 + 3504;
	// 825F52CC: 38A00047  li r5, 0x47
	ctx.r[5].s64 = 71;
	// 825F52D0: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 825F52D4: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825F52D8: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 825F52DC: 48863765  bl 0x82e58a40
	ctx.lr = 0x825F52E0;
	sub_82E58A40(ctx, base);
	// 825F52E0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825F52E4: 487FC9AD  bl 0x82df1c90
	ctx.lr = 0x825F52E8;
	sub_82DF1C90(ctx, base);
	// 825F52E8: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825F52EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F52F0: 419A0008  beq cr6, 0x825f52f8
	if ctx.cr[6].eq {
	pc = 0x825F52F8; continue 'dispatch;
	}
	// 825F52F4: 4BCCB59D  bl 0x822c0890
	ctx.lr = 0x825F52F8;
	sub_822C0890(ctx, base);
	// 825F52F8: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825F52FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F5300: 419A0008  beq cr6, 0x825f5308
	if ctx.cr[6].eq {
	pc = 0x825F5308; continue 'dispatch;
	}
	// 825F5304: 4BCCB58D  bl 0x822c0890
	ctx.lr = 0x825F5308;
	sub_822C0890(ctx, base);
	// 825F5308: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825F530C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F5310: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F5314: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825F5318: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F531C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F5320(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825F5320 size=232
    let mut pc: u32 = 0x825F5320;
    'dispatch: loop {
        match pc {
            0x825F5320 => {
    //   block [0x825F5320..0x825F5408)
	// 825F5320: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F5324: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F5328: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825F532C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F5330: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F5334: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F5338: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825F533C: 389F012C  addi r4, r31, 0x12c
	ctx.r[4].s64 = ctx.r[31].s64 + 300;
	// 825F5340: 4BFFFE81  bl 0x825f51c0
	ctx.lr = 0x825F5344;
	sub_825F51C0(ctx, base);
	// 825F5344: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F5348: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825F534C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825F5350: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F5354: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825F5358: 419A0024  beq cr6, 0x825f537c
	if ctx.cr[6].eq {
	pc = 0x825F537C; continue 'dispatch;
	}
	// 825F535C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825F5360: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825F5364: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F5368: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825F536C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825F5370: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825F5374: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F5378: 4082FFE8  bne 0x825f5360
	if !ctx.cr[0].eq {
	pc = 0x825F5360; continue 'dispatch;
	}
	// 825F537C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F5380: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825F5384: 4BF1A145  bl 0x8250f4c8
	ctx.lr = 0x825F5388;
	sub_8250F4C8(ctx, base);
	// 825F5388: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F538C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F5390: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 825F5394: 409A0008  bne cr6, 0x825f539c
	if !ctx.cr[6].eq {
	pc = 0x825F539C; continue 'dispatch;
	}
	// 825F5398: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825F539C: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 825F53A0: 4BF13111  bl 0x825084b0
	ctx.lr = 0x825F53A4;
	sub_825084B0(ctx, base);
	// 825F53A4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825F53A8: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825F53AC: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 825F53B0: 388A0DB0  addi r4, r10, 0xdb0
	ctx.r[4].s64 = ctx.r[10].s64 + 3504;
	// 825F53B4: 38A00052  li r5, 0x52
	ctx.r[5].s64 = 82;
	// 825F53B8: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 825F53BC: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825F53C0: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 825F53C4: 4886367D  bl 0x82e58a40
	ctx.lr = 0x825F53C8;
	sub_82E58A40(ctx, base);
	// 825F53C8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825F53CC: 487FC8C5  bl 0x82df1c90
	ctx.lr = 0x825F53D0;
	sub_82DF1C90(ctx, base);
	// 825F53D0: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825F53D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F53D8: 419A0008  beq cr6, 0x825f53e0
	if ctx.cr[6].eq {
	pc = 0x825F53E0; continue 'dispatch;
	}
	// 825F53DC: 4BCCB4B5  bl 0x822c0890
	ctx.lr = 0x825F53E0;
	sub_822C0890(ctx, base);
	// 825F53E0: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825F53E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F53E8: 419A0008  beq cr6, 0x825f53f0
	if ctx.cr[6].eq {
	pc = 0x825F53F0; continue 'dispatch;
	}
	// 825F53EC: 4BCCB4A5  bl 0x822c0890
	ctx.lr = 0x825F53F0;
	sub_822C0890(ctx, base);
	// 825F53F0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825F53F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F53F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F53FC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825F5400: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F5404: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F5408(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825F5408 size=208
    let mut pc: u32 = 0x825F5408;
    'dispatch: loop {
        match pc {
            0x825F5408 => {
    //   block [0x825F5408..0x825F54D8)
	// 825F5408: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F540C: 48BB2D5D  bl 0x831a8168
	ctx.lr = 0x825F5410;
	sub_831A8130(ctx, base);
	// 825F5410: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F5414: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F5418: 4809EEA9  bl 0x826942c0
	ctx.lr = 0x825F541C;
	sub_826942C0(ctx, base);
	// 825F541C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F5420: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825F5424: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 825F5428: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825F542C: 396B0E9C  addi r11, r11, 0xe9c
	ctx.r[11].s64 = ctx.r[11].s64 + 3740;
	// 825F5430: 394A0E88  addi r10, r10, 0xe88
	ctx.r[10].s64 = ctx.r[10].s64 + 3720;
	// 825F5434: 93DF012C  stw r30, 0x12c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(300 as u32), ctx.r[30].u32 ) };
	// 825F5438: 39290E3C  addi r9, r9, 0xe3c
	ctx.r[9].s64 = ctx.r[9].s64 + 3644;
	// 825F543C: 9BC10051  stb r30, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[30].u8 ) };
	// 825F5440: 3B800080  li r28, 0x80
	ctx.r[28].s64 = 128;
	// 825F5444: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F5448: 3BA000FF  li r29, 0xff
	ctx.r[29].s64 = 255;
	// 825F544C: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 825F5450: 9B810050  stb r28, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u8 ) };
	// 825F5454: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F5458: 913F00E8  stw r9, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[9].u32 ) };
	// 825F545C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825F5460: 9BC10052  stb r30, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[30].u8 ) };
	// 825F5464: 9BA10053  stb r29, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[29].u8 ) };
	// 825F5468: 4809E9A1  bl 0x82693e08
	ctx.lr = 0x825F546C;
	sub_82693E08(ctx, base);
	// 825F546C: 9B810054  stb r28, 0x54(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u8 ) };
	// 825F5470: 9BA10055  stb r29, 0x55(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(85 as u32), ctx.r[29].u8 ) };
	// 825F5474: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F5478: 9BC10056  stb r30, 0x56(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(86 as u32), ctx.r[30].u8 ) };
	// 825F547C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825F5480: 9BC10057  stb r30, 0x57(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(87 as u32), ctx.r[30].u8 ) };
	// 825F5484: 4809E9AD  bl 0x82693e30
	ctx.lr = 0x825F5488;
	sub_82693E30(ctx, base);
	// 825F5488: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825F548C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F5490: C02B9524  lfs f1, -0x6adc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825F5494: 4809E9E5  bl 0x82693e78
	ctx.lr = 0x825F5498;
	sub_82693E78(ctx, base);
	// 825F5498: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F549C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825F54A0: 388B0E0C  addi r4, r11, 0xe0c
	ctx.r[4].s64 = ctx.r[11].s64 + 3596;
	// 825F54A4: 4BCD3E4D  bl 0x822c92f0
	ctx.lr = 0x825F54A8;
	sub_822C92F0(ctx, base);
	// 825F54A8: 387F0104  addi r3, r31, 0x104
	ctx.r[3].s64 = ctx.r[31].s64 + 260;
	// 825F54AC: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 825F54B0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825F54B4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825F54B8: 4BCD3C79  bl 0x822c9130
	ctx.lr = 0x825F54BC;
	sub_822C9130(ctx, base);
	// 825F54BC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825F54C0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825F54C4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825F54C8: 4BCD3969  bl 0x822c8e30
	ctx.lr = 0x825F54CC;
	sub_822C8E30(ctx, base);
	// 825F54CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F54D0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825F54D4: 48BB2CE4  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F54D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825F54D8 size=8
    let mut pc: u32 = 0x825F54D8;
    'dispatch: loop {
        match pc {
            0x825F54D8 => {
    //   block [0x825F54D8..0x825F54E0)
	// 825F54D8: 3863FF18  addi r3, r3, -0xe8
	ctx.r[3].s64 = ctx.r[3].s64 + -232;
	// 825F54DC: 4BFFE8FC  b 0x825f3dd8
	sub_825F3DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F54E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825F54E0 size=424
    let mut pc: u32 = 0x825F54E0;
    'dispatch: loop {
        match pc {
            0x825F54E0 => {
    //   block [0x825F54E0..0x825F5688)
	// 825F54E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F54E4: 48BB2C81  bl 0x831a8164
	ctx.lr = 0x825F54E8;
	sub_831A8130(ctx, base);
	// 825F54E8: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F54EC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F54F0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825F54F4: 3BCB0DB0  addi r30, r11, 0xdb0
	ctx.r[30].s64 = ctx.r[11].s64 + 3504;
	// 825F54F8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825F54FC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F5500: 38A0001E  li r5, 0x1e
	ctx.r[5].s64 = 30;
	// 825F5504: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 825F5508: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825F550C: 38600130  li r3, 0x130
	ctx.r[3].s64 = 304;
	// 825F5510: 487FCED9  bl 0x82df23e8
	ctx.lr = 0x825F5514;
	sub_82DF23E8(ctx, base);
	// 825F5514: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F5518: 41820010  beq 0x825f5528
	if ctx.cr[0].eq {
	pc = 0x825F5528; continue 'dispatch;
	}
	// 825F551C: 4BFFFEED  bl 0x825f5408
	ctx.lr = 0x825F5520;
	sub_825F5408(ctx, base);
	// 825F5520: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F5524: 48000008  b 0x825f552c
	pc = 0x825F552C; continue 'dispatch;
	// 825F5528: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825F552C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825F5530: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F5534: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F5538: 4BFFF931  bl 0x825f4e68
	ctx.lr = 0x825F553C;
	sub_825F4E68(ctx, base);
	// 825F553C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825F5540: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F5544: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F5548: 4BCCAAB9  bl 0x822c0000
	ctx.lr = 0x825F554C;
	sub_822C0000(ctx, base);
	// 825F554C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825F5550: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F5554: 38A0001F  li r5, 0x1f
	ctx.r[5].s64 = 31;
	// 825F5558: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825F555C: 4BCCAE7D  bl 0x822c03d8
	ctx.lr = 0x825F5560;
	sub_822C03D8(ctx, base);
	// 825F5560: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825F5564: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825F5568: 418200B4  beq 0x825f561c
	if ctx.cr[0].eq {
	pc = 0x825F561C; continue 'dispatch;
	}
	// 825F556C: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825F5570: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 825F5574: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825F5578: 396A00E8  addi r11, r10, 0xe8
	ctx.r[11].s64 = ctx.r[10].s64 + 232;
	// 825F557C: 409A0008  bne cr6, 0x825f5584
	if !ctx.cr[6].eq {
	pc = 0x825F5584; continue 'dispatch;
	}
	// 825F5580: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F5584: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825F5588: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825F558C: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 825F5590: 419A0024  beq cr6, 0x825f55b4
	if ctx.cr[6].eq {
	pc = 0x825F55B4; continue 'dispatch;
	}
	// 825F5594: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825F5598: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 825F559C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F55A0: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 825F55A4: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 825F55A8: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825F55AC: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F55B0: 4082FFE8  bne 0x825f5598
	if !ctx.cr[0].eq {
	pc = 0x825F5598; continue 'dispatch;
	}
	// 825F55B4: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 825F55B8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825F55BC: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 825F55C0: 419A0024  beq cr6, 0x825f55e4
	if ctx.cr[6].eq {
	pc = 0x825F55E4; continue 'dispatch;
	}
	// 825F55C4: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825F55C8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825F55CC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F55D0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825F55D4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825F55D8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825F55DC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F55E0: 4082FFE8  bne 0x825f55c8
	if !ctx.cr[0].eq {
	pc = 0x825F55C8; continue 'dispatch;
	}
	// 825F55E4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825F55E8: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 825F55EC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825F55F0: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 825F55F4: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825F55F8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825F55FC: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825F5600: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825F5604: 481A392D  bl 0x82798f30
	ctx.lr = 0x825F5608;
	sub_82798F30(ctx, base);
	// 825F5608: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825F560C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F5610: 481A6059  bl 0x8279b668
	ctx.lr = 0x825F5614;
	sub_8279B668(ctx, base);
	// 825F5614: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F5618: 48000008  b 0x825f5620
	pc = 0x825F5620; continue 'dispatch;
	// 825F561C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825F5620: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825F5624: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 825F5628: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F562C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F5630: 4BFA2621  bl 0x82597c50
	ctx.lr = 0x825F5634;
	sub_82597C50(ctx, base);
	// 825F5634: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825F5638: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F563C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F5640: 4BCCA9C1  bl 0x822c0000
	ctx.lr = 0x825F5644;
	sub_822C0000(ctx, base);
	// 825F5644: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825F5648: 41820024  beq 0x825f566c
	if ctx.cr[0].eq {
	pc = 0x825F566C; continue 'dispatch;
	}
	// 825F564C: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 825F5650: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F5654: 419A0008  beq cr6, 0x825f565c
	if ctx.cr[6].eq {
	pc = 0x825F565C; continue 'dispatch;
	}
	// 825F5658: 4BCCB239  bl 0x822c0890
	ctx.lr = 0x825F565C;
	sub_822C0890(ctx, base);
	// 825F565C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825F5660: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F5664: 419A0008  beq cr6, 0x825f566c
	if ctx.cr[6].eq {
	pc = 0x825F566C; continue 'dispatch;
	}
	// 825F5668: 4BCCB229  bl 0x822c0890
	ctx.lr = 0x825F566C;
	sub_822C0890(ctx, base);
	// 825F566C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825F5670: 419A000C  beq cr6, 0x825f567c
	if ctx.cr[6].eq {
	pc = 0x825F567C; continue 'dispatch;
	}
	// 825F5674: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825F5678: 4BCCB219  bl 0x822c0890
	ctx.lr = 0x825F567C;
	sub_822C0890(ctx, base);
	// 825F567C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825F5680: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 825F5684: 48BB2B30  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F5688(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825F5688 size=12
    let mut pc: u32 = 0x825F5688;
    'dispatch: loop {
        match pc {
            0x825F5688 => {
    //   block [0x825F5688..0x825F5694)
	// 825F5688: 81640018  lwz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 825F568C: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 825F5690: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F5694(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825F5694 size=12
    let mut pc: u32 = 0x825F5694;
    'dispatch: loop {
        match pc {
            0x825F5694 => {
    //   block [0x825F5694..0x825F56A0)
	// 825F5694: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825F5698: 99630159  stb r11, 0x159(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(345 as u32), ctx.r[11].u8 ) };
	// 825F569C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F56A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F56A0 size=68
    let mut pc: u32 = 0x825F56A0;
    'dispatch: loop {
        match pc {
            0x825F56A0 => {
    //   block [0x825F56A0..0x825F56E4)
	// 825F56A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F56A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F56A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825F56AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F56B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F56B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F56B8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825F56BC: 4BF1B04D  bl 0x82510708
	ctx.lr = 0x825F56C0;
	sub_82510708(ctx, base);
	// 825F56C0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825F56C4: 387F0140  addi r3, r31, 0x140
	ctx.r[3].s64 = ctx.r[31].s64 + 320;
	// 825F56C8: 488677B1  bl 0x82e5ce78
	ctx.lr = 0x825F56CC;
	sub_82E5CE78(ctx, base);
	// 825F56CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825F56D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F56D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F56D8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825F56DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F56E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F56E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825F56E8 size=12
    let mut pc: u32 = 0x825F56E8;
    'dispatch: loop {
        match pc {
            0x825F56E8 => {
    //   block [0x825F56E8..0x825F56F4)
	// 825F56E8: 81640018  lwz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 825F56EC: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 825F56F0: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F56F4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825F56F4 size=12
    let mut pc: u32 = 0x825F56F4;
    'dispatch: loop {
        match pc {
            0x825F56F4 => {
    //   block [0x825F56F4..0x825F5700)
	// 825F56F4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825F56F8: 996301DE  stb r11, 0x1de(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(478 as u32), ctx.r[11].u8 ) };
	// 825F56FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F5700(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F5700 size=76
    let mut pc: u32 = 0x825F5700;
    'dispatch: loop {
        match pc {
            0x825F5700 => {
    //   block [0x825F5700..0x825F574C)
	// 825F5700: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F5704: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F5708: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F570C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F5710: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825F5714: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F5718: 4BF1C681  bl 0x82511d98
	ctx.lr = 0x825F571C;
	sub_82511D98(ctx, base);
	// 825F571C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825F5720: 807F0130  lwz r3, 0x130(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(304 as u32) ) } as u64;
	// 825F5724: 4BCF81FD  bl 0x822ed920
	ctx.lr = 0x825F5728;
	sub_822ED920(ctx, base);
	// 825F5728: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 825F572C: 807F0130  lwz r3, 0x130(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(304 as u32) ) } as u64;
	// 825F5730: 388B6910  addi r4, r11, 0x6910
	ctx.r[4].s64 = ctx.r[11].s64 + 26896;
	// 825F5734: 4BCF7A1D  bl 0x822ed150
	ctx.lr = 0x825F5738;
	sub_822ED150(ctx, base);
	// 825F5738: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825F573C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F5740: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F5744: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F5748: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F5750(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F5750 size=196
    let mut pc: u32 = 0x825F5750;
    'dispatch: loop {
        match pc {
            0x825F5750 => {
    //   block [0x825F5750..0x825F5814)
	// 825F5750: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F5754: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F5758: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825F575C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F5760: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F5764: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825F5768: 897E005C  lbz r11, 0x5c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(92 as u32) ) } as u64;
	// 825F576C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F5770: 4082008C  bne 0x825f57fc
	if !ctx.cr[0].eq {
	pc = 0x825F57FC; continue 'dispatch;
	}
	// 825F5774: 3BFEFF1C  addi r31, r30, -0xe4
	ctx.r[31].s64 = ctx.r[30].s64 + -228;
	// 825F5778: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825F577C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F5780: 4BF19D49  bl 0x8250f4c8
	ctx.lr = 0x825F5784;
	sub_8250F4C8(ctx, base);
	// 825F5784: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F5788: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F578C: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 825F5790: 409A0008  bne cr6, 0x825f5798
	if !ctx.cr[6].eq {
	pc = 0x825F5798; continue 'dispatch;
	}
	// 825F5794: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825F5798: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F579C: 4BF12FF5  bl 0x82508790
	ctx.lr = 0x825F57A0;
	sub_82508790(ctx, base);
	// 825F57A0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825F57A4: 487FC4ED  bl 0x82df1c90
	ctx.lr = 0x825F57A8;
	sub_82DF1C90(ctx, base);
	// 825F57A8: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 825F57AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F57B0: 808BE268  lwz r4, -0x1d98(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7576 as u32) ) } as u64;
	// 825F57B4: 487FE255  bl 0x82df3a08
	ctx.lr = 0x825F57B8;
	sub_82DF3A08(ctx, base);
	// 825F57B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F57BC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825F57C0: 4BF19D09  bl 0x8250f4c8
	ctx.lr = 0x825F57C4;
	sub_8250F4C8(ctx, base);
	// 825F57C4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F57C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F57CC: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 825F57D0: 409A0008  bne cr6, 0x825f57d8
	if !ctx.cr[6].eq {
	pc = 0x825F57D8; continue 'dispatch;
	}
	// 825F57D4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825F57D8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825F57DC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825F57E0: 4BF12FA1  bl 0x82508780
	ctx.lr = 0x825F57E4;
	sub_82508780(ctx, base);
	// 825F57E4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825F57E8: 487FC4A9  bl 0x82df1c90
	ctx.lr = 0x825F57EC;
	sub_82DF1C90(ctx, base);
	// 825F57EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F57F0: 487FDC39  bl 0x82df3428
	ctx.lr = 0x825F57F4;
	sub_82DF3428(ctx, base);
	// 825F57F4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825F57F8: 997E005C  stb r11, 0x5c(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(92 as u32), ctx.r[11].u8 ) };
	// 825F57FC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825F5800: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F5804: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F5808: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825F580C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F5810: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F5818(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F5818 size=172
    let mut pc: u32 = 0x825F5818;
    'dispatch: loop {
        match pc {
            0x825F5818 => {
    //   block [0x825F5818..0x825F58C4)
	// 825F5818: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F581C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F5820: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F5824: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F5828: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F582C: 3BE3FF1C  addi r31, r3, -0xe4
	ctx.r[31].s64 = ctx.r[3].s64 + -228;
	// 825F5830: 9963005C  stb r11, 0x5c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(92 as u32), ctx.r[11].u8 ) };
	// 825F5834: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825F5838: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F583C: 4BF19C8D  bl 0x8250f4c8
	ctx.lr = 0x825F5840;
	sub_8250F4C8(ctx, base);
	// 825F5840: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F5844: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F5848: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 825F584C: 409A0008  bne cr6, 0x825f5854
	if !ctx.cr[6].eq {
	pc = 0x825F5854; continue 'dispatch;
	}
	// 825F5850: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825F5854: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F5858: 4BF12F39  bl 0x82508790
	ctx.lr = 0x825F585C;
	sub_82508790(ctx, base);
	// 825F585C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825F5860: 487FC431  bl 0x82df1c90
	ctx.lr = 0x825F5864;
	sub_82DF1C90(ctx, base);
	// 825F5864: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 825F5868: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F586C: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 825F5870: 487FE199  bl 0x82df3a08
	ctx.lr = 0x825F5874;
	sub_82DF3A08(ctx, base);
	// 825F5874: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F5878: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825F587C: 4BF19C4D  bl 0x8250f4c8
	ctx.lr = 0x825F5880;
	sub_8250F4C8(ctx, base);
	// 825F5880: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F5884: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F5888: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 825F588C: 409A0008  bne cr6, 0x825f5894
	if !ctx.cr[6].eq {
	pc = 0x825F5894; continue 'dispatch;
	}
	// 825F5890: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825F5894: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825F5898: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825F589C: 4BF12EE5  bl 0x82508780
	ctx.lr = 0x825F58A0;
	sub_82508780(ctx, base);
	// 825F58A0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825F58A4: 487FC3ED  bl 0x82df1c90
	ctx.lr = 0x825F58A8;
	sub_82DF1C90(ctx, base);
	// 825F58A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F58AC: 487FDB7D  bl 0x82df3428
	ctx.lr = 0x825F58B0;
	sub_82DF3428(ctx, base);
	// 825F58B0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825F58B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F58B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F58BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F58C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F58C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825F58C8 size=68
    let mut pc: u32 = 0x825F58C8;
    'dispatch: loop {
        match pc {
            0x825F58C8 => {
    //   block [0x825F58C8..0x825F590C)
	// 825F58C8: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 825F58CC: 394001B0  li r10, 0x1b0
	ctx.r[10].s64 = 432;
	// 825F58D0: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 825F58D4: 392001C0  li r9, 0x1c0
	ctx.r[9].s64 = 448;
	// 825F58D8: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 825F58DC: 38E000F0  li r7, 0xf0
	ctx.r[7].s64 = 240;
	// 825F58E0: 38C00100  li r6, 0x100
	ctx.r[6].s64 = 256;
	// 825F58E4: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F5910(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F5910 size=88
    let mut pc: u32 = 0x825F5910;
    'dispatch: loop {
        match pc {
            0x825F5910 => {
    //   block [0x825F5910..0x825F5968)
	// 825F5910: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F5914: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F5918: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F591C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F5920: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825F5924: 3D408328  lis r10, -0x7cd8
	ctx.r[10].s64 = -2094530560;
	// 825F5928: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F592C: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 825F5930: 38CBF5F8  addi r6, r11, -0xa08
	ctx.r[6].s64 = ctx.r[11].s64 + -2568;
	// 825F5934: 38AABE54  addi r5, r10, -0x41ac
	ctx.r[5].s64 = ctx.r[10].s64 + -16812;
	// 825F5938: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 825F593C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825F5940: 48BB4609  bl 0x831a9f48
	ctx.lr = 0x825F5944;
	sub_831A9F48(ctx, base);
	// 825F5944: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F5948: 4182000C  beq 0x825f5954
	if ctx.cr[0].eq {
	pc = 0x825F5954; continue 'dispatch;
	}
	// 825F594C: 89630004  lbz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825F5950: 997F0004  stb r11, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u8 ) };
	// 825F5954: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825F5958: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F595C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F5960: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F5964: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F5968(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F5968 size=196
    let mut pc: u32 = 0x825F5968;
    'dispatch: loop {
        match pc {
            0x825F5968 => {
    //   block [0x825F5968..0x825F5A2C)
	// 825F5968: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F596C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F5970: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825F5974: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F5978: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F597C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825F5980: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F5984: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825F5988: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825F598C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F5990: 4BCCAFA9  bl 0x822c0938
	ctx.lr = 0x825F5994;
	sub_822C0938(ctx, base);
	// 825F5994: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F5998: 41820028  beq 0x825f59c0
	if ctx.cr[0].eq {
	pc = 0x825F59C0; continue 'dispatch;
	}
	// 825F599C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F59A0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825F59A4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825F59A8: 392B0EF4  addi r9, r11, 0xef4
	ctx.r[9].s64 = ctx.r[11].s64 + 3828;
	// 825F59AC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825F59B0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825F59B4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825F59B8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825F59BC: 48000008  b 0x825f59c4
	pc = 0x825F59C4; continue 'dispatch;
	// 825F59C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F59C4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F59C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F59CC: 409A0044  bne cr6, 0x825f5a10
	if !ctx.cr[6].eq {
	pc = 0x825F5A10; continue 'dispatch;
	}
	// 825F59D0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825F59D4: 419A001C  beq cr6, 0x825f59f0
	if ctx.cr[6].eq {
	pc = 0x825F59F0; continue 'dispatch;
	}
	// 825F59D8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F59DC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825F59E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F59E4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F59E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825F59EC: 4E800421  bctrl
	ctx.lr = 0x825F59F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825F59F0: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825F59F4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825F59F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F59FC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825F5A00: 816BF200  lwz r11, -0xe00(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3584 as u32) ) } as u64;
	// 825F5A04: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825F5A08: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825F5A0C: 4BCCA5F5  bl 0x822c0000
	ctx.lr = 0x825F5A10;
	sub_822C0000(ctx, base);
	// 825F5A10: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F5A14: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825F5A18: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F5A1C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F5A20: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825F5A24: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F5A28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F5A30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F5A30 size=196
    let mut pc: u32 = 0x825F5A30;
    'dispatch: loop {
        match pc {
            0x825F5A30 => {
    //   block [0x825F5A30..0x825F5AF4)
	// 825F5A30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F5A34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F5A38: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825F5A3C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F5A40: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F5A44: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825F5A48: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F5A4C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825F5A50: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825F5A54: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F5A58: 4BCCAEE1  bl 0x822c0938
	ctx.lr = 0x825F5A5C;
	sub_822C0938(ctx, base);
	// 825F5A5C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F5A60: 41820028  beq 0x825f5a88
	if ctx.cr[0].eq {
	pc = 0x825F5A88; continue 'dispatch;
	}
	// 825F5A64: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F5A68: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825F5A6C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825F5A70: 392B0F08  addi r9, r11, 0xf08
	ctx.r[9].s64 = ctx.r[11].s64 + 3848;
	// 825F5A74: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825F5A78: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825F5A7C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825F5A80: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825F5A84: 48000008  b 0x825f5a8c
	pc = 0x825F5A8C; continue 'dispatch;
	// 825F5A88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F5A8C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F5A90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F5A94: 409A0044  bne cr6, 0x825f5ad8
	if !ctx.cr[6].eq {
	pc = 0x825F5AD8; continue 'dispatch;
	}
	// 825F5A98: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825F5A9C: 419A001C  beq cr6, 0x825f5ab8
	if ctx.cr[6].eq {
	pc = 0x825F5AB8; continue 'dispatch;
	}
	// 825F5AA0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F5AA4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825F5AA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F5AAC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F5AB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825F5AB4: 4E800421  bctrl
	ctx.lr = 0x825F5AB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825F5AB8: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825F5ABC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825F5AC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F5AC4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825F5AC8: 816BF200  lwz r11, -0xe00(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3584 as u32) ) } as u64;
	// 825F5ACC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825F5AD0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825F5AD4: 4BCCA52D  bl 0x822c0000
	ctx.lr = 0x825F5AD8;
	sub_822C0000(ctx, base);
	// 825F5AD8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F5ADC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825F5AE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F5AE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F5AE8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825F5AEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F5AF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F5AF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F5AF8 size=196
    let mut pc: u32 = 0x825F5AF8;
    'dispatch: loop {
        match pc {
            0x825F5AF8 => {
    //   block [0x825F5AF8..0x825F5BBC)
	// 825F5AF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F5AFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F5B00: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825F5B04: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F5B08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F5B0C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825F5B10: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F5B14: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825F5B18: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825F5B1C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F5B20: 4BCCAE19  bl 0x822c0938
	ctx.lr = 0x825F5B24;
	sub_822C0938(ctx, base);
	// 825F5B24: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F5B28: 41820028  beq 0x825f5b50
	if ctx.cr[0].eq {
	pc = 0x825F5B50; continue 'dispatch;
	}
	// 825F5B2C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F5B30: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825F5B34: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825F5B38: 392B0F1C  addi r9, r11, 0xf1c
	ctx.r[9].s64 = ctx.r[11].s64 + 3868;
	// 825F5B3C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825F5B40: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825F5B44: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825F5B48: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825F5B4C: 48000008  b 0x825f5b54
	pc = 0x825F5B54; continue 'dispatch;
	// 825F5B50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F5B54: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F5B58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F5B5C: 409A0044  bne cr6, 0x825f5ba0
	if !ctx.cr[6].eq {
	pc = 0x825F5BA0; continue 'dispatch;
	}
	// 825F5B60: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825F5B64: 419A001C  beq cr6, 0x825f5b80
	if ctx.cr[6].eq {
	pc = 0x825F5B80; continue 'dispatch;
	}
	// 825F5B68: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F5B6C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825F5B70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F5B74: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F5B78: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825F5B7C: 4E800421  bctrl
	ctx.lr = 0x825F5B80;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825F5B80: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825F5B84: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825F5B88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F5B8C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825F5B90: 816BF200  lwz r11, -0xe00(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3584 as u32) ) } as u64;
	// 825F5B94: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825F5B98: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825F5B9C: 4BCCA465  bl 0x822c0000
	ctx.lr = 0x825F5BA0;
	sub_822C0000(ctx, base);
	// 825F5BA0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F5BA4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825F5BA8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F5BAC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F5BB0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825F5BB4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F5BB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F5BC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F5BC0 size=196
    let mut pc: u32 = 0x825F5BC0;
    'dispatch: loop {
        match pc {
            0x825F5BC0 => {
    //   block [0x825F5BC0..0x825F5C84)
	// 825F5BC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F5BC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F5BC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825F5BCC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F5BD0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F5BD4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825F5BD8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F5BDC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825F5BE0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825F5BE4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F5BE8: 4BCCAD51  bl 0x822c0938
	ctx.lr = 0x825F5BEC;
	sub_822C0938(ctx, base);
	// 825F5BEC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F5BF0: 41820028  beq 0x825f5c18
	if ctx.cr[0].eq {
	pc = 0x825F5C18; continue 'dispatch;
	}
	// 825F5BF4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F5BF8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825F5BFC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825F5C00: 392B0F30  addi r9, r11, 0xf30
	ctx.r[9].s64 = ctx.r[11].s64 + 3888;
	// 825F5C04: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825F5C08: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825F5C0C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825F5C10: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825F5C14: 48000008  b 0x825f5c1c
	pc = 0x825F5C1C; continue 'dispatch;
	// 825F5C18: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F5C1C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F5C20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F5C24: 409A0044  bne cr6, 0x825f5c68
	if !ctx.cr[6].eq {
	pc = 0x825F5C68; continue 'dispatch;
	}
	// 825F5C28: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825F5C2C: 419A001C  beq cr6, 0x825f5c48
	if ctx.cr[6].eq {
	pc = 0x825F5C48; continue 'dispatch;
	}
	// 825F5C30: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F5C34: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825F5C38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F5C3C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825F5C40: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825F5C44: 4E800421  bctrl
	ctx.lr = 0x825F5C48;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825F5C48: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825F5C4C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825F5C50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F5C54: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825F5C58: 816BF200  lwz r11, -0xe00(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3584 as u32) ) } as u64;
	// 825F5C5C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825F5C60: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825F5C64: 4BCCA39D  bl 0x822c0000
	ctx.lr = 0x825F5C68;
	sub_822C0000(ctx, base);
	// 825F5C68: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F5C6C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825F5C70: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F5C74: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F5C78: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825F5C7C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F5C80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F5C88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F5C88 size=196
    let mut pc: u32 = 0x825F5C88;
    'dispatch: loop {
        match pc {
            0x825F5C88 => {
    //   block [0x825F5C88..0x825F5D4C)
	// 825F5C88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F5C8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F5C90: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825F5C94: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F5C98: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F5C9C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825F5CA0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F5CA4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825F5CA8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825F5CAC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F5CB0: 4BCCAC89  bl 0x822c0938
	ctx.lr = 0x825F5CB4;
	sub_822C0938(ctx, base);
	// 825F5CB4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F5CB8: 41820028  beq 0x825f5ce0
	if ctx.cr[0].eq {
	pc = 0x825F5CE0; continue 'dispatch;
	}
	// 825F5CBC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F5CC0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825F5CC4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825F5CC8: 392B0F44  addi r9, r11, 0xf44
	ctx.r[9].s64 = ctx.r[11].s64 + 3908;
	// 825F5CCC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825F5CD0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825F5CD4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825F5CD8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825F5CDC: 48000008  b 0x825f5ce4
	pc = 0x825F5CE4; continue 'dispatch;
	// 825F5CE0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F5CE4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F5CE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F5CEC: 409A0044  bne cr6, 0x825f5d30
	if !ctx.cr[6].eq {
	pc = 0x825F5D30; continue 'dispatch;
	}
	// 825F5CF0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825F5CF4: 419A001C  beq cr6, 0x825f5d10
	if ctx.cr[6].eq {
	pc = 0x825F5D10; continue 'dispatch;
	}
	// 825F5CF8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F5CFC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825F5D00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F5D04: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825F5D08: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825F5D0C: 4E800421  bctrl
	ctx.lr = 0x825F5D10;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825F5D10: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825F5D14: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825F5D18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F5D1C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825F5D20: 816BF200  lwz r11, -0xe00(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3584 as u32) ) } as u64;
	// 825F5D24: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825F5D28: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825F5D2C: 4BCCA2D5  bl 0x822c0000
	ctx.lr = 0x825F5D30;
	sub_822C0000(ctx, base);
	// 825F5D30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F5D34: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825F5D38: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F5D3C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F5D40: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825F5D44: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F5D48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F5D50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F5D50 size=196
    let mut pc: u32 = 0x825F5D50;
    'dispatch: loop {
        match pc {
            0x825F5D50 => {
    //   block [0x825F5D50..0x825F5E14)
	// 825F5D50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F5D54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F5D58: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825F5D5C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F5D60: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F5D64: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825F5D68: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F5D6C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825F5D70: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825F5D74: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F5D78: 4BCCABC1  bl 0x822c0938
	ctx.lr = 0x825F5D7C;
	sub_822C0938(ctx, base);
	// 825F5D7C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F5D80: 41820028  beq 0x825f5da8
	if ctx.cr[0].eq {
	pc = 0x825F5DA8; continue 'dispatch;
	}
	// 825F5D84: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F5D88: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825F5D8C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825F5D90: 392B0F58  addi r9, r11, 0xf58
	ctx.r[9].s64 = ctx.r[11].s64 + 3928;
	// 825F5D94: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825F5D98: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825F5D9C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825F5DA0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825F5DA4: 48000008  b 0x825f5dac
	pc = 0x825F5DAC; continue 'dispatch;
	// 825F5DA8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F5DAC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F5DB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F5DB4: 409A0044  bne cr6, 0x825f5df8
	if !ctx.cr[6].eq {
	pc = 0x825F5DF8; continue 'dispatch;
	}
	// 825F5DB8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825F5DBC: 419A001C  beq cr6, 0x825f5dd8
	if ctx.cr[6].eq {
	pc = 0x825F5DD8; continue 'dispatch;
	}
	// 825F5DC0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F5DC4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825F5DC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F5DCC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825F5DD0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825F5DD4: 4E800421  bctrl
	ctx.lr = 0x825F5DD8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825F5DD8: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825F5DDC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825F5DE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F5DE4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825F5DE8: 816BF200  lwz r11, -0xe00(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3584 as u32) ) } as u64;
	// 825F5DEC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825F5DF0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825F5DF4: 4BCCA20D  bl 0x822c0000
	ctx.lr = 0x825F5DF8;
	sub_822C0000(ctx, base);
	// 825F5DF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F5DFC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825F5E00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F5E04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F5E08: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825F5E0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F5E10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F5E18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F5E18 size=196
    let mut pc: u32 = 0x825F5E18;
    'dispatch: loop {
        match pc {
            0x825F5E18 => {
    //   block [0x825F5E18..0x825F5EDC)
	// 825F5E18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F5E1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F5E20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825F5E24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F5E28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F5E2C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825F5E30: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F5E34: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825F5E38: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825F5E3C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F5E40: 4BCCAAF9  bl 0x822c0938
	ctx.lr = 0x825F5E44;
	sub_822C0938(ctx, base);
	// 825F5E44: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F5E48: 41820028  beq 0x825f5e70
	if ctx.cr[0].eq {
	pc = 0x825F5E70; continue 'dispatch;
	}
	// 825F5E4C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F5E50: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825F5E54: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825F5E58: 392B0F6C  addi r9, r11, 0xf6c
	ctx.r[9].s64 = ctx.r[11].s64 + 3948;
	// 825F5E5C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825F5E60: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825F5E64: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825F5E68: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825F5E6C: 48000008  b 0x825f5e74
	pc = 0x825F5E74; continue 'dispatch;
	// 825F5E70: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F5E74: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F5E78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F5E7C: 409A0044  bne cr6, 0x825f5ec0
	if !ctx.cr[6].eq {
	pc = 0x825F5EC0; continue 'dispatch;
	}
	// 825F5E80: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825F5E84: 419A001C  beq cr6, 0x825f5ea0
	if ctx.cr[6].eq {
	pc = 0x825F5EA0; continue 'dispatch;
	}
	// 825F5E88: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F5E8C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825F5E90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F5E94: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825F5E98: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825F5E9C: 4E800421  bctrl
	ctx.lr = 0x825F5EA0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825F5EA0: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825F5EA4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825F5EA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F5EAC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825F5EB0: 816BF200  lwz r11, -0xe00(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3584 as u32) ) } as u64;
	// 825F5EB4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825F5EB8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825F5EBC: 4BCCA145  bl 0x822c0000
	ctx.lr = 0x825F5EC0;
	sub_822C0000(ctx, base);
	// 825F5EC0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F5EC4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825F5EC8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F5ECC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F5ED0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825F5ED4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F5ED8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F5EE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F5EE0 size=172
    let mut pc: u32 = 0x825F5EE0;
    'dispatch: loop {
        match pc {
            0x825F5EE0 => {
    //   block [0x825F5EE0..0x825F5F8C)
	// 825F5EE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F5EE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F5EE8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825F5EEC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F5EF0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F5EF4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825F5EF8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F5EFC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825F5F00: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825F5F04: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F5F08: 4BCCAA31  bl 0x822c0938
	ctx.lr = 0x825F5F0C;
	sub_822C0938(ctx, base);
	// 825F5F0C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F5F10: 41820028  beq 0x825f5f38
	if ctx.cr[0].eq {
	pc = 0x825F5F38; continue 'dispatch;
	}
	// 825F5F14: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F5F18: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825F5F1C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825F5F20: 392B0F80  addi r9, r11, 0xf80
	ctx.r[9].s64 = ctx.r[11].s64 + 3968;
	// 825F5F24: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825F5F28: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825F5F2C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825F5F30: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825F5F34: 48000008  b 0x825f5f3c
	pc = 0x825F5F3C; continue 'dispatch;
	// 825F5F38: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F5F3C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F5F40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F5F44: 409A002C  bne cr6, 0x825f5f70
	if !ctx.cr[6].eq {
	pc = 0x825F5F70; continue 'dispatch;
	}
	// 825F5F48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F5F4C: 4BCCA31D  bl 0x822c0268
	ctx.lr = 0x825F5F50;
	sub_822C0268(ctx, base);
	// 825F5F50: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825F5F54: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825F5F58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F5F5C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825F5F60: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825F5F64: 816BF200  lwz r11, -0xe00(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3584 as u32) ) } as u64;
	// 825F5F68: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825F5F6C: 4BCCA095  bl 0x822c0000
	ctx.lr = 0x825F5F70;
	sub_822C0000(ctx, base);
	// 825F5F70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F5F74: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825F5F78: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F5F7C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F5F80: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825F5F84: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F5F88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F5F90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825F5F90 size=164
    let mut pc: u32 = 0x825F5F90;
    'dispatch: loop {
        match pc {
            0x825F5F90 => {
    //   block [0x825F5F90..0x825F6034)
	// 825F5F90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F5F94: 48BB21D9  bl 0x831a816c
	ctx.lr = 0x825F5F98;
	sub_831A8130(ctx, base);
	// 825F5F98: 9421FE50  stwu r1, -0x1b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-432 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F5F9C: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 825F5FA0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F5FA4: 4BF1BDF5  bl 0x82511d98
	ctx.lr = 0x825F5FA8;
	sub_82511D98(ctx, base);
	// 825F5FA8: 389F0120  addi r4, r31, 0x120
	ctx.r[4].s64 = ctx.r[31].s64 + 288;
	// 825F5FAC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F5FB0: 48885F79  bl 0x82e7bf28
	ctx.lr = 0x825F5FB4;
	sub_82E7BF28(ctx, base);
	// 825F5FB4: 389F00F0  addi r4, r31, 0xf0
	ctx.r[4].s64 = ctx.r[31].s64 + 240;
	// 825F5FB8: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 825F5FBC: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 825F5FC0: 3BA10090  addi r29, r1, 0x90
	ctx.r[29].s64 = ctx.r[1].s64 + 144;
	// 825F5FC4: 83FF0110  lwz r31, 0x110(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 825F5FC8: 48886011  bl 0x82e7bfd8
	ctx.lr = 0x825F5FCC;
	sub_82E7BFD8(ctx, base);
	// 825F5FCC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825F5FD0: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 825F5FD4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825F5FD8: 4BCCE929  bl 0x822c4900
	ctx.lr = 0x825F5FDC;
	sub_822C4900(ctx, base);
	// 825F5FDC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825F5FE0: 38610150  addi r3, r1, 0x150
	ctx.r[3].s64 = ctx.r[1].s64 + 336;
	// 825F5FE4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825F5FE8: 4BCCE919  bl 0x822c4900
	ctx.lr = 0x825F5FEC;
	sub_822C4900(ctx, base);
	// 825F5FEC: 815F0084  lwz r10, 0x84(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 825F5FF0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 825F5FF4: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 825F5FF8: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 825F5FFC: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 825F6000: 396A0010  addi r11, r10, 0x10
	ctx.r[11].s64 = ctx.r[10].s64 + 16;
	// 825F6004: 13E03407  vcmpneb. (lvlx128) v31, v0, v6
	tmp.u32 = ctx.r[6].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 825F6008: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 825F600C: 13C73407  vcmpneb. (lvlx128) v30, v7, v6
	tmp.u32 = ctx.r[7].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 825F6010: 13A83407  vcmpneb. (lvlx128) v29, v8, v6
	tmp.u32 = ctx.r[8].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 825F6014: 13893407  vcmpneb. (lvlx128) v28, v9, v6
	tmp.u32 = ctx.r[9].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F6038(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825F6038 size=184
    let mut pc: u32 = 0x825F6038;
    'dispatch: loop {
        match pc {
            0x825F6038 => {
    //   block [0x825F6038..0x825F60F0)
	// 825F6038: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F603C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F6040: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F6044: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 825F6048: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F604C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 825F6050: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825F6054: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F6058: C00B9F7C  lfs f0, -0x6084(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24708 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825F605C: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 825F6060: 40990078  ble cr6, 0x825f60d8
	if !ctx.cr[6].gt {
	pc = 0x825F60D8; continue 'dispatch;
	}
	// 825F6064: 809F0130  lwz r4, 0x130(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(304 as u32) ) } as u64;
	// 825F6068: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825F606C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F6070: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825F6074: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825F6078: 4E800421  bctrl
	ctx.lr = 0x825F607C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825F607C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F6080: 4BF1BA69  bl 0x82511ae8
	ctx.lr = 0x825F6084;
	sub_82511AE8(ctx, base);
	// 825F6084: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825F6088: 394000F0  li r10, 0xf0
	ctx.r[10].s64 = 240;
	// 825F608C: 807F0130  lwz r3, 0x130(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(304 as u32) ) } as u64;
	// 825F6090: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 825F6094: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 825F6098: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 825F609C: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 825F60A0: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 825F60A4: 13DF50C7  vcmpequd (lvx128) v30, v31, v10
	tmp.u32 = ctx.r[31].u32 + ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 825F60A8: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F60F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825F60F0 size=420
    let mut pc: u32 = 0x825F60F0;
    'dispatch: loop {
        match pc {
            0x825F60F0 => {
    //   block [0x825F60F0..0x825F6294)
	// 825F60F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F60F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F60F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825F60FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F6100: DBC1FFD8  stfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 825F6104: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 825F6108: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F610C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F6110: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825F6114: 4BF1BA45  bl 0x82511b58
	ctx.lr = 0x825F6118;
	sub_82511B58(ctx, base);
	// 825F6118: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825F611C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825F6120: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 825F6124: 895F0158  lbz r10, 0x158(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(344 as u32) ) } as u64;
	// 825F6128: C0030004  lfs f0, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825F612C: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 825F6130: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F6134: C0030008  lfs f0, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825F6138: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 825F613C: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825F6140: C003000C  lfs f0, 0xc(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825F6144: FFC0F890  fmr f30, f31
	ctx.f[30].f64 = ctx.f[31].f64;
	// 825F6148: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 825F614C: 4182002C  beq 0x825f6178
	if ctx.cr[0].eq {
	pc = 0x825F6178; continue 'dispatch;
	}
	// 825F6150: 897F0159  lbz r11, 0x159(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(345 as u32) ) } as u64;
	// 825F6154: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F6158: 41820060  beq 0x825f61b8
	if ctx.cr[0].eq {
	pc = 0x825F61B8; continue 'dispatch;
	}
	// 825F615C: C1BE0000  lfs f13, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825F6160: C01F015C  lfs f0, 0x15c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(348 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825F6164: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 825F6168: C1BF0148  lfs f13, 0x148(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(328 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825F616C: D01F015C  stfs f0, 0x15c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(348 as u32), tmp.u32 ) };
	// 825F6170: EFCD0032  fmuls f30, f13, f0
	ctx.f[30].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 825F6174: 48000044  b 0x825f61b8
	pc = 0x825F61B8; continue 'dispatch;
	// 825F6178: 897F0141  lbz r11, 0x141(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(321 as u32) ) } as u64;
	// 825F617C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F6180: 41820038  beq 0x825f61b8
	if ctx.cr[0].eq {
	pc = 0x825F61B8; continue 'dispatch;
	}
	// 825F6184: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F6188: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825F618C: 4BF1933D  bl 0x8250f4c8
	ctx.lr = 0x825F6190;
	sub_8250F4C8(ctx, base);
	// 825F6190: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F6194: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F6198: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 825F619C: 409A0008  bne cr6, 0x825f61a4
	if !ctx.cr[6].eq {
	pc = 0x825F61A4; continue 'dispatch;
	}
	// 825F61A0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825F61A4: 4BF12375  bl 0x82508518
	ctx.lr = 0x825F61A8;
	sub_82508518(ctx, base);
	// 825F61A8: C01F0148  lfs f0, 0x148(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(328 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825F61AC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825F61B0: EFC10032  fmuls f30, f1, f0
	ctx.f[30].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 825F61B4: 487FBADD  bl 0x82df1c90
	ctx.lr = 0x825F61B8;
	sub_82DF1C90(ctx, base);
	// 825F61B8: C01F0150  lfs f0, 0x150(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825F61BC: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 825F61C0: ED80F02A  fadds f12, f0, f30
	ctx.f[12].f64 = ((ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64;
	// 825F61C4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 825F61C8: C00BDFAC  lfs f0, -0x2054(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825F61CC: C1AA9524  lfs f13, -0x6adc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825F61D0: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 825F61D4: EC200372  fmuls f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 825F61D8: 48BB2BF1  bl 0x831a8dc8
	ctx.lr = 0x825F61DC;
	sub_831A8DC8(ctx, base);
	// 825F61DC: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 825F61E0: 817F0154  lwz r11, 0x154(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(340 as u32) ) } as u64;
	// 825F61E4: C1BF014C  lfs f13, 0x14c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(332 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825F61E8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 825F61EC: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 825F61F0: 41980018  blt cr6, 0x825f6208
	if ctx.cr[6].lt {
	pc = 0x825F6208; continue 'dispatch;
	}
	// 825F61F4: 409A0034  bne cr6, 0x825f6228
	if !ctx.cr[6].eq {
	pc = 0x825F6228; continue 'dispatch;
	}
	// 825F61F8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825F61FC: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 825F6200: D3E10054  stfs f31, 0x54(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 825F6204: 48000010  b 0x825f6214
	pc = 0x825F6214; continue 'dispatch;
	// 825F6208: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825F620C: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 825F6210: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 825F6214: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 825F6218: D3E10058  stfs f31, 0x58(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 825F621C: D3E1005C  stfs f31, 0x5c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 825F6220: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F6298(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825F6298 size=192
    let mut pc: u32 = 0x825F6298;
    'dispatch: loop {
        match pc {
            0x825F6298 => {
    //   block [0x825F6298..0x825F6358)
	// 825F6298: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F629C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F62A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F62A4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F62A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F62AC: 4BF1BFB5  bl 0x82512260
	ctx.lr = 0x825F62B0;
	sub_82512260(ctx, base);
	// 825F62B0: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825F62B4: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 825F62B8: 394AA214  addi r10, r10, -0x5dec
	ctx.r[10].s64 = ctx.r[10].s64 + -24044;
	// 825F62BC: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 825F62C0: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 825F62C4: 915F00E4  stw r10, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[10].u32 ) };
	// 825F62C8: 3CE08204  lis r7, -0x7dfc
	ctx.r[7].s64 = -2113667072;
	// 825F62CC: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 825F62D0: 394810D8  addi r10, r8, 0x10d8
	ctx.r[10].s64 = ctx.r[8].s64 + 4312;
	// 825F62D4: 39291094  addi r9, r9, 0x1094
	ctx.r[9].s64 = ctx.r[9].s64 + 4244;
	// 825F62D8: 38C000F0  li r6, 0xf0
	ctx.r[6].s64 = 240;
	// 825F62DC: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 825F62E0: 39071044  addi r8, r7, 0x1044
	ctx.r[8].s64 = ctx.r[7].s64 + 4164;
	// 825F62E4: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825F62E8: 39200100  li r9, 0x100
	ctx.r[9].s64 = 256;
	// 825F62EC: 911F00E4  stw r8, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[8].u32 ) };
	// 825F62F0: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 825F62F4: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F6358(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825F6358 size=8
    let mut pc: u32 = 0x825F6358;
    'dispatch: loop {
        match pc {
            0x825F6358 => {
    //   block [0x825F6358..0x825F6360)
	// 825F6358: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 825F635C: 48000B2C  b 0x825f6e88
	sub_825F6E88(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F6360(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825F6360 size=8
    let mut pc: u32 = 0x825F6360;
    'dispatch: loop {
        match pc {
            0x825F6360 => {
    //   block [0x825F6360..0x825F6368)
	// 825F6360: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 825F6364: 48000B24  b 0x825f6e88
	sub_825F6E88(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F6368(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F6368 size=232
    let mut pc: u32 = 0x825F6368;
    'dispatch: loop {
        match pc {
            0x825F6368 => {
    //   block [0x825F6368..0x825F6450)
	// 825F6368: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F636C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F6370: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825F6374: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F6378: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F637C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F6380: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F6384: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825F6388: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 825F638C: 396B1094  addi r11, r11, 0x1094
	ctx.r[11].s64 = ctx.r[11].s64 + 4244;
	// 825F6390: 394A10D8  addi r10, r10, 0x10d8
	ctx.r[10].s64 = ctx.r[10].s64 + 4312;
	// 825F6394: 39291044  addi r9, r9, 0x1044
	ctx.r[9].s64 = ctx.r[9].s64 + 4164;
	// 825F6398: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F639C: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 825F63A0: 3BDF00E4  addi r30, r31, 0xe4
	ctx.r[30].s64 = ctx.r[31].s64 + 228;
	// 825F63A4: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 825F63A8: 815F0110  lwz r10, 0x110(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 825F63AC: 817F0114  lwz r11, 0x114(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 825F63B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F63B4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825F63B8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825F63BC: 419A0024  beq cr6, 0x825f63e0
	if ctx.cr[6].eq {
	pc = 0x825F63E0; continue 'dispatch;
	}
	// 825F63C0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825F63C4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825F63C8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F63CC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825F63D0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825F63D4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825F63D8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F63DC: 4082FFE8  bne 0x825f63c4
	if !ctx.cr[0].eq {
	pc = 0x825F63C4; continue 'dispatch;
	}
	// 825F63E0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825F63E4: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 825F63E8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825F63EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F63F0: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 825F63F4: 4BF19CCD  bl 0x825100c0
	ctx.lr = 0x825F63F8;
	sub_825100C0(ctx, base);
	// 825F63F8: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825F63FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F6400: 419A0008  beq cr6, 0x825f6408
	if ctx.cr[6].eq {
	pc = 0x825F6408; continue 'dispatch;
	}
	// 825F6404: 4BCCA48D  bl 0x822c0890
	ctx.lr = 0x825F6408;
	sub_822C0890(ctx, base);
	// 825F6408: 807F0134  lwz r3, 0x134(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) } as u64;
	// 825F640C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F6410: 419A0008  beq cr6, 0x825f6418
	if ctx.cr[6].eq {
	pc = 0x825F6418; continue 'dispatch;
	}
	// 825F6414: 4BCCA47D  bl 0x822c0890
	ctx.lr = 0x825F6418;
	sub_822C0890(ctx, base);
	// 825F6418: 807F0114  lwz r3, 0x114(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 825F641C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F6420: 419A0008  beq cr6, 0x825f6428
	if ctx.cr[6].eq {
	pc = 0x825F6428; continue 'dispatch;
	}
	// 825F6424: 4BCCA46D  bl 0x822c0890
	ctx.lr = 0x825F6428;
	sub_822C0890(ctx, base);
	// 825F6428: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F642C: 481B122D  bl 0x827a7658
	ctx.lr = 0x825F6430;
	sub_827A7658(ctx, base);
	// 825F6430: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F6434: 4BD58F1D  bl 0x8234f350
	ctx.lr = 0x825F6438;
	sub_8234F350(ctx, base);
	// 825F6438: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825F643C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F6440: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F6444: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825F6448: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F644C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F6450(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825F6450 size=8
    let mut pc: u32 = 0x825F6450;
    'dispatch: loop {
        match pc {
            0x825F6450 => {
    //   block [0x825F6450..0x825F6458)
	// 825F6450: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 825F6454: 4BFFFB3C  b 0x825f5f90
	sub_825F5F90(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F6458(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825F6458 size=144
    let mut pc: u32 = 0x825F6458;
    'dispatch: loop {
        match pc {
            0x825F6458 => {
    //   block [0x825F6458..0x825F64E8)
	// 825F6458: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F645C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F6460: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F6464: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F6468: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F646C: 4BFFFE2D  bl 0x825f6298
	ctx.lr = 0x825F6470;
	sub_825F6298(ctx, base);
	// 825F6470: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825F6474: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 825F6478: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 825F647C: 3CE08204  lis r7, -0x7dfc
	ctx.r[7].s64 = -2113667072;
	// 825F6480: 3CC08204  lis r6, -0x7dfc
	ctx.r[6].s64 = -2113667072;
	// 825F6484: C00A08A8  lfs f0, 0x8a8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825F6488: 3948114C  addi r10, r8, 0x114c
	ctx.r[10].s64 = ctx.r[8].s64 + 4428;
	// 825F648C: C1A908A4  lfs f13, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825F6490: 39271138  addi r9, r7, 0x1138
	ctx.r[9].s64 = ctx.r[7].s64 + 4408;
	// 825F6494: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F6498: D01F0148  stfs f0, 0x148(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(328 as u32), tmp.u32 ) };
	// 825F649C: 390610EC  addi r8, r6, 0x10ec
	ctx.r[8].s64 = ctx.r[6].s64 + 4332;
	// 825F64A0: D01F014C  stfs f0, 0x14c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(332 as u32), tmp.u32 ) };
	// 825F64A4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825F64A8: D1BF0150  stfs f13, 0x150(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), tmp.u32 ) };
	// 825F64AC: D1BF015C  stfs f13, 0x15c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(348 as u32), tmp.u32 ) };
	// 825F64B0: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825F64B4: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 825F64B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F64BC: 911F00E4  stw r8, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[8].u32 ) };
	// 825F64C0: 997F0140  stb r11, 0x140(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(320 as u32), ctx.r[11].u8 ) };
	// 825F64C4: 98FF0141  stb r7, 0x141(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(321 as u32), ctx.r[7].u8 ) };
	// 825F64C8: 917F0154  stw r11, 0x154(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(340 as u32), ctx.r[11].u32 ) };
	// 825F64CC: 997F0158  stb r11, 0x158(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(344 as u32), ctx.r[11].u8 ) };
	// 825F64D0: 997F0159  stb r11, 0x159(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(345 as u32), ctx.r[11].u8 ) };
	// 825F64D4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825F64D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F64DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F64E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F64E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F64E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825F64E8 size=8
    let mut pc: u32 = 0x825F64E8;
    'dispatch: loop {
        match pc {
            0x825F64E8 => {
    //   block [0x825F64E8..0x825F64F0)
	// 825F64E8: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 825F64EC: 48000EEC  b 0x825f73d8
	sub_825F73D8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F64F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825F64F0 size=8
    let mut pc: u32 = 0x825F64F0;
    'dispatch: loop {
        match pc {
            0x825F64F0 => {
    //   block [0x825F64F0..0x825F64F8)
	// 825F64F0: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 825F64F4: 48000EE4  b 0x825f73d8
	sub_825F73D8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F64F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825F64F8 size=172
    let mut pc: u32 = 0x825F64F8;
    'dispatch: loop {
        match pc {
            0x825F64F8 => {
    //   block [0x825F64F8..0x825F65A4)
	// 825F64F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F64FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F6500: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F6504: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F6508: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F650C: 4BFFFD8D  bl 0x825f6298
	ctx.lr = 0x825F6510;
	sub_825F6298(ctx, base);
	// 825F6510: 387F0140  addi r3, r31, 0x140
	ctx.r[3].s64 = ctx.r[31].s64 + 320;
	// 825F6514: 488673BD  bl 0x82e5d8d0
	ctx.lr = 0x825F6518;
	sub_82E5D8D0(ctx, base);
	// 825F6518: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 825F651C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 825F6520: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F6524: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 825F6528: 3CE08204  lis r7, -0x7dfc
	ctx.r[7].s64 = -2113667072;
	// 825F652C: C1A9D7BC  lfs f13, -0x2844(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825F6530: 392B0EE4  addi r9, r11, 0xee4
	ctx.r[9].s64 = ctx.r[11].s64 + 3812;
	// 825F6534: C00AA1C4  lfs f0, -0x5e3c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825F6538: 3CC08204  lis r6, -0x7dfc
	ctx.r[6].s64 = -2113667072;
	// 825F653C: 3CA08204  lis r5, -0x7dfc
	ctx.r[5].s64 = -2113667072;
	// 825F6540: 913F0140  stw r9, 0x140(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(320 as u32), ctx.r[9].u32 ) };
	// 825F6544: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825F6548: C1889450  lfs f12, -0x6bb0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825F654C: 39071204  addi r8, r7, 0x1204
	ctx.r[8].s64 = ctx.r[7].s64 + 4612;
	// 825F6550: D01F01D0  stfs f0, 0x1d0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(464 as u32), tmp.u32 ) };
	// 825F6554: 392611F0  addi r9, r6, 0x11f0
	ctx.r[9].s64 = ctx.r[6].s64 + 4592;
	// 825F6558: D1BF01D4  stfs f13, 0x1d4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(468 as u32), tmp.u32 ) };
	// 825F655C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F6560: D19F01D8  stfs f12, 0x1d8(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(472 as u32), tmp.u32 ) };
	// 825F6564: 38E511A4  addi r7, r5, 0x11a4
	ctx.r[7].s64 = ctx.r[5].s64 + 4516;
	// 825F6568: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825F656C: 394A1190  addi r10, r10, 0x1190
	ctx.r[10].s64 = ctx.r[10].s64 + 4496;
	// 825F6570: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 825F6574: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 825F6578: 90FF00E4  stw r7, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[7].u32 ) };
	// 825F657C: 915F0140  stw r10, 0x140(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(320 as u32), ctx.r[10].u32 ) };
	// 825F6580: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F6584: 98DF01DC  stb r6, 0x1dc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(476 as u32), ctx.r[6].u8 ) };
	// 825F6588: 997F01DD  stb r11, 0x1dd(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(477 as u32), ctx.r[11].u8 ) };
	// 825F658C: 997F01DE  stb r11, 0x1de(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(478 as u32), ctx.r[11].u8 ) };
	// 825F6590: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825F6594: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F6598: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F659C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F65A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F65A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825F65A8 size=8
    let mut pc: u32 = 0x825F65A8;
    'dispatch: loop {
        match pc {
            0x825F65A8 => {
    //   block [0x825F65A8..0x825F65B0)
	// 825F65A8: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 825F65AC: 48001154  b 0x825f7700
	sub_825F7700(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F65B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825F65B0 size=8
    let mut pc: u32 = 0x825F65B0;
    'dispatch: loop {
        match pc {
            0x825F65B0 => {
    //   block [0x825F65B0..0x825F65B8)
	// 825F65B0: 3863FEC0  addi r3, r3, -0x140
	ctx.r[3].s64 = ctx.r[3].s64 + -320;
	// 825F65B4: 4800114C  b 0x825f7700
	sub_825F7700(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F65B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825F65B8 size=8
    let mut pc: u32 = 0x825F65B8;
    'dispatch: loop {
        match pc {
            0x825F65B8 => {
    //   block [0x825F65B8..0x825F65C0)
	// 825F65B8: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 825F65BC: 48001144  b 0x825f7700
	sub_825F7700(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F65C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F65C0 size=104
    let mut pc: u32 = 0x825F65C0;
    'dispatch: loop {
        match pc {
            0x825F65C0 => {
    //   block [0x825F65C0..0x825F6628)
	// 825F65C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F65C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F65C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F65CC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F65D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F65D4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F65D8: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 825F65DC: 396B1204  addi r11, r11, 0x1204
	ctx.r[11].s64 = ctx.r[11].s64 + 4612;
	// 825F65E0: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825F65E4: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 825F65E8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F65EC: 394A11F0  addi r10, r10, 0x11f0
	ctx.r[10].s64 = ctx.r[10].s64 + 4592;
	// 825F65F0: 392911A4  addi r9, r9, 0x11a4
	ctx.r[9].s64 = ctx.r[9].s64 + 4516;
	// 825F65F4: 39681190  addi r11, r8, 0x1190
	ctx.r[11].s64 = ctx.r[8].s64 + 4496;
	// 825F65F8: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 825F65FC: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 825F6600: 387F0140  addi r3, r31, 0x140
	ctx.r[3].s64 = ctx.r[31].s64 + 320;
	// 825F6604: 917F0140  stw r11, 0x140(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(320 as u32), ctx.r[11].u32 ) };
	// 825F6608: 48867241  bl 0x82e5d848
	ctx.lr = 0x825F660C;
	sub_82E5D848(ctx, base);
	// 825F660C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F6610: 4BFFFD59  bl 0x825f6368
	ctx.lr = 0x825F6614;
	sub_825F6368(ctx, base);
	// 825F6614: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825F6618: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F661C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F6620: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F6624: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F6628(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825F6628 size=620
    let mut pc: u32 = 0x825F6628;
    'dispatch: loop {
        match pc {
            0x825F6628 => {
    //   block [0x825F6628..0x825F6894)
	// 825F6628: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F662C: 48BB1B3D  bl 0x831a8168
	ctx.lr = 0x825F6630;
	sub_831A8130(ctx, base);
	// 825F6630: DBC1FFC8  stfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 825F6634: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 825F6638: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F663C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825F6640: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 825F6644: 4BF1C455  bl 0x82512a98
	ctx.lr = 0x825F6648;
	sub_82512A98(ctx, base);
	// 825F6648: 39600120  li r11, 0x120
	ctx.r[11].s64 = 288;
	// 825F664C: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F6650: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 825F6654: 39000014  li r8, 0x14
	ctx.r[8].s64 = 20;
	// 825F6658: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 825F665C: 38800030  li r4, 0x30
	ctx.r[4].s64 = 48;
	// 825F6660: 13FD58C7  vcmpequd (lvx128) v31, v29, v11
	tmp.u32 = ctx.r[29].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F6898(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825F6898 size=328
    let mut pc: u32 = 0x825F6898;
    'dispatch: loop {
        match pc {
            0x825F6898 => {
    //   block [0x825F6898..0x825F69E0)
	// 825F6898: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F689C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F68A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825F68A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F68A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F68AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825F68B0: 48B5DD51  bl 0x83154600
	ctx.lr = 0x825F68B4;
	sub_83154600(ctx, base);
	// 825F68B4: 896301DD  lbz r11, 0x1dd(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(477 as u32) ) } as u64;
	// 825F68B8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F68BC: 4182010C  beq 0x825f69c8
	if ctx.cr[0].eq {
	pc = 0x825F69C8; continue 'dispatch;
	}
	// 825F68C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F68C4: 48B5DD3D  bl 0x83154600
	ctx.lr = 0x825F68C8;
	sub_83154600(ctx, base);
	// 825F68C8: 896301DE  lbz r11, 0x1de(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(478 as u32) ) } as u64;
	// 825F68CC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F68D0: 418200F8  beq 0x825f69c8
	if ctx.cr[0].eq {
	pc = 0x825F69C8; continue 'dispatch;
	}
	// 825F68D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F68D8: 48B5DD29  bl 0x83154600
	ctx.lr = 0x825F68DC;
	sub_83154600(ctx, base);
	// 825F68DC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F68E0: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825F68E4: 996301DE  stb r11, 0x1de(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(478 as u32), ctx.r[11].u8 ) };
	// 825F68E8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F68EC: 388A1248  addi r4, r10, 0x1248
	ctx.r[4].s64 = ctx.r[10].s64 + 4680;
	// 825F68F0: 38A00178  li r5, 0x178
	ctx.r[5].s64 = 376;
	// 825F68F4: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 825F68F8: 487FBAF1  bl 0x82df23e8
	ctx.lr = 0x825F68FC;
	sub_82DF23E8(ctx, base);
	// 825F68FC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825F6900: 4182001C  beq 0x825f691c
	if ctx.cr[0].eq {
	pc = 0x825F691C; continue 'dispatch;
	}
	// 825F6904: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F6908: 48866021  bl 0x82e5c928
	ctx.lr = 0x825F690C;
	sub_82E5C928(ctx, base);
	// 825F690C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F6910: 396B0FE4  addi r11, r11, 0xfe4
	ctx.r[11].s64 = ctx.r[11].s64 + 4068;
	// 825F6914: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F6918: 48000008  b 0x825f6920
	pc = 0x825F6920; continue 'dispatch;
	// 825F691C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825F6920: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825F6924: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F6928: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F692C: 4BFFF425  bl 0x825f5d50
	ctx.lr = 0x825F6930;
	sub_825F5D50(ctx, base);
	// 825F6930: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825F6934: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F6938: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F693C: 4BCC96C5  bl 0x822c0000
	ctx.lr = 0x825F6940;
	sub_822C0000(ctx, base);
	// 825F6940: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825F6944: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825F6948: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825F694C: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825F6950: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825F6954: 419A0024  beq cr6, 0x825f6978
	if ctx.cr[6].eq {
	pc = 0x825F6978; continue 'dispatch;
	}
	// 825F6958: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 825F695C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825F6960: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F6964: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825F6968: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825F696C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825F6970: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F6974: 4082FFE8  bne 0x825f695c
	if !ctx.cr[0].eq {
	pc = 0x825F695C; continue 'dispatch;
	}
	// 825F6978: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825F697C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825F6980: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F6984: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825F6988: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825F698C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825F6990: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825F6994: 48867F2D  bl 0x82e5e8c0
	ctx.lr = 0x825F6998;
	sub_82E5E8C0(ctx, base);
	// 825F6998: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825F699C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F69A0: 419A0008  beq cr6, 0x825f69a8
	if ctx.cr[6].eq {
	pc = 0x825F69A8; continue 'dispatch;
	}
	// 825F69A4: 4BCC9EED  bl 0x822c0890
	ctx.lr = 0x825F69A8;
	sub_822C0890(ctx, base);
	// 825F69A8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825F69AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F69B0: 419A0008  beq cr6, 0x825f69b8
	if ctx.cr[6].eq {
	pc = 0x825F69B8; continue 'dispatch;
	}
	// 825F69B4: 4BCC9EDD  bl 0x822c0890
	ctx.lr = 0x825F69B8;
	sub_822C0890(ctx, base);
	// 825F69B8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825F69BC: 419A000C  beq cr6, 0x825f69c8
	if ctx.cr[6].eq {
	pc = 0x825F69C8; continue 'dispatch;
	}
	// 825F69C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F69C4: 4BCC9ECD  bl 0x822c0890
	ctx.lr = 0x825F69C8;
	sub_822C0890(ctx, base);
	// 825F69C8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825F69CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F69D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F69D4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825F69D8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F69DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F69E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825F69E0 size=304
    let mut pc: u32 = 0x825F69E0;
    'dispatch: loop {
        match pc {
            0x825F69E0 => {
    //   block [0x825F69E0..0x825F6B10)
	// 825F69E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F69E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F69E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825F69EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F69F0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F69F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825F69F8: 48B5DC09  bl 0x83154600
	ctx.lr = 0x825F69FC;
	sub_83154600(ctx, base);
	// 825F69FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F6A00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F6A04: 48862D5D  bl 0x82e59760
	ctx.lr = 0x825F6A08;
	sub_82E59760(ctx, base);
	// 825F6A08: C01F01D0  lfs f0, 0x1d0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(464 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825F6A0C: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 825F6A10: 419800E8  blt cr6, 0x825f6af8
	if ctx.cr[6].lt {
	pc = 0x825F6AF8; continue 'dispatch;
	}
	// 825F6A14: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F6A18: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F6A1C: 388B1248  addi r4, r11, 0x1248
	ctx.r[4].s64 = ctx.r[11].s64 + 4680;
	// 825F6A20: 38A00181  li r5, 0x181
	ctx.r[5].s64 = 385;
	// 825F6A24: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 825F6A28: 487FB9C1  bl 0x82df23e8
	ctx.lr = 0x825F6A2C;
	sub_82DF23E8(ctx, base);
	// 825F6A2C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825F6A30: 4182001C  beq 0x825f6a4c
	if ctx.cr[0].eq {
	pc = 0x825F6A4C; continue 'dispatch;
	}
	// 825F6A34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F6A38: 48865EF1  bl 0x82e5c928
	ctx.lr = 0x825F6A3C;
	sub_82E5C928(ctx, base);
	// 825F6A3C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F6A40: 396B100C  addi r11, r11, 0x100c
	ctx.r[11].s64 = ctx.r[11].s64 + 4108;
	// 825F6A44: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F6A48: 48000008  b 0x825f6a50
	pc = 0x825F6A50; continue 'dispatch;
	// 825F6A4C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825F6A50: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825F6A54: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F6A58: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F6A5C: 4BFFF3BD  bl 0x825f5e18
	ctx.lr = 0x825F6A60;
	sub_825F5E18(ctx, base);
	// 825F6A60: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825F6A64: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F6A68: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F6A6C: 4BCC9595  bl 0x822c0000
	ctx.lr = 0x825F6A70;
	sub_822C0000(ctx, base);
	// 825F6A70: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825F6A74: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825F6A78: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825F6A7C: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825F6A80: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825F6A84: 419A0024  beq cr6, 0x825f6aa8
	if ctx.cr[6].eq {
	pc = 0x825F6AA8; continue 'dispatch;
	}
	// 825F6A88: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 825F6A8C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825F6A90: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F6A94: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825F6A98: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825F6A9C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825F6AA0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F6AA4: 4082FFE8  bne 0x825f6a8c
	if !ctx.cr[0].eq {
	pc = 0x825F6A8C; continue 'dispatch;
	}
	// 825F6AA8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825F6AAC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825F6AB0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F6AB4: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825F6AB8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825F6ABC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825F6AC0: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825F6AC4: 48867DFD  bl 0x82e5e8c0
	ctx.lr = 0x825F6AC8;
	sub_82E5E8C0(ctx, base);
	// 825F6AC8: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825F6ACC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F6AD0: 419A0008  beq cr6, 0x825f6ad8
	if ctx.cr[6].eq {
	pc = 0x825F6AD8; continue 'dispatch;
	}
	// 825F6AD4: 4BCC9DBD  bl 0x822c0890
	ctx.lr = 0x825F6AD8;
	sub_822C0890(ctx, base);
	// 825F6AD8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825F6ADC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F6AE0: 419A0008  beq cr6, 0x825f6ae8
	if ctx.cr[6].eq {
	pc = 0x825F6AE8; continue 'dispatch;
	}
	// 825F6AE4: 4BCC9DAD  bl 0x822c0890
	ctx.lr = 0x825F6AE8;
	sub_822C0890(ctx, base);
	// 825F6AE8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825F6AEC: 419A000C  beq cr6, 0x825f6af8
	if ctx.cr[6].eq {
	pc = 0x825F6AF8; continue 'dispatch;
	}
	// 825F6AF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F6AF4: 4BCC9D9D  bl 0x822c0890
	ctx.lr = 0x825F6AF8;
	sub_822C0890(ctx, base);
	// 825F6AF8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825F6AFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F6B00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F6B04: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825F6B08: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F6B0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F6B10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825F6B10 size=308
    let mut pc: u32 = 0x825F6B10;
    'dispatch: loop {
        match pc {
            0x825F6B10 => {
    //   block [0x825F6B10..0x825F6C44)
	// 825F6B10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F6B14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F6B18: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825F6B1C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F6B20: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F6B24: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825F6B28: 48B5DAD9  bl 0x83154600
	ctx.lr = 0x825F6B2C;
	sub_83154600(ctx, base);
	// 825F6B2C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825F6B30: 418200FC  beq 0x825f6c2c
	if ctx.cr[0].eq {
	pc = 0x825F6C2C; continue 'dispatch;
	}
	// 825F6B34: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F6B38: 48862C29  bl 0x82e59760
	ctx.lr = 0x825F6B3C;
	sub_82E59760(ctx, base);
	// 825F6B3C: C01F01D0  lfs f0, 0x1d0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(464 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825F6B40: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 825F6B44: 419800E8  blt cr6, 0x825f6c2c
	if ctx.cr[6].lt {
	pc = 0x825F6C2C; continue 'dispatch;
	}
	// 825F6B48: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F6B4C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F6B50: 388B1248  addi r4, r11, 0x1248
	ctx.r[4].s64 = ctx.r[11].s64 + 4680;
	// 825F6B54: 38A0018B  li r5, 0x18b
	ctx.r[5].s64 = 395;
	// 825F6B58: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 825F6B5C: 487FB88D  bl 0x82df23e8
	ctx.lr = 0x825F6B60;
	sub_82DF23E8(ctx, base);
	// 825F6B60: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825F6B64: 4182001C  beq 0x825f6b80
	if ctx.cr[0].eq {
	pc = 0x825F6B80; continue 'dispatch;
	}
	// 825F6B68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F6B6C: 48865DBD  bl 0x82e5c928
	ctx.lr = 0x825F6B70;
	sub_82E5C928(ctx, base);
	// 825F6B70: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F6B74: 396B100C  addi r11, r11, 0x100c
	ctx.r[11].s64 = ctx.r[11].s64 + 4108;
	// 825F6B78: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F6B7C: 48000008  b 0x825f6b84
	pc = 0x825F6B84; continue 'dispatch;
	// 825F6B80: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825F6B84: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825F6B88: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F6B8C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F6B90: 4BFFF289  bl 0x825f5e18
	ctx.lr = 0x825F6B94;
	sub_825F5E18(ctx, base);
	// 825F6B94: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825F6B98: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F6B9C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F6BA0: 4BCC9461  bl 0x822c0000
	ctx.lr = 0x825F6BA4;
	sub_822C0000(ctx, base);
	// 825F6BA4: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825F6BA8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825F6BAC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825F6BB0: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825F6BB4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825F6BB8: 419A0024  beq cr6, 0x825f6bdc
	if ctx.cr[6].eq {
	pc = 0x825F6BDC; continue 'dispatch;
	}
	// 825F6BBC: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 825F6BC0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825F6BC4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F6BC8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825F6BCC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825F6BD0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825F6BD4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F6BD8: 4082FFE8  bne 0x825f6bc0
	if !ctx.cr[0].eq {
	pc = 0x825F6BC0; continue 'dispatch;
	}
	// 825F6BDC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825F6BE0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825F6BE4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F6BE8: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825F6BEC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825F6BF0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825F6BF4: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825F6BF8: 48867CC9  bl 0x82e5e8c0
	ctx.lr = 0x825F6BFC;
	sub_82E5E8C0(ctx, base);
	// 825F6BFC: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825F6C00: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F6C04: 419A0008  beq cr6, 0x825f6c0c
	if ctx.cr[6].eq {
	pc = 0x825F6C0C; continue 'dispatch;
	}
	// 825F6C08: 4BCC9C89  bl 0x822c0890
	ctx.lr = 0x825F6C0C;
	sub_822C0890(ctx, base);
	// 825F6C0C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825F6C10: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F6C14: 419A0008  beq cr6, 0x825f6c1c
	if ctx.cr[6].eq {
	pc = 0x825F6C1C; continue 'dispatch;
	}
	// 825F6C18: 4BCC9C79  bl 0x822c0890
	ctx.lr = 0x825F6C1C;
	sub_822C0890(ctx, base);
	// 825F6C1C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825F6C20: 419A000C  beq cr6, 0x825f6c2c
	if ctx.cr[6].eq {
	pc = 0x825F6C2C; continue 'dispatch;
	}
	// 825F6C24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F6C28: 4BCC9C69  bl 0x822c0890
	ctx.lr = 0x825F6C2C;
	sub_822C0890(ctx, base);
	// 825F6C2C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825F6C30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F6C34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F6C38: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825F6C3C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F6C40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F6C48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825F6C48 size=428
    let mut pc: u32 = 0x825F6C48;
    'dispatch: loop {
        match pc {
            0x825F6C48 => {
    //   block [0x825F6C48..0x825F6DF4)
	// 825F6C48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F6C4C: 48BB1521  bl 0x831a816c
	ctx.lr = 0x825F6C50;
	sub_831A8130(ctx, base);
	// 825F6C50: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F6C54: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825F6C58: 48B5D9A9  bl 0x83154600
	ctx.lr = 0x825F6C5C;
	sub_83154600(ctx, base);
	// 825F6C5C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825F6C60: 4182018C  beq 0x825f6dec
	if ctx.cr[0].eq {
	pc = 0x825F6DEC; continue 'dispatch;
	}
	// 825F6C64: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825F6C68: 48862AF9  bl 0x82e59760
	ctx.lr = 0x825F6C6C;
	sub_82E59760(ctx, base);
	// 825F6C6C: C01F01D4  lfs f0, 0x1d4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(468 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825F6C70: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 825F6C74: 419800F4  blt cr6, 0x825f6d68
	if ctx.cr[6].lt {
	pc = 0x825F6D68; continue 'dispatch;
	}
	// 825F6C78: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F6C7C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F6C80: 388B1248  addi r4, r11, 0x1248
	ctx.r[4].s64 = ctx.r[11].s64 + 4680;
	// 825F6C84: 38A00196  li r5, 0x196
	ctx.r[5].s64 = 406;
	// 825F6C88: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 825F6C8C: 487FB75D  bl 0x82df23e8
	ctx.lr = 0x825F6C90;
	sub_82DF23E8(ctx, base);
	// 825F6C90: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 825F6C94: 4182001C  beq 0x825f6cb0
	if ctx.cr[0].eq {
	pc = 0x825F6CB0; continue 'dispatch;
	}
	// 825F6C98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F6C9C: 48865C8D  bl 0x82e5c928
	ctx.lr = 0x825F6CA0;
	sub_82E5C928(ctx, base);
	// 825F6CA0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F6CA4: 396B0F94  addi r11, r11, 0xf94
	ctx.r[11].s64 = ctx.r[11].s64 + 3988;
	// 825F6CA8: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F6CAC: 48000008  b 0x825f6cb4
	pc = 0x825F6CB4; continue 'dispatch;
	// 825F6CB0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825F6CB4: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 825F6CB8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825F6CBC: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825F6CC0: 4BFFEF01  bl 0x825f5bc0
	ctx.lr = 0x825F6CC4;
	sub_825F5BC0(ctx, base);
	// 825F6CC4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825F6CC8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825F6CCC: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825F6CD0: 4BCC9331  bl 0x822c0000
	ctx.lr = 0x825F6CD4;
	sub_822C0000(ctx, base);
	// 825F6CD4: 83C1005C  lwz r30, 0x5c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825F6CD8: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825F6CDC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825F6CE0: 93C10064  stw r30, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 825F6CE4: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825F6CE8: 419A0024  beq cr6, 0x825f6d0c
	if ctx.cr[6].eq {
	pc = 0x825F6D0C; continue 'dispatch;
	}
	// 825F6CEC: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 825F6CF0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825F6CF4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F6CF8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825F6CFC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825F6D00: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825F6D04: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F6D08: 4082FFE8  bne 0x825f6cf0
	if !ctx.cr[0].eq {
	pc = 0x825F6CF0; continue 'dispatch;
	}
	// 825F6D0C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825F6D10: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825F6D14: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F6D18: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 825F6D1C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825F6D20: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825F6D24: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825F6D28: 48867B99  bl 0x82e5e8c0
	ctx.lr = 0x825F6D2C;
	sub_82E5E8C0(ctx, base);
	// 825F6D2C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 825F6D30: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F6D34: 419A0008  beq cr6, 0x825f6d3c
	if ctx.cr[6].eq {
	pc = 0x825F6D3C; continue 'dispatch;
	}
	// 825F6D38: 4BCC9B59  bl 0x822c0890
	ctx.lr = 0x825F6D3C;
	sub_822C0890(ctx, base);
	// 825F6D3C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825F6D40: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F6D44: 419A0008  beq cr6, 0x825f6d4c
	if ctx.cr[6].eq {
	pc = 0x825F6D4C; continue 'dispatch;
	}
	// 825F6D48: 4BCC9B49  bl 0x822c0890
	ctx.lr = 0x825F6D4C;
	sub_822C0890(ctx, base);
	// 825F6D4C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825F6D50: 419A000C  beq cr6, 0x825f6d5c
	if ctx.cr[6].eq {
	pc = 0x825F6D5C; continue 'dispatch;
	}
	// 825F6D54: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F6D58: 4BCC9B39  bl 0x822c0890
	ctx.lr = 0x825F6D5C;
	sub_822C0890(ctx, base);
	// 825F6D5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F6D60: 4BFFEB69  bl 0x825f58c8
	ctx.lr = 0x825F6D64;
	sub_825F58C8(ctx, base);
	// 825F6D64: 48000070  b 0x825f6dd4
	pc = 0x825F6DD4; continue 'dispatch;
	// 825F6D68: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825F6D6C: 48862A0D  bl 0x82e59778
	ctx.lr = 0x825F6D70;
	sub_82E59778(ctx, base);
	// 825F6D70: 396001D8  li r11, 0x1d8
	ctx.r[11].s64 = 472;
	// 825F6D74: 392001A0  li r9, 0x1a0
	ctx.r[9].s64 = 416;
	// 825F6D78: D0210050  stfs f1, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 825F6D7C: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 825F6D80: D0210058  stfs f1, 0x58(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 825F6D84: 395F01B0  addi r10, r31, 0x1b0
	ctx.r[10].s64 = ctx.r[31].s64 + 432;
	// 825F6D88: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 825F6D8C: 13FF5C07  vcmpneb. (lvlx128) v31, v31, v11
	tmp.u32 = ctx.r[31].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 825F6D90: 397F01C0  addi r11, r31, 0x1c0
	ctx.r[11].s64 = ctx.r[31].s64 + 448;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F6DF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F6DF8 size=140
    let mut pc: u32 = 0x825F6DF8;
    'dispatch: loop {
        match pc {
            0x825F6DF8 => {
    //   block [0x825F6DF8..0x825F6E84)
	// 825F6DF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F6DFC: 48BB1371  bl 0x831a816c
	ctx.lr = 0x825F6E00;
	sub_831A8130(ctx, base);
	// 825F6E00: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F6E04: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 825F6E08: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825F6E0C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825F6E10: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F6E14: 388B19D8  addi r4, r11, 0x19d8
	ctx.r[4].s64 = ctx.r[11].s64 + 6616;
	// 825F6E18: 38A00060  li r5, 0x60
	ctx.r[5].s64 = 96;
	// 825F6E1C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825F6E20: 4BCC95B9  bl 0x822c03d8
	ctx.lr = 0x825F6E24;
	sub_822C03D8(ctx, base);
	// 825F6E24: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F6E28: 41820028  beq 0x825f6e50
	if ctx.cr[0].eq {
	pc = 0x825F6E50; continue 'dispatch;
	}
	// 825F6E2C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825F6E30: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825F6E34: 893F0004  lbz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825F6E38: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F6E3C: 394A1034  addi r10, r10, 0x1034
	ctx.r[10].s64 = ctx.r[10].s64 + 4148;
	// 825F6E40: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825F6E44: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825F6E48: 99230004  stb r9, 4(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u8 ) };
	// 825F6E4C: 48000008  b 0x825f6e54
	pc = 0x825F6E54; continue 'dispatch;
	// 825F6E50: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825F6E54: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825F6E58: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 825F6E5C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F6E60: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F6E64: 4BFFF07D  bl 0x825f5ee0
	ctx.lr = 0x825F6E68;
	sub_825F5EE0(ctx, base);
	// 825F6E68: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825F6E6C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F6E70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F6E74: 4BCC918D  bl 0x822c0000
	ctx.lr = 0x825F6E78;
	sub_822C0000(ctx, base);
	// 825F6E78: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825F6E7C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825F6E80: 48BB133C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F6E88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F6E88 size=76
    let mut pc: u32 = 0x825F6E88;
    'dispatch: loop {
        match pc {
            0x825F6E88 => {
    //   block [0x825F6E88..0x825F6ED4)
	// 825F6E88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F6E8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F6E90: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825F6E94: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F6E98: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F6E9C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F6EA0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825F6EA4: 4BFFF4C5  bl 0x825f6368
	ctx.lr = 0x825F6EA8;
	sub_825F6368(ctx, base);
	// 825F6EA8: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825F6EAC: 4182000C  beq 0x825f6eb8
	if ctx.cr[0].eq {
	pc = 0x825F6EB8; continue 'dispatch;
	}
	// 825F6EB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F6EB4: 487FB525  bl 0x82df23d8
	ctx.lr = 0x825F6EB8;
	sub_82DF23D8(ctx, base);
	// 825F6EB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F6EBC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825F6EC0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F6EC4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F6EC8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825F6ECC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F6ED0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F6ED8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825F6ED8 size=856
    let mut pc: u32 = 0x825F6ED8;
    'dispatch: loop {
        match pc {
            0x825F6ED8 => {
    //   block [0x825F6ED8..0x825F7230)
	// 825F6ED8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F6EDC: 48BB127D  bl 0x831a8158
	ctx.lr = 0x825F6EE0;
	sub_831A8130(ctx, base);
	// 825F6EE0: 9421FE00  stwu r1, -0x200(r1)
	ea = ctx.r[1].u32.wrapping_add(-512 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F6EE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F6EE8: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 825F6EEC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825F6EF0: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 825F6EF4: 4BF1AAE5  bl 0x825119d8
	ctx.lr = 0x825F6EF8;
	sub_825119D8(ctx, base);
	// 825F6EF8: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 825F6EFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F6F00: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 825F6F04: 487FCB05  bl 0x82df3a08
	ctx.lr = 0x825F6F08;
	sub_82DF3A08(ctx, base);
	// 825F6F08: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825F6F0C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825F6F10: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F6F14: 4BF1186D  bl 0x82508780
	ctx.lr = 0x825F6F18;
	sub_82508780(ctx, base);
	// 825F6F18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F6F1C: 487FC50D  bl 0x82df3428
	ctx.lr = 0x825F6F20;
	sub_82DF3428(ctx, base);
	// 825F6F20: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 825F6F24: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825F6F28: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 825F6F2C: 409A0008  bne cr6, 0x825f6f34
	if !ctx.cr[6].eq {
	pc = 0x825F6F34; continue 'dispatch;
	}
	// 825F6F30: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 825F6F34: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F6F38: 4BF11869  bl 0x825087a0
	ctx.lr = 0x825F6F3C;
	sub_825087A0(ctx, base);
	// 825F6F3C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825F6F40: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F6F44: 48833BA5  bl 0x82e2aae8
	ctx.lr = 0x825F6F48;
	sub_82E2AAE8(ctx, base);
	// 825F6F48: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F6F4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F6F50: 388B12A8  addi r4, r11, 0x12a8
	ctx.r[4].s64 = ctx.r[11].s64 + 4776;
	// 825F6F54: 487FCAB5  bl 0x82df3a08
	ctx.lr = 0x825F6F58;
	sub_82DF3A08(ctx, base);
	// 825F6F58: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F6F5C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825F6F60: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 825F6F64: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825F6F68: 48837F09  bl 0x82e2ee70
	ctx.lr = 0x825F6F6C;
	sub_82E2EE70(ctx, base);
	// 825F6F6C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F6F70: 487FC4B9  bl 0x82df3428
	ctx.lr = 0x825F6F74;
	sub_82DF3428(ctx, base);
	// 825F6F74: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F6F78: 3B6B1248  addi r27, r11, 0x1248
	ctx.r[27].s64 = ctx.r[11].s64 + 4680;
	// 825F6F7C: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 825F6F80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F6F84: 419A0060  beq cr6, 0x825f6fe4
	if ctx.cr[6].eq {
	pc = 0x825F6FE4; continue 'dispatch;
	}
	// 825F6F88: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825F6F8C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F6F90: 38A00040  li r5, 0x40
	ctx.r[5].s64 = 64;
	// 825F6F94: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 825F6F98: 487FB451  bl 0x82df23e8
	ctx.lr = 0x825F6F9C;
	sub_82DF23E8(ctx, base);
	// 825F6F9C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F6FA0: 41820014  beq 0x825f6fb4
	if ctx.cr[0].eq {
	pc = 0x825F6FB4; continue 'dispatch;
	}
	// 825F6FA4: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 825F6FA8: 4881F8E9  bl 0x82e16890
	ctx.lr = 0x825F6FAC;
	sub_82E16890(ctx, base);
	// 825F6FAC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825F6FB0: 48000008  b 0x825f6fb8
	pc = 0x825F6FB8; continue 'dispatch;
	// 825F6FB4: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 825F6FB8: 3BDF0110  addi r30, r31, 0x110
	ctx.r[30].s64 = ctx.r[31].s64 + 272;
	// 825F6FBC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F6FC0: 4BD663B1  bl 0x8235d370
	ctx.lr = 0x825F6FC4;
	sub_8235D370(ctx, base);
	// 825F6FC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F6FC8: 4BFFEFC9  bl 0x825f5f90
	ctx.lr = 0x825F6FCC;
	sub_825F5F90(ctx, base);
	// 825F6FCC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825F6FD0: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 825F6FD4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825F6FD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F6FDC: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 825F6FE0: 4BF19B79  bl 0x82510b58
	ctx.lr = 0x825F6FE4;
	sub_82510B58(ctx, base);
	// 825F6FE4: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 825F6FE8: 488D5A01  bl 0x82ecc9e8
	ctx.lr = 0x825F6FEC;
	sub_82ECC9E8(ctx, base);
	// 825F6FEC: 39600006  li r11, 6
	ctx.r[11].s64 = 6;
	// 825F6FF0: 83AD0000  lwz r29, 0(r13)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F6FF4: 3B800014  li r28, 0x14
	ctx.r[28].s64 = 20;
	// 825F6FF8: 996101A0  stb r11, 0x1a0(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(416 as u32), ctx.r[11].u8 ) };
	// 825F6FFC: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 825F7000: 38800030  li r4, 0x30
	ctx.r[4].s64 = 48;
	// 825F7004: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 825F7008: 7C7CE82E  lwzx r3, r28, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 825F700C: 488A9725  bl 0x82ea0730
	ctx.lr = 0x825F7010;
	sub_82EA0730(ctx, base);
	// 825F7010: 39600030  li r11, 0x30
	ctx.r[11].s64 = 48;
	// 825F7014: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 825F7018: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 825F701C: C17F0124  lfs f11, 0x124(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(292 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825F7020: C19F0120  lfs f12, 0x120(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825F7024: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 825F7028: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 825F702C: C1BF0128  lfs f13, 0x128(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(296 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825F7030: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 825F7034: C02A9F78  lfs f1, -0x6088(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-24712 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825F7038: 38E100A0  addi r7, r1, 0xa0
	ctx.r[7].s64 = ctx.r[1].s64 + 160;
	// 825F703C: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 825F7040: C0099450  lfs f0, -0x6bb0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825F7044: ED4D0838  fmsubs f10, f13, f0, f1
	ctx.f[10].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 825F7048: C1A808A8  lfs f13, 0x8a8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825F704C: ED6B0838  fmsubs f11, f11, f0, f1
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 825F7050: D1A1006C  stfs f13, 0x6c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 825F7054: EC0C0838  fmsubs f0, f12, f0, f1
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 825F7058: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 825F705C: D1610064  stfs f11, 0x64(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 825F7060: D1410068  stfs f10, 0x68(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 825F7064: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F7230(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825F7230 size=420
    let mut pc: u32 = 0x825F7230;
    'dispatch: loop {
        match pc {
            0x825F7230 => {
    //   block [0x825F7230..0x825F73D4)
	// 825F7230: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F7234: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F7238: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825F723C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F7240: DBC1FFD8  stfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 825F7244: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 825F7248: 9421FE80  stwu r1, -0x180(r1)
	ea = ctx.r[1].u32.wrapping_add(-384 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F724C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F7250: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F7254: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825F7258: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F725C: 388B12D4  addi r4, r11, 0x12d4
	ctx.r[4].s64 = ctx.r[11].s64 + 4820;
	// 825F7260: 487FC7A9  bl 0x82df3a08
	ctx.lr = 0x825F7264;
	sub_82DF3A08(ctx, base);
	// 825F7264: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825F7268: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 825F726C: 389F003C  addi r4, r31, 0x3c
	ctx.r[4].s64 = ctx.r[31].s64 + 60;
	// 825F7270: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 825F7274: C3EB9450  lfs f31, -0x6bb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825F7278: C3CA9A8C  lfs f30, -0x6574(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25972 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 825F727C: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 825F7280: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 825F7284: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825F7288: 4BFABF29  bl 0x825a31b0
	ctx.lr = 0x825F728C;
	sub_825A31B0(ctx, base);
	// 825F728C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825F7290: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F7294: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825F7298: 4BFAA4D9  bl 0x825a1770
	ctx.lr = 0x825F729C;
	sub_825A1770(ctx, base);
	// 825F729C: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 825F72A0: 487FC189  bl 0x82df3428
	ctx.lr = 0x825F72A4;
	sub_82DF3428(ctx, base);
	// 825F72A4: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 825F72A8: 4BCD1A11  bl 0x822c8cb8
	ctx.lr = 0x825F72AC;
	sub_822C8CB8(ctx, base);
	// 825F72AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F72B0: 487FC179  bl 0x82df3428
	ctx.lr = 0x825F72B4;
	sub_82DF3428(ctx, base);
	// 825F72B4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F72B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F72BC: 388B12CC  addi r4, r11, 0x12cc
	ctx.r[4].s64 = ctx.r[11].s64 + 4812;
	// 825F72C0: 487FC749  bl 0x82df3a08
	ctx.lr = 0x825F72C4;
	sub_82DF3A08(ctx, base);
	// 825F72C4: 389F0040  addi r4, r31, 0x40
	ctx.r[4].s64 = ctx.r[31].s64 + 64;
	// 825F72C8: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825F72CC: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 825F72D0: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 825F72D4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825F72D8: 4BFABED9  bl 0x825a31b0
	ctx.lr = 0x825F72DC;
	sub_825A31B0(ctx, base);
	// 825F72DC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825F72E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F72E4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825F72E8: 4BFAA489  bl 0x825a1770
	ctx.lr = 0x825F72EC;
	sub_825A1770(ctx, base);
	// 825F72EC: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 825F72F0: 487FC139  bl 0x82df3428
	ctx.lr = 0x825F72F4;
	sub_82DF3428(ctx, base);
	// 825F72F4: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 825F72F8: 4BCD19C1  bl 0x822c8cb8
	ctx.lr = 0x825F72FC;
	sub_822C8CB8(ctx, base);
	// 825F72FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F7300: 487FC129  bl 0x82df3428
	ctx.lr = 0x825F7304;
	sub_82DF3428(ctx, base);
	// 825F7304: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F7308: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F730C: 388B12C4  addi r4, r11, 0x12c4
	ctx.r[4].s64 = ctx.r[11].s64 + 4804;
	// 825F7310: 487FC6F9  bl 0x82df3a08
	ctx.lr = 0x825F7314;
	sub_82DF3A08(ctx, base);
	// 825F7314: 389F0044  addi r4, r31, 0x44
	ctx.r[4].s64 = ctx.r[31].s64 + 68;
	// 825F7318: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 825F731C: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 825F7320: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 825F7324: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825F7328: 4BFABE89  bl 0x825a31b0
	ctx.lr = 0x825F732C;
	sub_825A31B0(ctx, base);
	// 825F732C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825F7330: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F7334: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825F7338: 4BFAA439  bl 0x825a1770
	ctx.lr = 0x825F733C;
	sub_825A1770(ctx, base);
	// 825F733C: 38610148  addi r3, r1, 0x148
	ctx.r[3].s64 = ctx.r[1].s64 + 328;
	// 825F7340: 487FC0E9  bl 0x82df3428
	ctx.lr = 0x825F7344;
	sub_82DF3428(ctx, base);
	// 825F7344: 38610128  addi r3, r1, 0x128
	ctx.r[3].s64 = ctx.r[1].s64 + 296;
	// 825F7348: 4BCD1971  bl 0x822c8cb8
	ctx.lr = 0x825F734C;
	sub_822C8CB8(ctx, base);
	// 825F734C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F7350: 487FC0D9  bl 0x82df3428
	ctx.lr = 0x825F7354;
	sub_82DF3428(ctx, base);
	// 825F7354: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F7358: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F735C: 388B12BC  addi r4, r11, 0x12bc
	ctx.r[4].s64 = ctx.r[11].s64 + 4796;
	// 825F7360: 487FC6A9  bl 0x82df3a08
	ctx.lr = 0x825F7364;
	sub_82DF3A08(ctx, base);
	// 825F7364: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F7368: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F736C: 388B12B4  addi r4, r11, 0x12b4
	ctx.r[4].s64 = ctx.r[11].s64 + 4788;
	// 825F7370: 487FC699  bl 0x82df3a08
	ctx.lr = 0x825F7374;
	sub_82DF3A08(ctx, base);
	// 825F7374: 38BF0054  addi r5, r31, 0x54
	ctx.r[5].s64 = ctx.r[31].s64 + 84;
	// 825F7378: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825F737C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825F7380: 4BFABCD1  bl 0x825a3050
	ctx.lr = 0x825F7384;
	sub_825A3050(ctx, base);
	// 825F7384: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825F7388: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825F738C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F7390: 4BFAADF9  bl 0x825a2188
	ctx.lr = 0x825F7394;
	sub_825A2188(ctx, base);
	// 825F7394: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 825F7398: 487FC091  bl 0x82df3428
	ctx.lr = 0x825F739C;
	sub_82DF3428(ctx, base);
	// 825F739C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825F73A0: 4BCD1919  bl 0x822c8cb8
	ctx.lr = 0x825F73A4;
	sub_822C8CB8(ctx, base);
	// 825F73A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F73A8: 487FC081  bl 0x82df3428
	ctx.lr = 0x825F73AC;
	sub_82DF3428(ctx, base);
	// 825F73AC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F73B0: 487FC079  bl 0x82df3428
	ctx.lr = 0x825F73B4;
	sub_82DF3428(ctx, base);
	// 825F73B4: 38210180  addi r1, r1, 0x180
	ctx.r[1].s64 = ctx.r[1].s64 + 384;
	// 825F73B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F73BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F73C0: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 825F73C4: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 825F73C8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825F73CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F73D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F73D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F73D8 size=112
    let mut pc: u32 = 0x825F73D8;
    'dispatch: loop {
        match pc {
            0x825F73D8 => {
    //   block [0x825F73D8..0x825F7448)
	// 825F73D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F73DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F73E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825F73E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F73E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F73EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F73F0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F73F4: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825F73F8: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 825F73FC: 396B114C  addi r11, r11, 0x114c
	ctx.r[11].s64 = ctx.r[11].s64 + 4428;
	// 825F7400: 394A1138  addi r10, r10, 0x1138
	ctx.r[10].s64 = ctx.r[10].s64 + 4408;
	// 825F7404: 392910EC  addi r9, r9, 0x10ec
	ctx.r[9].s64 = ctx.r[9].s64 + 4332;
	// 825F7408: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F740C: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 825F7410: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825F7414: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 825F7418: 4BFFEF51  bl 0x825f6368
	ctx.lr = 0x825F741C;
	sub_825F6368(ctx, base);
	// 825F741C: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825F7420: 4182000C  beq 0x825f742c
	if ctx.cr[0].eq {
	pc = 0x825F742C; continue 'dispatch;
	}
	// 825F7424: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F7428: 487FAFB1  bl 0x82df23d8
	ctx.lr = 0x825F742C;
	sub_82DF23D8(ctx, base);
	// 825F742C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F7430: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825F7434: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F7438: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F743C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825F7440: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F7444: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F7448(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825F7448 size=696
    let mut pc: u32 = 0x825F7448;
    'dispatch: loop {
        match pc {
            0x825F7448 => {
    //   block [0x825F7448..0x825F7700)
	// 825F7448: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F744C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F7450: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825F7454: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F7458: DBC1FFD8  stfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 825F745C: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 825F7460: 9421FE10  stwu r1, -0x1f0(r1)
	ea = ctx.r[1].u32.wrapping_add(-496 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F7464: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F7468: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825F746C: 4BFFFDC5  bl 0x825f7230
	ctx.lr = 0x825F7470;
	sub_825F7230(ctx, base);
	// 825F7470: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 825F7474: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F7478: 388B7C4C  addi r4, r11, 0x7c4c
	ctx.r[4].s64 = ctx.r[11].s64 + 31820;
	// 825F747C: 487FC58D  bl 0x82df3a08
	ctx.lr = 0x825F7480;
	sub_82DF3A08(ctx, base);
	// 825F7480: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F7484: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F7488: 388B132C  addi r4, r11, 0x132c
	ctx.r[4].s64 = ctx.r[11].s64 + 4908;
	// 825F748C: 487FC57D  bl 0x82df3a08
	ctx.lr = 0x825F7490;
	sub_82DF3A08(ctx, base);
	// 825F7490: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825F7494: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 825F7498: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 825F749C: 38BF0064  addi r5, r31, 0x64
	ctx.r[5].s64 = ctx.r[31].s64 + 100;
	// 825F74A0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825F74A4: C3EB9528  lfs f31, -0x6ad8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825F74A8: 38610140  addi r3, r1, 0x140
	ctx.r[3].s64 = ctx.r[1].s64 + 320;
	// 825F74AC: C3C908A4  lfs f30, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 825F74B0: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 825F74B4: C04A6218  lfs f2, 0x6218(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25112 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 825F74B8: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 825F74BC: 4BFABDED  bl 0x825a32a8
	ctx.lr = 0x825F74C0;
	sub_825A32A8(ctx, base);
	// 825F74C0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825F74C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F74C8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825F74CC: 4BFAA2A5  bl 0x825a1770
	ctx.lr = 0x825F74D0;
	sub_825A1770(ctx, base);
	// 825F74D0: 38610178  addi r3, r1, 0x178
	ctx.r[3].s64 = ctx.r[1].s64 + 376;
	// 825F74D4: 487FBF55  bl 0x82df3428
	ctx.lr = 0x825F74D8;
	sub_82DF3428(ctx, base);
	// 825F74D8: 38610158  addi r3, r1, 0x158
	ctx.r[3].s64 = ctx.r[1].s64 + 344;
	// 825F74DC: 4BCD17DD  bl 0x822c8cb8
	ctx.lr = 0x825F74E0;
	sub_822C8CB8(ctx, base);
	// 825F74E0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F74E4: 487FBF45  bl 0x82df3428
	ctx.lr = 0x825F74E8;
	sub_82DF3428(ctx, base);
	// 825F74E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F74EC: 487FBF3D  bl 0x82df3428
	ctx.lr = 0x825F74F0;
	sub_82DF3428(ctx, base);
	// 825F74F0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F74F4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F74F8: 388B131C  addi r4, r11, 0x131c
	ctx.r[4].s64 = ctx.r[11].s64 + 4892;
	// 825F74FC: 487FC50D  bl 0x82df3a08
	ctx.lr = 0x825F7500;
	sub_82DF3A08(ctx, base);
	// 825F7500: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F7504: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F7508: 388B1310  addi r4, r11, 0x1310
	ctx.r[4].s64 = ctx.r[11].s64 + 4880;
	// 825F750C: 487FC4FD  bl 0x82df3a08
	ctx.lr = 0x825F7510;
	sub_82DF3A08(ctx, base);
	// 825F7510: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F7514: 38BF0068  addi r5, r31, 0x68
	ctx.r[5].s64 = ctx.r[31].s64 + 104;
	// 825F7518: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 825F751C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825F7520: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 825F7524: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 825F7528: C04BDD6C  lfs f2, -0x2294(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8852 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 825F752C: 4BFABD7D  bl 0x825a32a8
	ctx.lr = 0x825F7530;
	sub_825A32A8(ctx, base);
	// 825F7530: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825F7534: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F7538: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825F753C: 4BFAA235  bl 0x825a1770
	ctx.lr = 0x825F7540;
	sub_825A1770(ctx, base);
	// 825F7540: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 825F7544: 487FBEE5  bl 0x82df3428
	ctx.lr = 0x825F7548;
	sub_82DF3428(ctx, base);
	// 825F7548: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 825F754C: 4BCD176D  bl 0x822c8cb8
	ctx.lr = 0x825F7550;
	sub_822C8CB8(ctx, base);
	// 825F7550: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F7554: 487FBED5  bl 0x82df3428
	ctx.lr = 0x825F7558;
	sub_82DF3428(ctx, base);
	// 825F7558: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F755C: 487FBECD  bl 0x82df3428
	ctx.lr = 0x825F7560;
	sub_82DF3428(ctx, base);
	// 825F7560: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F7564: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F7568: 388BFD10  addi r4, r11, -0x2f0
	ctx.r[4].s64 = ctx.r[11].s64 + -752;
	// 825F756C: 487FC49D  bl 0x82df3a08
	ctx.lr = 0x825F7570;
	sub_82DF3A08(ctx, base);
	// 825F7570: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F7574: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F7578: 388BFD08  addi r4, r11, -0x2f8
	ctx.r[4].s64 = ctx.r[11].s64 + -760;
	// 825F757C: 487FC48D  bl 0x82df3a08
	ctx.lr = 0x825F7580;
	sub_82DF3A08(ctx, base);
	// 825F7580: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 825F7584: 38BF006C  addi r5, r31, 0x6c
	ctx.r[5].s64 = ctx.r[31].s64 + 108;
	// 825F7588: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 825F758C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825F7590: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 825F7594: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 825F7598: C04B89AC  lfs f2, -0x7654(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 825F759C: 4BFABD0D  bl 0x825a32a8
	ctx.lr = 0x825F75A0;
	sub_825A32A8(ctx, base);
	// 825F75A0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825F75A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F75A8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825F75AC: 4BFAA1C5  bl 0x825a1770
	ctx.lr = 0x825F75B0;
	sub_825A1770(ctx, base);
	// 825F75B0: 38610138  addi r3, r1, 0x138
	ctx.r[3].s64 = ctx.r[1].s64 + 312;
	// 825F75B4: 487FBE75  bl 0x82df3428
	ctx.lr = 0x825F75B8;
	sub_82DF3428(ctx, base);
	// 825F75B8: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 825F75BC: 4BCD16FD  bl 0x822c8cb8
	ctx.lr = 0x825F75C0;
	sub_822C8CB8(ctx, base);
	// 825F75C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F75C4: 487FBE65  bl 0x82df3428
	ctx.lr = 0x825F75C8;
	sub_82DF3428(ctx, base);
	// 825F75C8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F75CC: 487FBE5D  bl 0x82df3428
	ctx.lr = 0x825F75D0;
	sub_82DF3428(ctx, base);
	// 825F75D0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F75D4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F75D8: 388B1308  addi r4, r11, 0x1308
	ctx.r[4].s64 = ctx.r[11].s64 + 4872;
	// 825F75DC: 487FC42D  bl 0x82df3a08
	ctx.lr = 0x825F75E0;
	sub_82DF3A08(ctx, base);
	// 825F75E0: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 825F75E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F75E8: 388B5EA0  addi r4, r11, 0x5ea0
	ctx.r[4].s64 = ctx.r[11].s64 + 24224;
	// 825F75EC: 487FC41D  bl 0x82df3a08
	ctx.lr = 0x825F75F0;
	sub_82DF3A08(ctx, base);
	// 825F75F0: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 825F75F4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825F75F8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F75FC: 38BF0070  addi r5, r31, 0x70
	ctx.r[5].s64 = ctx.r[31].s64 + 112;
	// 825F7600: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825F7604: 38610180  addi r3, r1, 0x180
	ctx.r[3].s64 = ctx.r[1].s64 + 384;
	// 825F7608: 4BFABE11  bl 0x825a3418
	ctx.lr = 0x825F760C;
	sub_825A3418(ctx, base);
	// 825F760C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825F7610: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F7614: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825F7618: 4BFAA8C1  bl 0x825a1ed8
	ctx.lr = 0x825F761C;
	sub_825A1ED8(ctx, base);
	// 825F761C: 386101B8  addi r3, r1, 0x1b8
	ctx.r[3].s64 = ctx.r[1].s64 + 440;
	// 825F7620: 487FBE09  bl 0x82df3428
	ctx.lr = 0x825F7624;
	sub_82DF3428(ctx, base);
	// 825F7624: 38610198  addi r3, r1, 0x198
	ctx.r[3].s64 = ctx.r[1].s64 + 408;
	// 825F7628: 4BCD1691  bl 0x822c8cb8
	ctx.lr = 0x825F762C;
	sub_822C8CB8(ctx, base);
	// 825F762C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F7630: 487FBDF9  bl 0x82df3428
	ctx.lr = 0x825F7634;
	sub_82DF3428(ctx, base);
	// 825F7634: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F7638: 487FBDF1  bl 0x82df3428
	ctx.lr = 0x825F763C;
	sub_82DF3428(ctx, base);
	// 825F763C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F7640: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F7644: 388B12F8  addi r4, r11, 0x12f8
	ctx.r[4].s64 = ctx.r[11].s64 + 4856;
	// 825F7648: 487FC3C1  bl 0x82df3a08
	ctx.lr = 0x825F764C;
	sub_82DF3A08(ctx, base);
	// 825F764C: 389F005D  addi r4, r31, 0x5d
	ctx.r[4].s64 = ctx.r[31].s64 + 93;
	// 825F7650: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825F7654: 4BFAB91D  bl 0x825a2f70
	ctx.lr = 0x825F7658;
	sub_825A2F70(ctx, base);
	// 825F7658: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825F765C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F7660: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825F7664: 4BFAAB25  bl 0x825a2188
	ctx.lr = 0x825F7668;
	sub_825A2188(ctx, base);
	// 825F7668: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 825F766C: 487FBDBD  bl 0x82df3428
	ctx.lr = 0x825F7670;
	sub_82DF3428(ctx, base);
	// 825F7670: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 825F7674: 4BCD1645  bl 0x822c8cb8
	ctx.lr = 0x825F7678;
	sub_822C8CB8(ctx, base);
	// 825F7678: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F767C: 487FBDAD  bl 0x82df3428
	ctx.lr = 0x825F7680;
	sub_82DF3428(ctx, base);
	// 825F7680: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F7684: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F7688: 388B12E8  addi r4, r11, 0x12e8
	ctx.r[4].s64 = ctx.r[11].s64 + 4840;
	// 825F768C: 487FC37D  bl 0x82df3a08
	ctx.lr = 0x825F7690;
	sub_82DF3A08(ctx, base);
	// 825F7690: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F7694: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F7698: 388B12DC  addi r4, r11, 0x12dc
	ctx.r[4].s64 = ctx.r[11].s64 + 4828;
	// 825F769C: 487FC36D  bl 0x82df3a08
	ctx.lr = 0x825F76A0;
	sub_82DF3A08(ctx, base);
	// 825F76A0: 38BF0074  addi r5, r31, 0x74
	ctx.r[5].s64 = ctx.r[31].s64 + 116;
	// 825F76A4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825F76A8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825F76AC: 4BFAB9A5  bl 0x825a3050
	ctx.lr = 0x825F76B0;
	sub_825A3050(ctx, base);
	// 825F76B0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825F76B4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825F76B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F76BC: 4BFAAACD  bl 0x825a2188
	ctx.lr = 0x825F76C0;
	sub_825A2188(ctx, base);
	// 825F76C0: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 825F76C4: 487FBD65  bl 0x82df3428
	ctx.lr = 0x825F76C8;
	sub_82DF3428(ctx, base);
	// 825F76C8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825F76CC: 4BCD15ED  bl 0x822c8cb8
	ctx.lr = 0x825F76D0;
	sub_822C8CB8(ctx, base);
	// 825F76D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F76D4: 487FBD55  bl 0x82df3428
	ctx.lr = 0x825F76D8;
	sub_82DF3428(ctx, base);
	// 825F76D8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F76DC: 487FBD4D  bl 0x82df3428
	ctx.lr = 0x825F76E0;
	sub_82DF3428(ctx, base);
	// 825F76E0: 382101F0  addi r1, r1, 0x1f0
	ctx.r[1].s64 = ctx.r[1].s64 + 496;
	// 825F76E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F76E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F76EC: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 825F76F0: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 825F76F4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825F76F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F76FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F7700(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F7700 size=76
    let mut pc: u32 = 0x825F7700;
    'dispatch: loop {
        match pc {
            0x825F7700 => {
    //   block [0x825F7700..0x825F774C)
	// 825F7700: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F7704: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F7708: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825F770C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F7710: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F7714: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F7718: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825F771C: 4BFFEEA5  bl 0x825f65c0
	ctx.lr = 0x825F7720;
	sub_825F65C0(ctx, base);
	// 825F7720: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825F7724: 4182000C  beq 0x825f7730
	if ctx.cr[0].eq {
	pc = 0x825F7730; continue 'dispatch;
	}
	// 825F7728: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F772C: 487FACAD  bl 0x82df23d8
	ctx.lr = 0x825F7730;
	sub_82DF23D8(ctx, base);
	// 825F7730: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F7734: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825F7738: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F773C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F7740: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825F7744: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F7748: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F7750(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825F7750 size=436
    let mut pc: u32 = 0x825F7750;
    'dispatch: loop {
        match pc {
            0x825F7750 => {
    //   block [0x825F7750..0x825F7904)
	// 825F7750: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F7754: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F7758: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825F775C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F7760: DBC1FFD8  stfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 825F7764: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 825F7768: 9421FE80  stwu r1, -0x180(r1)
	ea = ctx.r[1].u32.wrapping_add(-384 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F776C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F7770: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825F7774: 4BFFFABD  bl 0x825f7230
	ctx.lr = 0x825F7778;
	sub_825F7230(ctx, base);
	// 825F7778: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F777C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F7780: 388B1334  addi r4, r11, 0x1334
	ctx.r[4].s64 = ctx.r[11].s64 + 4916;
	// 825F7784: 487FC285  bl 0x82df3a08
	ctx.lr = 0x825F7788;
	sub_82DF3A08(ctx, base);
	// 825F7788: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825F778C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 825F7790: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 825F7794: 389F00EC  addi r4, r31, 0xec
	ctx.r[4].s64 = ctx.r[31].s64 + 236;
	// 825F7798: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 825F779C: C3EB964C  lfs f31, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825F77A0: C3C908A4  lfs f30, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 825F77A4: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 825F77A8: C04A6154  lfs f2, 0x6154(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24916 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 825F77AC: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 825F77B0: 4BFABA01  bl 0x825a31b0
	ctx.lr = 0x825F77B4;
	sub_825A31B0(ctx, base);
	// 825F77B4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825F77B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F77BC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825F77C0: 4BFA9FB1  bl 0x825a1770
	ctx.lr = 0x825F77C4;
	sub_825A1770(ctx, base);
	// 825F77C4: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 825F77C8: 487FBC61  bl 0x82df3428
	ctx.lr = 0x825F77CC;
	sub_82DF3428(ctx, base);
	// 825F77CC: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 825F77D0: 4BCD14E9  bl 0x822c8cb8
	ctx.lr = 0x825F77D4;
	sub_822C8CB8(ctx, base);
	// 825F77D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F77D8: 487FBC51  bl 0x82df3428
	ctx.lr = 0x825F77DC;
	sub_82DF3428(ctx, base);
	// 825F77DC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F77E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F77E4: 388BF800  addi r4, r11, -0x800
	ctx.r[4].s64 = ctx.r[11].s64 + -2048;
	// 825F77E8: 487FC221  bl 0x82df3a08
	ctx.lr = 0x825F77EC;
	sub_82DF3A08(ctx, base);
	// 825F77EC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 825F77F0: 389F00F0  addi r4, r31, 0xf0
	ctx.r[4].s64 = ctx.r[31].s64 + 240;
	// 825F77F4: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 825F77F8: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825F77FC: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 825F7800: C04B9A8C  lfs f2, -0x6574(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25972 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 825F7804: 4BFAB9AD  bl 0x825a31b0
	ctx.lr = 0x825F7808;
	sub_825A31B0(ctx, base);
	// 825F7808: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825F780C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F7810: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825F7814: 4BFA9F5D  bl 0x825a1770
	ctx.lr = 0x825F7818;
	sub_825A1770(ctx, base);
	// 825F7818: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 825F781C: 487FBC0D  bl 0x82df3428
	ctx.lr = 0x825F7820;
	sub_82DF3428(ctx, base);
	// 825F7820: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 825F7824: 4BCD1495  bl 0x822c8cb8
	ctx.lr = 0x825F7828;
	sub_822C8CB8(ctx, base);
	// 825F7828: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F782C: 487FBBFD  bl 0x82df3428
	ctx.lr = 0x825F7830;
	sub_82DF3428(ctx, base);
	// 825F7830: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825F7834: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F7838: 388BE0B8  addi r4, r11, -0x1f48
	ctx.r[4].s64 = ctx.r[11].s64 + -8008;
	// 825F783C: 487FC1CD  bl 0x82df3a08
	ctx.lr = 0x825F7840;
	sub_82DF3A08(ctx, base);
	// 825F7840: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 825F7844: 389F00F4  addi r4, r31, 0xf4
	ctx.r[4].s64 = ctx.r[31].s64 + 244;
	// 825F7848: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 825F784C: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 825F7850: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 825F7854: C04B89AC  lfs f2, -0x7654(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 825F7858: 4BFAB959  bl 0x825a31b0
	ctx.lr = 0x825F785C;
	sub_825A31B0(ctx, base);
	// 825F785C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825F7860: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F7864: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825F7868: 4BFA9F09  bl 0x825a1770
	ctx.lr = 0x825F786C;
	sub_825A1770(ctx, base);
	// 825F786C: 38610148  addi r3, r1, 0x148
	ctx.r[3].s64 = ctx.r[1].s64 + 328;
	// 825F7870: 487FBBB9  bl 0x82df3428
	ctx.lr = 0x825F7874;
	sub_82DF3428(ctx, base);
	// 825F7874: 38610128  addi r3, r1, 0x128
	ctx.r[3].s64 = ctx.r[1].s64 + 296;
	// 825F7878: 4BCD1441  bl 0x822c8cb8
	ctx.lr = 0x825F787C;
	sub_822C8CB8(ctx, base);
	// 825F787C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F7880: 487FBBA9  bl 0x82df3428
	ctx.lr = 0x825F7884;
	sub_82DF3428(ctx, base);
	// 825F7884: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F7888: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F788C: 388B12E8  addi r4, r11, 0x12e8
	ctx.r[4].s64 = ctx.r[11].s64 + 4840;
	// 825F7890: 487FC179  bl 0x82df3a08
	ctx.lr = 0x825F7894;
	sub_82DF3A08(ctx, base);
	// 825F7894: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F7898: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F789C: 388B12DC  addi r4, r11, 0x12dc
	ctx.r[4].s64 = ctx.r[11].s64 + 4828;
	// 825F78A0: 487FC169  bl 0x82df3a08
	ctx.lr = 0x825F78A4;
	sub_82DF3A08(ctx, base);
	// 825F78A4: 38BF00F9  addi r5, r31, 0xf9
	ctx.r[5].s64 = ctx.r[31].s64 + 249;
	// 825F78A8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825F78AC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825F78B0: 4BFAB7A1  bl 0x825a3050
	ctx.lr = 0x825F78B4;
	sub_825A3050(ctx, base);
	// 825F78B4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825F78B8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825F78BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F78C0: 4BFAA8C9  bl 0x825a2188
	ctx.lr = 0x825F78C4;
	sub_825A2188(ctx, base);
	// 825F78C4: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 825F78C8: 487FBB61  bl 0x82df3428
	ctx.lr = 0x825F78CC;
	sub_82DF3428(ctx, base);
	// 825F78CC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825F78D0: 4BCD13E9  bl 0x822c8cb8
	ctx.lr = 0x825F78D4;
	sub_822C8CB8(ctx, base);
	// 825F78D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F78D8: 487FBB51  bl 0x82df3428
	ctx.lr = 0x825F78DC;
	sub_82DF3428(ctx, base);
	// 825F78DC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F78E0: 487FBB49  bl 0x82df3428
	ctx.lr = 0x825F78E4;
	sub_82DF3428(ctx, base);
	// 825F78E4: 38210180  addi r1, r1, 0x180
	ctx.r[1].s64 = ctx.r[1].s64 + 384;
	// 825F78E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F78EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F78F0: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 825F78F4: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 825F78F8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825F78FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F7900: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F7908(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825F7908 size=600
    let mut pc: u32 = 0x825F7908;
    'dispatch: loop {
        match pc {
            0x825F7908 => {
    //   block [0x825F7908..0x825F7B60)
	// 825F7908: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F790C: 48BB0861  bl 0x831a816c
	ctx.lr = 0x825F7910;
	sub_831A8130(ctx, base);
	// 825F7910: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 825F7914: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F7B60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825F7B60 size=440
    let mut pc: u32 = 0x825F7B60;
    'dispatch: loop {
        match pc {
            0x825F7B60 => {
    //   block [0x825F7B60..0x825F7D18)
	// 825F7B60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F7B64: 48BB05FD  bl 0x831a8160
	ctx.lr = 0x825F7B68;
	sub_831A8130(ctx, base);
	// 825F7B68: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F7B6C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F7B70: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 825F7B74: 3BCB1248  addi r30, r11, 0x1248
	ctx.r[30].s64 = ctx.r[11].s64 + 4680;
	// 825F7B78: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 825F7B7C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F7B80: 38A0001D  li r5, 0x1d
	ctx.r[5].s64 = 29;
	// 825F7B84: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 825F7B88: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825F7B8C: 38600140  li r3, 0x140
	ctx.r[3].s64 = 320;
	// 825F7B90: 487FA859  bl 0x82df23e8
	ctx.lr = 0x825F7B94;
	sub_82DF23E8(ctx, base);
	// 825F7B94: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 825F7B98: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F7B9C: 3BABBA80  addi r29, r11, -0x4580
	ctx.r[29].s64 = ctx.r[11].s64 + -17792;
	// 825F7BA0: 4182001C  beq 0x825f7bbc
	if ctx.cr[0].eq {
	pc = 0x825F7BBC; continue 'dispatch;
	}
	// 825F7BA4: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 825F7BA8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825F7BAC: 388B6910  addi r4, r11, 0x6910
	ctx.r[4].s64 = ctx.r[11].s64 + 26896;
	// 825F7BB0: 4BFFE6E9  bl 0x825f6298
	ctx.lr = 0x825F7BB4;
	sub_825F6298(ctx, base);
	// 825F7BB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F7BB8: 48000008  b 0x825f7bc0
	pc = 0x825F7BC0; continue 'dispatch;
	// 825F7BBC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825F7BC0: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825F7BC4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F7BC8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F7BCC: 4BFFDD9D  bl 0x825f5968
	ctx.lr = 0x825F7BD0;
	sub_825F5968(ctx, base);
	// 825F7BD0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825F7BD4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F7BD8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F7BDC: 4BCC8425  bl 0x822c0000
	ctx.lr = 0x825F7BE0;
	sub_822C0000(ctx, base);
	// 825F7BE0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825F7BE4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F7BE8: 38A0001E  li r5, 0x1e
	ctx.r[5].s64 = 30;
	// 825F7BEC: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825F7BF0: 4BCC87E9  bl 0x822c03d8
	ctx.lr = 0x825F7BF4;
	sub_822C03D8(ctx, base);
	// 825F7BF4: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825F7BF8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825F7BFC: 418200B0  beq 0x825f7cac
	if ctx.cr[0].eq {
	pc = 0x825F7CAC; continue 'dispatch;
	}
	// 825F7C00: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825F7C04: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 825F7C08: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825F7C0C: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 825F7C10: 409A0008  bne cr6, 0x825f7c18
	if !ctx.cr[6].eq {
	pc = 0x825F7C18; continue 'dispatch;
	}
	// 825F7C14: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F7C18: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825F7C1C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 825F7C20: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 825F7C24: 419A0024  beq cr6, 0x825f7c48
	if ctx.cr[6].eq {
	pc = 0x825F7C48; continue 'dispatch;
	}
	// 825F7C28: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 825F7C2C: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 825F7C30: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F7C34: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 825F7C38: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 825F7C3C: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825F7C40: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F7C44: 4082FFE8  bne 0x825f7c2c
	if !ctx.cr[0].eq {
	pc = 0x825F7C2C; continue 'dispatch;
	}
	// 825F7C48: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 825F7C4C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 825F7C50: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 825F7C54: 419A0024  beq cr6, 0x825f7c78
	if ctx.cr[6].eq {
	pc = 0x825F7C78; continue 'dispatch;
	}
	// 825F7C58: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 825F7C5C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825F7C60: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F7C64: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825F7C68: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825F7C6C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825F7C70: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F7C74: 4082FFE8  bne 0x825f7c5c
	if !ctx.cr[0].eq {
	pc = 0x825F7C5C; continue 'dispatch;
	}
	// 825F7C78: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825F7C7C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 825F7C80: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825F7C84: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825F7C88: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825F7C8C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825F7C90: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825F7C94: 481A129D  bl 0x82798f30
	ctx.lr = 0x825F7C98;
	sub_82798F30(ctx, base);
	// 825F7C98: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825F7C9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F7CA0: 481A39C9  bl 0x8279b668
	ctx.lr = 0x825F7CA4;
	sub_8279B668(ctx, base);
	// 825F7CA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F7CA8: 48000008  b 0x825f7cb0
	pc = 0x825F7CB0; continue 'dispatch;
	// 825F7CAC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825F7CB0: 93FA0000  stw r31, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825F7CB4: 3BDA0004  addi r30, r26, 4
	ctx.r[30].s64 = ctx.r[26].s64 + 4;
	// 825F7CB8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F7CBC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F7CC0: 4BF9FF91  bl 0x82597c50
	ctx.lr = 0x825F7CC4;
	sub_82597C50(ctx, base);
	// 825F7CC4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825F7CC8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F7CCC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F7CD0: 4BCC8331  bl 0x822c0000
	ctx.lr = 0x825F7CD4;
	sub_822C0000(ctx, base);
	// 825F7CD4: 576B07FF  clrlwi. r11, r27, 0x1f
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825F7CD8: 41820024  beq 0x825f7cfc
	if ctx.cr[0].eq {
	pc = 0x825F7CFC; continue 'dispatch;
	}
	// 825F7CDC: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 825F7CE0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F7CE4: 419A0008  beq cr6, 0x825f7cec
	if ctx.cr[6].eq {
	pc = 0x825F7CEC; continue 'dispatch;
	}
	// 825F7CE8: 4BCC8BA9  bl 0x822c0890
	ctx.lr = 0x825F7CEC;
	sub_822C0890(ctx, base);
	// 825F7CEC: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825F7CF0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F7CF4: 419A0008  beq cr6, 0x825f7cfc
	if ctx.cr[6].eq {
	pc = 0x825F7CFC; continue 'dispatch;
	}
	// 825F7CF8: 4BCC8B99  bl 0x822c0890
	ctx.lr = 0x825F7CFC;
	sub_822C0890(ctx, base);
	// 825F7CFC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 825F7D00: 419A000C  beq cr6, 0x825f7d0c
	if ctx.cr[6].eq {
	pc = 0x825F7D0C; continue 'dispatch;
	}
	// 825F7D04: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825F7D08: 4BCC8B89  bl 0x822c0890
	ctx.lr = 0x825F7D0C;
	sub_822C0890(ctx, base);
	// 825F7D0C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825F7D10: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 825F7D14: 48BB049C  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F7D18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825F7D18 size=440
    let mut pc: u32 = 0x825F7D18;
    'dispatch: loop {
        match pc {
            0x825F7D18 => {
    //   block [0x825F7D18..0x825F7ED0)
	// 825F7D18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F7D1C: 48BB0445  bl 0x831a8160
	ctx.lr = 0x825F7D20;
	sub_831A8130(ctx, base);
	// 825F7D20: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F7D24: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F7D28: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 825F7D2C: 3BCB1248  addi r30, r11, 0x1248
	ctx.r[30].s64 = ctx.r[11].s64 + 4680;
	// 825F7D30: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 825F7D34: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F7D38: 38A000B5  li r5, 0xb5
	ctx.r[5].s64 = 181;
	// 825F7D3C: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 825F7D40: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825F7D44: 38600160  li r3, 0x160
	ctx.r[3].s64 = 352;
	// 825F7D48: 487FA6A1  bl 0x82df23e8
	ctx.lr = 0x825F7D4C;
	sub_82DF23E8(ctx, base);
	// 825F7D4C: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 825F7D50: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F7D54: 3BABBA80  addi r29, r11, -0x4580
	ctx.r[29].s64 = ctx.r[11].s64 + -17792;
	// 825F7D58: 4182001C  beq 0x825f7d74
	if ctx.cr[0].eq {
	pc = 0x825F7D74; continue 'dispatch;
	}
	// 825F7D5C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 825F7D60: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825F7D64: 388B6910  addi r4, r11, 0x6910
	ctx.r[4].s64 = ctx.r[11].s64 + 26896;
	// 825F7D68: 4BFFE6F1  bl 0x825f6458
	ctx.lr = 0x825F7D6C;
	sub_825F6458(ctx, base);
	// 825F7D6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F7D70: 48000008  b 0x825f7d78
	pc = 0x825F7D78; continue 'dispatch;
	// 825F7D74: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825F7D78: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825F7D7C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F7D80: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F7D84: 4BFFDCAD  bl 0x825f5a30
	ctx.lr = 0x825F7D88;
	sub_825F5A30(ctx, base);
	// 825F7D88: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825F7D8C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F7D90: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F7D94: 4BCC826D  bl 0x822c0000
	ctx.lr = 0x825F7D98;
	sub_822C0000(ctx, base);
	// 825F7D98: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825F7D9C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F7DA0: 38A000B6  li r5, 0xb6
	ctx.r[5].s64 = 182;
	// 825F7DA4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825F7DA8: 4BCC8631  bl 0x822c03d8
	ctx.lr = 0x825F7DAC;
	sub_822C03D8(ctx, base);
	// 825F7DAC: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825F7DB0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825F7DB4: 418200B0  beq 0x825f7e64
	if ctx.cr[0].eq {
	pc = 0x825F7E64; continue 'dispatch;
	}
	// 825F7DB8: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825F7DBC: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 825F7DC0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825F7DC4: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 825F7DC8: 409A0008  bne cr6, 0x825f7dd0
	if !ctx.cr[6].eq {
	pc = 0x825F7DD0; continue 'dispatch;
	}
	// 825F7DCC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F7DD0: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825F7DD4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 825F7DD8: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 825F7DDC: 419A0024  beq cr6, 0x825f7e00
	if ctx.cr[6].eq {
	pc = 0x825F7E00; continue 'dispatch;
	}
	// 825F7DE0: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 825F7DE4: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 825F7DE8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F7DEC: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 825F7DF0: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 825F7DF4: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825F7DF8: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F7DFC: 4082FFE8  bne 0x825f7de4
	if !ctx.cr[0].eq {
	pc = 0x825F7DE4; continue 'dispatch;
	}
	// 825F7E00: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 825F7E04: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 825F7E08: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 825F7E0C: 419A0024  beq cr6, 0x825f7e30
	if ctx.cr[6].eq {
	pc = 0x825F7E30; continue 'dispatch;
	}
	// 825F7E10: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 825F7E14: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825F7E18: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F7E1C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825F7E20: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825F7E24: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825F7E28: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F7E2C: 4082FFE8  bne 0x825f7e14
	if !ctx.cr[0].eq {
	pc = 0x825F7E14; continue 'dispatch;
	}
	// 825F7E30: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825F7E34: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 825F7E38: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825F7E3C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825F7E40: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825F7E44: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825F7E48: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825F7E4C: 481A10E5  bl 0x82798f30
	ctx.lr = 0x825F7E50;
	sub_82798F30(ctx, base);
	// 825F7E50: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825F7E54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F7E58: 481A3811  bl 0x8279b668
	ctx.lr = 0x825F7E5C;
	sub_8279B668(ctx, base);
	// 825F7E5C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F7E60: 48000008  b 0x825f7e68
	pc = 0x825F7E68; continue 'dispatch;
	// 825F7E64: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825F7E68: 93FA0000  stw r31, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825F7E6C: 3BDA0004  addi r30, r26, 4
	ctx.r[30].s64 = ctx.r[26].s64 + 4;
	// 825F7E70: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F7E74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F7E78: 4BF9FDD9  bl 0x82597c50
	ctx.lr = 0x825F7E7C;
	sub_82597C50(ctx, base);
	// 825F7E7C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825F7E80: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F7E84: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F7E88: 4BCC8179  bl 0x822c0000
	ctx.lr = 0x825F7E8C;
	sub_822C0000(ctx, base);
	// 825F7E8C: 576B07FF  clrlwi. r11, r27, 0x1f
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825F7E90: 41820024  beq 0x825f7eb4
	if ctx.cr[0].eq {
	pc = 0x825F7EB4; continue 'dispatch;
	}
	// 825F7E94: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 825F7E98: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F7E9C: 419A0008  beq cr6, 0x825f7ea4
	if ctx.cr[6].eq {
	pc = 0x825F7EA4; continue 'dispatch;
	}
	// 825F7EA0: 4BCC89F1  bl 0x822c0890
	ctx.lr = 0x825F7EA4;
	sub_822C0890(ctx, base);
	// 825F7EA4: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825F7EA8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F7EAC: 419A0008  beq cr6, 0x825f7eb4
	if ctx.cr[6].eq {
	pc = 0x825F7EB4; continue 'dispatch;
	}
	// 825F7EB0: 4BCC89E1  bl 0x822c0890
	ctx.lr = 0x825F7EB4;
	sub_822C0890(ctx, base);
	// 825F7EB4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 825F7EB8: 419A000C  beq cr6, 0x825f7ec4
	if ctx.cr[6].eq {
	pc = 0x825F7EC4; continue 'dispatch;
	}
	// 825F7EBC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825F7EC0: 4BCC89D1  bl 0x822c0890
	ctx.lr = 0x825F7EC4;
	sub_822C0890(ctx, base);
	// 825F7EC4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825F7EC8: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 825F7ECC: 48BB02E4  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F7ED0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825F7ED0 size=440
    let mut pc: u32 = 0x825F7ED0;
    'dispatch: loop {
        match pc {
            0x825F7ED0 => {
    //   block [0x825F7ED0..0x825F8088)
	// 825F7ED0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F7ED4: 48BB028D  bl 0x831a8160
	ctx.lr = 0x825F7ED8;
	sub_831A8130(ctx, base);
	// 825F7ED8: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F7EDC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F7EE0: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 825F7EE4: 3BCB1248  addi r30, r11, 0x1248
	ctx.r[30].s64 = ctx.r[11].s64 + 4680;
	// 825F7EE8: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 825F7EEC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F7EF0: 38A00142  li r5, 0x142
	ctx.r[5].s64 = 322;
	// 825F7EF4: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 825F7EF8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825F7EFC: 386001E0  li r3, 0x1e0
	ctx.r[3].s64 = 480;
	// 825F7F00: 487FA4E9  bl 0x82df23e8
	ctx.lr = 0x825F7F04;
	sub_82DF23E8(ctx, base);
	// 825F7F04: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 825F7F08: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F7F0C: 3BABBA80  addi r29, r11, -0x4580
	ctx.r[29].s64 = ctx.r[11].s64 + -17792;
	// 825F7F10: 4182001C  beq 0x825f7f2c
	if ctx.cr[0].eq {
	pc = 0x825F7F2C; continue 'dispatch;
	}
	// 825F7F14: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 825F7F18: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825F7F1C: 388B6910  addi r4, r11, 0x6910
	ctx.r[4].s64 = ctx.r[11].s64 + 26896;
	// 825F7F20: 4BFFE5D9  bl 0x825f64f8
	ctx.lr = 0x825F7F24;
	sub_825F64F8(ctx, base);
	// 825F7F24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F7F28: 48000008  b 0x825f7f30
	pc = 0x825F7F30; continue 'dispatch;
	// 825F7F2C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825F7F30: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825F7F34: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F7F38: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F7F3C: 4BFFDBBD  bl 0x825f5af8
	ctx.lr = 0x825F7F40;
	sub_825F5AF8(ctx, base);
	// 825F7F40: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825F7F44: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F7F48: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F7F4C: 4BCC80B5  bl 0x822c0000
	ctx.lr = 0x825F7F50;
	sub_822C0000(ctx, base);
	// 825F7F50: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825F7F54: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F7F58: 38A00143  li r5, 0x143
	ctx.r[5].s64 = 323;
	// 825F7F5C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825F7F60: 4BCC8479  bl 0x822c03d8
	ctx.lr = 0x825F7F64;
	sub_822C03D8(ctx, base);
	// 825F7F64: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825F7F68: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825F7F6C: 418200B0  beq 0x825f801c
	if ctx.cr[0].eq {
	pc = 0x825F801C; continue 'dispatch;
	}
	// 825F7F70: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825F7F74: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 825F7F78: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825F7F7C: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 825F7F80: 409A0008  bne cr6, 0x825f7f88
	if !ctx.cr[6].eq {
	pc = 0x825F7F88; continue 'dispatch;
	}
	// 825F7F84: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F7F88: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825F7F8C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 825F7F90: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 825F7F94: 419A0024  beq cr6, 0x825f7fb8
	if ctx.cr[6].eq {
	pc = 0x825F7FB8; continue 'dispatch;
	}
	// 825F7F98: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 825F7F9C: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 825F7FA0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F7FA4: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 825F7FA8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 825F7FAC: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825F7FB0: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F7FB4: 4082FFE8  bne 0x825f7f9c
	if !ctx.cr[0].eq {
	pc = 0x825F7F9C; continue 'dispatch;
	}
	// 825F7FB8: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 825F7FBC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 825F7FC0: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 825F7FC4: 419A0024  beq cr6, 0x825f7fe8
	if ctx.cr[6].eq {
	pc = 0x825F7FE8; continue 'dispatch;
	}
	// 825F7FC8: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 825F7FCC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825F7FD0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F7FD4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825F7FD8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825F7FDC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825F7FE0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F7FE4: 4082FFE8  bne 0x825f7fcc
	if !ctx.cr[0].eq {
	pc = 0x825F7FCC; continue 'dispatch;
	}
	// 825F7FE8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825F7FEC: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 825F7FF0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825F7FF4: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825F7FF8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825F7FFC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825F8000: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825F8004: 481A0F2D  bl 0x82798f30
	ctx.lr = 0x825F8008;
	sub_82798F30(ctx, base);
	// 825F8008: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825F800C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F8010: 481A3659  bl 0x8279b668
	ctx.lr = 0x825F8014;
	sub_8279B668(ctx, base);
	// 825F8014: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F8018: 48000008  b 0x825f8020
	pc = 0x825F8020; continue 'dispatch;
	// 825F801C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825F8020: 93FA0000  stw r31, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825F8024: 3BDA0004  addi r30, r26, 4
	ctx.r[30].s64 = ctx.r[26].s64 + 4;
	// 825F8028: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F802C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F8030: 4BF9FC21  bl 0x82597c50
	ctx.lr = 0x825F8034;
	sub_82597C50(ctx, base);
	// 825F8034: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825F8038: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F803C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F8040: 4BCC7FC1  bl 0x822c0000
	ctx.lr = 0x825F8044;
	sub_822C0000(ctx, base);
	// 825F8044: 576B07FF  clrlwi. r11, r27, 0x1f
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825F8048: 41820024  beq 0x825f806c
	if ctx.cr[0].eq {
	pc = 0x825F806C; continue 'dispatch;
	}
	// 825F804C: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 825F8050: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F8054: 419A0008  beq cr6, 0x825f805c
	if ctx.cr[6].eq {
	pc = 0x825F805C; continue 'dispatch;
	}
	// 825F8058: 4BCC8839  bl 0x822c0890
	ctx.lr = 0x825F805C;
	sub_822C0890(ctx, base);
	// 825F805C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825F8060: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F8064: 419A0008  beq cr6, 0x825f806c
	if ctx.cr[6].eq {
	pc = 0x825F806C; continue 'dispatch;
	}
	// 825F8068: 4BCC8829  bl 0x822c0890
	ctx.lr = 0x825F806C;
	sub_822C0890(ctx, base);
	// 825F806C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 825F8070: 419A000C  beq cr6, 0x825f807c
	if ctx.cr[6].eq {
	pc = 0x825F807C; continue 'dispatch;
	}
	// 825F8074: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825F8078: 4BCC8819  bl 0x822c0890
	ctx.lr = 0x825F807C;
	sub_822C0890(ctx, base);
	// 825F807C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825F8080: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 825F8084: 48BB012C  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F8088(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F8088 size=364
    let mut pc: u32 = 0x825F8088;
    'dispatch: loop {
        match pc {
            0x825F8088 => {
    //   block [0x825F8088..0x825F81F4)
	// 825F8088: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F808C: 48BB00DD  bl 0x831a8168
	ctx.lr = 0x825F8090;
	sub_831A8130(ctx, base);
	// 825F8090: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F8094: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825F8098: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825F809C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 825F80A0: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 825F80A4: 897E0000  lbz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F80A8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F80AC: 418200F0  beq 0x825f819c
	if ctx.cr[0].eq {
	pc = 0x825F819C; continue 'dispatch;
	}
	// 825F80B0: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 825F80B4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F80B8: 388B19D8  addi r4, r11, 0x19d8
	ctx.r[4].s64 = ctx.r[11].s64 + 6616;
	// 825F80BC: 38A00018  li r5, 0x18
	ctx.r[5].s64 = 24;
	// 825F80C0: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825F80C4: 4BCC8315  bl 0x822c03d8
	ctx.lr = 0x825F80C8;
	sub_822C03D8(ctx, base);
	// 825F80C8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F80CC: 41820024  beq 0x825f80f0
	if ctx.cr[0].eq {
	pc = 0x825F80F0; continue 'dispatch;
	}
	// 825F80D0: 897C0000  lbz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F80D4: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825F80D8: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 825F80DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F80E0: 394A1034  addi r10, r10, 0x1034
	ctx.r[10].s64 = ctx.r[10].s64 + 4148;
	// 825F80E4: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825F80E8: 99630004  stb r11, 4(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u8 ) };
	// 825F80EC: 48000008  b 0x825f80f4
	pc = 0x825F80F4; continue 'dispatch;
	// 825F80F0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825F80F4: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 825F80F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F80FC: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825F8100: 4BFFDDE1  bl 0x825f5ee0
	ctx.lr = 0x825F8104;
	sub_825F5EE0(ctx, base);
	// 825F8104: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825F8108: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F810C: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825F8110: 4BCC7EF1  bl 0x822c0000
	ctx.lr = 0x825F8114;
	sub_822C0000(ctx, base);
	// 825F8114: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825F8118: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F811C: 487FBAE5  bl 0x82df3c00
	ctx.lr = 0x825F8120;
	sub_82DF3C00(ctx, base);
	// 825F8120: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F8124: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825F8128: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F812C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825F8130: 484936E1  bl 0x82a8b810
	ctx.lr = 0x825F8134;
	sub_82A8B810(ctx, base);
	// 825F8134: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F8138: 487FB2F1  bl 0x82df3428
	ctx.lr = 0x825F813C;
	sub_82DF3428(ctx, base);
	// 825F813C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825F8140: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F8144: 419A0008  beq cr6, 0x825f814c
	if ctx.cr[6].eq {
	pc = 0x825F814C; continue 'dispatch;
	}
	// 825F8148: 4BCC8749  bl 0x822c0890
	ctx.lr = 0x825F814C;
	sub_822C0890(ctx, base);
	// 825F814C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 825F8150: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825F8154: 4858D65D  bl 0x82b857b0
	ctx.lr = 0x825F8158;
	sub_82B857B0(ctx, base);
	// 825F8158: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 825F815C: 389E0004  addi r4, r30, 4
	ctx.r[4].s64 = ctx.r[30].s64 + 4;
	// 825F8160: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825F8164: 4858E85D  bl 0x82b869c0
	ctx.lr = 0x825F8168;
	sub_82B869C0(ctx, base);
	// 825F8168: 80610068  lwz r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 825F816C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F8170: 419A0008  beq cr6, 0x825f8178
	if ctx.cr[6].eq {
	pc = 0x825F8178; continue 'dispatch;
	}
	// 825F8174: 4BCC871D  bl 0x822c0890
	ctx.lr = 0x825F8178;
	sub_822C0890(ctx, base);
	// 825F8178: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825F817C: 487FB2AD  bl 0x82df3428
	ctx.lr = 0x825F8180;
	sub_82DF3428(ctx, base);
	// 825F8180: 80610078  lwz r3, 0x78(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 825F8184: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F8188: 419A0008  beq cr6, 0x825f8190
	if ctx.cr[6].eq {
	pc = 0x825F8190; continue 'dispatch;
	}
	// 825F818C: 4BCC8705  bl 0x822c0890
	ctx.lr = 0x825F8190;
	sub_822C0890(ctx, base);
	// 825F8190: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825F8194: 487FB295  bl 0x82df3428
	ctx.lr = 0x825F8198;
	sub_82DF3428(ctx, base);
	// 825F8198: 48000054  b 0x825f81ec
	pc = 0x825F81EC; continue 'dispatch;
	// 825F819C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825F81A0: 389E0004  addi r4, r30, 4
	ctx.r[4].s64 = ctx.r[30].s64 + 4;
	// 825F81A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F81A8: 481FE621  bl 0x827f67c8
	ctx.lr = 0x825F81AC;
	sub_827F67C8(ctx, base);
	// 825F81AC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825F81B0: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825F81B4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825F81B8: 419A0034  beq cr6, 0x825f81ec
	if ctx.cr[6].eq {
	pc = 0x825F81EC; continue 'dispatch;
	}
	// 825F81BC: 806B0010  lwz r3, 0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 825F81C0: 3D408329  lis r10, -0x7cd7
	ctx.r[10].s64 = -2094465024;
	// 825F81C4: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 825F81C8: 38CAF5F8  addi r6, r10, -0xa08
	ctx.r[6].s64 = ctx.r[10].s64 + -2568;
	// 825F81CC: 38ABBE54  addi r5, r11, -0x41ac
	ctx.r[5].s64 = ctx.r[11].s64 + -16812;
	// 825F81D0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 825F81D4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825F81D8: 48BB1D71  bl 0x831a9f48
	ctx.lr = 0x825F81DC;
	sub_831A9F48(ctx, base);
	// 825F81DC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F81E0: 4182000C  beq 0x825f81ec
	if ctx.cr[0].eq {
	pc = 0x825F81EC; continue 'dispatch;
	}
	// 825F81E4: 89630004  lbz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825F81E8: 997C0000  stb r11, 0(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 825F81EC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825F81F0: 48BAFFC8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F81F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F81F8 size=96
    let mut pc: u32 = 0x825F81F8;
    'dispatch: loop {
        match pc {
            0x825F81F8 => {
    //   block [0x825F81F8..0x825F8258)
	// 825F81F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F81FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F8200: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825F8204: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F8208: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F820C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F8210: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F8214: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825F8218: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F821C: 388B1340  addi r4, r11, 0x1340
	ctx.r[4].s64 = ctx.r[11].s64 + 4928;
	// 825F8220: 487FB7E9  bl 0x82df3a08
	ctx.lr = 0x825F8224;
	sub_82DF3A08(ctx, base);
	// 825F8224: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 825F8228: 38BF0159  addi r5, r31, 0x159
	ctx.r[5].s64 = ctx.r[31].s64 + 345;
	// 825F822C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F8230: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825F8234: 4BFFFE55  bl 0x825f8088
	ctx.lr = 0x825F8238;
	sub_825F8088(ctx, base);
	// 825F8238: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F823C: 487FB1ED  bl 0x82df3428
	ctx.lr = 0x825F8240;
	sub_82DF3428(ctx, base);
	// 825F8240: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825F8244: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F8248: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F824C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825F8250: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F8254: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F8258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F8258 size=80
    let mut pc: u32 = 0x825F8258;
    'dispatch: loop {
        match pc {
            0x825F8258 => {
    //   block [0x825F8258..0x825F82A8)
	// 825F8258: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F825C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F8260: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F8264: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F8268: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F826C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825F8270: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825F8274: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825F8278: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 825F827C: 4BEBCF5D  bl 0x824b51d8
	ctx.lr = 0x825F8280;
	sub_824B51D8(ctx, base);
	// 825F8280: 39600006  li r11, 6
	ctx.r[11].s64 = 6;
	// 825F8284: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825F8288: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 825F828C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825F8290: 4BEBCF49  bl 0x824b51d8
	ctx.lr = 0x825F8294;
	sub_824B51D8(ctx, base);
	// 825F8294: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825F8298: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F829C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F82A0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F82A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F82A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F82A8 size=164
    let mut pc: u32 = 0x825F82A8;
    'dispatch: loop {
        match pc {
            0x825F82A8 => {
    //   block [0x825F82A8..0x825F834C)
	// 825F82A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F82AC: 48BAFEBD  bl 0x831a8168
	ctx.lr = 0x825F82B0;
	sub_831A8130(ctx, base);
	// 825F82B0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F82B4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825F82B8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825F82BC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825F82C0: 57BC063F  clrlwi. r28, r29, 0x18
	ctx.r[28].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 825F82C4: 41820038  beq 0x825f82fc
	if ctx.cr[0].eq {
	pc = 0x825F82FC; continue 'dispatch;
	}
	// 825F82C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F82CC: 48BB16BD  bl 0x831a9988
	ctx.lr = 0x825F82D0;
	sub_831A9988(ctx, base);
	// 825F82D0: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 825F82D4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825F82D8: 386B6C0C  addi r3, r11, 0x6c0c
	ctx.r[3].s64 = ctx.r[11].s64 + 27660;
	// 825F82DC: 48BAFE1D  bl 0x831a80f8
	ctx.lr = 0x825F82E0;
	sub_831A80F8(ctx, base);
	// 825F82E0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825F82E4: 41820018  beq 0x825f82fc
	if ctx.cr[0].eq {
	pc = 0x825F82FC; continue 'dispatch;
	}
	// 825F82E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F82EC: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 825F82F0: 4BFFFF69  bl 0x825f8258
	ctx.lr = 0x825F82F4;
	sub_825F8258(ctx, base);
	// 825F82F4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 825F82F8: 4800004C  b 0x825f8344
	pc = 0x825F8344; continue 'dispatch;
	// 825F82FC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 825F8300: 419A0034  beq cr6, 0x825f8334
	if ctx.cr[6].eq {
	pc = 0x825F8334; continue 'dispatch;
	}
	// 825F8304: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F8308: 48BB1681  bl 0x831a9988
	ctx.lr = 0x825F830C;
	sub_831A9988(ctx, base);
	// 825F830C: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 825F8310: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825F8314: 386B6BDC  addi r3, r11, 0x6bdc
	ctx.r[3].s64 = ctx.r[11].s64 + 27612;
	// 825F8318: 48BAFDE1  bl 0x831a80f8
	ctx.lr = 0x825F831C;
	sub_831A80F8(ctx, base);
	// 825F831C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825F8320: 41820014  beq 0x825f8334
	if ctx.cr[0].eq {
	pc = 0x825F8334; continue 'dispatch;
	}
	// 825F8324: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F8328: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 825F832C: 4BFFD35D  bl 0x825f5688
	ctx.lr = 0x825F8330;
	sub_825F5688(ctx, base);
	// 825F8330: 4BFFFFC4  b 0x825f82f4
	pc = 0x825F82F4; continue 'dispatch;
	// 825F8334: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825F8338: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F833C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F8340: 4BF1A2D9  bl 0x82512618
	ctx.lr = 0x825F8344;
	sub_82512618(ctx, base);
	// 825F8344: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825F8348: 48BAFE70  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F8350(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F8350 size=220
    let mut pc: u32 = 0x825F8350;
    'dispatch: loop {
        match pc {
            0x825F8350 => {
    //   block [0x825F8350..0x825F842C)
	// 825F8350: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F8354: 48BAFE15  bl 0x831a8168
	ctx.lr = 0x825F8358;
	sub_831A8130(ctx, base);
	// 825F8358: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F835C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 825F8360: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825F8364: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825F8368: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 825F836C: 41820038  beq 0x825f83a4
	if ctx.cr[0].eq {
	pc = 0x825F83A4; continue 'dispatch;
	}
	// 825F8370: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F8374: 48BB1615  bl 0x831a9988
	ctx.lr = 0x825F8378;
	sub_831A9988(ctx, base);
	// 825F8378: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 825F837C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825F8380: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 825F8384: 48BAFD75  bl 0x831a80f8
	ctx.lr = 0x825F8388;
	sub_831A80F8(ctx, base);
	// 825F8388: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825F838C: 41820018  beq 0x825f83a4
	if ctx.cr[0].eq {
	pc = 0x825F83A4; continue 'dispatch;
	}
	// 825F8390: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F8394: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 825F8398: 4BFFF571  bl 0x825f7908
	ctx.lr = 0x825F839C;
	sub_825F7908(ctx, base);
	// 825F839C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 825F83A0: 48000084  b 0x825f8424
	pc = 0x825F8424; continue 'dispatch;
	// 825F83A4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825F83A8: 419A006C  beq cr6, 0x825f8414
	if ctx.cr[6].eq {
	pc = 0x825F8414; continue 'dispatch;
	}
	// 825F83AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F83B0: 48BB15D9  bl 0x831a9988
	ctx.lr = 0x825F83B4;
	sub_831A9988(ctx, base);
	// 825F83B4: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 825F83B8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825F83BC: 386B6C0C  addi r3, r11, 0x6c0c
	ctx.r[3].s64 = ctx.r[11].s64 + 27660;
	// 825F83C0: 48BAFD39  bl 0x831a80f8
	ctx.lr = 0x825F83C4;
	sub_831A80F8(ctx, base);
	// 825F83C4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825F83C8: 41820014  beq 0x825f83dc
	if ctx.cr[0].eq {
	pc = 0x825F83DC; continue 'dispatch;
	}
	// 825F83CC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F83D0: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 825F83D4: 4BFFFE85  bl 0x825f8258
	ctx.lr = 0x825F83D8;
	sub_825F8258(ctx, base);
	// 825F83D8: 4BFFFFC4  b 0x825f839c
	pc = 0x825F839C; continue 'dispatch;
	// 825F83DC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825F83E0: 419A0034  beq cr6, 0x825f8414
	if ctx.cr[6].eq {
	pc = 0x825F8414; continue 'dispatch;
	}
	// 825F83E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F83E8: 48BB15A1  bl 0x831a9988
	ctx.lr = 0x825F83EC;
	sub_831A9988(ctx, base);
	// 825F83EC: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 825F83F0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825F83F4: 386B6BDC  addi r3, r11, 0x6bdc
	ctx.r[3].s64 = ctx.r[11].s64 + 27612;
	// 825F83F8: 48BAFD01  bl 0x831a80f8
	ctx.lr = 0x825F83FC;
	sub_831A80F8(ctx, base);
	// 825F83FC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825F8400: 41820014  beq 0x825f8414
	if ctx.cr[0].eq {
	pc = 0x825F8414; continue 'dispatch;
	}
	// 825F8404: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F8408: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 825F840C: 4BFFD2DD  bl 0x825f56e8
	ctx.lr = 0x825F8410;
	sub_825F56E8(ctx, base);
	// 825F8410: 4BFFFF8C  b 0x825f839c
	pc = 0x825F839C; continue 'dispatch;
	// 825F8414: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 825F8418: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F841C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F8420: 4BF1A1F9  bl 0x82512618
	ctx.lr = 0x825F8424;
	sub_82512618(ctx, base);
	// 825F8424: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825F8428: 48BAFD90  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F8430(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825F8430 size=24
    let mut pc: u32 = 0x825F8430;
    'dispatch: loop {
        match pc {
            0x825F8430 => {
    //   block [0x825F8430..0x825F8448)
	// 825F8430: 816300F8  lwz r11, 0xf8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(248 as u32) ) } as u64;
	// 825F8434: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 825F8438: 41980028  blt cr6, 0x825f8460
	if ctx.cr[6].lt {
		sub_825F8460(ctx, base);
		return;
	}
	// 825F843C: 419A000C  beq cr6, 0x825f8448
	if ctx.cr[6].eq {
		sub_825F8448(ctx, base);
		return;
	}
	// 825F8440: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825F8444: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F8448(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825F8448 size=24
    let mut pc: u32 = 0x825F8448;
    'dispatch: loop {
        match pc {
            0x825F8448 => {
    //   block [0x825F8448..0x825F8460)
	// 825F8448: 81630104  lwz r11, 0x104(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(260 as u32) ) } as u64;
	// 825F844C: 3D408329  lis r10, -0x7cd7
	ctx.r[10].s64 = -2094465024;
	// 825F8450: 394AF6C4  addi r10, r10, -0x93c
	ctx.r[10].s64 = ctx.r[10].s64 + -2364;
	// 825F8454: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825F8458: 7C6B502E  lwzx r3, r11, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 825F845C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F8460(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825F8460 size=24
    let mut pc: u32 = 0x825F8460;
    'dispatch: loop {
        match pc {
            0x825F8460 => {
    //   block [0x825F8460..0x825F8478)
	// 825F8460: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825F8464: 548A103A  slwi r10, r4, 2
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825F8468: 396BF6C4  addi r11, r11, -0x93c
	ctx.r[11].s64 = ctx.r[11].s64 + -2364;
	// 825F846C: 396BFFD4  addi r11, r11, -0x2c
	ctx.r[11].s64 = ctx.r[11].s64 + -44;
	// 825F8470: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825F8474: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F8478(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825F8478 size=48
    let mut pc: u32 = 0x825F8478;
    'dispatch: loop {
        match pc {
            0x825F8478 => {
    //   block [0x825F8478..0x825F84A8)
	// 825F8478: 816400F8  lwz r11, 0xf8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(248 as u32) ) } as u64;
	// 825F847C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F8480: 409A0050  bne cr6, 0x825f84d0
	if !ctx.cr[6].eq {
		sub_825F84D0(ctx, base);
		return;
	}
	// 825F8484: 816400FC  lwz r11, 0xfc(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(252 as u32) ) } as u64;
	// 825F8488: 2B0B000F  cmplwi cr6, r11, 0xf
	ctx.cr[6].compare_u32(ctx.r[11].u32, 15 as u32, &mut ctx.xer);
	// 825F848C: 419A0024  beq cr6, 0x825f84b0
	if ctx.cr[6].eq {
		sub_825F84B0(ctx, base);
		return;
	}
	// 825F8490: 2B0B001E  cmplwi cr6, r11, 0x1e
	ctx.cr[6].compare_u32(ctx.r[11].u32, 30 as u32, &mut ctx.xer);
	// 825F8494: 419A0014  beq cr6, 0x825f84a8
	if ctx.cr[6].eq {
		sub_825F84A8(ctx, base);
		return;
	}
	// 825F8498: 396BFFD3  addi r11, r11, -0x2d
	ctx.r[11].s64 = ctx.r[11].s64 + -45;
	// 825F849C: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 825F84A0: 556BE7BC  rlwinm r11, r11, 0x1c, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 825F84A4: 48000010  b 0x825f84b4
	sub_825F84B0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F84A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825F84A8 size=8
    let mut pc: u32 = 0x825F84A8;
    'dispatch: loop {
        match pc {
            0x825F84A8 => {
    //   block [0x825F84A8..0x825F84B0)
	// 825F84A8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825F84AC: 48000008  b 0x825f84b4
	sub_825F84B0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F84B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825F84B0 size=32
    let mut pc: u32 = 0x825F84B0;
    'dispatch: loop {
        match pc {
            0x825F84B0 => {
    //   block [0x825F84B0..0x825F84D0)
	// 825F84B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F84B4: 3D408329  lis r10, -0x7cd7
	ctx.r[10].s64 = -2094465024;
	// 825F84B8: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 825F84BC: 394AF6A4  addi r10, r10, -0x95c
	ctx.r[10].s64 = ctx.r[10].s64 + -2396;
	// 825F84C0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825F84C4: C00908A4  lfs f0, 0x8a4(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825F84C8: 7DAB542E  lfsx f13, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825F84CC: 48000044  b 0x825f8510
	sub_825F8500(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F84D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825F84D0 size=36
    let mut pc: u32 = 0x825F84D0;
    'dispatch: loop {
        match pc {
            0x825F84D0 => {
    //   block [0x825F84D0..0x825F84F4)
	// 825F84D0: 81640104  lwz r11, 0x104(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(260 as u32) ) } as u64;
	// 825F84D4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 825F84D8: 41980028  blt cr6, 0x825f8500
	if ctx.cr[6].lt {
		sub_825F8500(ctx, base);
		return;
	}
	// 825F84DC: 419A0018  beq cr6, 0x825f84f4
	if ctx.cr[6].eq {
		sub_825F84F4(ctx, base);
		return;
	}
	// 825F84E0: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 825F84E4: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 825F84E8: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F84F4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825F84F4 size=12
    let mut pc: u32 = 0x825F84F4;
    'dispatch: loop {
        match pc {
            0x825F84F4 => {
    //   block [0x825F84F4..0x825F8500)
	// 825F84F4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 825F84F8: C1AA9524  lfs f13, -0x6adc(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825F84FC: 4800000C  b 0x825f8508
	sub_825F8500(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F8500(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825F8500 size=36
    let mut pc: u32 = 0x825F8500;
    'dispatch: loop {
        match pc {
            0x825F8500 => {
    //   block [0x825F8500..0x825F8524)
	// 825F8500: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825F8504: C1AA08A8  lfs f13, 0x8a8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825F8508: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825F850C: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825F8510: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825F8514: D1A30004  stfs f13, 4(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 825F8518: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 825F851C: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 825F8520: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F8528(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F8528 size=196
    let mut pc: u32 = 0x825F8528;
    'dispatch: loop {
        match pc {
            0x825F8528 => {
    //   block [0x825F8528..0x825F85EC)
	// 825F8528: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F852C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F8530: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825F8534: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F8538: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F853C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825F8540: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F8544: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825F8548: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825F854C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F8550: 4BCC83E9  bl 0x822c0938
	ctx.lr = 0x825F8554;
	sub_822C0938(ctx, base);
	// 825F8554: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F8558: 41820028  beq 0x825f8580
	if ctx.cr[0].eq {
	pc = 0x825F8580; continue 'dispatch;
	}
	// 825F855C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F8560: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825F8564: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825F8568: 392B1444  addi r9, r11, 0x1444
	ctx.r[9].s64 = ctx.r[11].s64 + 5188;
	// 825F856C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825F8570: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825F8574: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825F8578: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825F857C: 48000008  b 0x825f8584
	pc = 0x825F8584; continue 'dispatch;
	// 825F8580: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F8584: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F8588: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F858C: 409A0044  bne cr6, 0x825f85d0
	if !ctx.cr[6].eq {
	pc = 0x825F85D0; continue 'dispatch;
	}
	// 825F8590: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825F8594: 419A001C  beq cr6, 0x825f85b0
	if ctx.cr[6].eq {
	pc = 0x825F85B0; continue 'dispatch;
	}
	// 825F8598: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F859C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825F85A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F85A4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F85A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825F85AC: 4E800421  bctrl
	ctx.lr = 0x825F85B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825F85B0: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825F85B4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825F85B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F85BC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825F85C0: 816BF6CC  lwz r11, -0x934(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2356 as u32) ) } as u64;
	// 825F85C4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825F85C8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825F85CC: 4BCC7A35  bl 0x822c0000
	ctx.lr = 0x825F85D0;
	sub_822C0000(ctx, base);
	// 825F85D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F85D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825F85D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F85DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F85E0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825F85E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F85E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F85F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F85F0 size=196
    let mut pc: u32 = 0x825F85F0;
    'dispatch: loop {
        match pc {
            0x825F85F0 => {
    //   block [0x825F85F0..0x825F86B4)
	// 825F85F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F85F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F85F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825F85FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F8600: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F8604: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825F8608: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F860C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825F8610: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825F8614: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F8618: 4BCC8321  bl 0x822c0938
	ctx.lr = 0x825F861C;
	sub_822C0938(ctx, base);
	// 825F861C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F8620: 41820028  beq 0x825f8648
	if ctx.cr[0].eq {
	pc = 0x825F8648; continue 'dispatch;
	}
	// 825F8624: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F8628: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825F862C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825F8630: 392B1458  addi r9, r11, 0x1458
	ctx.r[9].s64 = ctx.r[11].s64 + 5208;
	// 825F8634: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825F8638: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825F863C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825F8640: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825F8644: 48000008  b 0x825f864c
	pc = 0x825F864C; continue 'dispatch;
	// 825F8648: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F864C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F8650: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F8654: 409A0044  bne cr6, 0x825f8698
	if !ctx.cr[6].eq {
	pc = 0x825F8698; continue 'dispatch;
	}
	// 825F8658: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825F865C: 419A001C  beq cr6, 0x825f8678
	if ctx.cr[6].eq {
	pc = 0x825F8678; continue 'dispatch;
	}
	// 825F8660: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F8664: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825F8668: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F866C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F8670: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825F8674: 4E800421  bctrl
	ctx.lr = 0x825F8678;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825F8678: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825F867C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825F8680: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F8684: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825F8688: 816BF6CC  lwz r11, -0x934(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2356 as u32) ) } as u64;
	// 825F868C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825F8690: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825F8694: 4BCC796D  bl 0x822c0000
	ctx.lr = 0x825F8698;
	sub_822C0000(ctx, base);
	// 825F8698: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F869C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825F86A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F86A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F86A8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825F86AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F86B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F86B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F86B8 size=196
    let mut pc: u32 = 0x825F86B8;
    'dispatch: loop {
        match pc {
            0x825F86B8 => {
    //   block [0x825F86B8..0x825F877C)
	// 825F86B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F86BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F86C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825F86C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F86C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F86CC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825F86D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F86D4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825F86D8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825F86DC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F86E0: 4BCC8259  bl 0x822c0938
	ctx.lr = 0x825F86E4;
	sub_822C0938(ctx, base);
	// 825F86E4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F86E8: 41820028  beq 0x825f8710
	if ctx.cr[0].eq {
	pc = 0x825F8710; continue 'dispatch;
	}
	// 825F86EC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F86F0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825F86F4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825F86F8: 392B146C  addi r9, r11, 0x146c
	ctx.r[9].s64 = ctx.r[11].s64 + 5228;
	// 825F86FC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825F8700: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825F8704: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825F8708: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825F870C: 48000008  b 0x825f8714
	pc = 0x825F8714; continue 'dispatch;
	// 825F8710: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F8714: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F8718: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F871C: 409A0044  bne cr6, 0x825f8760
	if !ctx.cr[6].eq {
	pc = 0x825F8760; continue 'dispatch;
	}
	// 825F8720: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825F8724: 419A001C  beq cr6, 0x825f8740
	if ctx.cr[6].eq {
	pc = 0x825F8740; continue 'dispatch;
	}
	// 825F8728: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F872C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825F8730: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F8734: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F8738: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825F873C: 4E800421  bctrl
	ctx.lr = 0x825F8740;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825F8740: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825F8744: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825F8748: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F874C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825F8750: 816BF6CC  lwz r11, -0x934(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2356 as u32) ) } as u64;
	// 825F8754: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825F8758: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825F875C: 4BCC78A5  bl 0x822c0000
	ctx.lr = 0x825F8760;
	sub_822C0000(ctx, base);
	// 825F8760: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F8764: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825F8768: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F876C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F8770: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825F8774: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F8778: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


