pub fn sub_828CDB60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CDB60 size=112
    let mut pc: u32 = 0x828CDB60;
    'dispatch: loop {
        match pc {
            0x828CDB60 => {
    //   block [0x828CDB60..0x828CDBD0)
	// 828CDB60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CDB64: 488DA609  bl 0x831a816c
	ctx.lr = 0x828CDB68;
	sub_831A8130(ctx, base);
	// 828CDB68: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CDB6C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CDB70: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828CDB74: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828CDB78: 388BE358  addi r4, r11, -0x1ca8
	ctx.r[4].s64 = ctx.r[11].s64 + -7336;
	// 828CDB7C: 38A00086  li r5, 0x86
	ctx.r[5].s64 = 134;
	// 828CDB80: 3860006C  li r3, 0x6c
	ctx.r[3].s64 = 108;
	// 828CDB84: 48524865  bl 0x82df23e8
	ctx.lr = 0x828CDB88;
	sub_82DF23E8(ctx, base);
	// 828CDB88: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828CDB8C: 41820010  beq 0x828cdb9c
	if ctx.cr[0].eq {
	pc = 0x828CDB9C; continue 'dispatch;
	}
	// 828CDB90: 4BFFFCE1  bl 0x828cd870
	ctx.lr = 0x828CDB94;
	sub_828CD870(ctx, base);
	// 828CDB94: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CDB98: 48000008  b 0x828cdba0
	pc = 0x828CDBA0; continue 'dispatch;
	// 828CDB9C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828CDBA0: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828CDBA4: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828CDBA8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CDBAC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CDBB0: 4BFFE771  bl 0x828cc320
	ctx.lr = 0x828CDBB4;
	sub_828CC320(ctx, base);
	// 828CDBB4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828CDBB8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CDBBC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CDBC0: 4B9F2441  bl 0x822c0000
	ctx.lr = 0x828CDBC4;
	sub_822C0000(ctx, base);
	// 828CDBC4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828CDBC8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CDBCC: 488DA5F0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CDBD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CDBD0 size=112
    let mut pc: u32 = 0x828CDBD0;
    'dispatch: loop {
        match pc {
            0x828CDBD0 => {
    //   block [0x828CDBD0..0x828CDC40)
	// 828CDBD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CDBD4: 488DA599  bl 0x831a816c
	ctx.lr = 0x828CDBD8;
	sub_831A8130(ctx, base);
	// 828CDBD8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CDBDC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CDBE0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828CDBE4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828CDBE8: 388BE358  addi r4, r11, -0x1ca8
	ctx.r[4].s64 = ctx.r[11].s64 + -7336;
	// 828CDBEC: 38A00104  li r5, 0x104
	ctx.r[5].s64 = 260;
	// 828CDBF0: 3860007C  li r3, 0x7c
	ctx.r[3].s64 = 124;
	// 828CDBF4: 485247F5  bl 0x82df23e8
	ctx.lr = 0x828CDBF8;
	sub_82DF23E8(ctx, base);
	// 828CDBF8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828CDBFC: 41820010  beq 0x828cdc0c
	if ctx.cr[0].eq {
	pc = 0x828CDC0C; continue 'dispatch;
	}
	// 828CDC00: 4BFFFCD1  bl 0x828cd8d0
	ctx.lr = 0x828CDC04;
	sub_828CD8D0(ctx, base);
	// 828CDC04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CDC08: 48000008  b 0x828cdc10
	pc = 0x828CDC10; continue 'dispatch;
	// 828CDC0C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828CDC10: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828CDC14: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828CDC18: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CDC1C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CDC20: 4BFFE891  bl 0x828cc4b0
	ctx.lr = 0x828CDC24;
	sub_828CC4B0(ctx, base);
	// 828CDC24: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828CDC28: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CDC2C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CDC30: 4B9F23D1  bl 0x822c0000
	ctx.lr = 0x828CDC34;
	sub_822C0000(ctx, base);
	// 828CDC34: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828CDC38: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CDC3C: 488DA580  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CDC40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CDC40 size=112
    let mut pc: u32 = 0x828CDC40;
    'dispatch: loop {
        match pc {
            0x828CDC40 => {
    //   block [0x828CDC40..0x828CDCB0)
	// 828CDC40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CDC44: 488DA529  bl 0x831a816c
	ctx.lr = 0x828CDC48;
	sub_831A8130(ctx, base);
	// 828CDC48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CDC4C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CDC50: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828CDC54: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828CDC58: 388BE358  addi r4, r11, -0x1ca8
	ctx.r[4].s64 = ctx.r[11].s64 + -7336;
	// 828CDC5C: 38A00148  li r5, 0x148
	ctx.r[5].s64 = 328;
	// 828CDC60: 3860006C  li r3, 0x6c
	ctx.r[3].s64 = 108;
	// 828CDC64: 48524785  bl 0x82df23e8
	ctx.lr = 0x828CDC68;
	sub_82DF23E8(ctx, base);
	// 828CDC68: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828CDC6C: 41820010  beq 0x828cdc7c
	if ctx.cr[0].eq {
	pc = 0x828CDC7C; continue 'dispatch;
	}
	// 828CDC70: 4BFFFCE1  bl 0x828cd950
	ctx.lr = 0x828CDC74;
	sub_828CD950(ctx, base);
	// 828CDC74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CDC78: 48000008  b 0x828cdc80
	pc = 0x828CDC80; continue 'dispatch;
	// 828CDC7C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828CDC80: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828CDC84: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828CDC88: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CDC8C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CDC90: 4BFFE8E9  bl 0x828cc578
	ctx.lr = 0x828CDC94;
	sub_828CC578(ctx, base);
	// 828CDC94: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828CDC98: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CDC9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CDCA0: 4B9F2361  bl 0x822c0000
	ctx.lr = 0x828CDCA4;
	sub_822C0000(ctx, base);
	// 828CDCA4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828CDCA8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CDCAC: 488DA510  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CDCB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CDCB0 size=112
    let mut pc: u32 = 0x828CDCB0;
    'dispatch: loop {
        match pc {
            0x828CDCB0 => {
    //   block [0x828CDCB0..0x828CDD20)
	// 828CDCB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CDCB4: 488DA4B9  bl 0x831a816c
	ctx.lr = 0x828CDCB8;
	sub_831A8130(ctx, base);
	// 828CDCB8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CDCBC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CDCC0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828CDCC4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828CDCC8: 388BE358  addi r4, r11, -0x1ca8
	ctx.r[4].s64 = ctx.r[11].s64 + -7336;
	// 828CDCCC: 38A00179  li r5, 0x179
	ctx.r[5].s64 = 377;
	// 828CDCD0: 3860006C  li r3, 0x6c
	ctx.r[3].s64 = 108;
	// 828CDCD4: 48524715  bl 0x82df23e8
	ctx.lr = 0x828CDCD8;
	sub_82DF23E8(ctx, base);
	// 828CDCD8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828CDCDC: 41820010  beq 0x828cdcec
	if ctx.cr[0].eq {
	pc = 0x828CDCEC; continue 'dispatch;
	}
	// 828CDCE0: 4BFFFCD1  bl 0x828cd9b0
	ctx.lr = 0x828CDCE4;
	sub_828CD9B0(ctx, base);
	// 828CDCE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CDCE8: 48000008  b 0x828cdcf0
	pc = 0x828CDCF0; continue 'dispatch;
	// 828CDCEC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828CDCF0: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828CDCF4: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828CDCF8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CDCFC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CDD00: 4BFFE941  bl 0x828cc640
	ctx.lr = 0x828CDD04;
	sub_828CC640(ctx, base);
	// 828CDD04: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828CDD08: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CDD0C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CDD10: 4B9F22F1  bl 0x822c0000
	ctx.lr = 0x828CDD14;
	sub_822C0000(ctx, base);
	// 828CDD14: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828CDD18: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CDD1C: 488DA4A0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CDD20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CDD20 size=112
    let mut pc: u32 = 0x828CDD20;
    'dispatch: loop {
        match pc {
            0x828CDD20 => {
    //   block [0x828CDD20..0x828CDD90)
	// 828CDD20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CDD24: 488DA449  bl 0x831a816c
	ctx.lr = 0x828CDD28;
	sub_831A8130(ctx, base);
	// 828CDD28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CDD2C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CDD30: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828CDD34: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828CDD38: 388BE358  addi r4, r11, -0x1ca8
	ctx.r[4].s64 = ctx.r[11].s64 + -7336;
	// 828CDD3C: 38A001A8  li r5, 0x1a8
	ctx.r[5].s64 = 424;
	// 828CDD40: 3860006C  li r3, 0x6c
	ctx.r[3].s64 = 108;
	// 828CDD44: 485246A5  bl 0x82df23e8
	ctx.lr = 0x828CDD48;
	sub_82DF23E8(ctx, base);
	// 828CDD48: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828CDD4C: 41820010  beq 0x828cdd5c
	if ctx.cr[0].eq {
	pc = 0x828CDD5C; continue 'dispatch;
	}
	// 828CDD50: 4BFFFCC1  bl 0x828cda10
	ctx.lr = 0x828CDD54;
	sub_828CDA10(ctx, base);
	// 828CDD54: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CDD58: 48000008  b 0x828cdd60
	pc = 0x828CDD60; continue 'dispatch;
	// 828CDD5C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828CDD60: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828CDD64: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828CDD68: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CDD6C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CDD70: 4BFFE999  bl 0x828cc708
	ctx.lr = 0x828CDD74;
	sub_828CC708(ctx, base);
	// 828CDD74: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828CDD78: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CDD7C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CDD80: 4B9F2281  bl 0x822c0000
	ctx.lr = 0x828CDD84;
	sub_822C0000(ctx, base);
	// 828CDD84: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828CDD88: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CDD8C: 488DA430  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CDD90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CDD90 size=112
    let mut pc: u32 = 0x828CDD90;
    'dispatch: loop {
        match pc {
            0x828CDD90 => {
    //   block [0x828CDD90..0x828CDE00)
	// 828CDD90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CDD94: 488DA3D9  bl 0x831a816c
	ctx.lr = 0x828CDD98;
	sub_831A8130(ctx, base);
	// 828CDD98: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CDD9C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CDDA0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828CDDA4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828CDDA8: 388BE358  addi r4, r11, -0x1ca8
	ctx.r[4].s64 = ctx.r[11].s64 + -7336;
	// 828CDDAC: 38A00232  li r5, 0x232
	ctx.r[5].s64 = 562;
	// 828CDDB0: 3860007C  li r3, 0x7c
	ctx.r[3].s64 = 124;
	// 828CDDB4: 48524635  bl 0x82df23e8
	ctx.lr = 0x828CDDB8;
	sub_82DF23E8(ctx, base);
	// 828CDDB8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828CDDBC: 41820010  beq 0x828cddcc
	if ctx.cr[0].eq {
	pc = 0x828CDDCC; continue 'dispatch;
	}
	// 828CDDC0: 4BFFFCB1  bl 0x828cda70
	ctx.lr = 0x828CDDC4;
	sub_828CDA70(ctx, base);
	// 828CDDC4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CDDC8: 48000008  b 0x828cddd0
	pc = 0x828CDDD0; continue 'dispatch;
	// 828CDDCC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828CDDD0: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828CDDD4: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828CDDD8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CDDDC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CDDE0: 4BFFE9F1  bl 0x828cc7d0
	ctx.lr = 0x828CDDE4;
	sub_828CC7D0(ctx, base);
	// 828CDDE4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828CDDE8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CDDEC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CDDF0: 4B9F2211  bl 0x822c0000
	ctx.lr = 0x828CDDF4;
	sub_822C0000(ctx, base);
	// 828CDDF4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828CDDF8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CDDFC: 488DA3C0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CDE00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CDE00 size=112
    let mut pc: u32 = 0x828CDE00;
    'dispatch: loop {
        match pc {
            0x828CDE00 => {
    //   block [0x828CDE00..0x828CDE70)
	// 828CDE00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CDE04: 488DA369  bl 0x831a816c
	ctx.lr = 0x828CDE08;
	sub_831A8130(ctx, base);
	// 828CDE08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CDE0C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CDE10: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828CDE14: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828CDE18: 388BE358  addi r4, r11, -0x1ca8
	ctx.r[4].s64 = ctx.r[11].s64 + -7336;
	// 828CDE1C: 38A00058  li r5, 0x58
	ctx.r[5].s64 = 88;
	// 828CDE20: 3860006C  li r3, 0x6c
	ctx.r[3].s64 = 108;
	// 828CDE24: 485245C5  bl 0x82df23e8
	ctx.lr = 0x828CDE28;
	sub_82DF23E8(ctx, base);
	// 828CDE28: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828CDE2C: 41820010  beq 0x828cde3c
	if ctx.cr[0].eq {
	pc = 0x828CDE3C; continue 'dispatch;
	}
	// 828CDE30: 4BFFFCD1  bl 0x828cdb00
	ctx.lr = 0x828CDE34;
	sub_828CDB00(ctx, base);
	// 828CDE34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CDE38: 48000008  b 0x828cde40
	pc = 0x828CDE40; continue 'dispatch;
	// 828CDE3C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828CDE40: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828CDE44: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828CDE48: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CDE4C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CDE50: 4BFFE409  bl 0x828cc258
	ctx.lr = 0x828CDE54;
	sub_828CC258(ctx, base);
	// 828CDE54: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828CDE58: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CDE5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CDE60: 4B9F21A1  bl 0x822c0000
	ctx.lr = 0x828CDE64;
	sub_822C0000(ctx, base);
	// 828CDE64: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828CDE68: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CDE6C: 488DA350  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CDE70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CDE70 size=76
    let mut pc: u32 = 0x828CDE70;
    'dispatch: loop {
        match pc {
            0x828CDE70 => {
    //   block [0x828CDE70..0x828CDEBC)
	// 828CDE70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CDE74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CDE78: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CDE7C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CDE80: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828CDE84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CDE88: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828CDE8C: 808B0AF8  lwz r4, 0xaf8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2808 as u32) ) } as u64;
	// 828CDE90: 48525B79  bl 0x82df3a08
	ctx.lr = 0x828CDE94;
	sub_82DF3A08(ctx, base);
	// 828CDE94: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828CDE98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CDE9C: 4BF218A5  bl 0x827ef740
	ctx.lr = 0x828CDEA0;
	sub_827EF740(ctx, base);
	// 828CDEA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CDEA4: 48525585  bl 0x82df3428
	ctx.lr = 0x828CDEA8;
	sub_82DF3428(ctx, base);
	// 828CDEA8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CDEAC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CDEB0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CDEB4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CDEB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CDEC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828CDEC0 size=12
    let mut pc: u32 = 0x828CDEC0;
    'dispatch: loop {
        match pc {
            0x828CDEC0 => {
    //   block [0x828CDEC0..0x828CDECC)
	// 828CDEC0: 8163006C  lwz r11, 0x6c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(108 as u32) ) } as u64;
	// 828CDEC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CDEC8: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CDECC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828CDECC size=12
    let mut pc: u32 = 0x828CDECC;
    'dispatch: loop {
        match pc {
            0x828CDECC => {
    //   block [0x828CDECC..0x828CDED8)
	// 828CDECC: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 828CDED0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828CDED4: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CDED8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828CDED8 size=4
    let mut pc: u32 = 0x828CDED8;
    'dispatch: loop {
        match pc {
            0x828CDED8 => {
    //   block [0x828CDED8..0x828CDEDC)
	// 828CDED8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CDEE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CDEE0 size=76
    let mut pc: u32 = 0x828CDEE0;
    'dispatch: loop {
        match pc {
            0x828CDEE0 => {
    //   block [0x828CDEE0..0x828CDF2C)
	// 828CDEE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CDEE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CDEE8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CDEEC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CDEF0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828CDEF4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CDEF8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828CDEFC: 808B0AFC  lwz r4, 0xafc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2812 as u32) ) } as u64;
	// 828CDF00: 48525B09  bl 0x82df3a08
	ctx.lr = 0x828CDF04;
	sub_82DF3A08(ctx, base);
	// 828CDF04: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828CDF08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CDF0C: 4BF21835  bl 0x827ef740
	ctx.lr = 0x828CDF10;
	sub_827EF740(ctx, base);
	// 828CDF10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CDF14: 48525515  bl 0x82df3428
	ctx.lr = 0x828CDF18;
	sub_82DF3428(ctx, base);
	// 828CDF18: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CDF1C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CDF20: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CDF24: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CDF28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CDF30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CDF30 size=92
    let mut pc: u32 = 0x828CDF30;
    'dispatch: loop {
        match pc {
            0x828CDF30 => {
    //   block [0x828CDF30..0x828CDF8C)
	// 828CDF30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CDF34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CDF38: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CDF3C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CDF40: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CDF44: 4BFF4855  bl 0x828c2798
	ctx.lr = 0x828CDF48;
	sub_828C2798(ctx, base);
	// 828CDF48: 4804DED1  bl 0x8291be18
	ctx.lr = 0x828CDF4C;
	sub_8291BE18(ctx, base);
	// 828CDF4C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CDF50: 41820028  beq 0x828cdf78
	if ctx.cr[0].eq {
	pc = 0x828CDF78; continue 'dispatch;
	}
	// 828CDF54: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828CDF58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CDF5C: 808B0B08  lwz r4, 0xb08(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2824 as u32) ) } as u64;
	// 828CDF60: 48525AA9  bl 0x82df3a08
	ctx.lr = 0x828CDF64;
	sub_82DF3A08(ctx, base);
	// 828CDF64: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828CDF68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CDF6C: 4BF217D5  bl 0x827ef740
	ctx.lr = 0x828CDF70;
	sub_827EF740(ctx, base);
	// 828CDF70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CDF74: 485254B5  bl 0x82df3428
	ctx.lr = 0x828CDF78;
	sub_82DF3428(ctx, base);
	// 828CDF78: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CDF7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CDF80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CDF84: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CDF88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CDF90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828CDF90 size=4
    let mut pc: u32 = 0x828CDF90;
    'dispatch: loop {
        match pc {
            0x828CDF90 => {
    //   block [0x828CDF90..0x828CDF94)
	// 828CDF90: 4806E830  b 0x8293c7c0
	sub_8293C7C0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CDF98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828CDF98 size=4
    let mut pc: u32 = 0x828CDF98;
    'dispatch: loop {
        match pc {
            0x828CDF98 => {
    //   block [0x828CDF98..0x828CDF9C)
	// 828CDF98: 4806E9D0  b 0x8293c968
	sub_8293C968(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CDFA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CDFA0 size=136
    let mut pc: u32 = 0x828CDFA0;
    'dispatch: loop {
        match pc {
            0x828CDFA0 => {
    //   block [0x828CDFA0..0x828CE028)
	// 828CDFA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CDFA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CDFA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828CDFAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CDFB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CDFB4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828CDFB8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828CDFBC: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 828CDFC0: 409A0020  bne cr6, 0x828cdfe0
	if !ctx.cr[6].eq {
	pc = 0x828CDFE0; continue 'dispatch;
	}
	// 828CDFC4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828CDFC8: 419A0048  beq cr6, 0x828ce010
	if ctx.cr[6].eq {
	pc = 0x828CE010; continue 'dispatch;
	}
	// 828CDFCC: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 828CDFD0: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 828CDFD4: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 828CDFD8: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 828CDFDC: 48000034  b 0x828ce010
	pc = 0x828CE010; continue 'dispatch;
	// 828CDFE0: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 828CDFE4: 419A002C  beq cr6, 0x828ce010
	if ctx.cr[6].eq {
	pc = 0x828CE010; continue 'dispatch;
	}
	// 828CDFE8: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828CDFEC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CDFF0: 388B52B0  addi r4, r11, 0x52b0
	ctx.r[4].s64 = ctx.r[11].s64 + 21168;
	// 828CDFF4: 488DA105  bl 0x831a80f8
	ctx.lr = 0x828CDFF8;
	sub_831A80F8(ctx, base);
	// 828CDFF8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CDFFC: 4182000C  beq 0x828ce008
	if ctx.cr[0].eq {
	pc = 0x828CE008; continue 'dispatch;
	}
	// 828CE000: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828CE004: 4800000C  b 0x828ce010
	pc = 0x828CE010; continue 'dispatch;
	// 828CE008: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CE00C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CE010: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CE014: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CE018: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CE01C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828CE020: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CE024: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CE028(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CE028 size=108
    let mut pc: u32 = 0x828CE028;
    'dispatch: loop {
        match pc {
            0x828CE028 => {
    //   block [0x828CE028..0x828CE094)
	// 828CE028: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CE02C: 488DA141  bl 0x831a816c
	ctx.lr = 0x828CE030;
	sub_831A8130(ctx, base);
	// 828CE030: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CE034: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828CE038: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828CE03C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828CE040: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CE044: 41820038  beq 0x828ce07c
	if ctx.cr[0].eq {
	pc = 0x828CE07C; continue 'dispatch;
	}
	// 828CE048: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CE04C: 488DB93D  bl 0x831a9988
	ctx.lr = 0x828CE050;
	sub_831A9988(ctx, base);
	// 828CE050: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 828CE054: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828CE058: 386B6BDC  addi r3, r11, 0x6bdc
	ctx.r[3].s64 = ctx.r[11].s64 + 27612;
	// 828CE05C: 488DA09D  bl 0x831a80f8
	ctx.lr = 0x828CE060;
	sub_831A80F8(ctx, base);
	// 828CE060: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CE064: 41820018  beq 0x828ce07c
	if ctx.cr[0].eq {
	pc = 0x828CE07C; continue 'dispatch;
	}
	// 828CE068: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CE06C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828CE070: 4BF9F571  bl 0x8286d5e0
	ctx.lr = 0x828CE074;
	sub_8286D5E0(ctx, base);
	// 828CE074: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828CE078: 48000014  b 0x828ce08c
	pc = 0x828CE08C; continue 'dispatch;
	// 828CE07C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828CE080: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CE084: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828CE088: 4806E599  bl 0x8293c620
	ctx.lr = 0x828CE08C;
	sub_8293C620(ctx, base);
	// 828CE08C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CE090: 488DA12C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CE098(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CE098 size=196
    let mut pc: u32 = 0x828CE098;
    'dispatch: loop {
        match pc {
            0x828CE098 => {
    //   block [0x828CE098..0x828CE15C)
	// 828CE098: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CE09C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CE0A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828CE0A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CE0A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CE0AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828CE0B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CE0B4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828CE0B8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828CE0BC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CE0C0: 4B9F2879  bl 0x822c0938
	ctx.lr = 0x828CE0C4;
	sub_822C0938(ctx, base);
	// 828CE0C4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828CE0C8: 41820028  beq 0x828ce0f0
	if ctx.cr[0].eq {
	pc = 0x828CE0F0; continue 'dispatch;
	}
	// 828CE0CC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CE0D0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828CE0D4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828CE0D8: 392BE56C  addi r9, r11, -0x1a94
	ctx.r[9].s64 = ctx.r[11].s64 + -6804;
	// 828CE0DC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828CE0E0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828CE0E4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828CE0E8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828CE0EC: 48000008  b 0x828ce0f4
	pc = 0x828CE0F4; continue 'dispatch;
	// 828CE0F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CE0F4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CE0F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CE0FC: 409A0044  bne cr6, 0x828ce140
	if !ctx.cr[6].eq {
	pc = 0x828CE140; continue 'dispatch;
	}
	// 828CE100: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828CE104: 419A001C  beq cr6, 0x828ce120
	if ctx.cr[6].eq {
	pc = 0x828CE120; continue 'dispatch;
	}
	// 828CE108: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CE10C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828CE110: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CE114: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CE118: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828CE11C: 4E800421  bctrl
	ctx.lr = 0x828CE120;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CE120: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828CE124: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828CE128: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE12C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828CE130: 816B51A0  lwz r11, 0x51a0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20896 as u32) ) } as u64;
	// 828CE134: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828CE138: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828CE13C: 4B9F1EC5  bl 0x822c0000
	ctx.lr = 0x828CE140;
	sub_822C0000(ctx, base);
	// 828CE140: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CE144: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CE148: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CE14C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CE150: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828CE154: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CE158: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CE160(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CE160 size=196
    let mut pc: u32 = 0x828CE160;
    'dispatch: loop {
        match pc {
            0x828CE160 => {
    //   block [0x828CE160..0x828CE224)
	// 828CE160: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CE164: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CE168: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828CE16C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CE170: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CE174: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828CE178: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CE17C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828CE180: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828CE184: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CE188: 4B9F27B1  bl 0x822c0938
	ctx.lr = 0x828CE18C;
	sub_822C0938(ctx, base);
	// 828CE18C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828CE190: 41820028  beq 0x828ce1b8
	if ctx.cr[0].eq {
	pc = 0x828CE1B8; continue 'dispatch;
	}
	// 828CE194: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CE198: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828CE19C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828CE1A0: 392BE580  addi r9, r11, -0x1a80
	ctx.r[9].s64 = ctx.r[11].s64 + -6784;
	// 828CE1A4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828CE1A8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828CE1AC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828CE1B0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828CE1B4: 48000008  b 0x828ce1bc
	pc = 0x828CE1BC; continue 'dispatch;
	// 828CE1B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CE1BC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CE1C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CE1C4: 409A0044  bne cr6, 0x828ce208
	if !ctx.cr[6].eq {
	pc = 0x828CE208; continue 'dispatch;
	}
	// 828CE1C8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828CE1CC: 419A001C  beq cr6, 0x828ce1e8
	if ctx.cr[6].eq {
	pc = 0x828CE1E8; continue 'dispatch;
	}
	// 828CE1D0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CE1D4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828CE1D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CE1DC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CE1E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828CE1E4: 4E800421  bctrl
	ctx.lr = 0x828CE1E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CE1E8: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828CE1EC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828CE1F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE1F4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828CE1F8: 816B51A0  lwz r11, 0x51a0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20896 as u32) ) } as u64;
	// 828CE1FC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828CE200: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828CE204: 4B9F1DFD  bl 0x822c0000
	ctx.lr = 0x828CE208;
	sub_822C0000(ctx, base);
	// 828CE208: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CE20C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CE210: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CE214: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CE218: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828CE21C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CE220: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CE228(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CE228 size=196
    let mut pc: u32 = 0x828CE228;
    'dispatch: loop {
        match pc {
            0x828CE228 => {
    //   block [0x828CE228..0x828CE2EC)
	// 828CE228: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CE22C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CE230: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828CE234: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CE238: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CE23C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828CE240: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CE244: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828CE248: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828CE24C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CE250: 4B9F26E9  bl 0x822c0938
	ctx.lr = 0x828CE254;
	sub_822C0938(ctx, base);
	// 828CE254: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828CE258: 41820028  beq 0x828ce280
	if ctx.cr[0].eq {
	pc = 0x828CE280; continue 'dispatch;
	}
	// 828CE25C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CE260: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828CE264: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828CE268: 392BE594  addi r9, r11, -0x1a6c
	ctx.r[9].s64 = ctx.r[11].s64 + -6764;
	// 828CE26C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828CE270: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828CE274: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828CE278: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828CE27C: 48000008  b 0x828ce284
	pc = 0x828CE284; continue 'dispatch;
	// 828CE280: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CE284: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CE288: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CE28C: 409A0044  bne cr6, 0x828ce2d0
	if !ctx.cr[6].eq {
	pc = 0x828CE2D0; continue 'dispatch;
	}
	// 828CE290: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828CE294: 419A001C  beq cr6, 0x828ce2b0
	if ctx.cr[6].eq {
	pc = 0x828CE2B0; continue 'dispatch;
	}
	// 828CE298: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CE29C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828CE2A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CE2A4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CE2A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828CE2AC: 4E800421  bctrl
	ctx.lr = 0x828CE2B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CE2B0: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828CE2B4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828CE2B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE2BC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828CE2C0: 816B51A0  lwz r11, 0x51a0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20896 as u32) ) } as u64;
	// 828CE2C4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828CE2C8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828CE2CC: 4B9F1D35  bl 0x822c0000
	ctx.lr = 0x828CE2D0;
	sub_822C0000(ctx, base);
	// 828CE2D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CE2D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CE2D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CE2DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CE2E0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828CE2E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CE2E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CE2F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CE2F0 size=72
    let mut pc: u32 = 0x828CE2F0;
    'dispatch: loop {
        match pc {
            0x828CE2F0 => {
    //   block [0x828CE2F0..0x828CE338)
	// 828CE2F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CE2F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CE2F8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CE2FC: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 828CE300: 419A001C  beq cr6, 0x828ce31c
	if ctx.cr[6].eq {
	pc = 0x828CE31C; continue 'dispatch;
	}
	// 828CE304: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828CE308: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828CE30C: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 828CE310: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828CE314: 4BFFFC8D  bl 0x828cdfa0
	ctx.lr = 0x828CE318;
	sub_828CDFA0(ctx, base);
	// 828CE318: 48000010  b 0x828ce328
	pc = 0x828CE328; continue 'dispatch;
	// 828CE31C: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828CE320: 396B52B0  addi r11, r11, 0x52b0
	ctx.r[11].s64 = ctx.r[11].s64 + 21168;
	// 828CE324: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CE328: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828CE32C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CE330: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CE334: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CE338(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828CE338 size=116
    let mut pc: u32 = 0x828CE338;
    'dispatch: loop {
        match pc {
            0x828CE338 => {
    //   block [0x828CE338..0x828CE3AC)
	// 828CE338: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CE33C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CE340: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CE344: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CE348: 81640018  lwz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 828CE34C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CE350: 2F0B000B  cmpwi cr6, r11, 0xb
	ctx.cr[6].compare_i32(ctx.r[11].s32, 11, &mut ctx.xer);
	// 828CE354: 409A0044  bne cr6, 0x828ce398
	if !ctx.cr[6].eq {
	pc = 0x828CE398; continue 'dispatch;
	}
	// 828CE358: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828CE35C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE360: 808B0B10  lwz r4, 0xb10(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2832 as u32) ) } as u64;
	// 828CE364: 485256A5  bl 0x82df3a08
	ctx.lr = 0x828CE368;
	sub_82DF3A08(ctx, base);
	// 828CE368: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828CE36C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828CE370: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CE374: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828CE378: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828CE37C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828CE380: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828CE384: 4859070D  bl 0x82e5ea90
	ctx.lr = 0x828CE388;
	sub_82E5EA90(ctx, base);
	// 828CE388: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828CE38C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828CE390: 419A0008  beq cr6, 0x828ce398
	if ctx.cr[6].eq {
	pc = 0x828CE398; continue 'dispatch;
	}
	// 828CE394: 4B9F24FD  bl 0x822c0890
	ctx.lr = 0x828CE398;
	sub_822C0890(ctx, base);
	// 828CE398: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CE39C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CE3A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CE3A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CE3A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CE3B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CE3B0 size=124
    let mut pc: u32 = 0x828CE3B0;
    'dispatch: loop {
        match pc {
            0x828CE3B0 => {
    //   block [0x828CE3B0..0x828CE42C)
	// 828CE3B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CE3B4: 488D9DB9  bl 0x831a816c
	ctx.lr = 0x828CE3B8;
	sub_831A8130(ctx, base);
	// 828CE3B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CE3BC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CE3C0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828CE3C4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828CE3C8: 388BE5D0  addi r4, r11, -0x1a30
	ctx.r[4].s64 = ctx.r[11].s64 + -6704;
	// 828CE3CC: 38A000D0  li r5, 0xd0
	ctx.r[5].s64 = 208;
	// 828CE3D0: 3860006C  li r3, 0x6c
	ctx.r[3].s64 = 108;
	// 828CE3D4: 48524015  bl 0x82df23e8
	ctx.lr = 0x828CE3D8;
	sub_82DF23E8(ctx, base);
	// 828CE3D8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 828CE3DC: 4182001C  beq 0x828ce3f8
	if ctx.cr[0].eq {
	pc = 0x828CE3F8; continue 'dispatch;
	}
	// 828CE3E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CE3E4: 4806E36D  bl 0x8293c750
	ctx.lr = 0x828CE3E8;
	sub_8293C750(ctx, base);
	// 828CE3E8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CE3EC: 396BE5A8  addi r11, r11, -0x1a58
	ctx.r[11].s64 = ctx.r[11].s64 + -6744;
	// 828CE3F0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CE3F4: 48000008  b 0x828ce3fc
	pc = 0x828CE3FC; continue 'dispatch;
	// 828CE3F8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828CE3FC: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828CE400: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828CE404: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CE408: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CE40C: 4BFFFE1D  bl 0x828ce228
	ctx.lr = 0x828CE410;
	sub_828CE228(ctx, base);
	// 828CE410: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828CE414: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CE418: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CE41C: 4B9F1BE5  bl 0x822c0000
	ctx.lr = 0x828CE420;
	sub_822C0000(ctx, base);
	// 828CE420: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828CE424: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CE428: 488D9D94  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CE430(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CE430 size=128
    let mut pc: u32 = 0x828CE430;
    'dispatch: loop {
        match pc {
            0x828CE430 => {
    //   block [0x828CE430..0x828CE4B0)
	// 828CE430: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CE434: 488D9D39  bl 0x831a816c
	ctx.lr = 0x828CE438;
	sub_831A8130(ctx, base);
	// 828CE438: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CE43C: 3D408337  lis r10, -0x7cc9
	ctx.r[10].s64 = -2093547520;
	// 828CE440: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828CE444: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828CE448: 3BEB102C  addi r31, r11, 0x102c
	ctx.r[31].s64 = ctx.r[11].s64 + 4140;
	// 828CE44C: 816A1034  lwz r11, 0x1034(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4148 as u32) ) } as u64;
	// 828CE450: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828CE454: 40820024  bne 0x828ce478
	if !ctx.cr[0].eq {
	pc = 0x828CE478; continue 'dispatch;
	}
	// 828CE458: 3D208290  lis r9, -0x7d70
	ctx.r[9].s64 = -2104492032;
	// 828CE45C: 3D00828D  lis r8, -0x7d73
	ctx.r[8].s64 = -2104688640;
	// 828CE460: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828CE464: 3929DD90  addi r9, r9, -0x2270
	ctx.r[9].s64 = ctx.r[9].s64 + -8816;
	// 828CE468: 3908E2F0  addi r8, r8, -0x1d10
	ctx.r[8].s64 = ctx.r[8].s64 + -7440;
	// 828CE46C: 916A1034  stw r11, 0x1034(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4148 as u32), ctx.r[11].u32 ) };
	// 828CE470: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828CE474: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828CE478: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828CE47C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828CE480: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CE484: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 828CE488: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 828CE48C: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828CE490: 4BD86131  bl 0x826545c0
	ctx.lr = 0x828CE494;
	sub_826545C0(ctx, base);
	// 828CE494: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CE498: 4182000C  beq 0x828ce4a4
	if ctx.cr[0].eq {
	pc = 0x828CE4A4; continue 'dispatch;
	}
	// 828CE49C: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828CE4A0: 48000008  b 0x828ce4a8
	pc = 0x828CE4A8; continue 'dispatch;
	// 828CE4A4: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828CE4A8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828CE4AC: 488D9D10  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CE4B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828CE4B0 size=252
    let mut pc: u32 = 0x828CE4B0;
    'dispatch: loop {
        match pc {
            0x828CE4B0 => {
    //   block [0x828CE4B0..0x828CE5AC)
	// 828CE4B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CE4B4: 488D9CB5  bl 0x831a8168
	ctx.lr = 0x828CE4B8;
	sub_831A8130(ctx, base);
	// 828CE4B8: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CE4BC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828CE4C0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828CE4C4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828CE4C8: 4BFFCD11  bl 0x828cb1d8
	ctx.lr = 0x828CE4CC;
	sub_828CB1D8(ctx, base);
	// 828CE4CC: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CE4D0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828CE4D4: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828CE4D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CE4DC: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CE4E0: 7D5D5050  subf r10, r29, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[29].s64;
	// 828CE4E4: 7D4A0034  cntlzw r10, r10
	ctx.r[10].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 828CE4E8: 554ADFFE  rlwinm r10, r10, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 828CE4EC: 695C0001  xori r28, r10, 1
	ctx.r[28].u64 = ctx.r[10].u64 ^ 1;
	// 828CE4F0: 419A000C  beq cr6, 0x828ce4fc
	if ctx.cr[6].eq {
	pc = 0x828CE4FC; continue 'dispatch;
	}
	// 828CE4F4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828CE4F8: 4B9F2399  bl 0x822c0890
	ctx.lr = 0x828CE4FC;
	sub_822C0890(ctx, base);
	// 828CE4FC: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CE500: 41820074  beq 0x828ce574
	if ctx.cr[0].eq {
	pc = 0x828CE574; continue 'dispatch;
	}
	// 828CE504: 3D60828D  lis r11, -0x7d73
	ctx.r[11].s64 = -2104688640;
	// 828CE508: 93C10078  stw r30, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[30].u32 ) };
	// 828CE50C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828CE510: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828CE514: 396BDEE0  addi r11, r11, -0x2120
	ctx.r[11].s64 = ctx.r[11].s64 + -8480;
	// 828CE518: E8A10078  ld r5, 0x78(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 828CE51C: 93A10080  stw r29, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[29].u32 ) };
	// 828CE520: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828CE524: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828CE528: 4BFFFF09  bl 0x828ce430
	ctx.lr = 0x828CE52C;
	sub_828CE430(ctx, base);
	// 828CE52C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CE530: 4BFFCC09  bl 0x828cb138
	ctx.lr = 0x828CE534;
	sub_828CB138(ctx, base);
	// 828CE534: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 828CE538: C0230088  lfs f1, 0x88(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(136 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828CE53C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE540: C04B7BC8  lfs f2, 0x7bc8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31688 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 828CE544: 4BF279DD  bl 0x827f5f20
	ctx.lr = 0x828CE548;
	sub_827F5F20(ctx, base);
	// 828CE548: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CE54C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828CE550: 388BDA88  addi r4, r11, -0x2578
	ctx.r[4].s64 = ctx.r[11].s64 + -9592;
	// 828CE554: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 828CE558: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CE55C: 4BFF7C95  bl 0x828c61f0
	ctx.lr = 0x828CE560;
	sub_828C61F0(ctx, base);
	// 828CE560: 3D60828D  lis r11, -0x7d73
	ctx.r[11].s64 = -2104688640;
	// 828CE564: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828CE568: 396BDF30  addi r11, r11, -0x20d0
	ctx.r[11].s64 = ctx.r[11].s64 + -8400;
	// 828CE56C: 917E006C  stw r11, 0x6c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 828CE570: 4B9FA749  bl 0x822c8cb8
	ctx.lr = 0x828CE574;
	sub_822C8CB8(ctx, base);
	// 828CE574: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828CE578: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE57C: 808BF3F8  lwz r4, -0xc08(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3080 as u32) ) } as u64;
	// 828CE580: 48525489  bl 0x82df3a08
	ctx.lr = 0x828CE584;
	sub_82DF3A08(ctx, base);
	// 828CE584: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CE588: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828CE58C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CE590: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828CE594: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828CE598: 4E800421  bctrl
	ctx.lr = 0x828CE59C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CE59C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE5A0: 48524E89  bl 0x82df3428
	ctx.lr = 0x828CE5A4;
	sub_82DF3428(ctx, base);
	// 828CE5A4: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 828CE5A8: 488D9C10  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CE5B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CE5B0 size=104
    let mut pc: u32 = 0x828CE5B0;
    'dispatch: loop {
        match pc {
            0x828CE5B0 => {
    //   block [0x828CE5B0..0x828CE618)
	// 828CE5B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CE5B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CE5B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CE5BC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CE5C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CE5C4: 4BFFD64D  bl 0x828cbc10
	ctx.lr = 0x828CE5C8;
	sub_828CBC10(ctx, base);
	// 828CE5C8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CE5CC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828CE5D0: 396BE658  addi r11, r11, -0x19a8
	ctx.r[11].s64 = ctx.r[11].s64 + -6568;
	// 828CE5D4: 915F006C  stw r10, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 828CE5D8: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828CE5DC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CE5E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE5E4: 808A0AF8  lwz r4, 0xaf8(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2808 as u32) ) } as u64;
	// 828CE5E8: 48525421  bl 0x82df3a08
	ctx.lr = 0x828CE5EC;
	sub_82DF3A08(ctx, base);
	// 828CE5EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CE5F0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828CE5F4: 4858B0F5  bl 0x82e596e8
	ctx.lr = 0x828CE5F8;
	sub_82E596E8(ctx, base);
	// 828CE5F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE5FC: 48524E2D  bl 0x82df3428
	ctx.lr = 0x828CE600;
	sub_82DF3428(ctx, base);
	// 828CE600: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CE604: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CE608: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CE60C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CE610: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CE614: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CE618(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CE618 size=96
    let mut pc: u32 = 0x828CE618;
    'dispatch: loop {
        match pc {
            0x828CE618 => {
    //   block [0x828CE618..0x828CE678)
	// 828CE618: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CE61C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CE620: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CE624: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CE628: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CE62C: 4BFFD5E5  bl 0x828cbc10
	ctx.lr = 0x828CE630;
	sub_828CBC10(ctx, base);
	// 828CE630: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CE634: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828CE638: 396BE694  addi r11, r11, -0x196c
	ctx.r[11].s64 = ctx.r[11].s64 + -6508;
	// 828CE63C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE640: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CE644: 808A0AF4  lwz r4, 0xaf4(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2804 as u32) ) } as u64;
	// 828CE648: 485253C1  bl 0x82df3a08
	ctx.lr = 0x828CE64C;
	sub_82DF3A08(ctx, base);
	// 828CE64C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CE650: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828CE654: 4858B095  bl 0x82e596e8
	ctx.lr = 0x828CE658;
	sub_82E596E8(ctx, base);
	// 828CE658: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE65C: 48524DCD  bl 0x82df3428
	ctx.lr = 0x828CE660;
	sub_82DF3428(ctx, base);
	// 828CE660: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CE664: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CE668: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CE66C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CE670: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CE674: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CE678(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CE678 size=112
    let mut pc: u32 = 0x828CE678;
    'dispatch: loop {
        match pc {
            0x828CE678 => {
    //   block [0x828CE678..0x828CE6E8)
	// 828CE678: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CE67C: 488D9AF1  bl 0x831a816c
	ctx.lr = 0x828CE680;
	sub_831A8130(ctx, base);
	// 828CE680: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CE684: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CE688: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828CE68C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828CE690: 388BE5D0  addi r4, r11, -0x1a30
	ctx.r[4].s64 = ctx.r[11].s64 + -6704;
	// 828CE694: 38A0005F  li r5, 0x5f
	ctx.r[5].s64 = 95;
	// 828CE698: 38600070  li r3, 0x70
	ctx.r[3].s64 = 112;
	// 828CE69C: 48523D4D  bl 0x82df23e8
	ctx.lr = 0x828CE6A0;
	sub_82DF23E8(ctx, base);
	// 828CE6A0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828CE6A4: 41820010  beq 0x828ce6b4
	if ctx.cr[0].eq {
	pc = 0x828CE6B4; continue 'dispatch;
	}
	// 828CE6A8: 4BFFFF09  bl 0x828ce5b0
	ctx.lr = 0x828CE6AC;
	sub_828CE5B0(ctx, base);
	// 828CE6AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CE6B0: 48000008  b 0x828ce6b8
	pc = 0x828CE6B8; continue 'dispatch;
	// 828CE6B4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828CE6B8: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828CE6BC: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828CE6C0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CE6C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CE6C8: 4BFFFA99  bl 0x828ce160
	ctx.lr = 0x828CE6CC;
	sub_828CE160(ctx, base);
	// 828CE6CC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828CE6D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CE6D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CE6D8: 4B9F1929  bl 0x822c0000
	ctx.lr = 0x828CE6DC;
	sub_822C0000(ctx, base);
	// 828CE6DC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828CE6E0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CE6E4: 488D9AD8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CE6E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CE6E8 size=112
    let mut pc: u32 = 0x828CE6E8;
    'dispatch: loop {
        match pc {
            0x828CE6E8 => {
    //   block [0x828CE6E8..0x828CE758)
	// 828CE6E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CE6EC: 488D9A81  bl 0x831a816c
	ctx.lr = 0x828CE6F0;
	sub_831A8130(ctx, base);
	// 828CE6F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CE6F4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CE6F8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828CE6FC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828CE700: 388BE5D0  addi r4, r11, -0x1a30
	ctx.r[4].s64 = ctx.r[11].s64 + -6704;
	// 828CE704: 38A00032  li r5, 0x32
	ctx.r[5].s64 = 50;
	// 828CE708: 3860006C  li r3, 0x6c
	ctx.r[3].s64 = 108;
	// 828CE70C: 48523CDD  bl 0x82df23e8
	ctx.lr = 0x828CE710;
	sub_82DF23E8(ctx, base);
	// 828CE710: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828CE714: 41820010  beq 0x828ce724
	if ctx.cr[0].eq {
	pc = 0x828CE724; continue 'dispatch;
	}
	// 828CE718: 4BFFFF01  bl 0x828ce618
	ctx.lr = 0x828CE71C;
	sub_828CE618(ctx, base);
	// 828CE71C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CE720: 48000008  b 0x828ce728
	pc = 0x828CE728; continue 'dispatch;
	// 828CE724: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828CE728: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828CE72C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828CE730: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CE734: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CE738: 4BFFF961  bl 0x828ce098
	ctx.lr = 0x828CE73C;
	sub_828CE098(ctx, base);
	// 828CE73C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828CE740: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CE744: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CE748: 4B9F18B9  bl 0x822c0000
	ctx.lr = 0x828CE74C;
	sub_822C0000(ctx, base);
	// 828CE74C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828CE750: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CE754: 488D9A68  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CE758(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CE758 size=104
    let mut pc: u32 = 0x828CE758;
    'dispatch: loop {
        match pc {
            0x828CE758 => {
    //   block [0x828CE758..0x828CE7C0)
	// 828CE758: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CE75C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CE760: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828CE764: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CE768: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CE76C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CE770: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828CE774: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CE778: 816B0050  lwz r11, 0x50(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 828CE77C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828CE780: 4E800421  bctrl
	ctx.lr = 0x828CE784;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CE784: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828CE788: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE78C: 4852527D  bl 0x82df3a08
	ctx.lr = 0x828CE790;
	sub_82DF3A08(ctx, base);
	// 828CE790: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828CE794: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828CE798: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 828CE79C: 4803F6B5  bl 0x8290de50
	ctx.lr = 0x828CE7A0;
	sub_8290DE50(ctx, base);
	// 828CE7A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE7A4: 48524C85  bl 0x82df3428
	ctx.lr = 0x828CE7A8;
	sub_82DF3428(ctx, base);
	// 828CE7A8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CE7AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CE7B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CE7B4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828CE7B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CE7BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CE7C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828CE7C0 size=88
    let mut pc: u32 = 0x828CE7C0;
    'dispatch: loop {
        match pc {
            0x828CE7C0 => {
    //   block [0x828CE7C0..0x828CE818)
	// 828CE7C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CE7C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CE7C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CE7CC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CE7D0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828CE7D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CE7D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE7DC: 388B7868  addi r4, r11, 0x7868
	ctx.r[4].s64 = ctx.r[11].s64 + 30824;
	// 828CE7E0: 48525229  bl 0x82df3a08
	ctx.lr = 0x828CE7E4;
	sub_82DF3A08(ctx, base);
	// 828CE7E4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828CE7E8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828CE7EC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828CE7F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CE7F4: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828CE7F8: 4803DE89  bl 0x8290c680
	ctx.lr = 0x828CE7FC;
	sub_8290C680(ctx, base);
	// 828CE7FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE800: 48524C29  bl 0x82df3428
	ctx.lr = 0x828CE804;
	sub_82DF3428(ctx, base);
	// 828CE804: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CE808: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CE80C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CE810: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CE814: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CE818(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828CE818 size=88
    let mut pc: u32 = 0x828CE818;
    'dispatch: loop {
        match pc {
            0x828CE818 => {
    //   block [0x828CE818..0x828CE870)
	// 828CE818: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CE81C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CE820: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CE824: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CE828: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828CE82C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CE830: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE834: 388B7868  addi r4, r11, 0x7868
	ctx.r[4].s64 = ctx.r[11].s64 + 30824;
	// 828CE838: 485251D1  bl 0x82df3a08
	ctx.lr = 0x828CE83C;
	sub_82DF3A08(ctx, base);
	// 828CE83C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828CE840: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 828CE844: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828CE848: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CE84C: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828CE850: 4803DE31  bl 0x8290c680
	ctx.lr = 0x828CE854;
	sub_8290C680(ctx, base);
	// 828CE854: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE858: 48524BD1  bl 0x82df3428
	ctx.lr = 0x828CE85C;
	sub_82DF3428(ctx, base);
	// 828CE85C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CE860: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CE864: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CE868: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CE86C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CE870(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828CE870 size=88
    let mut pc: u32 = 0x828CE870;
    'dispatch: loop {
        match pc {
            0x828CE870 => {
    //   block [0x828CE870..0x828CE8C8)
	// 828CE870: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CE874: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CE878: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CE87C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CE880: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828CE884: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CE888: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE88C: 388B7868  addi r4, r11, 0x7868
	ctx.r[4].s64 = ctx.r[11].s64 + 30824;
	// 828CE890: 48525179  bl 0x82df3a08
	ctx.lr = 0x828CE894;
	sub_82DF3A08(ctx, base);
	// 828CE894: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828CE898: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828CE89C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828CE8A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CE8A4: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828CE8A8: 4803DE79  bl 0x8290c720
	ctx.lr = 0x828CE8AC;
	sub_8290C720(ctx, base);
	// 828CE8AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE8B0: 48524B79  bl 0x82df3428
	ctx.lr = 0x828CE8B4;
	sub_82DF3428(ctx, base);
	// 828CE8B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CE8B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CE8BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CE8C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CE8C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CE8C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828CE8C8 size=88
    let mut pc: u32 = 0x828CE8C8;
    'dispatch: loop {
        match pc {
            0x828CE8C8 => {
    //   block [0x828CE8C8..0x828CE920)
	// 828CE8C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CE8CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CE8D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CE8D4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CE8D8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828CE8DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CE8E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE8E4: 388B7868  addi r4, r11, 0x7868
	ctx.r[4].s64 = ctx.r[11].s64 + 30824;
	// 828CE8E8: 48525121  bl 0x82df3a08
	ctx.lr = 0x828CE8EC;
	sub_82DF3A08(ctx, base);
	// 828CE8EC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828CE8F0: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 828CE8F4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828CE8F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CE8FC: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828CE900: 4803DE21  bl 0x8290c720
	ctx.lr = 0x828CE904;
	sub_8290C720(ctx, base);
	// 828CE904: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CE908: 48524B21  bl 0x82df3428
	ctx.lr = 0x828CE90C;
	sub_82DF3428(ctx, base);
	// 828CE90C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CE910: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CE914: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CE918: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CE91C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CE920(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CE920 size=96
    let mut pc: u32 = 0x828CE920;
    'dispatch: loop {
        match pc {
            0x828CE920 => {
    //   block [0x828CE920..0x828CE980)
	// 828CE920: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CE924: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CE928: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CE92C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CE930: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CE934: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 828CE938: 409A0020  bne cr6, 0x828ce958
	if !ctx.cr[6].eq {
	pc = 0x828CE958; continue 'dispatch;
	}
	// 828CE93C: 4803A3ED  bl 0x82908d28
	ctx.lr = 0x828CE940;
	sub_82908D28(ctx, base);
	// 828CE940: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828CE944: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CE948: 4BF1D929  bl 0x827ec270
	ctx.lr = 0x828CE94C;
	sub_827EC270(ctx, base);
	// 828CE94C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CE950: 4BC41C81  bl 0x825105d0
	ctx.lr = 0x828CE954;
	sub_825105D0(ctx, base);
	// 828CE954: 48000018  b 0x828ce96c
	pc = 0x828CE96C; continue 'dispatch;
	// 828CE958: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CE95C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CE960: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 828CE964: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828CE968: 4E800421  bctrl
	ctx.lr = 0x828CE96C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CE96C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828CE970: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CE974: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CE978: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CE97C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CE980(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CE980 size=52
    let mut pc: u32 = 0x828CE980;
    'dispatch: loop {
        match pc {
            0x828CE980 => {
    //   block [0x828CE980..0x828CE9B4)
	// 828CE980: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CE984: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CE988: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CE98C: 8163FFF0  lwz r11, -0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-16 as u32) ) } as u64;
	// 828CE990: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 828CE994: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828CE998: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828CE99C: 4E800421  bctrl
	ctx.lr = 0x828CE9A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CE9A0: 38630078  addi r3, r3, 0x78
	ctx.r[3].s64 = ctx.r[3].s64 + 120;
	// 828CE9A4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828CE9A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CE9AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CE9B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CE9B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828CE9B8 size=20
    let mut pc: u32 = 0x828CE9B8;
    'dispatch: loop {
        match pc {
            0x828CE9B8 => {
    //   block [0x828CE9B8..0x828CE9CC)
	// 828CE9B8: 8163FFF0  lwz r11, -0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-16 as u32) ) } as u64;
	// 828CE9BC: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 828CE9C0: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828CE9C4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828CE9C8: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CE9D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828CE9D0 size=12
    let mut pc: u32 = 0x828CE9D0;
    'dispatch: loop {
        match pc {
            0x828CE9D0 => {
    //   block [0x828CE9D0..0x828CE9DC)
	// 828CE9D0: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828CE9D4: 386B1064  addi r3, r11, 0x1064
	ctx.r[3].s64 = ctx.r[11].s64 + 4196;
	// 828CE9D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CE9E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828CE9E0 size=12
    let mut pc: u32 = 0x828CE9E0;
    'dispatch: loop {
        match pc {
            0x828CE9E0 => {
    //   block [0x828CE9E0..0x828CE9EC)
	// 828CE9E0: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828CE9E4: 386B1070  addi r3, r11, 0x1070
	ctx.r[3].s64 = ctx.r[11].s64 + 4208;
	// 828CE9E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CE9F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828CE9F0 size=12
    let mut pc: u32 = 0x828CE9F0;
    'dispatch: loop {
        match pc {
            0x828CE9F0 => {
    //   block [0x828CE9F0..0x828CE9FC)
	// 828CE9F0: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828CE9F4: 386B1110  addi r3, r11, 0x1110
	ctx.r[3].s64 = ctx.r[11].s64 + 4368;
	// 828CE9F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CEA00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828CEA00 size=12
    let mut pc: u32 = 0x828CEA00;
    'dispatch: loop {
        match pc {
            0x828CEA00 => {
    //   block [0x828CEA00..0x828CEA0C)
	// 828CEA00: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828CEA04: 806B58F0  lwz r3, 0x58f0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(22768 as u32) ) } as u64;
	// 828CEA08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CEA10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828CEA10 size=12
    let mut pc: u32 = 0x828CEA10;
    'dispatch: loop {
        match pc {
            0x828CEA10 => {
    //   block [0x828CEA10..0x828CEA1C)
	// 828CEA10: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CEA14: 386BE6E4  addi r3, r11, -0x191c
	ctx.r[3].s64 = ctx.r[11].s64 + -6428;
	// 828CEA18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CEA20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CEA20 size=56
    let mut pc: u32 = 0x828CEA20;
    'dispatch: loop {
        match pc {
            0x828CEA20 => {
    //   block [0x828CEA20..0x828CEA58)
	// 828CEA20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CEA24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CEA28: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CEA2C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CEA30: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 828CEA34: 3BE40018  addi r31, r4, 0x18
	ctx.r[31].s64 = ctx.r[4].s64 + 24;
	// 828CEA38: 4BF1D729  bl 0x827ec160
	ctx.lr = 0x828CEA3C;
	sub_827EC160(ctx, base);
	// 828CEA3C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CEA40: 4BF20D01  bl 0x827ef740
	ctx.lr = 0x828CEA44;
	sub_827EF740(ctx, base);
	// 828CEA44: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828CEA48: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CEA4C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CEA50: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CEA54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CEA58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828CEA58 size=12
    let mut pc: u32 = 0x828CEA58;
    'dispatch: loop {
        match pc {
            0x828CEA58 => {
    //   block [0x828CEA58..0x828CEA64)
	// 828CEA58: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828CEA5C: 386B1218  addi r3, r11, 0x1218
	ctx.r[3].s64 = ctx.r[11].s64 + 4632;
	// 828CEA60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CEA68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828CEA68 size=12
    let mut pc: u32 = 0x828CEA68;
    'dispatch: loop {
        match pc {
            0x828CEA68 => {
    //   block [0x828CEA68..0x828CEA74)
	// 828CEA68: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828CEA6C: 806B58F4  lwz r3, 0x58f4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(22772 as u32) ) } as u64;
	// 828CEA70: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CEA78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828CEA78 size=12
    let mut pc: u32 = 0x828CEA78;
    'dispatch: loop {
        match pc {
            0x828CEA78 => {
    //   block [0x828CEA78..0x828CEA84)
	// 828CEA78: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CEA7C: 386BE6FC  addi r3, r11, -0x1904
	ctx.r[3].s64 = ctx.r[11].s64 + -6404;
	// 828CEA80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CEA88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CEA88 size=116
    let mut pc: u32 = 0x828CEA88;
    'dispatch: loop {
        match pc {
            0x828CEA88 => {
    //   block [0x828CEA88..0x828CEAFC)
	// 828CEA88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CEA8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CEA90: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828CEA94: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CEA98: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CEA9C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828CEAA0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828CEAA4: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 828CEAA8: 409A000C  bne cr6, 0x828ceab4
	if !ctx.cr[6].eq {
	pc = 0x828CEAB4; continue 'dispatch;
	}
	// 828CEAAC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CEAB0: 48000030  b 0x828ceae0
	pc = 0x828CEAE0; continue 'dispatch;
	// 828CEAB4: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 828CEAB8: 419A0024  beq cr6, 0x828ceadc
	if ctx.cr[6].eq {
	pc = 0x828CEADC; continue 'dispatch;
	}
	// 828CEABC: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828CEAC0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CEAC4: 388B55D8  addi r4, r11, 0x55d8
	ctx.r[4].s64 = ctx.r[11].s64 + 21976;
	// 828CEAC8: 488D9631  bl 0x831a80f8
	ctx.lr = 0x828CEACC;
	sub_831A80F8(ctx, base);
	// 828CEACC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CEAD0: 4182000C  beq 0x828ceadc
	if ctx.cr[0].eq {
	pc = 0x828CEADC; continue 'dispatch;
	}
	// 828CEAD4: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828CEAD8: 4800000C  b 0x828ceae4
	pc = 0x828CEAE4; continue 'dispatch;
	// 828CEADC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CEAE0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CEAE4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CEAE8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CEAEC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CEAF0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828CEAF4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CEAF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CEB00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CEB00 size=144
    let mut pc: u32 = 0x828CEB00;
    'dispatch: loop {
        match pc {
            0x828CEB00 => {
    //   block [0x828CEB00..0x828CEB90)
	// 828CEB00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CEB04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CEB08: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828CEB0C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CEB10: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CEB14: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828CEB18: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828CEB1C: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 828CEB20: 409A0028  bne cr6, 0x828ceb48
	if !ctx.cr[6].eq {
	pc = 0x828CEB48; continue 'dispatch;
	}
	// 828CEB24: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828CEB28: 419A0050  beq cr6, 0x828ceb78
	if ctx.cr[6].eq {
	pc = 0x828CEB78; continue 'dispatch;
	}
	// 828CEB2C: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 828CEB30: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 828CEB34: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 828CEB38: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 828CEB3C: E97E0010  ld r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	// 828CEB40: F97F0010  std r11, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 828CEB44: 48000034  b 0x828ceb78
	pc = 0x828CEB78; continue 'dispatch;
	// 828CEB48: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 828CEB4C: 419A002C  beq cr6, 0x828ceb78
	if ctx.cr[6].eq {
	pc = 0x828CEB78; continue 'dispatch;
	}
	// 828CEB50: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828CEB54: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CEB58: 388B5628  addi r4, r11, 0x5628
	ctx.r[4].s64 = ctx.r[11].s64 + 22056;
	// 828CEB5C: 488D959D  bl 0x831a80f8
	ctx.lr = 0x828CEB60;
	sub_831A80F8(ctx, base);
	// 828CEB60: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CEB64: 4182000C  beq 0x828ceb70
	if ctx.cr[0].eq {
	pc = 0x828CEB70; continue 'dispatch;
	}
	// 828CEB68: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828CEB6C: 4800000C  b 0x828ceb78
	pc = 0x828CEB78; continue 'dispatch;
	// 828CEB70: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CEB74: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CEB78: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CEB7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CEB80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CEB84: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828CEB88: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CEB8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CEB90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CEB90 size=136
    let mut pc: u32 = 0x828CEB90;
    'dispatch: loop {
        match pc {
            0x828CEB90 => {
    //   block [0x828CEB90..0x828CEC18)
	// 828CEB90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CEB94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CEB98: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828CEB9C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CEBA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CEBA4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828CEBA8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828CEBAC: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 828CEBB0: 409A0020  bne cr6, 0x828cebd0
	if !ctx.cr[6].eq {
	pc = 0x828CEBD0; continue 'dispatch;
	}
	// 828CEBB4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828CEBB8: 419A0048  beq cr6, 0x828cec00
	if ctx.cr[6].eq {
	pc = 0x828CEC00; continue 'dispatch;
	}
	// 828CEBBC: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 828CEBC0: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 828CEBC4: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 828CEBC8: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 828CEBCC: 48000034  b 0x828cec00
	pc = 0x828CEC00; continue 'dispatch;
	// 828CEBD0: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 828CEBD4: 419A002C  beq cr6, 0x828cec00
	if ctx.cr[6].eq {
	pc = 0x828CEC00; continue 'dispatch;
	}
	// 828CEBD8: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828CEBDC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CEBE0: 388B56E8  addi r4, r11, 0x56e8
	ctx.r[4].s64 = ctx.r[11].s64 + 22248;
	// 828CEBE4: 488D9515  bl 0x831a80f8
	ctx.lr = 0x828CEBE8;
	sub_831A80F8(ctx, base);
	// 828CEBE8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CEBEC: 4182000C  beq 0x828cebf8
	if ctx.cr[0].eq {
	pc = 0x828CEBF8; continue 'dispatch;
	}
	// 828CEBF0: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828CEBF4: 4800000C  b 0x828cec00
	pc = 0x828CEC00; continue 'dispatch;
	// 828CEBF8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CEBFC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CEC00: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CEC04: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CEC08: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CEC0C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828CEC10: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CEC14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CEC18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828CEC18 size=16
    let mut pc: u32 = 0x828CEC18;
    'dispatch: loop {
        match pc {
            0x828CEC18 => {
    //   block [0x828CEC18..0x828CEC28)
	// 828CEC18: 81830000  lwz r12, 0(r3)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CEC1C: 816C0060  lwz r11, 0x60(r12)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[12].u32.wrapping_add(96 as u32) ) } as u64;
	// 828CEC20: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828CEC24: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CEC28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828CEC28 size=16
    let mut pc: u32 = 0x828CEC28;
    'dispatch: loop {
        match pc {
            0x828CEC28 => {
    //   block [0x828CEC28..0x828CEC38)
	// 828CEC28: 81830000  lwz r12, 0(r3)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CEC2C: 816C0054  lwz r11, 0x54(r12)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[12].u32.wrapping_add(84 as u32) ) } as u64;
	// 828CEC30: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828CEC34: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CEC38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CEC38 size=152
    let mut pc: u32 = 0x828CEC38;
    'dispatch: loop {
        match pc {
            0x828CEC38 => {
    //   block [0x828CEC38..0x828CECD0)
	// 828CEC38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CEC3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CEC40: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828CEC44: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CEC48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CEC4C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CEC50: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828CEC54: 807F0360  lwz r3, 0x360(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(864 as u32) ) } as u64;
	// 828CEC58: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CEC5C: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 828CEC60: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828CEC64: 4E800421  bctrl
	ctx.lr = 0x828CEC68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CEC68: 807F0360  lwz r3, 0x360(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(864 as u32) ) } as u64;
	// 828CEC6C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CEC70: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 828CEC74: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828CEC78: 4E800421  bctrl
	ctx.lr = 0x828CEC7C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CEC7C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CEC80: 41820038  beq 0x828cecb8
	if ctx.cr[0].eq {
	pc = 0x828CECB8; continue 'dispatch;
	}
	// 828CEC84: 807F0360  lwz r3, 0x360(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(864 as u32) ) } as u64;
	// 828CEC88: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CEC8C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828CEC90: 41820018  beq 0x828ceca8
	if ctx.cr[0].eq {
	pc = 0x828CECA8; continue 'dispatch;
	}
	// 828CEC94: 48003A05  bl 0x828d2698
	ctx.lr = 0x828CEC98;
	sub_828D2698(ctx, base);
	// 828CEC98: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828CEC9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CECA0: 4BC43021  bl 0x82511cc0
	ctx.lr = 0x828CECA4;
	sub_82511CC0(ctx, base);
	// 828CECA4: 48000014  b 0x828cecb8
	pc = 0x828CECB8; continue 'dispatch;
	// 828CECA8: 480039F1  bl 0x828d2698
	ctx.lr = 0x828CECAC;
	sub_828D2698(ctx, base);
	// 828CECAC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828CECB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CECB4: 4BC42FED  bl 0x82511ca0
	ctx.lr = 0x828CECB8;
	sub_82511CA0(ctx, base);
	// 828CECB8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CECBC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CECC0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CECC4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828CECC8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CECCC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CECD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828CECD0 size=128
    let mut pc: u32 = 0x828CECD0;
    'dispatch: loop {
        match pc {
            0x828CECD0 => {
    //   block [0x828CECD0..0x828CED50)
	// 828CECD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CECD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CECD8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828CECDC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CECE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CECE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CECE8: 81640018  lwz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 828CECEC: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828CECF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CECF4: 813F0270  lwz r9, 0x270(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(624 as u32) ) } as u64;
	// 828CECF8: 91690014  stw r11, 0x14(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 828CECFC: 808A0B7C  lwz r4, 0xb7c(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2940 as u32) ) } as u64;
	// 828CED00: 48524D09  bl 0x82df3a08
	ctx.lr = 0x828CED04;
	sub_82DF3A08(ctx, base);
	// 828CED04: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 828CED08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CED0C: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 828CED10: 4BF1D451  bl 0x827ec160
	ctx.lr = 0x828CED14;
	sub_827EC160(ctx, base);
	// 828CED14: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828CED18: 4BF20A29  bl 0x827ef740
	ctx.lr = 0x828CED1C;
	sub_827EF740(ctx, base);
	// 828CED1C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CED20: 48524709  bl 0x82df3428
	ctx.lr = 0x828CED24;
	sub_82DF3428(ctx, base);
	// 828CED24: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828CED28: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 828CED2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CED30: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828CED34: 48040045  bl 0x8290ed78
	ctx.lr = 0x828CED38;
	sub_8290ED78(ctx, base);
	// 828CED38: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CED3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CED40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CED44: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828CED48: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CED4C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CED50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828CED50 size=124
    let mut pc: u32 = 0x828CED50;
    'dispatch: loop {
        match pc {
            0x828CED50 => {
    //   block [0x828CED50..0x828CEDCC)
	// 828CED50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CED54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CED58: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828CED5C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CED60: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CED64: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828CED68: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828CED6C: 387E0010  addi r3, r30, 0x10
	ctx.r[3].s64 = ctx.r[30].s64 + 16;
	// 828CED70: 4803A0E9  bl 0x82908e58
	ctx.lr = 0x828CED74;
	sub_82908E58(ctx, base);
	// 828CED74: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828CED78: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828CED7C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CED80: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 828CED84: 41990008  bgt cr6, 0x828ced8c
	if ctx.cr[6].gt {
	pc = 0x828CED8C; continue 'dispatch;
	}
	// 828CED88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CED8C: 997F0018  stb r11, 0x18(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u8 ) };
	// 828CED90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CED94: 809E00F4  lwz r4, 0xf4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(244 as u32) ) } as u64;
	// 828CED98: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CED9C: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 828CEDA0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828CEDA4: 4E800421  bctrl
	ctx.lr = 0x828CEDA8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CEDA8: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 828CEDAC: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CEDD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CEDD0 size=196
    let mut pc: u32 = 0x828CEDD0;
    'dispatch: loop {
        match pc {
            0x828CEDD0 => {
    //   block [0x828CEDD0..0x828CEE94)
	// 828CEDD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CEDD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CEDD8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828CEDDC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CEDE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CEDE4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828CEDE8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CEDEC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828CEDF0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828CEDF4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CEDF8: 4B9F1B41  bl 0x822c0938
	ctx.lr = 0x828CEDFC;
	sub_822C0938(ctx, base);
	// 828CEDFC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828CEE00: 41820028  beq 0x828cee28
	if ctx.cr[0].eq {
	pc = 0x828CEE28; continue 'dispatch;
	}
	// 828CEE04: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CEE08: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828CEE0C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828CEE10: 392BE71C  addi r9, r11, -0x18e4
	ctx.r[9].s64 = ctx.r[11].s64 + -6372;
	// 828CEE14: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828CEE18: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828CEE1C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828CEE20: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828CEE24: 48000008  b 0x828cee2c
	pc = 0x828CEE2C; continue 'dispatch;
	// 828CEE28: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CEE2C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CEE30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CEE34: 409A0044  bne cr6, 0x828cee78
	if !ctx.cr[6].eq {
	pc = 0x828CEE78; continue 'dispatch;
	}
	// 828CEE38: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828CEE3C: 419A001C  beq cr6, 0x828cee58
	if ctx.cr[6].eq {
	pc = 0x828CEE58; continue 'dispatch;
	}
	// 828CEE40: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CEE44: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828CEE48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CEE4C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CEE50: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828CEE54: 4E800421  bctrl
	ctx.lr = 0x828CEE58;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CEE58: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828CEE5C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828CEE60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CEE64: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828CEE68: 816B5484  lwz r11, 0x5484(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(21636 as u32) ) } as u64;
	// 828CEE6C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828CEE70: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828CEE74: 4B9F118D  bl 0x822c0000
	ctx.lr = 0x828CEE78;
	sub_822C0000(ctx, base);
	// 828CEE78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CEE7C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CEE80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CEE84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CEE88: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828CEE8C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CEE90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CEE98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CEE98 size=196
    let mut pc: u32 = 0x828CEE98;
    'dispatch: loop {
        match pc {
            0x828CEE98 => {
    //   block [0x828CEE98..0x828CEF5C)
	// 828CEE98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CEE9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CEEA0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828CEEA4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CEEA8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CEEAC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828CEEB0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CEEB4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828CEEB8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828CEEBC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CEEC0: 4B9F1A79  bl 0x822c0938
	ctx.lr = 0x828CEEC4;
	sub_822C0938(ctx, base);
	// 828CEEC4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828CEEC8: 41820028  beq 0x828ceef0
	if ctx.cr[0].eq {
	pc = 0x828CEEF0; continue 'dispatch;
	}
	// 828CEECC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CEED0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828CEED4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828CEED8: 392BE730  addi r9, r11, -0x18d0
	ctx.r[9].s64 = ctx.r[11].s64 + -6352;
	// 828CEEDC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828CEEE0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828CEEE4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828CEEE8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828CEEEC: 48000008  b 0x828ceef4
	pc = 0x828CEEF4; continue 'dispatch;
	// 828CEEF0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CEEF4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CEEF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CEEFC: 409A0044  bne cr6, 0x828cef40
	if !ctx.cr[6].eq {
	pc = 0x828CEF40; continue 'dispatch;
	}
	// 828CEF00: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828CEF04: 419A001C  beq cr6, 0x828cef20
	if ctx.cr[6].eq {
	pc = 0x828CEF20; continue 'dispatch;
	}
	// 828CEF08: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CEF0C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828CEF10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CEF14: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CEF18: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828CEF1C: 4E800421  bctrl
	ctx.lr = 0x828CEF20;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CEF20: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828CEF24: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828CEF28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CEF2C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828CEF30: 816B5484  lwz r11, 0x5484(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(21636 as u32) ) } as u64;
	// 828CEF34: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828CEF38: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828CEF3C: 4B9F10C5  bl 0x822c0000
	ctx.lr = 0x828CEF40;
	sub_822C0000(ctx, base);
	// 828CEF40: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CEF44: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CEF48: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CEF4C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CEF50: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828CEF54: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CEF58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CEF60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CEF60 size=196
    let mut pc: u32 = 0x828CEF60;
    'dispatch: loop {
        match pc {
            0x828CEF60 => {
    //   block [0x828CEF60..0x828CF024)
	// 828CEF60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CEF64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CEF68: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828CEF6C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CEF70: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CEF74: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828CEF78: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CEF7C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828CEF80: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828CEF84: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CEF88: 4B9F19B1  bl 0x822c0938
	ctx.lr = 0x828CEF8C;
	sub_822C0938(ctx, base);
	// 828CEF8C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828CEF90: 41820028  beq 0x828cefb8
	if ctx.cr[0].eq {
	pc = 0x828CEFB8; continue 'dispatch;
	}
	// 828CEF94: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CEF98: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828CEF9C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828CEFA0: 392BE744  addi r9, r11, -0x18bc
	ctx.r[9].s64 = ctx.r[11].s64 + -6332;
	// 828CEFA4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828CEFA8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828CEFAC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828CEFB0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828CEFB4: 48000008  b 0x828cefbc
	pc = 0x828CEFBC; continue 'dispatch;
	// 828CEFB8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CEFBC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CEFC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CEFC4: 409A0044  bne cr6, 0x828cf008
	if !ctx.cr[6].eq {
	pc = 0x828CF008; continue 'dispatch;
	}
	// 828CEFC8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828CEFCC: 419A001C  beq cr6, 0x828cefe8
	if ctx.cr[6].eq {
	pc = 0x828CEFE8; continue 'dispatch;
	}
	// 828CEFD0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CEFD4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828CEFD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CEFDC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CEFE0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828CEFE4: 4E800421  bctrl
	ctx.lr = 0x828CEFE8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CEFE8: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828CEFEC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828CEFF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CEFF4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828CEFF8: 816B5484  lwz r11, 0x5484(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(21636 as u32) ) } as u64;
	// 828CEFFC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828CF000: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828CF004: 4B9F0FFD  bl 0x822c0000
	ctx.lr = 0x828CF008;
	sub_822C0000(ctx, base);
	// 828CF008: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CF00C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CF010: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CF014: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CF018: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828CF01C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CF020: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CF028(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CF028 size=196
    let mut pc: u32 = 0x828CF028;
    'dispatch: loop {
        match pc {
            0x828CF028 => {
    //   block [0x828CF028..0x828CF0EC)
	// 828CF028: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CF02C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CF030: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828CF034: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CF038: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CF03C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828CF040: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CF044: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828CF048: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828CF04C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CF050: 4B9F18E9  bl 0x822c0938
	ctx.lr = 0x828CF054;
	sub_822C0938(ctx, base);
	// 828CF054: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828CF058: 41820028  beq 0x828cf080
	if ctx.cr[0].eq {
	pc = 0x828CF080; continue 'dispatch;
	}
	// 828CF05C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CF060: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828CF064: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828CF068: 392BE758  addi r9, r11, -0x18a8
	ctx.r[9].s64 = ctx.r[11].s64 + -6312;
	// 828CF06C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828CF070: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828CF074: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828CF078: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828CF07C: 48000008  b 0x828cf084
	pc = 0x828CF084; continue 'dispatch;
	// 828CF080: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CF084: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CF088: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CF08C: 409A0044  bne cr6, 0x828cf0d0
	if !ctx.cr[6].eq {
	pc = 0x828CF0D0; continue 'dispatch;
	}
	// 828CF090: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828CF094: 419A001C  beq cr6, 0x828cf0b0
	if ctx.cr[6].eq {
	pc = 0x828CF0B0; continue 'dispatch;
	}
	// 828CF098: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CF09C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828CF0A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CF0A4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CF0A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828CF0AC: 4E800421  bctrl
	ctx.lr = 0x828CF0B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CF0B0: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828CF0B4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828CF0B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CF0BC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828CF0C0: 816B5484  lwz r11, 0x5484(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(21636 as u32) ) } as u64;
	// 828CF0C4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828CF0C8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828CF0CC: 4B9F0F35  bl 0x822c0000
	ctx.lr = 0x828CF0D0;
	sub_822C0000(ctx, base);
	// 828CF0D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CF0D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CF0D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CF0DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CF0E0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828CF0E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CF0E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CF0F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CF0F0 size=72
    let mut pc: u32 = 0x828CF0F0;
    'dispatch: loop {
        match pc {
            0x828CF0F0 => {
    //   block [0x828CF0F0..0x828CF138)
	// 828CF0F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CF0F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CF0F8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CF0FC: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 828CF100: 419A001C  beq cr6, 0x828cf11c
	if ctx.cr[6].eq {
	pc = 0x828CF11C; continue 'dispatch;
	}
	// 828CF104: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828CF108: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828CF10C: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 828CF110: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828CF114: 4BFFF975  bl 0x828cea88
	ctx.lr = 0x828CF118;
	sub_828CEA88(ctx, base);
	// 828CF118: 48000010  b 0x828cf128
	pc = 0x828CF128; continue 'dispatch;
	// 828CF11C: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828CF120: 396B55D8  addi r11, r11, 0x55d8
	ctx.r[11].s64 = ctx.r[11].s64 + 21976;
	// 828CF124: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CF128: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828CF12C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CF130: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CF134: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CF138(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CF138 size=172
    let mut pc: u32 = 0x828CF138;
    'dispatch: loop {
        match pc {
            0x828CF138 => {
    //   block [0x828CF138..0x828CF1E4)
	// 828CF138: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CF13C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CF140: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828CF144: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CF148: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CF14C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CF150: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CF154: 3D008209  lis r8, -0x7df7
	ctx.r[8].s64 = -2113339392;
	// 828CF158: 396BE944  addi r11, r11, -0x16bc
	ctx.r[11].s64 = ctx.r[11].s64 + -5820;
	// 828CF15C: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828CF160: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828CF164: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CF168: 394AE784  addi r10, r10, -0x187c
	ctx.r[10].s64 = ctx.r[10].s64 + -6268;
	// 828CF16C: 807F0388  lwz r3, 0x388(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(904 as u32) ) } as u64;
	// 828CF170: 3929E76C  addi r9, r9, -0x1894
	ctx.r[9].s64 = ctx.r[9].s64 + -6292;
	// 828CF174: 3968E928  addi r11, r8, -0x16d8
	ctx.r[11].s64 = ctx.r[8].s64 + -5848;
	// 828CF178: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 828CF17C: 913F0038  stw r9, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[9].u32 ) };
	// 828CF180: 3BDF0010  addi r30, r31, 0x10
	ctx.r[30].s64 = ctx.r[31].s64 + 16;
	// 828CF184: 917F0218  stw r11, 0x218(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(536 as u32), ctx.r[11].u32 ) };
	// 828CF188: 4B9F10E1  bl 0x822c0268
	ctx.lr = 0x828CF18C;
	sub_822C0268(ctx, base);
	// 828CF18C: 807F0384  lwz r3, 0x384(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(900 as u32) ) } as u64;
	// 828CF190: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828CF194: 419A0008  beq cr6, 0x828cf19c
	if ctx.cr[6].eq {
	pc = 0x828CF19C; continue 'dispatch;
	}
	// 828CF198: 4B9F16F9  bl 0x822c0890
	ctx.lr = 0x828CF19C;
	sub_822C0890(ctx, base);
	// 828CF19C: 807F037C  lwz r3, 0x37c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(892 as u32) ) } as u64;
	// 828CF1A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828CF1A4: 419A0008  beq cr6, 0x828cf1ac
	if ctx.cr[6].eq {
	pc = 0x828CF1AC; continue 'dispatch;
	}
	// 828CF1A8: 4B9F16E9  bl 0x822c0890
	ctx.lr = 0x828CF1AC;
	sub_822C0890(ctx, base);
	// 828CF1AC: 807F0374  lwz r3, 0x374(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(884 as u32) ) } as u64;
	// 828CF1B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828CF1B4: 419A0008  beq cr6, 0x828cf1bc
	if ctx.cr[6].eq {
	pc = 0x828CF1BC; continue 'dispatch;
	}
	// 828CF1B8: 4B9F16D9  bl 0x822c0890
	ctx.lr = 0x828CF1BC;
	sub_822C0890(ctx, base);
	// 828CF1BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CF1C0: 48041AD1  bl 0x82910c90
	ctx.lr = 0x828CF1C4;
	sub_82910C90(ctx, base);
	// 828CF1C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CF1C8: 4BED8491  bl 0x827a7658
	ctx.lr = 0x828CF1CC;
	sub_827A7658(ctx, base);
	// 828CF1CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CF1D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CF1D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CF1D8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828CF1DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CF1E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CF1E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828CF1E8 size=8
    let mut pc: u32 = 0x828CF1E8;
    'dispatch: loop {
        match pc {
            0x828CF1E8 => {
    //   block [0x828CF1E8..0x828CF1F0)
	// 828CF1E8: 3863FFC8  addi r3, r3, -0x38
	ctx.r[3].s64 = ctx.r[3].s64 + -56;
	// 828CF1EC: 4800068C  b 0x828cf878
	sub_828CF878(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CF1F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828CF1F0 size=8
    let mut pc: u32 = 0x828CF1F0;
    'dispatch: loop {
        match pc {
            0x828CF1F0 => {
    //   block [0x828CF1F0..0x828CF1F8)
	// 828CF1F0: 3863FDE8  addi r3, r3, -0x218
	ctx.r[3].s64 = ctx.r[3].s64 + -536;
	// 828CF1F4: 48000684  b 0x828cf878
	sub_828CF878(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CF1F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828CF1F8 size=8
    let mut pc: u32 = 0x828CF1F8;
    'dispatch: loop {
        match pc {
            0x828CF1F8 => {
    //   block [0x828CF1F8..0x828CF200)
	// 828CF1F8: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 828CF1FC: 4800067C  b 0x828cf878
	sub_828CF878(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CF200(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828CF200 size=168
    let mut pc: u32 = 0x828CF200;
    'dispatch: loop {
        match pc {
            0x828CF200 => {
    //   block [0x828CF200..0x828CF2A8)
	// 828CF200: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CF204: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CF208: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CF20C: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CF210: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CF214: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CF218: 485ACC81  bl 0x82e7be98
	ctx.lr = 0x828CF21C;
	sub_82E7BE98(ctx, base);
	// 828CF21C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828CF220: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 828CF224: 807F01E8  lwz r3, 0x1e8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(488 as u32) ) } as u64;
	// 828CF228: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 828CF22C: 39000030  li r8, 0x30
	ctx.r[8].s64 = 48;
	// 828CF230: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 828CF234: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828CF238: 13E05C07  vcmpneb. (lvlx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828CF23C: 13CA5C07  vcmpneb. (lvlx128) v30, v10, v11
	tmp.u32 = ctx.r[10].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828CF240: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 828CF244: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 828CF248: 13A95C07  vcmpneb. (lvlx128) v29, v9, v11
	tmp.u32 = ctx.r[9].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828CF24C: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 828CF250: 13885C07  vcmpneb. (lvlx128) v28, v8, v11
	tmp.u32 = ctx.r[8].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CF2A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828CF2A8 size=200
    let mut pc: u32 = 0x828CF2A8;
    'dispatch: loop {
        match pc {
            0x828CF2A8 => {
    //   block [0x828CF2A8..0x828CF370)
	// 828CF2A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CF2AC: 488D8EC1  bl 0x831a816c
	ctx.lr = 0x828CF2B0;
	sub_831A8130(ctx, base);
	// 828CF2B0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CF2B4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828CF2B8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828CF2BC: 3BFE0010  addi r31, r30, 0x10
	ctx.r[31].s64 = ctx.r[30].s64 + 16;
	// 828CF2C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CF2C4: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828CF2C8: C03D000C  lfs f1, 0xc(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828CF2CC: 816B0064  lwz r11, 0x64(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 828CF2D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828CF2D4: 4E800421  bctrl
	ctx.lr = 0x828CF2D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CF2D8: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828CF2DC: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 828CF2E0: 396B6880  addi r11, r11, 0x6880
	ctx.r[11].s64 = ctx.r[11].s64 + 26752;
	// 828CF2E4: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 828CF2E8: 39000030  li r8, 0x30
	ctx.r[8].s64 = 48;
	// 828CF2EC: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 828CF2F0: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828CF2F4: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 828CF2F8: 13E05C07  vcmpneb. (lvlx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828CF2FC: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 828CF300: 13CA5C07  vcmpneb. (lvlx128) v30, v10, v11
	tmp.u32 = ctx.r[10].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828CF304: 13A95C07  vcmpneb. (lvlx128) v29, v9, v11
	tmp.u32 = ctx.r[9].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828CF308: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CF30C: 13885C07  vcmpneb. (lvlx128) v28, v8, v11
	tmp.u32 = ctx.r[8].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CF370(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828CF370 size=264
    let mut pc: u32 = 0x828CF370;
    'dispatch: loop {
        match pc {
            0x828CF370 => {
    //   block [0x828CF370..0x828CF478)
	// 828CF370: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CF374: 488D8DF9  bl 0x831a816c
	ctx.lr = 0x828CF378;
	sub_831A8130(ctx, base);
	// 828CF378: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CF37C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CF380: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 828CF384: 807F01DC  lwz r3, 0x1dc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(476 as u32) ) } as u64;
	// 828CF388: 4BF1AFE1  bl 0x827ea368
	ctx.lr = 0x828CF38C;
	sub_827EA368(ctx, base);
	// 828CF38C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828CF390: 3BDF0010  addi r30, r31, 0x10
	ctx.r[30].s64 = ctx.r[31].s64 + 16;
	// 828CF394: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828CF398: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CF39C: 816B00D4  lwz r11, 0xd4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(212 as u32) ) } as u64;
	// 828CF3A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828CF3A4: 4E800421  bctrl
	ctx.lr = 0x828CF3A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CF3A8: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CF3AC: 418200AC  beq 0x828cf458
	if ctx.cr[0].eq {
	pc = 0x828CF458; continue 'dispatch;
	}
	// 828CF3B0: 817F0398  lwz r11, 0x398(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(920 as u32) ) } as u64;
	// 828CF3B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CF3B8: 409A00B8  bne cr6, 0x828cf470
	if !ctx.cr[6].eq {
	pc = 0x828CF470; continue 'dispatch;
	}
	// 828CF3BC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828CF3C0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828CF3C4: 388B7868  addi r4, r11, 0x7868
	ctx.r[4].s64 = ctx.r[11].s64 + 30824;
	// 828CF3C8: 48524641  bl 0x82df3a08
	ctx.lr = 0x828CF3CC;
	sub_82DF3A08(ctx, base);
	// 828CF3CC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828CF3D0: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 828CF3D4: 388B2318  addi r4, r11, 0x2318
	ctx.r[4].s64 = ctx.r[11].s64 + 8984;
	// 828CF3D8: 48524631  bl 0x82df3a08
	ctx.lr = 0x828CF3DC;
	sub_82DF3A08(ctx, base);
	// 828CF3DC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828CF3E0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828CF3E4: 39200007  li r9, 7
	ctx.r[9].s64 = 7;
	// 828CF3E8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828CF3EC: 91210068  stw r9, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[9].u32 ) };
	// 828CF3F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CF3F4: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828CF3F8: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 828CF3FC: C1AA08A8  lfs f13, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828CF400: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 828CF404: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 828CF408: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 828CF40C: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 828CF410: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 828CF414: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 828CF418: D1A10084  stfs f13, 0x84(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 828CF41C: D1A10088  stfs f13, 0x88(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 828CF420: D1A1008C  stfs f13, 0x8c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 828CF424: 4BF1D1A5  bl 0x827ec5c8
	ctx.lr = 0x828CF428;
	sub_827EC5C8(ctx, base);
	// 828CF428: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828CF42C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CF430: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828CF434: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 828CF438: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828CF43C: 4BF1D405  bl 0x827ec840
	ctx.lr = 0x828CF440;
	sub_827EC840(ctx, base);
	// 828CF440: 907F0398  stw r3, 0x398(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(920 as u32), ctx.r[3].u32 ) };
	// 828CF444: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 828CF448: 48523FE1  bl 0x82df3428
	ctx.lr = 0x828CF44C;
	sub_82DF3428(ctx, base);
	// 828CF44C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828CF450: 48523FD9  bl 0x82df3428
	ctx.lr = 0x828CF454;
	sub_82DF3428(ctx, base);
	// 828CF454: 4800001C  b 0x828cf470
	pc = 0x828CF470; continue 'dispatch;
	// 828CF458: 809F0398  lwz r4, 0x398(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(920 as u32) ) } as u64;
	// 828CF45C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828CF460: 419A0010  beq cr6, 0x828cf470
	if ctx.cr[6].eq {
	pc = 0x828CF470; continue 'dispatch;
	}
	// 828CF464: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828CF468: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CF46C: 4BF1CDFD  bl 0x827ec268
	ctx.lr = 0x828CF470;
	sub_827EC268(ctx, base);
	// 828CF470: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828CF474: 488D8D48  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CF478(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828CF478 size=232
    let mut pc: u32 = 0x828CF478;
    'dispatch: loop {
        match pc {
            0x828CF478 => {
    //   block [0x828CF478..0x828CF560)
	// 828CF478: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CF47C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CF480: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828CF484: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CF488: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CF560(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828CF560 size=232
    let mut pc: u32 = 0x828CF560;
    'dispatch: loop {
        match pc {
            0x828CF560 => {
    //   block [0x828CF560..0x828CF648)
	// 828CF560: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CF564: 488D8C05  bl 0x831a8168
	ctx.lr = 0x828CF568;
	sub_831A8130(ctx, base);
	// 828CF568: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 828CF56C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CF570: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828CF574: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CF578: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CF57C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828CF580: 808B0B24  lwz r4, 0xb24(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2852 as u32) ) } as u64;
	// 828CF584: 48524485  bl 0x82df3a08
	ctx.lr = 0x828CF588;
	sub_82DF3A08(ctx, base);
	// 828CF588: 3BDF010C  addi r30, r31, 0x10c
	ctx.r[30].s64 = ctx.r[31].s64 + 268;
	// 828CF58C: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 828CF590: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CF594: 4858B13D  bl 0x82e5a6d0
	ctx.lr = 0x828CF598;
	sub_82E5A6D0(ctx, base);
	// 828CF598: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828CF59C: 48523D6D  bl 0x82df3308
	ctx.lr = 0x828CF5A0;
	sub_82DF3308(ctx, base);
	// 828CF5A0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828CF5A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CF5A8: 48523E81  bl 0x82df3428
	ctx.lr = 0x828CF5AC;
	sub_82DF3428(ctx, base);
	// 828CF5AC: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CF5B0: 4182008C  beq 0x828cf63c
	if ctx.cr[0].eq {
	pc = 0x828CF63C; continue 'dispatch;
	}
	// 828CF5B4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828CF5B8: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828CF5BC: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 828CF5C0: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828CF5C4: 816A0080  lwz r11, 0x80(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(128 as u32) ) } as u64;
	// 828CF5C8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828CF5CC: 4E800421  bctrl
	ctx.lr = 0x828CF5D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CF5D0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CF5D4: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 828CF5D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CF5DC: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828CF5E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828CF5E4: 4E800421  bctrl
	ctx.lr = 0x828CF5E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CF5E8: 38630098  addi r3, r3, 0x98
	ctx.r[3].s64 = ctx.r[3].s64 + 152;
	// 828CF5EC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828CF5F0: 48088B49  bl 0x82958138
	ctx.lr = 0x828CF5F4;
	sub_82958138(ctx, base);
	// 828CF5F4: FF1F0800  fcmpu cr6, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[1].f64);
	// 828CF5F8: 40980044  bge cr6, 0x828cf63c
	if !ctx.cr[6].lt {
	pc = 0x828CF63C; continue 'dispatch;
	}
	// 828CF5FC: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828CF600: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CF604: 808B6060  lwz r4, 0x6060(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24672 as u32) ) } as u64;
	// 828CF608: 48524401  bl 0x82df3a08
	ctx.lr = 0x828CF60C;
	sub_82DF3A08(ctx, base);
	// 828CF60C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828CF610: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828CF614: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828CF618: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828CF61C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828CF620: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828CF624: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828CF628: 4858F339  bl 0x82e5e960
	ctx.lr = 0x828CF62C;
	sub_82E5E960(ctx, base);
	// 828CF62C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828CF630: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828CF634: 419A0008  beq cr6, 0x828cf63c
	if ctx.cr[6].eq {
	pc = 0x828CF63C; continue 'dispatch;
	}
	// 828CF638: 4B9F1259  bl 0x822c0890
	ctx.lr = 0x828CF63C;
	sub_822C0890(ctx, base);
	// 828CF63C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828CF640: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 828CF644: 488D8B74  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CF648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828CF648 size=8
    let mut pc: u32 = 0x828CF648;
    'dispatch: loop {
        match pc {
            0x828CF648 => {
    //   block [0x828CF648..0x828CF650)
	// 828CF648: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 828CF64C: 48000764  b 0x828cfdb0
	sub_828CFDB0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CF650(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828CF650 size=8
    let mut pc: u32 = 0x828CF650;
    'dispatch: loop {
        match pc {
            0x828CF650 => {
    //   block [0x828CF650..0x828CF658)
	// 828CF650: 3863FFC8  addi r3, r3, -0x38
	ctx.r[3].s64 = ctx.r[3].s64 + -56;
	// 828CF654: 4800075C  b 0x828cfdb0
	sub_828CFDB0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CF658(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828CF658 size=8
    let mut pc: u32 = 0x828CF658;
    'dispatch: loop {
        match pc {
            0x828CF658 => {
    //   block [0x828CF658..0x828CF660)
	// 828CF658: 3863FDE8  addi r3, r3, -0x218
	ctx.r[3].s64 = ctx.r[3].s64 + -536;
	// 828CF65C: 48000754  b 0x828cfdb0
	sub_828CFDB0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CF660(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CF660 size=84
    let mut pc: u32 = 0x828CF660;
    'dispatch: loop {
        match pc {
            0x828CF660 => {
    //   block [0x828CF660..0x828CF6B4)
	// 828CF660: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CF664: 488D8B09  bl 0x831a816c
	ctx.lr = 0x828CF668;
	sub_831A8130(ctx, base);
	// 828CF668: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CF66C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828CF670: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828CF674: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828CF678: 397F0010  addi r11, r31, 0x10
	ctx.r[11].s64 = ctx.r[31].s64 + 16;
	// 828CF67C: 409A0008  bne cr6, 0x828cf684
	if !ctx.cr[6].eq {
	pc = 0x828CF684; continue 'dispatch;
	}
	// 828CF680: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CF684: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CF688: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828CF68C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CF690: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CF694: 4BFFF73D  bl 0x828cedd0
	ctx.lr = 0x828CF698;
	sub_828CEDD0(ctx, base);
	// 828CF698: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828CF69C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CF6A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CF6A4: 4B9F095D  bl 0x822c0000
	ctx.lr = 0x828CF6A8;
	sub_822C0000(ctx, base);
	// 828CF6A8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828CF6AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CF6B0: 488D8B0C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CF6B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CF6B8 size=84
    let mut pc: u32 = 0x828CF6B8;
    'dispatch: loop {
        match pc {
            0x828CF6B8 => {
    //   block [0x828CF6B8..0x828CF70C)
	// 828CF6B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CF6BC: 488D8AB1  bl 0x831a816c
	ctx.lr = 0x828CF6C0;
	sub_831A8130(ctx, base);
	// 828CF6C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CF6C4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828CF6C8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828CF6CC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828CF6D0: 397F0010  addi r11, r31, 0x10
	ctx.r[11].s64 = ctx.r[31].s64 + 16;
	// 828CF6D4: 409A0008  bne cr6, 0x828cf6dc
	if !ctx.cr[6].eq {
	pc = 0x828CF6DC; continue 'dispatch;
	}
	// 828CF6D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CF6DC: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CF6E0: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828CF6E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CF6E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CF6EC: 4BFFF7AD  bl 0x828cee98
	ctx.lr = 0x828CF6F0;
	sub_828CEE98(ctx, base);
	// 828CF6F0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828CF6F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CF6F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CF6FC: 4B9F0905  bl 0x822c0000
	ctx.lr = 0x828CF700;
	sub_822C0000(ctx, base);
	// 828CF700: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828CF704: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CF708: 488D8AB4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CF710(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CF710 size=72
    let mut pc: u32 = 0x828CF710;
    'dispatch: loop {
        match pc {
            0x828CF710 => {
    //   block [0x828CF710..0x828CF758)
	// 828CF710: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CF714: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CF718: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CF71C: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 828CF720: 419A001C  beq cr6, 0x828cf73c
	if ctx.cr[6].eq {
	pc = 0x828CF73C; continue 'dispatch;
	}
	// 828CF724: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828CF728: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828CF72C: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 828CF730: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828CF734: 4BFFF3CD  bl 0x828ceb00
	ctx.lr = 0x828CF738;
	sub_828CEB00(ctx, base);
	// 828CF738: 48000010  b 0x828cf748
	pc = 0x828CF748; continue 'dispatch;
	// 828CF73C: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828CF740: 396B5628  addi r11, r11, 0x5628
	ctx.r[11].s64 = ctx.r[11].s64 + 22056;
	// 828CF744: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CF748: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828CF74C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CF750: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CF754: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CF758(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CF758 size=72
    let mut pc: u32 = 0x828CF758;
    'dispatch: loop {
        match pc {
            0x828CF758 => {
    //   block [0x828CF758..0x828CF7A0)
	// 828CF758: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CF75C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CF760: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CF764: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 828CF768: 419A001C  beq cr6, 0x828cf784
	if ctx.cr[6].eq {
	pc = 0x828CF784; continue 'dispatch;
	}
	// 828CF76C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828CF770: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828CF774: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 828CF778: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828CF77C: 4BFFF415  bl 0x828ceb90
	ctx.lr = 0x828CF780;
	sub_828CEB90(ctx, base);
	// 828CF780: 48000010  b 0x828cf790
	pc = 0x828CF790; continue 'dispatch;
	// 828CF784: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828CF788: 396B56E8  addi r11, r11, 0x56e8
	ctx.r[11].s64 = ctx.r[11].s64 + 22248;
	// 828CF78C: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CF790: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828CF794: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CF798: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CF79C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CF7A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CF7A0 size=216
    let mut pc: u32 = 0x828CF7A0;
    'dispatch: loop {
        match pc {
            0x828CF7A0 => {
    //   block [0x828CF7A0..0x828CF878)
	// 828CF7A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CF7A4: 488D89C5  bl 0x831a8168
	ctx.lr = 0x828CF7A8;
	sub_831A8130(ctx, base);
	// 828CF7A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CF7AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CF7B0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 828CF7B4: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 828CF7B8: 396BA214  addi r11, r11, -0x5dec
	ctx.r[11].s64 = ctx.r[11].s64 + -24044;
	// 828CF7BC: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 828CF7C0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CF7C4: 7D1C4378  mr r28, r8
	ctx.r[28].u64 = ctx.r[8].u64;
	// 828CF7C8: 48041351  bl 0x82910b18
	ctx.lr = 0x828CF7CC;
	sub_82910B18(ctx, base);
	// 828CF7CC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CF7D0: 3D008209  lis r8, -0x7df7
	ctx.r[8].s64 = -2113339392;
	// 828CF7D4: 396BE944  addi r11, r11, -0x16bc
	ctx.r[11].s64 = ctx.r[11].s64 + -5820;
	// 828CF7D8: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828CF7DC: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828CF7E0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CF7E4: 3968E928  addi r11, r8, -0x16d8
	ctx.r[11].s64 = ctx.r[8].s64 + -5848;
	// 828CF7E8: 394AE784  addi r10, r10, -0x187c
	ctx.r[10].s64 = ctx.r[10].s64 + -6268;
	// 828CF7EC: 3929E76C  addi r9, r9, -0x1894
	ctx.r[9].s64 = ctx.r[9].s64 + -6292;
	// 828CF7F0: 917F0218  stw r11, 0x218(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(536 as u32), ctx.r[11].u32 ) };
	// 828CF7F4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828CF7F8: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 828CF7FC: 913F0038  stw r9, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[9].u32 ) };
	// 828CF800: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CF804: 93DF0370  stw r30, 0x370(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(880 as u32), ctx.r[30].u32 ) };
	// 828CF808: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828CF80C: 93DF0374  stw r30, 0x374(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(884 as u32), ctx.r[30].u32 ) };
	// 828CF810: 388BEBE8  addi r4, r11, -0x1418
	ctx.r[4].s64 = ctx.r[11].s64 + -5144;
	// 828CF814: 93DF0378  stw r30, 0x378(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(888 as u32), ctx.r[30].u32 ) };
	// 828CF818: 57CB003E  slwi r11, r30, 0
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828CF81C: 93DF037C  stw r30, 0x37c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(892 as u32), ctx.r[30].u32 ) };
	// 828CF820: 38A00096  li r5, 0x96
	ctx.r[5].s64 = 150;
	// 828CF824: 93DF0380  stw r30, 0x380(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(896 as u32), ctx.r[30].u32 ) };
	// 828CF828: 556B077E  clrlwi r11, r11, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000007u64;
	// 828CF82C: 93DF0384  stw r30, 0x384(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(900 as u32), ctx.r[30].u32 ) };
	// 828CF830: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 828CF834: 93DF0388  stw r30, 0x388(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(904 as u32), ctx.r[30].u32 ) };
	// 828CF838: 93DF038C  stw r30, 0x38c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(908 as u32), ctx.r[30].u32 ) };
	// 828CF83C: 93DF038C  stw r30, 0x38c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(908 as u32), ctx.r[30].u32 ) };
	// 828CF840: 917F038C  stw r11, 0x38c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(908 as u32), ctx.r[11].u32 ) };
	// 828CF844: 93BF0390  stw r29, 0x390(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(912 as u32), ctx.r[29].u32 ) };
	// 828CF848: 939F0394  stw r28, 0x394(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(916 as u32), ctx.r[28].u32 ) };
	// 828CF84C: 93DF0398  stw r30, 0x398(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(920 as u32), ctx.r[30].u32 ) };
	// 828CF850: 4B9F0B89  bl 0x822c03d8
	ctx.lr = 0x828CF854;
	sub_822C03D8(ctx, base);
	// 828CF854: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828CF858: 4182000C  beq 0x828cf864
	if ctx.cr[0].eq {
	pc = 0x828CF864; continue 'dispatch;
	}
	// 828CF85C: 4BF7CD65  bl 0x8284c5c0
	ctx.lr = 0x828CF860;
	sub_8284C5C0(ctx, base);
	// 828CF860: 48000008  b 0x828cf868
	pc = 0x828CF868; continue 'dispatch;
	// 828CF864: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CF868: 907F0388  stw r3, 0x388(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(904 as u32), ctx.r[3].u32 ) };
	// 828CF86C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CF870: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828CF874: 488D8944  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CF878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CF878 size=76
    let mut pc: u32 = 0x828CF878;
    'dispatch: loop {
        match pc {
            0x828CF878 => {
    //   block [0x828CF878..0x828CF8C4)
	// 828CF878: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CF87C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CF880: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828CF884: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CF888: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CF88C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CF890: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828CF894: 4BFFF8A5  bl 0x828cf138
	ctx.lr = 0x828CF898;
	sub_828CF138(ctx, base);
	// 828CF898: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CF89C: 4182000C  beq 0x828cf8a8
	if ctx.cr[0].eq {
	pc = 0x828CF8A8; continue 'dispatch;
	}
	// 828CF8A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CF8A4: 48522B35  bl 0x82df23d8
	ctx.lr = 0x828CF8A8;
	sub_82DF23D8(ctx, base);
	// 828CF8A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CF8AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CF8B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CF8B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CF8B8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828CF8BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CF8C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CF8C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CF8C8 size=120
    let mut pc: u32 = 0x828CF8C8;
    'dispatch: loop {
        match pc {
            0x828CF8C8 => {
    //   block [0x828CF8C8..0x828CF940)
	// 828CF8C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CF8CC: 488D8899  bl 0x831a8164
	ctx.lr = 0x828CF8D0;
	sub_831A8130(ctx, base);
	// 828CF8D0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CF8D4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CF8D8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828CF8DC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828CF8E0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828CF8E4: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 828CF8E8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828CF8EC: 388BEBE8  addi r4, r11, -0x1418
	ctx.r[4].s64 = ctx.r[11].s64 + -5144;
	// 828CF8F0: 38A000B1  li r5, 0xb1
	ctx.r[5].s64 = 177;
	// 828CF8F4: 386003A0  li r3, 0x3a0
	ctx.r[3].s64 = 928;
	// 828CF8F8: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 828CF8FC: 48522AED  bl 0x82df23e8
	ctx.lr = 0x828CF900;
	sub_82DF23E8(ctx, base);
	// 828CF900: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828CF904: 41820024  beq 0x828cf928
	if ctx.cr[0].eq {
	pc = 0x828CF928; continue 'dispatch;
	}
	// 828CF908: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 828CF90C: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 828CF910: 38C0000C  li r6, 0xc
	ctx.r[6].s64 = 12;
	// 828CF914: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828CF918: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CF91C: 4BFFFE85  bl 0x828cf7a0
	ctx.lr = 0x828CF920;
	sub_828CF7A0(ctx, base);
	// 828CF920: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828CF924: 48000008  b 0x828cf92c
	pc = 0x828CF92C; continue 'dispatch;
	// 828CF928: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828CF92C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828CF930: 4BFFFD31  bl 0x828cf660
	ctx.lr = 0x828CF934;
	sub_828CF660(ctx, base);
	// 828CF934: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828CF938: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828CF93C: 488D8878  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CF940(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CF940 size=632
    let mut pc: u32 = 0x828CF940;
    'dispatch: loop {
        match pc {
            0x828CF940 => {
    //   block [0x828CF940..0x828CFBB8)
	// 828CF940: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CF944: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CF948: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CF94C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CF950: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CF954: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CF958: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828CF95C: 388BEC58  addi r4, r11, -0x13a8
	ctx.r[4].s64 = ctx.r[11].s64 + -5032;
	// 828CF960: 485240A9  bl 0x82df3a08
	ctx.lr = 0x828CF964;
	sub_82DF3A08(ctx, base);
	// 828CF964: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828CF968: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CF96C: 388BD3AC  addi r4, r11, -0x2c54
	ctx.r[4].s64 = ctx.r[11].s64 + -11348;
	// 828CF970: 48524099  bl 0x82df3a08
	ctx.lr = 0x828CF974;
	sub_82DF3A08(ctx, base);
	// 828CF974: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CF978: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 828CF97C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828CF980: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828CF984: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CF988: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 828CF98C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828CF990: 4E800421  bctrl
	ctx.lr = 0x828CF994;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CF994: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CF998: 48523A91  bl 0x82df3428
	ctx.lr = 0x828CF99C;
	sub_82DF3428(ctx, base);
	// 828CF99C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828CF9A0: 48523A89  bl 0x82df3428
	ctx.lr = 0x828CF9A4;
	sub_82DF3428(ctx, base);
	// 828CF9A4: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828CF9A8: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828CF9AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CF9B0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828CF9B4: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828CF9B8: 419A0024  beq cr6, 0x828cf9dc
	if ctx.cr[6].eq {
	pc = 0x828CF9DC; continue 'dispatch;
	}
	// 828CF9BC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828CF9C0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828CF9C4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828CF9C8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828CF9CC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828CF9D0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828CF9D4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828CF9D8: 4082FFE8  bne 0x828cf9c0
	if !ctx.cr[0].eq {
	pc = 0x828CF9C0; continue 'dispatch;
	}
	// 828CF9DC: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828CF9E0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828CF9E4: 386B1070  addi r3, r11, 0x1070
	ctx.r[3].s64 = ctx.r[11].s64 + 4208;
	// 828CF9E8: 48003849  bl 0x828d3230
	ctx.lr = 0x828CF9EC;
	sub_828D3230(ctx, base);
	// 828CF9EC: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828CF9F0: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828CF9F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CF9F8: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828CF9FC: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828CFA00: 419A0024  beq cr6, 0x828cfa24
	if ctx.cr[6].eq {
	pc = 0x828CFA24; continue 'dispatch;
	}
	// 828CFA04: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828CFA08: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828CFA0C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828CFA10: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828CFA14: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828CFA18: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828CFA1C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828CFA20: 4082FFE8  bne 0x828cfa08
	if !ctx.cr[0].eq {
	pc = 0x828CFA08; continue 'dispatch;
	}
	// 828CFA24: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828CFA28: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828CFA2C: 386B5868  addi r3, r11, 0x5868
	ctx.r[3].s64 = ctx.r[11].s64 + 22632;
	// 828CFA30: 48045691  bl 0x829150c0
	ctx.lr = 0x828CFA34;
	sub_829150C0(ctx, base);
	// 828CFA34: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828CFA38: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828CFA3C: 419A0008  beq cr6, 0x828cfa44
	if ctx.cr[6].eq {
	pc = 0x828CFA44; continue 'dispatch;
	}
	// 828CFA40: 4B9F0E51  bl 0x822c0890
	ctx.lr = 0x828CFA44;
	sub_822C0890(ctx, base);
	// 828CFA44: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 828CFA48: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CFA4C: 388B77B8  addi r4, r11, 0x77b8
	ctx.r[4].s64 = ctx.r[11].s64 + 30648;
	// 828CFA50: 48523FB9  bl 0x82df3a08
	ctx.lr = 0x828CFA54;
	sub_82DF3A08(ctx, base);
	// 828CFA54: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 828CFA58: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828CFA5C: 388BCBCC  addi r4, r11, -0x3434
	ctx.r[4].s64 = ctx.r[11].s64 + -13364;
	// 828CFA60: 48523FA9  bl 0x82df3a08
	ctx.lr = 0x828CFA64;
	sub_82DF3A08(ctx, base);
	// 828CFA64: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CFA68: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828CFA6C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828CFA70: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828CFA74: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CFA78: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 828CFA7C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828CFA80: 4E800421  bctrl
	ctx.lr = 0x828CFA84;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CFA84: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828CFA88: 485239A1  bl 0x82df3428
	ctx.lr = 0x828CFA8C;
	sub_82DF3428(ctx, base);
	// 828CFA8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CFA90: 48523999  bl 0x82df3428
	ctx.lr = 0x828CFA94;
	sub_82DF3428(ctx, base);
	// 828CFA94: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828CFA98: 81410068  lwz r10, 0x68(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 828CFA9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CFAA0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828CFAA4: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828CFAA8: 419A0024  beq cr6, 0x828cfacc
	if ctx.cr[6].eq {
	pc = 0x828CFACC; continue 'dispatch;
	}
	// 828CFAAC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828CFAB0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828CFAB4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828CFAB8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828CFABC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828CFAC0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828CFAC4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828CFAC8: 4082FFE8  bne 0x828cfab0
	if !ctx.cr[0].eq {
	pc = 0x828CFAB0; continue 'dispatch;
	}
	// 828CFACC: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828CFAD0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828CFAD4: 386B1110  addi r3, r11, 0x1110
	ctx.r[3].s64 = ctx.r[11].s64 + 4368;
	// 828CFAD8: 48003151  bl 0x828d2c28
	ctx.lr = 0x828CFADC;
	sub_828D2C28(ctx, base);
	// 828CFADC: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828CFAE0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828CFAE4: 419A0008  beq cr6, 0x828cfaec
	if ctx.cr[6].eq {
	pc = 0x828CFAEC; continue 'dispatch;
	}
	// 828CFAE8: 4B9F0DA9  bl 0x822c0890
	ctx.lr = 0x828CFAEC;
	sub_822C0890(ctx, base);
	// 828CFAEC: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 828CFAF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CFAF4: 388B77A4  addi r4, r11, 0x77a4
	ctx.r[4].s64 = ctx.r[11].s64 + 30628;
	// 828CFAF8: 48523F11  bl 0x82df3a08
	ctx.lr = 0x828CFAFC;
	sub_82DF3A08(ctx, base);
	// 828CFAFC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CFB00: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828CFB04: 388BEC4C  addi r4, r11, -0x13b4
	ctx.r[4].s64 = ctx.r[11].s64 + -5044;
	// 828CFB08: 48523F01  bl 0x82df3a08
	ctx.lr = 0x828CFB0C;
	sub_82DF3A08(ctx, base);
	// 828CFB0C: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CFB10: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828CFB14: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828CFB18: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828CFB1C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CFB20: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 828CFB24: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828CFB28: 4E800421  bctrl
	ctx.lr = 0x828CFB2C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CFB2C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828CFB30: 485238F9  bl 0x82df3428
	ctx.lr = 0x828CFB34;
	sub_82DF3428(ctx, base);
	// 828CFB34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CFB38: 485238F1  bl 0x82df3428
	ctx.lr = 0x828CFB3C;
	sub_82DF3428(ctx, base);
	// 828CFB3C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828CFB40: 81410070  lwz r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 828CFB44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CFB48: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828CFB4C: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828CFB50: 419A0024  beq cr6, 0x828cfb74
	if ctx.cr[6].eq {
	pc = 0x828CFB74; continue 'dispatch;
	}
	// 828CFB54: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828CFB58: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828CFB5C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828CFB60: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828CFB64: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828CFB68: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828CFB6C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828CFB70: 4082FFE8  bne 0x828cfb58
	if !ctx.cr[0].eq {
	pc = 0x828CFB58; continue 'dispatch;
	}
	// 828CFB74: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828CFB78: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828CFB7C: 386B1218  addi r3, r11, 0x1218
	ctx.r[3].s64 = ctx.r[11].s64 + 4632;
	// 828CFB80: 480030A9  bl 0x828d2c28
	ctx.lr = 0x828CFB84;
	sub_828D2C28(ctx, base);
	// 828CFB84: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828CFB88: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828CFB8C: 419A0008  beq cr6, 0x828cfb94
	if ctx.cr[6].eq {
	pc = 0x828CFB94; continue 'dispatch;
	}
	// 828CFB90: 4B9F0D01  bl 0x822c0890
	ctx.lr = 0x828CFB94;
	sub_822C0890(ctx, base);
	// 828CFB94: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CFB98: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828CFB9C: 419A0008  beq cr6, 0x828cfba4
	if ctx.cr[6].eq {
	pc = 0x828CFBA4; continue 'dispatch;
	}
	// 828CFBA0: 4B9F0CF1  bl 0x822c0890
	ctx.lr = 0x828CFBA4;
	sub_822C0890(ctx, base);
	// 828CFBA4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828CFBA8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CFBAC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CFBB0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CFBB4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CFBB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828CFBB8 size=276
    let mut pc: u32 = 0x828CFBB8;
    'dispatch: loop {
        match pc {
            0x828CFBB8 => {
    //   block [0x828CFBB8..0x828CFCCC)
	// 828CFBB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CFBBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CFBC0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CFBC4: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CFBC8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CFBCC: 4803915D  bl 0x82908d28
	ctx.lr = 0x828CFBD0;
	sub_82908D28(ctx, base);
	// 828CFBD0: 817FFFF0  lwz r11, -0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-16 as u32) ) } as u64;
	// 828CFBD4: 387FFFF0  addi r3, r31, -0x10
	ctx.r[3].s64 = ctx.r[31].s64 + -16;
	// 828CFBD8: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828CFBDC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828CFBE0: 4E800421  bctrl
	ctx.lr = 0x828CFBE4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CFBE4: 80830004  lwz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CFBE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CFBEC: 4803E965  bl 0x8290e550
	ctx.lr = 0x828CFBF0;
	sub_8290E550(ctx, base);
	// 828CFBF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CFBF4: 4804079D  bl 0x82910390
	ctx.lr = 0x828CFBF8;
	sub_82910390(ctx, base);
	// 828CFBF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CFBFC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828CFC00: 4BF1C671  bl 0x827ec270
	ctx.lr = 0x828CFC04;
	sub_827EC270(ctx, base);
	// 828CFC04: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828CFC08: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828CFC0C: 388BC604  addi r4, r11, -0x39fc
	ctx.r[4].s64 = ctx.r[11].s64 + -14844;
	// 828CFC10: 48523DF9  bl 0x82df3a08
	ctx.lr = 0x828CFC14;
	sub_82DF3A08(ctx, base);
	// 828CFC14: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828CFC18: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 828CFC1C: 388B1268  addi r4, r11, 0x1268
	ctx.r[4].s64 = ctx.r[11].s64 + 4712;
	// 828CFC20: 48523DE9  bl 0x82df3a08
	ctx.lr = 0x828CFC24;
	sub_82DF3A08(ctx, base);
	// 828CFC24: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828CFC28: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828CFC2C: 39200007  li r9, 7
	ctx.r[9].s64 = 7;
	// 828CFC30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CFC34: 91210068  stw r9, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[9].u32 ) };
	// 828CFC38: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828CFC3C: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828CFC40: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828CFC44: C02A08A8  lfs f1, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828CFC48: D0210084  stfs f1, 0x84(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 828CFC4C: D0210088  stfs f1, 0x88(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 828CFC50: D021008C  stfs f1, 0x8c(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 828CFC54: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 828CFC58: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 828CFC5C: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 828CFC60: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 828CFC64: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 828CFC68: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 828CFC6C: 4BF1C99D  bl 0x827ec608
	ctx.lr = 0x828CFC70;
	sub_827EC608(ctx, base);
	// 828CFC70: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828CFC74: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CFC78: 38AB9704  addi r5, r11, -0x68fc
	ctx.r[5].s64 = ctx.r[11].s64 + -26876;
	// 828CFC7C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CFC80: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CFC84: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 828CFC88: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828CFC8C: 4E800421  bctrl
	ctx.lr = 0x828CFC90;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CFC90: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828CFC94: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828CFC98: 419A0008  beq cr6, 0x828cfca0
	if ctx.cr[6].eq {
	pc = 0x828CFCA0; continue 'dispatch;
	}
	// 828CFC9C: 4B9F0BF5  bl 0x822c0890
	ctx.lr = 0x828CFCA0;
	sub_822C0890(ctx, base);
	// 828CFCA0: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 828CFCA4: 48523785  bl 0x82df3428
	ctx.lr = 0x828CFCA8;
	sub_82DF3428(ctx, base);
	// 828CFCA8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828CFCAC: 4852377D  bl 0x82df3428
	ctx.lr = 0x828CFCB0;
	sub_82DF3428(ctx, base);
	// 828CFCB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CFCB4: 4BC4091D  bl 0x825105d0
	ctx.lr = 0x828CFCB8;
	sub_825105D0(ctx, base);
	// 828CFCB8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828CFCBC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CFCC0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CFCC4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CFCC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CFCD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CFCD0 size=112
    let mut pc: u32 = 0x828CFCD0;
    'dispatch: loop {
        match pc {
            0x828CFCD0 => {
    //   block [0x828CFCD0..0x828CFD40)
	// 828CFCD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CFCD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CFCD8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CFCDC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CFCE0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CFCE4: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 828CFCE8: 419A0028  beq cr6, 0x828cfd10
	if ctx.cr[6].eq {
	pc = 0x828CFD10; continue 'dispatch;
	}
	// 828CFCEC: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 828CFCF0: 419A0014  beq cr6, 0x828cfd04
	if ctx.cr[6].eq {
	pc = 0x828CFD04; continue 'dispatch;
	}
	// 828CFCF4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CFCF8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CFCFC: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828CFD00: 4800002C  b 0x828cfd2c
	pc = 0x828CFD2C; continue 'dispatch;
	// 828CFD04: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828CFD08: 38AAEC7C  addi r5, r10, -0x1384
	ctx.r[5].s64 = ctx.r[10].s64 + -4996;
	// 828CFD0C: 4800000C  b 0x828cfd18
	pc = 0x828CFD18; continue 'dispatch;
	// 828CFD10: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828CFD14: 38AAEC68  addi r5, r10, -0x1398
	ctx.r[5].s64 = ctx.r[10].s64 + -5016;
	// 828CFD18: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CFD1C: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 828CFD20: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828CFD24: 4E800421  bctrl
	ctx.lr = 0x828CFD28;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CFD28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CFD2C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828CFD30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CFD34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CFD38: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CFD3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CFD40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CFD40 size=108
    let mut pc: u32 = 0x828CFD40;
    'dispatch: loop {
        match pc {
            0x828CFD40 => {
    //   block [0x828CFD40..0x828CFDAC)
	// 828CFD40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CFD44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CFD48: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CFD4C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CFD50: 7CE83B78  mr r8, r7
	ctx.r[8].u64 = ctx.r[7].u64;
	// 828CFD54: 7CC73378  mr r7, r6
	ctx.r[7].u64 = ctx.r[6].u64;
	// 828CFD58: 38C0000D  li r6, 0xd
	ctx.r[6].s64 = 13;
	// 828CFD5C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CFD60: 4BFFFA41  bl 0x828cf7a0
	ctx.lr = 0x828CFD64;
	sub_828CF7A0(ctx, base);
	// 828CFD64: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CFD68: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828CFD6C: 396BEB84  addi r11, r11, -0x147c
	ctx.r[11].s64 = ctx.r[11].s64 + -5244;
	// 828CFD70: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828CFD74: 3D008209  lis r8, -0x7df7
	ctx.r[8].s64 = -2113339392;
	// 828CFD78: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CFD7C: 394AE9DC  addi r10, r10, -0x1624
	ctx.r[10].s64 = ctx.r[10].s64 + -5668;
	// 828CFD80: 3929E9C8  addi r9, r9, -0x1638
	ctx.r[9].s64 = ctx.r[9].s64 + -5688;
	// 828CFD84: 3968E9AC  addi r11, r8, -0x1654
	ctx.r[11].s64 = ctx.r[8].s64 + -5716;
	// 828CFD88: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 828CFD8C: 913F0038  stw r9, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[9].u32 ) };
	// 828CFD90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CFD94: 917F0218  stw r11, 0x218(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(536 as u32), ctx.r[11].u32 ) };
	// 828CFD98: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828CFD9C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CFDA0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CFDA4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CFDA8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CFDB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CFDB0 size=124
    let mut pc: u32 = 0x828CFDB0;
    'dispatch: loop {
        match pc {
            0x828CFDB0 => {
    //   block [0x828CFDB0..0x828CFE2C)
	// 828CFDB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CFDB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CFDB8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828CFDBC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CFDC0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CFDC4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CFDC8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CFDCC: 3D008209  lis r8, -0x7df7
	ctx.r[8].s64 = -2113339392;
	// 828CFDD0: 396BEB84  addi r11, r11, -0x147c
	ctx.r[11].s64 = ctx.r[11].s64 + -5244;
	// 828CFDD4: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828CFDD8: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828CFDDC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CFDE0: 394AE9DC  addi r10, r10, -0x1624
	ctx.r[10].s64 = ctx.r[10].s64 + -5668;
	// 828CFDE4: 3929E9C8  addi r9, r9, -0x1638
	ctx.r[9].s64 = ctx.r[9].s64 + -5688;
	// 828CFDE8: 3968E9AC  addi r11, r8, -0x1654
	ctx.r[11].s64 = ctx.r[8].s64 + -5716;
	// 828CFDEC: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 828CFDF0: 913F0038  stw r9, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[9].u32 ) };
	// 828CFDF4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828CFDF8: 917F0218  stw r11, 0x218(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(536 as u32), ctx.r[11].u32 ) };
	// 828CFDFC: 4BFFF33D  bl 0x828cf138
	ctx.lr = 0x828CFE00;
	sub_828CF138(ctx, base);
	// 828CFE00: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CFE04: 4182000C  beq 0x828cfe10
	if ctx.cr[0].eq {
	pc = 0x828CFE10; continue 'dispatch;
	}
	// 828CFE08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CFE0C: 485225CD  bl 0x82df23d8
	ctx.lr = 0x828CFE10;
	sub_82DF23D8(ctx, base);
	// 828CFE10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CFE14: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CFE18: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CFE1C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CFE20: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828CFE24: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CFE28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CFE30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CFE30 size=116
    let mut pc: u32 = 0x828CFE30;
    'dispatch: loop {
        match pc {
            0x828CFE30 => {
    //   block [0x828CFE30..0x828CFEA4)
	// 828CFE30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CFE34: 488D8331  bl 0x831a8164
	ctx.lr = 0x828CFE38;
	sub_831A8130(ctx, base);
	// 828CFE38: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CFE3C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CFE40: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828CFE44: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828CFE48: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828CFE4C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 828CFE50: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828CFE54: 388BEBE8  addi r4, r11, -0x1418
	ctx.r[4].s64 = ctx.r[11].s64 + -5144;
	// 828CFE58: 38A00448  li r5, 0x448
	ctx.r[5].s64 = 1096;
	// 828CFE5C: 386003A0  li r3, 0x3a0
	ctx.r[3].s64 = 928;
	// 828CFE60: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 828CFE64: 48522585  bl 0x82df23e8
	ctx.lr = 0x828CFE68;
	sub_82DF23E8(ctx, base);
	// 828CFE68: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828CFE6C: 41820020  beq 0x828cfe8c
	if ctx.cr[0].eq {
	pc = 0x828CFE8C; continue 'dispatch;
	}
	// 828CFE70: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 828CFE74: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 828CFE78: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828CFE7C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CFE80: 4BFFFEC1  bl 0x828cfd40
	ctx.lr = 0x828CFE84;
	sub_828CFD40(ctx, base);
	// 828CFE84: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828CFE88: 48000008  b 0x828cfe90
	pc = 0x828CFE90; continue 'dispatch;
	// 828CFE8C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828CFE90: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828CFE94: 4BFFF825  bl 0x828cf6b8
	ctx.lr = 0x828CFE98;
	sub_828CF6B8(ctx, base);
	// 828CFE98: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828CFE9C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828CFEA0: 488D8314  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CFEA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CFEA8 size=112
    let mut pc: u32 = 0x828CFEA8;
    'dispatch: loop {
        match pc {
            0x828CFEA8 => {
    //   block [0x828CFEA8..0x828CFF18)
	// 828CFEA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CFEAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CFEB0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828CFEB4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CFEB8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CFEBC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828CFEC0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CFEC4: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828CFEC8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828CFECC: 4BFFF095  bl 0x828cef60
	ctx.lr = 0x828CFED0;
	sub_828CEF60(ctx, base);
	// 828CFED0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828CFED4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828CFED8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828CFEDC: 4B9F0125  bl 0x822c0000
	ctx.lr = 0x828CFEE0;
	sub_822C0000(ctx, base);
	// 828CFEE0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828CFEE4: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828CFEE8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CFEEC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CFEF0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828CFEF4: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828CFEF8: 419A0008  beq cr6, 0x828cff00
	if ctx.cr[6].eq {
	pc = 0x828CFF00; continue 'dispatch;
	}
	// 828CFEFC: 4B9F0995  bl 0x822c0890
	ctx.lr = 0x828CFF00;
	sub_822C0890(ctx, base);
	// 828CFF00: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CFF04: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CFF08: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CFF0C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828CFF10: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CFF14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CFF18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CFF18 size=112
    let mut pc: u32 = 0x828CFF18;
    'dispatch: loop {
        match pc {
            0x828CFF18 => {
    //   block [0x828CFF18..0x828CFF88)
	// 828CFF18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CFF1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CFF20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828CFF24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CFF28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CFF2C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828CFF30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CFF34: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828CFF38: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828CFF3C: 4BFFF0ED  bl 0x828cf028
	ctx.lr = 0x828CFF40;
	sub_828CF028(ctx, base);
	// 828CFF40: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828CFF44: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828CFF48: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828CFF4C: 4B9F00B5  bl 0x822c0000
	ctx.lr = 0x828CFF50;
	sub_822C0000(ctx, base);
	// 828CFF50: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828CFF54: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828CFF58: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CFF5C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CFF60: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828CFF64: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828CFF68: 419A0008  beq cr6, 0x828cff70
	if ctx.cr[6].eq {
	pc = 0x828CFF70; continue 'dispatch;
	}
	// 828CFF6C: 4B9F0925  bl 0x822c0890
	ctx.lr = 0x828CFF70;
	sub_822C0890(ctx, base);
	// 828CFF70: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CFF74: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CFF78: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CFF7C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828CFF80: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CFF84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CFF88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828CFF88 size=492
    let mut pc: u32 = 0x828CFF88;
    'dispatch: loop {
        match pc {
            0x828CFF88 => {
    //   block [0x828CFF88..0x828D0174)
	// 828CFF88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CFF8C: 488D81DD  bl 0x831a8168
	ctx.lr = 0x828CFF90;
	sub_831A8130(ctx, base);
	// 828CFF90: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CFF94: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828CFF98: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828CFF9C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828CFFA0: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828CFFA4: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 828CFFA8: 419A01C4  beq cr6, 0x828d016c
	if ctx.cr[6].eq {
	pc = 0x828D016C; continue 'dispatch;
	}
	// 828CFFAC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CFFB0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828CFFB4: 388BEBE8  addi r4, r11, -0x1418
	ctx.r[4].s64 = ctx.r[11].s64 + -5144;
	// 828CFFB8: 38A001E4  li r5, 0x1e4
	ctx.r[5].s64 = 484;
	// 828CFFBC: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828CFFC0: 4B9F0419  bl 0x822c03d8
	ctx.lr = 0x828CFFC4;
	sub_822C03D8(ctx, base);
	// 828CFFC4: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 828CFFC8: 41820034  beq 0x828cfffc
	if ctx.cr[0].eq {
	pc = 0x828CFFFC; continue 'dispatch;
	}
	// 828CFFCC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 828CFFD0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CFFD4: 388B1CAC  addi r4, r11, 0x1cac
	ctx.r[4].s64 = ctx.r[11].s64 + 7340;
	// 828CFFD8: 48523A31  bl 0x82df3a08
	ctx.lr = 0x828CFFDC;
	sub_82DF3A08(ctx, base);
	// 828CFFDC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828CFFE0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828CFFE4: 80BD0388  lwz r5, 0x388(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(904 as u32) ) } as u64;
	// 828CFFE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CFFEC: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 828CFFF0: 4BCDC421  bl 0x825ac410
	ctx.lr = 0x828CFFF4;
	sub_825AC410(ctx, base);
	// 828CFFF4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CFFF8: 48000008  b 0x828d0000
	pc = 0x828D0000; continue 'dispatch;
	// 828CFFFC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828D0000: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 828D0004: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D0008: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828D000C: 4BC233AD  bl 0x824f33b8
	ctx.lr = 0x828D0010;
	sub_824F33B8(ctx, base);
	// 828D0010: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D0014: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D0018: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828D001C: 4B9EFFE5  bl 0x822c0000
	ctx.lr = 0x828D0020;
	sub_822C0000(ctx, base);
	// 828D0020: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D0024: 4182000C  beq 0x828d0030
	if ctx.cr[0].eq {
	pc = 0x828D0030; continue 'dispatch;
	}
	// 828D0028: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D002C: 485233FD  bl 0x82df3428
	ctx.lr = 0x828D0030;
	sub_82DF3428(ctx, base);
	// 828D0030: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828D0034: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D0038: 388B12F8  addi r4, r11, 0x12f8
	ctx.r[4].s64 = ctx.r[11].s64 + 4856;
	// 828D003C: 485239CD  bl 0x82df3a08
	ctx.lr = 0x828D0040;
	sub_82DF3A08(ctx, base);
	// 828D0040: 83C10058  lwz r30, 0x58(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828D0044: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828D0048: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828D004C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D0050: 4BCDBD71  bl 0x825abdc0
	ctx.lr = 0x828D0054;
	sub_825ABDC0(ctx, base);
	// 828D0054: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D0058: 485233D1  bl 0x82df3428
	ctx.lr = 0x828D005C;
	sub_82DF3428(ctx, base);
	// 828D005C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828D0060: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D0064: 388B12D4  addi r4, r11, 0x12d4
	ctx.r[4].s64 = ctx.r[11].s64 + 4820;
	// 828D0068: 485239A1  bl 0x82df3a08
	ctx.lr = 0x828D006C;
	sub_82DF3A08(ctx, base);
	// 828D006C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828D0070: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828D0074: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D0078: 4BCDBD49  bl 0x825abdc0
	ctx.lr = 0x828D007C;
	sub_825ABDC0(ctx, base);
	// 828D007C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D0080: 485233A9  bl 0x82df3428
	ctx.lr = 0x828D0084;
	sub_82DF3428(ctx, base);
	// 828D0084: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 828D0088: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D008C: 388B4858  addi r4, r11, 0x4858
	ctx.r[4].s64 = ctx.r[11].s64 + 18520;
	// 828D0090: 48523979  bl 0x82df3a08
	ctx.lr = 0x828D0094;
	sub_82DF3A08(ctx, base);
	// 828D0094: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828D0098: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 828D009C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828D00A0: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 828D00A4: 419A0024  beq cr6, 0x828d00c8
	if ctx.cr[6].eq {
	pc = 0x828D00C8; continue 'dispatch;
	}
	// 828D00A8: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 828D00AC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828D00B0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D00B4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828D00B8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828D00BC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D00C0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D00C4: 4082FFE8  bne 0x828d00ac
	if !ctx.cr[0].eq {
	pc = 0x828D00AC; continue 'dispatch;
	}
	// 828D00C8: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828D00CC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D00D0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828D00D4: 4BCD203D  bl 0x825a2110
	ctx.lr = 0x828D00D8;
	sub_825A2110(ctx, base);
	// 828D00D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D00DC: 4852334D  bl 0x82df3428
	ctx.lr = 0x828D00E0;
	sub_82DF3428(ctx, base);
	// 828D00E0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D00E4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D00E8: 388BEC9C  addi r4, r11, -0x1364
	ctx.r[4].s64 = ctx.r[11].s64 + -4964;
	// 828D00EC: 4852391D  bl 0x82df3a08
	ctx.lr = 0x828D00F0;
	sub_82DF3A08(ctx, base);
	// 828D00F0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D00F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D00F8: 388BEC90  addi r4, r11, -0x1370
	ctx.r[4].s64 = ctx.r[11].s64 + -4976;
	// 828D00FC: 4852390D  bl 0x82df3a08
	ctx.lr = 0x828D0100;
	sub_82DF3A08(ctx, base);
	// 828D0100: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 828D0104: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 828D0108: 817D0388  lwz r11, 0x388(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(904 as u32) ) } as u64;
	// 828D010C: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 828D0110: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828D0114: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828D0118: 38AB0004  addi r5, r11, 4
	ctx.r[5].s64 = ctx.r[11].s64 + 4;
	// 828D011C: C06A9528  lfs f3, -0x6ad8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 828D0120: C04908A8  lfs f2, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 828D0124: C0289534  lfs f1, -0x6acc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828D0128: 4BCDD991  bl 0x825adab8
	ctx.lr = 0x828D012C;
	sub_825ADAB8(ctx, base);
	// 828D012C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828D0130: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D0134: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828D0138: 4BCD1519  bl 0x825a1650
	ctx.lr = 0x828D013C;
	sub_825A1650(ctx, base);
	// 828D013C: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 828D0140: 485232E9  bl 0x82df3428
	ctx.lr = 0x828D0144;
	sub_82DF3428(ctx, base);
	// 828D0144: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 828D0148: 4B9F8B71  bl 0x822c8cb8
	ctx.lr = 0x828D014C;
	sub_822C8CB8(ctx, base);
	// 828D014C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D0150: 485232D9  bl 0x82df3428
	ctx.lr = 0x828D0154;
	sub_82DF3428(ctx, base);
	// 828D0154: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D0158: 485232D1  bl 0x82df3428
	ctx.lr = 0x828D015C;
	sub_82DF3428(ctx, base);
	// 828D015C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828D0160: 419A000C  beq cr6, 0x828d016c
	if ctx.cr[6].eq {
	pc = 0x828D016C; continue 'dispatch;
	}
	// 828D0164: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D0168: 4B9F0729  bl 0x822c0890
	ctx.lr = 0x828D016C;
	sub_822C0890(ctx, base);
	// 828D016C: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 828D0170: 488D8048  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D0178(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828D0178 size=380
    let mut pc: u32 = 0x828D0178;
    'dispatch: loop {
        match pc {
            0x828D0178 => {
    //   block [0x828D0178..0x828D02F4)
	// 828D0178: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D017C: 488D7FDD  bl 0x831a8158
	ctx.lr = 0x828D0180;
	sub_831A8130(ctx, base);
	// 828D0180: DBE1FFB0  stfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 828D0184: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D0188: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D018C: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 828D0190: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D0194: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 828D0198: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D019C: 386BFF6C  addi r3, r11, -0x94
	ctx.r[3].s64 = ctx.r[11].s64 + -148;
	// 828D01A0: 409A0008  bne cr6, 0x828d01a8
	if !ctx.cr[6].eq {
	pc = 0x828D01A8; continue 'dispatch;
	}
	// 828D01A4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828D01A8: 4BC57EE1  bl 0x82528088
	ctx.lr = 0x828D01AC;
	sub_82528088(ctx, base);
	// 828D01AC: 3BDF0010  addi r30, r31, 0x10
	ctx.r[30].s64 = ctx.r[31].s64 + 16;
	// 828D01B0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828D01B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D01B8: 4BF1BFA9  bl 0x827ec160
	ctx.lr = 0x828D01BC;
	sub_827EC160(ctx, base);
	// 828D01BC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D01C0: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 828D01C4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D01C8: 4E800421  bctrl
	ctx.lr = 0x828D01CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D01CC: 3F808335  lis r28, -0x7ccb
	ctx.r[28].s64 = -2093678592;
	// 828D01D0: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828D01D4: C3E30000  lfs f31, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828D01D8: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 828D01DC: 3D008209  lis r8, -0x7df7
	ctx.r[8].s64 = -2113339392;
	// 828D01E0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D01E4: 817C6810  lwz r11, 0x6810(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(26640 as u32) ) } as u64;
	// 828D01E8: 3888EBE8  addi r4, r8, -0x1418
	ctx.r[4].s64 = ctx.r[8].s64 + -5144;
	// 828D01EC: C00AE6D4  lfs f0, -0x192c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-6444 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D01F0: 38A00358  li r5, 0x358
	ctx.r[5].s64 = 856;
	// 828D01F4: EDBF002A  fadds f13, f31, f0
	ctx.f[13].f64 = ((ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64;
	// 828D01F8: C00908A4  lfs f0, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D01FC: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828D0200: 38600200  li r3, 0x200
	ctx.r[3].s64 = 512;
	// 828D0204: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 828D0208: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 828D020C: 917F0258  stw r11, 0x258(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(600 as u32), ctx.r[11].u32 ) };
	// 828D0210: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 828D0214: 485221D5  bl 0x82df23e8
	ctx.lr = 0x828D0218;
	sub_82DF23E8(ctx, base);
	// 828D0218: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 828D021C: 41820080  beq 0x828d029c
	if ctx.cr[0].eq {
	pc = 0x828D029C; continue 'dispatch;
	}
	// 828D0220: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D0224: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 828D0228: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 828D022C: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 828D0230: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828D0234: 485D04FD  bl 0x82ea0730
	ctx.lr = 0x828D0238;
	sub_82EA0730(ctx, base);
	// 828D0238: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 828D023C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828D0240: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 828D0244: 48649FAD  bl 0x82f1a1f0
	ctx.lr = 0x828D0248;
	sub_82F1A1F0(ctx, base);
	// 828D0248: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 828D024C: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 828D0250: 839C6810  lwz r28, 0x6810(r28)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(26640 as u32) ) } as u64;
	// 828D0254: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828D0258: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D025C: 3BCBBA80  addi r30, r11, -0x4580
	ctx.r[30].s64 = ctx.r[11].s64 + -17792;
	// 828D0260: 3B400003  li r26, 3
	ctx.r[26].s64 = 3;
	// 828D0264: 3B210060  addi r25, r1, 0x60
	ctx.r[25].s64 = ctx.r[1].s64 + 96;
	// 828D0268: 3B010050  addi r24, r1, 0x50
	ctx.r[24].s64 = ctx.r[1].s64 + 80;
	// 828D026C: 4BC3F2AD  bl 0x8250f518
	ctx.lr = 0x828D0270;
	sub_8250F518(ctx, base);
	// 828D0270: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828D0274: 389F0038  addi r4, r31, 0x38
	ctx.r[4].s64 = ctx.r[31].s64 + 56;
	// 828D0278: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D027C: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 828D0280: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 828D0284: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 828D0288: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 828D028C: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 828D0290: 48217051  bl 0x82ae72e0
	ctx.lr = 0x828D0294;
	sub_82AE72E0(ctx, base);
	// 828D0294: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D0298: 48000008  b 0x828d02a0
	pc = 0x828D02A0; continue 'dispatch;
	// 828D029C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828D02A0: 3BFF01E4  addi r31, r31, 0x1e4
	ctx.r[31].s64 = ctx.r[31].s64 + 484;
	// 828D02A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D02A8: 4BAA3FB1  bl 0x82374258
	ctx.lr = 0x828D02AC;
	sub_82374258(ctx, base);
	// 828D02AC: 574B07BD  rlwinm. r11, r26, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D02B0: 41820010  beq 0x828d02c0
	if ctx.cr[0].eq {
	pc = 0x828D02C0; continue 'dispatch;
	}
	// 828D02B4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D02B8: 575A07FA  rlwinm r26, r26, 0, 0x1f, 0x1d
	ctx.r[26].u64 = ctx.r[26].u32 as u64 & 0xFFFFFFFFu64;
	// 828D02BC: 485219D5  bl 0x82df1c90
	ctx.lr = 0x828D02C0;
	sub_82DF1C90(ctx, base);
	// 828D02C0: 574B07FF  clrlwi. r11, r26, 0x1f
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D02C4: 41820014  beq 0x828d02d8
	if ctx.cr[0].eq {
	pc = 0x828D02D8; continue 'dispatch;
	}
	// 828D02C8: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828D02CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D02D0: 419A0008  beq cr6, 0x828d02d8
	if ctx.cr[6].eq {
	pc = 0x828D02D8; continue 'dispatch;
	}
	// 828D02D4: 4BA17F95  bl 0x822e8268
	ctx.lr = 0x828D02D8;
	sub_822E8268(ctx, base);
	// 828D02D8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D02DC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D02E0: C02BEE7C  lfs f1, -0x1184(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4484 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828D02E4: 4821306D  bl 0x82ae3350
	ctx.lr = 0x828D02E8;
	sub_82AE3350(ctx, base);
	// 828D02E8: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828D02EC: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 828D02F0: 488D7EB8  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D02F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828D02F8 size=740
    let mut pc: u32 = 0x828D02F8;
    'dispatch: loop {
        match pc {
            0x828D02F8 => {
    //   block [0x828D02F8..0x828D05DC)
	// 828D02F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D02FC: 488D7E69  bl 0x831a8164
	ctx.lr = 0x828D0300;
	sub_831A8130(ctx, base);
	// 828D0300: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 828D0304: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D0308: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828D030C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828D0310: 807B0370  lwz r3, 0x370(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(880 as u32) ) } as u64;
	// 828D0314: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D0318: 419A02B8  beq cr6, 0x828d05d0
	if ctx.cr[6].eq {
	pc = 0x828D05D0; continue 'dispatch;
	}
	// 828D031C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D0320: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 828D0324: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828D0328: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D032C: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 828D0330: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D0334: 4E800421  bctrl
	ctx.lr = 0x828D0338;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D0338: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D033C: 41820294  beq 0x828d05d0
	if ctx.cr[0].eq {
	pc = 0x828D05D0; continue 'dispatch;
	}
	// 828D0340: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D0344: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D0348: 808B0B2C  lwz r4, 0xb2c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2860 as u32) ) } as u64;
	// 828D034C: 485236BD  bl 0x82df3a08
	ctx.lr = 0x828D0350;
	sub_82DF3A08(ctx, base);
	// 828D0350: 3BDB010C  addi r30, r27, 0x10c
	ctx.r[30].s64 = ctx.r[27].s64 + 268;
	// 828D0354: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 828D0358: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D035C: 4858A375  bl 0x82e5a6d0
	ctx.lr = 0x828D0360;
	sub_82E5A6D0(ctx, base);
	// 828D0360: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D0364: 48522F3D  bl 0x82df32a0
	ctx.lr = 0x828D0368;
	sub_82DF32A0(ctx, base);
	// 828D0368: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D036C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D0370: 485230B9  bl 0x82df3428
	ctx.lr = 0x828D0374;
	sub_82DF3428(ctx, base);
	// 828D0374: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D0378: 41820258  beq 0x828d05d0
	if ctx.cr[0].eq {
	pc = 0x828D05D0; continue 'dispatch;
	}
	// 828D037C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D0380: 83FB0378  lwz r31, 0x378(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(888 as u32) ) } as u64;
	// 828D0384: 4858A34D  bl 0x82e5a6d0
	ctx.lr = 0x828D0388;
	sub_82E5A6D0(ctx, base);
	// 828D0388: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D038C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D0390: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828D0394: 48051CFD  bl 0x82922090
	ctx.lr = 0x828D0398;
	sub_82922090(ctx, base);
	// 828D0398: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 828D039C: 41820234  beq 0x828d05d0
	if ctx.cr[0].eq {
	pc = 0x828D05D0; continue 'dispatch;
	}
	// 828D03A0: 3BBB0010  addi r29, r27, 0x10
	ctx.r[29].s64 = ctx.r[27].s64 + 16;
	// 828D03A4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D03A8: 4BF1BDB9  bl 0x827ec160
	ctx.lr = 0x828D03AC;
	sub_827EC160(ctx, base);
	// 828D03AC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D03B0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D03B4: 480469E5  bl 0x82916d98
	ctx.lr = 0x828D03B8;
	sub_82916D98(ctx, base);
	// 828D03B8: 39600050  li r11, 0x50
	ctx.r[11].s64 = 80;
	// 828D03BC: 80E10060  lwz r7, 0x60(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828D03C0: 394000D0  li r10, 0xd0
	ctx.r[10].s64 = 208;
	// 828D03C4: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 828D03C8: 390000E0  li r8, 0xe0
	ctx.r[8].s64 = 224;
	// 828D03CC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D03D0: 13FC58C7  vcmpequd (lvx128) v31, v28, v11
	tmp.u32 = ctx.r[28].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828D03D4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D05E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828D05E0 size=420
    let mut pc: u32 = 0x828D05E0;
    'dispatch: loop {
        match pc {
            0x828D05E0 => {
    //   block [0x828D05E0..0x828D0784)
	// 828D05E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D05E4: 488D7B81  bl 0x831a8164
	ctx.lr = 0x828D05E8;
	sub_831A8130(ctx, base);
	// 828D05E8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D05EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D05F0: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828D05F4: 48039C4D  bl 0x8290a240
	ctx.lr = 0x828D05F8;
	sub_8290A240(ctx, base);
	// 828D05F8: 807F0360  lwz r3, 0x360(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(864 as u32) ) } as u64;
	// 828D05FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D0600: 419A017C  beq cr6, 0x828d077c
	if ctx.cr[6].eq {
	pc = 0x828D077C; continue 'dispatch;
	}
	// 828D0604: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D0608: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828D060C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828D0610: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828D0614: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D0618: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 828D061C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D0620: 4E800421  bctrl
	ctx.lr = 0x828D0624;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D0624: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D0628: 41820154  beq 0x828d077c
	if ctx.cr[0].eq {
	pc = 0x828D077C; continue 'dispatch;
	}
	// 828D062C: 817FFFF0  lwz r11, -0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-16 as u32) ) } as u64;
	// 828D0630: 387FFFF0  addi r3, r31, -0x10
	ctx.r[3].s64 = ctx.r[31].s64 + -16;
	// 828D0634: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D0638: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D063C: 4E800421  bctrl
	ctx.lr = 0x828D0640;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D0640: 897C001C  lbz r11, 0x1c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) } as u64;
	// 828D0644: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828D0648: 41820018  beq 0x828d0660
	if ctx.cr[0].eq {
	pc = 0x828D0660; continue 'dispatch;
	}
	// 828D064C: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 828D0650: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 828D0654: 13FC58C7  vcmpequd (lvx128) v31, v28, v11
	tmp.u32 = ctx.r[28].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D0788(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828D0788 size=272
    let mut pc: u32 = 0x828D0788;
    'dispatch: loop {
        match pc {
            0x828D0788 => {
    //   block [0x828D0788..0x828D0898)
	// 828D0788: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D078C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D0790: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828D0794: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D0798: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D079C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D07A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D07A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D07A8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828D07AC: 808B0B88  lwz r4, 0xb88(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2952 as u32) ) } as u64;
	// 828D07B0: 48523259  bl 0x82df3a08
	ctx.lr = 0x828D07B4;
	sub_82DF3A08(ctx, base);
	// 828D07B4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828D07B8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828D07BC: 389F010C  addi r4, r31, 0x10c
	ctx.r[4].s64 = ctx.r[31].s64 + 268;
	// 828D07C0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D07C4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D07C8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828D07CC: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828D07D0: 4858E191  bl 0x82e5e960
	ctx.lr = 0x828D07D4;
	sub_82E5E960(ctx, base);
	// 828D07D4: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828D07D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D07DC: 419A0008  beq cr6, 0x828d07e4
	if ctx.cr[6].eq {
	pc = 0x828D07E4; continue 'dispatch;
	}
	// 828D07E0: 4B9F00B1  bl 0x822c0890
	ctx.lr = 0x828D07E4;
	sub_822C0890(ctx, base);
	// 828D07E4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D07E8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D07EC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828D07F0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828D07F4: 4BF97CC5  bl 0x828684b8
	ctx.lr = 0x828D07F8;
	sub_828684B8(ctx, base);
	// 828D07F8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D07FC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828D0800: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D0804: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D0808: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828D080C: 419A0024  beq cr6, 0x828d0830
	if ctx.cr[6].eq {
	pc = 0x828D0830; continue 'dispatch;
	}
	// 828D0810: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828D0814: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828D0818: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D081C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828D0820: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828D0824: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D0828: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D082C: 4082FFE8  bne 0x828d0814
	if !ctx.cr[0].eq {
	pc = 0x828D0814; continue 'dispatch;
	}
	// 828D0830: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D0834: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 828D0838: 487378F1  bl 0x83008128
	ctx.lr = 0x828D083C;
	sub_83008128(ctx, base);
	// 828D083C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D0840: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828D0844: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828D0848: 388AEBE8  addi r4, r10, -0x1418
	ctx.r[4].s64 = ctx.r[10].s64 + -5144;
	// 828D084C: 38A003F8  li r5, 0x3f8
	ctx.r[5].s64 = 1016;
	// 828D0850: 387F0038  addi r3, r31, 0x38
	ctx.r[3].s64 = ctx.r[31].s64 + 56;
	// 828D0854: C02BE6E0  lfs f1, -0x1920(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6432 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828D0858: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 828D085C: 485881E5  bl 0x82e58a40
	ctx.lr = 0x828D0860;
	sub_82E58A40(ctx, base);
	// 828D0860: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828D0864: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D0868: 419A0008  beq cr6, 0x828d0870
	if ctx.cr[6].eq {
	pc = 0x828D0870; continue 'dispatch;
	}
	// 828D086C: 4B9F0025  bl 0x822c0890
	ctx.lr = 0x828D0870;
	sub_822C0890(ctx, base);
	// 828D0870: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828D0874: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D0878: 419A0008  beq cr6, 0x828d0880
	if ctx.cr[6].eq {
	pc = 0x828D0880; continue 'dispatch;
	}
	// 828D087C: 4B9F0015  bl 0x822c0890
	ctx.lr = 0x828D0880;
	sub_822C0890(ctx, base);
	// 828D0880: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828D0884: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D0888: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D088C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828D0890: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D0894: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D0898(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D0898 size=128
    let mut pc: u32 = 0x828D0898;
    'dispatch: loop {
        match pc {
            0x828D0898 => {
    //   block [0x828D0898..0x828D0918)
	// 828D0898: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D089C: 488D78D1  bl 0x831a816c
	ctx.lr = 0x828D08A0;
	sub_831A8130(ctx, base);
	// 828D08A0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D08A4: 3D408337  lis r10, -0x7cc9
	ctx.r[10].s64 = -2093547520;
	// 828D08A8: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828D08AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D08B0: 3BEB1038  addi r31, r11, 0x1038
	ctx.r[31].s64 = ctx.r[11].s64 + 4152;
	// 828D08B4: 816A1040  lwz r11, 0x1040(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4160 as u32) ) } as u64;
	// 828D08B8: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828D08BC: 40820024  bne 0x828d08e0
	if !ctx.cr[0].eq {
	pc = 0x828D08E0; continue 'dispatch;
	}
	// 828D08C0: 3D208236  lis r9, -0x7dca
	ctx.r[9].s64 = -2110390272;
	// 828D08C4: 3D00828D  lis r8, -0x7d73
	ctx.r[8].s64 = -2104688640;
	// 828D08C8: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828D08CC: 3929A778  addi r9, r9, -0x5888
	ctx.r[9].s64 = ctx.r[9].s64 + -22664;
	// 828D08D0: 3908F0F0  addi r8, r8, -0xf10
	ctx.r[8].s64 = ctx.r[8].s64 + -3856;
	// 828D08D4: 916A1040  stw r11, 0x1040(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4160 as u32), ctx.r[11].u32 ) };
	// 828D08D8: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828D08DC: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828D08E0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828D08E4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828D08E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D08EC: 38BE0008  addi r5, r30, 8
	ctx.r[5].s64 = ctx.r[30].s64 + 8;
	// 828D08F0: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 828D08F4: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828D08F8: 4BFF6FE1  bl 0x828c78d8
	ctx.lr = 0x828D08FC;
	sub_828C78D8(ctx, base);
	// 828D08FC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D0900: 4182000C  beq 0x828d090c
	if ctx.cr[0].eq {
	pc = 0x828D090C; continue 'dispatch;
	}
	// 828D0904: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828D0908: 48000008  b 0x828d0910
	pc = 0x828D0910; continue 'dispatch;
	// 828D090C: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828D0910: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828D0914: 488D78A8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D0918(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828D0918 size=488
    let mut pc: u32 = 0x828D0918;
    'dispatch: loop {
        match pc {
            0x828D0918 => {
    //   block [0x828D0918..0x828D0B00)
	// 828D0918: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D091C: 488D7845  bl 0x831a8160
	ctx.lr = 0x828D0920;
	sub_831A8130(ctx, base);
	// 828D0920: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D0924: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D0928: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 828D092C: 3BABEBE8  addi r29, r11, -0x1418
	ctx.r[29].s64 = ctx.r[11].s64 + -5144;
	// 828D0930: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D0934: 38A000A6  li r5, 0xa6
	ctx.r[5].s64 = 166;
	// 828D0938: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828D093C: 386003A0  li r3, 0x3a0
	ctx.r[3].s64 = 928;
	// 828D0940: 48521AA9  bl 0x82df23e8
	ctx.lr = 0x828D0944;
	sub_82DF23E8(ctx, base);
	// 828D0944: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 828D0948: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828D094C: 3B8BBA80  addi r28, r11, -0x4580
	ctx.r[28].s64 = ctx.r[11].s64 + -17792;
	// 828D0950: 41820028  beq 0x828d0978
	if ctx.cr[0].eq {
	pc = 0x828D0978; continue 'dispatch;
	}
	// 828D0954: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828D0958: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828D095C: 388B6910  addi r4, r11, 0x6910
	ctx.r[4].s64 = ctx.r[11].s64 + 26896;
	// 828D0960: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828D0964: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828D0968: 38C0000C  li r6, 0xc
	ctx.r[6].s64 = 12;
	// 828D096C: 4BFFEE35  bl 0x828cf7a0
	ctx.lr = 0x828D0970;
	sub_828CF7A0(ctx, base);
	// 828D0970: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D0974: 48000008  b 0x828d097c
	pc = 0x828D097C; continue 'dispatch;
	// 828D0978: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828D097C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828D0980: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D0984: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D0988: 4BFFE449  bl 0x828cedd0
	ctx.lr = 0x828D098C;
	sub_828CEDD0(ctx, base);
	// 828D098C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D0990: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D0994: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D0998: 4B9EF669  bl 0x822c0000
	ctx.lr = 0x828D099C;
	sub_822C0000(ctx, base);
	// 828D099C: 83610054  lwz r27, 0x54(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828D09A0: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828D09A4: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 828D09A8: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 828D09AC: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828D09B0: 419A0024  beq cr6, 0x828d09d4
	if ctx.cr[6].eq {
	pc = 0x828D09D4; continue 'dispatch;
	}
	// 828D09B4: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 828D09B8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828D09BC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D09C0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828D09C4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828D09C8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D09CC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D09D0: 4082FFE8  bne 0x828d09b8
	if !ctx.cr[0].eq {
	pc = 0x828D09B8; continue 'dispatch;
	}
	// 828D09D4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828D09D8: 397E0010  addi r11, r30, 0x10
	ctx.r[11].s64 = ctx.r[30].s64 + 16;
	// 828D09DC: 409A0008  bne cr6, 0x828d09e4
	if !ctx.cr[6].eq {
	pc = 0x828D09E4; continue 'dispatch;
	}
	// 828D09E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D09E4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828D09E8: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 828D09EC: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 828D09F0: 419A0024  beq cr6, 0x828d0a14
	if ctx.cr[6].eq {
	pc = 0x828D0A14; continue 'dispatch;
	}
	// 828D09F4: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 828D09F8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828D09FC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D0A00: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828D0A04: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828D0A08: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D0A0C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D0A10: 4082FFE8  bne 0x828d09f8
	if !ctx.cr[0].eq {
	pc = 0x828D09F8; continue 'dispatch;
	}
	// 828D0A14: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828D0A18: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 828D0A1C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828D0A20: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828D0A24: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828D0A28: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D0A2C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828D0A30: 4BEC8501  bl 0x82798f30
	ctx.lr = 0x828D0A34;
	sub_82798F30(ctx, base);
	// 828D0A34: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828D0A38: 3BFE0010  addi r31, r30, 0x10
	ctx.r[31].s64 = ctx.r[30].s64 + 16;
	// 828D0A3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D0A40: 816B0150  lwz r11, 0x150(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(336 as u32) ) } as u64;
	// 828D0A44: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D0A48: 4E800421  bctrl
	ctx.lr = 0x828D0A4C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D0A4C: C0030010  lfs f0, 0x10(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D0A50: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 828D0A54: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828D0A58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D0A5C: 816B0150  lwz r11, 0x150(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(336 as u32) ) } as u64;
	// 828D0A60: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D0A64: 4E800421  bctrl
	ctx.lr = 0x828D0A68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D0A68: C0030014  lfs f0, 0x14(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D0A6C: D0010094  stfs f0, 0x94(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 828D0A70: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828D0A74: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D0A78: 38A000AB  li r5, 0xab
	ctx.r[5].s64 = 171;
	// 828D0A7C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828D0A80: 4B9EF959  bl 0x822c03d8
	ctx.lr = 0x828D0A84;
	sub_822C03D8(ctx, base);
	// 828D0A84: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828D0A88: 41820014  beq 0x828d0a9c
	if ctx.cr[0].eq {
	pc = 0x828D0A9C; continue 'dispatch;
	}
	// 828D0A8C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828D0A90: 4BECABD9  bl 0x8279b668
	ctx.lr = 0x828D0A94;
	sub_8279B668(ctx, base);
	// 828D0A94: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D0A98: 48000008  b 0x828d0aa0
	pc = 0x828D0AA0; continue 'dispatch;
	// 828D0A9C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828D0AA0: 93FA0000  stw r31, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828D0AA4: 3BDA0004  addi r30, r26, 4
	ctx.r[30].s64 = ctx.r[26].s64 + 4;
	// 828D0AA8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D0AAC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D0AB0: 4BCC71A1  bl 0x82597c50
	ctx.lr = 0x828D0AB4;
	sub_82597C50(ctx, base);
	// 828D0AB4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D0AB8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D0ABC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D0AC0: 4B9EF541  bl 0x822c0000
	ctx.lr = 0x828D0AC4;
	sub_822C0000(ctx, base);
	// 828D0AC4: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828D0AC8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D0ACC: 419A0008  beq cr6, 0x828d0ad4
	if ctx.cr[6].eq {
	pc = 0x828D0AD4; continue 'dispatch;
	}
	// 828D0AD0: 4B9EFDC1  bl 0x822c0890
	ctx.lr = 0x828D0AD4;
	sub_822C0890(ctx, base);
	// 828D0AD4: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828D0AD8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D0ADC: 419A0008  beq cr6, 0x828d0ae4
	if ctx.cr[6].eq {
	pc = 0x828D0AE4; continue 'dispatch;
	}
	// 828D0AE0: 4B9EFDB1  bl 0x822c0890
	ctx.lr = 0x828D0AE4;
	sub_822C0890(ctx, base);
	// 828D0AE4: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 828D0AE8: 419A000C  beq cr6, 0x828d0af4
	if ctx.cr[6].eq {
	pc = 0x828D0AF4; continue 'dispatch;
	}
	// 828D0AEC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828D0AF0: 4B9EFDA1  bl 0x822c0890
	ctx.lr = 0x828D0AF4;
	sub_822C0890(ctx, base);
	// 828D0AF4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828D0AF8: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 828D0AFC: 488D76B4  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D0B00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828D0B00 size=484
    let mut pc: u32 = 0x828D0B00;
    'dispatch: loop {
        match pc {
            0x828D0B00 => {
    //   block [0x828D0B00..0x828D0CE4)
	// 828D0B00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D0B04: 488D765D  bl 0x831a8160
	ctx.lr = 0x828D0B08;
	sub_831A8130(ctx, base);
	// 828D0B08: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D0B0C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D0B10: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 828D0B14: 3BABEBE8  addi r29, r11, -0x1418
	ctx.r[29].s64 = ctx.r[11].s64 + -5144;
	// 828D0B18: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D0B1C: 38A0043D  li r5, 0x43d
	ctx.r[5].s64 = 1085;
	// 828D0B20: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828D0B24: 386003A0  li r3, 0x3a0
	ctx.r[3].s64 = 928;
	// 828D0B28: 485218C1  bl 0x82df23e8
	ctx.lr = 0x828D0B2C;
	sub_82DF23E8(ctx, base);
	// 828D0B2C: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 828D0B30: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828D0B34: 3B8BBA80  addi r28, r11, -0x4580
	ctx.r[28].s64 = ctx.r[11].s64 + -17792;
	// 828D0B38: 41820024  beq 0x828d0b5c
	if ctx.cr[0].eq {
	pc = 0x828D0B5C; continue 'dispatch;
	}
	// 828D0B3C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828D0B40: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828D0B44: 388B6910  addi r4, r11, 0x6910
	ctx.r[4].s64 = ctx.r[11].s64 + 26896;
	// 828D0B48: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828D0B4C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D0B50: 4BFFF1F1  bl 0x828cfd40
	ctx.lr = 0x828D0B54;
	sub_828CFD40(ctx, base);
	// 828D0B54: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D0B58: 48000008  b 0x828d0b60
	pc = 0x828D0B60; continue 'dispatch;
	// 828D0B5C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828D0B60: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828D0B64: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D0B68: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D0B6C: 4BFFE32D  bl 0x828cee98
	ctx.lr = 0x828D0B70;
	sub_828CEE98(ctx, base);
	// 828D0B70: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D0B74: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D0B78: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D0B7C: 4B9EF485  bl 0x822c0000
	ctx.lr = 0x828D0B80;
	sub_822C0000(ctx, base);
	// 828D0B80: 83610054  lwz r27, 0x54(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828D0B84: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828D0B88: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 828D0B8C: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 828D0B90: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828D0B94: 419A0024  beq cr6, 0x828d0bb8
	if ctx.cr[6].eq {
	pc = 0x828D0BB8; continue 'dispatch;
	}
	// 828D0B98: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 828D0B9C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828D0BA0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D0BA4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828D0BA8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828D0BAC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D0BB0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D0BB4: 4082FFE8  bne 0x828d0b9c
	if !ctx.cr[0].eq {
	pc = 0x828D0B9C; continue 'dispatch;
	}
	// 828D0BB8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828D0BBC: 397E0010  addi r11, r30, 0x10
	ctx.r[11].s64 = ctx.r[30].s64 + 16;
	// 828D0BC0: 409A0008  bne cr6, 0x828d0bc8
	if !ctx.cr[6].eq {
	pc = 0x828D0BC8; continue 'dispatch;
	}
	// 828D0BC4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D0BC8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828D0BCC: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 828D0BD0: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 828D0BD4: 419A0024  beq cr6, 0x828d0bf8
	if ctx.cr[6].eq {
	pc = 0x828D0BF8; continue 'dispatch;
	}
	// 828D0BD8: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 828D0BDC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828D0BE0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D0BE4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828D0BE8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828D0BEC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D0BF0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D0BF4: 4082FFE8  bne 0x828d0bdc
	if !ctx.cr[0].eq {
	pc = 0x828D0BDC; continue 'dispatch;
	}
	// 828D0BF8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828D0BFC: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 828D0C00: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828D0C04: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828D0C08: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828D0C0C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D0C10: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828D0C14: 4BEC831D  bl 0x82798f30
	ctx.lr = 0x828D0C18;
	sub_82798F30(ctx, base);
	// 828D0C18: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828D0C1C: 3BFE0010  addi r31, r30, 0x10
	ctx.r[31].s64 = ctx.r[30].s64 + 16;
	// 828D0C20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D0C24: 816B0150  lwz r11, 0x150(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(336 as u32) ) } as u64;
	// 828D0C28: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D0C2C: 4E800421  bctrl
	ctx.lr = 0x828D0C30;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D0C30: C0030010  lfs f0, 0x10(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D0C34: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 828D0C38: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828D0C3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D0C40: 816B0150  lwz r11, 0x150(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(336 as u32) ) } as u64;
	// 828D0C44: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D0C48: 4E800421  bctrl
	ctx.lr = 0x828D0C4C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D0C4C: C0030014  lfs f0, 0x14(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D0C50: D0010094  stfs f0, 0x94(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 828D0C54: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828D0C58: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D0C5C: 38A00442  li r5, 0x442
	ctx.r[5].s64 = 1090;
	// 828D0C60: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828D0C64: 4B9EF775  bl 0x822c03d8
	ctx.lr = 0x828D0C68;
	sub_822C03D8(ctx, base);
	// 828D0C68: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828D0C6C: 41820014  beq 0x828d0c80
	if ctx.cr[0].eq {
	pc = 0x828D0C80; continue 'dispatch;
	}
	// 828D0C70: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828D0C74: 4BECA9F5  bl 0x8279b668
	ctx.lr = 0x828D0C78;
	sub_8279B668(ctx, base);
	// 828D0C78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D0C7C: 48000008  b 0x828d0c84
	pc = 0x828D0C84; continue 'dispatch;
	// 828D0C80: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828D0C84: 93FA0000  stw r31, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828D0C88: 3BDA0004  addi r30, r26, 4
	ctx.r[30].s64 = ctx.r[26].s64 + 4;
	// 828D0C8C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D0C90: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D0C94: 4BCC6FBD  bl 0x82597c50
	ctx.lr = 0x828D0C98;
	sub_82597C50(ctx, base);
	// 828D0C98: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D0C9C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D0CA0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D0CA4: 4B9EF35D  bl 0x822c0000
	ctx.lr = 0x828D0CA8;
	sub_822C0000(ctx, base);
	// 828D0CA8: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828D0CAC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D0CB0: 419A0008  beq cr6, 0x828d0cb8
	if ctx.cr[6].eq {
	pc = 0x828D0CB8; continue 'dispatch;
	}
	// 828D0CB4: 4B9EFBDD  bl 0x822c0890
	ctx.lr = 0x828D0CB8;
	sub_822C0890(ctx, base);
	// 828D0CB8: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828D0CBC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D0CC0: 419A0008  beq cr6, 0x828d0cc8
	if ctx.cr[6].eq {
	pc = 0x828D0CC8; continue 'dispatch;
	}
	// 828D0CC4: 4B9EFBCD  bl 0x822c0890
	ctx.lr = 0x828D0CC8;
	sub_822C0890(ctx, base);
	// 828D0CC8: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 828D0CCC: 419A000C  beq cr6, 0x828d0cd8
	if ctx.cr[6].eq {
	pc = 0x828D0CD8; continue 'dispatch;
	}
	// 828D0CD0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828D0CD4: 4B9EFBBD  bl 0x822c0890
	ctx.lr = 0x828D0CD8;
	sub_822C0890(ctx, base);
	// 828D0CD8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828D0CDC: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 828D0CE0: 488D74D0  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D0CE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D0CE8 size=128
    let mut pc: u32 = 0x828D0CE8;
    'dispatch: loop {
        match pc {
            0x828D0CE8 => {
    //   block [0x828D0CE8..0x828D0D68)
	// 828D0CE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D0CEC: 488D7481  bl 0x831a816c
	ctx.lr = 0x828D0CF0;
	sub_831A8130(ctx, base);
	// 828D0CF0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D0CF4: 3D408337  lis r10, -0x7cc9
	ctx.r[10].s64 = -2093547520;
	// 828D0CF8: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828D0CFC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D0D00: 3BEB1044  addi r31, r11, 0x1044
	ctx.r[31].s64 = ctx.r[11].s64 + 4164;
	// 828D0D04: 816A104C  lwz r11, 0x104c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4172 as u32) ) } as u64;
	// 828D0D08: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828D0D0C: 40820024  bne 0x828d0d30
	if !ctx.cr[0].eq {
	pc = 0x828D0D30; continue 'dispatch;
	}
	// 828D0D10: 3D208290  lis r9, -0x7d70
	ctx.r[9].s64 = -2104492032;
	// 828D0D14: 3D00828D  lis r8, -0x7d73
	ctx.r[8].s64 = -2104688640;
	// 828D0D18: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828D0D1C: 3929DD90  addi r9, r9, -0x2270
	ctx.r[9].s64 = ctx.r[9].s64 + -8816;
	// 828D0D20: 3908F758  addi r8, r8, -0x8a8
	ctx.r[8].s64 = ctx.r[8].s64 + -2216;
	// 828D0D24: 916A104C  stw r11, 0x104c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4172 as u32), ctx.r[11].u32 ) };
	// 828D0D28: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828D0D2C: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828D0D30: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828D0D34: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828D0D38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D0D3C: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 828D0D40: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 828D0D44: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828D0D48: 4BD83879  bl 0x826545c0
	ctx.lr = 0x828D0D4C;
	sub_826545C0(ctx, base);
	// 828D0D4C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D0D50: 4182000C  beq 0x828d0d5c
	if ctx.cr[0].eq {
	pc = 0x828D0D5C; continue 'dispatch;
	}
	// 828D0D54: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828D0D58: 48000008  b 0x828d0d60
	pc = 0x828D0D60; continue 'dispatch;
	// 828D0D5C: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828D0D60: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828D0D64: 488D7458  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D0D68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D0D68 size=128
    let mut pc: u32 = 0x828D0D68;
    'dispatch: loop {
        match pc {
            0x828D0D68 => {
    //   block [0x828D0D68..0x828D0DE8)
	// 828D0D68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D0D6C: 488D7401  bl 0x831a816c
	ctx.lr = 0x828D0D70;
	sub_831A8130(ctx, base);
	// 828D0D70: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D0D74: 3D408337  lis r10, -0x7cc9
	ctx.r[10].s64 = -2093547520;
	// 828D0D78: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828D0D7C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D0D80: 3BEB1050  addi r31, r11, 0x1050
	ctx.r[31].s64 = ctx.r[11].s64 + 4176;
	// 828D0D84: 816A1058  lwz r11, 0x1058(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4184 as u32) ) } as u64;
	// 828D0D88: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828D0D8C: 40820024  bne 0x828d0db0
	if !ctx.cr[0].eq {
	pc = 0x828D0DB0; continue 'dispatch;
	}
	// 828D0D90: 3D20828F  lis r9, -0x7d71
	ctx.r[9].s64 = -2104557568;
	// 828D0D94: 3D00828D  lis r8, -0x7d73
	ctx.r[8].s64 = -2104688640;
	// 828D0D98: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828D0D9C: 39294708  addi r9, r9, 0x4708
	ctx.r[9].s64 = ctx.r[9].s64 + 18184;
	// 828D0DA0: 3908F710  addi r8, r8, -0x8f0
	ctx.r[8].s64 = ctx.r[8].s64 + -2288;
	// 828D0DA4: 916A1058  stw r11, 0x1058(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4184 as u32), ctx.r[11].u32 ) };
	// 828D0DA8: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828D0DAC: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828D0DB0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828D0DB4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828D0DB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D0DBC: 38FE0008  addi r7, r30, 8
	ctx.r[7].s64 = ctx.r[30].s64 + 8;
	// 828D0DC0: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 828D0DC4: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828D0DC8: 48012C09  bl 0x828e39d0
	ctx.lr = 0x828D0DCC;
	sub_828E39D0(ctx, base);
	// 828D0DCC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D0DD0: 4182000C  beq 0x828d0ddc
	if ctx.cr[0].eq {
	pc = 0x828D0DDC; continue 'dispatch;
	}
	// 828D0DD4: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828D0DD8: 48000008  b 0x828d0de0
	pc = 0x828D0DE0; continue 'dispatch;
	// 828D0DDC: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828D0DE0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828D0DE4: 488D73D8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D0DE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828D0DE8 size=240
    let mut pc: u32 = 0x828D0DE8;
    'dispatch: loop {
        match pc {
            0x828D0DE8 => {
    //   block [0x828D0DE8..0x828D0ED8)
	// 828D0DE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D0DEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D0DF0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828D0DF4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D0DF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D0DFC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D0E00: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828D0E04: 2F050005  cmpwi cr6, r5, 5
	ctx.cr[6].compare_i32(ctx.r[5].s32, 5, &mut ctx.xer);
	// 828D0E08: 419A0094  beq cr6, 0x828d0e9c
	if ctx.cr[6].eq {
	pc = 0x828D0E9C; continue 'dispatch;
	}
	// 828D0E0C: 2F050006  cmpwi cr6, r5, 6
	ctx.cr[6].compare_i32(ctx.r[5].s32, 6, &mut ctx.xer);
	// 828D0E10: 419A0044  beq cr6, 0x828d0e54
	if ctx.cr[6].eq {
	pc = 0x828D0E54; continue 'dispatch;
	}
	// 828D0E14: 2F050007  cmpwi cr6, r5, 7
	ctx.cr[6].compare_i32(ctx.r[5].s32, 7, &mut ctx.xer);
	// 828D0E18: 419A0030  beq cr6, 0x828d0e48
	if ctx.cr[6].eq {
	pc = 0x828D0E48; continue 'dispatch;
	}
	// 828D0E1C: 2F050008  cmpwi cr6, r5, 8
	ctx.cr[6].compare_i32(ctx.r[5].s32, 8, &mut ctx.xer);
	// 828D0E20: 409A006C  bne cr6, 0x828d0e8c
	if !ctx.cr[6].eq {
	pc = 0x828D0E8C; continue 'dispatch;
	}
	// 828D0E24: 817F037C  lwz r11, 0x37c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(892 as u32) ) } as u64;
	// 828D0E28: 556BF7FF  rlwinm. r11, r11, 0x1e, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D0E2C: 40820060  bne 0x828d0e8c
	if !ctx.cr[0].eq {
	pc = 0x828D0E8C; continue 'dispatch;
	}
	// 828D0E30: 817F037C  lwz r11, 0x37c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(892 as u32) ) } as u64;
	// 828D0E34: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828D0E38: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 828D0E3C: 38AAECEC  addi r5, r10, -0x1314
	ctx.r[5].s64 = ctx.r[10].s64 + -4884;
	// 828D0E40: 917F037C  stw r11, 0x37c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(892 as u32), ctx.r[11].u32 ) };
	// 828D0E44: 48000060  b 0x828d0ea4
	pc = 0x828D0EA4; continue 'dispatch;
	// 828D0E48: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828D0E4C: 38AAECD8  addi r5, r10, -0x1328
	ctx.r[5].s64 = ctx.r[10].s64 + -4904;
	// 828D0E50: 48000054  b 0x828d0ea4
	pc = 0x828D0EA4; continue 'dispatch;
	// 828D0E54: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828D0E58: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D0E5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D0E60: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828D0E64: 816A0080  lwz r11, 0x80(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(128 as u32) ) } as u64;
	// 828D0E68: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D0E6C: 4E800421  bctrl
	ctx.lr = 0x828D0E70;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D0E70: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828D0E74: C00B9450  lfs f0, -0x6bb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D0E78: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 828D0E7C: 40980010  bge cr6, 0x828d0e8c
	if !ctx.cr[6].lt {
	pc = 0x828D0E8C; continue 'dispatch;
	}
	// 828D0E80: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828D0E84: 38AAECC4  addi r5, r10, -0x133c
	ctx.r[5].s64 = ctx.r[10].s64 + -4924;
	// 828D0E88: 4800001C  b 0x828d0ea4
	pc = 0x828D0EA4; continue 'dispatch;
	// 828D0E8C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D0E90: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D0E94: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828D0E98: 48000024  b 0x828d0ebc
	pc = 0x828D0EBC; continue 'dispatch;
	// 828D0E9C: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828D0EA0: 38AAECB0  addi r5, r10, -0x1350
	ctx.r[5].s64 = ctx.r[10].s64 + -4944;
	// 828D0EA4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D0EA8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D0EAC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D0EB0: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 828D0EB4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D0EB8: 4E800421  bctrl
	ctx.lr = 0x828D0EBC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D0EBC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D0EC0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D0EC4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D0EC8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D0ECC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828D0ED0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D0ED4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D0ED8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828D0ED8 size=16
    let mut pc: u32 = 0x828D0ED8;
    'dispatch: loop {
        match pc {
            0x828D0ED8 => {
    //   block [0x828D0ED8..0x828D0EE8)
	// 828D0ED8: 8163038C  lwz r11, 0x38c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(908 as u32) ) } as u64;
	// 828D0EDC: 616B0002  ori r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u64 | 2;
	// 828D0EE0: 9163038C  stw r11, 0x38c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(908 as u32), ctx.r[11].u32 ) };
	// 828D0EE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D0EE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D0EE8 size=780
    let mut pc: u32 = 0x828D0EE8;
    'dispatch: loop {
        match pc {
            0x828D0EE8 => {
    //   block [0x828D0EE8..0x828D11F4)
	// 828D0EE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D0EEC: 488D727D  bl 0x831a8168
	ctx.lr = 0x828D0EF0;
	sub_831A8130(ctx, base);
	// 828D0EF0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D0EF4: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 828D0EF8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D0EFC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828D0F00: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 828D0F04: 41820038  beq 0x828d0f3c
	if ctx.cr[0].eq {
	pc = 0x828D0F3C; continue 'dispatch;
	}
	// 828D0F08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D0F0C: 488D8A7D  bl 0x831a9988
	ctx.lr = 0x828D0F10;
	sub_831A9988(ctx, base);
	// 828D0F10: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 828D0F14: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D0F18: 386B3984  addi r3, r11, 0x3984
	ctx.r[3].s64 = ctx.r[11].s64 + 14724;
	// 828D0F1C: 488D71DD  bl 0x831a80f8
	ctx.lr = 0x828D0F20;
	sub_831A80F8(ctx, base);
	// 828D0F20: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D0F24: 41820018  beq 0x828d0f3c
	if ctx.cr[0].eq {
	pc = 0x828D0F3C; continue 'dispatch;
	}
	// 828D0F28: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D0F2C: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 828D0F30: 4BFFDCF9  bl 0x828cec28
	ctx.lr = 0x828D0F34;
	sub_828CEC28(ctx, base);
	// 828D0F34: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828D0F38: 480002B4  b 0x828d11ec
	pc = 0x828D11EC; continue 'dispatch;
	// 828D0F3C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828D0F40: 419A029C  beq cr6, 0x828d11dc
	if ctx.cr[6].eq {
	pc = 0x828D11DC; continue 'dispatch;
	}
	// 828D0F44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D0F48: 488D8A41  bl 0x831a9988
	ctx.lr = 0x828D0F4C;
	sub_831A9988(ctx, base);
	// 828D0F4C: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 828D0F50: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D0F54: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 828D0F58: 488D71A1  bl 0x831a80f8
	ctx.lr = 0x828D0F5C;
	sub_831A80F8(ctx, base);
	// 828D0F5C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D0F60: 41820014  beq 0x828d0f74
	if ctx.cr[0].eq {
	pc = 0x828D0F74; continue 'dispatch;
	}
	// 828D0F64: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D0F68: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 828D0F6C: 48008F75  bl 0x828d9ee0
	ctx.lr = 0x828D0F70;
	sub_828D9EE0(ctx, base);
	// 828D0F70: 4BFFFFC4  b 0x828d0f34
	pc = 0x828D0F34; continue 'dispatch;
	// 828D0F74: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828D0F78: 419A0264  beq cr6, 0x828d11dc
	if ctx.cr[6].eq {
	pc = 0x828D11DC; continue 'dispatch;
	}
	// 828D0F7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D0F80: 488D8A09  bl 0x831a9988
	ctx.lr = 0x828D0F84;
	sub_831A9988(ctx, base);
	// 828D0F84: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 828D0F88: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D0F8C: 386B6C0C  addi r3, r11, 0x6c0c
	ctx.r[3].s64 = ctx.r[11].s64 + 27660;
	// 828D0F90: 488D7169  bl 0x831a80f8
	ctx.lr = 0x828D0F94;
	sub_831A80F8(ctx, base);
	// 828D0F94: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D0F98: 41820014  beq 0x828d0fac
	if ctx.cr[0].eq {
	pc = 0x828D0FAC; continue 'dispatch;
	}
	// 828D0F9C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D0FA0: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 828D0FA4: 4BD90735  bl 0x826616d8
	ctx.lr = 0x828D0FA8;
	sub_826616D8(ctx, base);
	// 828D0FA8: 4BFFFF8C  b 0x828d0f34
	pc = 0x828D0F34; continue 'dispatch;
	// 828D0FAC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828D0FB0: 419A022C  beq cr6, 0x828d11dc
	if ctx.cr[6].eq {
	pc = 0x828D11DC; continue 'dispatch;
	}
	// 828D0FB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D0FB8: 488D89D1  bl 0x831a9988
	ctx.lr = 0x828D0FBC;
	sub_831A9988(ctx, base);
	// 828D0FBC: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 828D0FC0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D0FC4: 386B6BDC  addi r3, r11, 0x6bdc
	ctx.r[3].s64 = ctx.r[11].s64 + 27612;
	// 828D0FC8: 488D7131  bl 0x831a80f8
	ctx.lr = 0x828D0FCC;
	sub_831A80F8(ctx, base);
	// 828D0FCC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D0FD0: 41820014  beq 0x828d0fe4
	if ctx.cr[0].eq {
	pc = 0x828D0FE4; continue 'dispatch;
	}
	// 828D0FD4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D0FD8: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 828D0FDC: 4BD9072D  bl 0x82661708
	ctx.lr = 0x828D0FE0;
	sub_82661708(ctx, base);
	// 828D0FE0: 4BFFFF54  b 0x828d0f34
	pc = 0x828D0F34; continue 'dispatch;
	// 828D0FE4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828D0FE8: 419A01F4  beq cr6, 0x828d11dc
	if ctx.cr[6].eq {
	pc = 0x828D11DC; continue 'dispatch;
	}
	// 828D0FEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D0FF0: 488D8999  bl 0x831a9988
	ctx.lr = 0x828D0FF4;
	sub_831A9988(ctx, base);
	// 828D0FF4: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 828D0FF8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D0FFC: 386B5CEC  addi r3, r11, 0x5cec
	ctx.r[3].s64 = ctx.r[11].s64 + 23788;
	// 828D1000: 488D70F9  bl 0x831a80f8
	ctx.lr = 0x828D1004;
	sub_831A80F8(ctx, base);
	// 828D1004: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D1008: 41820014  beq 0x828d101c
	if ctx.cr[0].eq {
	pc = 0x828D101C; continue 'dispatch;
	}
	// 828D100C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D1010: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 828D1014: 4BFFDC05  bl 0x828cec18
	ctx.lr = 0x828D1018;
	sub_828CEC18(ctx, base);
	// 828D1018: 4BFFFF1C  b 0x828d0f34
	pc = 0x828D0F34; continue 'dispatch;
	// 828D101C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828D1020: 419A01BC  beq cr6, 0x828d11dc
	if ctx.cr[6].eq {
	pc = 0x828D11DC; continue 'dispatch;
	}
	// 828D1024: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D1028: 488D8961  bl 0x831a9988
	ctx.lr = 0x828D102C;
	sub_831A9988(ctx, base);
	// 828D102C: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 828D1030: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D1034: 386B5CC4  addi r3, r11, 0x5cc4
	ctx.r[3].s64 = ctx.r[11].s64 + 23748;
	// 828D1038: 488D70C1  bl 0x831a80f8
	ctx.lr = 0x828D103C;
	sub_831A80F8(ctx, base);
	// 828D103C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D1040: 41820014  beq 0x828d1054
	if ctx.cr[0].eq {
	pc = 0x828D1054; continue 'dispatch;
	}
	// 828D1044: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D1048: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 828D104C: 4BFFD9D5  bl 0x828cea20
	ctx.lr = 0x828D1050;
	sub_828CEA20(ctx, base);
	// 828D1050: 4BFFFEE4  b 0x828d0f34
	pc = 0x828D0F34; continue 'dispatch;
	// 828D1054: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828D1058: 419A0184  beq cr6, 0x828d11dc
	if ctx.cr[6].eq {
	pc = 0x828D11DC; continue 'dispatch;
	}
	// 828D105C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D1060: 488D8929  bl 0x831a9988
	ctx.lr = 0x828D1064;
	sub_831A9988(ctx, base);
	// 828D1064: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 828D1068: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D106C: 386B3A18  addi r3, r11, 0x3a18
	ctx.r[3].s64 = ctx.r[11].s64 + 14872;
	// 828D1070: 488D7089  bl 0x831a80f8
	ctx.lr = 0x828D1074;
	sub_831A80F8(ctx, base);
	// 828D1074: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D1078: 41820014  beq 0x828d108c
	if ctx.cr[0].eq {
	pc = 0x828D108C; continue 'dispatch;
	}
	// 828D107C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D1080: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 828D1084: 4BFFDC4D  bl 0x828cecd0
	ctx.lr = 0x828D1088;
	sub_828CECD0(ctx, base);
	// 828D1088: 4BFFFEAC  b 0x828d0f34
	pc = 0x828D0F34; continue 'dispatch;
	// 828D108C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828D1090: 419A014C  beq cr6, 0x828d11dc
	if ctx.cr[6].eq {
	pc = 0x828D11DC; continue 'dispatch;
	}
	// 828D1094: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D1098: 488D88F1  bl 0x831a9988
	ctx.lr = 0x828D109C;
	sub_831A9988(ctx, base);
	// 828D109C: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 828D10A0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D10A4: 386B3A44  addi r3, r11, 0x3a44
	ctx.r[3].s64 = ctx.r[11].s64 + 14916;
	// 828D10A8: 488D7051  bl 0x831a80f8
	ctx.lr = 0x828D10AC;
	sub_831A80F8(ctx, base);
	// 828D10AC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D10B0: 41820014  beq 0x828d10c4
	if ctx.cr[0].eq {
	pc = 0x828D10C4; continue 'dispatch;
	}
	// 828D10B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D10B8: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 828D10BC: 4BFFE3BD  bl 0x828cf478
	ctx.lr = 0x828D10C0;
	sub_828CF478(ctx, base);
	// 828D10C0: 4BFFFE74  b 0x828d0f34
	pc = 0x828D0F34; continue 'dispatch;
	// 828D10C4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828D10C8: 419A0114  beq cr6, 0x828d11dc
	if ctx.cr[6].eq {
	pc = 0x828D11DC; continue 'dispatch;
	}
	// 828D10CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D10D0: 488D88B9  bl 0x831a9988
	ctx.lr = 0x828D10D4;
	sub_831A9988(ctx, base);
	// 828D10D4: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 828D10D8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D10DC: 386B1FA4  addi r3, r11, 0x1fa4
	ctx.r[3].s64 = ctx.r[11].s64 + 8100;
	// 828D10E0: 488D7019  bl 0x831a80f8
	ctx.lr = 0x828D10E4;
	sub_831A80F8(ctx, base);
	// 828D10E4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D10E8: 41820014  beq 0x828d10fc
	if ctx.cr[0].eq {
	pc = 0x828D10FC; continue 'dispatch;
	}
	// 828D10EC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D10F0: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 828D10F4: 4BFECF8D  bl 0x828be080
	ctx.lr = 0x828D10F8;
	sub_828BE080(ctx, base);
	// 828D10F8: 4BFFFE3C  b 0x828d0f34
	pc = 0x828D0F34; continue 'dispatch;
	// 828D10FC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828D1100: 419A00DC  beq cr6, 0x828d11dc
	if ctx.cr[6].eq {
	pc = 0x828D11DC; continue 'dispatch;
	}
	// 828D1104: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D1108: 488D8881  bl 0x831a9988
	ctx.lr = 0x828D110C;
	sub_831A9988(ctx, base);
	// 828D110C: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 828D1110: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D1114: 386B2380  addi r3, r11, 0x2380
	ctx.r[3].s64 = ctx.r[11].s64 + 9088;
	// 828D1118: 488D6FE1  bl 0x831a80f8
	ctx.lr = 0x828D111C;
	sub_831A80F8(ctx, base);
	// 828D111C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D1120: 41820014  beq 0x828d1134
	if ctx.cr[0].eq {
	pc = 0x828D1134; continue 'dispatch;
	}
	// 828D1124: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D1128: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 828D112C: 4BFFDC25  bl 0x828ced50
	ctx.lr = 0x828D1130;
	sub_828CED50(ctx, base);
	// 828D1130: 4BFFFE04  b 0x828d0f34
	pc = 0x828D0F34; continue 'dispatch;
	// 828D1134: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828D1138: 419A00A4  beq cr6, 0x828d11dc
	if ctx.cr[6].eq {
	pc = 0x828D11DC; continue 'dispatch;
	}
	// 828D113C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D1140: 488D8849  bl 0x831a9988
	ctx.lr = 0x828D1144;
	sub_831A9988(ctx, base);
	// 828D1144: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D1148: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D114C: 386B583C  addi r3, r11, 0x583c
	ctx.r[3].s64 = ctx.r[11].s64 + 22588;
	// 828D1150: 488D6FA9  bl 0x831a80f8
	ctx.lr = 0x828D1154;
	sub_831A80F8(ctx, base);
	// 828D1154: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D1158: 41820014  beq 0x828d116c
	if ctx.cr[0].eq {
	pc = 0x828D116C; continue 'dispatch;
	}
	// 828D115C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D1160: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 828D1164: 4B9EEE9D  bl 0x822c0000
	ctx.lr = 0x828D1168;
	sub_822C0000(ctx, base);
	// 828D1168: 4BFFFDCC  b 0x828d0f34
	pc = 0x828D0F34; continue 'dispatch;
	// 828D116C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828D1170: 419A006C  beq cr6, 0x828d11dc
	if ctx.cr[6].eq {
	pc = 0x828D11DC; continue 'dispatch;
	}
	// 828D1174: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D1178: 488D8811  bl 0x831a9988
	ctx.lr = 0x828D117C;
	sub_831A9988(ctx, base);
	// 828D117C: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D1180: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D1184: 386B580C  addi r3, r11, 0x580c
	ctx.r[3].s64 = ctx.r[11].s64 + 22540;
	// 828D1188: 488D6F71  bl 0x831a80f8
	ctx.lr = 0x828D118C;
	sub_831A80F8(ctx, base);
	// 828D118C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D1190: 41820014  beq 0x828d11a4
	if ctx.cr[0].eq {
	pc = 0x828D11A4; continue 'dispatch;
	}
	// 828D1194: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D1198: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 828D119C: 4BFFFD3D  bl 0x828d0ed8
	ctx.lr = 0x828D11A0;
	sub_828D0ED8(ctx, base);
	// 828D11A0: 4BFFFD94  b 0x828d0f34
	pc = 0x828D0F34; continue 'dispatch;
	// 828D11A4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828D11A8: 419A0034  beq cr6, 0x828d11dc
	if ctx.cr[6].eq {
	pc = 0x828D11DC; continue 'dispatch;
	}
	// 828D11AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D11B0: 488D87D9  bl 0x831a9988
	ctx.lr = 0x828D11B4;
	sub_831A9988(ctx, base);
	// 828D11B4: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 828D11B8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D11BC: 386BF378  addi r3, r11, -0xc88
	ctx.r[3].s64 = ctx.r[11].s64 + -3208;
	// 828D11C0: 488D6F39  bl 0x831a80f8
	ctx.lr = 0x828D11C4;
	sub_831A80F8(ctx, base);
	// 828D11C4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D11C8: 41820014  beq 0x828d11dc
	if ctx.cr[0].eq {
	pc = 0x828D11DC; continue 'dispatch;
	}
	// 828D11CC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D11D0: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 828D11D4: 4BFFE38D  bl 0x828cf560
	ctx.lr = 0x828D11D8;
	sub_828CF560(ctx, base);
	// 828D11D8: 4BFFFD5C  b 0x828d0f34
	pc = 0x828D0F34; continue 'dispatch;
	// 828D11DC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828D11E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D11E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D11E8: 4803E8A9  bl 0x8290fa90
	ctx.lr = 0x828D11EC;
	sub_8290FA90(ctx, base);
	// 828D11EC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828D11F0: 488D6FC8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D11F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828D11F8 size=5124
    let mut pc: u32 = 0x828D11F8;
    'dispatch: loop {
        match pc {
            0x828D11F8 => {
    //   block [0x828D11F8..0x828D25FC)
	// 828D11F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D11FC: 488D6F3D  bl 0x831a8138
	ctx.lr = 0x828D1200;
	sub_831A8130(ctx, base);
	// 828D1200: DBE1FF70  stfd f31, -0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.f[31].u64 ) };
	// 828D1204: 9421FE60  stwu r1, -0x1a0(r1)
	ea = ctx.r[1].u32.wrapping_add(-416 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D1208: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D120C: 7C942378  mr r20, r4
	ctx.r[20].u64 = ctx.r[4].u64;
	// 828D1210: 7CB32B78  mr r19, r5
	ctx.r[19].u64 = ctx.r[5].u64;
	// 828D1214: 7CD53378  mr r21, r6
	ctx.r[21].u64 = ctx.r[6].u64;
	// 828D1218: 4803FB79  bl 0x82910d90
	ctx.lr = 0x828D121C;
	sub_82910D90(ctx, base);
	// 828D121C: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 828D1220: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D1224: 4BC3E14D  bl 0x8250f370
	ctx.lr = 0x828D1228;
	sub_8250F370(ctx, base);
	// 828D1228: 365DFFF0  addic. r18, r29, -0x10
	ctx.xer.ca = (ctx.r[29].u32 > (!(-16 as u32)));
	ctx.r[18].s64 = ctx.r[29].s64 + -16;
	ctx.cr[0].compare_i32(ctx.r[18].s32, 0, &mut ctx.xer);
	// 828D122C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828D1230: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 828D1234: 40820008  bne 0x828d123c
	if !ctx.cr[0].eq {
	pc = 0x828D123C; continue 'dispatch;
	}
	// 828D1238: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 828D123C: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 828D1240: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D1244: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 828D1248: 485227C1  bl 0x82df3a08
	ctx.lr = 0x828D124C;
	sub_82DF3A08(ctx, base);
	// 828D124C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828D1250: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D1254: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 828D1258: 4BC37529  bl 0x82508780
	ctx.lr = 0x828D125C;
	sub_82508780(ctx, base);
	// 828D125C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D1260: 485221C9  bl 0x82df3428
	ctx.lr = 0x828D1264;
	sub_82DF3428(ctx, base);
	// 828D1264: 2B120000  cmplwi cr6, r18, 0
	ctx.cr[6].compare_u32(ctx.r[18].u32, 0 as u32, &mut ctx.xer);
	// 828D1268: 389D0028  addi r4, r29, 0x28
	ctx.r[4].s64 = ctx.r[29].s64 + 40;
	// 828D126C: 409A0008  bne cr6, 0x828d1274
	if !ctx.cr[6].eq {
	pc = 0x828D1274; continue 'dispatch;
	}
	// 828D1270: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D1274: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 828D1278: 4BC37529  bl 0x825087a0
	ctx.lr = 0x828D127C;
	sub_825087A0(ctx, base);
	// 828D127C: 817DFFF0  lwz r11, -0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-16 as u32) ) } as u64;
	// 828D1280: 3B5DFFF0  addi r26, r29, -0x10
	ctx.r[26].s64 = ctx.r[29].s64 + -16;
	// 828D1284: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828D1288: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D128C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D1290: 4E800421  bctrl
	ctx.lr = 0x828D1294;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D1294: 817D02E0  lwz r11, 0x2e0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(736 as u32) ) } as u64;
	// 828D1298: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828D129C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D12A0: 409A0010  bne cr6, 0x828d12b0
	if !ctx.cr[6].eq {
	pc = 0x828D12B0; continue 'dispatch;
	}
	// 828D12A4: 817D0378  lwz r11, 0x378(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(888 as u32) ) } as u64;
	// 828D12A8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D12AC: 917D0380  stw r11, 0x380(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(896 as u32), ctx.r[11].u32 ) };
	// 828D12B0: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D12B4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828D12B8: 816B004C  lwz r11, 0x4c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828D12BC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D12C0: 4E800421  bctrl
	ctx.lr = 0x828D12C4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D12C4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D12C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D12CC: 4852273D  bl 0x82df3a08
	ctx.lr = 0x828D12D0;
	sub_82DF3A08(ctx, base);
	// 828D12D0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828D12D4: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 828D12D8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D12DC: 4803F325  bl 0x82910600
	ctx.lr = 0x828D12E0;
	sub_82910600(ctx, base);
	// 828D12E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D12E4: 48522145  bl 0x82df3428
	ctx.lr = 0x828D12E8;
	sub_82DF3428(ctx, base);
	// 828D12E8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D12EC: 4803F5D5  bl 0x829108c0
	ctx.lr = 0x828D12F0;
	sub_829108C0(ctx, base);
	// 828D12F0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D12F4: 41820010  beq 0x828d1304
	if ctx.cr[0].eq {
	pc = 0x828D1304; continue 'dispatch;
	}
	// 828D12F8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D12FC: 4BC3F2D5  bl 0x825105d0
	ctx.lr = 0x828D1300;
	sub_825105D0(ctx, base);
	// 828D1300: 480012F0  b 0x828d25f0
	pc = 0x828D25F0; continue 'dispatch;
	// 828D1304: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D1308: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D130C: 3ACBEBE8  addi r22, r11, -0x1418
	ctx.r[22].s64 = ctx.r[11].s64 + -5144;
	// 828D1310: 38A000EC  li r5, 0xec
	ctx.r[5].s64 = 236;
	// 828D1314: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 828D1318: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 828D131C: 4B9EF0BD  bl 0x822c03d8
	ctx.lr = 0x828D1320;
	sub_822C03D8(ctx, base);
	// 828D1320: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828D1324: 41820020  beq 0x828d1344
	if ctx.cr[0].eq {
	pc = 0x828D1344; continue 'dispatch;
	}
	// 828D1328: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D132C: 4BF19985  bl 0x827eacb0
	ctx.lr = 0x828D1330;
	sub_827EACB0(ctx, base);
	// 828D1330: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828D1334: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828D1338: 396B09D8  addi r11, r11, 0x9d8
	ctx.r[11].s64 = ctx.r[11].s64 + 2520;
	// 828D133C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D1340: 48000008  b 0x828d1348
	pc = 0x828D1348; continue 'dispatch;
	// 828D1344: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D1348: 3BDD01CC  addi r30, r29, 0x1cc
	ctx.r[30].s64 = ctx.r[29].s64 + 460;
	// 828D134C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D1350: 4BF96F31  bl 0x82868280
	ctx.lr = 0x828D1354;
	sub_82868280(ctx, base);
	// 828D1354: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D1358: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D135C: 808B58F8  lwz r4, 0x58f8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(22776 as u32) ) } as u64;
	// 828D1360: 485226A9  bl 0x82df3a08
	ctx.lr = 0x828D1364;
	sub_82DF3A08(ctx, base);
	// 828D1364: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828D1368: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828D136C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828D1370: 3AEB1070  addi r23, r11, 0x1070
	ctx.r[23].s64 = ctx.r[11].s64 + 4208;
	// 828D1374: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 828D1378: 837D01CC  lwz r27, 0x1cc(r29)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(460 as u32) ) } as u64;
	// 828D137C: C3EB1070  lfs f31, 0x1070(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4208 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828D1380: 4BC3E149  bl 0x8250f4c8
	ctx.lr = 0x828D1384;
	sub_8250F4C8(ctx, base);
	// 828D1384: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D1388: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828D138C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828D1390: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828D1394: 4BF195D5  bl 0x827ea968
	ctx.lr = 0x828D1398;
	sub_827EA968(ctx, base);
	// 828D1398: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828D139C: 485208F5  bl 0x82df1c90
	ctx.lr = 0x828D13A0;
	sub_82DF1C90(ctx, base);
	// 828D13A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D13A4: 48522085  bl 0x82df3428
	ctx.lr = 0x828D13A8;
	sub_82DF3428(ctx, base);
	// 828D13A8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D13AC: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 828D13B0: 807D01CC  lwz r3, 0x1cc(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(460 as u32) ) } as u64;
	// 828D13B4: 388A5900  addi r4, r10, 0x5900
	ctx.r[4].s64 = ctx.r[10].s64 + 22784;
	// 828D13B8: 80ABEE20  lwz r5, -0x11e0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4576 as u32) ) } as u64;
	// 828D13BC: 4BF19305  bl 0x827ea6c0
	ctx.lr = 0x828D13C0;
	sub_827EA6C0(ctx, base);
	// 828D13C0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828D13C4: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 828D13C8: 4BF1B201  bl 0x827ec5c8
	ctx.lr = 0x828D13CC;
	sub_827EC5C8(ctx, base);
	// 828D13CC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828D13D0: 807D01CC  lwz r3, 0x1cc(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(460 as u32) ) } as u64;
	// 828D13D4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D13D8: 4BF192F1  bl 0x827ea6c8
	ctx.lr = 0x828D13DC;
	sub_827EA6C8(ctx, base);
	// 828D13DC: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 828D13E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D13E4: 419A0008  beq cr6, 0x828d13ec
	if ctx.cr[6].eq {
	pc = 0x828D13EC; continue 'dispatch;
	}
	// 828D13E8: 4B9EF4A9  bl 0x822c0890
	ctx.lr = 0x828D13EC;
	sub_822C0890(ctx, base);
	// 828D13EC: 3F80832C  lis r28, -0x7cd4
	ctx.r[28].s64 = -2094268416;
	// 828D13F0: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 828D13F4: 3D60828D  lis r11, -0x7d73
	ctx.r[11].s64 = -2104688640;
	// 828D13F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D13FC: 396BF370  addi r11, r11, -0xc90
	ctx.r[11].s64 = ctx.r[11].s64 + -3216;
	// 828D1400: 809C5FF4  lwz r4, 0x5ff4(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24564 as u32) ) } as u64;
	// 828D1404: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828D1408: 48522601  bl 0x82df3a08
	ctx.lr = 0x828D140C;
	sub_82DF3A08(ctx, base);
	// 828D140C: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	// 828D1410: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828D1414: C01900C0  lfs f0, 0xc0(r25)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(192 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D1418: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 828D141C: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 828D1420: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 828D1424: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828D1428: 99610060  stb r11, 0x60(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u8 ) };
	// 828D142C: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828D1430: 914100AC  stw r10, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[10].u32 ) };
	// 828D1434: 934100A8  stw r26, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[26].u32 ) };
	// 828D1438: 916100B0  stw r11, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[11].u32 ) };
	// 828D143C: E8C100B0  ld r6, 0xb0(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) };
	// 828D1440: E8A100A8  ld r5, 0xa8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 828D1444: 93E100C0  stw r31, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[31].u32 ) };
	// 828D1448: 4BFFF921  bl 0x828d0d68
	ctx.lr = 0x828D144C;
	sub_828D0D68(ctx, base);
	// 828D144C: 38C100C0  addi r6, r1, 0xc0
	ctx.r[6].s64 = ctx.r[1].s64 + 192;
	// 828D1450: C03900C8  lfs f1, 0xc8(r25)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(200 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828D1454: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D1458: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D145C: 4BF19355  bl 0x827ea7b0
	ctx.lr = 0x828D1460;
	sub_827EA7B0(ctx, base);
	// 828D1460: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D1464: 48521FC5  bl 0x82df3428
	ctx.lr = 0x828D1468;
	sub_82DF3428(ctx, base);
	// 828D1468: 3D60828D  lis r11, -0x7d73
	ctx.r[11].s64 = -2104688640;
	// 828D146C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D1470: 809C5FF4  lwz r4, 0x5ff4(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24564 as u32) ) } as u64;
	// 828D1474: 396BF370  addi r11, r11, -0xc90
	ctx.r[11].s64 = ctx.r[11].s64 + -3216;
	// 828D1478: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 828D147C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828D1480: 48522589  bl 0x82df3a08
	ctx.lr = 0x828D1484;
	sub_82DF3A08(ctx, base);
	// 828D1484: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828D1488: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828D148C: C01900C4  lfs f0, 0xc4(r25)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(196 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D1490: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 828D1494: 996100A8  stb r11, 0xa8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[11].u8 ) };
	// 828D1498: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 828D149C: 816100A8  lwz r11, 0xa8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) } as u64;
	// 828D14A0: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828D14A4: 914100CC  stw r10, 0xcc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), ctx.r[10].u32 ) };
	// 828D14A8: 916100D0  stw r11, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[11].u32 ) };
	// 828D14AC: 934100C8  stw r26, 0xc8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[26].u32 ) };
	// 828D14B0: E8C100D0  ld r6, 0xd0(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(208 as u32) ) };
	// 828D14B4: E8A100C8  ld r5, 0xc8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) };
	// 828D14B8: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 828D14BC: 4BFFF8AD  bl 0x828d0d68
	ctx.lr = 0x828D14C0;
	sub_828D0D68(ctx, base);
	// 828D14C0: 38C100F0  addi r6, r1, 0xf0
	ctx.r[6].s64 = ctx.r[1].s64 + 240;
	// 828D14C4: C03900CC  lfs f1, 0xcc(r25)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(204 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828D14C8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D14CC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D14D0: 4BF192E1  bl 0x827ea7b0
	ctx.lr = 0x828D14D4;
	sub_827EA7B0(ctx, base);
	// 828D14D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D14D8: 48521F51  bl 0x82df3428
	ctx.lr = 0x828D14DC;
	sub_82DF3428(ctx, base);
	// 828D14DC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D14E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D14E4: 388BED00  addi r4, r11, -0x1300
	ctx.r[4].s64 = ctx.r[11].s64 + -4864;
	// 828D14E8: 48522521  bl 0x82df3a08
	ctx.lr = 0x828D14EC;
	sub_82DF3A08(ctx, base);
	// 828D14EC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828D14F0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D14F4: 80950000  lwz r4, 0(r21)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D14F8: 48040429  bl 0x82911920
	ctx.lr = 0x828D14FC;
	sub_82911920(ctx, base);
	// 828D14FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D1500: 48521F29  bl 0x82df3428
	ctx.lr = 0x828D1504;
	sub_82DF3428(ctx, base);
	// 828D1504: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D1508: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D150C: 808B6040  lwz r4, 0x6040(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24640 as u32) ) } as u64;
	// 828D1510: 485224F9  bl 0x82df3a08
	ctx.lr = 0x828D1514;
	sub_82DF3A08(ctx, base);
	// 828D1514: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828D1518: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D151C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D1520: C02B0A90  lfs f1, 0xa90(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2704 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828D1524: 4BF18E15  bl 0x827ea338
	ctx.lr = 0x828D1528;
	sub_827EA338(ctx, base);
	// 828D1528: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D152C: 48521EFD  bl 0x82df3428
	ctx.lr = 0x828D1530;
	sub_82DF3428(ctx, base);
	// 828D1530: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D1534: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D1538: 808BF3FC  lwz r4, -0xc04(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3076 as u32) ) } as u64;
	// 828D153C: 485224CD  bl 0x82df3a08
	ctx.lr = 0x828D1540;
	sub_82DF3A08(ctx, base);
	// 828D1540: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828D1544: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D1548: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D154C: C3EB6150  lfs f31, 0x6150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828D1550: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828D1554: 4BF18DE5  bl 0x827ea338
	ctx.lr = 0x828D1558;
	sub_827EA338(ctx, base);
	// 828D1558: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D155C: 48521ECD  bl 0x82df3428
	ctx.lr = 0x828D1560;
	sub_82DF3428(ctx, base);
	// 828D1560: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D1564: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D1568: 808B6030  lwz r4, 0x6030(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24624 as u32) ) } as u64;
	// 828D156C: 4852249D  bl 0x82df3a08
	ctx.lr = 0x828D1570;
	sub_82DF3A08(ctx, base);
	// 828D1570: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D1574: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D1578: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828D157C: 4BF18DBD  bl 0x827ea338
	ctx.lr = 0x828D1580;
	sub_827EA338(ctx, base);
	// 828D1580: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D1584: 48521EA5  bl 0x82df3428
	ctx.lr = 0x828D1588;
	sub_82DF3428(ctx, base);
	// 828D1588: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D158C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D1590: 808B6038  lwz r4, 0x6038(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24632 as u32) ) } as u64;
	// 828D1594: 48522475  bl 0x82df3a08
	ctx.lr = 0x828D1598;
	sub_82DF3A08(ctx, base);
	// 828D1598: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D159C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D15A0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828D15A4: 4BF18D95  bl 0x827ea338
	ctx.lr = 0x828D15A8;
	sub_827EA338(ctx, base);
	// 828D15A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D15AC: 48521E7D  bl 0x82df3428
	ctx.lr = 0x828D15B0;
	sub_82DF3428(ctx, base);
	// 828D15B0: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D15B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D15B8: 808B603C  lwz r4, 0x603c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24636 as u32) ) } as u64;
	// 828D15BC: 4852244D  bl 0x82df3a08
	ctx.lr = 0x828D15C0;
	sub_82DF3A08(ctx, base);
	// 828D15C0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D15C4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D15C8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828D15CC: 4BF18D6D  bl 0x827ea338
	ctx.lr = 0x828D15D0;
	sub_827EA338(ctx, base);
	// 828D15D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D15D4: 48521E55  bl 0x82df3428
	ctx.lr = 0x828D15D8;
	sub_82DF3428(ctx, base);
	// 828D15D8: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D15DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D15E0: 808B600C  lwz r4, 0x600c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24588 as u32) ) } as u64;
	// 828D15E4: 48522425  bl 0x82df3a08
	ctx.lr = 0x828D15E8;
	sub_82DF3A08(ctx, base);
	// 828D15E8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D15EC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D15F0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D15F4: 3B6BE6CC  addi r27, r11, -0x1934
	ctx.r[27].s64 = ctx.r[11].s64 + -6452;
	// 828D15F8: C3FB0008  lfs f31, 8(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828D15FC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828D1600: 4BF18D39  bl 0x827ea338
	ctx.lr = 0x828D1604;
	sub_827EA338(ctx, base);
	// 828D1604: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D1608: 48521E21  bl 0x82df3428
	ctx.lr = 0x828D160C;
	sub_82DF3428(ctx, base);
	// 828D160C: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D1610: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D1614: 808B6010  lwz r4, 0x6010(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24592 as u32) ) } as u64;
	// 828D1618: 485223F1  bl 0x82df3a08
	ctx.lr = 0x828D161C;
	sub_82DF3A08(ctx, base);
	// 828D161C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D1620: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D1624: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828D1628: 4BF18D11  bl 0x827ea338
	ctx.lr = 0x828D162C;
	sub_827EA338(ctx, base);
	// 828D162C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D1630: 48521DF9  bl 0x82df3428
	ctx.lr = 0x828D1634;
	sub_82DF3428(ctx, base);
	// 828D1634: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D1638: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D163C: 808B6014  lwz r4, 0x6014(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24596 as u32) ) } as u64;
	// 828D1640: 485223C9  bl 0x82df3a08
	ctx.lr = 0x828D1644;
	sub_82DF3A08(ctx, base);
	// 828D1644: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D1648: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D164C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828D1650: 4BF18CE9  bl 0x827ea338
	ctx.lr = 0x828D1654;
	sub_827EA338(ctx, base);
	// 828D1654: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D1658: 48521DD1  bl 0x82df3428
	ctx.lr = 0x828D165C;
	sub_82DF3428(ctx, base);
	// 828D165C: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D1660: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D1664: 808B6018  lwz r4, 0x6018(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24600 as u32) ) } as u64;
	// 828D1668: 485223A1  bl 0x82df3a08
	ctx.lr = 0x828D166C;
	sub_82DF3A08(ctx, base);
	// 828D166C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D1670: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D1674: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828D1678: 4BF18CC1  bl 0x827ea338
	ctx.lr = 0x828D167C;
	sub_827EA338(ctx, base);
	// 828D167C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D1680: 48521DA9  bl 0x82df3428
	ctx.lr = 0x828D1684;
	sub_82DF3428(ctx, base);
	// 828D1684: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D1688: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D168C: 808B601C  lwz r4, 0x601c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24604 as u32) ) } as u64;
	// 828D1690: 48522379  bl 0x82df3a08
	ctx.lr = 0x828D1694;
	sub_82DF3A08(ctx, base);
	// 828D1694: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D1698: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D169C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828D16A0: 4BF18C99  bl 0x827ea338
	ctx.lr = 0x828D16A4;
	sub_827EA338(ctx, base);
	// 828D16A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D16A8: 48521D81  bl 0x82df3428
	ctx.lr = 0x828D16AC;
	sub_82DF3428(ctx, base);
	// 828D16AC: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D16B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D16B4: 808B6020  lwz r4, 0x6020(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24608 as u32) ) } as u64;
	// 828D16B8: 48522351  bl 0x82df3a08
	ctx.lr = 0x828D16BC;
	sub_82DF3A08(ctx, base);
	// 828D16BC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D16C0: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D16C4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828D16C8: 4BF18C71  bl 0x827ea338
	ctx.lr = 0x828D16CC;
	sub_827EA338(ctx, base);
	// 828D16CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D16D0: 48521D59  bl 0x82df3428
	ctx.lr = 0x828D16D4;
	sub_82DF3428(ctx, base);
	// 828D16D4: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D16D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D16DC: 808B6024  lwz r4, 0x6024(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24612 as u32) ) } as u64;
	// 828D16E0: 48522329  bl 0x82df3a08
	ctx.lr = 0x828D16E4;
	sub_82DF3A08(ctx, base);
	// 828D16E4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D16E8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D16EC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828D16F0: 4BF18C49  bl 0x827ea338
	ctx.lr = 0x828D16F4;
	sub_827EA338(ctx, base);
	// 828D16F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D16F8: 48521D31  bl 0x82df3428
	ctx.lr = 0x828D16FC;
	sub_82DF3428(ctx, base);
	// 828D16FC: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D1700: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D1704: 808B6028  lwz r4, 0x6028(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24616 as u32) ) } as u64;
	// 828D1708: 48522301  bl 0x82df3a08
	ctx.lr = 0x828D170C;
	sub_82DF3A08(ctx, base);
	// 828D170C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D1710: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D1714: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828D1718: 4BF18C21  bl 0x827ea338
	ctx.lr = 0x828D171C;
	sub_827EA338(ctx, base);
	// 828D171C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D1720: 48521D09  bl 0x82df3428
	ctx.lr = 0x828D1724;
	sub_82DF3428(ctx, base);
	// 828D1724: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D1728: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D172C: 808B602C  lwz r4, 0x602c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24620 as u32) ) } as u64;
	// 828D1730: 485222D9  bl 0x82df3a08
	ctx.lr = 0x828D1734;
	sub_82DF3A08(ctx, base);
	// 828D1734: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D1738: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D173C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828D1740: 4BF18BF9  bl 0x827ea338
	ctx.lr = 0x828D1744;
	sub_827EA338(ctx, base);
	// 828D1744: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D1748: 48521CE1  bl 0x82df3428
	ctx.lr = 0x828D174C;
	sub_82DF3428(ctx, base);
	// 828D174C: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D1750: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D1754: 808B5FFC  lwz r4, 0x5ffc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24572 as u32) ) } as u64;
	// 828D1758: 485222B1  bl 0x82df3a08
	ctx.lr = 0x828D175C;
	sub_82DF3A08(ctx, base);
	// 828D175C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D1760: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D1764: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828D1768: 4BF18BD1  bl 0x827ea338
	ctx.lr = 0x828D176C;
	sub_827EA338(ctx, base);
	// 828D176C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D1770: 48521CB9  bl 0x82df3428
	ctx.lr = 0x828D1774;
	sub_82DF3428(ctx, base);
	// 828D1774: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D1778: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D177C: 808B6000  lwz r4, 0x6000(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24576 as u32) ) } as u64;
	// 828D1780: 48522289  bl 0x82df3a08
	ctx.lr = 0x828D1784;
	sub_82DF3A08(ctx, base);
	// 828D1784: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D1788: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D178C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828D1790: 4BF18BA9  bl 0x827ea338
	ctx.lr = 0x828D1794;
	sub_827EA338(ctx, base);
	// 828D1794: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D1798: 48521C91  bl 0x82df3428
	ctx.lr = 0x828D179C;
	sub_82DF3428(ctx, base);
	// 828D179C: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D17A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D17A4: 808B6004  lwz r4, 0x6004(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24580 as u32) ) } as u64;
	// 828D17A8: 48522261  bl 0x82df3a08
	ctx.lr = 0x828D17AC;
	sub_82DF3A08(ctx, base);
	// 828D17AC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D17B0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D17B4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828D17B8: 4BF18B81  bl 0x827ea338
	ctx.lr = 0x828D17BC;
	sub_827EA338(ctx, base);
	// 828D17BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D17C0: 48521C69  bl 0x82df3428
	ctx.lr = 0x828D17C4;
	sub_82DF3428(ctx, base);
	// 828D17C4: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D17C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D17CC: 808BF460  lwz r4, -0xba0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2976 as u32) ) } as u64;
	// 828D17D0: 48522239  bl 0x82df3a08
	ctx.lr = 0x828D17D4;
	sub_82DF3A08(ctx, base);
	// 828D17D4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D17D8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D17DC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828D17E0: 4BF18B59  bl 0x827ea338
	ctx.lr = 0x828D17E4;
	sub_827EA338(ctx, base);
	// 828D17E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D17E8: 48521C41  bl 0x82df3428
	ctx.lr = 0x828D17EC;
	sub_82DF3428(ctx, base);
	// 828D17EC: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D17F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D17F4: 808BF45C  lwz r4, -0xba4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2980 as u32) ) } as u64;
	// 828D17F8: 48522211  bl 0x82df3a08
	ctx.lr = 0x828D17FC;
	sub_82DF3A08(ctx, base);
	// 828D17FC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D1800: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D1804: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828D1808: 4BF18B31  bl 0x827ea338
	ctx.lr = 0x828D180C;
	sub_827EA338(ctx, base);
	// 828D180C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D1810: 48521C19  bl 0x82df3428
	ctx.lr = 0x828D1814;
	sub_82DF3428(ctx, base);
	// 828D1814: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D1818: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D181C: 808BF464  lwz r4, -0xb9c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2972 as u32) ) } as u64;
	// 828D1820: 485221E9  bl 0x82df3a08
	ctx.lr = 0x828D1824;
	sub_82DF3A08(ctx, base);
	// 828D1824: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D1828: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D182C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828D1830: 4BF18B09  bl 0x827ea338
	ctx.lr = 0x828D1834;
	sub_827EA338(ctx, base);
	// 828D1834: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D1838: 48521BF1  bl 0x82df3428
	ctx.lr = 0x828D183C;
	sub_82DF3428(ctx, base);
	// 828D183C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D1840: 809C5FF4  lwz r4, 0x5ff4(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24564 as u32) ) } as u64;
	// 828D1844: 485221C5  bl 0x82df3a08
	ctx.lr = 0x828D1848;
	sub_82DF3A08(ctx, base);
	// 828D1848: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D184C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D1850: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828D1854: 4BF18AE5  bl 0x827ea338
	ctx.lr = 0x828D1858;
	sub_827EA338(ctx, base);
	// 828D1858: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D185C: 48521BCD  bl 0x82df3428
	ctx.lr = 0x828D1860;
	sub_82DF3428(ctx, base);
	// 828D1860: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D1864: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D1868: 808BF46C  lwz r4, -0xb94(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2964 as u32) ) } as u64;
	// 828D186C: 4852219D  bl 0x82df3a08
	ctx.lr = 0x828D1870;
	sub_82DF3A08(ctx, base);
	// 828D1870: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D1874: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D1878: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828D187C: 4BF18ABD  bl 0x827ea338
	ctx.lr = 0x828D1880;
	sub_827EA338(ctx, base);
	// 828D1880: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D1884: 48521BA5  bl 0x82df3428
	ctx.lr = 0x828D1888;
	sub_82DF3428(ctx, base);
	// 828D1888: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D188C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D1890: 808BF470  lwz r4, -0xb90(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2960 as u32) ) } as u64;
	// 828D1894: 48522175  bl 0x82df3a08
	ctx.lr = 0x828D1898;
	sub_82DF3A08(ctx, base);
	// 828D1898: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D189C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D18A0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828D18A4: 4BF18A95  bl 0x827ea338
	ctx.lr = 0x828D18A8;
	sub_827EA338(ctx, base);
	// 828D18A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D18AC: 48521B7D  bl 0x82df3428
	ctx.lr = 0x828D18B0;
	sub_82DF3428(ctx, base);
	// 828D18B0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D18B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D18B8: 808BF47C  lwz r4, -0xb84(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2948 as u32) ) } as u64;
	// 828D18BC: 4852214D  bl 0x82df3a08
	ctx.lr = 0x828D18C0;
	sub_82DF3A08(ctx, base);
	// 828D18C0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D18C4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D18C8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828D18CC: 4BF18A6D  bl 0x827ea338
	ctx.lr = 0x828D18D0;
	sub_827EA338(ctx, base);
	// 828D18D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D18D4: 48521B55  bl 0x82df3428
	ctx.lr = 0x828D18D8;
	sub_82DF3428(ctx, base);
	// 828D18D8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D18DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D18E0: 808BF468  lwz r4, -0xb98(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2968 as u32) ) } as u64;
	// 828D18E4: 48522125  bl 0x82df3a08
	ctx.lr = 0x828D18E8;
	sub_82DF3A08(ctx, base);
	// 828D18E8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D18EC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D18F0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828D18F4: 4BF18A45  bl 0x827ea338
	ctx.lr = 0x828D18F8;
	sub_827EA338(ctx, base);
	// 828D18F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D18FC: 48521B2D  bl 0x82df3428
	ctx.lr = 0x828D1900;
	sub_82DF3428(ctx, base);
	// 828D1900: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D1904: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D1908: 808BF480  lwz r4, -0xb80(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2944 as u32) ) } as u64;
	// 828D190C: 485220FD  bl 0x82df3a08
	ctx.lr = 0x828D1910;
	sub_82DF3A08(ctx, base);
	// 828D1910: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D1914: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D1918: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828D191C: 4BF18A1D  bl 0x827ea338
	ctx.lr = 0x828D1920;
	sub_827EA338(ctx, base);
	// 828D1920: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D1924: 48521B05  bl 0x82df3428
	ctx.lr = 0x828D1928;
	sub_82DF3428(ctx, base);
	// 828D1928: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D192C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D1930: 808BF450  lwz r4, -0xbb0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2992 as u32) ) } as u64;
	// 828D1934: 485220D5  bl 0x82df3a08
	ctx.lr = 0x828D1938;
	sub_82DF3A08(ctx, base);
	// 828D1938: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D193C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D1940: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828D1944: 4BF189F5  bl 0x827ea338
	ctx.lr = 0x828D1948;
	sub_827EA338(ctx, base);
	// 828D1948: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D194C: 48521ADD  bl 0x82df3428
	ctx.lr = 0x828D1950;
	sub_82DF3428(ctx, base);
	// 828D1950: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 828D1954: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D1958: 38A00122  li r5, 0x122
	ctx.r[5].s64 = 290;
	// 828D195C: 386000C0  li r3, 0xc0
	ctx.r[3].s64 = 192;
	// 828D1960: 4B9EEA79  bl 0x822c03d8
	ctx.lr = 0x828D1964;
	sub_822C03D8(ctx, base);
	// 828D1964: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828D1968: 41820020  beq 0x828d1988
	if ctx.cr[0].eq {
	pc = 0x828D1988; continue 'dispatch;
	}
	// 828D196C: 2B120000  cmplwi cr6, r18, 0
	ctx.cr[6].compare_u32(ctx.r[18].u32, 0 as u32, &mut ctx.xer);
	// 828D1970: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828D1974: 409A0008  bne cr6, 0x828d197c
	if !ctx.cr[6].eq {
	pc = 0x828D197C; continue 'dispatch;
	}
	// 828D1978: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D197C: 48000F45  bl 0x828d28c0
	ctx.lr = 0x828D1980;
	sub_828D28C0(ctx, base);
	// 828D1980: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D1984: 48000008  b 0x828d198c
	pc = 0x828D198C; continue 'dispatch;
	// 828D1988: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D198C: 3B9D00E4  addi r28, r29, 0xe4
	ctx.r[28].s64 = ctx.r[29].s64 + 228;
	// 828D1990: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828D1994: 4BFFE515  bl 0x828cfea8
	ctx.lr = 0x828D1998;
	sub_828CFEA8(ctx, base);
	// 828D1998: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D199C: 4BF1A7C5  bl 0x827ec160
	ctx.lr = 0x828D19A0;
	sub_827EC160(ctx, base);
	// 828D19A0: 7C711B78  mr r17, r3
	ctx.r[17].u64 = ctx.r[3].u64;
	// 828D19A4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D19A8: 83D10000  lwz r30, 0(r17)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D19AC: 48141CD5  bl 0x82a13680
	ctx.lr = 0x828D19B0;
	sub_82A13680(ctx, base);
	// 828D19B0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D19B4: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828D19B8: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 828D19BC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D19C0: 4E800421  bctrl
	ctx.lr = 0x828D19C4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D19C4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D19C8: 83D10000  lwz r30, 0(r17)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D19CC: 48141CBD  bl 0x82a13688
	ctx.lr = 0x828D19D0;
	sub_82A13688(ctx, base);
	// 828D19D0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D19D4: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 828D19D8: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 828D19DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D19E0: 4E800421  bctrl
	ctx.lr = 0x828D19E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D19E4: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828D19E8: 4804F991  bl 0x82921378
	ctx.lr = 0x828D19EC;
	sub_82921378(ctx, base);
	// 828D19EC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828D19F0: C01B0010  lfs f0, 0x10(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D19F4: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 828D19F8: D00100A8  stfs f0, 0xa8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 828D19FC: 93E100AC  stw r31, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[31].u32 ) };
	// 828D1A00: C1BB0004  lfs f13, 4(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828D1A04: 9BE100B0  stb r31, 0xb0(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[31].u8 ) };
	// 828D1A08: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 828D1A0C: 9B0100B1  stb r24, 0xb1(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(177 as u32), ctx.r[24].u8 ) };
	// 828D1A10: C18B9450  lfs f12, -0x6bb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828D1A14: 9B0100B2  stb r24, 0xb2(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(178 as u32), ctx.r[24].u8 ) };
	// 828D1A18: 81710000  lwz r11, 0(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D1A1C: C0170000  lfs f0, 0(r23)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D1A20: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 828D1A24: D1A100A0  stfs f13, 0xa0(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 828D1A28: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 828D1A2C: D00100A4  stfs f0, 0xa4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 828D1A30: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 828D1A34: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D1A38: 4E800421  bctrl
	ctx.lr = 0x828D1A3C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D1A3C: 81710000  lwz r11, 0(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D1A40: 888100B0  lbz r4, 0xb0(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 828D1A44: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 828D1A48: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D1A4C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D1A50: 4E800421  bctrl
	ctx.lr = 0x828D1A54;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D1A54: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 828D1A58: 4BF1EB39  bl 0x827f0590
	ctx.lr = 0x828D1A5C;
	sub_827F0590(ctx, base);
	// 828D1A5C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 828D1A60: 3940000F  li r10, 0xf
	ctx.r[10].s64 = 15;
	// 828D1A64: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 828D1A68: 914100D4  stw r10, 0xd4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), ctx.r[10].u32 ) };
	// 828D1A6C: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 828D1A70: C00BD7BC  lfs f0, -0x2844(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D1A74: D00100C0  stfs f0, 0xc0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 828D1A78: D00100C4  stfs f0, 0xc4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 828D1A7C: 81710000  lwz r11, 0(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D1A80: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 828D1A84: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D1A88: 4E800421  bctrl
	ctx.lr = 0x828D1A8C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D1A8C: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 828D1A90: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828D1A94: 4BFFE6E5  bl 0x828d0178
	ctx.lr = 0x828D1A98;
	sub_828D0178(ctx, base);
	// 828D1A98: 817D00FC  lwz r11, 0xfc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(252 as u32) ) } as u64;
	// 828D1A9C: 3BDD00FC  addi r30, r29, 0xfc
	ctx.r[30].s64 = ctx.r[29].s64 + 252;
	// 828D1AA0: 809D00E4  lwz r4, 0xe4(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(228 as u32) ) } as u64;
	// 828D1AA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D1AA8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D1AAC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D1AB0: 4E800421  bctrl
	ctx.lr = 0x828D1AB4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D1AB4: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 828D1AB8: 3D60828D  lis r11, -0x7d73
	ctx.r[11].s64 = -2104688640;
	// 828D1ABC: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 828D1AC0: 388B7A18  addi r4, r11, 0x7a18
	ctx.r[4].s64 = ctx.r[11].s64 + 31256;
	// 828D1AC4: 4BFFEDD5  bl 0x828d0898
	ctx.lr = 0x828D1AC8;
	sub_828D0898(ctx, base);
	// 828D1AC8: 3E20832D  lis r17, -0x7cd3
	ctx.r[17].s64 = -2094202880;
	// 828D1ACC: 80910AF0  lwz r4, 0xaf0(r17)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(2800 as u32) ) } as u64;
	// 828D1AD0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D1AD4: 3A0100F0  addi r16, r1, 0xf0
	ctx.r[16].s64 = ctx.r[1].s64 + 240;
	// 828D1AD8: 48521F31  bl 0x82df3a08
	ctx.lr = 0x828D1ADC;
	sub_82DF3A08(ctx, base);
	// 828D1ADC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D1AE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D1AE4: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 828D1AE8: 4858A671  bl 0x82e5c158
	ctx.lr = 0x828D1AEC;
	sub_82E5C158(ctx, base);
	// 828D1AEC: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 828D1AF0: 3D60828D  lis r11, -0x7d73
	ctx.r[11].s64 = -2104688640;
	// 828D1AF4: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 828D1AF8: 388B3EF8  addi r4, r11, 0x3ef8
	ctx.r[4].s64 = ctx.r[11].s64 + 16120;
	// 828D1AFC: 4BFFED9D  bl 0x828d0898
	ctx.lr = 0x828D1B00;
	sub_828D0898(ctx, base);
	// 828D1B00: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D1B04: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D1B08: 3A0100F0  addi r16, r1, 0xf0
	ctx.r[16].s64 = ctx.r[1].s64 + 240;
	// 828D1B0C: 808B6058  lwz r4, 0x6058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24664 as u32) ) } as u64;
	// 828D1B10: 48521EF9  bl 0x82df3a08
	ctx.lr = 0x828D1B14;
	sub_82DF3A08(ctx, base);
	// 828D1B14: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D1B18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D1B1C: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 828D1B20: 4858A639  bl 0x82e5c158
	ctx.lr = 0x828D1B24;
	sub_82E5C158(ctx, base);
	// 828D1B24: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 828D1B28: 3D60828D  lis r11, -0x7d73
	ctx.r[11].s64 = -2104688640;
	// 828D1B2C: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 828D1B30: 388B7BD8  addi r4, r11, 0x7bd8
	ctx.r[4].s64 = ctx.r[11].s64 + 31704;
	// 828D1B34: 4BFFED65  bl 0x828d0898
	ctx.lr = 0x828D1B38;
	sub_828D0898(ctx, base);
	// 828D1B38: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D1B3C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D1B40: 3A0100F0  addi r16, r1, 0xf0
	ctx.r[16].s64 = ctx.r[1].s64 + 240;
	// 828D1B44: 808B6054  lwz r4, 0x6054(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24660 as u32) ) } as u64;
	// 828D1B48: 48521EC1  bl 0x82df3a08
	ctx.lr = 0x828D1B4C;
	sub_82DF3A08(ctx, base);
	// 828D1B4C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D1B50: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D1B54: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 828D1B58: 4858A601  bl 0x82e5c158
	ctx.lr = 0x828D1B5C;
	sub_82E5C158(ctx, base);
	// 828D1B5C: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 828D1B60: 3D60828D  lis r11, -0x7d73
	ctx.r[11].s64 = -2104688640;
	// 828D1B64: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 828D1B68: 388B7A88  addi r4, r11, 0x7a88
	ctx.r[4].s64 = ctx.r[11].s64 + 31368;
	// 828D1B6C: 4BFFED2D  bl 0x828d0898
	ctx.lr = 0x828D1B70;
	sub_828D0898(ctx, base);
	// 828D1B70: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D1B74: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D1B78: 3A0100F0  addi r16, r1, 0xf0
	ctx.r[16].s64 = ctx.r[1].s64 + 240;
	// 828D1B7C: 808B604C  lwz r4, 0x604c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24652 as u32) ) } as u64;
	// 828D1B80: 48521E89  bl 0x82df3a08
	ctx.lr = 0x828D1B84;
	sub_82DF3A08(ctx, base);
	// 828D1B84: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D1B88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D1B8C: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 828D1B90: 4858A5C9  bl 0x82e5c158
	ctx.lr = 0x828D1B94;
	sub_82E5C158(ctx, base);
	// 828D1B94: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 828D1B98: 3D60828D  lis r11, -0x7d73
	ctx.r[11].s64 = -2104688640;
	// 828D1B9C: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 828D1BA0: 388B7AF8  addi r4, r11, 0x7af8
	ctx.r[4].s64 = ctx.r[11].s64 + 31480;
	// 828D1BA4: 4BFFECF5  bl 0x828d0898
	ctx.lr = 0x828D1BA8;
	sub_828D0898(ctx, base);
	// 828D1BA8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D1BAC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D1BB0: 3A0100F0  addi r16, r1, 0xf0
	ctx.r[16].s64 = ctx.r[1].s64 + 240;
	// 828D1BB4: 808B0AF8  lwz r4, 0xaf8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2808 as u32) ) } as u64;
	// 828D1BB8: 48521E51  bl 0x82df3a08
	ctx.lr = 0x828D1BBC;
	sub_82DF3A08(ctx, base);
	// 828D1BBC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D1BC0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D1BC4: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 828D1BC8: 4858A591  bl 0x82e5c158
	ctx.lr = 0x828D1BCC;
	sub_82E5C158(ctx, base);
	// 828D1BCC: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 828D1BD0: 3D60828D  lis r11, -0x7d73
	ctx.r[11].s64 = -2104688640;
	// 828D1BD4: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 828D1BD8: 388B7B68  addi r4, r11, 0x7b68
	ctx.r[4].s64 = ctx.r[11].s64 + 31592;
	// 828D1BDC: 4BFFECBD  bl 0x828d0898
	ctx.lr = 0x828D1BE0;
	sub_828D0898(ctx, base);
	// 828D1BE0: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D1BE4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D1BE8: 3A0100F0  addi r16, r1, 0xf0
	ctx.r[16].s64 = ctx.r[1].s64 + 240;
	// 828D1BEC: 808B6050  lwz r4, 0x6050(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24656 as u32) ) } as u64;
	// 828D1BF0: 48521E19  bl 0x82df3a08
	ctx.lr = 0x828D1BF4;
	sub_82DF3A08(ctx, base);
	// 828D1BF4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D1BF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D1BFC: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 828D1C00: 4858A559  bl 0x82e5c158
	ctx.lr = 0x828D1C04;
	sub_82E5C158(ctx, base);
	// 828D1C04: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828D1C08: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 828D1C0C: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 828D1C10: 388B9598  addi r4, r11, -0x6a68
	ctx.r[4].s64 = ctx.r[11].s64 + -27240;
	// 828D1C14: 4BFFEC85  bl 0x828d0898
	ctx.lr = 0x828D1C18;
	sub_828D0898(ctx, base);
	// 828D1C18: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D1C1C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D1C20: 3A0100F0  addi r16, r1, 0xf0
	ctx.r[16].s64 = ctx.r[1].s64 + 240;
	// 828D1C24: 808B0AFC  lwz r4, 0xafc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2812 as u32) ) } as u64;
	// 828D1C28: 48521DE1  bl 0x82df3a08
	ctx.lr = 0x828D1C2C;
	sub_82DF3A08(ctx, base);
	// 828D1C2C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D1C30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D1C34: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 828D1C38: 4858A521  bl 0x82e5c158
	ctx.lr = 0x828D1C3C;
	sub_82E5C158(ctx, base);
	// 828D1C3C: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 828D1C40: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828D1C44: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 828D1C48: 388B9878  addi r4, r11, -0x6788
	ctx.r[4].s64 = ctx.r[11].s64 + -26504;
	// 828D1C4C: 4BFFEC4D  bl 0x828d0898
	ctx.lr = 0x828D1C50;
	sub_828D0898(ctx, base);
	// 828D1C50: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D1C54: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D1C58: 3A0100F0  addi r16, r1, 0xf0
	ctx.r[16].s64 = ctx.r[1].s64 + 240;
	// 828D1C5C: 808B0B10  lwz r4, 0xb10(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2832 as u32) ) } as u64;
	// 828D1C60: 48521DA9  bl 0x82df3a08
	ctx.lr = 0x828D1C64;
	sub_82DF3A08(ctx, base);
	// 828D1C64: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D1C68: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D1C6C: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 828D1C70: 4858A4E9  bl 0x82e5c158
	ctx.lr = 0x828D1C74;
	sub_82E5C158(ctx, base);
	// 828D1C74: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 828D1C78: 3D60828D  lis r11, -0x7d73
	ctx.r[11].s64 = -2104688640;
	// 828D1C7C: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 828D1C80: 388B5F38  addi r4, r11, 0x5f38
	ctx.r[4].s64 = ctx.r[11].s64 + 24376;
	// 828D1C84: 4BFFEC15  bl 0x828d0898
	ctx.lr = 0x828D1C88;
	sub_828D0898(ctx, base);
	// 828D1C88: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D1C8C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D1C90: 3A0100F0  addi r16, r1, 0xf0
	ctx.r[16].s64 = ctx.r[1].s64 + 240;
	// 828D1C94: 808B0B08  lwz r4, 0xb08(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2824 as u32) ) } as u64;
	// 828D1C98: 48521D71  bl 0x82df3a08
	ctx.lr = 0x828D1C9C;
	sub_82DF3A08(ctx, base);
	// 828D1C9C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D1CA0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D1CA4: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 828D1CA8: 4858A4B1  bl 0x82e5c158
	ctx.lr = 0x828D1CAC;
	sub_82E5C158(ctx, base);
	// 828D1CAC: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 828D1CB0: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828D1CB4: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 828D1CB8: 388B8540  addi r4, r11, -0x7ac0
	ctx.r[4].s64 = ctx.r[11].s64 + -31424;
	// 828D1CBC: 4BFFEBDD  bl 0x828d0898
	ctx.lr = 0x828D1CC0;
	sub_828D0898(ctx, base);
	// 828D1CC0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D1CC4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D1CC8: 3A0100F0  addi r16, r1, 0xf0
	ctx.r[16].s64 = ctx.r[1].s64 + 240;
	// 828D1CCC: 808B0B24  lwz r4, 0xb24(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2852 as u32) ) } as u64;
	// 828D1CD0: 48521D39  bl 0x82df3a08
	ctx.lr = 0x828D1CD4;
	sub_82DF3A08(ctx, base);
	// 828D1CD4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D1CD8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D1CDC: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 828D1CE0: 4858A479  bl 0x82e5c158
	ctx.lr = 0x828D1CE4;
	sub_82E5C158(ctx, base);
	// 828D1CE4: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 828D1CE8: 3D60828D  lis r11, -0x7d73
	ctx.r[11].s64 = -2104688640;
	// 828D1CEC: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 828D1CF0: 388B6200  addi r4, r11, 0x6200
	ctx.r[4].s64 = ctx.r[11].s64 + 25088;
	// 828D1CF4: 4BFFEBA5  bl 0x828d0898
	ctx.lr = 0x828D1CF8;
	sub_828D0898(ctx, base);
	// 828D1CF8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D1CFC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D1D00: 3A0100F0  addi r16, r1, 0xf0
	ctx.r[16].s64 = ctx.r[1].s64 + 240;
	// 828D1D04: 808B0B30  lwz r4, 0xb30(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2864 as u32) ) } as u64;
	// 828D1D08: 48521D01  bl 0x82df3a08
	ctx.lr = 0x828D1D0C;
	sub_82DF3A08(ctx, base);
	// 828D1D0C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D1D10: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D1D14: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 828D1D18: 4858A441  bl 0x82e5c158
	ctx.lr = 0x828D1D1C;
	sub_82E5C158(ctx, base);
	// 828D1D1C: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 828D1D20: 3D60828D  lis r11, -0x7d73
	ctx.r[11].s64 = -2104688640;
	// 828D1D24: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 828D1D28: 388B6270  addi r4, r11, 0x6270
	ctx.r[4].s64 = ctx.r[11].s64 + 25200;
	// 828D1D2C: 4BFFEB6D  bl 0x828d0898
	ctx.lr = 0x828D1D30;
	sub_828D0898(ctx, base);
	// 828D1D30: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D1D34: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D1D38: 3A0100F0  addi r16, r1, 0xf0
	ctx.r[16].s64 = ctx.r[1].s64 + 240;
	// 828D1D3C: 808B0B88  lwz r4, 0xb88(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2952 as u32) ) } as u64;
	// 828D1D40: 48521CC9  bl 0x82df3a08
	ctx.lr = 0x828D1D44;
	sub_82DF3A08(ctx, base);
	// 828D1D44: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D1D48: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D1D4C: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 828D1D50: 4858A409  bl 0x82e5c158
	ctx.lr = 0x828D1D54;
	sub_82E5C158(ctx, base);
	// 828D1D54: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 828D1D58: 3D60828D  lis r11, -0x7d73
	ctx.r[11].s64 = -2104688640;
	// 828D1D5C: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 828D1D60: 388B6540  addi r4, r11, 0x6540
	ctx.r[4].s64 = ctx.r[11].s64 + 25920;
	// 828D1D64: 4BFFEB35  bl 0x828d0898
	ctx.lr = 0x828D1D68;
	sub_828D0898(ctx, base);
	// 828D1D68: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D1D6C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D1D70: 3A0100F0  addi r16, r1, 0xf0
	ctx.r[16].s64 = ctx.r[1].s64 + 240;
	// 828D1D74: 808B0B28  lwz r4, 0xb28(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2856 as u32) ) } as u64;
	// 828D1D78: 48521C91  bl 0x82df3a08
	ctx.lr = 0x828D1D7C;
	sub_82DF3A08(ctx, base);
	// 828D1D7C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D1D80: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D1D84: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 828D1D88: 4858A3D1  bl 0x82e5c158
	ctx.lr = 0x828D1D8C;
	sub_82E5C158(ctx, base);
	// 828D1D8C: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 828D1D90: 3D60828D  lis r11, -0x7d73
	ctx.r[11].s64 = -2104688640;
	// 828D1D94: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 828D1D98: 388B6460  addi r4, r11, 0x6460
	ctx.r[4].s64 = ctx.r[11].s64 + 25696;
	// 828D1D9C: 4BFFEAFD  bl 0x828d0898
	ctx.lr = 0x828D1DA0;
	sub_828D0898(ctx, base);
	// 828D1DA0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D1DA4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D1DA8: 3A0100F0  addi r16, r1, 0xf0
	ctx.r[16].s64 = ctx.r[1].s64 + 240;
	// 828D1DAC: 808B0B34  lwz r4, 0xb34(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2868 as u32) ) } as u64;
	// 828D1DB0: 48521C59  bl 0x82df3a08
	ctx.lr = 0x828D1DB4;
	sub_82DF3A08(ctx, base);
	// 828D1DB4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D1DB8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D1DBC: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 828D1DC0: 4858A399  bl 0x82e5c158
	ctx.lr = 0x828D1DC4;
	sub_82E5C158(ctx, base);
	// 828D1DC4: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 828D1DC8: 3D60828D  lis r11, -0x7d73
	ctx.r[11].s64 = -2104688640;
	// 828D1DCC: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 828D1DD0: 388B6620  addi r4, r11, 0x6620
	ctx.r[4].s64 = ctx.r[11].s64 + 26144;
	// 828D1DD4: 4BF972D5  bl 0x828690a8
	ctx.lr = 0x828D1DD8;
	sub_828690A8(ctx, base);
	// 828D1DD8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D1DDC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D1DE0: 3A0100F0  addi r16, r1, 0xf0
	ctx.r[16].s64 = ctx.r[1].s64 + 240;
	// 828D1DE4: 808B0B2C  lwz r4, 0xb2c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2860 as u32) ) } as u64;
	// 828D1DE8: 48521C21  bl 0x82df3a08
	ctx.lr = 0x828D1DEC;
	sub_82DF3A08(ctx, base);
	// 828D1DEC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D1DF0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D1DF4: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 828D1DF8: 4858A361  bl 0x82e5c158
	ctx.lr = 0x828D1DFC;
	sub_82E5C158(ctx, base);
	// 828D1DFC: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 828D1E00: 3D60828D  lis r11, -0x7d73
	ctx.r[11].s64 = -2104688640;
	// 828D1E04: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 828D1E08: 388B66A0  addi r4, r11, 0x66a0
	ctx.r[4].s64 = ctx.r[11].s64 + 26272;
	// 828D1E0C: 4BFFEA8D  bl 0x828d0898
	ctx.lr = 0x828D1E10;
	sub_828D0898(ctx, base);
	// 828D1E10: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D1E14: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D1E18: 3A0100F0  addi r16, r1, 0xf0
	ctx.r[16].s64 = ctx.r[1].s64 + 240;
	// 828D1E1C: 808B605C  lwz r4, 0x605c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24668 as u32) ) } as u64;
	// 828D1E20: 48521BE9  bl 0x82df3a08
	ctx.lr = 0x828D1E24;
	sub_82DF3A08(ctx, base);
	// 828D1E24: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D1E28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D1E2C: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 828D1E30: 4858A329  bl 0x82e5c158
	ctx.lr = 0x828D1E34;
	sub_82E5C158(ctx, base);
	// 828D1E34: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 828D1E38: 3D60828D  lis r11, -0x7d73
	ctx.r[11].s64 = -2104688640;
	// 828D1E3C: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 828D1E40: 388B64D0  addi r4, r11, 0x64d0
	ctx.r[4].s64 = ctx.r[11].s64 + 25808;
	// 828D1E44: 4BFFEA55  bl 0x828d0898
	ctx.lr = 0x828D1E48;
	sub_828D0898(ctx, base);
	// 828D1E48: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D1E4C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D1E50: 3A0100F0  addi r16, r1, 0xf0
	ctx.r[16].s64 = ctx.r[1].s64 + 240;
	// 828D1E54: 808B6060  lwz r4, 0x6060(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24672 as u32) ) } as u64;
	// 828D1E58: 48521BB1  bl 0x82df3a08
	ctx.lr = 0x828D1E5C;
	sub_82DF3A08(ctx, base);
	// 828D1E5C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D1E60: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D1E64: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 828D1E68: 4858A2F1  bl 0x82e5c158
	ctx.lr = 0x828D1E6C;
	sub_82E5C158(ctx, base);
	// 828D1E6C: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 828D1E70: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 828D1E74: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 828D1E78: 388BC038  addi r4, r11, -0x3fc8
	ctx.r[4].s64 = ctx.r[11].s64 + -16328;
	// 828D1E7C: 4BF9722D  bl 0x828690a8
	ctx.lr = 0x828D1E80;
	sub_828690A8(ctx, base);
	// 828D1E80: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D1E84: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D1E88: 3A0100F0  addi r16, r1, 0xf0
	ctx.r[16].s64 = ctx.r[1].s64 + 240;
	// 828D1E8C: 808B0B70  lwz r4, 0xb70(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2928 as u32) ) } as u64;
	// 828D1E90: 48521B79  bl 0x82df3a08
	ctx.lr = 0x828D1E94;
	sub_82DF3A08(ctx, base);
	// 828D1E94: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D1E98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D1E9C: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 828D1EA0: 4858A2B9  bl 0x82e5c158
	ctx.lr = 0x828D1EA4;
	sub_82E5C158(ctx, base);
	// 828D1EA4: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 828D1EA8: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 828D1EAC: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 828D1EB0: 388B10F8  addi r4, r11, 0x10f8
	ctx.r[4].s64 = ctx.r[11].s64 + 4344;
	// 828D1EB4: 4BF971F5  bl 0x828690a8
	ctx.lr = 0x828D1EB8;
	sub_828690A8(ctx, base);
	// 828D1EB8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D1EBC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D1EC0: 3A0100F0  addi r16, r1, 0xf0
	ctx.r[16].s64 = ctx.r[1].s64 + 240;
	// 828D1EC4: 808B0B7C  lwz r4, 0xb7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2940 as u32) ) } as u64;
	// 828D1EC8: 48521B41  bl 0x82df3a08
	ctx.lr = 0x828D1ECC;
	sub_82DF3A08(ctx, base);
	// 828D1ECC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D1ED0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D1ED4: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 828D1ED8: 4858A281  bl 0x82e5c158
	ctx.lr = 0x828D1EDC;
	sub_82E5C158(ctx, base);
	// 828D1EDC: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 828D1EE0: 3D608294  lis r11, -0x7d6c
	ctx.r[11].s64 = -2104229888;
	// 828D1EE4: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 828D1EE8: 388BBFA0  addi r4, r11, -0x4060
	ctx.r[4].s64 = ctx.r[11].s64 + -16480;
	// 828D1EEC: 4BF971BD  bl 0x828690a8
	ctx.lr = 0x828D1EF0;
	sub_828690A8(ctx, base);
	// 828D1EF0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D1EF4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D1EF8: 3A0100F0  addi r16, r1, 0xf0
	ctx.r[16].s64 = ctx.r[1].s64 + 240;
	// 828D1EFC: 808B0B98  lwz r4, 0xb98(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2968 as u32) ) } as u64;
	// 828D1F00: 48521B09  bl 0x82df3a08
	ctx.lr = 0x828D1F04;
	sub_82DF3A08(ctx, base);
	// 828D1F04: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D1F08: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D1F0C: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 828D1F10: 4858A249  bl 0x82e5c158
	ctx.lr = 0x828D1F14;
	sub_82E5C158(ctx, base);
	// 828D1F14: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 828D1F18: 3D60828D  lis r11, -0x7d73
	ctx.r[11].s64 = -2104688640;
	// 828D1F1C: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 828D1F20: 388B7E20  addi r4, r11, 0x7e20
	ctx.r[4].s64 = ctx.r[11].s64 + 32288;
	// 828D1F24: 4BF97185  bl 0x828690a8
	ctx.lr = 0x828D1F28;
	sub_828690A8(ctx, base);
	// 828D1F28: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D1F2C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D1F30: 3A0100F0  addi r16, r1, 0xf0
	ctx.r[16].s64 = ctx.r[1].s64 + 240;
	// 828D1F34: 808B0B50  lwz r4, 0xb50(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2896 as u32) ) } as u64;
	// 828D1F38: 48521AD1  bl 0x82df3a08
	ctx.lr = 0x828D1F3C;
	sub_82DF3A08(ctx, base);
	// 828D1F3C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D1F40: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D1F44: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 828D1F48: 4858A211  bl 0x82e5c158
	ctx.lr = 0x828D1F4C;
	sub_82E5C158(ctx, base);
	// 828D1F4C: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 828D1F50: 3D608292  lis r11, -0x7d6e
	ctx.r[11].s64 = -2104360960;
	// 828D1F54: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 828D1F58: 388B4378  addi r4, r11, 0x4378
	ctx.r[4].s64 = ctx.r[11].s64 + 17272;
	// 828D1F5C: 4BF9714D  bl 0x828690a8
	ctx.lr = 0x828D1F60;
	sub_828690A8(ctx, base);
	// 828D1F60: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D1F64: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D1F68: 3A0100F0  addi r16, r1, 0xf0
	ctx.r[16].s64 = ctx.r[1].s64 + 240;
	// 828D1F6C: 808B0B58  lwz r4, 0xb58(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2904 as u32) ) } as u64;
	// 828D1F70: 48521A99  bl 0x82df3a08
	ctx.lr = 0x828D1F74;
	sub_82DF3A08(ctx, base);
	// 828D1F74: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D1F78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D1F7C: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 828D1F80: 4858A1D9  bl 0x82e5c158
	ctx.lr = 0x828D1F84;
	sub_82E5C158(ctx, base);
	// 828D1F84: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 828D1F88: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 828D1F8C: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 828D1F90: 388B55E8  addi r4, r11, 0x55e8
	ctx.r[4].s64 = ctx.r[11].s64 + 21992;
	// 828D1F94: 4BF97115  bl 0x828690a8
	ctx.lr = 0x828D1F98;
	sub_828690A8(ctx, base);
	// 828D1F98: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D1F9C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D1FA0: 3A0100F0  addi r16, r1, 0xf0
	ctx.r[16].s64 = ctx.r[1].s64 + 240;
	// 828D1FA4: 808B0B5C  lwz r4, 0xb5c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2908 as u32) ) } as u64;
	// 828D1FA8: 48521A61  bl 0x82df3a08
	ctx.lr = 0x828D1FAC;
	sub_82DF3A08(ctx, base);
	// 828D1FAC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D1FB0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D1FB4: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 828D1FB8: 4858A1A1  bl 0x82e5c158
	ctx.lr = 0x828D1FBC;
	sub_82E5C158(ctx, base);
	// 828D1FBC: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 828D1FC0: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 828D1FC4: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 828D1FC8: 388B8DD8  addi r4, r11, -0x7228
	ctx.r[4].s64 = ctx.r[11].s64 + -29224;
	// 828D1FCC: 4BF970DD  bl 0x828690a8
	ctx.lr = 0x828D1FD0;
	sub_828690A8(ctx, base);
	// 828D1FD0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D1FD4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D1FD8: 3A0100F0  addi r16, r1, 0xf0
	ctx.r[16].s64 = ctx.r[1].s64 + 240;
	// 828D1FDC: 808B0B60  lwz r4, 0xb60(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2912 as u32) ) } as u64;
	// 828D1FE0: 48521A29  bl 0x82df3a08
	ctx.lr = 0x828D1FE4;
	sub_82DF3A08(ctx, base);
	// 828D1FE4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D1FE8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D1FEC: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 828D1FF0: 4858A169  bl 0x82e5c158
	ctx.lr = 0x828D1FF4;
	sub_82E5C158(ctx, base);
	// 828D1FF4: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 828D1FF8: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 828D1FFC: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 828D2000: 388B9EF8  addi r4, r11, -0x6108
	ctx.r[4].s64 = ctx.r[11].s64 + -24840;
	// 828D2004: 4BF970A5  bl 0x828690a8
	ctx.lr = 0x828D2008;
	sub_828690A8(ctx, base);
	// 828D2008: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D200C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D2010: 3A0100F0  addi r16, r1, 0xf0
	ctx.r[16].s64 = ctx.r[1].s64 + 240;
	// 828D2014: 808B0B64  lwz r4, 0xb64(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2916 as u32) ) } as u64;
	// 828D2018: 485219F1  bl 0x82df3a08
	ctx.lr = 0x828D201C;
	sub_82DF3A08(ctx, base);
	// 828D201C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D2020: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D2024: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 828D2028: 4858A131  bl 0x82e5c158
	ctx.lr = 0x828D202C;
	sub_82E5C158(ctx, base);
	// 828D202C: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 828D2030: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 828D2034: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 828D2038: 388B4700  addi r4, r11, 0x4700
	ctx.r[4].s64 = ctx.r[11].s64 + 18176;
	// 828D203C: 4BF9706D  bl 0x828690a8
	ctx.lr = 0x828D2040;
	sub_828690A8(ctx, base);
	// 828D2040: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D2044: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D2048: 3A0100F0  addi r16, r1, 0xf0
	ctx.r[16].s64 = ctx.r[1].s64 + 240;
	// 828D204C: 808B0B68  lwz r4, 0xb68(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2920 as u32) ) } as u64;
	// 828D2050: 485219B9  bl 0x82df3a08
	ctx.lr = 0x828D2054;
	sub_82DF3A08(ctx, base);
	// 828D2054: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D2058: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D205C: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 828D2060: 4858A0F9  bl 0x82e5c158
	ctx.lr = 0x828D2064;
	sub_82E5C158(ctx, base);
	// 828D2064: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 828D2068: 3D608294  lis r11, -0x7d6c
	ctx.r[11].s64 = -2104229888;
	// 828D206C: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 828D2070: 388B8D88  addi r4, r11, -0x7278
	ctx.r[4].s64 = ctx.r[11].s64 + -29304;
	// 828D2074: 4BF97035  bl 0x828690a8
	ctx.lr = 0x828D2078;
	sub_828690A8(ctx, base);
	// 828D2078: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D207C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D2080: 3A0100F0  addi r16, r1, 0xf0
	ctx.r[16].s64 = ctx.r[1].s64 + 240;
	// 828D2084: 808B0B6C  lwz r4, 0xb6c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2924 as u32) ) } as u64;
	// 828D2088: 48521981  bl 0x82df3a08
	ctx.lr = 0x828D208C;
	sub_82DF3A08(ctx, base);
	// 828D208C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D2090: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D2094: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 828D2098: 4858A0C1  bl 0x82e5c158
	ctx.lr = 0x828D209C;
	sub_82E5C158(ctx, base);
	// 828D209C: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 828D20A0: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 828D20A4: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 828D20A8: 388B8648  addi r4, r11, -0x79b8
	ctx.r[4].s64 = ctx.r[11].s64 + -31160;
	// 828D20AC: 4BF96FFD  bl 0x828690a8
	ctx.lr = 0x828D20B0;
	sub_828690A8(ctx, base);
	// 828D20B0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D20B4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D20B8: 3A0100F0  addi r16, r1, 0xf0
	ctx.r[16].s64 = ctx.r[1].s64 + 240;
	// 828D20BC: 808B0BA4  lwz r4, 0xba4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2980 as u32) ) } as u64;
	// 828D20C0: 48521949  bl 0x82df3a08
	ctx.lr = 0x828D20C4;
	sub_82DF3A08(ctx, base);
	// 828D20C4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D20C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D20CC: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 828D20D0: 4858A089  bl 0x82e5c158
	ctx.lr = 0x828D20D4;
	sub_82E5C158(ctx, base);
	// 828D20D4: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 828D20D8: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 828D20DC: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 828D20E0: 388B8420  addi r4, r11, -0x7be0
	ctx.r[4].s64 = ctx.r[11].s64 + -31712;
	// 828D20E4: 4BF96FC5  bl 0x828690a8
	ctx.lr = 0x828D20E8;
	sub_828690A8(ctx, base);
	// 828D20E8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D20EC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D20F0: 3A0100F0  addi r16, r1, 0xf0
	ctx.r[16].s64 = ctx.r[1].s64 + 240;
	// 828D20F4: 808B0BA8  lwz r4, 0xba8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2984 as u32) ) } as u64;
	// 828D20F8: 48521911  bl 0x82df3a08
	ctx.lr = 0x828D20FC;
	sub_82DF3A08(ctx, base);
	// 828D20FC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D2100: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D2104: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 828D2108: 4858A051  bl 0x82e5c158
	ctx.lr = 0x828D210C;
	sub_82E5C158(ctx, base);
	// 828D210C: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 828D2110: 3D60828D  lis r11, -0x7d73
	ctx.r[11].s64 = -2104688640;
	// 828D2114: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 828D2118: 388B65B0  addi r4, r11, 0x65b0
	ctx.r[4].s64 = ctx.r[11].s64 + 26032;
	// 828D211C: 4BFFE77D  bl 0x828d0898
	ctx.lr = 0x828D2120;
	sub_828D0898(ctx, base);
	// 828D2120: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D2124: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D2128: 808B0BC0  lwz r4, 0xbc0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3008 as u32) ) } as u64;
	// 828D212C: 3A0100F0  addi r16, r1, 0xf0
	ctx.r[16].s64 = ctx.r[1].s64 + 240;
	// 828D2130: 485218D9  bl 0x82df3a08
	ctx.lr = 0x828D2134;
	sub_82DF3A08(ctx, base);
	// 828D2134: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D2138: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D213C: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 828D2140: 4858A019  bl 0x82e5c158
	ctx.lr = 0x828D2144;
	sub_82E5C158(ctx, base);
	// 828D2144: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D2148: 80910AF0  lwz r4, 0xaf0(r17)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(2800 as u32) ) } as u64;
	// 828D214C: 485218BD  bl 0x82df3a08
	ctx.lr = 0x828D2150;
	sub_82DF3A08(ctx, base);
	// 828D2150: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828D2154: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828D2158: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828D215C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828D2160: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D2164: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828D2168: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828D216C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828D2170: 4858C7F1  bl 0x82e5e960
	ctx.lr = 0x828D2174;
	sub_82E5E960(ctx, base);
	// 828D2174: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 828D2178: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D217C: 419A0008  beq cr6, 0x828d2184
	if ctx.cr[6].eq {
	pc = 0x828D2184; continue 'dispatch;
	}
	// 828D2180: 4B9EE711  bl 0x822c0890
	ctx.lr = 0x828D2184;
	sub_822C0890(ctx, base);
	// 828D2184: 817D0164  lwz r11, 0x164(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(356 as u32) ) } as u64;
	// 828D2188: 3BDD0164  addi r30, r29, 0x164
	ctx.r[30].s64 = ctx.r[29].s64 + 356;
	// 828D218C: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D2190: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D2194: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D2198: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D219C: 4E800421  bctrl
	ctx.lr = 0x828D21A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D21A0: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 828D21A4: 3D608294  lis r11, -0x7d6c
	ctx.r[11].s64 = -2104229888;
	// 828D21A8: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 828D21AC: 388BD8C8  addi r4, r11, -0x2738
	ctx.r[4].s64 = ctx.r[11].s64 + -10040;
	// 828D21B0: 4BF96EF9  bl 0x828690a8
	ctx.lr = 0x828D21B4;
	sub_828690A8(ctx, base);
	// 828D21B4: 3F80832D  lis r28, -0x7cd3
	ctx.r[28].s64 = -2094202880;
	// 828D21B8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D21BC: 3A2100F0  addi r17, r1, 0xf0
	ctx.r[17].s64 = ctx.r[1].s64 + 240;
	// 828D21C0: 809C0BD8  lwz r4, 0xbd8(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(3032 as u32) ) } as u64;
	// 828D21C4: 48521845  bl 0x82df3a08
	ctx.lr = 0x828D21C8;
	sub_82DF3A08(ctx, base);
	// 828D21C8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D21CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D21D0: 7E258B78  mr r5, r17
	ctx.r[5].u64 = ctx.r[17].u64;
	// 828D21D4: 48589F85  bl 0x82e5c158
	ctx.lr = 0x828D21D8;
	sub_82E5C158(ctx, base);
	// 828D21D8: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 828D21DC: 3D608294  lis r11, -0x7d6c
	ctx.r[11].s64 = -2104229888;
	// 828D21E0: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 828D21E4: 388BE1E0  addi r4, r11, -0x1e20
	ctx.r[4].s64 = ctx.r[11].s64 + -7712;
	// 828D21E8: 4BF96EC1  bl 0x828690a8
	ctx.lr = 0x828D21EC;
	sub_828690A8(ctx, base);
	// 828D21EC: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D21F0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D21F4: 3A2100F0  addi r17, r1, 0xf0
	ctx.r[17].s64 = ctx.r[1].s64 + 240;
	// 828D21F8: 808B0BDC  lwz r4, 0xbdc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3036 as u32) ) } as u64;
	// 828D21FC: 4852180D  bl 0x82df3a08
	ctx.lr = 0x828D2200;
	sub_82DF3A08(ctx, base);
	// 828D2200: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D2204: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D2208: 7E258B78  mr r5, r17
	ctx.r[5].u64 = ctx.r[17].u64;
	// 828D220C: 48589F4D  bl 0x82e5c158
	ctx.lr = 0x828D2210;
	sub_82E5C158(ctx, base);
	// 828D2210: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 828D2214: 3D608294  lis r11, -0x7d6c
	ctx.r[11].s64 = -2104229888;
	// 828D2218: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 828D221C: 388BDE20  addi r4, r11, -0x21e0
	ctx.r[4].s64 = ctx.r[11].s64 + -8672;
	// 828D2220: 4BF96E89  bl 0x828690a8
	ctx.lr = 0x828D2224;
	sub_828690A8(ctx, base);
	// 828D2224: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D2228: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D222C: 3A2100F0  addi r17, r1, 0xf0
	ctx.r[17].s64 = ctx.r[1].s64 + 240;
	// 828D2230: 808B0BE0  lwz r4, 0xbe0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3040 as u32) ) } as u64;
	// 828D2234: 485217D5  bl 0x82df3a08
	ctx.lr = 0x828D2238;
	sub_82DF3A08(ctx, base);
	// 828D2238: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D223C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D2240: 7E258B78  mr r5, r17
	ctx.r[5].u64 = ctx.r[17].u64;
	// 828D2244: 48589F15  bl 0x82e5c158
	ctx.lr = 0x828D2248;
	sub_82E5C158(ctx, base);
	// 828D2248: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 828D224C: 3D608294  lis r11, -0x7d6c
	ctx.r[11].s64 = -2104229888;
	// 828D2250: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 828D2254: 388BE810  addi r4, r11, -0x17f0
	ctx.r[4].s64 = ctx.r[11].s64 + -6128;
	// 828D2258: 4BF96E51  bl 0x828690a8
	ctx.lr = 0x828D225C;
	sub_828690A8(ctx, base);
	// 828D225C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D2260: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D2264: 3A2100F0  addi r17, r1, 0xf0
	ctx.r[17].s64 = ctx.r[1].s64 + 240;
	// 828D2268: 808B0BE8  lwz r4, 0xbe8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3048 as u32) ) } as u64;
	// 828D226C: 4852179D  bl 0x82df3a08
	ctx.lr = 0x828D2270;
	sub_82DF3A08(ctx, base);
	// 828D2270: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D2274: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D2278: 7E258B78  mr r5, r17
	ctx.r[5].u64 = ctx.r[17].u64;
	// 828D227C: 48589EDD  bl 0x82e5c158
	ctx.lr = 0x828D2280;
	sub_82E5C158(ctx, base);
	// 828D2280: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D2284: 809C0BD8  lwz r4, 0xbd8(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(3032 as u32) ) } as u64;
	// 828D2288: 48521781  bl 0x82df3a08
	ctx.lr = 0x828D228C;
	sub_82DF3A08(ctx, base);
	// 828D228C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828D2290: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828D2294: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828D2298: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 828D229C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D22A0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828D22A4: 4858C6BD  bl 0x82e5e960
	ctx.lr = 0x828D22A8;
	sub_82E5E960(ctx, base);
	// 828D22A8: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 828D22AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D22B0: 419A0008  beq cr6, 0x828d22b8
	if ctx.cr[6].eq {
	pc = 0x828D22B8; continue 'dispatch;
	}
	// 828D22B4: 4B9EE5DD  bl 0x822c0890
	ctx.lr = 0x828D22B8;
	sub_822C0890(ctx, base);
	// 828D22B8: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 828D22BC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D22C0: 38A00192  li r5, 0x192
	ctx.r[5].s64 = 402;
	// 828D22C4: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 828D22C8: 4B9EE111  bl 0x822c03d8
	ctx.lr = 0x828D22CC;
	sub_822C03D8(ctx, base);
	// 828D22CC: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828D22D0: 41820040  beq 0x828d2310
	if ctx.cr[0].eq {
	pc = 0x828D2310; continue 'dispatch;
	}
	// 828D22D4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D22D8: 4BF19E89  bl 0x827ec160
	ctx.lr = 0x828D22DC;
	sub_827EC160(ctx, base);
	// 828D22DC: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D22E0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828D22E4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828D22E8: 816B0050  lwz r11, 0x50(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 828D22EC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D22F0: 4E800421  bctrl
	ctx.lr = 0x828D22F4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D22F4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828D22F8: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 828D22FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D2300: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 828D2304: 480504BD  bl 0x829227c0
	ctx.lr = 0x828D2308;
	sub_829227C0(ctx, base);
	// 828D2308: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D230C: 48000008  b 0x828d2314
	pc = 0x828D2314; continue 'dispatch;
	// 828D2310: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D2314: 387D0368  addi r3, r29, 0x368
	ctx.r[3].s64 = ctx.r[29].s64 + 872;
	// 828D2318: 4BF96CA1  bl 0x82868fb8
	ctx.lr = 0x828D231C;
	sub_82868FB8(ctx, base);
	// 828D231C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D2320: 4BC40779  bl 0x82512a98
	ctx.lr = 0x828D2324;
	sub_82512A98(ctx, base);
	// 828D2324: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 828D2328: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D232C: 38A00198  li r5, 0x198
	ctx.r[5].s64 = 408;
	// 828D2330: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 828D2334: 4B9EE0A5  bl 0x822c03d8
	ctx.lr = 0x828D2338;
	sub_822C03D8(ctx, base);
	// 828D2338: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828D233C: 41820020  beq 0x828d235c
	if ctx.cr[0].eq {
	pc = 0x828D235C; continue 'dispatch;
	}
	// 828D2340: 2B120000  cmplwi cr6, r18, 0
	ctx.cr[6].compare_u32(ctx.r[18].u32, 0 as u32, &mut ctx.xer);
	// 828D2344: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828D2348: 409A0008  bne cr6, 0x828d2350
	if !ctx.cr[6].eq {
	pc = 0x828D2350; continue 'dispatch;
	}
	// 828D234C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D2350: 480002B1  bl 0x828d2600
	ctx.lr = 0x828D2354;
	sub_828D2600(ctx, base);
	// 828D2354: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D2358: 48000008  b 0x828d2360
	pc = 0x828D2360; continue 'dispatch;
	// 828D235C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D2360: 387D0360  addi r3, r29, 0x360
	ctx.r[3].s64 = ctx.r[29].s64 + 864;
	// 828D2364: 4BFFDBB5  bl 0x828cff18
	ctx.lr = 0x828D2368;
	sub_828CFF18(ctx, base);
	// 828D2368: 807D0360  lwz r3, 0x360(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(864 as u32) ) } as u64;
	// 828D236C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D2370: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828D2374: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D2378: 4E800421  bctrl
	ctx.lr = 0x828D237C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D237C: 7E649B78  mr r4, r19
	ctx.r[4].u64 = ctx.r[19].u64;
	// 828D2380: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D2384: 4803BC7D  bl 0x8290e000
	ctx.lr = 0x828D2388;
	sub_8290E000(ctx, base);
	// 828D2388: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 828D238C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D2390: 38A001A1  li r5, 0x1a1
	ctx.r[5].s64 = 417;
	// 828D2394: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 828D2398: 4B9EE041  bl 0x822c03d8
	ctx.lr = 0x828D239C;
	sub_822C03D8(ctx, base);
	// 828D239C: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828D23A0: 41820040  beq 0x828d23e0
	if ctx.cr[0].eq {
	pc = 0x828D23E0; continue 'dispatch;
	}
	// 828D23A4: 2B120000  cmplwi cr6, r18, 0
	ctx.cr[6].compare_u32(ctx.r[18].u32, 0 as u32, &mut ctx.xer);
	// 828D23A8: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 828D23AC: 409A0008  bne cr6, 0x828d23b4
	if !ctx.cr[6].eq {
	pc = 0x828D23B4; continue 'dispatch;
	}
	// 828D23B0: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828D23B4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D23B8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D23BC: 816B0150  lwz r11, 0x150(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(336 as u32) ) } as u64;
	// 828D23C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D23C4: 4E800421  bctrl
	ctx.lr = 0x828D23C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D23C8: 38A30034  addi r5, r3, 0x34
	ctx.r[5].s64 = ctx.r[3].s64 + 52;
	// 828D23CC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828D23D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D23D4: 4807184D  bl 0x82943c20
	ctx.lr = 0x828D23D8;
	sub_82943C20(ctx, base);
	// 828D23D8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D23DC: 48000008  b 0x828d23e4
	pc = 0x828D23E4; continue 'dispatch;
	// 828D23E0: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 828D23E4: 93C10068  stw r30, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[30].u32 ) };
	// 828D23E8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828D23EC: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 828D23F0: 4BF94599  bl 0x82866988
	ctx.lr = 0x828D23F4;
	sub_82866988(ctx, base);
	// 828D23F4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828D23F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828D23FC: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 828D2400: 4B9EDC01  bl 0x822c0000
	ctx.lr = 0x828D2404;
	sub_822C0000(ctx, base);
	// 828D2404: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 828D2408: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 828D240C: 4BF95FC5  bl 0x828683d0
	ctx.lr = 0x828D2410;
	sub_828683D0(ctx, base);
	// 828D2410: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D2414: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828D2418: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D241C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D2420: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828D2424: 419A0024  beq cr6, 0x828d2448
	if ctx.cr[6].eq {
	pc = 0x828D2448; continue 'dispatch;
	}
	// 828D2428: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828D242C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828D2430: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D2434: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828D2438: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828D243C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D2440: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D2444: 4082FFE8  bne 0x828d242c
	if !ctx.cr[0].eq {
	pc = 0x828D242C; continue 'dispatch;
	}
	// 828D2448: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828D244C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828D2450: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D2454: 48039095  bl 0x8290b4e8
	ctx.lr = 0x828D2458;
	sub_8290B4E8(ctx, base);
	// 828D2458: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 828D245C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D2460: 419A0008  beq cr6, 0x828d2468
	if ctx.cr[6].eq {
	pc = 0x828D2468; continue 'dispatch;
	}
	// 828D2464: 4B9EE42D  bl 0x822c0890
	ctx.lr = 0x828D2468;
	sub_822C0890(ctx, base);
	// 828D2468: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828D246C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D2470: 419A0008  beq cr6, 0x828d2478
	if ctx.cr[6].eq {
	pc = 0x828D2478; continue 'dispatch;
	}
	// 828D2474: 4B9EE41D  bl 0x822c0890
	ctx.lr = 0x828D2478;
	sub_822C0890(ctx, base);
	// 828D2478: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D247C: C0390000  lfs f1, 0(r25)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828D2480: 4803BFD1  bl 0x8290e450
	ctx.lr = 0x828D2484;
	sub_8290E450(ctx, base);
	// 828D2484: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D2488: 4BF19CD9  bl 0x827ec160
	ctx.lr = 0x828D248C;
	sub_827EC160(ctx, base);
	// 828D248C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D2490: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 828D2494: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D2498: 4E800421  bctrl
	ctx.lr = 0x828D249C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D249C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828D24A0: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 828D24A4: C0970018  lfs f4, 0x18(r23)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(24 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 828D24A8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D24AC: C0770014  lfs f3, 0x14(r23)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(20 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 828D24B0: C0570010  lfs f2, 0x10(r23)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(16 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 828D24B4: C03B0000  lfs f1, 0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828D24B8: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828D24BC: C00AFD2C  lfs f0, -0x2d4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-724 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D24C0: ECAD002A  fadds f5, f13, f0
	ctx.f[5].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 828D24C4: 4803DDE5  bl 0x829102a8
	ctx.lr = 0x828D24C8;
	sub_829102A8(ctx, base);
	// 828D24C8: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 828D24CC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D24D0: 38A001AD  li r5, 0x1ad
	ctx.r[5].s64 = 429;
	// 828D24D4: 386000A0  li r3, 0xa0
	ctx.r[3].s64 = 160;
	// 828D24D8: 4B9EDF01  bl 0x822c03d8
	ctx.lr = 0x828D24DC;
	sub_822C03D8(ctx, base);
	// 828D24DC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828D24E0: 41820024  beq 0x828d2504
	if ctx.cr[0].eq {
	pc = 0x828D2504; continue 'dispatch;
	}
	// 828D24E4: 2B120000  cmplwi cr6, r18, 0
	ctx.cr[6].compare_u32(ctx.r[18].u32, 0 as u32, &mut ctx.xer);
	// 828D24E8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828D24EC: 409A0008  bne cr6, 0x828d24f4
	if !ctx.cr[6].eq {
	pc = 0x828D24F4; continue 'dispatch;
	}
	// 828D24F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D24F4: 38B900D8  addi r5, r25, 0xd8
	ctx.r[5].s64 = ctx.r[25].s64 + 216;
	// 828D24F8: 4806DBD9  bl 0x829400d0
	ctx.lr = 0x828D24FC;
	sub_829400D0(ctx, base);
	// 828D24FC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D2500: 48000008  b 0x828d2508
	pc = 0x828D2508; continue 'dispatch;
	// 828D2504: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D2508: 387D0370  addi r3, r29, 0x370
	ctx.r[3].s64 = ctx.r[29].s64 + 880;
	// 828D250C: 4BF95F3D  bl 0x82868448
	ctx.lr = 0x828D2510;
	sub_82868448(ctx, base);
	// 828D2510: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D2514: 4BF19C4D  bl 0x827ec160
	ctx.lr = 0x828D2518;
	sub_827EC160(ctx, base);
	// 828D2518: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D251C: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 828D2520: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D2524: 4E800421  bctrl
	ctx.lr = 0x828D2528;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D2528: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828D252C: 394100A0  addi r10, r1, 0xa0
	ctx.r[10].s64 = ctx.r[1].s64 + 160;
	// 828D2530: 39200005  li r9, 5
	ctx.r[9].s64 = 5;
	// 828D2534: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 828D2538: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D253C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828D2540: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828D2544: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 828D2548: 4200FFF0  bdnz 0x828d2538
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x828D2538; continue 'dispatch;
	}
	// 828D254C: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 828D2550: 48280E81  bl 0x82b533d0
	ctx.lr = 0x828D2554;
	sub_82B533D0(ctx, base);
	// 828D2554: 39600015  li r11, 0x15
	ctx.r[11].s64 = 21;
	// 828D2558: C00100A0  lfs f0, 0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D255C: 93E100C0  stw r31, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[31].u32 ) };
	// 828D2560: 916100C4  stw r11, 0xc4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 828D2564: D3E100EC  stfs f31, 0xec(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 828D2568: D00100E4  stfs f0, 0xe4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 828D256C: 930100E8  stw r24, 0xe8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[24].u32 ) };
	// 828D2570: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828D2574: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D2578: 388BC604  addi r4, r11, -0x39fc
	ctx.r[4].s64 = ctx.r[11].s64 + -14844;
	// 828D257C: 83DD0260  lwz r30, 0x260(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(608 as u32) ) } as u64;
	// 828D2580: 48521489  bl 0x82df3a08
	ctx.lr = 0x828D2584;
	sub_82DF3A08(ctx, base);
	// 828D2584: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 828D2588: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D258C: 38E100C0  addi r7, r1, 0xc0
	ctx.r[7].s64 = ctx.r[1].s64 + 192;
	// 828D2590: 7EA6AB78  mr r6, r21
	ctx.r[6].u64 = ctx.r[21].u64;
	// 828D2594: 7E659B78  mr r5, r19
	ctx.r[5].u64 = ctx.r[19].u64;
	// 828D2598: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 828D259C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 828D25A0: 480416A9  bl 0x82913c48
	ctx.lr = 0x828D25A4;
	sub_82913C48(ctx, base);
	// 828D25A4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D25A8: 48520E81  bl 0x82df3428
	ctx.lr = 0x828D25AC;
	sub_82DF3428(ctx, base);
	// 828D25AC: 3D60828D  lis r11, -0x7d73
	ctx.r[11].s64 = -2104688640;
	// 828D25B0: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 828D25B4: 934100A8  stw r26, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[26].u32 ) };
	// 828D25B8: 396BF2A8  addi r11, r11, -0xd58
	ctx.r[11].s64 = ctx.r[11].s64 + -3416;
	// 828D25BC: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 828D25C0: E8A100A8  ld r5, 0xa8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 828D25C4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828D25C8: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828D25CC: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 828D25D0: 4BFFE719  bl 0x828d0ce8
	ctx.lr = 0x828D25D4;
	sub_828D0CE8(ctx, base);
	// 828D25D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D25D8: 388100F0  addi r4, r1, 0xf0
	ctx.r[4].s64 = ctx.r[1].s64 + 240;
	// 828D25DC: 4804033D  bl 0x82912918
	ctx.lr = 0x828D25E0;
	sub_82912918(ctx, base);
	// 828D25E0: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D25E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D25E8: 388B5868  addi r4, r11, 0x5868
	ctx.r[4].s64 = ctx.r[11].s64 + 22632;
	// 828D25EC: 4803FBC5  bl 0x829121b0
	ctx.lr = 0x828D25F0;
	sub_829121B0(ctx, base);
	// 828D25F0: 382101A0  addi r1, r1, 0x1a0
	ctx.r[1].s64 = ctx.r[1].s64 + 416;
	// 828D25F4: CBE1FF70  lfd f31, -0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-144 as u32) ) };
	// 828D25F8: 488D5B90  b 0x831a8188
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D2600(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D2600 size=60
    let mut pc: u32 = 0x828D2600;
    'dispatch: loop {
        match pc {
            0x828D2600 => {
    //   block [0x828D2600..0x828D263C)
	// 828D2600: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D2604: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D2608: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D260C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D2610: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D2614: 48042F8D  bl 0x829155a0
	ctx.lr = 0x828D2618;
	sub_829155A0(ctx, base);
	// 828D2618: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D261C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D2620: 396BED14  addi r11, r11, -0x12ec
	ctx.r[11].s64 = ctx.r[11].s64 + -4844;
	// 828D2624: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D2628: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828D262C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D2630: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D2634: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D2638: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D2640(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D2640 size=88
    let mut pc: u32 = 0x828D2640;
    'dispatch: loop {
        match pc {
            0x828D2640 => {
    //   block [0x828D2640..0x828D2698)
	// 828D2640: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D2644: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D2648: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828D264C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D2650: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D2654: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D2658: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D265C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828D2660: 396BED14  addi r11, r11, -0x12ec
	ctx.r[11].s64 = ctx.r[11].s64 + -4844;
	// 828D2664: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D2668: 48042F21  bl 0x82915588
	ctx.lr = 0x828D266C;
	sub_82915588(ctx, base);
	// 828D266C: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D2670: 4182000C  beq 0x828d267c
	if ctx.cr[0].eq {
	pc = 0x828D267C; continue 'dispatch;
	}
	// 828D2674: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D2678: 4B9EDBF1  bl 0x822c0268
	ctx.lr = 0x828D267C;
	sub_822C0268(ctx, base);
	// 828D267C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D2680: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D2684: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D2688: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D268C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828D2690: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D2694: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D2698(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D2698 size=64
    let mut pc: u32 = 0x828D2698;
    'dispatch: loop {
        match pc {
            0x828D2698 => {
    //   block [0x828D2698..0x828D26D8)
	// 828D2698: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D269C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D26A0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D26A4: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828D26A8: 1D44000C  mulli r10, r4, 0xc
	ctx.r[10].s64 = ctx.r[4].s64 * 12;
	// 828D26AC: 396B131C  addi r11, r11, 0x131c
	ctx.r[11].s64 = ctx.r[11].s64 + 4892;
	// 828D26B0: 38830004  addi r4, r3, 4
	ctx.r[4].s64 = ctx.r[3].s64 + 4;
	// 828D26B4: 7CAA5A14  add r5, r10, r11
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828D26B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D26BC: 4BF989A5  bl 0x8286b060
	ctx.lr = 0x828D26C0;
	sub_8286B060(ctx, base);
	// 828D26C0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828D26C4: 806B0010  lwz r3, 0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 828D26C8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828D26CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D26D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D26D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D26D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828D26D8 size=488
    let mut pc: u32 = 0x828D26D8;
    'dispatch: loop {
        match pc {
            0x828D26D8 => {
    //   block [0x828D26D8..0x828D28C0)
	// 828D26D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D26DC: 488D5A75  bl 0x831a8150
	ctx.lr = 0x828D26E0;
	sub_831A8130(ctx, base);
	// 828D26E0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D26E4: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 828D26E8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828D26EC: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 828D26F0: 4BFFC2F1  bl 0x828ce9e0
	ctx.lr = 0x828D26F4;
	sub_828CE9E0(ctx, base);
	// 828D26F4: 834D0000  lwz r26, 0(r13)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D26F8: 3B200014  li r25, 0x14
	ctx.r[25].s64 = 20;
	// 828D26FC: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 828D2700: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 828D2704: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828D2708: 7C79D02E  lwzx r3, r25, r26
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 828D270C: 485CE025  bl 0x82ea0730
	ctx.lr = 0x828D2710;
	sub_82EA0730(ctx, base);
	// 828D2710: 3AC00020  li r22, 0x20
	ctx.r[22].s64 = 32;
	// 828D2714: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828D2718: B2C30004  sth r22, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[22].u16 ) };
	// 828D271C: C1BB0000  lfs f13, 0(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828D2720: 3BEB131C  addi r31, r11, 0x131c
	ctx.r[31].s64 = ctx.r[11].s64 + 4892;
	// 828D2724: C01F0008  lfs f0, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D2728: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 828D272C: 48647AC5  bl 0x82f1a1f0
	ctx.lr = 0x828D2730;
	sub_82F1A1F0(ctx, base);
	// 828D2730: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 828D2734: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 828D2738: 4182000C  beq 0x828d2744
	if ctx.cr[0].eq {
	pc = 0x828D2744; continue 'dispatch;
	}
	// 828D273C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D2740: 4BA15B09  bl 0x822e8248
	ctx.lr = 0x828D2744;
	sub_822E8248(ctx, base);
	// 828D2744: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D2748: 839E0000  lwz r28, 0(r30)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D274C: 38BF0004  addi r5, r31, 4
	ctx.r[5].s64 = ctx.r[31].s64 + 4;
	// 828D2750: 80970000  lwz r4, 0(r23)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D2754: 485428DD  bl 0x82e15030
	ctx.lr = 0x828D2758;
	sub_82E15030(ctx, base);
	// 828D2758: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 828D275C: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 828D2760: 815C00C8  lwz r10, 0xc8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(200 as u32) ) } as u64;
	// 828D2764: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D2768: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828D276C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D2770: 80CB6820  lwz r6, 0x6820(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26656 as u32) ) } as u64;
	// 828D2774: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828D2778: 4E800421  bctrl
	ctx.lr = 0x828D277C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D277C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828D2780: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828D2784: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D2788: 419A000C  beq cr6, 0x828d2794
	if ctx.cr[6].eq {
	pc = 0x828D2794; continue 'dispatch;
	}
	// 828D278C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828D2790: 4BA15AD9  bl 0x822e8268
	ctx.lr = 0x828D2794;
	sub_822E8268(ctx, base);
	// 828D2794: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D2798: 3B180004  addi r24, r24, 4
	ctx.r[24].s64 = ctx.r[24].s64 + 4;
	// 828D279C: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 828D27A0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828D27A4: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 828D27A8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D27AC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828D27B0: 4BF98971  bl 0x8286b120
	ctx.lr = 0x828D27B4;
	sub_8286B120(ctx, base);
	// 828D27B4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828D27B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D27BC: 480366F5  bl 0x82908eb0
	ctx.lr = 0x828D27C0;
	sub_82908EB0(ctx, base);
	// 828D27C0: 38802012  li r4, 0x2012
	ctx.r[4].s64 = 8210;
	// 828D27C4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828D27C8: 4BBBC9E9  bl 0x8248f1b0
	ctx.lr = 0x828D27CC;
	sub_8248F1B0(ctx, base);
	// 828D27CC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828D27D0: 419A000C  beq cr6, 0x828d27dc
	if ctx.cr[6].eq {
	pc = 0x828D27DC; continue 'dispatch;
	}
	// 828D27D4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D27D8: 4BA15A91  bl 0x822e8268
	ctx.lr = 0x828D27DC;
	sub_822E8268(ctx, base);
	// 828D27DC: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 828D27E0: 7C79D02E  lwzx r3, r25, r26
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 828D27E4: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 828D27E8: 485CDF49  bl 0x82ea0730
	ctx.lr = 0x828D27EC;
	sub_82EA0730(ctx, base);
	// 828D27EC: B2C30004  sth r22, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[22].u16 ) };
	// 828D27F0: C01F0014  lfs f0, 0x14(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D27F4: C1BB0000  lfs f13, 0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828D27F8: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 828D27FC: 486479F5  bl 0x82f1a1f0
	ctx.lr = 0x828D2800;
	sub_82F1A1F0(ctx, base);
	// 828D2800: 7C7C1B79  or. r28, r3, r3
	ctx.r[28].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 828D2804: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 828D2808: 4182000C  beq 0x828d2814
	if ctx.cr[0].eq {
	pc = 0x828D2814; continue 'dispatch;
	}
	// 828D280C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828D2810: 4BA15A39  bl 0x822e8248
	ctx.lr = 0x828D2814;
	sub_822E8248(ctx, base);
	// 828D2814: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D2818: 83BE0000  lwz r29, 0(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D281C: 38BF0010  addi r5, r31, 0x10
	ctx.r[5].s64 = ctx.r[31].s64 + 16;
	// 828D2820: 80970000  lwz r4, 0(r23)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D2824: 4854280D  bl 0x82e15030
	ctx.lr = 0x828D2828;
	sub_82E15030(ctx, base);
	// 828D2828: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 828D282C: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 828D2830: 815D00C8  lwz r10, 0xc8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(200 as u32) ) } as u64;
	// 828D2834: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 828D2838: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 828D283C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D2840: 80CB681C  lwz r6, 0x681c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26652 as u32) ) } as u64;
	// 828D2844: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828D2848: 4E800421  bctrl
	ctx.lr = 0x828D284C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D284C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828D2850: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D2854: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D2858: 419A000C  beq cr6, 0x828d2864
	if ctx.cr[6].eq {
	pc = 0x828D2864; continue 'dispatch;
	}
	// 828D285C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828D2860: 4BA15A09  bl 0x822e8268
	ctx.lr = 0x828D2864;
	sub_822E8268(ctx, base);
	// 828D2864: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828D2868: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828D286C: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 828D2870: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 828D2874: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D2878: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828D287C: 4BF988A5  bl 0x8286b120
	ctx.lr = 0x828D2880;
	sub_8286B120(ctx, base);
	// 828D2880: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828D2884: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D2888: 48036629  bl 0x82908eb0
	ctx.lr = 0x828D288C;
	sub_82908EB0(ctx, base);
	// 828D288C: 38802012  li r4, 0x2012
	ctx.r[4].s64 = 8210;
	// 828D2890: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828D2894: 4BBBC91D  bl 0x8248f1b0
	ctx.lr = 0x828D2898;
	sub_8248F1B0(ctx, base);
	// 828D2898: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828D289C: 419A000C  beq cr6, 0x828d28a8
	if ctx.cr[6].eq {
	pc = 0x828D28A8; continue 'dispatch;
	}
	// 828D28A0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828D28A4: 4BA159C5  bl 0x822e8268
	ctx.lr = 0x828D28A8;
	sub_822E8268(ctx, base);
	// 828D28A8: 80770004  lwz r3, 4(r23)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D28AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D28B0: 419A0008  beq cr6, 0x828d28b8
	if ctx.cr[6].eq {
	pc = 0x828D28B8; continue 'dispatch;
	}
	// 828D28B4: 4B9EDFDD  bl 0x822c0890
	ctx.lr = 0x828D28B8;
	sub_822C0890(ctx, base);
	// 828D28B8: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828D28BC: 488D58E4  b 0x831a81a0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D28C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D28C0 size=60
    let mut pc: u32 = 0x828D28C0;
    'dispatch: loop {
        match pc {
            0x828D28C0 => {
    //   block [0x828D28C0..0x828D28FC)
	// 828D28C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D28C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D28C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D28CC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D28D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D28D4: 48044605  bl 0x82916ed8
	ctx.lr = 0x828D28D8;
	sub_82916ED8(ctx, base);
	// 828D28D8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D28DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D28E0: 396BED5C  addi r11, r11, -0x12a4
	ctx.r[11].s64 = ctx.r[11].s64 + -4772;
	// 828D28E4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D28E8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828D28EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D28F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D28F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D28F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D2900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D2900 size=88
    let mut pc: u32 = 0x828D2900;
    'dispatch: loop {
        match pc {
            0x828D2900 => {
    //   block [0x828D2900..0x828D2958)
	// 828D2900: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D2904: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D2908: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828D290C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D2910: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D2914: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D2918: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D291C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828D2920: 396BED5C  addi r11, r11, -0x12a4
	ctx.r[11].s64 = ctx.r[11].s64 + -4772;
	// 828D2924: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D2928: 48044241  bl 0x82916b68
	ctx.lr = 0x828D292C;
	sub_82916B68(ctx, base);
	// 828D292C: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D2930: 4182000C  beq 0x828d293c
	if ctx.cr[0].eq {
	pc = 0x828D293C; continue 'dispatch;
	}
	// 828D2934: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D2938: 4B9ED931  bl 0x822c0268
	ctx.lr = 0x828D293C;
	sub_822C0268(ctx, base);
	// 828D293C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D2940: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D2944: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D2948: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D294C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828D2950: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D2954: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D2958(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828D2958 size=152
    let mut pc: u32 = 0x828D2958;
    'dispatch: loop {
        match pc {
            0x828D2958 => {
    //   block [0x828D2958..0x828D29F0)
	// 828D2958: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D295C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D2960: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D2964: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D2968: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D296C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D2970: 48044429  bl 0x82916d98
	ctx.lr = 0x828D2974;
	sub_82916D98(ctx, base);
	// 828D2974: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828D2978: 396000D0  li r11, 0xd0
	ctx.r[11].s64 = 208;
	// 828D297C: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 828D2980: 13E958C7  vcmpequd (lvx128) v31, v9, v11
	tmp.u32 = ctx.r[9].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D29F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828D29F0 size=372
    let mut pc: u32 = 0x828D29F0;
    'dispatch: loop {
        match pc {
            0x828D29F0 => {
    //   block [0x828D29F0..0x828D2B64)
	// 828D29F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D29F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D29F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D29FC: 3981FFF0  addi r12, r1, -0x10
	ctx.r[12].s64 = ctx.r[1].s64 + -16;
	// 828D2A00: 488D6075  bl 0x831a8a74
	ctx.lr = 0x828D2A04;
	sub_831A8A40(ctx, base);
	// 828D2A04: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D2A08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D2A0C: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 828D2A10: 48070949  bl 0x82943358
	ctx.lr = 0x828D2A14;
	sub_82943358(ctx, base);
	// 828D2A14: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 828D2A18: 4806EA19  bl 0x82941430
	ctx.lr = 0x828D2A1C;
	sub_82941430(ctx, base);
	// 828D2A1C: 387F007C  addi r3, r31, 0x7c
	ctx.r[3].s64 = ctx.r[31].s64 + 124;
	// 828D2A20: 4806FED1  bl 0x829428f0
	ctx.lr = 0x828D2A24;
	sub_829428F0(ctx, base);
	// 828D2A24: 387F008C  addi r3, r31, 0x8c
	ctx.r[3].s64 = ctx.r[31].s64 + 140;
	// 828D2A28: 4806DDD1  bl 0x829407f8
	ctx.lr = 0x828D2A2C;
	sub_829407F8(ctx, base);
	// 828D2A2C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828D2A30: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 828D2A34: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 828D2A38: 3D008208  lis r8, -0x7df8
	ctx.r[8].s64 = -2113404928;
	// 828D2A3C: 3CE08208  lis r7, -0x7df8
	ctx.r[7].s64 = -2113404928;
	// 828D2A40: C0AB0A94  lfs f5, 0xa94(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2708 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 828D2A44: 3CC08201  lis r6, -0x7dff
	ctx.r[6].s64 = -2113863680;
	// 828D2A48: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828D2A4C: C14A0A90  lfs f10, 0xa90(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2704 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 828D2A50: C1296150  lfs f9, 0x6150(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(24912 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 828D2A54: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 828D2A58: C10889AC  lfs f8, -0x7654(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 828D2A5C: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 828D2A60: C0076154  lfs f0, 0x6154(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(24916 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D2A64: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 828D2A68: C1A69524  lfs f13, -0x6adc(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828D2A6C: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 828D2A70: C18BE830  lfs f12, -0x17d0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828D2A74: 3CC08201  lis r6, -0x7dff
	ctx.r[6].s64 = -2113863680;
	// 828D2A78: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828D2A7C: C08A0A98  lfs f4, 0xa98(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2712 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 828D2A80: C0699594  lfs f3, -0x6a6c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27244 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 828D2A84: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 828D2A88: C048FD2C  lfs f2, -0x2d4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-724 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 828D2A8C: 3D208203  lis r9, -0x7dfd
	ctx.r[9].s64 = -2113732608;
	// 828D2A90: C167A2EC  lfs f11, -0x5d14(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-23828 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 828D2A94: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 828D2A98: C0269C28  lfs f1, -0x63d8(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-25560 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828D2A9C: 3CE08208  lis r7, -0x7df8
	ctx.r[7].s64 = -2113404928;
	// 828D2AA0: C0EB08A8  lfs f7, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 828D2AA4: 3CC08201  lis r6, -0x7dff
	ctx.r[6].s64 = -2113863680;
	// 828D2AA8: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 828D2AAC: C3EA9590  lfs f31, -0x6a70(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27248 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828D2AB0: C3C97A10  lfs f30, 0x7a10(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(31248 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 828D2AB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D2AB8: C3A8959C  lfs f29, -0x6a64(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27236 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 828D2ABC: C0C7614C  lfs f6, 0x614c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(24908 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 828D2AC0: C386C664  lfs f28, -0x399c(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-14748 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 828D2AC4: C36B7BC4  lfs f27, 0x7bc4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31684 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 828D2AC8: D0BF0000  stfs f5, 0(r31)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 828D2ACC: D15F0004  stfs f10, 4(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 828D2AD0: D15F0008  stfs f10, 8(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 828D2AD4: D13F000C  stfs f9, 0xc(r31)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 828D2AD8: D11F0010  stfs f8, 0x10(r31)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 828D2ADC: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 828D2AE0: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 828D2AE4: D1BF001C  stfs f13, 0x1c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 828D2AE8: D19F0020  stfs f12, 0x20(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 828D2AEC: D09F0024  stfs f4, 0x24(r31)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 828D2AF0: D07F0028  stfs f3, 0x28(r31)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 828D2AF4: D11F002C  stfs f8, 0x2c(r31)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 828D2AF8: D05F0030  stfs f2, 0x30(r31)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 828D2AFC: D17F0034  stfs f11, 0x34(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 828D2B00: D03F0038  stfs f1, 0x38(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 828D2B04: D19F003C  stfs f12, 0x3c(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 828D2B08: D0FF0040  stfs f7, 0x40(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 828D2B0C: D3FF0044  stfs f31, 0x44(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 828D2B10: D0FF0048  stfs f7, 0x48(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 828D2B14: D3DF004C  stfs f30, 0x4c(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 828D2B18: D3BF0054  stfs f29, 0x54(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 828D2B1C: D19F0050  stfs f12, 0x50(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 828D2B20: D0DF0060  stfs f6, 0x60(r31)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828D2B24: D01F0064  stfs f0, 0x64(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 828D2B28: D13F0068  stfs f9, 0x68(r31)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 828D2B2C: D0DF007C  stfs f6, 0x7c(r31)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 828D2B30: D39F0080  stfs f28, 0x80(r31)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 828D2B34: D1BF0084  stfs f13, 0x84(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 828D2B38: D1BF0088  stfs f13, 0x88(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 828D2B3C: D17F008C  stfs f11, 0x8c(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 828D2B40: D17F0090  stfs f11, 0x90(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 828D2B44: D37F0094  stfs f27, 0x94(r31)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 828D2B48: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828D2B4C: 3981FFF0  addi r12, r1, -0x10
	ctx.r[12].s64 = ctx.r[1].s64 + -16;
	// 828D2B50: 488D5F71  bl 0x831a8ac0
	ctx.lr = 0x828D2B54;
	sub_831A8A8C(ctx, base);
	// 828D2B54: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D2B58: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D2B5C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D2B60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D2B68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828D2B68 size=192
    let mut pc: u32 = 0x828D2B68;
    'dispatch: loop {
        match pc {
            0x828D2B68 => {
    //   block [0x828D2B68..0x828D2C28)
	// 828D2B68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D2B6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D2B70: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D2B74: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D2B78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D2B7C: 48087395  bl 0x82959f10
	ctx.lr = 0x828D2B80;
	sub_82959F10(ctx, base);
	// 828D2B80: 387F0078  addi r3, r31, 0x78
	ctx.r[3].s64 = ctx.r[31].s64 + 120;
	// 828D2B84: 48085075  bl 0x82957bf8
	ctx.lr = 0x828D2B88;
	sub_82957BF8(ctx, base);
	// 828D2B88: 387F0098  addi r3, r31, 0x98
	ctx.r[3].s64 = ctx.r[31].s64 + 152;
	// 828D2B8C: 48085505  bl 0x82958090
	ctx.lr = 0x828D2B90;
	sub_82958090(ctx, base);
	// 828D2B90: 387F00BC  addi r3, r31, 0xbc
	ctx.r[3].s64 = ctx.r[31].s64 + 188;
	// 828D2B94: 48082C2D  bl 0x829557c0
	ctx.lr = 0x828D2B98;
	sub_829557C0(ctx, base);
	// 828D2B98: 387F00D8  addi r3, r31, 0xd8
	ctx.r[3].s64 = ctx.r[31].s64 + 216;
	// 828D2B9C: 4806C3CD  bl 0x8293ef68
	ctx.lr = 0x828D2BA0;
	sub_8293EF68(ctx, base);
	// 828D2BA0: 387F00F0  addi r3, r31, 0xf0
	ctx.r[3].s64 = ctx.r[31].s64 + 240;
	// 828D2BA4: 4806E435  bl 0x82940fd8
	ctx.lr = 0x828D2BA8;
	sub_82940FD8(ctx, base);
	// 828D2BA8: 387F00FC  addi r3, r31, 0xfc
	ctx.r[3].s64 = ctx.r[31].s64 + 252;
	// 828D2BAC: 480703A5  bl 0x82942f50
	ctx.lr = 0x828D2BB0;
	sub_82942F50(ctx, base);
	// 828D2BB0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828D2BB4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828D2BB8: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 828D2BBC: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 828D2BC0: 3CE08203  lis r7, -0x7dfd
	ctx.r[7].s64 = -2113732608;
	// 828D2BC4: 3CC08208  lis r6, -0x7df8
	ctx.r[6].s64 = -2113404928;
	// 828D2BC8: C00B9524  lfs f0, -0x6adc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D2BCC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D2BD0: C1AA08A8  lfs f13, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828D2BD4: C1899450  lfs f12, -0x6bb0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828D2BD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D2BDC: C168A1C4  lfs f11, -0x5e3c(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 828D2BE0: 997F0048  stb r11, 0x48(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[11].u8 ) };
	// 828D2BE4: C1477BC4  lfs f10, 0x7bc4(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(31684 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 828D2BE8: 997F0058  stb r11, 0x58(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[11].u8 ) };
	// 828D2BEC: C126E830  lfs f9, -0x17d0(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-6096 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 828D2BF0: 997F0068  stb r11, 0x68(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u8 ) };
	// 828D2BF4: D01F0088  stfs f0, 0x88(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 828D2BF8: D1BF008C  stfs f13, 0x8c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 828D2BFC: D19F0090  stfs f12, 0x90(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 828D2C00: D1BF0094  stfs f13, 0x94(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 828D2C04: D17F00B4  stfs f11, 0xb4(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 828D2C08: D15F00B8  stfs f10, 0xb8(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 828D2C0C: D01F00F0  stfs f0, 0xf0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 828D2C10: D13F00F4  stfs f9, 0xf4(r31)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 828D2C14: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828D2C18: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D2C1C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D2C20: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D2C24: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D2C28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828D2C28 size=1540
    let mut pc: u32 = 0x828D2C28;
    'dispatch: loop {
        match pc {
            0x828D2C28 => {
    //   block [0x828D2C28..0x828D322C)
	// 828D2C28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D2C2C: 488D553D  bl 0x831a8168
	ctx.lr = 0x828D2C30;
	sub_831A8130(ctx, base);
	// 828D2C30: DBA1FFC0  stfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[29].u64 ) };
	// 828D2C34: DBC1FFC8  stfd f30, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 828D2C38: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 828D2C3C: 9421FDD0  stwu r1, -0x230(r1)
	ea = ctx.r[1].u32.wrapping_add(-560 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D2C40: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828D2C44: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D2C48: 3BBE0004  addi r29, r30, 4
	ctx.r[29].s64 = ctx.r[30].s64 + 4;
	// 828D2C4C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D2C50: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D2C54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D2C58: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828D2C5C: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828D2C60: 419A0024  beq cr6, 0x828d2c84
	if ctx.cr[6].eq {
	pc = 0x828D2C84; continue 'dispatch;
	}
	// 828D2C64: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828D2C68: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828D2C6C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D2C70: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828D2C74: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828D2C78: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D2C7C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D2C80: 4082FFE8  bne 0x828d2c68
	if !ctx.cr[0].eq {
	pc = 0x828D2C68; continue 'dispatch;
	}
	// 828D2C84: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828D2C88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D2C8C: 48087E8D  bl 0x8295ab18
	ctx.lr = 0x828D2C90;
	sub_8295AB18(ctx, base);
	// 828D2C90: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 828D2C94: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828D2C98: 388B7A1C  addi r4, r11, 0x7a1c
	ctx.r[4].s64 = ctx.r[11].s64 + 31260;
	// 828D2C9C: 48520D6D  bl 0x82df3a08
	ctx.lr = 0x828D2CA0;
	sub_82DF3A08(ctx, base);
	// 828D2CA0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828D2CA4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D2CA8: 388B1A04  addi r4, r11, 0x1a04
	ctx.r[4].s64 = ctx.r[11].s64 + 6660;
	// 828D2CAC: 48520D5D  bl 0x82df3a08
	ctx.lr = 0x828D2CB0;
	sub_82DF3A08(ctx, base);
	// 828D2CB0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D2CB4: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D2CB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D2CBC: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828D2CC0: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828D2CC4: 419A0024  beq cr6, 0x828d2ce8
	if ctx.cr[6].eq {
	pc = 0x828D2CE8; continue 'dispatch;
	}
	// 828D2CC8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828D2CCC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828D2CD0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D2CD4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828D2CD8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828D2CDC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D2CE0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D2CE4: 4082FFE8  bne 0x828d2ccc
	if !ctx.cr[0].eq {
	pc = 0x828D2CCC; continue 'dispatch;
	}
	// 828D2CE8: 38C10068  addi r6, r1, 0x68
	ctx.r[6].s64 = ctx.r[1].s64 + 104;
	// 828D2CEC: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828D2CF0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828D2CF4: 387F0078  addi r3, r31, 0x78
	ctx.r[3].s64 = ctx.r[31].s64 + 120;
	// 828D2CF8: 48084F19  bl 0x82957c10
	ctx.lr = 0x828D2CFC;
	sub_82957C10(ctx, base);
	// 828D2CFC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D2D00: 48520729  bl 0x82df3428
	ctx.lr = 0x828D2D04;
	sub_82DF3428(ctx, base);
	// 828D2D04: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828D2D08: 48520721  bl 0x82df3428
	ctx.lr = 0x828D2D0C;
	sub_82DF3428(ctx, base);
	// 828D2D0C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D2D10: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D2D14: 388BF094  addi r4, r11, -0xf6c
	ctx.r[4].s64 = ctx.r[11].s64 + -3948;
	// 828D2D18: 48520CF1  bl 0x82df3a08
	ctx.lr = 0x828D2D1C;
	sub_82DF3A08(ctx, base);
	// 828D2D1C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828D2D20: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828D2D24: 388B1B14  addi r4, r11, 0x1b14
	ctx.r[4].s64 = ctx.r[11].s64 + 6932;
	// 828D2D28: 48520CE1  bl 0x82df3a08
	ctx.lr = 0x828D2D2C;
	sub_82DF3A08(ctx, base);
	// 828D2D2C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828D2D30: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 828D2D34: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D2D38: 4BCF77C9  bl 0x825ca500
	ctx.lr = 0x828D2D3C;
	sub_825CA500(ctx, base);
	// 828D2D3C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828D2D40: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828D2D44: 485206E5  bl 0x82df3428
	ctx.lr = 0x828D2D48;
	sub_82DF3428(ctx, base);
	// 828D2D48: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D2D4C: 485206DD  bl 0x82df3428
	ctx.lr = 0x828D2D50;
	sub_82DF3428(ctx, base);
	// 828D2D50: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828D2D54: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D2D58: 388B1AD0  addi r4, r11, 0x1ad0
	ctx.r[4].s64 = ctx.r[11].s64 + 6864;
	// 828D2D5C: 48520CAD  bl 0x82df3a08
	ctx.lr = 0x828D2D60;
	sub_82DF3A08(ctx, base);
	// 828D2D60: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828D2D64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D2D68: 388B1ABC  addi r4, r11, 0x1abc
	ctx.r[4].s64 = ctx.r[11].s64 + 6844;
	// 828D2D6C: 48520C9D  bl 0x82df3a08
	ctx.lr = 0x828D2D70;
	sub_82DF3A08(ctx, base);
	// 828D2D70: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828D2D74: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 828D2D78: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 828D2D7C: 38BF0088  addi r5, r31, 0x88
	ctx.r[5].s64 = ctx.r[31].s64 + 136;
	// 828D2D80: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828D2D84: C3EB9528  lfs f31, -0x6ad8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828D2D88: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828D2D8C: C3CA89AC  lfs f30, -0x7654(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 828D2D90: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828D2D94: C3A9964C  lfs f29, -0x69b4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 828D2D98: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 828D2D9C: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828D2DA0: 4BCD0509  bl 0x825a32a8
	ctx.lr = 0x828D2DA4;
	sub_825A32A8(ctx, base);
	// 828D2DA4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828D2DA8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828D2DAC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D2DB0: 4BCCE9C1  bl 0x825a1770
	ctx.lr = 0x828D2DB4;
	sub_825A1770(ctx, base);
	// 828D2DB4: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 828D2DB8: 48520671  bl 0x82df3428
	ctx.lr = 0x828D2DBC;
	sub_82DF3428(ctx, base);
	// 828D2DBC: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 828D2DC0: 4B9F5EF9  bl 0x822c8cb8
	ctx.lr = 0x828D2DC4;
	sub_822C8CB8(ctx, base);
	// 828D2DC4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D2DC8: 48520661  bl 0x82df3428
	ctx.lr = 0x828D2DCC;
	sub_82DF3428(ctx, base);
	// 828D2DCC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D2DD0: 48520659  bl 0x82df3428
	ctx.lr = 0x828D2DD4;
	sub_82DF3428(ctx, base);
	// 828D2DD4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828D2DD8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D2DDC: 388B1AA0  addi r4, r11, 0x1aa0
	ctx.r[4].s64 = ctx.r[11].s64 + 6816;
	// 828D2DE0: 48520C29  bl 0x82df3a08
	ctx.lr = 0x828D2DE4;
	sub_82DF3A08(ctx, base);
	// 828D2DE4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828D2DE8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D2DEC: 388B1A88  addi r4, r11, 0x1a88
	ctx.r[4].s64 = ctx.r[11].s64 + 6792;
	// 828D2DF0: 48520C19  bl 0x82df3a08
	ctx.lr = 0x828D2DF4;
	sub_82DF3A08(ctx, base);
	// 828D2DF4: 38BF008C  addi r5, r31, 0x8c
	ctx.r[5].s64 = ctx.r[31].s64 + 140;
	// 828D2DF8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D2DFC: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828D2E00: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 828D2E04: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 828D2E08: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828D2E0C: 4BCD049D  bl 0x825a32a8
	ctx.lr = 0x828D2E10;
	sub_825A32A8(ctx, base);
	// 828D2E10: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828D2E14: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828D2E18: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828D2E1C: 4BCCE955  bl 0x825a1770
	ctx.lr = 0x828D2E20;
	sub_825A1770(ctx, base);
	// 828D2E20: 38610128  addi r3, r1, 0x128
	ctx.r[3].s64 = ctx.r[1].s64 + 296;
	// 828D2E24: 48520605  bl 0x82df3428
	ctx.lr = 0x828D2E28;
	sub_82DF3428(ctx, base);
	// 828D2E28: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 828D2E2C: 4B9F5E8D  bl 0x822c8cb8
	ctx.lr = 0x828D2E30;
	sub_822C8CB8(ctx, base);
	// 828D2E30: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D2E34: 485205F5  bl 0x82df3428
	ctx.lr = 0x828D2E38;
	sub_82DF3428(ctx, base);
	// 828D2E38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D2E3C: 485205ED  bl 0x82df3428
	ctx.lr = 0x828D2E40;
	sub_82DF3428(ctx, base);
	// 828D2E40: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828D2E44: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D2E48: 388B1A6C  addi r4, r11, 0x1a6c
	ctx.r[4].s64 = ctx.r[11].s64 + 6764;
	// 828D2E4C: 48520BBD  bl 0x82df3a08
	ctx.lr = 0x828D2E50;
	sub_82DF3A08(ctx, base);
	// 828D2E50: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828D2E54: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D2E58: 388B1A58  addi r4, r11, 0x1a58
	ctx.r[4].s64 = ctx.r[11].s64 + 6744;
	// 828D2E5C: 48520BAD  bl 0x82df3a08
	ctx.lr = 0x828D2E60;
	sub_82DF3A08(ctx, base);
	// 828D2E60: 38BF0090  addi r5, r31, 0x90
	ctx.r[5].s64 = ctx.r[31].s64 + 144;
	// 828D2E64: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D2E68: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828D2E6C: 38610170  addi r3, r1, 0x170
	ctx.r[3].s64 = ctx.r[1].s64 + 368;
	// 828D2E70: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 828D2E74: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828D2E78: 4BCD0431  bl 0x825a32a8
	ctx.lr = 0x828D2E7C;
	sub_825A32A8(ctx, base);
	// 828D2E7C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828D2E80: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828D2E84: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828D2E88: 4BCCE8E9  bl 0x825a1770
	ctx.lr = 0x828D2E8C;
	sub_825A1770(ctx, base);
	// 828D2E8C: 386101A8  addi r3, r1, 0x1a8
	ctx.r[3].s64 = ctx.r[1].s64 + 424;
	// 828D2E90: 48520599  bl 0x82df3428
	ctx.lr = 0x828D2E94;
	sub_82DF3428(ctx, base);
	// 828D2E94: 38610188  addi r3, r1, 0x188
	ctx.r[3].s64 = ctx.r[1].s64 + 392;
	// 828D2E98: 4B9F5E21  bl 0x822c8cb8
	ctx.lr = 0x828D2E9C;
	sub_822C8CB8(ctx, base);
	// 828D2E9C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D2EA0: 48520589  bl 0x82df3428
	ctx.lr = 0x828D2EA4;
	sub_82DF3428(ctx, base);
	// 828D2EA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D2EA8: 48520581  bl 0x82df3428
	ctx.lr = 0x828D2EAC;
	sub_82DF3428(ctx, base);
	// 828D2EAC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828D2EB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D2EB4: 388B1A3C  addi r4, r11, 0x1a3c
	ctx.r[4].s64 = ctx.r[11].s64 + 6716;
	// 828D2EB8: 48520B51  bl 0x82df3a08
	ctx.lr = 0x828D2EBC;
	sub_82DF3A08(ctx, base);
	// 828D2EBC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828D2EC0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D2EC4: 388B1A24  addi r4, r11, 0x1a24
	ctx.r[4].s64 = ctx.r[11].s64 + 6692;
	// 828D2EC8: 48520B41  bl 0x82df3a08
	ctx.lr = 0x828D2ECC;
	sub_82DF3A08(ctx, base);
	// 828D2ECC: 38BF0094  addi r5, r31, 0x94
	ctx.r[5].s64 = ctx.r[31].s64 + 148;
	// 828D2ED0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D2ED4: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828D2ED8: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 828D2EDC: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 828D2EE0: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828D2EE4: 4BCD03C5  bl 0x825a32a8
	ctx.lr = 0x828D2EE8;
	sub_825A32A8(ctx, base);
	// 828D2EE8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828D2EEC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828D2EF0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828D2EF4: 4BCCE87D  bl 0x825a1770
	ctx.lr = 0x828D2EF8;
	sub_825A1770(ctx, base);
	// 828D2EF8: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 828D2EFC: 4852052D  bl 0x82df3428
	ctx.lr = 0x828D2F00;
	sub_82DF3428(ctx, base);
	// 828D2F00: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 828D2F04: 4B9F5DB5  bl 0x822c8cb8
	ctx.lr = 0x828D2F08;
	sub_822C8CB8(ctx, base);
	// 828D2F08: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D2F0C: 4852051D  bl 0x82df3428
	ctx.lr = 0x828D2F10;
	sub_82DF3428(ctx, base);
	// 828D2F10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D2F14: 48520515  bl 0x82df3428
	ctx.lr = 0x828D2F18;
	sub_82DF3428(ctx, base);
	// 828D2F18: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D2F1C: 4BCF6DB5  bl 0x825c9cd0
	ctx.lr = 0x828D2F20;
	sub_825C9CD0(ctx, base);
	// 828D2F20: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D2F24: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D2F28: 388BF080  addi r4, r11, -0xf80
	ctx.r[4].s64 = ctx.r[11].s64 + -3968;
	// 828D2F2C: 48520ADD  bl 0x82df3a08
	ctx.lr = 0x828D2F30;
	sub_82DF3A08(ctx, base);
	// 828D2F30: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D2F34: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D2F38: 388BF06C  addi r4, r11, -0xf94
	ctx.r[4].s64 = ctx.r[11].s64 + -3988;
	// 828D2F3C: 48520ACD  bl 0x82df3a08
	ctx.lr = 0x828D2F40;
	sub_82DF3A08(ctx, base);
	// 828D2F40: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D2F44: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D2F48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D2F4C: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 828D2F50: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 828D2F54: 419A0024  beq cr6, 0x828d2f78
	if ctx.cr[6].eq {
	pc = 0x828D2F78; continue 'dispatch;
	}
	// 828D2F58: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828D2F5C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828D2F60: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D2F64: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828D2F68: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828D2F6C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D2F70: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D2F74: 4082FFE8  bne 0x828d2f5c
	if !ctx.cr[0].eq {
	pc = 0x828D2F5C; continue 'dispatch;
	}
	// 828D2F78: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828D2F7C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828D2F80: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 828D2F84: 387F0098  addi r3, r31, 0x98
	ctx.r[3].s64 = ctx.r[31].s64 + 152;
	// 828D2F88: 480851E9  bl 0x82958170
	ctx.lr = 0x828D2F8C;
	sub_82958170(ctx, base);
	// 828D2F8C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D2F90: 48520499  bl 0x82df3428
	ctx.lr = 0x828D2F94;
	sub_82DF3428(ctx, base);
	// 828D2F94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D2F98: 48520491  bl 0x82df3428
	ctx.lr = 0x828D2F9C;
	sub_82DF3428(ctx, base);
	// 828D2F9C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D2FA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D2FA4: 388BF058  addi r4, r11, -0xfa8
	ctx.r[4].s64 = ctx.r[11].s64 + -4008;
	// 828D2FA8: 48520A61  bl 0x82df3a08
	ctx.lr = 0x828D2FAC;
	sub_82DF3A08(ctx, base);
	// 828D2FAC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D2FB0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D2FB4: 388BF04C  addi r4, r11, -0xfb4
	ctx.r[4].s64 = ctx.r[11].s64 + -4020;
	// 828D2FB8: 48520A51  bl 0x82df3a08
	ctx.lr = 0x828D2FBC;
	sub_82DF3A08(ctx, base);
	// 828D2FBC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828D2FC0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828D2FC4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D2FC8: 4BCF7539  bl 0x825ca500
	ctx.lr = 0x828D2FCC;
	sub_825CA500(ctx, base);
	// 828D2FCC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828D2FD0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D2FD4: 48520455  bl 0x82df3428
	ctx.lr = 0x828D2FD8;
	sub_82DF3428(ctx, base);
	// 828D2FD8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D2FDC: 4852044D  bl 0x82df3428
	ctx.lr = 0x828D2FE0;
	sub_82DF3428(ctx, base);
	// 828D2FE0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D2FE4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D2FE8: 388BF038  addi r4, r11, -0xfc8
	ctx.r[4].s64 = ctx.r[11].s64 + -4040;
	// 828D2FEC: 48520A1D  bl 0x82df3a08
	ctx.lr = 0x828D2FF0;
	sub_82DF3A08(ctx, base);
	// 828D2FF0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D2FF4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828D2FF8: 388BF028  addi r4, r11, -0xfd8
	ctx.r[4].s64 = ctx.r[11].s64 + -4056;
	// 828D2FFC: 48520A0D  bl 0x82df3a08
	ctx.lr = 0x828D3000;
	sub_82DF3A08(ctx, base);
	// 828D3000: 38BF00B4  addi r5, r31, 0xb4
	ctx.r[5].s64 = ctx.r[31].s64 + 180;
	// 828D3004: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828D3008: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828D300C: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 828D3010: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 828D3014: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828D3018: 4BCD0291  bl 0x825a32a8
	ctx.lr = 0x828D301C;
	sub_825A32A8(ctx, base);
	// 828D301C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828D3020: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828D3024: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 828D3028: 4BCCE749  bl 0x825a1770
	ctx.lr = 0x828D302C;
	sub_825A1770(ctx, base);
	// 828D302C: 38610168  addi r3, r1, 0x168
	ctx.r[3].s64 = ctx.r[1].s64 + 360;
	// 828D3030: 485203F9  bl 0x82df3428
	ctx.lr = 0x828D3034;
	sub_82DF3428(ctx, base);
	// 828D3034: 38610148  addi r3, r1, 0x148
	ctx.r[3].s64 = ctx.r[1].s64 + 328;
	// 828D3038: 4B9F5C81  bl 0x822c8cb8
	ctx.lr = 0x828D303C;
	sub_822C8CB8(ctx, base);
	// 828D303C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828D3040: 485203E9  bl 0x82df3428
	ctx.lr = 0x828D3044;
	sub_82DF3428(ctx, base);
	// 828D3044: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D3048: 485203E1  bl 0x82df3428
	ctx.lr = 0x828D304C;
	sub_82DF3428(ctx, base);
	// 828D304C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D3050: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D3054: 388BF014  addi r4, r11, -0xfec
	ctx.r[4].s64 = ctx.r[11].s64 + -4076;
	// 828D3058: 485209B1  bl 0x82df3a08
	ctx.lr = 0x828D305C;
	sub_82DF3A08(ctx, base);
	// 828D305C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D3060: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828D3064: 388BF000  addi r4, r11, -0x1000
	ctx.r[4].s64 = ctx.r[11].s64 + -4096;
	// 828D3068: 485209A1  bl 0x82df3a08
	ctx.lr = 0x828D306C;
	sub_82DF3A08(ctx, base);
	// 828D306C: 38BF00B8  addi r5, r31, 0xb8
	ctx.r[5].s64 = ctx.r[31].s64 + 184;
	// 828D3070: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828D3074: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828D3078: 386101B0  addi r3, r1, 0x1b0
	ctx.r[3].s64 = ctx.r[1].s64 + 432;
	// 828D307C: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 828D3080: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828D3084: 4BCD0225  bl 0x825a32a8
	ctx.lr = 0x828D3088;
	sub_825A32A8(ctx, base);
	// 828D3088: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828D308C: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 828D3090: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828D3094: 4BCCE6DD  bl 0x825a1770
	ctx.lr = 0x828D3098;
	sub_825A1770(ctx, base);
	// 828D3098: 386101E8  addi r3, r1, 0x1e8
	ctx.r[3].s64 = ctx.r[1].s64 + 488;
	// 828D309C: 4852038D  bl 0x82df3428
	ctx.lr = 0x828D30A0;
	sub_82DF3428(ctx, base);
	// 828D30A0: 386101C8  addi r3, r1, 0x1c8
	ctx.r[3].s64 = ctx.r[1].s64 + 456;
	// 828D30A4: 4B9F5C15  bl 0x822c8cb8
	ctx.lr = 0x828D30A8;
	sub_822C8CB8(ctx, base);
	// 828D30A8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828D30AC: 4852037D  bl 0x82df3428
	ctx.lr = 0x828D30B0;
	sub_82DF3428(ctx, base);
	// 828D30B0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D30B4: 48520375  bl 0x82df3428
	ctx.lr = 0x828D30B8;
	sub_82DF3428(ctx, base);
	// 828D30B8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D30BC: 4BCF6C15  bl 0x825c9cd0
	ctx.lr = 0x828D30C0;
	sub_825C9CD0(ctx, base);
	// 828D30C0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D30C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D30C8: 388BEFE8  addi r4, r11, -0x1018
	ctx.r[4].s64 = ctx.r[11].s64 + -4120;
	// 828D30CC: 4852093D  bl 0x82df3a08
	ctx.lr = 0x828D30D0;
	sub_82DF3A08(ctx, base);
	// 828D30D0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828D30D4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D30D8: 388B1980  addi r4, r11, 0x1980
	ctx.r[4].s64 = ctx.r[11].s64 + 6528;
	// 828D30DC: 4852092D  bl 0x82df3a08
	ctx.lr = 0x828D30E0;
	sub_82DF3A08(ctx, base);
	// 828D30E0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D30E4: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D30E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D30EC: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 828D30F0: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 828D30F4: 419A0024  beq cr6, 0x828d3118
	if ctx.cr[6].eq {
	pc = 0x828D3118; continue 'dispatch;
	}
	// 828D30F8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828D30FC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828D3100: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D3104: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828D3108: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828D310C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D3110: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D3114: 4082FFE8  bne 0x828d30fc
	if !ctx.cr[0].eq {
	pc = 0x828D30FC; continue 'dispatch;
	}
	// 828D3118: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828D311C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828D3120: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 828D3124: 387F00BC  addi r3, r31, 0xbc
	ctx.r[3].s64 = ctx.r[31].s64 + 188;
	// 828D3128: 48082751  bl 0x82955878
	ctx.lr = 0x828D312C;
	sub_82955878(ctx, base);
	// 828D312C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D3130: 485202F9  bl 0x82df3428
	ctx.lr = 0x828D3134;
	sub_82DF3428(ctx, base);
	// 828D3134: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D3138: 485202F1  bl 0x82df3428
	ctx.lr = 0x828D313C;
	sub_82DF3428(ctx, base);
	// 828D313C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D3140: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D3144: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D3148: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828D314C: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828D3150: 419A0024  beq cr6, 0x828d3174
	if ctx.cr[6].eq {
	pc = 0x828D3174; continue 'dispatch;
	}
	// 828D3154: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828D3158: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828D315C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D3160: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828D3164: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828D3168: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D316C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D3170: 4082FFE8  bne 0x828d3158
	if !ctx.cr[0].eq {
	pc = 0x828D3158; continue 'dispatch;
	}
	// 828D3174: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828D3178: 387F00D8  addi r3, r31, 0xd8
	ctx.r[3].s64 = ctx.r[31].s64 + 216;
	// 828D317C: 4806CA2D  bl 0x8293fba8
	ctx.lr = 0x828D3180;
	sub_8293FBA8(ctx, base);
	// 828D3180: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D3184: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D3188: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D318C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828D3190: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828D3194: 419A0024  beq cr6, 0x828d31b8
	if ctx.cr[6].eq {
	pc = 0x828D31B8; continue 'dispatch;
	}
	// 828D3198: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828D319C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828D31A0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D31A4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828D31A8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828D31AC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D31B0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D31B4: 4082FFE8  bne 0x828d319c
	if !ctx.cr[0].eq {
	pc = 0x828D319C; continue 'dispatch;
	}
	// 828D31B8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828D31BC: 387F00F0  addi r3, r31, 0xf0
	ctx.r[3].s64 = ctx.r[31].s64 + 240;
	// 828D31C0: 4806E1E9  bl 0x829413a8
	ctx.lr = 0x828D31C4;
	sub_829413A8(ctx, base);
	// 828D31C4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D31C8: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D31CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D31D0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828D31D4: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828D31D8: 419A0024  beq cr6, 0x828d31fc
	if ctx.cr[6].eq {
	pc = 0x828D31FC; continue 'dispatch;
	}
	// 828D31DC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828D31E0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828D31E4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D31E8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828D31EC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828D31F0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D31F4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D31F8: 4082FFE8  bne 0x828d31e0
	if !ctx.cr[0].eq {
	pc = 0x828D31E0; continue 'dispatch;
	}
	// 828D31FC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828D3200: 387F00FC  addi r3, r31, 0xfc
	ctx.r[3].s64 = ctx.r[31].s64 + 252;
	// 828D3204: 480700CD  bl 0x829432d0
	ctx.lr = 0x828D3208;
	sub_829432D0(ctx, base);
	// 828D3208: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D320C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D3210: 419A0008  beq cr6, 0x828d3218
	if ctx.cr[6].eq {
	pc = 0x828D3218; continue 'dispatch;
	}
	// 828D3214: 4B9ED67D  bl 0x822c0890
	ctx.lr = 0x828D3218;
	sub_822C0890(ctx, base);
	// 828D3218: 38210230  addi r1, r1, 0x230
	ctx.r[1].s64 = ctx.r[1].s64 + 560;
	// 828D321C: CBA1FFC0  lfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 828D3220: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 828D3224: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 828D3228: 488D4F90  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D3230(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828D3230 size=2640
    let mut pc: u32 = 0x828D3230;
    'dispatch: loop {
        match pc {
            0x828D3230 => {
    //   block [0x828D3230..0x828D3C80)
	// 828D3230: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D3234: 488D4F39  bl 0x831a816c
	ctx.lr = 0x828D3238;
	sub_831A8130(ctx, base);
	// 828D3238: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 828D323C: 488D5831  bl 0x831a8a6c
	ctx.lr = 0x828D3240;
	sub_831A8A40(ctx, base);
	// 828D3240: 9421FA30  stwu r1, -0x5d0(r1)
	ea = ctx.r[1].u32.wrapping_add(-1488 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D3244: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828D3248: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D324C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828D3250: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D3254: 388B1F3C  addi r4, r11, 0x1f3c
	ctx.r[4].s64 = ctx.r[11].s64 + 7996;
	// 828D3258: 485207B1  bl 0x82df3a08
	ctx.lr = 0x828D325C;
	sub_82DF3A08(ctx, base);
	// 828D325C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828D3260: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 828D3264: 388B1F2C  addi r4, r11, 0x1f2c
	ctx.r[4].s64 = ctx.r[11].s64 + 7980;
	// 828D3268: 485207A1  bl 0x82df3a08
	ctx.lr = 0x828D326C;
	sub_82DF3A08(ctx, base);
	// 828D326C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828D3270: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 828D3274: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D3278: 4BCF7289  bl 0x825ca500
	ctx.lr = 0x828D327C;
	sub_825CA500(ctx, base);
	// 828D327C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D3280: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 828D3284: 485201A5  bl 0x82df3428
	ctx.lr = 0x828D3288;
	sub_82DF3428(ctx, base);
	// 828D3288: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D328C: 4852019D  bl 0x82df3428
	ctx.lr = 0x828D3290;
	sub_82DF3428(ctx, base);
	// 828D3290: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828D3294: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D3298: 388B1F18  addi r4, r11, 0x1f18
	ctx.r[4].s64 = ctx.r[11].s64 + 7960;
	// 828D329C: 4852076D  bl 0x82df3a08
	ctx.lr = 0x828D32A0;
	sub_82DF3A08(ctx, base);
	// 828D32A0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828D32A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D32A8: 388B1F0C  addi r4, r11, 0x1f0c
	ctx.r[4].s64 = ctx.r[11].s64 + 7948;
	// 828D32AC: 4852075D  bl 0x82df3a08
	ctx.lr = 0x828D32B0;
	sub_82DF3A08(ctx, base);
	// 828D32B0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828D32B4: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 828D32B8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D32BC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828D32C0: 38610270  addi r3, r1, 0x270
	ctx.r[3].s64 = ctx.r[1].s64 + 624;
	// 828D32C4: C3EB9528  lfs f31, -0x6ad8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828D32C8: C34A89AC  lfs f26, -0x7654(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 828D32CC: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828D32D0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828D32D4: FC40D090  fmr f2, f26
	ctx.f[2].f64 = ctx.f[26].f64;
	// 828D32D8: 4BCCFFD1  bl 0x825a32a8
	ctx.lr = 0x828D32DC;
	sub_825A32A8(ctx, base);
	// 828D32DC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828D32E0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D32E4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D32E8: 4BCCE489  bl 0x825a1770
	ctx.lr = 0x828D32EC;
	sub_825A1770(ctx, base);
	// 828D32EC: 386102A8  addi r3, r1, 0x2a8
	ctx.r[3].s64 = ctx.r[1].s64 + 680;
	// 828D32F0: 48520139  bl 0x82df3428
	ctx.lr = 0x828D32F4;
	sub_82DF3428(ctx, base);
	// 828D32F4: 38610288  addi r3, r1, 0x288
	ctx.r[3].s64 = ctx.r[1].s64 + 648;
	// 828D32F8: 4B9F59C1  bl 0x822c8cb8
	ctx.lr = 0x828D32FC;
	sub_822C8CB8(ctx, base);
	// 828D32FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D3300: 48520129  bl 0x82df3428
	ctx.lr = 0x828D3304;
	sub_82DF3428(ctx, base);
	// 828D3304: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D3308: 48520121  bl 0x82df3428
	ctx.lr = 0x828D330C;
	sub_82DF3428(ctx, base);
	// 828D330C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828D3310: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D3314: 388B1C34  addi r4, r11, 0x1c34
	ctx.r[4].s64 = ctx.r[11].s64 + 7220;
	// 828D3318: 485206F1  bl 0x82df3a08
	ctx.lr = 0x828D331C;
	sub_82DF3A08(ctx, base);
	// 828D331C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828D3320: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D3324: 388B1C24  addi r4, r11, 0x1c24
	ctx.r[4].s64 = ctx.r[11].s64 + 7204;
	// 828D3328: 485206E1  bl 0x82df3a08
	ctx.lr = 0x828D332C;
	sub_82DF3A08(ctx, base);
	// 828D332C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828D3330: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828D3334: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828D3338: 38BF0004  addi r5, r31, 4
	ctx.r[5].s64 = ctx.r[31].s64 + 4;
	// 828D333C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D3340: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 828D3344: C36B08A8  lfs f27, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 828D3348: C3CA08A4  lfs f30, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 828D334C: FC40D890  fmr f2, f27
	ctx.f[2].f64 = ctx.f[27].f64;
	// 828D3350: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828D3354: 4BCCFF55  bl 0x825a32a8
	ctx.lr = 0x828D3358;
	sub_825A32A8(ctx, base);
	// 828D3358: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828D335C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828D3360: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D3364: 4BCCE40D  bl 0x825a1770
	ctx.lr = 0x828D3368;
	sub_825A1770(ctx, base);
	// 828D3368: 38610128  addi r3, r1, 0x128
	ctx.r[3].s64 = ctx.r[1].s64 + 296;
	// 828D336C: 485200BD  bl 0x82df3428
	ctx.lr = 0x828D3370;
	sub_82DF3428(ctx, base);
	// 828D3370: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 828D3374: 4B9F5945  bl 0x822c8cb8
	ctx.lr = 0x828D3378;
	sub_822C8CB8(ctx, base);
	// 828D3378: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D337C: 485200AD  bl 0x82df3428
	ctx.lr = 0x828D3380;
	sub_82DF3428(ctx, base);
	// 828D3380: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D3384: 485200A5  bl 0x82df3428
	ctx.lr = 0x828D3388;
	sub_82DF3428(ctx, base);
	// 828D3388: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828D338C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D3390: 388B1C0C  addi r4, r11, 0x1c0c
	ctx.r[4].s64 = ctx.r[11].s64 + 7180;
	// 828D3394: 48520675  bl 0x82df3a08
	ctx.lr = 0x828D3398;
	sub_82DF3A08(ctx, base);
	// 828D3398: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828D339C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D33A0: 388B1BFC  addi r4, r11, 0x1bfc
	ctx.r[4].s64 = ctx.r[11].s64 + 7164;
	// 828D33A4: 48520665  bl 0x82df3a08
	ctx.lr = 0x828D33A8;
	sub_82DF3A08(ctx, base);
	// 828D33A8: 38BF0008  addi r5, r31, 8
	ctx.r[5].s64 = ctx.r[31].s64 + 8;
	// 828D33AC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D33B0: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828D33B4: 386104F0  addi r3, r1, 0x4f0
	ctx.r[3].s64 = ctx.r[1].s64 + 1264;
	// 828D33B8: FC40D890  fmr f2, f27
	ctx.f[2].f64 = ctx.f[27].f64;
	// 828D33BC: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828D33C0: 4BCCFEE9  bl 0x825a32a8
	ctx.lr = 0x828D33C4;
	sub_825A32A8(ctx, base);
	// 828D33C4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828D33C8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D33CC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828D33D0: 4BCCE3A1  bl 0x825a1770
	ctx.lr = 0x828D33D4;
	sub_825A1770(ctx, base);
	// 828D33D4: 38610528  addi r3, r1, 0x528
	ctx.r[3].s64 = ctx.r[1].s64 + 1320;
	// 828D33D8: 48520051  bl 0x82df3428
	ctx.lr = 0x828D33DC;
	sub_82DF3428(ctx, base);
	// 828D33DC: 38610508  addi r3, r1, 0x508
	ctx.r[3].s64 = ctx.r[1].s64 + 1288;
	// 828D33E0: 4B9F58D9  bl 0x822c8cb8
	ctx.lr = 0x828D33E4;
	sub_822C8CB8(ctx, base);
	// 828D33E4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D33E8: 48520041  bl 0x82df3428
	ctx.lr = 0x828D33EC;
	sub_82DF3428(ctx, base);
	// 828D33EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D33F0: 48520039  bl 0x82df3428
	ctx.lr = 0x828D33F4;
	sub_82DF3428(ctx, base);
	// 828D33F4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828D33F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D33FC: 388B1BE4  addi r4, r11, 0x1be4
	ctx.r[4].s64 = ctx.r[11].s64 + 7140;
	// 828D3400: 48520609  bl 0x82df3a08
	ctx.lr = 0x828D3404;
	sub_82DF3A08(ctx, base);
	// 828D3404: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828D3408: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D340C: 388B1BD4  addi r4, r11, 0x1bd4
	ctx.r[4].s64 = ctx.r[11].s64 + 7124;
	// 828D3410: 485205F9  bl 0x82df3a08
	ctx.lr = 0x828D3414;
	sub_82DF3A08(ctx, base);
	// 828D3414: 38BF000C  addi r5, r31, 0xc
	ctx.r[5].s64 = ctx.r[31].s64 + 12;
	// 828D3418: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D341C: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828D3420: 38610170  addi r3, r1, 0x170
	ctx.r[3].s64 = ctx.r[1].s64 + 368;
	// 828D3424: FC40D890  fmr f2, f27
	ctx.f[2].f64 = ctx.f[27].f64;
	// 828D3428: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828D342C: 4BCCFE7D  bl 0x825a32a8
	ctx.lr = 0x828D3430;
	sub_825A32A8(ctx, base);
	// 828D3430: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828D3434: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D3438: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828D343C: 4BCCE335  bl 0x825a1770
	ctx.lr = 0x828D3440;
	sub_825A1770(ctx, base);
	// 828D3440: 386101A8  addi r3, r1, 0x1a8
	ctx.r[3].s64 = ctx.r[1].s64 + 424;
	// 828D3444: 4851FFE5  bl 0x82df3428
	ctx.lr = 0x828D3448;
	sub_82DF3428(ctx, base);
	// 828D3448: 38610188  addi r3, r1, 0x188
	ctx.r[3].s64 = ctx.r[1].s64 + 392;
	// 828D344C: 4B9F586D  bl 0x822c8cb8
	ctx.lr = 0x828D3450;
	sub_822C8CB8(ctx, base);
	// 828D3450: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D3454: 4851FFD5  bl 0x82df3428
	ctx.lr = 0x828D3458;
	sub_82DF3428(ctx, base);
	// 828D3458: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D345C: 4851FFCD  bl 0x82df3428
	ctx.lr = 0x828D3460;
	sub_82DF3428(ctx, base);
	// 828D3460: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828D3464: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D3468: 388B1F00  addi r4, r11, 0x1f00
	ctx.r[4].s64 = ctx.r[11].s64 + 7936;
	// 828D346C: 4852059D  bl 0x82df3a08
	ctx.lr = 0x828D3470;
	sub_82DF3A08(ctx, base);
	// 828D3470: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828D3474: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D3478: 388B1EF4  addi r4, r11, 0x1ef4
	ctx.r[4].s64 = ctx.r[11].s64 + 7924;
	// 828D347C: 4852058D  bl 0x82df3a08
	ctx.lr = 0x828D3480;
	sub_82DF3A08(ctx, base);
	// 828D3480: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 828D3484: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 828D3488: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828D348C: 38BF0010  addi r5, r31, 0x10
	ctx.r[5].s64 = ctx.r[31].s64 + 16;
	// 828D3490: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D3494: 38610370  addi r3, r1, 0x370
	ctx.r[3].s64 = ctx.r[1].s64 + 880;
	// 828D3498: C38B6218  lfs f28, 0x6218(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(25112 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 828D349C: C3AA964C  lfs f29, -0x69b4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 828D34A0: FC40E090  fmr f2, f28
	ctx.f[2].f64 = ctx.f[28].f64;
	// 828D34A4: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828D34A8: 4BCCFE01  bl 0x825a32a8
	ctx.lr = 0x828D34AC;
	sub_825A32A8(ctx, base);
	// 828D34AC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828D34B0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828D34B4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D34B8: 4BCCE2B9  bl 0x825a1770
	ctx.lr = 0x828D34BC;
	sub_825A1770(ctx, base);
	// 828D34BC: 386103A8  addi r3, r1, 0x3a8
	ctx.r[3].s64 = ctx.r[1].s64 + 936;
	// 828D34C0: 4851FF69  bl 0x82df3428
	ctx.lr = 0x828D34C4;
	sub_82DF3428(ctx, base);
	// 828D34C4: 38610388  addi r3, r1, 0x388
	ctx.r[3].s64 = ctx.r[1].s64 + 904;
	// 828D34C8: 4B9F57F1  bl 0x822c8cb8
	ctx.lr = 0x828D34CC;
	sub_822C8CB8(ctx, base);
	// 828D34CC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D34D0: 4851FF59  bl 0x82df3428
	ctx.lr = 0x828D34D4;
	sub_82DF3428(ctx, base);
	// 828D34D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D34D8: 4851FF51  bl 0x82df3428
	ctx.lr = 0x828D34DC;
	sub_82DF3428(ctx, base);
	// 828D34DC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828D34E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D34E4: 388B1EE4  addi r4, r11, 0x1ee4
	ctx.r[4].s64 = ctx.r[11].s64 + 7908;
	// 828D34E8: 48520521  bl 0x82df3a08
	ctx.lr = 0x828D34EC;
	sub_82DF3A08(ctx, base);
	// 828D34EC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828D34F0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D34F4: 388B1ED8  addi r4, r11, 0x1ed8
	ctx.r[4].s64 = ctx.r[11].s64 + 7896;
	// 828D34F8: 48520511  bl 0x82df3a08
	ctx.lr = 0x828D34FC;
	sub_82DF3A08(ctx, base);
	// 828D34FC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828D3500: 38BF0014  addi r5, r31, 0x14
	ctx.r[5].s64 = ctx.r[31].s64 + 20;
	// 828D3504: FC60D890  fmr f3, f27
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[27].f64;
	// 828D3508: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D350C: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828D3510: 386101F0  addi r3, r1, 0x1f0
	ctx.r[3].s64 = ctx.r[1].s64 + 496;
	// 828D3514: C32BD200  lfs f25, -0x2e00(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11776 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 828D3518: FC40C890  fmr f2, f25
	ctx.f[2].f64 = ctx.f[25].f64;
	// 828D351C: 4BCCFD8D  bl 0x825a32a8
	ctx.lr = 0x828D3520;
	sub_825A32A8(ctx, base);
	// 828D3520: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828D3524: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D3528: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828D352C: 4BCCE245  bl 0x825a1770
	ctx.lr = 0x828D3530;
	sub_825A1770(ctx, base);
	// 828D3530: 38610228  addi r3, r1, 0x228
	ctx.r[3].s64 = ctx.r[1].s64 + 552;
	// 828D3534: 4851FEF5  bl 0x82df3428
	ctx.lr = 0x828D3538;
	sub_82DF3428(ctx, base);
	// 828D3538: 38610208  addi r3, r1, 0x208
	ctx.r[3].s64 = ctx.r[1].s64 + 520;
	// 828D353C: 4B9F577D  bl 0x822c8cb8
	ctx.lr = 0x828D3540;
	sub_822C8CB8(ctx, base);
	// 828D3540: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D3544: 4851FEE5  bl 0x82df3428
	ctx.lr = 0x828D3548;
	sub_82DF3428(ctx, base);
	// 828D3548: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D354C: 4851FEDD  bl 0x82df3428
	ctx.lr = 0x828D3550;
	sub_82DF3428(ctx, base);
	// 828D3550: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828D3554: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D3558: 388B1EC8  addi r4, r11, 0x1ec8
	ctx.r[4].s64 = ctx.r[11].s64 + 7880;
	// 828D355C: 485204AD  bl 0x82df3a08
	ctx.lr = 0x828D3560;
	sub_82DF3A08(ctx, base);
	// 828D3560: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828D3564: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D3568: 388B1EBC  addi r4, r11, 0x1ebc
	ctx.r[4].s64 = ctx.r[11].s64 + 7868;
	// 828D356C: 4852049D  bl 0x82df3a08
	ctx.lr = 0x828D3570;
	sub_82DF3A08(ctx, base);
	// 828D3570: 38BF0018  addi r5, r31, 0x18
	ctx.r[5].s64 = ctx.r[31].s64 + 24;
	// 828D3574: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D3578: FC60D890  fmr f3, f27
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[27].f64;
	// 828D357C: 38610470  addi r3, r1, 0x470
	ctx.r[3].s64 = ctx.r[1].s64 + 1136;
	// 828D3580: FC40C890  fmr f2, f25
	ctx.f[2].f64 = ctx.f[25].f64;
	// 828D3584: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828D3588: 4BCCFD21  bl 0x825a32a8
	ctx.lr = 0x828D358C;
	sub_825A32A8(ctx, base);
	// 828D358C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828D3590: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D3594: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828D3598: 4BCCE1D9  bl 0x825a1770
	ctx.lr = 0x828D359C;
	sub_825A1770(ctx, base);
	// 828D359C: 386104A8  addi r3, r1, 0x4a8
	ctx.r[3].s64 = ctx.r[1].s64 + 1192;
	// 828D35A0: 4851FE89  bl 0x82df3428
	ctx.lr = 0x828D35A4;
	sub_82DF3428(ctx, base);
	// 828D35A4: 38610488  addi r3, r1, 0x488
	ctx.r[3].s64 = ctx.r[1].s64 + 1160;
	// 828D35A8: 4B9F5711  bl 0x822c8cb8
	ctx.lr = 0x828D35AC;
	sub_822C8CB8(ctx, base);
	// 828D35AC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D35B0: 4851FE79  bl 0x82df3428
	ctx.lr = 0x828D35B4;
	sub_82DF3428(ctx, base);
	// 828D35B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D35B8: 4851FE71  bl 0x82df3428
	ctx.lr = 0x828D35BC;
	sub_82DF3428(ctx, base);
	// 828D35BC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828D35C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D35C4: 388B1EA8  addi r4, r11, 0x1ea8
	ctx.r[4].s64 = ctx.r[11].s64 + 7848;
	// 828D35C8: 48520441  bl 0x82df3a08
	ctx.lr = 0x828D35CC;
	sub_82DF3A08(ctx, base);
	// 828D35CC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828D35D0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D35D4: 388B1E98  addi r4, r11, 0x1e98
	ctx.r[4].s64 = ctx.r[11].s64 + 7832;
	// 828D35D8: 48520431  bl 0x82df3a08
	ctx.lr = 0x828D35DC;
	sub_82DF3A08(ctx, base);
	// 828D35DC: 38BF001C  addi r5, r31, 0x1c
	ctx.r[5].s64 = ctx.r[31].s64 + 28;
	// 828D35E0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D35E4: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828D35E8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828D35EC: FC40D090  fmr f2, f26
	ctx.f[2].f64 = ctx.f[26].f64;
	// 828D35F0: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828D35F4: 4BCCFCB5  bl 0x825a32a8
	ctx.lr = 0x828D35F8;
	sub_825A32A8(ctx, base);
	// 828D35F8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828D35FC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828D3600: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D3604: 4BCCE16D  bl 0x825a1770
	ctx.lr = 0x828D3608;
	sub_825A1770(ctx, base);
	// 828D3608: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 828D360C: 4851FE1D  bl 0x82df3428
	ctx.lr = 0x828D3610;
	sub_82DF3428(ctx, base);
	// 828D3610: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 828D3614: 4B9F56A5  bl 0x822c8cb8
	ctx.lr = 0x828D3618;
	sub_822C8CB8(ctx, base);
	// 828D3618: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D361C: 4851FE0D  bl 0x82df3428
	ctx.lr = 0x828D3620;
	sub_82DF3428(ctx, base);
	// 828D3620: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D3624: 4851FE05  bl 0x82df3428
	ctx.lr = 0x828D3628;
	sub_82DF3428(ctx, base);
	// 828D3628: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828D362C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D3630: 388B1E80  addi r4, r11, 0x1e80
	ctx.r[4].s64 = ctx.r[11].s64 + 7808;
	// 828D3634: 485203D5  bl 0x82df3a08
	ctx.lr = 0x828D3638;
	sub_82DF3A08(ctx, base);
	// 828D3638: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828D363C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D3640: 388B1E74  addi r4, r11, 0x1e74
	ctx.r[4].s64 = ctx.r[11].s64 + 7796;
	// 828D3644: 485203C5  bl 0x82df3a08
	ctx.lr = 0x828D3648;
	sub_82DF3A08(ctx, base);
	// 828D3648: 38BF0020  addi r5, r31, 0x20
	ctx.r[5].s64 = ctx.r[31].s64 + 32;
	// 828D364C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D3650: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828D3654: 386103F0  addi r3, r1, 0x3f0
	ctx.r[3].s64 = ctx.r[1].s64 + 1008;
	// 828D3658: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828D365C: FC40D090  fmr f2, f26
	ctx.f[2].f64 = ctx.f[26].f64;
	// 828D3660: 4BCCFC49  bl 0x825a32a8
	ctx.lr = 0x828D3664;
	sub_825A32A8(ctx, base);
	// 828D3664: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828D3668: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D366C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828D3670: 4BCCE101  bl 0x825a1770
	ctx.lr = 0x828D3674;
	sub_825A1770(ctx, base);
	// 828D3674: 38610428  addi r3, r1, 0x428
	ctx.r[3].s64 = ctx.r[1].s64 + 1064;
	// 828D3678: 4851FDB1  bl 0x82df3428
	ctx.lr = 0x828D367C;
	sub_82DF3428(ctx, base);
	// 828D367C: 38610408  addi r3, r1, 0x408
	ctx.r[3].s64 = ctx.r[1].s64 + 1032;
	// 828D3680: 4B9F5639  bl 0x822c8cb8
	ctx.lr = 0x828D3684;
	sub_822C8CB8(ctx, base);
	// 828D3684: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D3688: 4851FDA1  bl 0x82df3428
	ctx.lr = 0x828D368C;
	sub_82DF3428(ctx, base);
	// 828D368C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D3690: 4851FD99  bl 0x82df3428
	ctx.lr = 0x828D3694;
	sub_82DF3428(ctx, base);
	// 828D3694: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828D3698: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D369C: 388B1E4C  addi r4, r11, 0x1e4c
	ctx.r[4].s64 = ctx.r[11].s64 + 7756;
	// 828D36A0: 48520369  bl 0x82df3a08
	ctx.lr = 0x828D36A4;
	sub_82DF3A08(ctx, base);
	// 828D36A4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828D36A8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D36AC: 388B1E40  addi r4, r11, 0x1e40
	ctx.r[4].s64 = ctx.r[11].s64 + 7744;
	// 828D36B0: 48520359  bl 0x82df3a08
	ctx.lr = 0x828D36B4;
	sub_82DF3A08(ctx, base);
	// 828D36B4: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 828D36B8: 38BF0024  addi r5, r31, 0x24
	ctx.r[5].s64 = ctx.r[31].s64 + 36;
	// 828D36BC: FC60E890  fmr f3, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[29].f64;
	// 828D36C0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D36C4: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828D36C8: 386102F0  addi r3, r1, 0x2f0
	ctx.r[3].s64 = ctx.r[1].s64 + 752;
	// 828D36CC: C32B029C  lfs f25, 0x29c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(668 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 828D36D0: FC40C890  fmr f2, f25
	ctx.f[2].f64 = ctx.f[25].f64;
	// 828D36D4: 4BCCFBD5  bl 0x825a32a8
	ctx.lr = 0x828D36D8;
	sub_825A32A8(ctx, base);
	// 828D36D8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828D36DC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D36E0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828D36E4: 4BCCE08D  bl 0x825a1770
	ctx.lr = 0x828D36E8;
	sub_825A1770(ctx, base);
	// 828D36E8: 38610328  addi r3, r1, 0x328
	ctx.r[3].s64 = ctx.r[1].s64 + 808;
	// 828D36EC: 4851FD3D  bl 0x82df3428
	ctx.lr = 0x828D36F0;
	sub_82DF3428(ctx, base);
	// 828D36F0: 38610308  addi r3, r1, 0x308
	ctx.r[3].s64 = ctx.r[1].s64 + 776;
	// 828D36F4: 4B9F55C5  bl 0x822c8cb8
	ctx.lr = 0x828D36F8;
	sub_822C8CB8(ctx, base);
	// 828D36F8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D36FC: 4851FD2D  bl 0x82df3428
	ctx.lr = 0x828D3700;
	sub_82DF3428(ctx, base);
	// 828D3700: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D3704: 4851FD25  bl 0x82df3428
	ctx.lr = 0x828D3708;
	sub_82DF3428(ctx, base);
	// 828D3708: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828D370C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D3710: 388B1E30  addi r4, r11, 0x1e30
	ctx.r[4].s64 = ctx.r[11].s64 + 7728;
	// 828D3714: 485202F5  bl 0x82df3a08
	ctx.lr = 0x828D3718;
	sub_82DF3A08(ctx, base);
	// 828D3718: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828D371C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D3720: 388B1E24  addi r4, r11, 0x1e24
	ctx.r[4].s64 = ctx.r[11].s64 + 7716;
	// 828D3724: 485202E5  bl 0x82df3a08
	ctx.lr = 0x828D3728;
	sub_82DF3A08(ctx, base);
	// 828D3728: 38BF0028  addi r5, r31, 0x28
	ctx.r[5].s64 = ctx.r[31].s64 + 40;
	// 828D372C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D3730: FC60E890  fmr f3, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[29].f64;
	// 828D3734: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 828D3738: FC40C890  fmr f2, f25
	ctx.f[2].f64 = ctx.f[25].f64;
	// 828D373C: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828D3740: 4BCCFB69  bl 0x825a32a8
	ctx.lr = 0x828D3744;
	sub_825A32A8(ctx, base);
	// 828D3744: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828D3748: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828D374C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D3750: 4BCCE021  bl 0x825a1770
	ctx.lr = 0x828D3754;
	sub_825A1770(ctx, base);
	// 828D3754: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 828D3758: 4851FCD1  bl 0x82df3428
	ctx.lr = 0x828D375C;
	sub_82DF3428(ctx, base);
	// 828D375C: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 828D3760: 4B9F5559  bl 0x822c8cb8
	ctx.lr = 0x828D3764;
	sub_822C8CB8(ctx, base);
	// 828D3764: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D3768: 4851FCC1  bl 0x82df3428
	ctx.lr = 0x828D376C;
	sub_82DF3428(ctx, base);
	// 828D376C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D3770: 4851FCB9  bl 0x82df3428
	ctx.lr = 0x828D3774;
	sub_82DF3428(ctx, base);
	// 828D3774: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828D3778: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D377C: 388B1DC4  addi r4, r11, 0x1dc4
	ctx.r[4].s64 = ctx.r[11].s64 + 7620;
	// 828D3780: 48520289  bl 0x82df3a08
	ctx.lr = 0x828D3784;
	sub_82DF3A08(ctx, base);
	// 828D3784: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828D3788: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D378C: 388B1DB0  addi r4, r11, 0x1db0
	ctx.r[4].s64 = ctx.r[11].s64 + 7600;
	// 828D3790: 48520279  bl 0x82df3a08
	ctx.lr = 0x828D3794;
	sub_82DF3A08(ctx, base);
	// 828D3794: 38BF002C  addi r5, r31, 0x2c
	ctx.r[5].s64 = ctx.r[31].s64 + 44;
	// 828D3798: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D379C: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828D37A0: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 828D37A4: FC40E090  fmr f2, f28
	ctx.f[2].f64 = ctx.f[28].f64;
	// 828D37A8: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828D37AC: 4BCCFAFD  bl 0x825a32a8
	ctx.lr = 0x828D37B0;
	sub_825A32A8(ctx, base);
	// 828D37B0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828D37B4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D37B8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828D37BC: 4BCCDFB5  bl 0x825a1770
	ctx.lr = 0x828D37C0;
	sub_825A1770(ctx, base);
	// 828D37C0: 38610168  addi r3, r1, 0x168
	ctx.r[3].s64 = ctx.r[1].s64 + 360;
	// 828D37C4: 4851FC65  bl 0x82df3428
	ctx.lr = 0x828D37C8;
	sub_82DF3428(ctx, base);
	// 828D37C8: 38610148  addi r3, r1, 0x148
	ctx.r[3].s64 = ctx.r[1].s64 + 328;
	// 828D37CC: 4B9F54ED  bl 0x822c8cb8
	ctx.lr = 0x828D37D0;
	sub_822C8CB8(ctx, base);
	// 828D37D0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D37D4: 4851FC55  bl 0x82df3428
	ctx.lr = 0x828D37D8;
	sub_82DF3428(ctx, base);
	// 828D37D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D37DC: 4851FC4D  bl 0x82df3428
	ctx.lr = 0x828D37E0;
	sub_82DF3428(ctx, base);
	// 828D37E0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828D37E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D37E8: 388B1D9C  addi r4, r11, 0x1d9c
	ctx.r[4].s64 = ctx.r[11].s64 + 7580;
	// 828D37EC: 4852021D  bl 0x82df3a08
	ctx.lr = 0x828D37F0;
	sub_82DF3A08(ctx, base);
	// 828D37F0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828D37F4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D37F8: 388B1D8C  addi r4, r11, 0x1d8c
	ctx.r[4].s64 = ctx.r[11].s64 + 7564;
	// 828D37FC: 4852020D  bl 0x82df3a08
	ctx.lr = 0x828D3800;
	sub_82DF3A08(ctx, base);
	// 828D3800: 38BF0030  addi r5, r31, 0x30
	ctx.r[5].s64 = ctx.r[31].s64 + 48;
	// 828D3804: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D3808: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828D380C: 386101B0  addi r3, r1, 0x1b0
	ctx.r[3].s64 = ctx.r[1].s64 + 432;
	// 828D3810: FC40D090  fmr f2, f26
	ctx.f[2].f64 = ctx.f[26].f64;
	// 828D3814: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828D3818: 4BCCFA91  bl 0x825a32a8
	ctx.lr = 0x828D381C;
	sub_825A32A8(ctx, base);
	// 828D381C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828D3820: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D3824: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828D3828: 4BCCDF49  bl 0x825a1770
	ctx.lr = 0x828D382C;
	sub_825A1770(ctx, base);
	// 828D382C: 386101E8  addi r3, r1, 0x1e8
	ctx.r[3].s64 = ctx.r[1].s64 + 488;
	// 828D3830: 4851FBF9  bl 0x82df3428
	ctx.lr = 0x828D3834;
	sub_82DF3428(ctx, base);
	// 828D3834: 386101C8  addi r3, r1, 0x1c8
	ctx.r[3].s64 = ctx.r[1].s64 + 456;
	// 828D3838: 4B9F5481  bl 0x822c8cb8
	ctx.lr = 0x828D383C;
	sub_822C8CB8(ctx, base);
	// 828D383C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D3840: 4851FBE9  bl 0x82df3428
	ctx.lr = 0x828D3844;
	sub_82DF3428(ctx, base);
	// 828D3844: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D3848: 4851FBE1  bl 0x82df3428
	ctx.lr = 0x828D384C;
	sub_82DF3428(ctx, base);
	// 828D384C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828D3850: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D3854: 388B1D78  addi r4, r11, 0x1d78
	ctx.r[4].s64 = ctx.r[11].s64 + 7544;
	// 828D3858: 485201B1  bl 0x82df3a08
	ctx.lr = 0x828D385C;
	sub_82DF3A08(ctx, base);
	// 828D385C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828D3860: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D3864: 388B1D64  addi r4, r11, 0x1d64
	ctx.r[4].s64 = ctx.r[11].s64 + 7524;
	// 828D3868: 485201A1  bl 0x82df3a08
	ctx.lr = 0x828D386C;
	sub_82DF3A08(ctx, base);
	// 828D386C: 38BF0034  addi r5, r31, 0x34
	ctx.r[5].s64 = ctx.r[31].s64 + 52;
	// 828D3870: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D3874: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828D3878: 38610230  addi r3, r1, 0x230
	ctx.r[3].s64 = ctx.r[1].s64 + 560;
	// 828D387C: FC40E090  fmr f2, f28
	ctx.f[2].f64 = ctx.f[28].f64;
	// 828D3880: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828D3884: 4BCCFA25  bl 0x825a32a8
	ctx.lr = 0x828D3888;
	sub_825A32A8(ctx, base);
	// 828D3888: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828D388C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828D3890: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D3894: 4BCCDEDD  bl 0x825a1770
	ctx.lr = 0x828D3898;
	sub_825A1770(ctx, base);
	// 828D3898: 38610268  addi r3, r1, 0x268
	ctx.r[3].s64 = ctx.r[1].s64 + 616;
	// 828D389C: 4851FB8D  bl 0x82df3428
	ctx.lr = 0x828D38A0;
	sub_82DF3428(ctx, base);
	// 828D38A0: 38610248  addi r3, r1, 0x248
	ctx.r[3].s64 = ctx.r[1].s64 + 584;
	// 828D38A4: 4B9F5415  bl 0x822c8cb8
	ctx.lr = 0x828D38A8;
	sub_822C8CB8(ctx, base);
	// 828D38A8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D38AC: 4851FB7D  bl 0x82df3428
	ctx.lr = 0x828D38B0;
	sub_82DF3428(ctx, base);
	// 828D38B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D38B4: 4851FB75  bl 0x82df3428
	ctx.lr = 0x828D38B8;
	sub_82DF3428(ctx, base);
	// 828D38B8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828D38BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D38C0: 388B1D48  addi r4, r11, 0x1d48
	ctx.r[4].s64 = ctx.r[11].s64 + 7496;
	// 828D38C4: 48520145  bl 0x82df3a08
	ctx.lr = 0x828D38C8;
	sub_82DF3A08(ctx, base);
	// 828D38C8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828D38CC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D38D0: 388B1D34  addi r4, r11, 0x1d34
	ctx.r[4].s64 = ctx.r[11].s64 + 7476;
	// 828D38D4: 48520135  bl 0x82df3a08
	ctx.lr = 0x828D38D8;
	sub_82DF3A08(ctx, base);
	// 828D38D8: 38BF0038  addi r5, r31, 0x38
	ctx.r[5].s64 = ctx.r[31].s64 + 56;
	// 828D38DC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D38E0: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828D38E4: 386102B0  addi r3, r1, 0x2b0
	ctx.r[3].s64 = ctx.r[1].s64 + 688;
	// 828D38E8: FC40E090  fmr f2, f28
	ctx.f[2].f64 = ctx.f[28].f64;
	// 828D38EC: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828D38F0: 4BCCF9B9  bl 0x825a32a8
	ctx.lr = 0x828D38F4;
	sub_825A32A8(ctx, base);
	// 828D38F4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828D38F8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D38FC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828D3900: 4BCCDE71  bl 0x825a1770
	ctx.lr = 0x828D3904;
	sub_825A1770(ctx, base);
	// 828D3904: 386102E8  addi r3, r1, 0x2e8
	ctx.r[3].s64 = ctx.r[1].s64 + 744;
	// 828D3908: 4851FB21  bl 0x82df3428
	ctx.lr = 0x828D390C;
	sub_82DF3428(ctx, base);
	// 828D390C: 386102C8  addi r3, r1, 0x2c8
	ctx.r[3].s64 = ctx.r[1].s64 + 712;
	// 828D3910: 4B9F53A9  bl 0x822c8cb8
	ctx.lr = 0x828D3914;
	sub_822C8CB8(ctx, base);
	// 828D3914: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D3918: 4851FB11  bl 0x82df3428
	ctx.lr = 0x828D391C;
	sub_82DF3428(ctx, base);
	// 828D391C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D3920: 4851FB09  bl 0x82df3428
	ctx.lr = 0x828D3924;
	sub_82DF3428(ctx, base);
	// 828D3924: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828D3928: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D392C: 388B1D14  addi r4, r11, 0x1d14
	ctx.r[4].s64 = ctx.r[11].s64 + 7444;
	// 828D3930: 485200D9  bl 0x82df3a08
	ctx.lr = 0x828D3934;
	sub_82DF3A08(ctx, base);
	// 828D3934: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828D3938: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D393C: 388B1D04  addi r4, r11, 0x1d04
	ctx.r[4].s64 = ctx.r[11].s64 + 7428;
	// 828D3940: 485200C9  bl 0x82df3a08
	ctx.lr = 0x828D3944;
	sub_82DF3A08(ctx, base);
	// 828D3944: 38BF003C  addi r5, r31, 0x3c
	ctx.r[5].s64 = ctx.r[31].s64 + 60;
	// 828D3948: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D394C: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828D3950: 38610330  addi r3, r1, 0x330
	ctx.r[3].s64 = ctx.r[1].s64 + 816;
	// 828D3954: FC40E090  fmr f2, f28
	ctx.f[2].f64 = ctx.f[28].f64;
	// 828D3958: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828D395C: 4BCCF94D  bl 0x825a32a8
	ctx.lr = 0x828D3960;
	sub_825A32A8(ctx, base);
	// 828D3960: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828D3964: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D3968: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828D396C: 4BCCDE05  bl 0x825a1770
	ctx.lr = 0x828D3970;
	sub_825A1770(ctx, base);
	// 828D3970: 38610368  addi r3, r1, 0x368
	ctx.r[3].s64 = ctx.r[1].s64 + 872;
	// 828D3974: 4851FAB5  bl 0x82df3428
	ctx.lr = 0x828D3978;
	sub_82DF3428(ctx, base);
	// 828D3978: 38610348  addi r3, r1, 0x348
	ctx.r[3].s64 = ctx.r[1].s64 + 840;
	// 828D397C: 4B9F533D  bl 0x822c8cb8
	ctx.lr = 0x828D3980;
	sub_822C8CB8(ctx, base);
	// 828D3980: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D3984: 4851FAA5  bl 0x82df3428
	ctx.lr = 0x828D3988;
	sub_82DF3428(ctx, base);
	// 828D3988: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D398C: 4851FA9D  bl 0x82df3428
	ctx.lr = 0x828D3990;
	sub_82DF3428(ctx, base);
	// 828D3990: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828D3994: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D3998: 388B1CF8  addi r4, r11, 0x1cf8
	ctx.r[4].s64 = ctx.r[11].s64 + 7416;
	// 828D399C: 4852006D  bl 0x82df3a08
	ctx.lr = 0x828D39A0;
	sub_82DF3A08(ctx, base);
	// 828D39A0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828D39A4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D39A8: 388B1CF0  addi r4, r11, 0x1cf0
	ctx.r[4].s64 = ctx.r[11].s64 + 7408;
	// 828D39AC: 4852005D  bl 0x82df3a08
	ctx.lr = 0x828D39B0;
	sub_82DF3A08(ctx, base);
	// 828D39B0: 38BF0040  addi r5, r31, 0x40
	ctx.r[5].s64 = ctx.r[31].s64 + 64;
	// 828D39B4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D39B8: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828D39BC: 386103B0  addi r3, r1, 0x3b0
	ctx.r[3].s64 = ctx.r[1].s64 + 944;
	// 828D39C0: FC40D090  fmr f2, f26
	ctx.f[2].f64 = ctx.f[26].f64;
	// 828D39C4: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828D39C8: 4BCCF8E1  bl 0x825a32a8
	ctx.lr = 0x828D39CC;
	sub_825A32A8(ctx, base);
	// 828D39CC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828D39D0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828D39D4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D39D8: 4BCCDD99  bl 0x825a1770
	ctx.lr = 0x828D39DC;
	sub_825A1770(ctx, base);
	// 828D39DC: 386103E8  addi r3, r1, 0x3e8
	ctx.r[3].s64 = ctx.r[1].s64 + 1000;
	// 828D39E0: 4851FA49  bl 0x82df3428
	ctx.lr = 0x828D39E4;
	sub_82DF3428(ctx, base);
	// 828D39E4: 386103C8  addi r3, r1, 0x3c8
	ctx.r[3].s64 = ctx.r[1].s64 + 968;
	// 828D39E8: 4B9F52D1  bl 0x822c8cb8
	ctx.lr = 0x828D39EC;
	sub_822C8CB8(ctx, base);
	// 828D39EC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D39F0: 4851FA39  bl 0x82df3428
	ctx.lr = 0x828D39F4;
	sub_82DF3428(ctx, base);
	// 828D39F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D39F8: 4851FA31  bl 0x82df3428
	ctx.lr = 0x828D39FC;
	sub_82DF3428(ctx, base);
	// 828D39FC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828D3A00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D3A04: 388B1CD4  addi r4, r11, 0x1cd4
	ctx.r[4].s64 = ctx.r[11].s64 + 7380;
	// 828D3A08: 48520001  bl 0x82df3a08
	ctx.lr = 0x828D3A0C;
	sub_82DF3A08(ctx, base);
	// 828D3A0C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828D3A10: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D3A14: 388B1CC0  addi r4, r11, 0x1cc0
	ctx.r[4].s64 = ctx.r[11].s64 + 7360;
	// 828D3A18: 4851FFF1  bl 0x82df3a08
	ctx.lr = 0x828D3A1C;
	sub_82DF3A08(ctx, base);
	// 828D3A1C: 38BF0044  addi r5, r31, 0x44
	ctx.r[5].s64 = ctx.r[31].s64 + 68;
	// 828D3A20: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D3A24: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828D3A28: 38610430  addi r3, r1, 0x430
	ctx.r[3].s64 = ctx.r[1].s64 + 1072;
	// 828D3A2C: FC40E090  fmr f2, f28
	ctx.f[2].f64 = ctx.f[28].f64;
	// 828D3A30: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828D3A34: 4BCCF875  bl 0x825a32a8
	ctx.lr = 0x828D3A38;
	sub_825A32A8(ctx, base);
	// 828D3A38: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828D3A3C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D3A40: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828D3A44: 4BCCDD2D  bl 0x825a1770
	ctx.lr = 0x828D3A48;
	sub_825A1770(ctx, base);
	// 828D3A48: 38610468  addi r3, r1, 0x468
	ctx.r[3].s64 = ctx.r[1].s64 + 1128;
	// 828D3A4C: 4851F9DD  bl 0x82df3428
	ctx.lr = 0x828D3A50;
	sub_82DF3428(ctx, base);
	// 828D3A50: 38610448  addi r3, r1, 0x448
	ctx.r[3].s64 = ctx.r[1].s64 + 1096;
	// 828D3A54: 4B9F5265  bl 0x822c8cb8
	ctx.lr = 0x828D3A58;
	sub_822C8CB8(ctx, base);
	// 828D3A58: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D3A5C: 4851F9CD  bl 0x82df3428
	ctx.lr = 0x828D3A60;
	sub_82DF3428(ctx, base);
	// 828D3A60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D3A64: 4851F9C5  bl 0x82df3428
	ctx.lr = 0x828D3A68;
	sub_82DF3428(ctx, base);
	// 828D3A68: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828D3A6C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D3A70: 388B1CA4  addi r4, r11, 0x1ca4
	ctx.r[4].s64 = ctx.r[11].s64 + 7332;
	// 828D3A74: 4851FF95  bl 0x82df3a08
	ctx.lr = 0x828D3A78;
	sub_82DF3A08(ctx, base);
	// 828D3A78: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828D3A7C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D3A80: 388B1C88  addi r4, r11, 0x1c88
	ctx.r[4].s64 = ctx.r[11].s64 + 7304;
	// 828D3A84: 4851FF85  bl 0x82df3a08
	ctx.lr = 0x828D3A88;
	sub_82DF3A08(ctx, base);
	// 828D3A88: 38BF0048  addi r5, r31, 0x48
	ctx.r[5].s64 = ctx.r[31].s64 + 72;
	// 828D3A8C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D3A90: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828D3A94: 386104B0  addi r3, r1, 0x4b0
	ctx.r[3].s64 = ctx.r[1].s64 + 1200;
	// 828D3A98: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828D3A9C: FC40E090  fmr f2, f28
	ctx.f[2].f64 = ctx.f[28].f64;
	// 828D3AA0: 4BCCF809  bl 0x825a32a8
	ctx.lr = 0x828D3AA4;
	sub_825A32A8(ctx, base);
	// 828D3AA4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828D3AA8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D3AAC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828D3AB0: 4BCCDCC1  bl 0x825a1770
	ctx.lr = 0x828D3AB4;
	sub_825A1770(ctx, base);
	// 828D3AB4: 386104E8  addi r3, r1, 0x4e8
	ctx.r[3].s64 = ctx.r[1].s64 + 1256;
	// 828D3AB8: 4851F971  bl 0x82df3428
	ctx.lr = 0x828D3ABC;
	sub_82DF3428(ctx, base);
	// 828D3ABC: 386104C8  addi r3, r1, 0x4c8
	ctx.r[3].s64 = ctx.r[1].s64 + 1224;
	// 828D3AC0: 4B9F51F9  bl 0x822c8cb8
	ctx.lr = 0x828D3AC4;
	sub_822C8CB8(ctx, base);
	// 828D3AC4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D3AC8: 4851F961  bl 0x82df3428
	ctx.lr = 0x828D3ACC;
	sub_82DF3428(ctx, base);
	// 828D3ACC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D3AD0: 4851F959  bl 0x82df3428
	ctx.lr = 0x828D3AD4;
	sub_82DF3428(ctx, base);
	// 828D3AD4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828D3AD8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D3ADC: 388B1C78  addi r4, r11, 0x1c78
	ctx.r[4].s64 = ctx.r[11].s64 + 7288;
	// 828D3AE0: 4851FF29  bl 0x82df3a08
	ctx.lr = 0x828D3AE4;
	sub_82DF3A08(ctx, base);
	// 828D3AE4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828D3AE8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D3AEC: 388B1C64  addi r4, r11, 0x1c64
	ctx.r[4].s64 = ctx.r[11].s64 + 7268;
	// 828D3AF0: 4851FF19  bl 0x82df3a08
	ctx.lr = 0x828D3AF4;
	sub_82DF3A08(ctx, base);
	// 828D3AF4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828D3AF8: 38BF004C  addi r5, r31, 0x4c
	ctx.r[5].s64 = ctx.r[31].s64 + 76;
	// 828D3AFC: FC60D890  fmr f3, f27
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[27].f64;
	// 828D3B00: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D3B04: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828D3B08: 38610530  addi r3, r1, 0x530
	ctx.r[3].s64 = ctx.r[1].s64 + 1328;
	// 828D3B0C: C04BDDF0  lfs f2, -0x2210(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8720 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 828D3B10: 4BCCF799  bl 0x825a32a8
	ctx.lr = 0x828D3B14;
	sub_825A32A8(ctx, base);
	// 828D3B14: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828D3B18: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828D3B1C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D3B20: 4BCCDC51  bl 0x825a1770
	ctx.lr = 0x828D3B24;
	sub_825A1770(ctx, base);
	// 828D3B24: 38610568  addi r3, r1, 0x568
	ctx.r[3].s64 = ctx.r[1].s64 + 1384;
	// 828D3B28: 4851F901  bl 0x82df3428
	ctx.lr = 0x828D3B2C;
	sub_82DF3428(ctx, base);
	// 828D3B2C: 38610548  addi r3, r1, 0x548
	ctx.r[3].s64 = ctx.r[1].s64 + 1352;
	// 828D3B30: 4B9F5189  bl 0x822c8cb8
	ctx.lr = 0x828D3B34;
	sub_822C8CB8(ctx, base);
	// 828D3B34: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D3B38: 4851F8F1  bl 0x82df3428
	ctx.lr = 0x828D3B3C;
	sub_82DF3428(ctx, base);
	// 828D3B3C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D3B40: 4851F8E9  bl 0x82df3428
	ctx.lr = 0x828D3B44;
	sub_82DF3428(ctx, base);
	// 828D3B44: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D3B48: 4BCF6189  bl 0x825c9cd0
	ctx.lr = 0x828D3B4C;
	sub_825C9CD0(ctx, base);
	// 828D3B4C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D3B50: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D3B54: 3BBE0004  addi r29, r30, 4
	ctx.r[29].s64 = ctx.r[30].s64 + 4;
	// 828D3B58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D3B5C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828D3B60: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828D3B64: 419A0024  beq cr6, 0x828d3b88
	if ctx.cr[6].eq {
	pc = 0x828D3B88; continue 'dispatch;
	}
	// 828D3B68: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828D3B6C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828D3B70: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D3B74: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828D3B78: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828D3B7C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D3B80: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D3B84: 4082FFE8  bne 0x828d3b6c
	if !ctx.cr[0].eq {
	pc = 0x828D3B6C; continue 'dispatch;
	}
	// 828D3B88: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828D3B8C: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 828D3B90: 4806FF01  bl 0x82943a90
	ctx.lr = 0x828D3B94;
	sub_82943A90(ctx, base);
	// 828D3B94: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D3B98: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D3B9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D3BA0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828D3BA4: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828D3BA8: 419A0024  beq cr6, 0x828d3bcc
	if ctx.cr[6].eq {
	pc = 0x828D3BCC; continue 'dispatch;
	}
	// 828D3BAC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828D3BB0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828D3BB4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D3BB8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828D3BBC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828D3BC0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D3BC4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D3BC8: 4082FFE8  bne 0x828d3bb0
	if !ctx.cr[0].eq {
	pc = 0x828D3BB0; continue 'dispatch;
	}
	// 828D3BCC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828D3BD0: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 828D3BD4: 4806E2AD  bl 0x82941e80
	ctx.lr = 0x828D3BD8;
	sub_82941E80(ctx, base);
	// 828D3BD8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D3BDC: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D3BE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D3BE4: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828D3BE8: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828D3BEC: 419A0024  beq cr6, 0x828d3c10
	if ctx.cr[6].eq {
	pc = 0x828D3C10; continue 'dispatch;
	}
	// 828D3BF0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828D3BF4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828D3BF8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D3BFC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828D3C00: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828D3C04: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D3C08: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D3C0C: 4082FFE8  bne 0x828d3bf4
	if !ctx.cr[0].eq {
	pc = 0x828D3BF4; continue 'dispatch;
	}
	// 828D3C10: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828D3C14: 387F007C  addi r3, r31, 0x7c
	ctx.r[3].s64 = ctx.r[31].s64 + 124;
	// 828D3C18: 4806F009  bl 0x82942c20
	ctx.lr = 0x828D3C1C;
	sub_82942C20(ctx, base);
	// 828D3C1C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D3C20: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D3C24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D3C28: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828D3C2C: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828D3C30: 419A0024  beq cr6, 0x828d3c54
	if ctx.cr[6].eq {
	pc = 0x828D3C54; continue 'dispatch;
	}
	// 828D3C34: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828D3C38: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828D3C3C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D3C40: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828D3C44: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828D3C48: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D3C4C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D3C50: 4082FFE8  bne 0x828d3c38
	if !ctx.cr[0].eq {
	pc = 0x828D3C38; continue 'dispatch;
	}
	// 828D3C54: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828D3C58: 387F008C  addi r3, r31, 0x8c
	ctx.r[3].s64 = ctx.r[31].s64 + 140;
	// 828D3C5C: 4806CFE5  bl 0x82940c40
	ctx.lr = 0x828D3C60;
	sub_82940C40(ctx, base);
	// 828D3C60: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D3C64: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D3C68: 419A0008  beq cr6, 0x828d3c70
	if ctx.cr[6].eq {
	pc = 0x828D3C70; continue 'dispatch;
	}
	// 828D3C6C: 4B9ECC25  bl 0x822c0890
	ctx.lr = 0x828D3C70;
	sub_822C0890(ctx, base);
	// 828D3C70: 382105D0  addi r1, r1, 0x5d0
	ctx.r[1].s64 = ctx.r[1].s64 + 1488;
	// 828D3C74: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 828D3C78: 488D4E41  bl 0x831a8ab8
	ctx.lr = 0x828D3C7C;
	sub_831A8A8C(ctx, base);
	// 828D3C7C: 488D4540  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D3C80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D3C80 size=172
    let mut pc: u32 = 0x828D3C80;
    'dispatch: loop {
        match pc {
            0x828D3C80 => {
    //   block [0x828D3C80..0x828D3D2C)
	// 828D3C80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D3C84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D3C88: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828D3C8C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D3C90: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D3C94: 4888096D  bl 0x83154600
	ctx.lr = 0x828D3C98;
	sub_83154600(ctx, base);
	// 828D3C98: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D3C9C: 4BFE504D  bl 0x828b8ce8
	ctx.lr = 0x828D3CA0;
	sub_828B8CE8(ctx, base);
	// 828D3CA0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D3CA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D3CA8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D3CAC: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828D3CB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D3CB4: 4E800421  bctrl
	ctx.lr = 0x828D3CB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D3CB8: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D3CBC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D3CC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D3CC4: 808B5FF0  lwz r4, 0x5ff0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24560 as u32) ) } as u64;
	// 828D3CC8: 4851FD41  bl 0x82df3a08
	ctx.lr = 0x828D3CCC;
	sub_82DF3A08(ctx, base);
	// 828D3CCC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D3CD0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D3CD4: 4BF1680D  bl 0x827ea4e0
	ctx.lr = 0x828D3CD8;
	sub_827EA4E0(ctx, base);
	// 828D3CD8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D3CDC: 4851F74D  bl 0x82df3428
	ctx.lr = 0x828D3CE0;
	sub_82DF3428(ctx, base);
	// 828D3CE0: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828D3CE4: 3BDF0010  addi r30, r31, 0x10
	ctx.r[30].s64 = ctx.r[31].s64 + 16;
	// 828D3CE8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828D3CEC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D3CF0: 816B00D0  lwz r11, 0xd0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(208 as u32) ) } as u64;
	// 828D3CF4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D3CF8: 4E800421  bctrl
	ctx.lr = 0x828D3CFC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D3CFC: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828D3D00: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828D3D04: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D3D08: 816B00D4  lwz r11, 0xd4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(212 as u32) ) } as u64;
	// 828D3D0C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D3D10: 4E800421  bctrl
	ctx.lr = 0x828D3D14;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D3D14: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D3D18: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D3D1C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D3D20: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828D3D24: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D3D28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D3D30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D3D30 size=96
    let mut pc: u32 = 0x828D3D30;
    'dispatch: loop {
        match pc {
            0x828D3D30 => {
    //   block [0x828D3D30..0x828D3D90)
	// 828D3D30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D3D34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D3D38: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D3D3C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D3D40: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D3D44: 48000225  bl 0x828d3f68
	ctx.lr = 0x828D3D48;
	sub_828D3F68(ctx, base);
	// 828D3D48: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D3D4C: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 828D3D50: 396BF0C0  addi r11, r11, -0xf40
	ctx.r[11].s64 = ctx.r[11].s64 + -3904;
	// 828D3D54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D3D58: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D3D5C: 808A6058  lwz r4, 0x6058(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24664 as u32) ) } as u64;
	// 828D3D60: 4851FCA9  bl 0x82df3a08
	ctx.lr = 0x828D3D64;
	sub_82DF3A08(ctx, base);
	// 828D3D64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D3D68: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D3D6C: 4858597D  bl 0x82e596e8
	ctx.lr = 0x828D3D70;
	sub_82E596E8(ctx, base);
	// 828D3D70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D3D74: 4851F6B5  bl 0x82df3428
	ctx.lr = 0x828D3D78;
	sub_82DF3428(ctx, base);
	// 828D3D78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D3D7C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D3D80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D3D84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D3D88: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D3D8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D3D90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D3D90 size=196
    let mut pc: u32 = 0x828D3D90;
    'dispatch: loop {
        match pc {
            0x828D3D90 => {
    //   block [0x828D3D90..0x828D3E54)
	// 828D3D90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D3D94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D3D98: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828D3D9C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D3DA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D3DA4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D3DA8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D3DAC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828D3DB0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828D3DB4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D3DB8: 4B9ECB81  bl 0x822c0938
	ctx.lr = 0x828D3DBC;
	sub_822C0938(ctx, base);
	// 828D3DBC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828D3DC0: 41820028  beq 0x828d3de8
	if ctx.cr[0].eq {
	pc = 0x828D3DE8; continue 'dispatch;
	}
	// 828D3DC4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D3DC8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828D3DCC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D3DD0: 392BF0AC  addi r9, r11, -0xf54
	ctx.r[9].s64 = ctx.r[11].s64 + -3924;
	// 828D3DD4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828D3DD8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828D3DDC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828D3DE0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828D3DE4: 48000008  b 0x828d3dec
	pc = 0x828D3DEC; continue 'dispatch;
	// 828D3DE8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D3DEC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D3DF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D3DF4: 409A0044  bne cr6, 0x828d3e38
	if !ctx.cr[6].eq {
	pc = 0x828D3E38; continue 'dispatch;
	}
	// 828D3DF8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828D3DFC: 419A001C  beq cr6, 0x828d3e18
	if ctx.cr[6].eq {
	pc = 0x828D3E18; continue 'dispatch;
	}
	// 828D3E00: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D3E04: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828D3E08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D3E0C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D3E10: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D3E14: 4E800421  bctrl
	ctx.lr = 0x828D3E18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D3E18: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D3E1C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828D3E20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D3E24: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828D3E28: 816B6068  lwz r11, 0x6068(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24680 as u32) ) } as u64;
	// 828D3E2C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828D3E30: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828D3E34: 4B9EC1CD  bl 0x822c0000
	ctx.lr = 0x828D3E38;
	sub_822C0000(ctx, base);
	// 828D3E38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D3E3C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D3E40: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D3E44: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D3E48: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828D3E4C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D3E50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D3E58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828D3E58 size=156
    let mut pc: u32 = 0x828D3E58;
    'dispatch: loop {
        match pc {
            0x828D3E58 => {
    //   block [0x828D3E58..0x828D3EF4)
	// 828D3E58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D3E5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D3E60: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828D3E64: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D3E68: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D3E6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D3E70: 48880791  bl 0x83154600
	ctx.lr = 0x828D3E74;
	sub_83154600(ctx, base);
	// 828D3E74: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D3E78: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828D3E7C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D3E80: 4E800421  bctrl
	ctx.lr = 0x828D3E84;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D3E84: 4BF1648D  bl 0x827ea310
	ctx.lr = 0x828D3E88;
	sub_827EA310(ctx, base);
	// 828D3E88: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D3E8C: 41820050  beq 0x828d3edc
	if ctx.cr[0].eq {
	pc = 0x828D3EDC; continue 'dispatch;
	}
	// 828D3E90: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D3E94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D3E98: 808B0B24  lwz r4, 0xb24(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2852 as u32) ) } as u64;
	// 828D3E9C: 4851FB6D  bl 0x82df3a08
	ctx.lr = 0x828D3EA0;
	sub_82DF3A08(ctx, base);
	// 828D3EA0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D3EA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D3EA8: 48734281  bl 0x83008128
	ctx.lr = 0x828D3EAC;
	sub_83008128(ctx, base);
	// 828D3EAC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828D3EB0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D3EB4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D3EB8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828D3EBC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D3EC0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828D3EC4: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828D3EC8: 4858AA99  bl 0x82e5e960
	ctx.lr = 0x828D3ECC;
	sub_82E5E960(ctx, base);
	// 828D3ECC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828D3ED0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D3ED4: 419A0008  beq cr6, 0x828d3edc
	if ctx.cr[6].eq {
	pc = 0x828D3EDC; continue 'dispatch;
	}
	// 828D3ED8: 4B9EC9B9  bl 0x822c0890
	ctx.lr = 0x828D3EDC;
	sub_822C0890(ctx, base);
	// 828D3EDC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828D3EE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D3EE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D3EE8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828D3EEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D3EF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D3EF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D3EF8 size=112
    let mut pc: u32 = 0x828D3EF8;
    'dispatch: loop {
        match pc {
            0x828D3EF8 => {
    //   block [0x828D3EF8..0x828D3F68)
	// 828D3EF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D3EFC: 488D4271  bl 0x831a816c
	ctx.lr = 0x828D3F00;
	sub_831A8130(ctx, base);
	// 828D3F00: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D3F04: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D3F08: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D3F0C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D3F10: 388BF0E8  addi r4, r11, -0xf18
	ctx.r[4].s64 = ctx.r[11].s64 + -3864;
	// 828D3F14: 38A00058  li r5, 0x58
	ctx.r[5].s64 = 88;
	// 828D3F18: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 828D3F1C: 4851E4CD  bl 0x82df23e8
	ctx.lr = 0x828D3F20;
	sub_82DF23E8(ctx, base);
	// 828D3F20: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828D3F24: 41820010  beq 0x828d3f34
	if ctx.cr[0].eq {
	pc = 0x828D3F34; continue 'dispatch;
	}
	// 828D3F28: 4BFFFE09  bl 0x828d3d30
	ctx.lr = 0x828D3F2C;
	sub_828D3D30(ctx, base);
	// 828D3F2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D3F30: 48000008  b 0x828d3f38
	pc = 0x828D3F38; continue 'dispatch;
	// 828D3F34: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828D3F38: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828D3F3C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828D3F40: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D3F44: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D3F48: 4BFFFE49  bl 0x828d3d90
	ctx.lr = 0x828D3F4C;
	sub_828D3D90(ctx, base);
	// 828D3F4C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D3F50: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D3F54: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D3F58: 4B9EC0A9  bl 0x822c0000
	ctx.lr = 0x828D3F5C;
	sub_822C0000(ctx, base);
	// 828D3F5C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D3F60: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D3F64: 488D4258  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D3F68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828D3F68 size=72
    let mut pc: u32 = 0x828D3F68;
    'dispatch: loop {
        match pc {
            0x828D3F68 => {
    //   block [0x828D3F68..0x828D3FB0)
	// 828D3F68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D3F6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D3F70: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D3F74: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D3F78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D3F7C: 485889AD  bl 0x82e5c928
	ctx.lr = 0x828D3F80;
	sub_82E5C928(ctx, base);
	// 828D3F80: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828D3F84: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828D3F88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D3F8C: 394AF164  addi r10, r10, -0xe9c
	ctx.r[10].s64 = ctx.r[10].s64 + -3740;
	// 828D3F90: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D3F94: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828D3F98: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828D3F9C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828D3FA0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D3FA4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D3FA8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D3FAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D3FB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D3FB0 size=60
    let mut pc: u32 = 0x828D3FB0;
    'dispatch: loop {
        match pc {
            0x828D3FB0 => {
    //   block [0x828D3FB0..0x828D3FEC)
	// 828D3FB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D3FB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D3FB8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D3FBC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D3FC0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D3FC4: 4BFFFFA5  bl 0x828d3f68
	ctx.lr = 0x828D3FC8;
	sub_828D3F68(ctx, base);
	// 828D3FC8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D3FCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D3FD0: 396BF18C  addi r11, r11, -0xe74
	ctx.r[11].s64 = ctx.r[11].s64 + -3700;
	// 828D3FD4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D3FD8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828D3FDC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D3FE0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D3FE4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D3FE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D3FF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D3FF0 size=60
    let mut pc: u32 = 0x828D3FF0;
    'dispatch: loop {
        match pc {
            0x828D3FF0 => {
    //   block [0x828D3FF0..0x828D402C)
	// 828D3FF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D3FF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D3FF8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D3FFC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D4000: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D4004: 4BFFFF65  bl 0x828d3f68
	ctx.lr = 0x828D4008;
	sub_828D3F68(ctx, base);
	// 828D4008: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D400C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D4010: 396BF1B8  addi r11, r11, -0xe48
	ctx.r[11].s64 = ctx.r[11].s64 + -3656;
	// 828D4014: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D4018: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828D401C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D4020: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D4024: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D4028: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D4030(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828D4030 size=156
    let mut pc: u32 = 0x828D4030;
    'dispatch: loop {
        match pc {
            0x828D4030 => {
    //   block [0x828D4030..0x828D40CC)
	// 828D4030: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D4034: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D4038: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828D403C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D4040: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D4044: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D4048: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828D404C: 488805B5  bl 0x83154600
	ctx.lr = 0x828D4050;
	sub_83154600(ctx, base);
	// 828D4050: 4BFE4C99  bl 0x828b8ce8
	ctx.lr = 0x828D4054;
	sub_828B8CE8(ctx, base);
	// 828D4054: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 828D4058: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 828D405C: 409A0058  bne cr6, 0x828d40b4
	if !ctx.cr[6].eq {
	pc = 0x828D40B4; continue 'dispatch;
	}
	// 828D4060: 4BF92419  bl 0x82866478
	ctx.lr = 0x828D4064;
	sub_82866478(ctx, base);
	// 828D4064: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828D4068: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828D406C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D4070: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D4074: 61290001  ori r9, r9, 1
	ctx.r[9].u64 = ctx.r[9].u64 | 1;
	// 828D4078: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828D407C: 808A0B08  lwz r4, 0xb08(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2824 as u32) ) } as u64;
	// 828D4080: 4851F989  bl 0x82df3a08
	ctx.lr = 0x828D4084;
	sub_82DF3A08(ctx, base);
	// 828D4084: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828D4088: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828D408C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828D4090: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D4094: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D4098: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D409C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828D40A0: 4858A9F1  bl 0x82e5ea90
	ctx.lr = 0x828D40A4;
	sub_82E5EA90(ctx, base);
	// 828D40A4: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828D40A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D40AC: 419A0008  beq cr6, 0x828d40b4
	if ctx.cr[6].eq {
	pc = 0x828D40B4; continue 'dispatch;
	}
	// 828D40B0: 4B9EC7E1  bl 0x822c0890
	ctx.lr = 0x828D40B4;
	sub_822C0890(ctx, base);
	// 828D40B4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828D40B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D40BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D40C0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828D40C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D40C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D40D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D40D0 size=96
    let mut pc: u32 = 0x828D40D0;
    'dispatch: loop {
        match pc {
            0x828D40D0 => {
    //   block [0x828D40D0..0x828D4130)
	// 828D40D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D40D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D40D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D40DC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D40E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D40E4: 4BFFFE85  bl 0x828d3f68
	ctx.lr = 0x828D40E8;
	sub_828D3F68(ctx, base);
	// 828D40E8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D40EC: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828D40F0: 396BF2A0  addi r11, r11, -0xd60
	ctx.r[11].s64 = ctx.r[11].s64 + -3424;
	// 828D40F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D40F8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D40FC: 808A0B30  lwz r4, 0xb30(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2864 as u32) ) } as u64;
	// 828D4100: 4851F909  bl 0x82df3a08
	ctx.lr = 0x828D4104;
	sub_82DF3A08(ctx, base);
	// 828D4104: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D4108: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D410C: 485855DD  bl 0x82e596e8
	ctx.lr = 0x828D4110;
	sub_82E596E8(ctx, base);
	// 828D4110: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D4114: 4851F315  bl 0x82df3428
	ctx.lr = 0x828D4118;
	sub_82DF3428(ctx, base);
	// 828D4118: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D411C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D4120: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D4124: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D4128: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D412C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D4130(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828D4130 size=128
    let mut pc: u32 = 0x828D4130;
    'dispatch: loop {
        match pc {
            0x828D4130 => {
    //   block [0x828D4130..0x828D41B0)
	// 828D4130: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D4134: 488D4039  bl 0x831a816c
	ctx.lr = 0x828D4138;
	sub_831A8130(ctx, base);
	// 828D4138: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 828D413C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D4140: 488804C1  bl 0x83154600
	ctx.lr = 0x828D4144;
	sub_83154600(ctx, base);
	// 828D4144: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D4148: 4BFE4BA1  bl 0x828b8ce8
	ctx.lr = 0x828D414C;
	sub_828B8CE8(ctx, base);
	// 828D414C: 3BE30010  addi r31, r3, 0x10
	ctx.r[31].s64 = ctx.r[3].s64 + 16;
	// 828D4150: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D4154: 48035435  bl 0x82909588
	ctx.lr = 0x828D4158;
	sub_82909588(ctx, base);
	// 828D4158: 4806C351  bl 0x829404a8
	ctx.lr = 0x828D415C;
	sub_829404A8(ctx, base);
	// 828D415C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828D4160: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D4164: 83DD0000  lwz r30, 0(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D4168: 4BF1B6E9  bl 0x827ef850
	ctx.lr = 0x828D416C;
	sub_827EF850(ctx, base);
	// 828D416C: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 828D4170: 815E0034  lwz r10, 0x34(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) } as u64;
	// 828D4174: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D4178: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D417C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D4180: C02B029C  lfs f1, 0x29c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(668 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828D4184: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828D4188: 4E800421  bctrl
	ctx.lr = 0x828D418C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D418C: 4BFFA855  bl 0x828ce9e0
	ctx.lr = 0x828D4190;
	sub_828CE9E0(ctx, base);
	// 828D4190: C3E30010  lfs f31, 0x10(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828D4194: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D4198: 480353E9  bl 0x82909580
	ctx.lr = 0x828D419C;
	sub_82909580(ctx, base);
	// 828D419C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828D41A0: 480476B1  bl 0x8291b850
	ctx.lr = 0x828D41A4;
	sub_8291B850(ctx, base);
	// 828D41A4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828D41A8: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 828D41AC: 488D4010  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D41B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D41B0 size=96
    let mut pc: u32 = 0x828D41B0;
    'dispatch: loop {
        match pc {
            0x828D41B0 => {
    //   block [0x828D41B0..0x828D4210)
	// 828D41B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D41B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D41B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D41BC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D41C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D41C4: 4BFFFDA5  bl 0x828d3f68
	ctx.lr = 0x828D41C8;
	sub_828D3F68(ctx, base);
	// 828D41C8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D41CC: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828D41D0: 396BF2CC  addi r11, r11, -0xd34
	ctx.r[11].s64 = ctx.r[11].s64 + -3380;
	// 828D41D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D41D8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D41DC: 808A0B88  lwz r4, 0xb88(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2952 as u32) ) } as u64;
	// 828D41E0: 4851F829  bl 0x82df3a08
	ctx.lr = 0x828D41E4;
	sub_82DF3A08(ctx, base);
	// 828D41E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D41E8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D41EC: 485854FD  bl 0x82e596e8
	ctx.lr = 0x828D41F0;
	sub_82E596E8(ctx, base);
	// 828D41F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D41F4: 4851F235  bl 0x82df3428
	ctx.lr = 0x828D41F8;
	sub_82DF3428(ctx, base);
	// 828D41F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D41FC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D4200: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D4204: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D4208: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D420C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D4210(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828D4210 size=296
    let mut pc: u32 = 0x828D4210;
    'dispatch: loop {
        match pc {
            0x828D4210 => {
    //   block [0x828D4210..0x828D4338)
	// 828D4210: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D4214: 488D3F55  bl 0x831a8168
	ctx.lr = 0x828D4218;
	sub_831A8130(ctx, base);
	// 828D4218: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D421C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D4220: 488803E1  bl 0x83154600
	ctx.lr = 0x828D4224;
	sub_83154600(ctx, base);
	// 828D4224: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828D4228: 4BFE4AC1  bl 0x828b8ce8
	ctx.lr = 0x828D422C;
	sub_828B8CE8(ctx, base);
	// 828D422C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D4230: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828D4234: 3BDF0010  addi r30, r31, 0x10
	ctx.r[30].s64 = ctx.r[31].s64 + 16;
	// 828D4238: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D423C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828D4240: 816B00D0  lwz r11, 0xd0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(208 as u32) ) } as u64;
	// 828D4244: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D4248: 4E800421  bctrl
	ctx.lr = 0x828D424C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D424C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828D4250: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828D4254: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D4258: 816B00D4  lwz r11, 0xd4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(212 as u32) ) } as u64;
	// 828D425C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D4260: 4E800421  bctrl
	ctx.lr = 0x828D4264;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D4264: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D4268: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D426C: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 828D4270: 83FC0000  lwz r31, 0(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D4274: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D4278: 4E800421  bctrl
	ctx.lr = 0x828D427C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D427C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D4280: 817F0098  lwz r11, 0x98(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 828D4284: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828D4288: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D428C: 4E800421  bctrl
	ctx.lr = 0x828D4290;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D4290: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D4294: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D4298: 808B5FF4  lwz r4, 0x5ff4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24564 as u32) ) } as u64;
	// 828D429C: 4851F76D  bl 0x82df3a08
	ctx.lr = 0x828D42A0;
	sub_82DF3A08(ctx, base);
	// 828D42A0: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D42A4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828D42A8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D42AC: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828D42B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D42B4: 4E800421  bctrl
	ctx.lr = 0x828D42B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D42B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D42BC: 4851F16D  bl 0x82df3428
	ctx.lr = 0x828D42C0;
	sub_82DF3428(ctx, base);
	// 828D42C0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828D42C4: 4BFE4A25  bl 0x828b8ce8
	ctx.lr = 0x828D42C8;
	sub_828B8CE8(ctx, base);
	// 828D42C8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D42CC: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D42D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D42D4: 4E800421  bctrl
	ctx.lr = 0x828D42D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D42D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D42DC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828D42E0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828D42E4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828D42E8: C1BF00D0  lfs f13, 0xd0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828D42EC: C19F00D4  lfs f12, 0xd4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828D42F0: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D42F4: D1A10060  stfs f13, 0x60(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828D42F8: D1810064  stfs f12, 0x64(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 828D42FC: D1A10068  stfs f13, 0x68(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 828D4300: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 828D4304: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D4308: 816B005C  lwz r11, 0x5c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 828D430C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D4310: 4E800421  bctrl
	ctx.lr = 0x828D4314;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D4314: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D4318: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828D431C: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828D4320: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D4324: 4E800421  bctrl
	ctx.lr = 0x828D4328;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D4328: C03F00BC  lfs f1, 0xbc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828D432C: 4BF1603D  bl 0x827ea368
	ctx.lr = 0x828D4330;
	sub_827EA368(ctx, base);
	// 828D4330: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828D4334: 488D3E84  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D4338(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828D4338 size=204
    let mut pc: u32 = 0x828D4338;
    'dispatch: loop {
        match pc {
            0x828D4338 => {
    //   block [0x828D4338..0x828D4404)
	// 828D4338: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D433C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D4340: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828D4344: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D4348: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D434C: 488802B5  bl 0x83154600
	ctx.lr = 0x828D4350;
	sub_83154600(ctx, base);
	// 828D4350: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D4354: 4BFE4995  bl 0x828b8ce8
	ctx.lr = 0x828D4358;
	sub_828B8CE8(ctx, base);
	// 828D4358: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828D435C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828D4360: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D4364: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828D4368: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D436C: C00B08A8  lfs f0, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D4370: C1AA08A4  lfs f13, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828D4374: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828D4378: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 828D437C: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 828D4380: D1A1006C  stfs f13, 0x6c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 828D4384: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D4388: 816B005C  lwz r11, 0x5c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 828D438C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D4390: 4E800421  bctrl
	ctx.lr = 0x828D4394;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D4394: 809E0398  lwz r4, 0x398(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(920 as u32) ) } as u64;
	// 828D4398: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828D439C: 419A0050  beq cr6, 0x828d43ec
	if ctx.cr[6].eq {
	pc = 0x828D43EC; continue 'dispatch;
	}
	// 828D43A0: 3BFE0010  addi r31, r30, 0x10
	ctx.r[31].s64 = ctx.r[30].s64 + 16;
	// 828D43A4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828D43A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D43AC: 4BF17EBD  bl 0x827ec268
	ctx.lr = 0x828D43B0;
	sub_827EC268(ctx, base);
	// 828D43B0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D43B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D43B8: 4BC3B111  bl 0x8250f4c8
	ctx.lr = 0x828D43BC;
	sub_8250F4C8(ctx, base);
	// 828D43BC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D43C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D43C4: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 828D43C8: 409A0008  bne cr6, 0x828d43d0
	if !ctx.cr[6].eq {
	pc = 0x828D43D0; continue 'dispatch;
	}
	// 828D43CC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828D43D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D43D4: 80BE0398  lwz r5, 0x398(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(920 as u32) ) } as u64;
	// 828D43D8: 4BF17EB9  bl 0x827ec290
	ctx.lr = 0x828D43DC;
	sub_827EC290(ctx, base);
	// 828D43DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D43E0: 4851D8B1  bl 0x82df1c90
	ctx.lr = 0x828D43E4;
	sub_82DF1C90(ctx, base);
	// 828D43E4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D43E8: 917E0398  stw r11, 0x398(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(920 as u32), ctx.r[11].u32 ) };
	// 828D43EC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828D43F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D43F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D43F8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828D43FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D4400: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D4408(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D4408 size=96
    let mut pc: u32 = 0x828D4408;
    'dispatch: loop {
        match pc {
            0x828D4408 => {
    //   block [0x828D4408..0x828D4468)
	// 828D4408: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D440C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D4410: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D4414: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D4418: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D441C: 4BFFFB4D  bl 0x828d3f68
	ctx.lr = 0x828D4420;
	sub_828D3F68(ctx, base);
	// 828D4420: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D4424: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828D4428: 396BF2F4  addi r11, r11, -0xd0c
	ctx.r[11].s64 = ctx.r[11].s64 + -3340;
	// 828D442C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D4430: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D4434: 808A0B34  lwz r4, 0xb34(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2868 as u32) ) } as u64;
	// 828D4438: 4851F5D1  bl 0x82df3a08
	ctx.lr = 0x828D443C;
	sub_82DF3A08(ctx, base);
	// 828D443C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D4440: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D4444: 485852A5  bl 0x82e596e8
	ctx.lr = 0x828D4448;
	sub_82E596E8(ctx, base);
	// 828D4448: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D444C: 4851EFDD  bl 0x82df3428
	ctx.lr = 0x828D4450;
	sub_82DF3428(ctx, base);
	// 828D4450: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D4454: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D4458: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D445C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D4460: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D4464: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D4468(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D4468 size=264
    let mut pc: u32 = 0x828D4468;
    'dispatch: loop {
        match pc {
            0x828D4468 => {
    //   block [0x828D4468..0x828D4570)
	// 828D4468: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D446C: 488D3CFD  bl 0x831a8168
	ctx.lr = 0x828D4470;
	sub_831A8130(ctx, base);
	// 828D4470: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D4474: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828D4478: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D447C: 48880185  bl 0x83154600
	ctx.lr = 0x828D4480;
	sub_83154600(ctx, base);
	// 828D4480: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D4484: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828D4488: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D448C: 4E800421  bctrl
	ctx.lr = 0x828D4490;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D4490: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D4494: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D4498: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D449C: 808B5FFC  lwz r4, 0x5ffc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24572 as u32) ) } as u64;
	// 828D44A0: 4851F569  bl 0x82df3a08
	ctx.lr = 0x828D44A4;
	sub_82DF3A08(ctx, base);
	// 828D44A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D44A8: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 828D44AC: 3BA10054  addi r29, r1, 0x54
	ctx.r[29].s64 = ctx.r[1].s64 + 84;
	// 828D44B0: 4BF15DF9  bl 0x827ea2a8
	ctx.lr = 0x828D44B4;
	sub_827EA2A8(ctx, base);
	// 828D44B4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828D44B8: 4851EE51  bl 0x82df3308
	ctx.lr = 0x828D44BC;
	sub_82DF3308(ctx, base);
	// 828D44BC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D44C0: 40820038  bne 0x828d44f8
	if !ctx.cr[0].eq {
	pc = 0x828D44F8; continue 'dispatch;
	}
	// 828D44C4: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D44C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D44CC: 808B6000  lwz r4, 0x6000(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24576 as u32) ) } as u64;
	// 828D44D0: 4851F539  bl 0x82df3a08
	ctx.lr = 0x828D44D4;
	sub_82DF3A08(ctx, base);
	// 828D44D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D44D8: 3BE00003  li r31, 3
	ctx.r[31].s64 = 3;
	// 828D44DC: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 828D44E0: 4BF15DC9  bl 0x827ea2a8
	ctx.lr = 0x828D44E4;
	sub_827EA2A8(ctx, base);
	// 828D44E4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828D44E8: 4851EE21  bl 0x82df3308
	ctx.lr = 0x828D44EC;
	sub_82DF3308(ctx, base);
	// 828D44EC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D44F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D44F4: 41820008  beq 0x828d44fc
	if ctx.cr[0].eq {
	pc = 0x828D44FC; continue 'dispatch;
	}
	// 828D44F8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D44FC: 57EA07BD  rlwinm. r10, r31, 0, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828D4500: 557D063E  clrlwi r29, r11, 0x18
	ctx.r[29].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D4504: 41820010  beq 0x828d4514
	if ctx.cr[0].eq {
	pc = 0x828D4514; continue 'dispatch;
	}
	// 828D4508: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D450C: 57FF07FA  rlwinm r31, r31, 0, 0x1f, 0x1d
	ctx.r[31].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	// 828D4510: 4851EF19  bl 0x82df3428
	ctx.lr = 0x828D4514;
	sub_82DF3428(ctx, base);
	// 828D4514: 57EB07FF  clrlwi. r11, r31, 0x1f
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D4518: 4182000C  beq 0x828d4524
	if ctx.cr[0].eq {
	pc = 0x828D4524; continue 'dispatch;
	}
	// 828D451C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D4520: 4851EF09  bl 0x82df3428
	ctx.lr = 0x828D4524;
	sub_82DF3428(ctx, base);
	// 828D4524: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D4528: 41820040  beq 0x828d4568
	if ctx.cr[0].eq {
	pc = 0x828D4568; continue 'dispatch;
	}
	// 828D452C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D4530: 4BF15DE1  bl 0x827ea310
	ctx.lr = 0x828D4534;
	sub_827EA310(ctx, base);
	// 828D4534: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D4538: 41820030  beq 0x828d4568
	if ctx.cr[0].eq {
	pc = 0x828D4568; continue 'dispatch;
	}
	// 828D453C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D4540: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D4544: 808B0B24  lwz r4, 0xb24(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2852 as u32) ) } as u64;
	// 828D4548: 4851F4C1  bl 0x82df3a08
	ctx.lr = 0x828D454C;
	sub_82DF3A08(ctx, base);
	// 828D454C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828D4550: 3BE10054  addi r31, r1, 0x54
	ctx.r[31].s64 = ctx.r[1].s64 + 84;
	// 828D4554: 488800AD  bl 0x83154600
	ctx.lr = 0x828D4558;
	sub_83154600(ctx, base);
	// 828D4558: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D455C: 4BF1B1E5  bl 0x827ef740
	ctx.lr = 0x828D4560;
	sub_827EF740(ctx, base);
	// 828D4560: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D4564: 4851EEC5  bl 0x82df3428
	ctx.lr = 0x828D4568;
	sub_82DF3428(ctx, base);
	// 828D4568: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828D456C: 488D3C4C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D4570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D4570 size=96
    let mut pc: u32 = 0x828D4570;
    'dispatch: loop {
        match pc {
            0x828D4570 => {
    //   block [0x828D4570..0x828D45D0)
	// 828D4570: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D4574: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D4578: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D457C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D4580: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D4584: 4BFFF9E5  bl 0x828d3f68
	ctx.lr = 0x828D4588;
	sub_828D3F68(ctx, base);
	// 828D4588: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D458C: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 828D4590: 396BF31C  addi r11, r11, -0xce4
	ctx.r[11].s64 = ctx.r[11].s64 + -3300;
	// 828D4594: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D4598: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D459C: 808A6060  lwz r4, 0x6060(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24672 as u32) ) } as u64;
	// 828D45A0: 4851F469  bl 0x82df3a08
	ctx.lr = 0x828D45A4;
	sub_82DF3A08(ctx, base);
	// 828D45A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D45A8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D45AC: 4858513D  bl 0x82e596e8
	ctx.lr = 0x828D45B0;
	sub_82E596E8(ctx, base);
	// 828D45B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D45B4: 4851EE75  bl 0x82df3428
	ctx.lr = 0x828D45B8;
	sub_82DF3428(ctx, base);
	// 828D45B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D45BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D45C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D45C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D45C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D45CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D45D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828D45D0 size=168
    let mut pc: u32 = 0x828D45D0;
    'dispatch: loop {
        match pc {
            0x828D45D0 => {
    //   block [0x828D45D0..0x828D4678)
	// 828D45D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D45D4: 488D3B99  bl 0x831a816c
	ctx.lr = 0x828D45D8;
	sub_831A8130(ctx, base);
	// 828D45D8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D45DC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D45E0: 48880021  bl 0x83154600
	ctx.lr = 0x828D45E4;
	sub_83154600(ctx, base);
	// 828D45E4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D45E8: 4BFE4701  bl 0x828b8ce8
	ctx.lr = 0x828D45EC;
	sub_828B8CE8(ctx, base);
	// 828D45EC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828D45F0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828D45F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D45F8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828D45FC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D4600: C00B08A8  lfs f0, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D4604: C1AA08A4  lfs f13, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828D4608: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828D460C: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 828D4610: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 828D4614: D1A1006C  stfs f13, 0x6c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 828D4618: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D461C: 816B005C  lwz r11, 0x5c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 828D4620: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D4624: 4E800421  bctrl
	ctx.lr = 0x828D4628;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D4628: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 828D462C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828D4630: 809E0064  lwz r4, 0x64(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 828D4634: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D4638: 4BF17C31  bl 0x827ec268
	ctx.lr = 0x828D463C;
	sub_827EC268(ctx, base);
	// 828D463C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D4640: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D4644: 4BC3AE85  bl 0x8250f4c8
	ctx.lr = 0x828D4648;
	sub_8250F4C8(ctx, base);
	// 828D4648: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D464C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D4650: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 828D4654: 409A0008  bne cr6, 0x828d465c
	if !ctx.cr[6].eq {
	pc = 0x828D465C; continue 'dispatch;
	}
	// 828D4658: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828D465C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D4660: 80BE0064  lwz r5, 0x64(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 828D4664: 4BF17C2D  bl 0x827ec290
	ctx.lr = 0x828D4668;
	sub_827EC290(ctx, base);
	// 828D4668: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D466C: 4851D625  bl 0x82df1c90
	ctx.lr = 0x828D4670;
	sub_82DF1C90(ctx, base);
	// 828D4670: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828D4674: 488D3B48  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D4678(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D4678 size=104
    let mut pc: u32 = 0x828D4678;
    'dispatch: loop {
        match pc {
            0x828D4678 => {
    //   block [0x828D4678..0x828D46E0)
	// 828D4678: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D467C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D4680: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D4684: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D4688: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D468C: 4BFFF8DD  bl 0x828d3f68
	ctx.lr = 0x828D4690;
	sub_828D3F68(ctx, base);
	// 828D4690: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D4694: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828D4698: 396BF344  addi r11, r11, -0xcbc
	ctx.r[11].s64 = ctx.r[11].s64 + -3260;
	// 828D469C: 915F0064  stw r10, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 828D46A0: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828D46A4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D46A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D46AC: 808A0B28  lwz r4, 0xb28(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2856 as u32) ) } as u64;
	// 828D46B0: 4851F359  bl 0x82df3a08
	ctx.lr = 0x828D46B4;
	sub_82DF3A08(ctx, base);
	// 828D46B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D46B8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D46BC: 4858502D  bl 0x82e596e8
	ctx.lr = 0x828D46C0;
	sub_82E596E8(ctx, base);
	// 828D46C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D46C4: 4851ED65  bl 0x82df3428
	ctx.lr = 0x828D46C8;
	sub_82DF3428(ctx, base);
	// 828D46C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D46CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D46D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D46D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D46D8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D46DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D46E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D46E0 size=96
    let mut pc: u32 = 0x828D46E0;
    'dispatch: loop {
        match pc {
            0x828D46E0 => {
    //   block [0x828D46E0..0x828D4740)
	// 828D46E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D46E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D46E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D46EC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D46F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D46F4: 4BFFF875  bl 0x828d3f68
	ctx.lr = 0x828D46F8;
	sub_828D3F68(ctx, base);
	// 828D46F8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D46FC: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828D4700: 396BF36C  addi r11, r11, -0xc94
	ctx.r[11].s64 = ctx.r[11].s64 + -3220;
	// 828D4704: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D4708: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D470C: 808A0BC0  lwz r4, 0xbc0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3008 as u32) ) } as u64;
	// 828D4710: 4851F2F9  bl 0x82df3a08
	ctx.lr = 0x828D4714;
	sub_82DF3A08(ctx, base);
	// 828D4714: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D4718: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D471C: 48584FCD  bl 0x82e596e8
	ctx.lr = 0x828D4720;
	sub_82E596E8(ctx, base);
	// 828D4720: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D4724: 4851ED05  bl 0x82df3428
	ctx.lr = 0x828D4728;
	sub_82DF3428(ctx, base);
	// 828D4728: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D472C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D4730: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D4734: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D4738: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D473C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D4740(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828D4740 size=300
    let mut pc: u32 = 0x828D4740;
    'dispatch: loop {
        match pc {
            0x828D4740 => {
    //   block [0x828D4740..0x828D486C)
	// 828D4740: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D4744: 488D3A25  bl 0x831a8168
	ctx.lr = 0x828D4748;
	sub_831A8130(ctx, base);
	// 828D4748: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 828D474C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D4750: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D4754: 4887FEAD  bl 0x83154600
	ctx.lr = 0x828D4758;
	sub_83154600(ctx, base);
	// 828D4758: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D475C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D4760: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828D4764: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D4768: 4E800421  bctrl
	ctx.lr = 0x828D476C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D476C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828D4770: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D4774: 48584FED  bl 0x82e59760
	ctx.lr = 0x828D4778;
	sub_82E59760(ctx, base);
	// 828D4778: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D477C: C00BACFC  lfs f0, -0x5304(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-21252 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D4780: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 828D4784: 40980088  bge cr6, 0x828d480c
	if !ctx.cr[6].lt {
	pc = 0x828D480C; continue 'dispatch;
	}
	// 828D4788: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D478C: 48584FD5  bl 0x82e59760
	ctx.lr = 0x828D4790;
	sub_82E59760(ctx, base);
	// 828D4790: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828D4794: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828D4798: C00B03E8  lfs f0, 0x3e8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1000 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D479C: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 828D47A0: C3EA08A8  lfs f31, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828D47A4: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 828D47A8: 4099000C  ble cr6, 0x828d47b4
	if !ctx.cr[6].gt {
	pc = 0x828D47B4; continue 'dispatch;
	}
	// 828D47AC: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 828D47B0: 48000014  b 0x828d47c4
	pc = 0x828D47C4; continue 'dispatch;
	// 828D47B4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828D47B8: C1AB08A4  lfs f13, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828D47BC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 828D47C0: 41980008  blt cr6, 0x828d47c8
	if ctx.cr[6].lt {
	pc = 0x828D47C8; continue 'dispatch;
	}
	// 828D47C4: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 828D47C8: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 828D47CC: C00BDFAC  lfs f0, -0x2054(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D47D0: EC200372  fmuls f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 828D47D4: 488D46D5  bl 0x831a8ea8
	ctx.lr = 0x828D47D8;
	sub_831A8EA8(ctx, base);
	// 828D47D8: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 828D47DC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828D47E0: 38BF0080  addi r5, r31, 0x80
	ctx.r[5].s64 = ctx.r[31].s64 + 128;
	// 828D47E4: 83BE0000  lwz r29, 0(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D47E8: 389F0070  addi r4, r31, 0x70
	ctx.r[4].s64 = ctx.r[31].s64 + 112;
	// 828D47EC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D47F0: C00B9450  lfs f0, -0x6bb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D47F4: EDADF82A  fadds f13, f13, f31
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[31].f64) as f32) as f64;
	// 828D47F8: EC2DF83C  fnmsubs f1, f13, f0, f31
	ctx.f[1].f64 = -(((ctx.f[13].f64 * ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 828D47FC: 485A8ACD  bl 0x82e7d2c8
	ctx.lr = 0x828D4800;
	sub_82E7D2C8(ctx, base);
	// 828D4800: 817D0014  lwz r11, 0x14(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 828D4804: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D4808: 48000010  b 0x828d4818
	pc = 0x828D4818; continue 'dispatch;
	// 828D480C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D4810: 389F0080  addi r4, r31, 0x80
	ctx.r[4].s64 = ctx.r[31].s64 + 128;
	// 828D4814: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 828D4818: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D481C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D4820: 4E800421  bctrl
	ctx.lr = 0x828D4824;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D4824: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828D4828: 4BF15AE9  bl 0x827ea310
	ctx.lr = 0x828D482C;
	sub_827EA310(ctx, base);
	// 828D482C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D4830: 41820030  beq 0x828d4860
	if ctx.cr[0].eq {
	pc = 0x828D4860; continue 'dispatch;
	}
	// 828D4834: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D4838: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D483C: 808B0B2C  lwz r4, 0xb2c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2860 as u32) ) } as u64;
	// 828D4840: 4851F1C9  bl 0x82df3a08
	ctx.lr = 0x828D4844;
	sub_82DF3A08(ctx, base);
	// 828D4844: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D4848: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 828D484C: 4887FDB5  bl 0x83154600
	ctx.lr = 0x828D4850;
	sub_83154600(ctx, base);
	// 828D4850: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D4854: 4BF1AEED  bl 0x827ef740
	ctx.lr = 0x828D4858;
	sub_827EF740(ctx, base);
	// 828D4858: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D485C: 4851EBCD  bl 0x82df3428
	ctx.lr = 0x828D4860;
	sub_82DF3428(ctx, base);
	// 828D4860: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828D4864: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 828D4868: 488D3950  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D4870(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D4870 size=88
    let mut pc: u32 = 0x828D4870;
    'dispatch: loop {
        match pc {
            0x828D4870 => {
    //   block [0x828D4870..0x828D48C8)
	// 828D4870: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D4874: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D4878: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828D487C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D4880: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D4884: 4887FD7D  bl 0x83154600
	ctx.lr = 0x828D4888;
	sub_83154600(ctx, base);
	// 828D4888: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D488C: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D4890: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 828D4894: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D4898: 4E800421  bctrl
	ctx.lr = 0x828D489C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D489C: 88830010  lbz r4, 0x10(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 828D48A0: 817E0048  lwz r11, 0x48(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D48A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D48A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D48AC: 4E800421  bctrl
	ctx.lr = 0x828D48B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D48B0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D48B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D48B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D48BC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828D48C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D48C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D48C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D48C8 size=96
    let mut pc: u32 = 0x828D48C8;
    'dispatch: loop {
        match pc {
            0x828D48C8 => {
    //   block [0x828D48C8..0x828D4928)
	// 828D48C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D48CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D48D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D48D4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D48D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D48DC: 4BFFF68D  bl 0x828d3f68
	ctx.lr = 0x828D48E0;
	sub_828D3F68(ctx, base);
	// 828D48E0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D48E4: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 828D48E8: 396BF394  addi r11, r11, -0xc6c
	ctx.r[11].s64 = ctx.r[11].s64 + -3180;
	// 828D48EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D48F0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D48F4: 808A605C  lwz r4, 0x605c(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24668 as u32) ) } as u64;
	// 828D48F8: 4851F111  bl 0x82df3a08
	ctx.lr = 0x828D48FC;
	sub_82DF3A08(ctx, base);
	// 828D48FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D4900: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D4904: 48584DE5  bl 0x82e596e8
	ctx.lr = 0x828D4908;
	sub_82E596E8(ctx, base);
	// 828D4908: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D490C: 4851EB1D  bl 0x82df3428
	ctx.lr = 0x828D4910;
	sub_82DF3428(ctx, base);
	// 828D4910: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D4914: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D4918: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D491C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D4920: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D4924: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D4928(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D4928 size=176
    let mut pc: u32 = 0x828D4928;
    'dispatch: loop {
        match pc {
            0x828D4928 => {
    //   block [0x828D4928..0x828D49D8)
	// 828D4928: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D492C: 488D383D  bl 0x831a8168
	ctx.lr = 0x828D4930;
	sub_831A8130(ctx, base);
	// 828D4930: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D4934: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D4938: 4887FCC9  bl 0x83154600
	ctx.lr = 0x828D493C;
	sub_83154600(ctx, base);
	// 828D493C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828D4940: 4BFE43A9  bl 0x828b8ce8
	ctx.lr = 0x828D4944;
	sub_828B8CE8(ctx, base);
	// 828D4944: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D4948: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828D494C: 3BDF0010  addi r30, r31, 0x10
	ctx.r[30].s64 = ctx.r[31].s64 + 16;
	// 828D4950: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D4954: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828D4958: 816B00D0  lwz r11, 0xd0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(208 as u32) ) } as u64;
	// 828D495C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D4960: 4E800421  bctrl
	ctx.lr = 0x828D4964;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D4964: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828D4968: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828D496C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D4970: 816B00D4  lwz r11, 0xd4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(212 as u32) ) } as u64;
	// 828D4974: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D4978: 4E800421  bctrl
	ctx.lr = 0x828D497C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D497C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D4980: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D4984: 808B0BD8  lwz r4, 0xbd8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3032 as u32) ) } as u64;
	// 828D4988: 4851F081  bl 0x82df3a08
	ctx.lr = 0x828D498C;
	sub_82DF3A08(ctx, base);
	// 828D498C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828D4990: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D4994: 4BF1ADDD  bl 0x827ef770
	ctx.lr = 0x828D4998;
	sub_827EF770(ctx, base);
	// 828D4998: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D499C: 4851EA8D  bl 0x82df3428
	ctx.lr = 0x828D49A0;
	sub_82DF3428(ctx, base);
	// 828D49A0: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D49A4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828D49A8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828D49AC: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D49B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D49B4: 4E800421  bctrl
	ctx.lr = 0x828D49B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D49B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D49BC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828D49C0: 917D0064  stw r11, 0x64(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828D49C4: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 828D49C8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828D49CC: 48042655  bl 0x82917020
	ctx.lr = 0x828D49D0;
	sub_82917020(ctx, base);
	// 828D49D0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828D49D4: 488D37E4  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D49D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D49D8 size=196
    let mut pc: u32 = 0x828D49D8;
    'dispatch: loop {
        match pc {
            0x828D49D8 => {
    //   block [0x828D49D8..0x828D4A9C)
	// 828D49D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D49DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D49E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828D49E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D49E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D49EC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D49F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D49F4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828D49F8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828D49FC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D4A00: 4B9EBF39  bl 0x822c0938
	ctx.lr = 0x828D4A04;
	sub_822C0938(ctx, base);
	// 828D4A04: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828D4A08: 41820028  beq 0x828d4a30
	if ctx.cr[0].eq {
	pc = 0x828D4A30; continue 'dispatch;
	}
	// 828D4A0C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D4A10: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828D4A14: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D4A18: 392BF1EC  addi r9, r11, -0xe14
	ctx.r[9].s64 = ctx.r[11].s64 + -3604;
	// 828D4A1C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828D4A20: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828D4A24: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828D4A28: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828D4A2C: 48000008  b 0x828d4a34
	pc = 0x828D4A34; continue 'dispatch;
	// 828D4A30: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D4A34: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D4A38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D4A3C: 409A0044  bne cr6, 0x828d4a80
	if !ctx.cr[6].eq {
	pc = 0x828D4A80; continue 'dispatch;
	}
	// 828D4A40: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828D4A44: 419A001C  beq cr6, 0x828d4a60
	if ctx.cr[6].eq {
	pc = 0x828D4A60; continue 'dispatch;
	}
	// 828D4A48: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D4A4C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828D4A50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D4A54: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D4A58: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D4A5C: 4E800421  bctrl
	ctx.lr = 0x828D4A60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D4A60: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D4A64: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828D4A68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D4A6C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828D4A70: 816B61F4  lwz r11, 0x61f4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(25076 as u32) ) } as u64;
	// 828D4A74: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828D4A78: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828D4A7C: 4B9EB585  bl 0x822c0000
	ctx.lr = 0x828D4A80;
	sub_822C0000(ctx, base);
	// 828D4A80: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D4A84: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D4A88: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D4A8C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D4A90: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828D4A94: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D4A98: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D4AA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D4AA0 size=196
    let mut pc: u32 = 0x828D4AA0;
    'dispatch: loop {
        match pc {
            0x828D4AA0 => {
    //   block [0x828D4AA0..0x828D4B64)
	// 828D4AA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D4AA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D4AA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828D4AAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D4AB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D4AB4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D4AB8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D4ABC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828D4AC0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828D4AC4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D4AC8: 4B9EBE71  bl 0x822c0938
	ctx.lr = 0x828D4ACC;
	sub_822C0938(ctx, base);
	// 828D4ACC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828D4AD0: 41820028  beq 0x828d4af8
	if ctx.cr[0].eq {
	pc = 0x828D4AF8; continue 'dispatch;
	}
	// 828D4AD4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D4AD8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828D4ADC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D4AE0: 392BF200  addi r9, r11, -0xe00
	ctx.r[9].s64 = ctx.r[11].s64 + -3584;
	// 828D4AE4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828D4AE8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828D4AEC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828D4AF0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828D4AF4: 48000008  b 0x828d4afc
	pc = 0x828D4AFC; continue 'dispatch;
	// 828D4AF8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D4AFC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D4B00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D4B04: 409A0044  bne cr6, 0x828d4b48
	if !ctx.cr[6].eq {
	pc = 0x828D4B48; continue 'dispatch;
	}
	// 828D4B08: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828D4B0C: 419A001C  beq cr6, 0x828d4b28
	if ctx.cr[6].eq {
	pc = 0x828D4B28; continue 'dispatch;
	}
	// 828D4B10: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D4B14: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828D4B18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D4B1C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D4B20: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D4B24: 4E800421  bctrl
	ctx.lr = 0x828D4B28;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D4B28: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D4B2C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828D4B30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D4B34: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828D4B38: 816B61F4  lwz r11, 0x61f4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(25076 as u32) ) } as u64;
	// 828D4B3C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828D4B40: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828D4B44: 4B9EB4BD  bl 0x822c0000
	ctx.lr = 0x828D4B48;
	sub_822C0000(ctx, base);
	// 828D4B48: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D4B4C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D4B50: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D4B54: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D4B58: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828D4B5C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D4B60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D4B68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D4B68 size=196
    let mut pc: u32 = 0x828D4B68;
    'dispatch: loop {
        match pc {
            0x828D4B68 => {
    //   block [0x828D4B68..0x828D4C2C)
	// 828D4B68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D4B6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D4B70: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828D4B74: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D4B78: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D4B7C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D4B80: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D4B84: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828D4B88: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828D4B8C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D4B90: 4B9EBDA9  bl 0x822c0938
	ctx.lr = 0x828D4B94;
	sub_822C0938(ctx, base);
	// 828D4B94: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828D4B98: 41820028  beq 0x828d4bc0
	if ctx.cr[0].eq {
	pc = 0x828D4BC0; continue 'dispatch;
	}
	// 828D4B9C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D4BA0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828D4BA4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D4BA8: 392BF214  addi r9, r11, -0xdec
	ctx.r[9].s64 = ctx.r[11].s64 + -3564;
	// 828D4BAC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828D4BB0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828D4BB4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828D4BB8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828D4BBC: 48000008  b 0x828d4bc4
	pc = 0x828D4BC4; continue 'dispatch;
	// 828D4BC0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D4BC4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D4BC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D4BCC: 409A0044  bne cr6, 0x828d4c10
	if !ctx.cr[6].eq {
	pc = 0x828D4C10; continue 'dispatch;
	}
	// 828D4BD0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828D4BD4: 419A001C  beq cr6, 0x828d4bf0
	if ctx.cr[6].eq {
	pc = 0x828D4BF0; continue 'dispatch;
	}
	// 828D4BD8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D4BDC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828D4BE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D4BE4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D4BE8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D4BEC: 4E800421  bctrl
	ctx.lr = 0x828D4BF0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D4BF0: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D4BF4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828D4BF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D4BFC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828D4C00: 816B61F4  lwz r11, 0x61f4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(25076 as u32) ) } as u64;
	// 828D4C04: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828D4C08: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828D4C0C: 4B9EB3F5  bl 0x822c0000
	ctx.lr = 0x828D4C10;
	sub_822C0000(ctx, base);
	// 828D4C10: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D4C14: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D4C18: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D4C1C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D4C20: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828D4C24: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D4C28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D4C30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D4C30 size=196
    let mut pc: u32 = 0x828D4C30;
    'dispatch: loop {
        match pc {
            0x828D4C30 => {
    //   block [0x828D4C30..0x828D4CF4)
	// 828D4C30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D4C34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D4C38: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828D4C3C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D4C40: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D4C44: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D4C48: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D4C4C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828D4C50: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828D4C54: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D4C58: 4B9EBCE1  bl 0x822c0938
	ctx.lr = 0x828D4C5C;
	sub_822C0938(ctx, base);
	// 828D4C5C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828D4C60: 41820028  beq 0x828d4c88
	if ctx.cr[0].eq {
	pc = 0x828D4C88; continue 'dispatch;
	}
	// 828D4C64: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D4C68: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828D4C6C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D4C70: 392BF228  addi r9, r11, -0xdd8
	ctx.r[9].s64 = ctx.r[11].s64 + -3544;
	// 828D4C74: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828D4C78: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828D4C7C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828D4C80: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828D4C84: 48000008  b 0x828d4c8c
	pc = 0x828D4C8C; continue 'dispatch;
	// 828D4C88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D4C8C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D4C90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D4C94: 409A0044  bne cr6, 0x828d4cd8
	if !ctx.cr[6].eq {
	pc = 0x828D4CD8; continue 'dispatch;
	}
	// 828D4C98: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828D4C9C: 419A001C  beq cr6, 0x828d4cb8
	if ctx.cr[6].eq {
	pc = 0x828D4CB8; continue 'dispatch;
	}
	// 828D4CA0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D4CA4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828D4CA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D4CAC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D4CB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D4CB4: 4E800421  bctrl
	ctx.lr = 0x828D4CB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D4CB8: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D4CBC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828D4CC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D4CC4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828D4CC8: 816B61F4  lwz r11, 0x61f4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(25076 as u32) ) } as u64;
	// 828D4CCC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828D4CD0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828D4CD4: 4B9EB32D  bl 0x822c0000
	ctx.lr = 0x828D4CD8;
	sub_822C0000(ctx, base);
	// 828D4CD8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D4CDC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D4CE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D4CE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D4CE8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828D4CEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D4CF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D4CF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D4CF8 size=196
    let mut pc: u32 = 0x828D4CF8;
    'dispatch: loop {
        match pc {
            0x828D4CF8 => {
    //   block [0x828D4CF8..0x828D4DBC)
	// 828D4CF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D4CFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D4D00: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828D4D04: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D4D08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D4D0C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D4D10: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D4D14: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828D4D18: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828D4D1C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D4D20: 4B9EBC19  bl 0x822c0938
	ctx.lr = 0x828D4D24;
	sub_822C0938(ctx, base);
	// 828D4D24: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828D4D28: 41820028  beq 0x828d4d50
	if ctx.cr[0].eq {
	pc = 0x828D4D50; continue 'dispatch;
	}
	// 828D4D2C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D4D30: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828D4D34: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D4D38: 392BF23C  addi r9, r11, -0xdc4
	ctx.r[9].s64 = ctx.r[11].s64 + -3524;
	// 828D4D3C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828D4D40: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828D4D44: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828D4D48: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828D4D4C: 48000008  b 0x828d4d54
	pc = 0x828D4D54; continue 'dispatch;
	// 828D4D50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D4D54: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D4D58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D4D5C: 409A0044  bne cr6, 0x828d4da0
	if !ctx.cr[6].eq {
	pc = 0x828D4DA0; continue 'dispatch;
	}
	// 828D4D60: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828D4D64: 419A001C  beq cr6, 0x828d4d80
	if ctx.cr[6].eq {
	pc = 0x828D4D80; continue 'dispatch;
	}
	// 828D4D68: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D4D6C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828D4D70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D4D74: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D4D78: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D4D7C: 4E800421  bctrl
	ctx.lr = 0x828D4D80;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D4D80: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D4D84: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828D4D88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D4D8C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828D4D90: 816B61F4  lwz r11, 0x61f4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(25076 as u32) ) } as u64;
	// 828D4D94: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828D4D98: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828D4D9C: 4B9EB265  bl 0x822c0000
	ctx.lr = 0x828D4DA0;
	sub_822C0000(ctx, base);
	// 828D4DA0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D4DA4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D4DA8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D4DAC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D4DB0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828D4DB4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D4DB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D4DC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D4DC0 size=196
    let mut pc: u32 = 0x828D4DC0;
    'dispatch: loop {
        match pc {
            0x828D4DC0 => {
    //   block [0x828D4DC0..0x828D4E84)
	// 828D4DC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D4DC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D4DC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828D4DCC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D4DD0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D4DD4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D4DD8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D4DDC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828D4DE0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828D4DE4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D4DE8: 4B9EBB51  bl 0x822c0938
	ctx.lr = 0x828D4DEC;
	sub_822C0938(ctx, base);
	// 828D4DEC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828D4DF0: 41820028  beq 0x828d4e18
	if ctx.cr[0].eq {
	pc = 0x828D4E18; continue 'dispatch;
	}
	// 828D4DF4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D4DF8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828D4DFC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D4E00: 392BF250  addi r9, r11, -0xdb0
	ctx.r[9].s64 = ctx.r[11].s64 + -3504;
	// 828D4E04: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828D4E08: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828D4E0C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828D4E10: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828D4E14: 48000008  b 0x828d4e1c
	pc = 0x828D4E1C; continue 'dispatch;
	// 828D4E18: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D4E1C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D4E20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D4E24: 409A0044  bne cr6, 0x828d4e68
	if !ctx.cr[6].eq {
	pc = 0x828D4E68; continue 'dispatch;
	}
	// 828D4E28: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828D4E2C: 419A001C  beq cr6, 0x828d4e48
	if ctx.cr[6].eq {
	pc = 0x828D4E48; continue 'dispatch;
	}
	// 828D4E30: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D4E34: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828D4E38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D4E3C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D4E40: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D4E44: 4E800421  bctrl
	ctx.lr = 0x828D4E48;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D4E48: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D4E4C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828D4E50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D4E54: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828D4E58: 816B61F4  lwz r11, 0x61f4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(25076 as u32) ) } as u64;
	// 828D4E5C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828D4E60: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828D4E64: 4B9EB19D  bl 0x822c0000
	ctx.lr = 0x828D4E68;
	sub_822C0000(ctx, base);
	// 828D4E68: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D4E6C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D4E70: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D4E74: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D4E78: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828D4E7C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D4E80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D4E88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D4E88 size=196
    let mut pc: u32 = 0x828D4E88;
    'dispatch: loop {
        match pc {
            0x828D4E88 => {
    //   block [0x828D4E88..0x828D4F4C)
	// 828D4E88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D4E8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D4E90: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828D4E94: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D4E98: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D4E9C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D4EA0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D4EA4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828D4EA8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828D4EAC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D4EB0: 4B9EBA89  bl 0x822c0938
	ctx.lr = 0x828D4EB4;
	sub_822C0938(ctx, base);
	// 828D4EB4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828D4EB8: 41820028  beq 0x828d4ee0
	if ctx.cr[0].eq {
	pc = 0x828D4EE0; continue 'dispatch;
	}
	// 828D4EBC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D4EC0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828D4EC4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D4EC8: 392BF264  addi r9, r11, -0xd9c
	ctx.r[9].s64 = ctx.r[11].s64 + -3484;
	// 828D4ECC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828D4ED0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828D4ED4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828D4ED8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828D4EDC: 48000008  b 0x828d4ee4
	pc = 0x828D4EE4; continue 'dispatch;
	// 828D4EE0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D4EE4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D4EE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D4EEC: 409A0044  bne cr6, 0x828d4f30
	if !ctx.cr[6].eq {
	pc = 0x828D4F30; continue 'dispatch;
	}
	// 828D4EF0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828D4EF4: 419A001C  beq cr6, 0x828d4f10
	if ctx.cr[6].eq {
	pc = 0x828D4F10; continue 'dispatch;
	}
	// 828D4EF8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D4EFC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828D4F00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D4F04: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D4F08: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D4F0C: 4E800421  bctrl
	ctx.lr = 0x828D4F10;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D4F10: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D4F14: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828D4F18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D4F1C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828D4F20: 816B61F4  lwz r11, 0x61f4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(25076 as u32) ) } as u64;
	// 828D4F24: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828D4F28: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828D4F2C: 4B9EB0D5  bl 0x822c0000
	ctx.lr = 0x828D4F30;
	sub_822C0000(ctx, base);
	// 828D4F30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D4F34: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D4F38: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D4F3C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D4F40: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828D4F44: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D4F48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D4F50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D4F50 size=196
    let mut pc: u32 = 0x828D4F50;
    'dispatch: loop {
        match pc {
            0x828D4F50 => {
    //   block [0x828D4F50..0x828D5014)
	// 828D4F50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D4F54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D4F58: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828D4F5C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D4F60: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D4F64: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D4F68: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D4F6C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828D4F70: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828D4F74: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D4F78: 4B9EB9C1  bl 0x822c0938
	ctx.lr = 0x828D4F7C;
	sub_822C0938(ctx, base);
	// 828D4F7C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828D4F80: 41820028  beq 0x828d4fa8
	if ctx.cr[0].eq {
	pc = 0x828D4FA8; continue 'dispatch;
	}
	// 828D4F84: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D4F88: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828D4F8C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D4F90: 392BF278  addi r9, r11, -0xd88
	ctx.r[9].s64 = ctx.r[11].s64 + -3464;
	// 828D4F94: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828D4F98: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828D4F9C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828D4FA0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828D4FA4: 48000008  b 0x828d4fac
	pc = 0x828D4FAC; continue 'dispatch;
	// 828D4FA8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D4FAC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D4FB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D4FB4: 409A0044  bne cr6, 0x828d4ff8
	if !ctx.cr[6].eq {
	pc = 0x828D4FF8; continue 'dispatch;
	}
	// 828D4FB8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828D4FBC: 419A001C  beq cr6, 0x828d4fd8
	if ctx.cr[6].eq {
	pc = 0x828D4FD8; continue 'dispatch;
	}
	// 828D4FC0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D4FC4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828D4FC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D4FCC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D4FD0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D4FD4: 4E800421  bctrl
	ctx.lr = 0x828D4FD8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D4FD8: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D4FDC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828D4FE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D4FE4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828D4FE8: 816B61F4  lwz r11, 0x61f4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(25076 as u32) ) } as u64;
	// 828D4FEC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828D4FF0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828D4FF4: 4B9EB00D  bl 0x822c0000
	ctx.lr = 0x828D4FF8;
	sub_822C0000(ctx, base);
	// 828D4FF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D4FFC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D5000: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D5004: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D5008: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828D500C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D5010: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D5018(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D5018 size=196
    let mut pc: u32 = 0x828D5018;
    'dispatch: loop {
        match pc {
            0x828D5018 => {
    //   block [0x828D5018..0x828D50DC)
	// 828D5018: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D501C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D5020: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828D5024: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D5028: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D502C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D5030: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D5034: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828D5038: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828D503C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D5040: 4B9EB8F9  bl 0x822c0938
	ctx.lr = 0x828D5044;
	sub_822C0938(ctx, base);
	// 828D5044: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828D5048: 41820028  beq 0x828d5070
	if ctx.cr[0].eq {
	pc = 0x828D5070; continue 'dispatch;
	}
	// 828D504C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D5050: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828D5054: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D5058: 392BF28C  addi r9, r11, -0xd74
	ctx.r[9].s64 = ctx.r[11].s64 + -3444;
	// 828D505C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828D5060: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828D5064: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828D5068: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828D506C: 48000008  b 0x828d5074
	pc = 0x828D5074; continue 'dispatch;
	// 828D5070: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D5074: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D5078: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D507C: 409A0044  bne cr6, 0x828d50c0
	if !ctx.cr[6].eq {
	pc = 0x828D50C0; continue 'dispatch;
	}
	// 828D5080: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828D5084: 419A001C  beq cr6, 0x828d50a0
	if ctx.cr[6].eq {
	pc = 0x828D50A0; continue 'dispatch;
	}
	// 828D5088: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D508C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828D5090: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D5094: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D5098: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D509C: 4E800421  bctrl
	ctx.lr = 0x828D50A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D50A0: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D50A4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828D50A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D50AC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828D50B0: 816B61F4  lwz r11, 0x61f4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(25076 as u32) ) } as u64;
	// 828D50B4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828D50B8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828D50BC: 4B9EAF45  bl 0x822c0000
	ctx.lr = 0x828D50C0;
	sub_822C0000(ctx, base);
	// 828D50C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D50C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D50C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D50CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D50D0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828D50D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D50D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D50E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D50E0 size=96
    let mut pc: u32 = 0x828D50E0;
    'dispatch: loop {
        match pc {
            0x828D50E0 => {
    //   block [0x828D50E0..0x828D5140)
	// 828D50E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D50E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D50E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D50EC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D50F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D50F4: 4BFFEE75  bl 0x828d3f68
	ctx.lr = 0x828D50F8;
	sub_828D3F68(ctx, base);
	// 828D50F8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D50FC: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828D5100: 396BF3BC  addi r11, r11, -0xc44
	ctx.r[11].s64 = ctx.r[11].s64 + -3140;
	// 828D5104: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D5108: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D510C: 808A0B08  lwz r4, 0xb08(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2824 as u32) ) } as u64;
	// 828D5110: 4851E8F9  bl 0x82df3a08
	ctx.lr = 0x828D5114;
	sub_82DF3A08(ctx, base);
	// 828D5114: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D5118: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D511C: 485845CD  bl 0x82e596e8
	ctx.lr = 0x828D5120;
	sub_82E596E8(ctx, base);
	// 828D5120: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D5124: 4851E305  bl 0x82df3428
	ctx.lr = 0x828D5128;
	sub_82DF3428(ctx, base);
	// 828D5128: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D512C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D5130: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D5134: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D5138: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D513C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D5140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828D5140 size=736
    let mut pc: u32 = 0x828D5140;
    'dispatch: loop {
        match pc {
            0x828D5140 => {
    //   block [0x828D5140..0x828D5420)
	// 828D5140: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D5144: 488D3021  bl 0x831a8164
	ctx.lr = 0x828D5148;
	sub_831A8130(ctx, base);
	// 828D5148: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 828D514C: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D5150: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D5154: 4887F4AD  bl 0x83154600
	ctx.lr = 0x828D5158;
	sub_83154600(ctx, base);
	// 828D5158: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D515C: 4BFE3B8D  bl 0x828b8ce8
	ctx.lr = 0x828D5160;
	sub_828B8CE8(ctx, base);
	// 828D5160: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D5164: 4BFF987D  bl 0x828ce9e0
	ctx.lr = 0x828D5168;
	sub_828CE9E0(ctx, base);
	// 828D5168: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D516C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828D5170: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D5174: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D5178: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D517C: 4E800421  bctrl
	ctx.lr = 0x828D5180;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D5180: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828D5184: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D5188: 4801E209  bl 0x828f3390
	ctx.lr = 0x828D518C;
	sub_828F3390(ctx, base);
	// 828D518C: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 828D5190: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 828D5194: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D5198: 480343F1  bl 0x82909588
	ctx.lr = 0x828D519C;
	sub_82909588(ctx, base);
	// 828D519C: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 828D51A0: 4806B2B1  bl 0x82940450
	ctx.lr = 0x828D51A4;
	sub_82940450(ctx, base);
	// 828D51A4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D51A8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D51AC: 4806D525  bl 0x829426d0
	ctx.lr = 0x828D51B0;
	sub_829426D0(ctx, base);
	// 828D51B0: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828D51B4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D51B8: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 828D51BC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D51C0: 4E800421  bctrl
	ctx.lr = 0x828D51C4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D51C4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D51C8: 41820098  beq 0x828d5260
	if ctx.cr[0].eq {
	pc = 0x828D5260; continue 'dispatch;
	}
	// 828D51CC: C01C0034  lfs f0, 0x34(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D51D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D51D4: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 828D51D8: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 828D51DC: 40980038  bge cr6, 0x828d5214
	if !ctx.cr[6].lt {
	pc = 0x828D5214; continue 'dispatch;
	}
	// 828D51E0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D51E4: 808B0B24  lwz r4, 0xb24(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2852 as u32) ) } as u64;
	// 828D51E8: 4851E821  bl 0x82df3a08
	ctx.lr = 0x828D51EC;
	sub_82DF3A08(ctx, base);
	// 828D51EC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D51F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D51F4: 4BF1A54D  bl 0x827ef740
	ctx.lr = 0x828D51F8;
	sub_827EF740(ctx, base);
	// 828D51F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D51FC: 4851E22D  bl 0x82df3428
	ctx.lr = 0x828D5200;
	sub_82DF3428(ctx, base);
	// 828D5200: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828D5204: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D5208: 419A020C  beq cr6, 0x828d5414
	if ctx.cr[6].eq {
	pc = 0x828D5414; continue 'dispatch;
	}
	// 828D520C: 4B9EB685  bl 0x822c0890
	ctx.lr = 0x828D5210;
	sub_822C0890(ctx, base);
	// 828D5210: 48000204  b 0x828d5414
	pc = 0x828D5414; continue 'dispatch;
	// 828D5214: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D5218: 808B0B10  lwz r4, 0xb10(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2832 as u32) ) } as u64;
	// 828D521C: 4851E7ED  bl 0x82df3a08
	ctx.lr = 0x828D5220;
	sub_82DF3A08(ctx, base);
	// 828D5220: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D5224: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D5228: 48732F01  bl 0x83008128
	ctx.lr = 0x828D522C;
	sub_83008128(ctx, base);
	// 828D522C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828D5230: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D5234: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D5238: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D523C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D5240: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828D5244: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828D5248: 48589719  bl 0x82e5e960
	ctx.lr = 0x828D524C;
	sub_82E5E960(ctx, base);
	// 828D524C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828D5250: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D5254: 419AFFAC  beq cr6, 0x828d5200
	if ctx.cr[6].eq {
	pc = 0x828D5200; continue 'dispatch;
	}
	// 828D5258: 4B9EB639  bl 0x822c0890
	ctx.lr = 0x828D525C;
	sub_822C0890(ctx, base);
	// 828D525C: 4BFFFFA4  b 0x828d5200
	pc = 0x828D5200; continue 'dispatch;
	// 828D5260: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828D5264: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D5268: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828D526C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D5270: 4E800421  bctrl
	ctx.lr = 0x828D5274;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D5274: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D5278: 40820048  bne 0x828d52c0
	if !ctx.cr[0].eq {
	pc = 0x828D52C0; continue 'dispatch;
	}
	// 828D527C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D5280: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D5284: 808B0B10  lwz r4, 0xb10(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2832 as u32) ) } as u64;
	// 828D5288: 4851E781  bl 0x82df3a08
	ctx.lr = 0x828D528C;
	sub_82DF3A08(ctx, base);
	// 828D528C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D5290: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D5294: 48732E95  bl 0x83008128
	ctx.lr = 0x828D5298;
	sub_83008128(ctx, base);
	// 828D5298: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828D529C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D52A0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828D52A4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D52A8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D52AC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828D52B0: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828D52B4: 485896AD  bl 0x82e5e960
	ctx.lr = 0x828D52B8;
	sub_82E5E960(ctx, base);
	// 828D52B8: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828D52BC: 4BFFFF94  b 0x828d5250
	pc = 0x828D5250; continue 'dispatch;
	// 828D52C0: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828D52C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D52C8: 419A0008  beq cr6, 0x828d52d0
	if ctx.cr[6].eq {
	pc = 0x828D52D0; continue 'dispatch;
	}
	// 828D52CC: 4B9EB5C5  bl 0x822c0890
	ctx.lr = 0x828D52D0;
	sub_822C0890(ctx, base);
	// 828D52D0: C01B00F4  lfs f0, 0xf4(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(244 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D52D4: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 828D52D8: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 828D52DC: 4098002C  bge cr6, 0x828d5308
	if !ctx.cr[6].lt {
	pc = 0x828D5308; continue 'dispatch;
	}
	// 828D52E0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D52E4: 808B0B24  lwz r4, 0xb24(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2852 as u32) ) } as u64;
	// 828D52E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D52EC: 4851E71D  bl 0x82df3a08
	ctx.lr = 0x828D52F0;
	sub_82DF3A08(ctx, base);
	// 828D52F0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D52F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D52F8: 4BF1A449  bl 0x827ef740
	ctx.lr = 0x828D52FC;
	sub_827EF740(ctx, base);
	// 828D52FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D5300: 4851E129  bl 0x82df3428
	ctx.lr = 0x828D5304;
	sub_82DF3428(ctx, base);
	// 828D5304: 48000110  b 0x828d5414
	pc = 0x828D5414; continue 'dispatch;
	// 828D5308: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D530C: 48584455  bl 0x82e59760
	ctx.lr = 0x828D5310;
	sub_82E59760(ctx, base);
	// 828D5310: 3F608209  lis r27, -0x7df7
	ctx.r[27].s64 = -2113339392;
	// 828D5314: C01BF1E4  lfs f0, -0xe1c(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-3612 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D5318: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 828D531C: 40990020  ble cr6, 0x828d533c
	if !ctx.cr[6].gt {
	pc = 0x828D533C; continue 'dispatch;
	}
	// 828D5320: C01C0038  lfs f0, 0x38(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D5324: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 828D5328: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 828D532C: 40990010  ble cr6, 0x828d533c
	if !ctx.cr[6].gt {
	pc = 0x828D533C; continue 'dispatch;
	}
	// 828D5330: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D5334: 808B0B10  lwz r4, 0xb10(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2832 as u32) ) } as u64;
	// 828D5338: 4BFFFFB0  b 0x828d52e8
	pc = 0x828D52E8; continue 'dispatch;
	// 828D533C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D5340: 48034241  bl 0x82909580
	ctx.lr = 0x828D5344;
	sub_82909580(ctx, base);
	// 828D5344: 48046AD5  bl 0x8291be18
	ctx.lr = 0x828D5348;
	sub_8291BE18(ctx, base);
	// 828D5348: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D534C: 41820014  beq 0x828d5360
	if ctx.cr[0].eq {
	pc = 0x828D5360; continue 'dispatch;
	}
	// 828D5350: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828D5354: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D5358: D01D0060  stfs f0, 0x60(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828D535C: 4800003C  b 0x828d5398
	pc = 0x828D5398; continue 'dispatch;
	// 828D5360: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D5364: 48584415  bl 0x82e59778
	ctx.lr = 0x828D5368;
	sub_82E59778(ctx, base);
	// 828D5368: C01D0060  lfs f0, 0x60(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D536C: EC01002A  fadds f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 828D5370: D01D0060  stfs f0, 0x60(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828D5374: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D5378: 485843E9  bl 0x82e59760
	ctx.lr = 0x828D537C;
	sub_82E59760(ctx, base);
	// 828D537C: C01BF1E4  lfs f0, -0xe1c(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-3612 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D5380: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 828D5384: 40990014  ble cr6, 0x828d5398
	if !ctx.cr[6].gt {
	pc = 0x828D5398; continue 'dispatch;
	}
	// 828D5388: C01D0060  lfs f0, 0x60(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D538C: C1BC003C  lfs f13, 0x3c(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(60 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828D5390: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 828D5394: 4199FF9C  bgt cr6, 0x828d5330
	if ctx.cr[6].gt {
	pc = 0x828D5330; continue 'dispatch;
	}
	// 828D5398: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D539C: 480341ED  bl 0x82909588
	ctx.lr = 0x828D53A0;
	sub_82909588(ctx, base);
	// 828D53A0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828D53A4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D53A8: 485843D1  bl 0x82e59778
	ctx.lr = 0x828D53AC;
	sub_82E59778(ctx, base);
	// 828D53AC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828D53B0: 4806AF69  bl 0x82940318
	ctx.lr = 0x828D53B4;
	sub_82940318(ctx, base);
	// 828D53B4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828D53B8: C1BC004C  lfs f13, 0x4c(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(76 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828D53BC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828D53C0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828D53C4: C00BCEE4  lfs f0, -0x311c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12572 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D53C8: EFED0032  fmuls f31, f13, f0
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 828D53CC: 83FE0000  lwz r31, 0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D53D0: 4806AE39  bl 0x82940208
	ctx.lr = 0x828D53D4;
	sub_82940208(ctx, base);
	// 828D53D4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D53D8: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 828D53DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D53E0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828D53E4: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 828D53E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D53EC: 4E800421  bctrl
	ctx.lr = 0x828D53F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D53F0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828D53F4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828D53F8: 83FE0000  lwz r31, 0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D53FC: 4806AE1D  bl 0x82940218
	ctx.lr = 0x828D5400;
	sub_82940218(ctx, base);
	// 828D5400: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D5404: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 828D5408: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D540C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D5410: 4E800421  bctrl
	ctx.lr = 0x828D5414;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D5414: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828D5418: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 828D541C: 488D2D98  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D5420(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828D5420 size=952
    let mut pc: u32 = 0x828D5420;
    'dispatch: loop {
        match pc {
            0x828D5420 => {
    //   block [0x828D5420..0x828D57D8)
	// 828D5420: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D5424: 488D2D41  bl 0x831a8164
	ctx.lr = 0x828D5428;
	sub_831A8130(ctx, base);
	// 828D5428: DBC1FFC0  stfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 828D542C: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 828D5430: 9421FE80  stwu r1, -0x180(r1)
	ea = ctx.r[1].u32.wrapping_add(-384 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D5434: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828D5438: 4887F1C9  bl 0x83154600
	ctx.lr = 0x828D543C;
	sub_83154600(ctx, base);
	// 828D543C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D5440: 4BFE38A9  bl 0x828b8ce8
	ctx.lr = 0x828D5444;
	sub_828B8CE8(ctx, base);
	// 828D5444: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D5448: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D544C: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D5450: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D5454: 4E800421  bctrl
	ctx.lr = 0x828D5458;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D5458: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 828D545C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828D5460: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828D5464: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 828D5468: 4BC3A0B1  bl 0x8250f518
	ctx.lr = 0x828D546C;
	sub_8250F518(ctx, base);
	// 828D546C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D5470: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D5474: 4BBBBC7D  bl 0x824910f0
	ctx.lr = 0x828D5478;
	sub_824910F0(ctx, base);
	// 828D5478: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 828D547C: 4851C815  bl 0x82df1c90
	ctx.lr = 0x828D5480;
	sub_82DF1C90(ctx, base);
	// 828D5480: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D5484: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D5488: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828D548C: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 828D5490: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D5494: 4E800421  bctrl
	ctx.lr = 0x828D5498;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D5498: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D549C: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 828D54A0: 4BF1A451  bl 0x827ef8f0
	ctx.lr = 0x828D54A4;
	sub_827EF8F0(ctx, base);
	// 828D54A4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828D54A8: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 828D54AC: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 828D54B0: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 828D54B4: 38E10110  addi r7, r1, 0x110
	ctx.r[7].s64 = ctx.r[1].s64 + 272;
	// 828D54B8: C00B614C  lfs f0, 0x614c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24908 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D54BC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D54C0: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 828D54C4: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 828D54C8: 13E05407  vcmpneb. (lvlx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D57D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828D57D8 size=556
    let mut pc: u32 = 0x828D57D8;
    'dispatch: loop {
        match pc {
            0x828D57D8 => {
    //   block [0x828D57D8..0x828D5A04)
	// 828D57D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D57DC: 488D2989  bl 0x831a8164
	ctx.lr = 0x828D57E0;
	sub_831A8130(ctx, base);
	// 828D57E0: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 828D57E4: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D57E8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D57EC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828D57F0: 4887EE11  bl 0x83154600
	ctx.lr = 0x828D57F4;
	sub_83154600(ctx, base);
	// 828D57F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D57F8: 4BFE34F1  bl 0x828b8ce8
	ctx.lr = 0x828D57FC;
	sub_828B8CE8(ctx, base);
	// 828D57FC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D5800: 4BFF91E1  bl 0x828ce9e0
	ctx.lr = 0x828D5804;
	sub_828CE9E0(ctx, base);
	// 828D5804: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 828D5808: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828D580C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828D5810: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D5814: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D5818: 816B00D0  lwz r11, 0xd0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(208 as u32) ) } as u64;
	// 828D581C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D5820: 4E800421  bctrl
	ctx.lr = 0x828D5824;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D5824: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D5828: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828D582C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D5830: 816B00D4  lwz r11, 0xd4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(212 as u32) ) } as u64;
	// 828D5834: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D5838: 4E800421  bctrl
	ctx.lr = 0x828D583C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D583C: 939D0064  stw r28, 0x64(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 828D5840: C01B0040  lfs f0, 0x40(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(64 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D5844: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D5848: D01D0060  stfs f0, 0x60(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828D584C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D5850: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828D5854: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D5858: 4E800421  bctrl
	ctx.lr = 0x828D585C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D585C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828D5860: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828D5864: FF01F800  fcmpu cr6, f1, f31
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 828D5868: 41990040  bgt cr6, 0x828d58a8
	if ctx.cr[6].gt {
	pc = 0x828D58A8; continue 'dispatch;
	}
	// 828D586C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D5870: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 828D5874: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828D5878: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D587C: 816B0188  lwz r11, 0x188(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(392 as u32) ) } as u64;
	// 828D5880: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D5884: 4E800421  bctrl
	ctx.lr = 0x828D5888;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D5888: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828D588C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D5890: 419A0008  beq cr6, 0x828d5898
	if ctx.cr[6].eq {
	pc = 0x828D5898; continue 'dispatch;
	}
	// 828D5894: 4B9EAFFD  bl 0x822c0890
	ctx.lr = 0x828D5898;
	sub_822C0890(ctx, base);
	// 828D5898: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828D589C: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 828D58A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D58A4: 4804177D  bl 0x82917020
	ctx.lr = 0x828D58A8;
	sub_82917020(ctx, base);
	// 828D58A8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D58AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D58B0: 808B0B70  lwz r4, 0xb70(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2928 as u32) ) } as u64;
	// 828D58B4: 4851E155  bl 0x82df3a08
	ctx.lr = 0x828D58B8;
	sub_82DF3A08(ctx, base);
	// 828D58B8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828D58BC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D58C0: 485840D1  bl 0x82e59990
	ctx.lr = 0x828D58C4;
	sub_82E59990(ctx, base);
	// 828D58C4: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D58C8: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 828D58CC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D58D0: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 828D58D4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D58D8: 4E800421  bctrl
	ctx.lr = 0x828D58DC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D58DC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828D58E0: 4851DA29  bl 0x82df3308
	ctx.lr = 0x828D58E4;
	sub_82DF3308(ctx, base);
	// 828D58E4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D58E8: 41820024  beq 0x828d590c
	if ctx.cr[0].eq {
	pc = 0x828D590C; continue 'dispatch;
	}
	// 828D58EC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D58F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D58F4: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828D58F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D58FC: 4E800421  bctrl
	ctx.lr = 0x828D5900;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D5900: FF01F800  fcmpu cr6, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 828D5904: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D5908: 40990008  ble cr6, 0x828d5910
	if !ctx.cr[6].gt {
	pc = 0x828D5910; continue 'dispatch;
	}
	// 828D590C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828D5910: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828D5914: 557E063E  clrlwi r30, r11, 0x18
	ctx.r[30].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828D5918: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D591C: 419A0008  beq cr6, 0x828d5924
	if ctx.cr[6].eq {
	pc = 0x828D5924; continue 'dispatch;
	}
	// 828D5920: 4B9EAF71  bl 0x822c0890
	ctx.lr = 0x828D5924;
	sub_822C0890(ctx, base);
	// 828D5924: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D5928: 4851DB01  bl 0x82df3428
	ctx.lr = 0x828D592C;
	sub_82DF3428(ctx, base);
	// 828D592C: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D5930: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D5934: 4182005C  beq 0x828d5990
	if ctx.cr[0].eq {
	pc = 0x828D5990; continue 'dispatch;
	}
	// 828D5938: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D593C: 808B0BE0  lwz r4, 0xbe0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3040 as u32) ) } as u64;
	// 828D5940: 4851E0C9  bl 0x82df3a08
	ctx.lr = 0x828D5944;
	sub_82DF3A08(ctx, base);
	// 828D5944: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D5948: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D594C: 4BF19E25  bl 0x827ef770
	ctx.lr = 0x828D5950;
	sub_827EF770(ctx, base);
	// 828D5950: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D5954: 4851DAD5  bl 0x82df3428
	ctx.lr = 0x828D5958;
	sub_82DF3428(ctx, base);
	// 828D5958: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D595C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D5960: 808BF4E4  lwz r4, -0xb1c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2844 as u32) ) } as u64;
	// 828D5964: 4851E0A5  bl 0x82df3a08
	ctx.lr = 0x828D5968;
	sub_82DF3A08(ctx, base);
	// 828D5968: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D596C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D5970: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D5974: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828D5978: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D597C: 4E800421  bctrl
	ctx.lr = 0x828D5980;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D5980: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D5984: 4851DAA5  bl 0x82df3428
	ctx.lr = 0x828D5988;
	sub_82DF3428(ctx, base);
	// 828D5988: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828D598C: 48000058  b 0x828d59e4
	pc = 0x828D59E4; continue 'dispatch;
	// 828D5990: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D5994: 808B0BD8  lwz r4, 0xbd8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3032 as u32) ) } as u64;
	// 828D5998: 4851E071  bl 0x82df3a08
	ctx.lr = 0x828D599C;
	sub_82DF3A08(ctx, base);
	// 828D599C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D59A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D59A4: 4BF19DCD  bl 0x827ef770
	ctx.lr = 0x828D59A8;
	sub_827EF770(ctx, base);
	// 828D59A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D59AC: 4851DA7D  bl 0x82df3428
	ctx.lr = 0x828D59B0;
	sub_82DF3428(ctx, base);
	// 828D59B0: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D59B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D59B8: 808B6004  lwz r4, 0x6004(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24580 as u32) ) } as u64;
	// 828D59BC: 4851E04D  bl 0x82df3a08
	ctx.lr = 0x828D59C0;
	sub_82DF3A08(ctx, base);
	// 828D59C0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D59C4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D59C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D59CC: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828D59D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D59D4: 4E800421  bctrl
	ctx.lr = 0x828D59D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D59D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D59DC: 4851DA4D  bl 0x82df3428
	ctx.lr = 0x828D59E0;
	sub_82DF3428(ctx, base);
	// 828D59E0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828D59E4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D59E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D59EC: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D59F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D59F4: 4E800421  bctrl
	ctx.lr = 0x828D59F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D59F8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828D59FC: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 828D5A00: 488D27B4  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D5A08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828D5A08 size=384
    let mut pc: u32 = 0x828D5A08;
    'dispatch: loop {
        match pc {
            0x828D5A08 => {
    //   block [0x828D5A08..0x828D5B88)
	// 828D5A08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D5A0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D5A10: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828D5A14: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D5A18: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 828D5A1C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D5A20: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D5A24: 4887EBDD  bl 0x83154600
	ctx.lr = 0x828D5A28;
	sub_83154600(ctx, base);
	// 828D5A28: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D5A2C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D5A30: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828D5A34: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D5A38: 4E800421  bctrl
	ctx.lr = 0x828D5A3C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D5A3C: 817F0064  lwz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 828D5A40: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 828D5A44: 419800B0  blt cr6, 0x828d5af4
	if ctx.cr[6].lt {
	pc = 0x828D5AF4; continue 'dispatch;
	}
	// 828D5A48: 419A0050  beq cr6, 0x828d5a98
	if ctx.cr[6].eq {
	pc = 0x828D5A98; continue 'dispatch;
	}
	// 828D5A4C: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 828D5A50: 4098011C  bge cr6, 0x828d5b6c
	if !ctx.cr[6].lt {
	pc = 0x828D5B6C; continue 'dispatch;
	}
	// 828D5A54: 4BF148BD  bl 0x827ea310
	ctx.lr = 0x828D5A58;
	sub_827EA310(ctx, base);
	// 828D5A58: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D5A5C: 41820110  beq 0x828d5b6c
	if ctx.cr[0].eq {
	pc = 0x828D5B6C; continue 'dispatch;
	}
	// 828D5A60: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D5A64: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D5A68: 808B0B24  lwz r4, 0xb24(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2852 as u32) ) } as u64;
	// 828D5A6C: 4851DF9D  bl 0x82df3a08
	ctx.lr = 0x828D5A70;
	sub_82DF3A08(ctx, base);
	// 828D5A70: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828D5A74: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828D5A78: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D5A7C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D5A80: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D5A84: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828D5A88: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828D5A8C: 48589005  bl 0x82e5ea90
	ctx.lr = 0x828D5A90;
	sub_82E5EA90(ctx, base);
	// 828D5A90: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828D5A94: 480000C0  b 0x828d5b54
	pc = 0x828D5B54; continue 'dispatch;
	// 828D5A98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D5A9C: 48583CDD  bl 0x82e59778
	ctx.lr = 0x828D5AA0;
	sub_82E59778(ctx, base);
	// 828D5AA0: C01F0060  lfs f0, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D5AA4: EDA00828  fsubs f13, f0, f1
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 828D5AA8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828D5AAC: D1BF0060  stfs f13, 0x60(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828D5AB0: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D5AB4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 828D5AB8: 409800B4  bge cr6, 0x828d5b6c
	if !ctx.cr[6].lt {
	pc = 0x828D5B6C; continue 'dispatch;
	}
	// 828D5ABC: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D5AC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D5AC4: 808BF460  lwz r4, -0xba0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2976 as u32) ) } as u64;
	// 828D5AC8: 4851DF41  bl 0x82df3a08
	ctx.lr = 0x828D5ACC;
	sub_82DF3A08(ctx, base);
	// 828D5ACC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D5AD0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D5AD4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D5AD8: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828D5ADC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D5AE0: 4E800421  bctrl
	ctx.lr = 0x828D5AE4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D5AE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D5AE8: 4851D941  bl 0x82df3428
	ctx.lr = 0x828D5AEC;
	sub_82DF3428(ctx, base);
	// 828D5AEC: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 828D5AF0: 48000078  b 0x828d5b68
	pc = 0x828D5B68; continue 'dispatch;
	// 828D5AF4: 4BF1481D  bl 0x827ea310
	ctx.lr = 0x828D5AF8;
	sub_827EA310(ctx, base);
	// 828D5AF8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D5AFC: 41820070  beq 0x828d5b6c
	if ctx.cr[0].eq {
	pc = 0x828D5B6C; continue 'dispatch;
	}
	// 828D5B00: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D5B04: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D5B08: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828D5B0C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D5B10: 4E800421  bctrl
	ctx.lr = 0x828D5B14;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D5B14: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828D5B18: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828D5B1C: FF01F800  fcmpu cr6, f1, f31
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 828D5B20: 41990044  bgt cr6, 0x828d5b64
	if ctx.cr[6].gt {
	pc = 0x828D5B64; continue 'dispatch;
	}
	// 828D5B24: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D5B28: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D5B2C: 808B0B2C  lwz r4, 0xb2c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2860 as u32) ) } as u64;
	// 828D5B30: 4851DED9  bl 0x82df3a08
	ctx.lr = 0x828D5B34;
	sub_82DF3A08(ctx, base);
	// 828D5B34: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828D5B38: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828D5B3C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D5B40: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828D5B44: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D5B48: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828D5B4C: 48588F45  bl 0x82e5ea90
	ctx.lr = 0x828D5B50;
	sub_82E5EA90(ctx, base);
	// 828D5B50: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828D5B54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D5B58: 419A0014  beq cr6, 0x828d5b6c
	if ctx.cr[6].eq {
	pc = 0x828D5B6C; continue 'dispatch;
	}
	// 828D5B5C: 4B9EAD35  bl 0x822c0890
	ctx.lr = 0x828D5B60;
	sub_822C0890(ctx, base);
	// 828D5B60: 4800000C  b 0x828d5b6c
	pc = 0x828D5B6C; continue 'dispatch;
	// 828D5B64: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D5B68: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828D5B6C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828D5B70: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D5B74: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D5B78: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 828D5B7C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828D5B80: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D5B84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D5B88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828D5B88 size=944
    let mut pc: u32 = 0x828D5B88;
    'dispatch: loop {
        match pc {
            0x828D5B88 => {
    //   block [0x828D5B88..0x828D5F38)
	// 828D5B88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D5B8C: 488D25DD  bl 0x831a8168
	ctx.lr = 0x828D5B90;
	sub_831A8130(ctx, base);
	// 828D5B90: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 828D5B94: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D5F38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D5F38 size=112
    let mut pc: u32 = 0x828D5F38;
    'dispatch: loop {
        match pc {
            0x828D5F38 => {
    //   block [0x828D5F38..0x828D5FA8)
	// 828D5F38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D5F3C: 488D2231  bl 0x831a816c
	ctx.lr = 0x828D5F40;
	sub_831A8130(ctx, base);
	// 828D5F40: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D5F44: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D5F48: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D5F4C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D5F50: 388BF3E0  addi r4, r11, -0xc20
	ctx.r[4].s64 = ctx.r[11].s64 + -3104;
	// 828D5F54: 38A00096  li r5, 0x96
	ctx.r[5].s64 = 150;
	// 828D5F58: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 828D5F5C: 4851C48D  bl 0x82df23e8
	ctx.lr = 0x828D5F60;
	sub_82DF23E8(ctx, base);
	// 828D5F60: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828D5F64: 41820010  beq 0x828d5f74
	if ctx.cr[0].eq {
	pc = 0x828D5F74; continue 'dispatch;
	}
	// 828D5F68: 4BFFF179  bl 0x828d50e0
	ctx.lr = 0x828D5F6C;
	sub_828D50E0(ctx, base);
	// 828D5F6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D5F70: 48000008  b 0x828d5f78
	pc = 0x828D5F78; continue 'dispatch;
	// 828D5F74: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828D5F78: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828D5F7C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828D5F80: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D5F84: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D5F88: 4BFFEA51  bl 0x828d49d8
	ctx.lr = 0x828D5F8C;
	sub_828D49D8(ctx, base);
	// 828D5F8C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D5F90: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D5F94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D5F98: 4B9EA069  bl 0x822c0000
	ctx.lr = 0x828D5F9C;
	sub_822C0000(ctx, base);
	// 828D5F9C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D5FA0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D5FA4: 488D2218  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D5FA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828D5FA8 size=596
    let mut pc: u32 = 0x828D5FA8;
    'dispatch: loop {
        match pc {
            0x828D5FA8 => {
    //   block [0x828D5FA8..0x828D61FC)
	// 828D5FA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D5FAC: 488D21A5  bl 0x831a8150
	ctx.lr = 0x828D5FB0;
	sub_831A8130(ctx, base);
	// 828D5FB0: DBE1FFA0  stfd f31, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[31].u64 ) };
	// 828D5FB4: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D5FB8: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 828D5FBC: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 828D5FC0: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 828D5FC4: 4887E63D  bl 0x83154600
	ctx.lr = 0x828D5FC8;
	sub_83154600(ctx, base);
	// 828D5FC8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828D5FCC: 4BFE2D1D  bl 0x828b8ce8
	ctx.lr = 0x828D5FD0;
	sub_828B8CE8(ctx, base);
	// 828D5FD0: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D5FD4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D5FD8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D5FDC: 808B6030  lwz r4, 0x6030(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24624 as u32) ) } as u64;
	// 828D5FE0: 4851DA29  bl 0x82df3a08
	ctx.lr = 0x828D5FE4;
	sub_82DF3A08(ctx, base);
	// 828D5FE4: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D5FE8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D5FEC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828D5FF0: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828D5FF4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D5FF8: 4E800421  bctrl
	ctx.lr = 0x828D5FFC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D5FFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D6000: 4851D429  bl 0x82df3428
	ctx.lr = 0x828D6004;
	sub_82DF3428(ctx, base);
	// 828D6004: 3AFF0010  addi r23, r31, 0x10
	ctx.r[23].s64 = ctx.r[31].s64 + 16;
	// 828D6008: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 828D600C: 4803357D  bl 0x82909588
	ctx.lr = 0x828D6010;
	sub_82909588(ctx, base);
	// 828D6010: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D6014: 4806A495  bl 0x829404a8
	ctx.lr = 0x828D6018;
	sub_829404A8(ctx, base);
	// 828D6018: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D601C: 4806BFCD  bl 0x82941fe8
	ctx.lr = 0x828D6020;
	sub_82941FE8(ctx, base);
	// 828D6020: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828D6024: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D6028: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D602C: 3BABF3E0  addi r29, r11, -0xc20
	ctx.r[29].s64 = ctx.r[11].s64 + -3104;
	// 828D6030: 38A000BE  li r5, 0xbe
	ctx.r[5].s64 = 190;
	// 828D6034: C00A08A8  lfs f0, 0x8a8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D6038: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828D603C: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 828D6040: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 828D6044: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 828D6048: 4B9EA391  bl 0x822c03d8
	ctx.lr = 0x828D604C;
	sub_822C03D8(ctx, base);
	// 828D604C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828D6050: 41820018  beq 0x828d6068
	if ctx.cr[0].eq {
	pc = 0x828D6068; continue 'dispatch;
	}
	// 828D6054: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828D6058: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D605C: 4806BFAD  bl 0x82942008
	ctx.lr = 0x828D6060;
	sub_82942008(ctx, base);
	// 828D6060: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D6064: 48000008  b 0x828d606c
	pc = 0x828D606C; continue 'dispatch;
	// 828D6068: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828D606C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828D6070: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828D6074: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D6078: 4BF97DB9  bl 0x8286de30
	ctx.lr = 0x828D607C;
	sub_8286DE30(ctx, base);
	// 828D607C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828D6080: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828D6084: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D6088: 4B9E9F79  bl 0x822c0000
	ctx.lr = 0x828D608C;
	sub_822C0000(ctx, base);
	// 828D608C: 82C10054  lwz r22, 0x54(r1)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828D6090: 83210050  lwz r25, 0x50(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828D6094: 2B160000  cmplwi cr6, r22, 0
	ctx.cr[6].compare_u32(ctx.r[22].u32, 0 as u32, &mut ctx.xer);
	// 828D6098: 92C10054  stw r22, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[22].u32 ) };
	// 828D609C: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 828D60A0: 419A0024  beq cr6, 0x828d60c4
	if ctx.cr[6].eq {
	pc = 0x828D60C4; continue 'dispatch;
	}
	// 828D60A4: 39760004  addi r11, r22, 4
	ctx.r[11].s64 = ctx.r[22].s64 + 4;
	// 828D60A8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828D60AC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D60B0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828D60B4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828D60B8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D60BC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D60C0: 4082FFE8  bne 0x828d60a8
	if !ctx.cr[0].eq {
	pc = 0x828D60A8; continue 'dispatch;
	}
	// 828D60C4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D60C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D60CC: 4806A3E5  bl 0x829404b0
	ctx.lr = 0x828D60D0;
	sub_829404B0(ctx, base);
	// 828D60D0: 4BFF8911  bl 0x828ce9e0
	ctx.lr = 0x828D60D4;
	sub_828CE9E0(ctx, base);
	// 828D60D4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828D60D8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828D60DC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D60E0: 38A000C3  li r5, 0xc3
	ctx.r[5].s64 = 195;
	// 828D60E4: 3860002C  li r3, 0x2c
	ctx.r[3].s64 = 44;
	// 828D60E8: 4B9EA2F1  bl 0x822c03d8
	ctx.lr = 0x828D60EC;
	sub_822C03D8(ctx, base);
	// 828D60EC: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828D60F0: 41820030  beq 0x828d6120
	if ctx.cr[0].eq {
	pc = 0x828D6120; continue 'dispatch;
	}
	// 828D60F4: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 828D60F8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D60FC: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 828D6100: 4806C5D1  bl 0x829426d0
	ctx.lr = 0x828D6104;
	sub_829426D0(ctx, base);
	// 828D6104: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828D6108: 38BB008C  addi r5, r27, 0x8c
	ctx.r[5].s64 = ctx.r[27].s64 + 140;
	// 828D610C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D6110: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D6114: 4806ACAD  bl 0x82940dc0
	ctx.lr = 0x828D6118;
	sub_82940DC0(ctx, base);
	// 828D6118: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D611C: 48000008  b 0x828d6124
	pc = 0x828D6124; continue 'dispatch;
	// 828D6120: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828D6124: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828D6128: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828D612C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D6130: 4BFF62B9  bl 0x828cc3e8
	ctx.lr = 0x828D6134;
	sub_828CC3E8(ctx, base);
	// 828D6134: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828D6138: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828D613C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D6140: 4B9E9EC1  bl 0x822c0000
	ctx.lr = 0x828D6144;
	sub_822C0000(ctx, base);
	// 828D6144: 574B07FF  clrlwi. r11, r26, 0x1f
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D6148: 41820014  beq 0x828d615c
	if ctx.cr[0].eq {
	pc = 0x828D615C; continue 'dispatch;
	}
	// 828D614C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828D6150: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D6154: 419A0008  beq cr6, 0x828d615c
	if ctx.cr[6].eq {
	pc = 0x828D615C; continue 'dispatch;
	}
	// 828D6158: 4B9EA739  bl 0x822c0890
	ctx.lr = 0x828D615C;
	sub_822C0890(ctx, base);
	// 828D615C: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828D6160: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828D6164: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828D6168: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 828D616C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828D6170: 419A0024  beq cr6, 0x828d6194
	if ctx.cr[6].eq {
	pc = 0x828D6194; continue 'dispatch;
	}
	// 828D6174: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 828D6178: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828D617C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D6180: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828D6184: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828D6188: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D618C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D6190: 4082FFE8  bne 0x828d6178
	if !ctx.cr[0].eq {
	pc = 0x828D6178; continue 'dispatch;
	}
	// 828D6194: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D6198: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D619C: 4806A315  bl 0x829404b0
	ctx.lr = 0x828D61A0;
	sub_829404B0(ctx, base);
	// 828D61A0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828D61A4: 419A000C  beq cr6, 0x828d61b0
	if ctx.cr[6].eq {
	pc = 0x828D61B0; continue 'dispatch;
	}
	// 828D61A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D61AC: 4B9EA6E5  bl 0x822c0890
	ctx.lr = 0x828D61B0;
	sub_822C0890(ctx, base);
	// 828D61B0: 2B160000  cmplwi cr6, r22, 0
	ctx.cr[6].compare_u32(ctx.r[22].u32, 0 as u32, &mut ctx.xer);
	// 828D61B4: 419A000C  beq cr6, 0x828d61c0
	if ctx.cr[6].eq {
	pc = 0x828D61C0; continue 'dispatch;
	}
	// 828D61B8: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 828D61BC: 4B9EA6D5  bl 0x822c0890
	ctx.lr = 0x828D61C0;
	sub_822C0890(ctx, base);
	// 828D61C0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828D61C4: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D61C8: D0180060  stfs f0, 0x60(r24)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828D61CC: 4BFF8815  bl 0x828ce9e0
	ctx.lr = 0x828D61D0;
	sub_828CE9E0(ctx, base);
	// 828D61D0: C3E30038  lfs f31, 0x38(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828D61D4: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 828D61D8: 480333A9  bl 0x82909580
	ctx.lr = 0x828D61DC;
	sub_82909580(ctx, base);
	// 828D61DC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828D61E0: 48045671  bl 0x8291b850
	ctx.lr = 0x828D61E4;
	sub_8291B850(ctx, base);
	// 828D61E4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828D61E8: 48040919  bl 0x82916b00
	ctx.lr = 0x828D61EC;
	sub_82916B00(ctx, base);
	// 828D61EC: 98780064  stb r3, 0x64(r24)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[24].u32.wrapping_add(100 as u32), ctx.r[3].u8 ) };
	// 828D61F0: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 828D61F4: CBE1FFA0  lfd f31, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 828D61F8: 488D1FA8  b 0x831a81a0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D6200(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D6200 size=112
    let mut pc: u32 = 0x828D6200;
    'dispatch: loop {
        match pc {
            0x828D6200 => {
    //   block [0x828D6200..0x828D6270)
	// 828D6200: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D6204: 488D1F69  bl 0x831a816c
	ctx.lr = 0x828D6208;
	sub_831A8130(ctx, base);
	// 828D6208: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D620C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D6210: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D6214: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D6218: 388BF3E0  addi r4, r11, -0xc20
	ctx.r[4].s64 = ctx.r[11].s64 + -3104;
	// 828D621C: 38A00147  li r5, 0x147
	ctx.r[5].s64 = 327;
	// 828D6220: 38600068  li r3, 0x68
	ctx.r[3].s64 = 104;
	// 828D6224: 4851C1C5  bl 0x82df23e8
	ctx.lr = 0x828D6228;
	sub_82DF23E8(ctx, base);
	// 828D6228: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828D622C: 41820010  beq 0x828d623c
	if ctx.cr[0].eq {
	pc = 0x828D623C; continue 'dispatch;
	}
	// 828D6230: 4BFFDEA1  bl 0x828d40d0
	ctx.lr = 0x828D6234;
	sub_828D40D0(ctx, base);
	// 828D6234: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D6238: 48000008  b 0x828d6240
	pc = 0x828D6240; continue 'dispatch;
	// 828D623C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828D6240: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828D6244: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828D6248: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D624C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D6250: 4BFFE851  bl 0x828d4aa0
	ctx.lr = 0x828D6254;
	sub_828D4AA0(ctx, base);
	// 828D6254: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D6258: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D625C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D6260: 4B9E9DA1  bl 0x822c0000
	ctx.lr = 0x828D6264;
	sub_822C0000(ctx, base);
	// 828D6264: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D6268: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D626C: 488D1F50  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D6270(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D6270 size=112
    let mut pc: u32 = 0x828D6270;
    'dispatch: loop {
        match pc {
            0x828D6270 => {
    //   block [0x828D6270..0x828D62E0)
	// 828D6270: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D6274: 488D1EF9  bl 0x831a816c
	ctx.lr = 0x828D6278;
	sub_831A8130(ctx, base);
	// 828D6278: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D627C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D6280: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D6284: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D6288: 388BF3E0  addi r4, r11, -0xc20
	ctx.r[4].s64 = ctx.r[11].s64 + -3104;
	// 828D628C: 38A0019B  li r5, 0x19b
	ctx.r[5].s64 = 411;
	// 828D6290: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 828D6294: 4851C155  bl 0x82df23e8
	ctx.lr = 0x828D6298;
	sub_82DF23E8(ctx, base);
	// 828D6298: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828D629C: 41820010  beq 0x828d62ac
	if ctx.cr[0].eq {
	pc = 0x828D62AC; continue 'dispatch;
	}
	// 828D62A0: 4BFFDF11  bl 0x828d41b0
	ctx.lr = 0x828D62A4;
	sub_828D41B0(ctx, base);
	// 828D62A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D62A8: 48000008  b 0x828d62b0
	pc = 0x828D62B0; continue 'dispatch;
	// 828D62AC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828D62B0: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828D62B4: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828D62B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D62BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D62C0: 4BFFE8A9  bl 0x828d4b68
	ctx.lr = 0x828D62C4;
	sub_828D4B68(ctx, base);
	// 828D62C4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D62C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D62CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D62D0: 4B9E9D31  bl 0x822c0000
	ctx.lr = 0x828D62D4;
	sub_822C0000(ctx, base);
	// 828D62D4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D62D8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D62DC: 488D1EE0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D62E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828D62E0 size=384
    let mut pc: u32 = 0x828D62E0;
    'dispatch: loop {
        match pc {
            0x828D62E0 => {
    //   block [0x828D62E0..0x828D6460)
	// 828D62E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D62E4: 488D1E89  bl 0x831a816c
	ctx.lr = 0x828D62E8;
	sub_831A8130(ctx, base);
	// 828D62E8: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D6460(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D6460 size=112
    let mut pc: u32 = 0x828D6460;
    'dispatch: loop {
        match pc {
            0x828D6460 => {
    //   block [0x828D6460..0x828D64D0)
	// 828D6460: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D6464: 488D1D09  bl 0x831a816c
	ctx.lr = 0x828D6468;
	sub_831A8130(ctx, base);
	// 828D6468: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D646C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D6470: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D6474: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D6478: 388BF3E0  addi r4, r11, -0xc20
	ctx.r[4].s64 = ctx.r[11].s64 + -3104;
	// 828D647C: 38A001E2  li r5, 0x1e2
	ctx.r[5].s64 = 482;
	// 828D6480: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 828D6484: 4851BF65  bl 0x82df23e8
	ctx.lr = 0x828D6488;
	sub_82DF23E8(ctx, base);
	// 828D6488: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828D648C: 41820010  beq 0x828d649c
	if ctx.cr[0].eq {
	pc = 0x828D649C; continue 'dispatch;
	}
	// 828D6490: 4BFFDF79  bl 0x828d4408
	ctx.lr = 0x828D6494;
	sub_828D4408(ctx, base);
	// 828D6494: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D6498: 48000008  b 0x828d64a0
	pc = 0x828D64A0; continue 'dispatch;
	// 828D649C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828D64A0: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828D64A4: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828D64A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D64AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D64B0: 4BFFE781  bl 0x828d4c30
	ctx.lr = 0x828D64B4;
	sub_828D4C30(ctx, base);
	// 828D64B4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D64B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D64BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D64C0: 4B9E9B41  bl 0x822c0000
	ctx.lr = 0x828D64C4;
	sub_822C0000(ctx, base);
	// 828D64C4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D64C8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D64CC: 488D1CF0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D64D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D64D0 size=112
    let mut pc: u32 = 0x828D64D0;
    'dispatch: loop {
        match pc {
            0x828D64D0 => {
    //   block [0x828D64D0..0x828D6540)
	// 828D64D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D64D4: 488D1C99  bl 0x831a816c
	ctx.lr = 0x828D64D8;
	sub_831A8130(ctx, base);
	// 828D64D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D64DC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D64E0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D64E4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D64E8: 388BF3E0  addi r4, r11, -0xc20
	ctx.r[4].s64 = ctx.r[11].s64 + -3104;
	// 828D64EC: 38A0029D  li r5, 0x29d
	ctx.r[5].s64 = 669;
	// 828D64F0: 38600068  li r3, 0x68
	ctx.r[3].s64 = 104;
	// 828D64F4: 4851BEF5  bl 0x82df23e8
	ctx.lr = 0x828D64F8;
	sub_82DF23E8(ctx, base);
	// 828D64F8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828D64FC: 41820010  beq 0x828d650c
	if ctx.cr[0].eq {
	pc = 0x828D650C; continue 'dispatch;
	}
	// 828D6500: 4BFFE071  bl 0x828d4570
	ctx.lr = 0x828D6504;
	sub_828D4570(ctx, base);
	// 828D6504: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D6508: 48000008  b 0x828d6510
	pc = 0x828D6510; continue 'dispatch;
	// 828D650C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828D6510: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828D6514: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828D6518: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D651C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D6520: 4BFFE7D9  bl 0x828d4cf8
	ctx.lr = 0x828D6524;
	sub_828D4CF8(ctx, base);
	// 828D6524: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D6528: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D652C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D6530: 4B9E9AD1  bl 0x822c0000
	ctx.lr = 0x828D6534;
	sub_822C0000(ctx, base);
	// 828D6534: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D6538: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D653C: 488D1C80  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D6540(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D6540 size=112
    let mut pc: u32 = 0x828D6540;
    'dispatch: loop {
        match pc {
            0x828D6540 => {
    //   block [0x828D6540..0x828D65B0)
	// 828D6540: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D6544: 488D1C29  bl 0x831a816c
	ctx.lr = 0x828D6548;
	sub_831A8130(ctx, base);
	// 828D6548: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D654C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D6550: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D6554: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D6558: 388BF3E0  addi r4, r11, -0xc20
	ctx.r[4].s64 = ctx.r[11].s64 + -3104;
	// 828D655C: 38A0031D  li r5, 0x31d
	ctx.r[5].s64 = 797;
	// 828D6560: 38600068  li r3, 0x68
	ctx.r[3].s64 = 104;
	// 828D6564: 4851BE85  bl 0x82df23e8
	ctx.lr = 0x828D6568;
	sub_82DF23E8(ctx, base);
	// 828D6568: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828D656C: 41820010  beq 0x828d657c
	if ctx.cr[0].eq {
	pc = 0x828D657C; continue 'dispatch;
	}
	// 828D6570: 4BFFE109  bl 0x828d4678
	ctx.lr = 0x828D6574;
	sub_828D4678(ctx, base);
	// 828D6574: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D6578: 48000008  b 0x828d6580
	pc = 0x828D6580; continue 'dispatch;
	// 828D657C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828D6580: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828D6584: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828D6588: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D658C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D6590: 4BFFE831  bl 0x828d4dc0
	ctx.lr = 0x828D6594;
	sub_828D4DC0(ctx, base);
	// 828D6594: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D6598: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D659C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D65A0: 4B9E9A61  bl 0x822c0000
	ctx.lr = 0x828D65A4;
	sub_822C0000(ctx, base);
	// 828D65A4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D65A8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D65AC: 488D1C10  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D65B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D65B0 size=112
    let mut pc: u32 = 0x828D65B0;
    'dispatch: loop {
        match pc {
            0x828D65B0 => {
    //   block [0x828D65B0..0x828D6620)
	// 828D65B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D65B4: 488D1BB9  bl 0x831a816c
	ctx.lr = 0x828D65B8;
	sub_831A8130(ctx, base);
	// 828D65B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D65BC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D65C0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D65C4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D65C8: 388BF3E0  addi r4, r11, -0xc20
	ctx.r[4].s64 = ctx.r[11].s64 + -3104;
	// 828D65CC: 38A0038A  li r5, 0x38a
	ctx.r[5].s64 = 906;
	// 828D65D0: 38600090  li r3, 0x90
	ctx.r[3].s64 = 144;
	// 828D65D4: 4851BE15  bl 0x82df23e8
	ctx.lr = 0x828D65D8;
	sub_82DF23E8(ctx, base);
	// 828D65D8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828D65DC: 41820010  beq 0x828d65ec
	if ctx.cr[0].eq {
	pc = 0x828D65EC; continue 'dispatch;
	}
	// 828D65E0: 4BFFE101  bl 0x828d46e0
	ctx.lr = 0x828D65E4;
	sub_828D46E0(ctx, base);
	// 828D65E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D65E8: 48000008  b 0x828d65f0
	pc = 0x828D65F0; continue 'dispatch;
	// 828D65EC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828D65F0: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828D65F4: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828D65F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D65FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D6600: 4BFFE889  bl 0x828d4e88
	ctx.lr = 0x828D6604;
	sub_828D4E88(ctx, base);
	// 828D6604: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D6608: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D660C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D6610: 4B9E99F1  bl 0x822c0000
	ctx.lr = 0x828D6614;
	sub_822C0000(ctx, base);
	// 828D6614: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D6618: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D661C: 488D1BA0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D6620(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D6620 size=124
    let mut pc: u32 = 0x828D6620;
    'dispatch: loop {
        match pc {
            0x828D6620 => {
    //   block [0x828D6620..0x828D669C)
	// 828D6620: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D6624: 488D1B49  bl 0x831a816c
	ctx.lr = 0x828D6628;
	sub_831A8130(ctx, base);
	// 828D6628: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D662C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D6630: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D6634: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D6638: 388BF3E0  addi r4, r11, -0xc20
	ctx.r[4].s64 = ctx.r[11].s64 + -3104;
	// 828D663C: 38A003B2  li r5, 0x3b2
	ctx.r[5].s64 = 946;
	// 828D6640: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 828D6644: 4851BDA5  bl 0x82df23e8
	ctx.lr = 0x828D6648;
	sub_82DF23E8(ctx, base);
	// 828D6648: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 828D664C: 4182001C  beq 0x828d6668
	if ctx.cr[0].eq {
	pc = 0x828D6668; continue 'dispatch;
	}
	// 828D6650: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D6654: 4805221D  bl 0x82928870
	ctx.lr = 0x828D6658;
	sub_82928870(ctx, base);
	// 828D6658: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D665C: 396BF470  addi r11, r11, -0xb90
	ctx.r[11].s64 = ctx.r[11].s64 + -2960;
	// 828D6660: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D6664: 48000008  b 0x828d666c
	pc = 0x828D666C; continue 'dispatch;
	// 828D6668: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828D666C: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828D6670: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828D6674: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D6678: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D667C: 4BFFE8D5  bl 0x828d4f50
	ctx.lr = 0x828D6680;
	sub_828D4F50(ctx, base);
	// 828D6680: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D6684: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D6688: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D668C: 4B9E9975  bl 0x822c0000
	ctx.lr = 0x828D6690;
	sub_822C0000(ctx, base);
	// 828D6690: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D6694: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D6698: 488D1B24  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D66A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D66A0 size=112
    let mut pc: u32 = 0x828D66A0;
    'dispatch: loop {
        match pc {
            0x828D66A0 => {
    //   block [0x828D66A0..0x828D6710)
	// 828D66A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D66A4: 488D1AC9  bl 0x831a816c
	ctx.lr = 0x828D66A8;
	sub_831A8130(ctx, base);
	// 828D66A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D66AC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D66B0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D66B4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D66B8: 388BF3E0  addi r4, r11, -0xc20
	ctx.r[4].s64 = ctx.r[11].s64 + -3104;
	// 828D66BC: 38A00412  li r5, 0x412
	ctx.r[5].s64 = 1042;
	// 828D66C0: 38600068  li r3, 0x68
	ctx.r[3].s64 = 104;
	// 828D66C4: 4851BD25  bl 0x82df23e8
	ctx.lr = 0x828D66C8;
	sub_82DF23E8(ctx, base);
	// 828D66C8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828D66CC: 41820010  beq 0x828d66dc
	if ctx.cr[0].eq {
	pc = 0x828D66DC; continue 'dispatch;
	}
	// 828D66D0: 4BFFE1F9  bl 0x828d48c8
	ctx.lr = 0x828D66D4;
	sub_828D48C8(ctx, base);
	// 828D66D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D66D8: 48000008  b 0x828d66e0
	pc = 0x828D66E0; continue 'dispatch;
	// 828D66DC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828D66E0: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828D66E4: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828D66E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D66EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D66F0: 4BFFE929  bl 0x828d5018
	ctx.lr = 0x828D66F4;
	sub_828D5018(ctx, base);
	// 828D66F4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D66F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D66FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D6700: 4B9E9901  bl 0x822c0000
	ctx.lr = 0x828D6704;
	sub_822C0000(ctx, base);
	// 828D6704: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D6708: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D670C: 488D1AB0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D6710(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828D6710 size=192
    let mut pc: u32 = 0x828D6710;
    'dispatch: loop {
        match pc {
            0x828D6710 => {
    //   block [0x828D6710..0x828D67D0)
	// 828D6710: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D6714: 488D1A59  bl 0x831a816c
	ctx.lr = 0x828D6718;
	sub_831A8130(ctx, base);
	// 828D6718: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D671C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D6720: 4887DEE1  bl 0x83154600
	ctx.lr = 0x828D6724;
	sub_83154600(ctx, base);
	// 828D6724: 48040045  bl 0x82916768
	ctx.lr = 0x828D6728;
	sub_82916768(ctx, base);
	// 828D6728: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828D672C: 3BE3FFF0  addi r31, r3, -0x10
	ctx.r[31].s64 = ctx.r[3].s64 + -16;
	// 828D6730: 40820008  bne 0x828d6738
	if !ctx.cr[0].eq {
	pc = 0x828D6738; continue 'dispatch;
	}
	// 828D6734: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828D6738: 3BDF0010  addi r30, r31, 0x10
	ctx.r[30].s64 = ctx.r[31].s64 + 16;
	// 828D673C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D6740: 48032711  bl 0x82908e50
	ctx.lr = 0x828D6744;
	sub_82908E50(ctx, base);
	// 828D6744: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828D6748: 4182006C  beq 0x828d67b4
	if ctx.cr[0].eq {
	pc = 0x828D67B4; continue 'dispatch;
	}
	// 828D674C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D6750: 4BF8FD31  bl 0x82866480
	ctx.lr = 0x828D6754;
	sub_82866480(ctx, base);
	// 828D6754: 2B030002  cmplwi cr6, r3, 2
	ctx.cr[6].compare_u32(ctx.r[3].u32, 2 as u32, &mut ctx.xer);
	// 828D6758: 409A005C  bne cr6, 0x828d67b4
	if !ctx.cr[6].eq {
	pc = 0x828D67B4; continue 'dispatch;
	}
	// 828D675C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D6760: 4BF8FD19  bl 0x82866478
	ctx.lr = 0x828D6764;
	sub_82866478(ctx, base);
	// 828D6764: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D6768: 556BFFFF  rlwinm. r11, r11, 0x1f, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D676C: 40820048  bne 0x828d67b4
	if !ctx.cr[0].eq {
	pc = 0x828D67B4; continue 'dispatch;
	}
	// 828D6770: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D6774: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D6778: 808B605C  lwz r4, 0x605c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24668 as u32) ) } as u64;
	// 828D677C: 4851D28D  bl 0x82df3a08
	ctx.lr = 0x828D6780;
	sub_82DF3A08(ctx, base);
	// 828D6780: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828D6784: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828D6788: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828D678C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D6790: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D6794: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828D6798: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828D679C: 485882F5  bl 0x82e5ea90
	ctx.lr = 0x828D67A0;
	sub_82E5EA90(ctx, base);
	// 828D67A0: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828D67A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D67A8: 419A0020  beq cr6, 0x828d67c8
	if ctx.cr[6].eq {
	pc = 0x828D67C8; continue 'dispatch;
	}
	// 828D67AC: 4B9EA0E5  bl 0x822c0890
	ctx.lr = 0x828D67B0;
	sub_822C0890(ctx, base);
	// 828D67B0: 48000018  b 0x828d67c8
	pc = 0x828D67C8; continue 'dispatch;
	// 828D67B4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D67B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D67BC: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 828D67C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D67C4: 4E800421  bctrl
	ctx.lr = 0x828D67C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D67C8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828D67CC: 488D19F0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D67D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828D67D0 size=244
    let mut pc: u32 = 0x828D67D0;
    'dispatch: loop {
        match pc {
            0x828D67D0 => {
    //   block [0x828D67D0..0x828D68C4)
	// 828D67D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D67D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D67D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828D67DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D67E0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D67E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D67E8: 4887DE19  bl 0x83154600
	ctx.lr = 0x828D67EC;
	sub_83154600(ctx, base);
	// 828D67EC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D67F0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D67F4: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828D67F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D67FC: 4E800421  bctrl
	ctx.lr = 0x828D6800;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D6800: 817F0064  lwz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 828D6804: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 828D6808: 4198004C  blt cr6, 0x828d6854
	if ctx.cr[6].lt {
	pc = 0x828D6854; continue 'dispatch;
	}
	// 828D680C: 409A00A0  bne cr6, 0x828d68ac
	if !ctx.cr[6].eq {
	pc = 0x828D68AC; continue 'dispatch;
	}
	// 828D6810: 4BF13B01  bl 0x827ea310
	ctx.lr = 0x828D6814;
	sub_827EA310(ctx, base);
	// 828D6814: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D6818: 41820094  beq 0x828d68ac
	if ctx.cr[0].eq {
	pc = 0x828D68AC; continue 'dispatch;
	}
	// 828D681C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D6820: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D6824: 808B0B24  lwz r4, 0xb24(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2852 as u32) ) } as u64;
	// 828D6828: 4851D1E1  bl 0x82df3a08
	ctx.lr = 0x828D682C;
	sub_82DF3A08(ctx, base);
	// 828D682C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828D6830: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828D6834: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D6838: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D683C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D6840: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828D6844: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828D6848: 48588249  bl 0x82e5ea90
	ctx.lr = 0x828D684C;
	sub_82E5EA90(ctx, base);
	// 828D684C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828D6850: 48000050  b 0x828d68a0
	pc = 0x828D68A0; continue 'dispatch;
	// 828D6854: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D6858: 4BFE2491  bl 0x828b8ce8
	ctx.lr = 0x828D685C;
	sub_828B8CE8(ctx, base);
	// 828D685C: 4BF8FC1D  bl 0x82866478
	ctx.lr = 0x828D6860;
	sub_82866478(ctx, base);
	// 828D6860: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D6864: 556BFFFF  rlwinm. r11, r11, 0x1f, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D6868: 41820044  beq 0x828d68ac
	if ctx.cr[0].eq {
	pc = 0x828D68AC; continue 'dispatch;
	}
	// 828D686C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D6870: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D6874: 808B0B2C  lwz r4, 0xb2c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2860 as u32) ) } as u64;
	// 828D6878: 4851D191  bl 0x82df3a08
	ctx.lr = 0x828D687C;
	sub_82DF3A08(ctx, base);
	// 828D687C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828D6880: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828D6884: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D6888: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D688C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D6890: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828D6894: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828D6898: 485881F9  bl 0x82e5ea90
	ctx.lr = 0x828D689C;
	sub_82E5EA90(ctx, base);
	// 828D689C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828D68A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D68A4: 419A0008  beq cr6, 0x828d68ac
	if ctx.cr[6].eq {
	pc = 0x828D68AC; continue 'dispatch;
	}
	// 828D68A8: 4B9E9FE9  bl 0x822c0890
	ctx.lr = 0x828D68AC;
	sub_822C0890(ctx, base);
	// 828D68AC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828D68B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D68B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D68B8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828D68BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D68C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D68C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828D68C8 size=624
    let mut pc: u32 = 0x828D68C8;
    'dispatch: loop {
        match pc {
            0x828D68C8 => {
    //   block [0x828D68C8..0x828D6B38)
	// 828D68C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D68CC: 488D18A1  bl 0x831a816c
	ctx.lr = 0x828D68D0;
	sub_831A8130(ctx, base);
	// 828D68D0: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 828D68D4: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 828D68D8: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D68DC: 4887DD25  bl 0x83154600
	ctx.lr = 0x828D68E0;
	sub_83154600(ctx, base);
	// 828D68E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D68E4: 4BFE2405  bl 0x828b8ce8
	ctx.lr = 0x828D68E8;
	sub_828B8CE8(ctx, base);
	// 828D68E8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D68EC: 4BFF80F5  bl 0x828ce9e0
	ctx.lr = 0x828D68F0;
	sub_828CE9E0(ctx, base);
	// 828D68F0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D68F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D68F8: 4BF8FB81  bl 0x82866478
	ctx.lr = 0x828D68FC;
	sub_82866478(ctx, base);
	// 828D68FC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828D6900: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D6904: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D6908: C3CA08A8  lfs f30, 0x8a8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 828D690C: 41820080  beq 0x828d698c
	if ctx.cr[0].eq {
	pc = 0x828D698C; continue 'dispatch;
	}
	// 828D6910: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828D6914: 387E0010  addi r3, r30, 0x10
	ctx.r[3].s64 = ctx.r[30].s64 + 16;
	// 828D6918: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828D691C: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828D6920: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D6924: 4E800421  bctrl
	ctx.lr = 0x828D6928;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D6928: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D692C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D6930: C00BF1E0  lfs f0, -0xe20(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3616 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D6934: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 828D6938: 40980010  bge cr6, 0x828d6948
	if !ctx.cr[6].lt {
	pc = 0x828D6948; continue 'dispatch;
	}
	// 828D693C: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D6940: 808B6038  lwz r4, 0x6038(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24632 as u32) ) } as u64;
	// 828D6944: 4800000C  b 0x828d6950
	pc = 0x828D6950; continue 'dispatch;
	// 828D6948: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D694C: 808B603C  lwz r4, 0x603c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24636 as u32) ) } as u64;
	// 828D6950: 4851D0B9  bl 0x82df3a08
	ctx.lr = 0x828D6954;
	sub_82DF3A08(ctx, base);
	// 828D6954: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D6958: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D695C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D6960: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828D6964: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D6968: 4E800421  bctrl
	ctx.lr = 0x828D696C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D696C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D6970: 4851CAB9  bl 0x82df3428
	ctx.lr = 0x828D6974;
	sub_82DF3428(ctx, base);
	// 828D6974: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D6978: 4BF8FB01  bl 0x82866478
	ctx.lr = 0x828D697C;
	sub_82866478(ctx, base);
	// 828D697C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D6980: 556B003C  rlwinm r11, r11, 0, 0, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828D6984: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D6988: 48000034  b 0x828d69bc
	pc = 0x828D69BC; continue 'dispatch;
	// 828D698C: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D6990: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D6994: 808B603C  lwz r4, 0x603c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24636 as u32) ) } as u64;
	// 828D6998: 4851D071  bl 0x82df3a08
	ctx.lr = 0x828D699C;
	sub_82DF3A08(ctx, base);
	// 828D699C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D69A0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D69A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D69A8: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828D69AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D69B0: 4E800421  bctrl
	ctx.lr = 0x828D69B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D69B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D69B8: 4851CA71  bl 0x82df3428
	ctx.lr = 0x828D69BC;
	sub_82DF3428(ctx, base);
	// 828D69BC: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828D69C0: 3BFE0010  addi r31, r30, 0x10
	ctx.r[31].s64 = ctx.r[30].s64 + 16;
	// 828D69C4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828D69C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D69CC: 816B00D0  lwz r11, 0xd0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(208 as u32) ) } as u64;
	// 828D69D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D69D4: 4E800421  bctrl
	ctx.lr = 0x828D69D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D69D8: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828D69DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D69E0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828D69E4: 816B00D4  lwz r11, 0xd4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(212 as u32) ) } as u64;
	// 828D69E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D69EC: 4E800421  bctrl
	ctx.lr = 0x828D69F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D69F0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828D69F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D69F8: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 828D69FC: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828D6A00: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828D6A04: 48038375  bl 0x8290ed78
	ctx.lr = 0x828D6A08;
	sub_8290ED78(ctx, base);
	// 828D6A08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D6A0C: 48032ADD  bl 0x829094e8
	ctx.lr = 0x828D6A10;
	sub_829094E8(ctx, base);
	// 828D6A10: 39600008  li r11, 8
	ctx.r[11].s64 = 8;
	// 828D6A14: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D6A18: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828D6A1C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D6A20: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D6A24: 4BAC3AD5  bl 0x8239a4f8
	ctx.lr = 0x828D6A28;
	sub_8239A4F8(ctx, base);
	// 828D6A28: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D6A2C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828D6A30: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D6A34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D6A38: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828D6A3C: 419A0024  beq cr6, 0x828d6a60
	if ctx.cr[6].eq {
	pc = 0x828D6A60; continue 'dispatch;
	}
	// 828D6A40: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828D6A44: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828D6A48: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D6A4C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828D6A50: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828D6A54: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D6A58: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D6A5C: 4082FFE8  bne 0x828d6a44
	if !ctx.cr[0].eq {
	pc = 0x828D6A44; continue 'dispatch;
	}
	// 828D6A60: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828D6A64: C05D0030  lfs f2, 0x30(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 828D6A68: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D6A6C: C03D002C  lfs f1, 0x2c(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(44 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828D6A70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D6A74: 4804813D  bl 0x8291ebb0
	ctx.lr = 0x828D6A78;
	sub_8291EBB0(ctx, base);
	// 828D6A78: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828D6A7C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D6A80: 419A0008  beq cr6, 0x828d6a88
	if ctx.cr[6].eq {
	pc = 0x828D6A88; continue 'dispatch;
	}
	// 828D6A84: 4B9E9E0D  bl 0x822c0890
	ctx.lr = 0x828D6A88;
	sub_822C0890(ctx, base);
	// 828D6A88: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828D6A8C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828D6A90: 388B7868  addi r4, r11, 0x7868
	ctx.r[4].s64 = ctx.r[11].s64 + 30824;
	// 828D6A94: 4851CF75  bl 0x82df3a08
	ctx.lr = 0x828D6A98;
	sub_82DF3A08(ctx, base);
	// 828D6A98: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828D6A9C: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 828D6AA0: 388B242C  addi r4, r11, 0x242c
	ctx.r[4].s64 = ctx.r[11].s64 + 9260;
	// 828D6AA4: 4851CF65  bl 0x82df3a08
	ctx.lr = 0x828D6AA8;
	sub_82DF3A08(ctx, base);
	// 828D6AA8: 39600007  li r11, 7
	ctx.r[11].s64 = 7;
	// 828D6AAC: D3E1007C  stfs f31, 0x7c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 828D6AB0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828D6AB4: D3E10080  stfs f31, 0x80(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 828D6AB8: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 828D6ABC: D3E10084  stfs f31, 0x84(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 828D6AC0: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 828D6AC4: D3E10088  stfs f31, 0x88(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 828D6AC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D6ACC: D3E1008C  stfs f31, 0x8c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 828D6AD0: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828D6AD4: D3E10090  stfs f31, 0x90(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 828D6AD8: D3C10094  stfs f30, 0x94(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 828D6ADC: D3C10098  stfs f30, 0x98(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 828D6AE0: D3C1009C  stfs f30, 0x9c(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 828D6AE4: 4BF15B25  bl 0x827ec608
	ctx.lr = 0x828D6AE8;
	sub_827EC608(ctx, base);
	// 828D6AE8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828D6AEC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D6AF0: 38AB241C  addi r5, r11, 0x241c
	ctx.r[5].s64 = ctx.r[11].s64 + 9244;
	// 828D6AF4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828D6AF8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D6AFC: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 828D6B00: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D6B04: 4E800421  bctrl
	ctx.lr = 0x828D6B08;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D6B08: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828D6B0C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D6B10: 419A0008  beq cr6, 0x828d6b18
	if ctx.cr[6].eq {
	pc = 0x828D6B18; continue 'dispatch;
	}
	// 828D6B14: 4B9E9D7D  bl 0x822c0890
	ctx.lr = 0x828D6B18;
	sub_822C0890(ctx, base);
	// 828D6B18: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 828D6B1C: 4851C90D  bl 0x82df3428
	ctx.lr = 0x828D6B20;
	sub_82DF3428(ctx, base);
	// 828D6B20: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828D6B24: 4851C905  bl 0x82df3428
	ctx.lr = 0x828D6B28;
	sub_82DF3428(ctx, base);
	// 828D6B28: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 828D6B2C: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 828D6B30: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 828D6B34: 488D1688  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D6B38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828D6B38 size=304
    let mut pc: u32 = 0x828D6B38;
    'dispatch: loop {
        match pc {
            0x828D6B38 => {
    //   block [0x828D6B38..0x828D6C68)
	// 828D6B38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D6B3C: 488D162D  bl 0x831a8168
	ctx.lr = 0x828D6B40;
	sub_831A8130(ctx, base);
	// 828D6B40: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D6B44: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D6B48: 4887DAB9  bl 0x83154600
	ctx.lr = 0x828D6B4C;
	sub_83154600(ctx, base);
	// 828D6B4C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D6B50: 4BFE2199  bl 0x828b8ce8
	ctx.lr = 0x828D6B54;
	sub_828B8CE8(ctx, base);
	// 828D6B54: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828D6B58: 3BDC0010  addi r30, r28, 0x10
	ctx.r[30].s64 = ctx.r[28].s64 + 16;
	// 828D6B5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D6B60: 48032301  bl 0x82908e60
	ctx.lr = 0x828D6B64;
	sub_82908E60(ctx, base);
	// 828D6B64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D6B68: 48032A01  bl 0x82909568
	ctx.lr = 0x828D6B6C;
	sub_82909568(ctx, base);
	// 828D6B6C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D6B70: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D6B74: 38ABF4AC  addi r5, r11, -0xb54
	ctx.r[5].s64 = ctx.r[11].s64 + -2900;
	// 828D6B78: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828D6B7C: 817C0010  lwz r11, 0x10(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 828D6B80: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 828D6B84: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D6B88: 4E800421  bctrl
	ctx.lr = 0x828D6B8C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D6B8C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828D6B90: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D6B94: 419A0008  beq cr6, 0x828d6b9c
	if ctx.cr[6].eq {
	pc = 0x828D6B9C; continue 'dispatch;
	}
	// 828D6B98: 4B9E9CF9  bl 0x822c0890
	ctx.lr = 0x828D6B9C;
	sub_822C0890(ctx, base);
	// 828D6B9C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828D6BA0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D6BA4: 4BF155B5  bl 0x827ec158
	ctx.lr = 0x828D6BA8;
	sub_827EC158(ctx, base);
	// 828D6BA8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D6BAC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D6BB0: 388BF494  addi r4, r11, -0xb6c
	ctx.r[4].s64 = ctx.r[11].s64 + -2924;
	// 828D6BB4: 4851CE55  bl 0x82df3a08
	ctx.lr = 0x828D6BB8;
	sub_82DF3A08(ctx, base);
	// 828D6BB8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828D6BBC: 38E00007  li r7, 7
	ctx.r[7].s64 = 7;
	// 828D6BC0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828D6BC4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828D6BC8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D6BCC: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828D6BD0: 4BF15631  bl 0x827ec200
	ctx.lr = 0x828D6BD4;
	sub_827EC200(ctx, base);
	// 828D6BD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D6BD8: 4851C851  bl 0x82df3428
	ctx.lr = 0x828D6BDC;
	sub_82DF3428(ctx, base);
	// 828D6BDC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828D6BE0: 4BF8F899  bl 0x82866478
	ctx.lr = 0x828D6BE4;
	sub_82866478(ctx, base);
	// 828D6BE4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828D6BE8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828D6BEC: 38800011  li r4, 0x11
	ctx.r[4].s64 = 17;
	// 828D6BF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D6BF4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D6BF8: 554A07B8  rlwinm r10, r10, 0, 0x1e, 0x1c
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 828D6BFC: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828D6C00: 48040421  bl 0x82917020
	ctx.lr = 0x828D6C04;
	sub_82917020(ctx, base);
	// 828D6C04: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828D6C08: 38800012  li r4, 0x12
	ctx.r[4].s64 = 18;
	// 828D6C0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D6C10: 48040411  bl 0x82917020
	ctx.lr = 0x828D6C14;
	sub_82917020(ctx, base);
	// 828D6C14: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828D6C18: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 828D6C1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D6C20: 48040401  bl 0x82917020
	ctx.lr = 0x828D6C24;
	sub_82917020(ctx, base);
	// 828D6C24: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D6C28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D6C2C: 808BF460  lwz r4, -0xba0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2976 as u32) ) } as u64;
	// 828D6C30: 4851CDD9  bl 0x82df3a08
	ctx.lr = 0x828D6C34;
	sub_82DF3A08(ctx, base);
	// 828D6C34: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D6C38: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D6C3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D6C40: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828D6C44: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D6C48: 4E800421  bctrl
	ctx.lr = 0x828D6C4C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D6C4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D6C50: 4851C7D9  bl 0x82df3428
	ctx.lr = 0x828D6C54;
	sub_82DF3428(ctx, base);
	// 828D6C54: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828D6C58: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828D6C5C: 917D0064  stw r11, 0x64(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828D6C60: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 828D6C64: 488D1554  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D6C68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D6C68 size=104
    let mut pc: u32 = 0x828D6C68;
    'dispatch: loop {
        match pc {
            0x828D6C68 => {
    //   block [0x828D6C68..0x828D6CD0)
	// 828D6C68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D6C6C: 488D1501  bl 0x831a816c
	ctx.lr = 0x828D6C70;
	sub_831A8130(ctx, base);
	// 828D6C70: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D6C74: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828D6C78: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D6C7C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828D6C80: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D6C84: 41820034  beq 0x828d6cb8
	if ctx.cr[0].eq {
	pc = 0x828D6CB8; continue 'dispatch;
	}
	// 828D6C88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D6C8C: 488D2CFD  bl 0x831a9988
	ctx.lr = 0x828D6C90;
	sub_831A9988(ctx, base);
	// 828D6C90: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D6C94: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D6C98: 386B583C  addi r3, r11, 0x583c
	ctx.r[3].s64 = ctx.r[11].s64 + 22588;
	// 828D6C9C: 488D145D  bl 0x831a80f8
	ctx.lr = 0x828D6CA0;
	sub_831A80F8(ctx, base);
	// 828D6CA0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D6CA4: 41820014  beq 0x828d6cb8
	if ctx.cr[0].eq {
	pc = 0x828D6CB8; continue 'dispatch;
	}
	// 828D6CA8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D6CAC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D6CB0: 4BFFFE89  bl 0x828d6b38
	ctx.lr = 0x828D6CB4;
	sub_828D6B38(ctx, base);
	// 828D6CB4: 48000014  b 0x828d6cc8
	pc = 0x828D6CC8; continue 'dispatch;
	// 828D6CB8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828D6CBC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D6CC0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D6CC4: 488A77C5  bl 0x8317e488
	ctx.lr = 0x828D6CC8;
	sub_8317E488(ctx, base);
	// 828D6CC8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D6CCC: 488D14F0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D6CD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D6CD0 size=96
    let mut pc: u32 = 0x828D6CD0;
    'dispatch: loop {
        match pc {
            0x828D6CD0 => {
    //   block [0x828D6CD0..0x828D6D30)
	// 828D6CD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D6CD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D6CD8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D6CDC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D6CE0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D6CE4: 4BFFD285  bl 0x828d3f68
	ctx.lr = 0x828D6CE8;
	sub_828D3F68(ctx, base);
	// 828D6CE8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D6CEC: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 828D6CF0: 396BF4C4  addi r11, r11, -0xb3c
	ctx.r[11].s64 = ctx.r[11].s64 + -2876;
	// 828D6CF4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D6CF8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D6CFC: 808A604C  lwz r4, 0x604c(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24652 as u32) ) } as u64;
	// 828D6D00: 4851CD09  bl 0x82df3a08
	ctx.lr = 0x828D6D04;
	sub_82DF3A08(ctx, base);
	// 828D6D04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D6D08: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D6D0C: 485829DD  bl 0x82e596e8
	ctx.lr = 0x828D6D10;
	sub_82E596E8(ctx, base);
	// 828D6D10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D6D14: 4851C715  bl 0x82df3428
	ctx.lr = 0x828D6D18;
	sub_82DF3428(ctx, base);
	// 828D6D18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D6D1C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D6D20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D6D24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D6D28: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D6D2C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D6D30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828D6D30 size=100
    let mut pc: u32 = 0x828D6D30;
    'dispatch: loop {
        match pc {
            0x828D6D30 => {
    //   block [0x828D6D30..0x828D6D94)
	// 828D6D30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D6D34: 488D1439  bl 0x831a816c
	ctx.lr = 0x828D6D38;
	sub_831A8130(ctx, base);
	// 828D6D38: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D6D3C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D6D40: 4887D8C1  bl 0x83154600
	ctx.lr = 0x828D6D44;
	sub_83154600(ctx, base);
	// 828D6D44: 4BFE1FA5  bl 0x828b8ce8
	ctx.lr = 0x828D6D48;
	sub_828B8CE8(ctx, base);
	// 828D6D48: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D6D4C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828D6D50: 3BDF0010  addi r30, r31, 0x10
	ctx.r[30].s64 = ctx.r[31].s64 + 16;
	// 828D6D54: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D6D58: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828D6D5C: 816B00D0  lwz r11, 0xd0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(208 as u32) ) } as u64;
	// 828D6D60: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D6D64: 4E800421  bctrl
	ctx.lr = 0x828D6D68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D6D68: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828D6D6C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828D6D70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D6D74: 816B00D4  lwz r11, 0xd4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(212 as u32) ) } as u64;
	// 828D6D78: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D6D7C: 4E800421  bctrl
	ctx.lr = 0x828D6D80;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D6D80: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828D6D84: C00B9534  lfs f0, -0x6acc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D6D88: D01D0060  stfs f0, 0x60(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828D6D8C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D6D90: 488D142C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D6D98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D6D98 size=96
    let mut pc: u32 = 0x828D6D98;
    'dispatch: loop {
        match pc {
            0x828D6D98 => {
    //   block [0x828D6D98..0x828D6DF8)
	// 828D6D98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D6D9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D6DA0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D6DA4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D6DA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D6DAC: 4BFFD205  bl 0x828d3fb0
	ctx.lr = 0x828D6DB0;
	sub_828D3FB0(ctx, base);
	// 828D6DB0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D6DB4: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 828D6DB8: 396BF4EC  addi r11, r11, -0xb14
	ctx.r[11].s64 = ctx.r[11].s64 + -2836;
	// 828D6DBC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D6DC0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D6DC4: 808A6050  lwz r4, 0x6050(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24656 as u32) ) } as u64;
	// 828D6DC8: 4851CC41  bl 0x82df3a08
	ctx.lr = 0x828D6DCC;
	sub_82DF3A08(ctx, base);
	// 828D6DCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D6DD0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D6DD4: 48582915  bl 0x82e596e8
	ctx.lr = 0x828D6DD8;
	sub_82E596E8(ctx, base);
	// 828D6DD8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D6DDC: 4851C64D  bl 0x82df3428
	ctx.lr = 0x828D6DE0;
	sub_82DF3428(ctx, base);
	// 828D6DE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D6DE4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D6DE8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D6DEC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D6DF0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D6DF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D6DF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D6DF8 size=184
    let mut pc: u32 = 0x828D6DF8;
    'dispatch: loop {
        match pc {
            0x828D6DF8 => {
    //   block [0x828D6DF8..0x828D6EB0)
	// 828D6DF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D6DFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D6E00: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828D6E04: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D6E08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D6E0C: 4887D7F5  bl 0x83154600
	ctx.lr = 0x828D6E10;
	sub_83154600(ctx, base);
	// 828D6E10: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D6E14: 4BFE1ED5  bl 0x828b8ce8
	ctx.lr = 0x828D6E18;
	sub_828B8CE8(ctx, base);
	// 828D6E18: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D6E1C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D6E20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D6E24: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828D6E28: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D6E2C: 4E800421  bctrl
	ctx.lr = 0x828D6E30;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D6E30: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D6E34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D6E38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D6E3C: 808B6034  lwz r4, 0x6034(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24628 as u32) ) } as u64;
	// 828D6E40: 4851CBC9  bl 0x82df3a08
	ctx.lr = 0x828D6E44;
	sub_82DF3A08(ctx, base);
	// 828D6E44: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D6E48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D6E4C: 4BF13695  bl 0x827ea4e0
	ctx.lr = 0x828D6E50;
	sub_827EA4E0(ctx, base);
	// 828D6E50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D6E54: 4851C5D5  bl 0x82df3428
	ctx.lr = 0x828D6E58;
	sub_82DF3428(ctx, base);
	// 828D6E58: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828D6E5C: 3BFE0010  addi r31, r30, 0x10
	ctx.r[31].s64 = ctx.r[30].s64 + 16;
	// 828D6E60: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828D6E64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D6E68: 816B00D0  lwz r11, 0xd0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(208 as u32) ) } as u64;
	// 828D6E6C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D6E70: 4E800421  bctrl
	ctx.lr = 0x828D6E74;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D6E74: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828D6E78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D6E7C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828D6E80: 816B00D4  lwz r11, 0xd4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(212 as u32) ) } as u64;
	// 828D6E84: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D6E88: 4E800421  bctrl
	ctx.lr = 0x828D6E8C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D6E8C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828D6E90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D6E94: 480398B5  bl 0x82910748
	ctx.lr = 0x828D6E98;
	sub_82910748(ctx, base);
	// 828D6E98: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D6E9C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D6EA0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D6EA4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828D6EA8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D6EAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D6EB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D6EB0 size=96
    let mut pc: u32 = 0x828D6EB0;
    'dispatch: loop {
        match pc {
            0x828D6EB0 => {
    //   block [0x828D6EB0..0x828D6F10)
	// 828D6EB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D6EB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D6EB8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D6EBC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D6EC0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D6EC4: 4BFFD0A5  bl 0x828d3f68
	ctx.lr = 0x828D6EC8;
	sub_828D3F68(ctx, base);
	// 828D6EC8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D6ECC: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 828D6ED0: 396BF518  addi r11, r11, -0xae8
	ctx.r[11].s64 = ctx.r[11].s64 + -2792;
	// 828D6ED4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D6ED8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D6EDC: 808A6054  lwz r4, 0x6054(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24660 as u32) ) } as u64;
	// 828D6EE0: 4851CB29  bl 0x82df3a08
	ctx.lr = 0x828D6EE4;
	sub_82DF3A08(ctx, base);
	// 828D6EE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D6EE8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D6EEC: 485827FD  bl 0x82e596e8
	ctx.lr = 0x828D6EF0;
	sub_82E596E8(ctx, base);
	// 828D6EF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D6EF4: 4851C535  bl 0x82df3428
	ctx.lr = 0x828D6EF8;
	sub_82DF3428(ctx, base);
	// 828D6EF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D6EFC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D6F00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D6F04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D6F08: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D6F0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D6F10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D6F10 size=172
    let mut pc: u32 = 0x828D6F10;
    'dispatch: loop {
        match pc {
            0x828D6F10 => {
    //   block [0x828D6F10..0x828D6FBC)
	// 828D6F10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D6F14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D6F18: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828D6F1C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D6F20: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D6F24: 4887D6DD  bl 0x83154600
	ctx.lr = 0x828D6F28;
	sub_83154600(ctx, base);
	// 828D6F28: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D6F2C: 4BFE1DBD  bl 0x828b8ce8
	ctx.lr = 0x828D6F30;
	sub_828B8CE8(ctx, base);
	// 828D6F30: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D6F34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D6F38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D6F3C: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828D6F40: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D6F44: 4E800421  bctrl
	ctx.lr = 0x828D6F48;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D6F48: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D6F4C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D6F50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D6F54: 808B6040  lwz r4, 0x6040(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24640 as u32) ) } as u64;
	// 828D6F58: 4851CAB1  bl 0x82df3a08
	ctx.lr = 0x828D6F5C;
	sub_82DF3A08(ctx, base);
	// 828D6F5C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D6F60: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D6F64: 4BF1357D  bl 0x827ea4e0
	ctx.lr = 0x828D6F68;
	sub_827EA4E0(ctx, base);
	// 828D6F68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D6F6C: 4851C4BD  bl 0x82df3428
	ctx.lr = 0x828D6F70;
	sub_82DF3428(ctx, base);
	// 828D6F70: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828D6F74: 3BDF0010  addi r30, r31, 0x10
	ctx.r[30].s64 = ctx.r[31].s64 + 16;
	// 828D6F78: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828D6F7C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D6F80: 816B00D0  lwz r11, 0xd0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(208 as u32) ) } as u64;
	// 828D6F84: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D6F88: 4E800421  bctrl
	ctx.lr = 0x828D6F8C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D6F8C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828D6F90: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828D6F94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D6F98: 816B00D4  lwz r11, 0xd4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(212 as u32) ) } as u64;
	// 828D6F9C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D6FA0: 4E800421  bctrl
	ctx.lr = 0x828D6FA4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D6FA4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D6FA8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D6FAC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D6FB0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828D6FB4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D6FB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D6FC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D6FC0 size=96
    let mut pc: u32 = 0x828D6FC0;
    'dispatch: loop {
        match pc {
            0x828D6FC0 => {
    //   block [0x828D6FC0..0x828D7020)
	// 828D6FC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D6FC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D6FC8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D6FCC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D6FD0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D6FD4: 4BFFCF95  bl 0x828d3f68
	ctx.lr = 0x828D6FD8;
	sub_828D3F68(ctx, base);
	// 828D6FD8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D6FDC: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828D6FE0: 396BF5A4  addi r11, r11, -0xa5c
	ctx.r[11].s64 = ctx.r[11].s64 + -2652;
	// 828D6FE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D6FE8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D6FEC: 808A0AF0  lwz r4, 0xaf0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2800 as u32) ) } as u64;
	// 828D6FF0: 4851CA19  bl 0x82df3a08
	ctx.lr = 0x828D6FF4;
	sub_82DF3A08(ctx, base);
	// 828D6FF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D6FF8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D6FFC: 485826ED  bl 0x82e596e8
	ctx.lr = 0x828D7000;
	sub_82E596E8(ctx, base);
	// 828D7000: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D7004: 4851C425  bl 0x82df3428
	ctx.lr = 0x828D7008;
	sub_82DF3428(ctx, base);
	// 828D7008: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D700C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D7010: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D7014: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D7018: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D701C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D7020(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828D7020 size=348
    let mut pc: u32 = 0x828D7020;
    'dispatch: loop {
        match pc {
            0x828D7020 => {
    //   block [0x828D7020..0x828D717C)
	// 828D7020: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D7024: 488D1149  bl 0x831a816c
	ctx.lr = 0x828D7028;
	sub_831A8130(ctx, base);
	// 828D7028: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 828D702C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D7030: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D7034: 48582745  bl 0x82e59778
	ctx.lr = 0x828D7038;
	sub_82E59778(ctx, base);
	// 828D7038: C01E0060  lfs f0, 0x60(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D703C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828D7040: EC000828  fsubs f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 828D7044: D01E0060  stfs f0, 0x60(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828D7048: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828D704C: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 828D7050: 40980120  bge cr6, 0x828d7170
	if !ctx.cr[6].lt {
	pc = 0x828D7170; continue 'dispatch;
	}
	// 828D7054: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D7058: 4887D5A9  bl 0x83154600
	ctx.lr = 0x828D705C;
	sub_83154600(ctx, base);
	// 828D705C: 4BFE1C8D  bl 0x828b8ce8
	ctx.lr = 0x828D7060;
	sub_828B8CE8(ctx, base);
	// 828D7060: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D7064: 4BFF797D  bl 0x828ce9e0
	ctx.lr = 0x828D7068;
	sub_828CE9E0(ctx, base);
	// 828D7068: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D706C: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 828D7070: 387D0010  addi r3, r29, 0x10
	ctx.r[3].s64 = ctx.r[29].s64 + 16;
	// 828D7074: C1BF0008  lfs f13, 8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828D7078: C01F000C  lfs f0, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D707C: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828D7080: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 828D7084: C1BF0004  lfs f13, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828D7088: EC20682A  fadds f1, f0, f13
	ctx.f[1].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 828D708C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D7090: 4E800421  bctrl
	ctx.lr = 0x828D7094;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D7094: C01F0004  lfs f0, 4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D7098: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 828D709C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D70A0: 40980040  bge cr6, 0x828d70e0
	if !ctx.cr[6].lt {
	pc = 0x828D70E0; continue 'dispatch;
	}
	// 828D70A4: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D70A8: 808B0AFC  lwz r4, 0xafc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2812 as u32) ) } as u64;
	// 828D70AC: 4851C95D  bl 0x82df3a08
	ctx.lr = 0x828D70B0;
	sub_82DF3A08(ctx, base);
	// 828D70B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D70B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D70B8: 48731071  bl 0x83008128
	ctx.lr = 0x828D70BC;
	sub_83008128(ctx, base);
	// 828D70BC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D70C0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D70C4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828D70C8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D70CC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D70D0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828D70D4: 4858788D  bl 0x82e5e960
	ctx.lr = 0x828D70D8;
	sub_82E5E960(ctx, base);
	// 828D70D8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828D70DC: 48000088  b 0x828d7164
	pc = 0x828D7164; continue 'dispatch;
	// 828D70E0: EC010028  fsubs f0, f1, f0
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 828D70E4: C1BF0008  lfs f13, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828D70E8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 828D70EC: 40980040  bge cr6, 0x828d712c
	if !ctx.cr[6].lt {
	pc = 0x828D712C; continue 'dispatch;
	}
	// 828D70F0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D70F4: 808B0AF8  lwz r4, 0xaf8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2808 as u32) ) } as u64;
	// 828D70F8: 4851C911  bl 0x82df3a08
	ctx.lr = 0x828D70FC;
	sub_82DF3A08(ctx, base);
	// 828D70FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D7100: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D7104: 48731025  bl 0x83008128
	ctx.lr = 0x828D7108;
	sub_83008128(ctx, base);
	// 828D7108: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D710C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D7110: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828D7114: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D7118: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D711C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828D7120: 48587841  bl 0x82e5e960
	ctx.lr = 0x828D7124;
	sub_82E5E960(ctx, base);
	// 828D7124: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828D7128: 4800003C  b 0x828d7164
	pc = 0x828D7164; continue 'dispatch;
	// 828D712C: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D7130: 808B6050  lwz r4, 0x6050(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24656 as u32) ) } as u64;
	// 828D7134: 4851C8D5  bl 0x82df3a08
	ctx.lr = 0x828D7138;
	sub_82DF3A08(ctx, base);
	// 828D7138: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D713C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D7140: 48730FE9  bl 0x83008128
	ctx.lr = 0x828D7144;
	sub_83008128(ctx, base);
	// 828D7144: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D7148: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828D714C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828D7150: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D7154: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D7158: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828D715C: 48587805  bl 0x82e5e960
	ctx.lr = 0x828D7160;
	sub_82E5E960(ctx, base);
	// 828D7160: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828D7164: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D7168: 419A0008  beq cr6, 0x828d7170
	if ctx.cr[6].eq {
	pc = 0x828D7170; continue 'dispatch;
	}
	// 828D716C: 4B9E9725  bl 0x822c0890
	ctx.lr = 0x828D7170;
	sub_822C0890(ctx, base);
	// 828D7170: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828D7174: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 828D7178: 488D1044  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D7180(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D7180 size=96
    let mut pc: u32 = 0x828D7180;
    'dispatch: loop {
        match pc {
            0x828D7180 => {
    //   block [0x828D7180..0x828D71E0)
	// 828D7180: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D7184: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D7188: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D718C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D7190: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D7194: 4BFFCE1D  bl 0x828d3fb0
	ctx.lr = 0x828D7198;
	sub_828D3FB0(ctx, base);
	// 828D7198: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D719C: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828D71A0: 396BF5CC  addi r11, r11, -0xa34
	ctx.r[11].s64 = ctx.r[11].s64 + -2612;
	// 828D71A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D71A8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D71AC: 808A0AF8  lwz r4, 0xaf8(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2808 as u32) ) } as u64;
	// 828D71B0: 4851C859  bl 0x82df3a08
	ctx.lr = 0x828D71B4;
	sub_82DF3A08(ctx, base);
	// 828D71B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D71B8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D71BC: 4858252D  bl 0x82e596e8
	ctx.lr = 0x828D71C0;
	sub_82E596E8(ctx, base);
	// 828D71C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D71C4: 4851C265  bl 0x82df3428
	ctx.lr = 0x828D71C8;
	sub_82DF3428(ctx, base);
	// 828D71C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D71CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D71D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D71D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D71D8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D71DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D71E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828D71E0 size=268
    let mut pc: u32 = 0x828D71E0;
    'dispatch: loop {
        match pc {
            0x828D71E0 => {
    //   block [0x828D71E0..0x828D72EC)
	// 828D71E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D71E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D71E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828D71EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D71F0: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 828D71F4: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D71F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D71FC: 4887D405  bl 0x83154600
	ctx.lr = 0x828D7200;
	sub_83154600(ctx, base);
	// 828D7200: 4BFE1AE9  bl 0x828b8ce8
	ctx.lr = 0x828D7204;
	sub_828B8CE8(ctx, base);
	// 828D7204: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D7208: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D720C: 4858256D  bl 0x82e59778
	ctx.lr = 0x828D7210;
	sub_82E59778(ctx, base);
	// 828D7210: C01F0060  lfs f0, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D7214: EC000828  fsubs f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 828D7218: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828D721C: 387E0010  addi r3, r30, 0x10
	ctx.r[3].s64 = ctx.r[30].s64 + 16;
	// 828D7220: 48032361  bl 0x82909580
	ctx.lr = 0x828D7224;
	sub_82909580(ctx, base);
	// 828D7224: 48044BF5  bl 0x8291be18
	ctx.lr = 0x828D7228;
	sub_8291BE18(ctx, base);
	// 828D7228: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D722C: 41820048  beq 0x828d7274
	if ctx.cr[0].eq {
	pc = 0x828D7274; continue 'dispatch;
	}
	// 828D7230: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D7234: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D7238: 808B0B08  lwz r4, 0xb08(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2824 as u32) ) } as u64;
	// 828D723C: 4851C7CD  bl 0x82df3a08
	ctx.lr = 0x828D7240;
	sub_82DF3A08(ctx, base);
	// 828D7240: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D7244: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D7248: 48730EE1  bl 0x83008128
	ctx.lr = 0x828D724C;
	sub_83008128(ctx, base);
	// 828D724C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828D7250: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D7254: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D7258: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828D725C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D7260: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828D7264: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828D7268: 485876F9  bl 0x82e5e960
	ctx.lr = 0x828D726C;
	sub_82E5E960(ctx, base);
	// 828D726C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828D7270: 48000054  b 0x828d72c4
	pc = 0x828D72C4; continue 'dispatch;
	// 828D7274: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828D7278: C01F0060  lfs f0, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D727C: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828D7280: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 828D7284: 4098004C  bge cr6, 0x828d72d0
	if !ctx.cr[6].lt {
	pc = 0x828D72D0; continue 'dispatch;
	}
	// 828D7288: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D728C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D7290: 808B604C  lwz r4, 0x604c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24652 as u32) ) } as u64;
	// 828D7294: 4851C775  bl 0x82df3a08
	ctx.lr = 0x828D7298;
	sub_82DF3A08(ctx, base);
	// 828D7298: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D729C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D72A0: 48730E89  bl 0x83008128
	ctx.lr = 0x828D72A4;
	sub_83008128(ctx, base);
	// 828D72A4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D72A8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D72AC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828D72B0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828D72B4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D72B8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828D72BC: 485876A5  bl 0x82e5e960
	ctx.lr = 0x828D72C0;
	sub_82E5E960(ctx, base);
	// 828D72C0: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828D72C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D72C8: 419A0008  beq cr6, 0x828d72d0
	if ctx.cr[6].eq {
	pc = 0x828D72D0; continue 'dispatch;
	}
	// 828D72CC: 4B9E95C5  bl 0x822c0890
	ctx.lr = 0x828D72D0;
	sub_822C0890(ctx, base);
	// 828D72D0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828D72D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D72D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D72DC: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 828D72E0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828D72E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D72E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D72F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828D72F0 size=256
    let mut pc: u32 = 0x828D72F0;
    'dispatch: loop {
        match pc {
            0x828D72F0 => {
    //   block [0x828D72F0..0x828D73F0)
	// 828D72F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D72F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D72F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828D72FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D7300: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D7304: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D7308: 4887D2F9  bl 0x83154600
	ctx.lr = 0x828D730C;
	sub_83154600(ctx, base);
	// 828D730C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D7310: 4BFE19D9  bl 0x828b8ce8
	ctx.lr = 0x828D7314;
	sub_828B8CE8(ctx, base);
	// 828D7314: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 828D7318: 48032269  bl 0x82909580
	ctx.lr = 0x828D731C;
	sub_82909580(ctx, base);
	// 828D731C: 48044AFD  bl 0x8291be18
	ctx.lr = 0x828D7320;
	sub_8291BE18(ctx, base);
	// 828D7320: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D7324: 41820048  beq 0x828d736c
	if ctx.cr[0].eq {
	pc = 0x828D736C; continue 'dispatch;
	}
	// 828D7328: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D732C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D7330: 808B0B08  lwz r4, 0xb08(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2824 as u32) ) } as u64;
	// 828D7334: 4851C6D5  bl 0x82df3a08
	ctx.lr = 0x828D7338;
	sub_82DF3A08(ctx, base);
	// 828D7338: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D733C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D7340: 48730DE9  bl 0x83008128
	ctx.lr = 0x828D7344;
	sub_83008128(ctx, base);
	// 828D7344: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828D7348: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D734C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D7350: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828D7354: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D7358: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828D735C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828D7360: 48587601  bl 0x82e5e960
	ctx.lr = 0x828D7364;
	sub_82E5E960(ctx, base);
	// 828D7364: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828D7368: 48000064  b 0x828d73cc
	pc = 0x828D73CC; continue 'dispatch;
	// 828D736C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D7370: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D7374: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828D7378: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D737C: 4E800421  bctrl
	ctx.lr = 0x828D7380;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D7380: 4BF12F91  bl 0x827ea310
	ctx.lr = 0x828D7384;
	sub_827EA310(ctx, base);
	// 828D7384: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D7388: 41820050  beq 0x828d73d8
	if ctx.cr[0].eq {
	pc = 0x828D73D8; continue 'dispatch;
	}
	// 828D738C: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D7390: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D7394: 808B604C  lwz r4, 0x604c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24652 as u32) ) } as u64;
	// 828D7398: 4851C671  bl 0x82df3a08
	ctx.lr = 0x828D739C;
	sub_82DF3A08(ctx, base);
	// 828D739C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D73A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D73A4: 48730D85  bl 0x83008128
	ctx.lr = 0x828D73A8;
	sub_83008128(ctx, base);
	// 828D73A8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828D73AC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D73B0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D73B4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828D73B8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D73BC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828D73C0: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828D73C4: 4858759D  bl 0x82e5e960
	ctx.lr = 0x828D73C8;
	sub_82E5E960(ctx, base);
	// 828D73C8: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828D73CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D73D0: 419A0008  beq cr6, 0x828d73d8
	if ctx.cr[6].eq {
	pc = 0x828D73D8; continue 'dispatch;
	}
	// 828D73D4: 4B9E94BD  bl 0x822c0890
	ctx.lr = 0x828D73D8;
	sub_822C0890(ctx, base);
	// 828D73D8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828D73DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D73E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D73E4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828D73E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D73EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D73F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D73F0 size=196
    let mut pc: u32 = 0x828D73F0;
    'dispatch: loop {
        match pc {
            0x828D73F0 => {
    //   block [0x828D73F0..0x828D74B4)
	// 828D73F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D73F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D73F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828D73FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D7400: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D7404: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D7408: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D740C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828D7410: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828D7414: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D7418: 4B9E9521  bl 0x822c0938
	ctx.lr = 0x828D741C;
	sub_822C0938(ctx, base);
	// 828D741C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828D7420: 41820028  beq 0x828d7448
	if ctx.cr[0].eq {
	pc = 0x828D7448; continue 'dispatch;
	}
	// 828D7424: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D7428: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828D742C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D7430: 392BF540  addi r9, r11, -0xac0
	ctx.r[9].s64 = ctx.r[11].s64 + -2752;
	// 828D7434: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828D7438: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828D743C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828D7440: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828D7444: 48000008  b 0x828d744c
	pc = 0x828D744C; continue 'dispatch;
	// 828D7448: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D744C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D7450: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D7454: 409A0044  bne cr6, 0x828d7498
	if !ctx.cr[6].eq {
	pc = 0x828D7498; continue 'dispatch;
	}
	// 828D7458: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828D745C: 419A001C  beq cr6, 0x828d7478
	if ctx.cr[6].eq {
	pc = 0x828D7478; continue 'dispatch;
	}
	// 828D7460: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D7464: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828D7468: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D746C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D7470: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D7474: 4E800421  bctrl
	ctx.lr = 0x828D7478;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D7478: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D747C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828D7480: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D7484: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828D7488: 816B66E4  lwz r11, 0x66e4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26340 as u32) ) } as u64;
	// 828D748C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828D7490: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828D7494: 4B9E8B6D  bl 0x822c0000
	ctx.lr = 0x828D7498;
	sub_822C0000(ctx, base);
	// 828D7498: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D749C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D74A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D74A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D74A8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828D74AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D74B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D74B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D74B8 size=196
    let mut pc: u32 = 0x828D74B8;
    'dispatch: loop {
        match pc {
            0x828D74B8 => {
    //   block [0x828D74B8..0x828D757C)
	// 828D74B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D74BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D74C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828D74C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D74C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D74CC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D74D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D74D4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828D74D8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828D74DC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D74E0: 4B9E9459  bl 0x822c0938
	ctx.lr = 0x828D74E4;
	sub_822C0938(ctx, base);
	// 828D74E4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828D74E8: 41820028  beq 0x828d7510
	if ctx.cr[0].eq {
	pc = 0x828D7510; continue 'dispatch;
	}
	// 828D74EC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D74F0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828D74F4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D74F8: 392BF554  addi r9, r11, -0xaac
	ctx.r[9].s64 = ctx.r[11].s64 + -2732;
	// 828D74FC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828D7500: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828D7504: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828D7508: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828D750C: 48000008  b 0x828d7514
	pc = 0x828D7514; continue 'dispatch;
	// 828D7510: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D7514: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D7518: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D751C: 409A0044  bne cr6, 0x828d7560
	if !ctx.cr[6].eq {
	pc = 0x828D7560; continue 'dispatch;
	}
	// 828D7520: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828D7524: 419A001C  beq cr6, 0x828d7540
	if ctx.cr[6].eq {
	pc = 0x828D7540; continue 'dispatch;
	}
	// 828D7528: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D752C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828D7530: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D7534: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D7538: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D753C: 4E800421  bctrl
	ctx.lr = 0x828D7540;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D7540: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D7544: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828D7548: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D754C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828D7550: 816B66E4  lwz r11, 0x66e4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26340 as u32) ) } as u64;
	// 828D7554: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828D7558: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828D755C: 4B9E8AA5  bl 0x822c0000
	ctx.lr = 0x828D7560;
	sub_822C0000(ctx, base);
	// 828D7560: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D7564: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D7568: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D756C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D7570: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828D7574: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D7578: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D7580(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D7580 size=196
    let mut pc: u32 = 0x828D7580;
    'dispatch: loop {
        match pc {
            0x828D7580 => {
    //   block [0x828D7580..0x828D7644)
	// 828D7580: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D7584: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D7588: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828D758C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D7590: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D7594: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D7598: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D759C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828D75A0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828D75A4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D75A8: 4B9E9391  bl 0x822c0938
	ctx.lr = 0x828D75AC;
	sub_822C0938(ctx, base);
	// 828D75AC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828D75B0: 41820028  beq 0x828d75d8
	if ctx.cr[0].eq {
	pc = 0x828D75D8; continue 'dispatch;
	}
	// 828D75B4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D75B8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828D75BC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D75C0: 392BF568  addi r9, r11, -0xa98
	ctx.r[9].s64 = ctx.r[11].s64 + -2712;
	// 828D75C4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828D75C8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828D75CC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828D75D0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828D75D4: 48000008  b 0x828d75dc
	pc = 0x828D75DC; continue 'dispatch;
	// 828D75D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D75DC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D75E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D75E4: 409A0044  bne cr6, 0x828d7628
	if !ctx.cr[6].eq {
	pc = 0x828D7628; continue 'dispatch;
	}
	// 828D75E8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828D75EC: 419A001C  beq cr6, 0x828d7608
	if ctx.cr[6].eq {
	pc = 0x828D7608; continue 'dispatch;
	}
	// 828D75F0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D75F4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828D75F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D75FC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D7600: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D7604: 4E800421  bctrl
	ctx.lr = 0x828D7608;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D7608: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D760C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828D7610: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D7614: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828D7618: 816B66E4  lwz r11, 0x66e4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26340 as u32) ) } as u64;
	// 828D761C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828D7620: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828D7624: 4B9E89DD  bl 0x822c0000
	ctx.lr = 0x828D7628;
	sub_822C0000(ctx, base);
	// 828D7628: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D762C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D7630: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D7634: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D7638: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828D763C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D7640: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D7648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D7648 size=196
    let mut pc: u32 = 0x828D7648;
    'dispatch: loop {
        match pc {
            0x828D7648 => {
    //   block [0x828D7648..0x828D770C)
	// 828D7648: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D764C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D7650: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828D7654: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D7658: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D765C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D7660: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D7664: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828D7668: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828D766C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D7670: 4B9E92C9  bl 0x822c0938
	ctx.lr = 0x828D7674;
	sub_822C0938(ctx, base);
	// 828D7674: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828D7678: 41820028  beq 0x828d76a0
	if ctx.cr[0].eq {
	pc = 0x828D76A0; continue 'dispatch;
	}
	// 828D767C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D7680: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828D7684: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D7688: 392BF57C  addi r9, r11, -0xa84
	ctx.r[9].s64 = ctx.r[11].s64 + -2692;
	// 828D768C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828D7690: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828D7694: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828D7698: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828D769C: 48000008  b 0x828d76a4
	pc = 0x828D76A4; continue 'dispatch;
	// 828D76A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D76A4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D76A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D76AC: 409A0044  bne cr6, 0x828d76f0
	if !ctx.cr[6].eq {
	pc = 0x828D76F0; continue 'dispatch;
	}
	// 828D76B0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828D76B4: 419A001C  beq cr6, 0x828d76d0
	if ctx.cr[6].eq {
	pc = 0x828D76D0; continue 'dispatch;
	}
	// 828D76B8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D76BC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828D76C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D76C4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D76C8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D76CC: 4E800421  bctrl
	ctx.lr = 0x828D76D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D76D0: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D76D4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828D76D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D76DC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828D76E0: 816B66E4  lwz r11, 0x66e4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26340 as u32) ) } as u64;
	// 828D76E4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828D76E8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828D76EC: 4B9E8915  bl 0x822c0000
	ctx.lr = 0x828D76F0;
	sub_822C0000(ctx, base);
	// 828D76F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D76F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D76F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D76FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D7700: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828D7704: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D7708: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D7710(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D7710 size=196
    let mut pc: u32 = 0x828D7710;
    'dispatch: loop {
        match pc {
            0x828D7710 => {
    //   block [0x828D7710..0x828D77D4)
	// 828D7710: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D7714: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D7718: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828D771C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D7720: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D7724: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D7728: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D772C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828D7730: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828D7734: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D7738: 4B9E9201  bl 0x822c0938
	ctx.lr = 0x828D773C;
	sub_822C0938(ctx, base);
	// 828D773C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828D7740: 41820028  beq 0x828d7768
	if ctx.cr[0].eq {
	pc = 0x828D7768; continue 'dispatch;
	}
	// 828D7744: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D7748: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828D774C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D7750: 392BF590  addi r9, r11, -0xa70
	ctx.r[9].s64 = ctx.r[11].s64 + -2672;
	// 828D7754: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828D7758: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828D775C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828D7760: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828D7764: 48000008  b 0x828d776c
	pc = 0x828D776C; continue 'dispatch;
	// 828D7768: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D776C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D7770: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D7774: 409A0044  bne cr6, 0x828d77b8
	if !ctx.cr[6].eq {
	pc = 0x828D77B8; continue 'dispatch;
	}
	// 828D7778: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828D777C: 419A001C  beq cr6, 0x828d7798
	if ctx.cr[6].eq {
	pc = 0x828D7798; continue 'dispatch;
	}
	// 828D7780: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D7784: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828D7788: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D778C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D7790: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D7794: 4E800421  bctrl
	ctx.lr = 0x828D7798;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D7798: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D779C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828D77A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D77A4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828D77A8: 816B66E4  lwz r11, 0x66e4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26340 as u32) ) } as u64;
	// 828D77AC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828D77B0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828D77B4: 4B9E884D  bl 0x822c0000
	ctx.lr = 0x828D77B8;
	sub_822C0000(ctx, base);
	// 828D77B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D77BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D77C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D77C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D77C8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828D77CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D77D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D77D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828D77D8 size=248
    let mut pc: u32 = 0x828D77D8;
    'dispatch: loop {
        match pc {
            0x828D77D8 => {
    //   block [0x828D77D8..0x828D78D0)
	// 828D77D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D77DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D77E0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D77E4: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D77E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D77EC: 4887CE15  bl 0x83154600
	ctx.lr = 0x828D77F0;
	sub_83154600(ctx, base);
	// 828D77F0: 4BFE14F9  bl 0x828b8ce8
	ctx.lr = 0x828D77F4;
	sub_828B8CE8(ctx, base);
	// 828D77F4: 81630390  lwz r11, 0x390(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(912 as u32) ) } as u64;
	// 828D77F8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 828D77FC: 419A0080  beq cr6, 0x828d787c
	if ctx.cr[6].eq {
	pc = 0x828D787C; continue 'dispatch;
	}
	// 828D7800: 40990044  ble cr6, 0x828d7844
	if !ctx.cr[6].gt {
	pc = 0x828D7844; continue 'dispatch;
	}
	// 828D7804: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 828D7808: 4199003C  bgt cr6, 0x828d7844
	if ctx.cr[6].gt {
	pc = 0x828D7844; continue 'dispatch;
	}
	// 828D780C: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D7810: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D7814: 808B6058  lwz r4, 0x6058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24664 as u32) ) } as u64;
	// 828D7818: 4851C1F1  bl 0x82df3a08
	ctx.lr = 0x828D781C;
	sub_82DF3A08(ctx, base);
	// 828D781C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828D7820: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828D7824: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D7828: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D782C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D7830: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828D7834: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828D7838: 48587259  bl 0x82e5ea90
	ctx.lr = 0x828D783C;
	sub_82E5EA90(ctx, base);
	// 828D783C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828D7840: 48000070  b 0x828d78b0
	pc = 0x828D78B0; continue 'dispatch;
	// 828D7844: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D7848: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D784C: 808B604C  lwz r4, 0x604c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24652 as u32) ) } as u64;
	// 828D7850: 4851C1B9  bl 0x82df3a08
	ctx.lr = 0x828D7854;
	sub_82DF3A08(ctx, base);
	// 828D7854: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828D7858: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828D785C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D7860: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828D7864: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D7868: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828D786C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828D7870: 48587221  bl 0x82e5ea90
	ctx.lr = 0x828D7874;
	sub_82E5EA90(ctx, base);
	// 828D7874: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828D7878: 48000038  b 0x828d78b0
	pc = 0x828D78B0; continue 'dispatch;
	// 828D787C: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D7880: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D7884: 808B6054  lwz r4, 0x6054(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24660 as u32) ) } as u64;
	// 828D7888: 4851C181  bl 0x82df3a08
	ctx.lr = 0x828D788C;
	sub_82DF3A08(ctx, base);
	// 828D788C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828D7890: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828D7894: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D7898: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828D789C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D78A0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828D78A4: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828D78A8: 485871E9  bl 0x82e5ea90
	ctx.lr = 0x828D78AC;
	sub_82E5EA90(ctx, base);
	// 828D78AC: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828D78B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D78B4: 419A0008  beq cr6, 0x828d78bc
	if ctx.cr[6].eq {
	pc = 0x828D78BC; continue 'dispatch;
	}
	// 828D78B8: 4B9E8FD9  bl 0x822c0890
	ctx.lr = 0x828D78BC;
	sub_822C0890(ctx, base);
	// 828D78BC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828D78C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D78C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D78C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D78CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D78D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828D78D0 size=324
    let mut pc: u32 = 0x828D78D0;
    'dispatch: loop {
        match pc {
            0x828D78D0 => {
    //   block [0x828D78D0..0x828D7A14)
	// 828D78D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D78D4: 488D0891  bl 0x831a8164
	ctx.lr = 0x828D78D8;
	sub_831A8130(ctx, base);
	// 828D78D8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D78DC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828D78E0: 4887CD21  bl 0x83154600
	ctx.lr = 0x828D78E4;
	sub_83154600(ctx, base);
	// 828D78E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D78E8: 4BFE1401  bl 0x828b8ce8
	ctx.lr = 0x828D78EC;
	sub_828B8CE8(ctx, base);
	// 828D78EC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D78F0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D78F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D78F8: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828D78FC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D7900: 4E800421  bctrl
	ctx.lr = 0x828D7904;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D7904: 3FA0832C  lis r29, -0x7cd4
	ctx.r[29].s64 = -2094268416;
	// 828D7908: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828D790C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D7910: 809D6040  lwz r4, 0x6040(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24640 as u32) ) } as u64;
	// 828D7914: 4851C0F5  bl 0x82df3a08
	ctx.lr = 0x828D7918;
	sub_82DF3A08(ctx, base);
	// 828D7918: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828D791C: 3B610050  addi r27, r1, 0x50
	ctx.r[27].s64 = ctx.r[1].s64 + 80;
	// 828D7920: 4BF12989  bl 0x827ea2a8
	ctx.lr = 0x828D7924;
	sub_827EA2A8(ctx, base);
	// 828D7924: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828D7928: 4851B979  bl 0x82df32a0
	ctx.lr = 0x828D792C;
	sub_82DF32A0(ctx, base);
	// 828D792C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828D7930: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D7934: 4851BAF5  bl 0x82df3428
	ctx.lr = 0x828D7938;
	sub_82DF3428(ctx, base);
	// 828D7938: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D793C: 41820030  beq 0x828d796c
	if ctx.cr[0].eq {
	pc = 0x828D796C; continue 'dispatch;
	}
	// 828D7940: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D7944: 809D6040  lwz r4, 0x6040(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24640 as u32) ) } as u64;
	// 828D7948: 4851C0C1  bl 0x82df3a08
	ctx.lr = 0x828D794C;
	sub_82DF3A08(ctx, base);
	// 828D794C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D7950: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D7954: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D7958: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828D795C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D7960: 4E800421  bctrl
	ctx.lr = 0x828D7964;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D7964: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D7968: 4851BAC1  bl 0x82df3428
	ctx.lr = 0x828D796C;
	sub_82DF3428(ctx, base);
	// 828D796C: 4BFF7075  bl 0x828ce9e0
	ctx.lr = 0x828D7970;
	sub_828CE9E0(ctx, base);
	// 828D7970: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828D7974: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828D7978: 3BFE0010  addi r31, r30, 0x10
	ctx.r[31].s64 = ctx.r[30].s64 + 16;
	// 828D797C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D7980: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D7984: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828D7988: 816A0080  lwz r11, 0x80(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(128 as u32) ) } as u64;
	// 828D798C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D7990: 4E800421  bctrl
	ctx.lr = 0x828D7994;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D7994: C01D0020  lfs f0, 0x20(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D7998: C1BD001C  lfs f13, 0x1c(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828D799C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D79A0: EC01683A  fmadds f0, f1, f0, f13
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 828D79A4: D01C0060  stfs f0, 0x60(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828D79A8: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828D79AC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828D79B0: 816B00D0  lwz r11, 0xd0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(208 as u32) ) } as u64;
	// 828D79B4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D79B8: 4E800421  bctrl
	ctx.lr = 0x828D79BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D79BC: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828D79C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D79C4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828D79C8: 816B00D4  lwz r11, 0xd4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(212 as u32) ) } as u64;
	// 828D79CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D79D0: 4E800421  bctrl
	ctx.lr = 0x828D79D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D79D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D79D8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828D79DC: 48038D6D  bl 0x82910748
	ctx.lr = 0x828D79E0;
	sub_82910748(ctx, base);
	// 828D79E0: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828D79E4: 38A00005  li r5, 5
	ctx.r[5].s64 = 5;
	// 828D79E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D79EC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D79F0: 816B0188  lwz r11, 0x188(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(392 as u32) ) } as u64;
	// 828D79F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D79F8: 4E800421  bctrl
	ctx.lr = 0x828D79FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D79FC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828D7A00: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D7A04: 419A0008  beq cr6, 0x828d7a0c
	if ctx.cr[6].eq {
	pc = 0x828D7A0C; continue 'dispatch;
	}
	// 828D7A08: 4B9E8E89  bl 0x822c0890
	ctx.lr = 0x828D7A0C;
	sub_822C0890(ctx, base);
	// 828D7A0C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828D7A10: 488D07A4  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D7A18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D7A18 size=112
    let mut pc: u32 = 0x828D7A18;
    'dispatch: loop {
        match pc {
            0x828D7A18 => {
    //   block [0x828D7A18..0x828D7A88)
	// 828D7A18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D7A1C: 488D0751  bl 0x831a816c
	ctx.lr = 0x828D7A20;
	sub_831A8130(ctx, base);
	// 828D7A20: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D7A24: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D7A28: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D7A2C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D7A30: 388BF5F8  addi r4, r11, -0xa08
	ctx.r[4].s64 = ctx.r[11].s64 + -2568;
	// 828D7A34: 38A00062  li r5, 0x62
	ctx.r[5].s64 = 98;
	// 828D7A38: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 828D7A3C: 4851A9AD  bl 0x82df23e8
	ctx.lr = 0x828D7A40;
	sub_82DF23E8(ctx, base);
	// 828D7A40: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828D7A44: 41820010  beq 0x828d7a54
	if ctx.cr[0].eq {
	pc = 0x828D7A54; continue 'dispatch;
	}
	// 828D7A48: 4BFFF579  bl 0x828d6fc0
	ctx.lr = 0x828D7A4C;
	sub_828D6FC0(ctx, base);
	// 828D7A4C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D7A50: 48000008  b 0x828d7a58
	pc = 0x828D7A58; continue 'dispatch;
	// 828D7A54: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828D7A58: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828D7A5C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828D7A60: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D7A64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D7A68: 4BFFF989  bl 0x828d73f0
	ctx.lr = 0x828D7A6C;
	sub_828D73F0(ctx, base);
	// 828D7A6C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D7A70: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D7A74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D7A78: 4B9E8589  bl 0x822c0000
	ctx.lr = 0x828D7A7C;
	sub_822C0000(ctx, base);
	// 828D7A7C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D7A80: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D7A84: 488D0738  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D7A88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D7A88 size=112
    let mut pc: u32 = 0x828D7A88;
    'dispatch: loop {
        match pc {
            0x828D7A88 => {
    //   block [0x828D7A88..0x828D7AF8)
	// 828D7A88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D7A8C: 488D06E1  bl 0x831a816c
	ctx.lr = 0x828D7A90;
	sub_831A8130(ctx, base);
	// 828D7A90: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D7A94: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D7A98: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D7A9C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D7AA0: 388BF5F8  addi r4, r11, -0xa08
	ctx.r[4].s64 = ctx.r[11].s64 + -2568;
	// 828D7AA4: 38A000BA  li r5, 0xba
	ctx.r[5].s64 = 186;
	// 828D7AA8: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 828D7AAC: 4851A93D  bl 0x82df23e8
	ctx.lr = 0x828D7AB0;
	sub_82DF23E8(ctx, base);
	// 828D7AB0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828D7AB4: 41820010  beq 0x828d7ac4
	if ctx.cr[0].eq {
	pc = 0x828D7AC4; continue 'dispatch;
	}
	// 828D7AB8: 4BFFF219  bl 0x828d6cd0
	ctx.lr = 0x828D7ABC;
	sub_828D6CD0(ctx, base);
	// 828D7ABC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D7AC0: 48000008  b 0x828d7ac8
	pc = 0x828D7AC8; continue 'dispatch;
	// 828D7AC4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828D7AC8: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828D7ACC: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828D7AD0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D7AD4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D7AD8: 4BFFF9E1  bl 0x828d74b8
	ctx.lr = 0x828D7ADC;
	sub_828D74B8(ctx, base);
	// 828D7ADC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D7AE0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D7AE4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D7AE8: 4B9E8519  bl 0x822c0000
	ctx.lr = 0x828D7AEC;
	sub_822C0000(ctx, base);
	// 828D7AEC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D7AF0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D7AF4: 488D06C8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D7AF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D7AF8 size=112
    let mut pc: u32 = 0x828D7AF8;
    'dispatch: loop {
        match pc {
            0x828D7AF8 => {
    //   block [0x828D7AF8..0x828D7B68)
	// 828D7AF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D7AFC: 488D0671  bl 0x831a816c
	ctx.lr = 0x828D7B00;
	sub_831A8130(ctx, base);
	// 828D7B00: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D7B04: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D7B08: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D7B0C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D7B10: 388BF5F8  addi r4, r11, -0xa08
	ctx.r[4].s64 = ctx.r[11].s64 + -2568;
	// 828D7B14: 38A00109  li r5, 0x109
	ctx.r[5].s64 = 265;
	// 828D7B18: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 828D7B1C: 4851A8CD  bl 0x82df23e8
	ctx.lr = 0x828D7B20;
	sub_82DF23E8(ctx, base);
	// 828D7B20: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828D7B24: 41820010  beq 0x828d7b34
	if ctx.cr[0].eq {
	pc = 0x828D7B34; continue 'dispatch;
	}
	// 828D7B28: 4BFFF659  bl 0x828d7180
	ctx.lr = 0x828D7B2C;
	sub_828D7180(ctx, base);
	// 828D7B2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D7B30: 48000008  b 0x828d7b38
	pc = 0x828D7B38; continue 'dispatch;
	// 828D7B34: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828D7B38: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828D7B3C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828D7B40: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D7B44: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D7B48: 4BFFFA39  bl 0x828d7580
	ctx.lr = 0x828D7B4C;
	sub_828D7580(ctx, base);
	// 828D7B4C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D7B50: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D7B54: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D7B58: 4B9E84A9  bl 0x822c0000
	ctx.lr = 0x828D7B5C;
	sub_822C0000(ctx, base);
	// 828D7B5C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D7B60: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D7B64: 488D0658  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D7B68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D7B68 size=112
    let mut pc: u32 = 0x828D7B68;
    'dispatch: loop {
        match pc {
            0x828D7B68 => {
    //   block [0x828D7B68..0x828D7BD8)
	// 828D7B68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D7B6C: 488D0601  bl 0x831a816c
	ctx.lr = 0x828D7B70;
	sub_831A8130(ctx, base);
	// 828D7B70: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D7B74: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D7B78: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D7B7C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D7B80: 388BF5F8  addi r4, r11, -0xa08
	ctx.r[4].s64 = ctx.r[11].s64 + -2568;
	// 828D7B84: 38A00152  li r5, 0x152
	ctx.r[5].s64 = 338;
	// 828D7B88: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 828D7B8C: 4851A85D  bl 0x82df23e8
	ctx.lr = 0x828D7B90;
	sub_82DF23E8(ctx, base);
	// 828D7B90: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828D7B94: 41820010  beq 0x828d7ba4
	if ctx.cr[0].eq {
	pc = 0x828D7BA4; continue 'dispatch;
	}
	// 828D7B98: 4BFFF201  bl 0x828d6d98
	ctx.lr = 0x828D7B9C;
	sub_828D6D98(ctx, base);
	// 828D7B9C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D7BA0: 48000008  b 0x828d7ba8
	pc = 0x828D7BA8; continue 'dispatch;
	// 828D7BA4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828D7BA8: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828D7BAC: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828D7BB0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D7BB4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D7BB8: 4BFFFA91  bl 0x828d7648
	ctx.lr = 0x828D7BBC;
	sub_828D7648(ctx, base);
	// 828D7BBC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D7BC0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D7BC4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D7BC8: 4B9E8439  bl 0x822c0000
	ctx.lr = 0x828D7BCC;
	sub_822C0000(ctx, base);
	// 828D7BCC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D7BD0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D7BD4: 488D05E8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D7BD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D7BD8 size=112
    let mut pc: u32 = 0x828D7BD8;
    'dispatch: loop {
        match pc {
            0x828D7BD8 => {
    //   block [0x828D7BD8..0x828D7C48)
	// 828D7BD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D7BDC: 488D0591  bl 0x831a816c
	ctx.lr = 0x828D7BE0;
	sub_831A8130(ctx, base);
	// 828D7BE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D7BE4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D7BE8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D7BEC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D7BF0: 388BF5F8  addi r4, r11, -0xa08
	ctx.r[4].s64 = ctx.r[11].s64 + -2568;
	// 828D7BF4: 38A00183  li r5, 0x183
	ctx.r[5].s64 = 387;
	// 828D7BF8: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 828D7BFC: 4851A7ED  bl 0x82df23e8
	ctx.lr = 0x828D7C00;
	sub_82DF23E8(ctx, base);
	// 828D7C00: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828D7C04: 41820010  beq 0x828d7c14
	if ctx.cr[0].eq {
	pc = 0x828D7C14; continue 'dispatch;
	}
	// 828D7C08: 4BFFF2A9  bl 0x828d6eb0
	ctx.lr = 0x828D7C0C;
	sub_828D6EB0(ctx, base);
	// 828D7C0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D7C10: 48000008  b 0x828d7c18
	pc = 0x828D7C18; continue 'dispatch;
	// 828D7C14: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828D7C18: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828D7C1C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828D7C20: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D7C24: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D7C28: 4BFFFAE9  bl 0x828d7710
	ctx.lr = 0x828D7C2C;
	sub_828D7710(ctx, base);
	// 828D7C2C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D7C30: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D7C34: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D7C38: 4B9E83C9  bl 0x822c0000
	ctx.lr = 0x828D7C3C;
	sub_822C0000(ctx, base);
	// 828D7C3C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D7C40: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D7C44: 488D0578  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D7C48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828D7C48 size=28
    let mut pc: u32 = 0x828D7C48;
    'dispatch: loop {
        match pc {
            0x828D7C48 => {
    //   block [0x828D7C48..0x828D7C64)
	// 828D7C48: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828D7C4C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 828D7C50: C00B6150  lfs f0, 0x6150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D7C54: C1AAC664  lfs f13, -0x399c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-14748 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828D7C58: D0040000  stfs f0, 0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 828D7C5C: D1A50000  stfs f13, 0(r5)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 828D7C60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D7C68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D7C68 size=72
    let mut pc: u32 = 0x828D7C68;
    'dispatch: loop {
        match pc {
            0x828D7C68 => {
    //   block [0x828D7C68..0x828D7CB0)
	// 828D7C68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D7C6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D7C70: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D7C74: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D7C78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D7C7C: 4805EBE5  bl 0x82936860
	ctx.lr = 0x828D7C80;
	sub_82936860(ctx, base);
	// 828D7C80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D7C84: 4887C97D  bl 0x83154600
	ctx.lr = 0x828D7C88;
	sub_83154600(ctx, base);
	// 828D7C88: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D7C8C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828D7C90: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D7C94: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D7C98: 4E800421  bctrl
	ctx.lr = 0x828D7C9C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D7C9C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828D7CA0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D7CA4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D7CA8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D7CAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D7CB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D7CB0 size=100
    let mut pc: u32 = 0x828D7CB0;
    'dispatch: loop {
        match pc {
            0x828D7CB0 => {
    //   block [0x828D7CB0..0x828D7D14)
	// 828D7CB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D7CB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D7CB8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828D7CBC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D7CC0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D7CC4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D7CC8: 4805EAC9  bl 0x82936790
	ctx.lr = 0x828D7CCC;
	sub_82936790(ctx, base);
	// 828D7CCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D7CD0: 4887C931  bl 0x83154600
	ctx.lr = 0x828D7CD4;
	sub_83154600(ctx, base);
	// 828D7CD4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D7CD8: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D7CDC: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 828D7CE0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D7CE4: 4E800421  bctrl
	ctx.lr = 0x828D7CE8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D7CE8: 88830010  lbz r4, 0x10(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 828D7CEC: 817E0048  lwz r11, 0x48(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D7CF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D7CF4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D7CF8: 4E800421  bctrl
	ctx.lr = 0x828D7CFC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D7CFC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D7D00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D7D04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D7D08: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828D7D0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D7D10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D7D18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828D7D18 size=60
    let mut pc: u32 = 0x828D7D18;
    'dispatch: loop {
        match pc {
            0x828D7D18 => {
    //   block [0x828D7D18..0x828D7D54)
	// 828D7D18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D7D1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D7D20: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D7D24: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 828D7D28: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 828D7D2C: C00BDFAC  lfs f0, -0x2054(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D7D30: EDA00072  fmuls f13, f0, f1
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 828D7D34: C00A9450  lfs f0, -0x6bb0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D7D38: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 828D7D3C: 488D108D  bl 0x831a8dc8
	ctx.lr = 0x828D7D40;
	sub_831A8DC8(ctx, base);
	// 828D7D40: FC200818  frsp f1, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = (ctx.f[1].f64 as f32) as f64;
	// 828D7D44: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828D7D48: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D7D4C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D7D50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D7D58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D7D58 size=196
    let mut pc: u32 = 0x828D7D58;
    'dispatch: loop {
        match pc {
            0x828D7D58 => {
    //   block [0x828D7D58..0x828D7E1C)
	// 828D7D58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D7D5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D7D60: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828D7D64: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D7D68: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D7D6C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D7D70: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D7D74: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828D7D78: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828D7D7C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D7D80: 4B9E8BB9  bl 0x822c0938
	ctx.lr = 0x828D7D84;
	sub_822C0938(ctx, base);
	// 828D7D84: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828D7D88: 41820028  beq 0x828d7db0
	if ctx.cr[0].eq {
	pc = 0x828D7DB0; continue 'dispatch;
	}
	// 828D7D8C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D7D90: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828D7D94: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D7D98: 392BF670  addi r9, r11, -0x990
	ctx.r[9].s64 = ctx.r[11].s64 + -2448;
	// 828D7D9C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828D7DA0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828D7DA4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828D7DA8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828D7DAC: 48000008  b 0x828d7db4
	pc = 0x828D7DB4; continue 'dispatch;
	// 828D7DB0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D7DB4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D7DB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D7DBC: 409A0044  bne cr6, 0x828d7e00
	if !ctx.cr[6].eq {
	pc = 0x828D7E00; continue 'dispatch;
	}
	// 828D7DC0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828D7DC4: 419A001C  beq cr6, 0x828d7de0
	if ctx.cr[6].eq {
	pc = 0x828D7DE0; continue 'dispatch;
	}
	// 828D7DC8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D7DCC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828D7DD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D7DD4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D7DD8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D7DDC: 4E800421  bctrl
	ctx.lr = 0x828D7DE0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D7DE0: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D7DE4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828D7DE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D7DEC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828D7DF0: 816B6998  lwz r11, 0x6998(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27032 as u32) ) } as u64;
	// 828D7DF4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828D7DF8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828D7DFC: 4B9E8205  bl 0x822c0000
	ctx.lr = 0x828D7E00;
	sub_822C0000(ctx, base);
	// 828D7E00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D7E04: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D7E08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D7E0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D7E10: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828D7E14: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D7E18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D7E20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D7E20 size=124
    let mut pc: u32 = 0x828D7E20;
    'dispatch: loop {
        match pc {
            0x828D7E20 => {
    //   block [0x828D7E20..0x828D7E9C)
	// 828D7E20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D7E24: 488D0349  bl 0x831a816c
	ctx.lr = 0x828D7E28;
	sub_831A8130(ctx, base);
	// 828D7E28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D7E2C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D7E30: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D7E34: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D7E38: 388BF6B0  addi r4, r11, -0x950
	ctx.r[4].s64 = ctx.r[11].s64 + -2384;
	// 828D7E3C: 38A0003E  li r5, 0x3e
	ctx.r[5].s64 = 62;
	// 828D7E40: 38600080  li r3, 0x80
	ctx.r[3].s64 = 128;
	// 828D7E44: 4851A5A5  bl 0x82df23e8
	ctx.lr = 0x828D7E48;
	sub_82DF23E8(ctx, base);
	// 828D7E48: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 828D7E4C: 4182001C  beq 0x828d7e68
	if ctx.cr[0].eq {
	pc = 0x828D7E68; continue 'dispatch;
	}
	// 828D7E50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D7E54: 4805E98D  bl 0x829367e0
	ctx.lr = 0x828D7E58;
	sub_829367E0(ctx, base);
	// 828D7E58: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D7E5C: 396BF684  addi r11, r11, -0x97c
	ctx.r[11].s64 = ctx.r[11].s64 + -2428;
	// 828D7E60: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D7E64: 48000008  b 0x828d7e6c
	pc = 0x828D7E6C; continue 'dispatch;
	// 828D7E68: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828D7E6C: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828D7E70: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828D7E74: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D7E78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D7E7C: 4BFFFEDD  bl 0x828d7d58
	ctx.lr = 0x828D7E80;
	sub_828D7D58(ctx, base);
	// 828D7E80: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D7E84: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D7E88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D7E8C: 4B9E8175  bl 0x822c0000
	ctx.lr = 0x828D7E90;
	sub_822C0000(ctx, base);
	// 828D7E90: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D7E94: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D7E98: 488D0324  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D7EA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828D7EA0 size=148
    let mut pc: u32 = 0x828D7EA0;
    'dispatch: loop {
        match pc {
            0x828D7EA0 => {
    //   block [0x828D7EA0..0x828D7F34)
	// 828D7EA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D7EA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D7EA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828D7EAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D7EB0: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 828D7EB4: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D7EB8: 4887C749  bl 0x83154600
	ctx.lr = 0x828D7EBC;
	sub_83154600(ctx, base);
	// 828D7EBC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D7EC0: 4803E8A9  bl 0x82916768
	ctx.lr = 0x828D7EC4;
	sub_82916768(ctx, base);
	// 828D7EC4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828D7EC8: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 828D7ECC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D7ED0: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828D7ED4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828D7ED8: 48036EA1  bl 0x8290ed78
	ctx.lr = 0x828D7EDC;
	sub_8290ED78(ctx, base);
	// 828D7EDC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828D7EE0: D3E1005C  stfs f31, 0x5c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 828D7EE4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D7EE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D7EEC: C00B08A8  lfs f0, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D7EF0: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 828D7EF4: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 828D7EF8: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 828D7EFC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D7F00: 816B005C  lwz r11, 0x5c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 828D7F04: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D7F08: 4E800421  bctrl
	ctx.lr = 0x828D7F0C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D7F0C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D7F10: 48031679  bl 0x82909588
	ctx.lr = 0x828D7F14;
	sub_82909588(ctx, base);
	// 828D7F14: 48068595  bl 0x829404a8
	ctx.lr = 0x828D7F18;
	sub_829404A8(ctx, base);
	// 828D7F18: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828D7F1C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D7F20: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D7F24: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 828D7F28: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828D7F2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D7F30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D7F38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D7F38 size=196
    let mut pc: u32 = 0x828D7F38;
    'dispatch: loop {
        match pc {
            0x828D7F38 => {
    //   block [0x828D7F38..0x828D7FFC)
	// 828D7F38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D7F3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D7F40: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828D7F44: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D7F48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D7F4C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D7F50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D7F54: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828D7F58: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828D7F5C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D7F60: 4B9E89D9  bl 0x822c0938
	ctx.lr = 0x828D7F64;
	sub_822C0938(ctx, base);
	// 828D7F64: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828D7F68: 41820028  beq 0x828d7f90
	if ctx.cr[0].eq {
	pc = 0x828D7F90; continue 'dispatch;
	}
	// 828D7F6C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D7F70: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828D7F74: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D7F78: 392BF72C  addi r9, r11, -0x8d4
	ctx.r[9].s64 = ctx.r[11].s64 + -2260;
	// 828D7F7C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828D7F80: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828D7F84: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828D7F88: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828D7F8C: 48000008  b 0x828d7f94
	pc = 0x828D7F94; continue 'dispatch;
	// 828D7F90: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D7F94: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D7F98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D7F9C: 409A0044  bne cr6, 0x828d7fe0
	if !ctx.cr[6].eq {
	pc = 0x828D7FE0; continue 'dispatch;
	}
	// 828D7FA0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828D7FA4: 419A001C  beq cr6, 0x828d7fc0
	if ctx.cr[6].eq {
	pc = 0x828D7FC0; continue 'dispatch;
	}
	// 828D7FA8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D7FAC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828D7FB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D7FB4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D7FB8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D7FBC: 4E800421  bctrl
	ctx.lr = 0x828D7FC0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D7FC0: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D7FC4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828D7FC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D7FCC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828D7FD0: 816B6A24  lwz r11, 0x6a24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27172 as u32) ) } as u64;
	// 828D7FD4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828D7FD8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828D7FDC: 4B9E8025  bl 0x822c0000
	ctx.lr = 0x828D7FE0;
	sub_822C0000(ctx, base);
	// 828D7FE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D7FE4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D7FE8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D7FEC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D7FF0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828D7FF4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D7FF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D8000(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D8000 size=196
    let mut pc: u32 = 0x828D8000;
    'dispatch: loop {
        match pc {
            0x828D8000 => {
    //   block [0x828D8000..0x828D80C4)
	// 828D8000: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D8004: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D8008: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828D800C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D8010: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D8014: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D8018: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D801C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828D8020: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828D8024: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D8028: 4B9E8911  bl 0x822c0938
	ctx.lr = 0x828D802C;
	sub_822C0938(ctx, base);
	// 828D802C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828D8030: 41820028  beq 0x828d8058
	if ctx.cr[0].eq {
	pc = 0x828D8058; continue 'dispatch;
	}
	// 828D8034: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D8038: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828D803C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D8040: 392BF740  addi r9, r11, -0x8c0
	ctx.r[9].s64 = ctx.r[11].s64 + -2240;
	// 828D8044: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828D8048: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828D804C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828D8050: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828D8054: 48000008  b 0x828d805c
	pc = 0x828D805C; continue 'dispatch;
	// 828D8058: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D805C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D8060: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D8064: 409A0044  bne cr6, 0x828d80a8
	if !ctx.cr[6].eq {
	pc = 0x828D80A8; continue 'dispatch;
	}
	// 828D8068: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828D806C: 419A001C  beq cr6, 0x828d8088
	if ctx.cr[6].eq {
	pc = 0x828D8088; continue 'dispatch;
	}
	// 828D8070: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D8074: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828D8078: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D807C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D8080: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D8084: 4E800421  bctrl
	ctx.lr = 0x828D8088;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D8088: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D808C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828D8090: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D8094: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828D8098: 816B6A24  lwz r11, 0x6a24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27172 as u32) ) } as u64;
	// 828D809C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828D80A0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828D80A4: 4B9E7F5D  bl 0x822c0000
	ctx.lr = 0x828D80A8;
	sub_822C0000(ctx, base);
	// 828D80A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D80AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D80B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D80B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D80B8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828D80BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D80C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D80C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D80C8 size=108
    let mut pc: u32 = 0x828D80C8;
    'dispatch: loop {
        match pc {
            0x828D80C8 => {
    //   block [0x828D80C8..0x828D8134)
	// 828D80C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D80CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D80D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D80D4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D80D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D80DC: 4BFFBE8D  bl 0x828d3f68
	ctx.lr = 0x828D80E0;
	sub_828D3F68(ctx, base);
	// 828D80E0: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828D80E4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D80E8: 394AF754  addi r10, r10, -0x8ac
	ctx.r[10].s64 = ctx.r[10].s64 + -2220;
	// 828D80EC: 3D20832D  lis r9, -0x7cd3
	ctx.r[9].s64 = -2094202880;
	// 828D80F0: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828D80F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D80F8: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828D80FC: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 828D8100: 80890B24  lwz r4, 0xb24(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2852 as u32) ) } as u64;
	// 828D8104: 4851B905  bl 0x82df3a08
	ctx.lr = 0x828D8108;
	sub_82DF3A08(ctx, base);
	// 828D8108: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D810C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D8110: 485815D9  bl 0x82e596e8
	ctx.lr = 0x828D8114;
	sub_82E596E8(ctx, base);
	// 828D8114: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D8118: 4851B311  bl 0x82df3428
	ctx.lr = 0x828D811C;
	sub_82DF3428(ctx, base);
	// 828D811C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D8120: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D8124: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D8128: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D812C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D8130: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D8138(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828D8138 size=1028
    let mut pc: u32 = 0x828D8138;
    'dispatch: loop {
        match pc {
            0x828D8138 => {
    //   block [0x828D8138..0x828D853C)
	// 828D8138: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D813C: 488D0021  bl 0x831a815c
	ctx.lr = 0x828D8140;
	sub_831A8130(ctx, base);
	// 828D8140: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 828D8144: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D8148: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D814C: 4887C4B5  bl 0x83154600
	ctx.lr = 0x828D8150;
	sub_83154600(ctx, base);
	// 828D8150: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D8154: 4BFE0B95  bl 0x828b8ce8
	ctx.lr = 0x828D8158;
	sub_828B8CE8(ctx, base);
	// 828D8158: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D815C: 4BFF6885  bl 0x828ce9e0
	ctx.lr = 0x828D8160;
	sub_828CE9E0(ctx, base);
	// 828D8160: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D8164: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 828D8168: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D816C: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D8170: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D8174: 4E800421  bctrl
	ctx.lr = 0x828D8178;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D8178: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828D817C: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 828D8180: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828D8184: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D8188: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 828D818C: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828D8190: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828D8194: 48036BE5  bl 0x8290ed78
	ctx.lr = 0x828D8198;
	sub_8290ED78(ctx, base);
	// 828D8198: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D819C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D81A0: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828D81A4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D81A8: 4E800421  bctrl
	ctx.lr = 0x828D81AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D81AC: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D81B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D81B4: 808B600C  lwz r4, 0x600c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24588 as u32) ) } as u64;
	// 828D81B8: 4851B851  bl 0x82df3a08
	ctx.lr = 0x828D81BC;
	sub_82DF3A08(ctx, base);
	// 828D81BC: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D81C0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D81C4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D81C8: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828D81CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D81D0: 4E800421  bctrl
	ctx.lr = 0x828D81D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D81D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D81D8: 4851B251  bl 0x82df3428
	ctx.lr = 0x828D81DC;
	sub_82DF3428(ctx, base);
	// 828D81DC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828D81E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D81E4: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828D81E8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D81EC: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828D81F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D81F4: 4E800421  bctrl
	ctx.lr = 0x828D81F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D81F8: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 828D81FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D8200: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828D8204: C00B7BC4  lfs f0, 0x7bc4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31684 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D8208: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 828D820C: D01E0060  stfs f0, 0x60(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828D8210: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D8214: 816B00D0  lwz r11, 0xd0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(208 as u32) ) } as u64;
	// 828D8218: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D821C: 4E800421  bctrl
	ctx.lr = 0x828D8220;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D8220: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D8224: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D8228: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828D822C: 816B00D4  lwz r11, 0xd4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(212 as u32) ) } as u64;
	// 828D8230: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D8234: 4E800421  bctrl
	ctx.lr = 0x828D8238;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D8238: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 828D823C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D8240: 933E0064  stw r25, 0x64(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(100 as u32), ctx.r[25].u32 ) };
	// 828D8244: 933E0068  stw r25, 0x68(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(104 as u32), ctx.r[25].u32 ) };
	// 828D8248: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D824C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D8250: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D8254: 4E800421  bctrl
	ctx.lr = 0x828D8258;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D8258: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D825C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D8260: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D8264: 480313F5  bl 0x82909658
	ctx.lr = 0x828D8268;
	sub_82909658(ctx, base);
	// 828D8268: 13C018C7  vcmpequd (lvx128) v30, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828D826C: 13E0E8C7  vcmpequd (lvx128) v31, v0, v29
	tmp.u32 = ctx.r[29].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828D8270: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D8540(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D8540 size=112
    let mut pc: u32 = 0x828D8540;
    'dispatch: loop {
        match pc {
            0x828D8540 => {
    //   block [0x828D8540..0x828D85B0)
	// 828D8540: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D8544: 488CFC29  bl 0x831a816c
	ctx.lr = 0x828D8548;
	sub_831A8130(ctx, base);
	// 828D8548: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D854C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D8550: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D8554: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D8558: 388BF778  addi r4, r11, -0x888
	ctx.r[4].s64 = ctx.r[11].s64 + -2184;
	// 828D855C: 38A00156  li r5, 0x156
	ctx.r[5].s64 = 342;
	// 828D8560: 38600070  li r3, 0x70
	ctx.r[3].s64 = 112;
	// 828D8564: 48519E85  bl 0x82df23e8
	ctx.lr = 0x828D8568;
	sub_82DF23E8(ctx, base);
	// 828D8568: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828D856C: 41820010  beq 0x828d857c
	if ctx.cr[0].eq {
	pc = 0x828D857C; continue 'dispatch;
	}
	// 828D8570: 4BFFFB59  bl 0x828d80c8
	ctx.lr = 0x828D8574;
	sub_828D80C8(ctx, base);
	// 828D8574: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D8578: 48000008  b 0x828d8580
	pc = 0x828D8580; continue 'dispatch;
	// 828D857C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828D8580: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828D8584: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828D8588: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D858C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D8590: 4BFFFA71  bl 0x828d8000
	ctx.lr = 0x828D8594;
	sub_828D8000(ctx, base);
	// 828D8594: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D8598: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D859C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D85A0: 4B9E7A61  bl 0x822c0000
	ctx.lr = 0x828D85A4;
	sub_822C0000(ctx, base);
	// 828D85A4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D85A8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D85AC: 488CFC10  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D85B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828D85B0 size=356
    let mut pc: u32 = 0x828D85B0;
    'dispatch: loop {
        match pc {
            0x828D85B0 => {
    //   block [0x828D85B0..0x828D8714)
	// 828D85B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D85B4: 488CFBB1  bl 0x831a8164
	ctx.lr = 0x828D85B8;
	sub_831A8130(ctx, base);
	// 828D85B8: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 828D85BC: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D85C0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D85C4: 4887C03D  bl 0x83154600
	ctx.lr = 0x828D85C8;
	sub_83154600(ctx, base);
	// 828D85C8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D85CC: 4BFE071D  bl 0x828b8ce8
	ctx.lr = 0x828D85D0;
	sub_828B8CE8(ctx, base);
	// 828D85D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D85D4: 4BFF640D  bl 0x828ce9e0
	ctx.lr = 0x828D85D8;
	sub_828CE9E0(ctx, base);
	// 828D85D8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828D85DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D85E0: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 828D85E4: 48581195  bl 0x82e59778
	ctx.lr = 0x828D85E8;
	sub_82E59778(ctx, base);
	// 828D85E8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D85EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D85F0: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 828D85F4: 816B006C  lwz r11, 0x6c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 828D85F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D85FC: 4E800421  bctrl
	ctx.lr = 0x828D8600;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D8600: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D8604: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D8608: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828D860C: 48067625  bl 0x8293fc30
	ctx.lr = 0x828D8610;
	sub_8293FC30(ctx, base);
	// 828D8610: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D8614: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D8618: 48031041  bl 0x82909658
	ctx.lr = 0x828D861C;
	sub_82909658(ctx, base);
	// 828D861C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D8620: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828D8624: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D8628: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D862C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D8630: 4E800421  bctrl
	ctx.lr = 0x828D8634;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D8634: 13C018C7  vcmpequd (lvx128) v30, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828D8638: 13E0D8C7  vcmpequd (lvx128) v31, v0, v27
	tmp.u32 = ctx.r[27].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828D863C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D8718(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828D8718 size=1160
    let mut pc: u32 = 0x828D8718;
    'dispatch: loop {
        match pc {
            0x828D8718 => {
    //   block [0x828D8718..0x828D8BA0)
	// 828D8718: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D871C: 488CFA49  bl 0x831a8164
	ctx.lr = 0x828D8720;
	sub_831A8130(ctx, base);
	// 828D8720: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D8724: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D8728: 4887BED9  bl 0x83154600
	ctx.lr = 0x828D872C;
	sub_83154600(ctx, base);
	// 828D872C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D8730: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D8734: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828D8738: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D873C: 4E800421  bctrl
	ctx.lr = 0x828D8740;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D8740: 817D0068  lwz r11, 0x68(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(104 as u32) ) } as u64;
	// 828D8744: 3BDD0068  addi r30, r29, 0x68
	ctx.r[30].s64 = ctx.r[29].s64 + 104;
	// 828D8748: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D874C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828D8750: 41820010  beq 0x828d8760
	if ctx.cr[0].eq {
	pc = 0x828D8760; continue 'dispatch;
	}
	// 828D8754: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D8758: 917D0064  stw r11, 0x64(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828D875C: 480003E4  b 0x828d8b40
	pc = 0x828D8B40; continue 'dispatch;
	// 828D8760: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D8764: 4BFE0585  bl 0x828b8ce8
	ctx.lr = 0x828D8768;
	sub_828B8CE8(ctx, base);
	// 828D8768: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D876C: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828D8770: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D8774: 4E800421  bctrl
	ctx.lr = 0x828D8778;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D8778: 817D0064  lwz r11, 0x64(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(100 as u32) ) } as u64;
	// 828D877C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828D8780: 556AD7FF  rlwinm. r10, r11, 0x1a, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828D8784: 41820084  beq 0x828d8808
	if ctx.cr[0].eq {
	pc = 0x828D8808; continue 'dispatch;
	}
	// 828D8788: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828D878C: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 828D8790: 556B06B0  rlwinm r11, r11, 0, 0x1a, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828D8794: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D8798: 917D0064  stw r11, 0x64(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828D879C: 808A6010  lwz r4, 0x6010(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24592 as u32) ) } as u64;
	// 828D87A0: 4851B269  bl 0x82df3a08
	ctx.lr = 0x828D87A4;
	sub_82DF3A08(ctx, base);
	// 828D87A4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D87A8: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828D87AC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D87B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D87B4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D87B8: 4E800421  bctrl
	ctx.lr = 0x828D87BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D87BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D87C0: 4851AC69  bl 0x82df3428
	ctx.lr = 0x828D87C4;
	sub_82DF3428(ctx, base);
	// 828D87C4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828D87C8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828D87CC: C19C0088  lfs f12, 0x88(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(136 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828D87D0: D18100A0  stfs f12, 0xa0(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 828D87D4: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 828D87D8: D18100A8  stfs f12, 0xa8(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 828D87DC: C00B08A8  lfs f0, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D87E0: C1AA08A4  lfs f13, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828D87E4: D00100A4  stfs f0, 0xa4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 828D87E8: D1A100AC  stfs f13, 0xac(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 828D87EC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D87F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D87F4: 816B005C  lwz r11, 0x5c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 828D87F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D87FC: 4E800421  bctrl
	ctx.lr = 0x828D8800;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D8800: C03C008C  lfs f1, 0x8c(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(140 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828D8804: 48000328  b 0x828d8b2c
	pc = 0x828D8B2C; continue 'dispatch;
	// 828D8808: 556ADFFF  rlwinm. r10, r11, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828D880C: 4182006C  beq 0x828d8878
	if ctx.cr[0].eq {
	pc = 0x828D8878; continue 'dispatch;
	}
	// 828D8810: 817D0064  lwz r11, 0x64(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(100 as u32) ) } as u64;
	// 828D8814: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 828D8818: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D881C: 556B06F2  rlwinm r11, r11, 0, 0x1b, 0x19
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828D8820: 917D0064  stw r11, 0x64(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828D8824: 808A6018  lwz r4, 0x6018(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24600 as u32) ) } as u64;
	// 828D8828: 4851B1E1  bl 0x82df3a08
	ctx.lr = 0x828D882C;
	sub_82DF3A08(ctx, base);
	// 828D882C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D8830: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D8834: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D8838: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828D883C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D8840: 4E800421  bctrl
	ctx.lr = 0x828D8844;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D8844: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D8848: 4851ABE1  bl 0x82df3428
	ctx.lr = 0x828D884C;
	sub_82DF3428(ctx, base);
	// 828D884C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828D8850: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828D8854: C19C0088  lfs f12, 0x88(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(136 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828D8858: D1810080  stfs f12, 0x80(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 828D885C: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 828D8860: D1810088  stfs f12, 0x88(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 828D8864: C00B08A8  lfs f0, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D8868: C1AA08A4  lfs f13, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828D886C: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 828D8870: D1A1008C  stfs f13, 0x8c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 828D8874: 4BFFFF78  b 0x828d87ec
	pc = 0x828D87EC; continue 'dispatch;
	// 828D8878: 556AF7FF  rlwinm. r10, r11, 0x1e, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828D887C: 4182006C  beq 0x828d88e8
	if ctx.cr[0].eq {
	pc = 0x828D88E8; continue 'dispatch;
	}
	// 828D8880: 817D0064  lwz r11, 0x64(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(100 as u32) ) } as u64;
	// 828D8884: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 828D8888: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D888C: 556B07B8  rlwinm r11, r11, 0, 0x1e, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828D8890: 917D0064  stw r11, 0x64(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828D8894: 808A6014  lwz r4, 0x6014(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24596 as u32) ) } as u64;
	// 828D8898: 4851B171  bl 0x82df3a08
	ctx.lr = 0x828D889C;
	sub_82DF3A08(ctx, base);
	// 828D889C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D88A0: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828D88A4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D88A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D88AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D88B0: 4E800421  bctrl
	ctx.lr = 0x828D88B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D88B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D88B8: 4851AB71  bl 0x82df3428
	ctx.lr = 0x828D88BC;
	sub_82DF3428(ctx, base);
	// 828D88BC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828D88C0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828D88C4: C19C0090  lfs f12, 0x90(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(144 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828D88C8: D18100C0  stfs f12, 0xc0(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 828D88CC: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 828D88D0: D18100C8  stfs f12, 0xc8(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 828D88D4: C00B08A8  lfs f0, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D88D8: C1AA08A4  lfs f13, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828D88DC: D00100C4  stfs f0, 0xc4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 828D88E0: D1A100CC  stfs f13, 0xcc(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 828D88E4: 48000230  b 0x828d8b14
	pc = 0x828D8B14; continue 'dispatch;
	// 828D88E8: 556AFFFF  rlwinm. r10, r11, 0x1f, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828D88EC: 4182006C  beq 0x828d8958
	if ctx.cr[0].eq {
	pc = 0x828D8958; continue 'dispatch;
	}
	// 828D88F0: 817D0064  lwz r11, 0x64(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(100 as u32) ) } as u64;
	// 828D88F4: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 828D88F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D88FC: 556B07FA  rlwinm r11, r11, 0, 0x1f, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828D8900: 917D0064  stw r11, 0x64(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828D8904: 808A601C  lwz r4, 0x601c(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24604 as u32) ) } as u64;
	// 828D8908: 4851B101  bl 0x82df3a08
	ctx.lr = 0x828D890C;
	sub_82DF3A08(ctx, base);
	// 828D890C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D8910: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D8914: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D8918: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828D891C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D8920: 4E800421  bctrl
	ctx.lr = 0x828D8924;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D8924: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D8928: 4851AB01  bl 0x82df3428
	ctx.lr = 0x828D892C;
	sub_82DF3428(ctx, base);
	// 828D892C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828D8930: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828D8934: C19C0090  lfs f12, 0x90(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(144 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828D8938: D1810060  stfs f12, 0x60(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828D893C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828D8940: D1810068  stfs f12, 0x68(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 828D8944: C00B08A8  lfs f0, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D8948: C1AA08A4  lfs f13, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828D894C: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 828D8950: D1A1006C  stfs f13, 0x6c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 828D8954: 480001C0  b 0x828d8b14
	pc = 0x828D8B14; continue 'dispatch;
	// 828D8958: 556AC7FF  rlwinm. r10, r11, 0x18, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828D895C: 4182006C  beq 0x828d89c8
	if ctx.cr[0].eq {
	pc = 0x828D89C8; continue 'dispatch;
	}
	// 828D8960: 817D0064  lwz r11, 0x64(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(100 as u32) ) } as u64;
	// 828D8964: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 828D8968: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D896C: 556B062C  rlwinm r11, r11, 0, 0x18, 0x16
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828D8970: 917D0064  stw r11, 0x64(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828D8974: 808A6020  lwz r4, 0x6020(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24608 as u32) ) } as u64;
	// 828D8978: 4851B091  bl 0x82df3a08
	ctx.lr = 0x828D897C;
	sub_82DF3A08(ctx, base);
	// 828D897C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D8980: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D8984: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D8988: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828D898C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D8990: 4E800421  bctrl
	ctx.lr = 0x828D8994;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D8994: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D8998: 4851AA91  bl 0x82df3428
	ctx.lr = 0x828D899C;
	sub_82DF3428(ctx, base);
	// 828D899C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828D89A0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828D89A4: C19C0088  lfs f12, 0x88(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(136 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828D89A8: D1810070  stfs f12, 0x70(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 828D89AC: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 828D89B0: D1810078  stfs f12, 0x78(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 828D89B4: C00B08A8  lfs f0, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D89B8: C1AA08A4  lfs f13, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828D89BC: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 828D89C0: D1A1007C  stfs f13, 0x7c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 828D89C4: 4BFFFE28  b 0x828d87ec
	pc = 0x828D87EC; continue 'dispatch;
	// 828D89C8: 556AE7FF  rlwinm. r10, r11, 0x1c, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828D89CC: 4182006C  beq 0x828d8a38
	if ctx.cr[0].eq {
	pc = 0x828D8A38; continue 'dispatch;
	}
	// 828D89D0: 817D0064  lwz r11, 0x64(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(100 as u32) ) } as u64;
	// 828D89D4: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 828D89D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D89DC: 556B0734  rlwinm r11, r11, 0, 0x1c, 0x1a
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828D89E0: 917D0064  stw r11, 0x64(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828D89E4: 808A6024  lwz r4, 0x6024(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24612 as u32) ) } as u64;
	// 828D89E8: 4851B021  bl 0x82df3a08
	ctx.lr = 0x828D89EC;
	sub_82DF3A08(ctx, base);
	// 828D89EC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D89F0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D89F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D89F8: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828D89FC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D8A00: 4E800421  bctrl
	ctx.lr = 0x828D8A04;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D8A04: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D8A08: 4851AA21  bl 0x82df3428
	ctx.lr = 0x828D8A0C;
	sub_82DF3428(ctx, base);
	// 828D8A0C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828D8A10: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828D8A14: C19C0090  lfs f12, 0x90(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(144 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828D8A18: D1810090  stfs f12, 0x90(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 828D8A1C: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 828D8A20: D1810098  stfs f12, 0x98(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 828D8A24: C00B08A8  lfs f0, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D8A28: C1AA08A4  lfs f13, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828D8A2C: D0010094  stfs f0, 0x94(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 828D8A30: D1A1009C  stfs f13, 0x9c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 828D8A34: 480000E0  b 0x828d8b14
	pc = 0x828D8B14; continue 'dispatch;
	// 828D8A38: 556ACFFF  rlwinm. r10, r11, 0x19, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000007Fu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828D8A3C: 4182006C  beq 0x828d8aa8
	if ctx.cr[0].eq {
	pc = 0x828D8AA8; continue 'dispatch;
	}
	// 828D8A40: 817D0064  lwz r11, 0x64(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(100 as u32) ) } as u64;
	// 828D8A44: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 828D8A48: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D8A4C: 556B066E  rlwinm r11, r11, 0, 0x19, 0x17
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828D8A50: 917D0064  stw r11, 0x64(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828D8A54: 808A6028  lwz r4, 0x6028(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24616 as u32) ) } as u64;
	// 828D8A58: 4851AFB1  bl 0x82df3a08
	ctx.lr = 0x828D8A5C;
	sub_82DF3A08(ctx, base);
	// 828D8A5C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D8A60: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D8A64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D8A68: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828D8A6C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D8A70: 4E800421  bctrl
	ctx.lr = 0x828D8A74;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D8A74: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D8A78: 4851A9B1  bl 0x82df3428
	ctx.lr = 0x828D8A7C;
	sub_82DF3428(ctx, base);
	// 828D8A7C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828D8A80: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828D8A84: C19C0088  lfs f12, 0x88(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(136 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828D8A88: D18100B0  stfs f12, 0xb0(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 828D8A8C: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 828D8A90: D18100B8  stfs f12, 0xb8(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 828D8A94: C00B08A8  lfs f0, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D8A98: C1AA08A4  lfs f13, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828D8A9C: D00100B4  stfs f0, 0xb4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 828D8AA0: D1A100BC  stfs f13, 0xbc(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 828D8AA4: 4BFFFD48  b 0x828d87ec
	pc = 0x828D87EC; continue 'dispatch;
	// 828D8AA8: 556BEFFF  rlwinm. r11, r11, 0x1d, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000007u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D8AAC: 41820094  beq 0x828d8b40
	if ctx.cr[0].eq {
	pc = 0x828D8B40; continue 'dispatch;
	}
	// 828D8AB0: 817D0064  lwz r11, 0x64(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(100 as u32) ) } as u64;
	// 828D8AB4: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 828D8AB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D8ABC: 556B0776  rlwinm r11, r11, 0, 0x1d, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828D8AC0: 917D0064  stw r11, 0x64(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828D8AC4: 808A602C  lwz r4, 0x602c(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24620 as u32) ) } as u64;
	// 828D8AC8: 4851AF41  bl 0x82df3a08
	ctx.lr = 0x828D8ACC;
	sub_82DF3A08(ctx, base);
	// 828D8ACC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D8AD0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D8AD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D8AD8: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828D8ADC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D8AE0: 4E800421  bctrl
	ctx.lr = 0x828D8AE4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D8AE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D8AE8: 4851A941  bl 0x82df3428
	ctx.lr = 0x828D8AEC;
	sub_82DF3428(ctx, base);
	// 828D8AEC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828D8AF0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828D8AF4: C19C0090  lfs f12, 0x90(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(144 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828D8AF8: D18100D0  stfs f12, 0xd0(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 828D8AFC: 388100D0  addi r4, r1, 0xd0
	ctx.r[4].s64 = ctx.r[1].s64 + 208;
	// 828D8B00: D18100D8  stfs f12, 0xd8(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 828D8B04: C00B08A8  lfs f0, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D8B08: C1AA08A4  lfs f13, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828D8B0C: D00100D4  stfs f0, 0xd4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 828D8B10: D1A100DC  stfs f13, 0xdc(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 828D8B14: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D8B18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D8B1C: 816B005C  lwz r11, 0x5c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 828D8B20: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D8B24: 4E800421  bctrl
	ctx.lr = 0x828D8B28;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D8B28: C03C0094  lfs f1, 0x94(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(148 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828D8B2C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828D8B30: 4BF11839  bl 0x827ea368
	ctx.lr = 0x828D8B34;
	sub_827EA368(ctx, base);
	// 828D8B34: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D8B38: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828D8B3C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D8B40: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D8B44: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D8B48: 41820050  beq 0x828d8b98
	if ctx.cr[0].eq {
	pc = 0x828D8B98; continue 'dispatch;
	}
	// 828D8B4C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828D8B50: 4BF117C1  bl 0x827ea310
	ctx.lr = 0x828D8B54;
	sub_827EA310(ctx, base);
	// 828D8B54: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D8B58: 41820040  beq 0x828d8b98
	if ctx.cr[0].eq {
	pc = 0x828D8B98; continue 'dispatch;
	}
	// 828D8B5C: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D8B60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D8B64: 808B600C  lwz r4, 0x600c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24588 as u32) ) } as u64;
	// 828D8B68: 4851AEA1  bl 0x82df3a08
	ctx.lr = 0x828D8B6C;
	sub_82DF3A08(ctx, base);
	// 828D8B6C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D8B70: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D8B74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D8B78: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828D8B7C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D8B80: 4E800421  bctrl
	ctx.lr = 0x828D8B84;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D8B84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D8B88: 4851A8A1  bl 0x82df3428
	ctx.lr = 0x828D8B8C;
	sub_82DF3428(ctx, base);
	// 828D8B8C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D8B90: 556B003C  rlwinm r11, r11, 0, 0, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828D8B94: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D8B98: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 828D8B9C: 488CF618  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D8BA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828D8BA0 size=316
    let mut pc: u32 = 0x828D8BA0;
    'dispatch: loop {
        match pc {
            0x828D8BA0 => {
    //   block [0x828D8BA0..0x828D8CDC)
	// 828D8BA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D8BA4: 488CF5C1  bl 0x831a8164
	ctx.lr = 0x828D8BA8;
	sub_831A8130(ctx, base);
	// 828D8BA8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D8BAC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D8BB0: 4887BA51  bl 0x83154600
	ctx.lr = 0x828D8BB4;
	sub_83154600(ctx, base);
	// 828D8BB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D8BB8: 4BFE0131  bl 0x828b8ce8
	ctx.lr = 0x828D8BBC;
	sub_828B8CE8(ctx, base);
	// 828D8BBC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D8BC0: 4BFF5E21  bl 0x828ce9e0
	ctx.lr = 0x828D8BC4;
	sub_828CE9E0(ctx, base);
	// 828D8BC4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D8BC8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828D8BCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D8BD0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D8BD4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D8BD8: 4E800421  bctrl
	ctx.lr = 0x828D8BDC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D8BDC: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 828D8BE0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828D8BE4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828D8BE8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828D8BEC: 48030A6D  bl 0x82909658
	ctx.lr = 0x828D8BF0;
	sub_82909658(ctx, base);
	// 828D8BF0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828D8BF4: 13E0D8C7  vcmpequd (lvx128) v31, v0, v27
	tmp.u32 = ctx.r[27].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828D8BF8: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 828D8BFC: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 828D8C00: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D8C04: 13C058C7  vcmpequd (lvx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D8CE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828D8CE0 size=108
    let mut pc: u32 = 0x828D8CE0;
    'dispatch: loop {
        match pc {
            0x828D8CE0 => {
    //   block [0x828D8CE0..0x828D8D4C)
	// 828D8CE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D8CE4: 488CF489  bl 0x831a816c
	ctx.lr = 0x828D8CE8;
	sub_831A8130(ctx, base);
	// 828D8CE8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D8CEC: 4887B915  bl 0x83154600
	ctx.lr = 0x828D8CF0;
	sub_83154600(ctx, base);
	// 828D8CF0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D8CF4: 4BFDFFF5  bl 0x828b8ce8
	ctx.lr = 0x828D8CF8;
	sub_828B8CE8(ctx, base);
	// 828D8CF8: 3BE30010  addi r31, r3, 0x10
	ctx.r[31].s64 = ctx.r[3].s64 + 16;
	// 828D8CFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D8D00: 48030889  bl 0x82909588
	ctx.lr = 0x828D8D04;
	sub_82909588(ctx, base);
	// 828D8D04: 480677A5  bl 0x829404a8
	ctx.lr = 0x828D8D08;
	sub_829404A8(ctx, base);
	// 828D8D08: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828D8D0C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D8D10: 83DD0000  lwz r30, 0(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D8D14: 4BF16B3D  bl 0x827ef850
	ctx.lr = 0x828D8D18;
	sub_827EF850(ctx, base);
	// 828D8D18: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 828D8D1C: 815E0034  lwz r10, 0x34(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) } as u64;
	// 828D8D20: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D8D24: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D8D28: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D8D2C: C02B029C  lfs f1, 0x29c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(668 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828D8D30: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828D8D34: 4E800421  bctrl
	ctx.lr = 0x828D8D38;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D8D38: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828D8D3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D8D40: 48037A09  bl 0x82910748
	ctx.lr = 0x828D8D44;
	sub_82910748(ctx, base);
	// 828D8D44: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828D8D48: 488CF474  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D8D50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D8D50 size=96
    let mut pc: u32 = 0x828D8D50;
    'dispatch: loop {
        match pc {
            0x828D8D50 => {
    //   block [0x828D8D50..0x828D8DB0)
	// 828D8D50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D8D54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D8D58: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D8D5C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D8D60: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D8D64: 4BFFB24D  bl 0x828d3fb0
	ctx.lr = 0x828D8D68;
	sub_828D3FB0(ctx, base);
	// 828D8D68: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D8D6C: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828D8D70: 396BF820  addi r11, r11, -0x7e0
	ctx.r[11].s64 = ctx.r[11].s64 + -2016;
	// 828D8D74: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D8D78: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D8D7C: 808A0B10  lwz r4, 0xb10(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2832 as u32) ) } as u64;
	// 828D8D80: 4851AC89  bl 0x82df3a08
	ctx.lr = 0x828D8D84;
	sub_82DF3A08(ctx, base);
	// 828D8D84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D8D88: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D8D8C: 4858095D  bl 0x82e596e8
	ctx.lr = 0x828D8D90;
	sub_82E596E8(ctx, base);
	// 828D8D90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D8D94: 4851A695  bl 0x82df3428
	ctx.lr = 0x828D8D98;
	sub_82DF3428(ctx, base);
	// 828D8D98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D8D9C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D8DA0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D8DA4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D8DA8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D8DAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D8DB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828D8DB0 size=444
    let mut pc: u32 = 0x828D8DB0;
    'dispatch: loop {
        match pc {
            0x828D8DB0 => {
    //   block [0x828D8DB0..0x828D8F6C)
	// 828D8DB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D8DB4: 488CF3B5  bl 0x831a8168
	ctx.lr = 0x828D8DB8;
	sub_831A8130(ctx, base);
	// 828D8DB8: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 828D8DBC: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D8DC0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D8DC4: 4887B83D  bl 0x83154600
	ctx.lr = 0x828D8DC8;
	sub_83154600(ctx, base);
	// 828D8DC8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D8DCC: 4BFDFF1D  bl 0x828b8ce8
	ctx.lr = 0x828D8DD0;
	sub_828B8CE8(ctx, base);
	// 828D8DD0: 3BA30010  addi r29, r3, 0x10
	ctx.r[29].s64 = ctx.r[3].s64 + 16;
	// 828D8DD4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D8DD8: 480307A9  bl 0x82909580
	ctx.lr = 0x828D8DDC;
	sub_82909580(ctx, base);
	// 828D8DDC: 4804303D  bl 0x8291be18
	ctx.lr = 0x828D8DE0;
	sub_8291BE18(ctx, base);
	// 828D8DE0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D8DE4: 41820054  beq 0x828d8e38
	if ctx.cr[0].eq {
	pc = 0x828D8E38; continue 'dispatch;
	}
	// 828D8DE8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D8DEC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D8DF0: 808B0B08  lwz r4, 0xb08(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2824 as u32) ) } as u64;
	// 828D8DF4: 4851AC15  bl 0x82df3a08
	ctx.lr = 0x828D8DF8;
	sub_82DF3A08(ctx, base);
	// 828D8DF8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D8DFC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D8E00: 4872F329  bl 0x83008128
	ctx.lr = 0x828D8E04;
	sub_83008128(ctx, base);
	// 828D8E04: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828D8E08: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D8E0C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D8E10: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D8E14: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D8E18: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828D8E1C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828D8E20: 48585B41  bl 0x82e5e960
	ctx.lr = 0x828D8E24;
	sub_82E5E960(ctx, base);
	// 828D8E24: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828D8E28: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D8E2C: 419A0134  beq cr6, 0x828d8f60
	if ctx.cr[6].eq {
	pc = 0x828D8F60; continue 'dispatch;
	}
	// 828D8E30: 4B9E7A61  bl 0x822c0890
	ctx.lr = 0x828D8E34;
	sub_822C0890(ctx, base);
	// 828D8E34: 4800012C  b 0x828d8f60
	pc = 0x828D8F60; continue 'dispatch;
	// 828D8E38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D8E3C: 4BF168FD  bl 0x827ef738
	ctx.lr = 0x828D8E40;
	sub_827EF738(ctx, base);
	// 828D8E40: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D8E44: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828D8E48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D8E4C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D8E50: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D8E54: 4E800421  bctrl
	ctx.lr = 0x828D8E58;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D8E58: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 828D8E5C: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828D8E60: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 828D8E64: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 828D8E68: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 828D8E6C: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 828D8E70: 13DC58C7  vcmpequd (lvx128) v30, v28, v11
	tmp.u32 = ctx.r[28].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828D8E74: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D8F70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D8F70 size=196
    let mut pc: u32 = 0x828D8F70;
    'dispatch: loop {
        match pc {
            0x828D8F70 => {
    //   block [0x828D8F70..0x828D9034)
	// 828D8F70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D8F74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D8F78: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828D8F7C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D8F80: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D8F84: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D8F88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D8F8C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828D8F90: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828D8F94: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D8F98: 4B9E79A1  bl 0x822c0938
	ctx.lr = 0x828D8F9C;
	sub_822C0938(ctx, base);
	// 828D8F9C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828D8FA0: 41820028  beq 0x828d8fc8
	if ctx.cr[0].eq {
	pc = 0x828D8FC8; continue 'dispatch;
	}
	// 828D8FA4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D8FA8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828D8FAC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D8FB0: 392BF7F8  addi r9, r11, -0x808
	ctx.r[9].s64 = ctx.r[11].s64 + -2056;
	// 828D8FB4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828D8FB8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828D8FBC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828D8FC0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828D8FC4: 48000008  b 0x828d8fcc
	pc = 0x828D8FCC; continue 'dispatch;
	// 828D8FC8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D8FCC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D8FD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D8FD4: 409A0044  bne cr6, 0x828d9018
	if !ctx.cr[6].eq {
	pc = 0x828D9018; continue 'dispatch;
	}
	// 828D8FD8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828D8FDC: 419A001C  beq cr6, 0x828d8ff8
	if ctx.cr[6].eq {
	pc = 0x828D8FF8; continue 'dispatch;
	}
	// 828D8FE0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D8FE4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828D8FE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D8FEC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D8FF0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D8FF4: 4E800421  bctrl
	ctx.lr = 0x828D8FF8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D8FF8: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D8FFC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828D9000: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D9004: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828D9008: 816B6B1C  lwz r11, 0x6b1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27420 as u32) ) } as u64;
	// 828D900C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828D9010: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828D9014: 4B9E6FED  bl 0x822c0000
	ctx.lr = 0x828D9018;
	sub_822C0000(ctx, base);
	// 828D9018: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D901C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D9020: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D9024: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D9028: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828D902C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D9030: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D9038(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D9038 size=196
    let mut pc: u32 = 0x828D9038;
    'dispatch: loop {
        match pc {
            0x828D9038 => {
    //   block [0x828D9038..0x828D90FC)
	// 828D9038: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D903C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D9040: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828D9044: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D9048: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D904C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D9050: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D9054: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828D9058: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828D905C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D9060: 4B9E78D9  bl 0x822c0938
	ctx.lr = 0x828D9064;
	sub_822C0938(ctx, base);
	// 828D9064: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828D9068: 41820028  beq 0x828d9090
	if ctx.cr[0].eq {
	pc = 0x828D9090; continue 'dispatch;
	}
	// 828D906C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D9070: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828D9074: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D9078: 392BF80C  addi r9, r11, -0x7f4
	ctx.r[9].s64 = ctx.r[11].s64 + -2036;
	// 828D907C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828D9080: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828D9084: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828D9088: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828D908C: 48000008  b 0x828d9094
	pc = 0x828D9094; continue 'dispatch;
	// 828D9090: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D9094: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D9098: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D909C: 409A0044  bne cr6, 0x828d90e0
	if !ctx.cr[6].eq {
	pc = 0x828D90E0; continue 'dispatch;
	}
	// 828D90A0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828D90A4: 419A001C  beq cr6, 0x828d90c0
	if ctx.cr[6].eq {
	pc = 0x828D90C0; continue 'dispatch;
	}
	// 828D90A8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D90AC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828D90B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D90B4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828D90B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D90BC: 4E800421  bctrl
	ctx.lr = 0x828D90C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D90C0: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D90C4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828D90C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D90CC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828D90D0: 816B6B1C  lwz r11, 0x6b1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27420 as u32) ) } as u64;
	// 828D90D4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828D90D8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828D90DC: 4B9E6F25  bl 0x822c0000
	ctx.lr = 0x828D90E0;
	sub_822C0000(ctx, base);
	// 828D90E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D90E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D90E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D90EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D90F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828D90F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D90F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D9100(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D9100 size=96
    let mut pc: u32 = 0x828D9100;
    'dispatch: loop {
        match pc {
            0x828D9100 => {
    //   block [0x828D9100..0x828D9160)
	// 828D9100: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D9104: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D9108: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D910C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D9110: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D9114: 4BFFAEDD  bl 0x828d3ff0
	ctx.lr = 0x828D9118;
	sub_828D3FF0(ctx, base);
	// 828D9118: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D911C: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828D9120: 396BF84C  addi r11, r11, -0x7b4
	ctx.r[11].s64 = ctx.r[11].s64 + -1972;
	// 828D9124: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D9128: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D912C: 808A0AFC  lwz r4, 0xafc(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2812 as u32) ) } as u64;
	// 828D9130: 4851A8D9  bl 0x82df3a08
	ctx.lr = 0x828D9134;
	sub_82DF3A08(ctx, base);
	// 828D9134: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D9138: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D913C: 485805AD  bl 0x82e596e8
	ctx.lr = 0x828D9140;
	sub_82E596E8(ctx, base);
	// 828D9140: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D9144: 4851A2E5  bl 0x82df3428
	ctx.lr = 0x828D9148;
	sub_82DF3428(ctx, base);
	// 828D9148: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D914C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D9150: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D9154: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D9158: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D915C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D9160(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828D9160 size=336
    let mut pc: u32 = 0x828D9160;
    'dispatch: loop {
        match pc {
            0x828D9160 => {
    //   block [0x828D9160..0x828D92B0)
	// 828D9160: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D9164: 488CF009  bl 0x831a816c
	ctx.lr = 0x828D9168;
	sub_831A8130(ctx, base);
	// 828D9168: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 828D916C: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D9170: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D9174: 4887B48D  bl 0x83154600
	ctx.lr = 0x828D9178;
	sub_83154600(ctx, base);
	// 828D9178: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D917C: 4BFDFB6D  bl 0x828b8ce8
	ctx.lr = 0x828D9180;
	sub_828B8CE8(ctx, base);
	// 828D9180: 3BA30010  addi r29, r3, 0x10
	ctx.r[29].s64 = ctx.r[3].s64 + 16;
	// 828D9184: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D9188: 480303F9  bl 0x82909580
	ctx.lr = 0x828D918C;
	sub_82909580(ctx, base);
	// 828D918C: 48042C8D  bl 0x8291be18
	ctx.lr = 0x828D9190;
	sub_8291BE18(ctx, base);
	// 828D9190: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D9194: 41820054  beq 0x828d91e8
	if ctx.cr[0].eq {
	pc = 0x828D91E8; continue 'dispatch;
	}
	// 828D9198: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D919C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D91A0: 808B0B08  lwz r4, 0xb08(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2824 as u32) ) } as u64;
	// 828D91A4: 4851A865  bl 0x82df3a08
	ctx.lr = 0x828D91A8;
	sub_82DF3A08(ctx, base);
	// 828D91A8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D91AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D91B0: 4872EF79  bl 0x83008128
	ctx.lr = 0x828D91B4;
	sub_83008128(ctx, base);
	// 828D91B4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828D91B8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D91BC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828D91C0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828D91C4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D91C8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828D91CC: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828D91D0: 48585791  bl 0x82e5e960
	ctx.lr = 0x828D91D4;
	sub_82E5E960(ctx, base);
	// 828D91D4: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828D91D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D91DC: 419A00C8  beq cr6, 0x828d92a4
	if ctx.cr[6].eq {
	pc = 0x828D92A4; continue 'dispatch;
	}
	// 828D91E0: 4B9E76B1  bl 0x822c0890
	ctx.lr = 0x828D91E4;
	sub_822C0890(ctx, base);
	// 828D91E4: 480000C0  b 0x828d92a4
	pc = 0x828D92A4; continue 'dispatch;
	// 828D91E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D91EC: 4858058D  bl 0x82e59778
	ctx.lr = 0x828D91F0;
	sub_82E59778(ctx, base);
	// 828D91F0: C01F0060  lfs f0, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D91F4: EC000828  fsubs f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 828D91F8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828D91FC: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828D9200: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828D9204: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 828D9208: 40980044  bge cr6, 0x828d924c
	if !ctx.cr[6].lt {
	pc = 0x828D924C; continue 'dispatch;
	}
	// 828D920C: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D9210: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D9214: 808B604C  lwz r4, 0x604c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24652 as u32) ) } as u64;
	// 828D9218: 4851A7F1  bl 0x82df3a08
	ctx.lr = 0x828D921C;
	sub_82DF3A08(ctx, base);
	// 828D921C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D9220: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D9224: 4872EF05  bl 0x83008128
	ctx.lr = 0x828D9228;
	sub_83008128(ctx, base);
	// 828D9228: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828D922C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D9230: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828D9234: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828D9238: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D923C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828D9240: 48585721  bl 0x82e5e960
	ctx.lr = 0x828D9244;
	sub_82E5E960(ctx, base);
	// 828D9244: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828D9248: 4BFFFF90  b 0x828d91d8
	pc = 0x828D91D8; continue 'dispatch;
	// 828D924C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D9250: 48030339  bl 0x82909588
	ctx.lr = 0x828D9254;
	sub_82909588(ctx, base);
	// 828D9254: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D9258: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D925C: 4858051D  bl 0x82e59778
	ctx.lr = 0x828D9260;
	sub_82E59778(ctx, base);
	// 828D9260: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D9264: 480670B5  bl 0x82940318
	ctx.lr = 0x828D9268;
	sub_82940318(ctx, base);
	// 828D9268: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828D926C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828D9270: 48066F99  bl 0x82940208
	ctx.lr = 0x828D9274;
	sub_82940208(ctx, base);
	// 828D9274: 83FE0000  lwz r31, 0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D9278: 4BFF5769  bl 0x828ce9e0
	ctx.lr = 0x828D927C;
	sub_828CE9E0(ctx, base);
	// 828D927C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828D9280: C1A3004C  lfs f13, 0x4c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828D9284: 815F0034  lwz r10, 0x34(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 828D9288: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 828D928C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D9290: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 828D9294: C00BCEE4  lfs f0, -0x311c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12572 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D9298: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 828D929C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828D92A0: 4E800421  bctrl
	ctx.lr = 0x828D92A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D92A4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828D92A8: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 828D92AC: 488CEF10  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D92B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828D92B0 size=744
    let mut pc: u32 = 0x828D92B0;
    'dispatch: loop {
        match pc {
            0x828D92B0 => {
    //   block [0x828D92B0..0x828D9598)
	// 828D92B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D92B4: 488CEEA5  bl 0x831a8158
	ctx.lr = 0x828D92B8;
	sub_831A8130(ctx, base);
	// 828D92B8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D92BC: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828D92C0: 4887B341  bl 0x83154600
	ctx.lr = 0x828D92C4;
	sub_83154600(ctx, base);
	// 828D92C4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D92C8: 4BFDFA21  bl 0x828b8ce8
	ctx.lr = 0x828D92CC;
	sub_828B8CE8(ctx, base);
	// 828D92CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D92D0: 4BFF5711  bl 0x828ce9e0
	ctx.lr = 0x828D92D4;
	sub_828CE9E0(ctx, base);
	// 828D92D4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D92D8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828D92DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D92E0: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828D92E4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D92E8: 4E800421  bctrl
	ctx.lr = 0x828D92EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D92EC: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D92F0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D92F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D92F8: 808BF3FC  lwz r4, -0xc04(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3076 as u32) ) } as u64;
	// 828D92FC: 4851A70D  bl 0x82df3a08
	ctx.lr = 0x828D9300;
	sub_82DF3A08(ctx, base);
	// 828D9300: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D9304: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D9308: 4BF111D9  bl 0x827ea4e0
	ctx.lr = 0x828D930C;
	sub_827EA4E0(ctx, base);
	// 828D930C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D9310: 4851A119  bl 0x82df3428
	ctx.lr = 0x828D9314;
	sub_82DF3428(ctx, base);
	// 828D9314: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 828D9318: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828D931C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D9320: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D9324: 816B00D0  lwz r11, 0xd0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(208 as u32) ) } as u64;
	// 828D9328: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D932C: 4E800421  bctrl
	ctx.lr = 0x828D9330;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D9330: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D9334: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D9338: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828D933C: 816B00D4  lwz r11, 0xd4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(212 as u32) ) } as u64;
	// 828D9340: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D9344: 4E800421  bctrl
	ctx.lr = 0x828D9348;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D9348: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D934C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828D9350: 480373F9  bl 0x82910748
	ctx.lr = 0x828D9354;
	sub_82910748(ctx, base);
	// 828D9354: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D9358: 48030231  bl 0x82909588
	ctx.lr = 0x828D935C;
	sub_82909588(ctx, base);
	// 828D935C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D9360: 48067149  bl 0x829404a8
	ctx.lr = 0x828D9364;
	sub_829404A8(ctx, base);
	// 828D9364: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D9368: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D936C: 3B8BF878  addi r28, r11, -0x788
	ctx.r[28].s64 = ctx.r[11].s64 + -1928;
	// 828D9370: 38A0005B  li r5, 0x5b
	ctx.r[5].s64 = 91;
	// 828D9374: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828D9378: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 828D937C: 4B9E705D  bl 0x822c03d8
	ctx.lr = 0x828D9380;
	sub_822C03D8(ctx, base);
	// 828D9380: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828D9384: 41820018  beq 0x828d939c
	if ctx.cr[0].eq {
	pc = 0x828D939C; continue 'dispatch;
	}
	// 828D9388: 38BB0050  addi r5, r27, 0x50
	ctx.r[5].s64 = ctx.r[27].s64 + 80;
	// 828D938C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828D9390: 48069FF9  bl 0x82943388
	ctx.lr = 0x828D9394;
	sub_82943388(ctx, base);
	// 828D9394: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D9398: 48000008  b 0x828d93a0
	pc = 0x828D93A0; continue 'dispatch;
	// 828D939C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828D93A0: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 828D93A4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828D93A8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D93AC: 4BF98B0D  bl 0x82871eb8
	ctx.lr = 0x828D93B0;
	sub_82871EB8(ctx, base);
	// 828D93B0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828D93B4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828D93B8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D93BC: 4B9E6C45  bl 0x822c0000
	ctx.lr = 0x828D93C0;
	sub_822C0000(ctx, base);
	// 828D93C0: 83010054  lwz r24, 0x54(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828D93C4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828D93C8: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 828D93CC: 93010054  stw r24, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[24].u32 ) };
	// 828D93D0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828D93D4: 419A0024  beq cr6, 0x828d93f8
	if ctx.cr[6].eq {
	pc = 0x828D93F8; continue 'dispatch;
	}
	// 828D93D8: 39780004  addi r11, r24, 4
	ctx.r[11].s64 = ctx.r[24].s64 + 4;
	// 828D93DC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828D93E0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D93E4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828D93E8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828D93EC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D93F0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D93F4: 4082FFE8  bne 0x828d93dc
	if !ctx.cr[0].eq {
	pc = 0x828D93DC; continue 'dispatch;
	}
	// 828D93F8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D93FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D9400: 480670B1  bl 0x829404b0
	ctx.lr = 0x828D9404;
	sub_829404B0(ctx, base);
	// 828D9404: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828D9408: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D940C: 38A0005F  li r5, 0x5f
	ctx.r[5].s64 = 95;
	// 828D9410: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 828D9414: 4B9E6FC5  bl 0x822c03d8
	ctx.lr = 0x828D9418;
	sub_822C03D8(ctx, base);
	// 828D9418: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828D941C: 41820018  beq 0x828d9434
	if ctx.cr[0].eq {
	pc = 0x828D9434; continue 'dispatch;
	}
	// 828D9420: 38BB0060  addi r5, r27, 0x60
	ctx.r[5].s64 = ctx.r[27].s64 + 96;
	// 828D9424: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828D9428: 48068AE1  bl 0x82941f08
	ctx.lr = 0x828D942C;
	sub_82941F08(ctx, base);
	// 828D942C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D9430: 48000008  b 0x828d9438
	pc = 0x828D9438; continue 'dispatch;
	// 828D9434: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828D9438: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 828D943C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828D9440: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D9444: 4BF99965  bl 0x82872da8
	ctx.lr = 0x828D9448;
	sub_82872DA8(ctx, base);
	// 828D9448: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828D944C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828D9450: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D9454: 4B9E6BAD  bl 0x822c0000
	ctx.lr = 0x828D9458;
	sub_822C0000(ctx, base);
	// 828D9458: 83410054  lwz r26, 0x54(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828D945C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828D9460: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 828D9464: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	// 828D9468: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828D946C: 419A0024  beq cr6, 0x828d9490
	if ctx.cr[6].eq {
	pc = 0x828D9490; continue 'dispatch;
	}
	// 828D9470: 397A0004  addi r11, r26, 4
	ctx.r[11].s64 = ctx.r[26].s64 + 4;
	// 828D9474: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828D9478: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D947C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828D9480: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828D9484: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D9488: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D948C: 4082FFE8  bne 0x828d9474
	if !ctx.cr[0].eq {
	pc = 0x828D9474; continue 'dispatch;
	}
	// 828D9490: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D9494: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D9498: 48067019  bl 0x829404b0
	ctx.lr = 0x828D949C;
	sub_829404B0(ctx, base);
	// 828D949C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828D94A0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D94A4: 38A00063  li r5, 0x63
	ctx.r[5].s64 = 99;
	// 828D94A8: 38600040  li r3, 0x40
	ctx.r[3].s64 = 64;
	// 828D94AC: 4B9E6F2D  bl 0x822c03d8
	ctx.lr = 0x828D94B0;
	sub_822C03D8(ctx, base);
	// 828D94B0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828D94B4: 41820018  beq 0x828d94cc
	if ctx.cr[0].eq {
	pc = 0x828D94CC; continue 'dispatch;
	}
	// 828D94B8: 38BB007C  addi r5, r27, 0x7c
	ctx.r[5].s64 = ctx.r[27].s64 + 124;
	// 828D94BC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828D94C0: 48069461  bl 0x82942920
	ctx.lr = 0x828D94C4;
	sub_82942920(ctx, base);
	// 828D94C4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D94C8: 48000008  b 0x828d94d0
	pc = 0x828D94D0; continue 'dispatch;
	// 828D94CC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828D94D0: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 828D94D4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828D94D8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D94DC: 4BF98AA5  bl 0x82871f80
	ctx.lr = 0x828D94E0;
	sub_82871F80(ctx, base);
	// 828D94E0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828D94E4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828D94E8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828D94EC: 4B9E6B15  bl 0x822c0000
	ctx.lr = 0x828D94F0;
	sub_822C0000(ctx, base);
	// 828D94F0: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828D94F4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828D94F8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828D94FC: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828D9500: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828D9504: 419A0024  beq cr6, 0x828d9528
	if ctx.cr[6].eq {
	pc = 0x828D9528; continue 'dispatch;
	}
	// 828D9508: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 828D950C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828D9510: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D9514: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828D9518: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828D951C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828D9520: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828D9524: 4082FFE8  bne 0x828d950c
	if !ctx.cr[0].eq {
	pc = 0x828D950C; continue 'dispatch;
	}
	// 828D9528: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D952C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D9530: 48066F81  bl 0x829404b0
	ctx.lr = 0x828D9534;
	sub_829404B0(ctx, base);
	// 828D9534: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828D9538: 419A000C  beq cr6, 0x828d9544
	if ctx.cr[6].eq {
	pc = 0x828D9544; continue 'dispatch;
	}
	// 828D953C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D9540: 4B9E7351  bl 0x822c0890
	ctx.lr = 0x828D9544;
	sub_822C0890(ctx, base);
	// 828D9544: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 828D9548: 419A000C  beq cr6, 0x828d9554
	if ctx.cr[6].eq {
	pc = 0x828D9554; continue 'dispatch;
	}
	// 828D954C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828D9550: 4B9E7341  bl 0x822c0890
	ctx.lr = 0x828D9554;
	sub_822C0890(ctx, base);
	// 828D9554: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 828D9558: 419A000C  beq cr6, 0x828d9564
	if ctx.cr[6].eq {
	pc = 0x828D9564; continue 'dispatch;
	}
	// 828D955C: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 828D9560: 4B9E7331  bl 0x822c0890
	ctx.lr = 0x828D9564;
	sub_822C0890(ctx, base);
	// 828D9564: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D9568: C01B0028  lfs f0, 0x28(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(40 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D956C: C1BB0024  lfs f13, 0x24(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(36 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828D9570: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D9574: EC206828  fsubs f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 828D9578: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828D957C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D9580: 4E800421  bctrl
	ctx.lr = 0x828D9584;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D9584: C01B0024  lfs f0, 0x24(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828D9588: EC01002A  fadds f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 828D958C: D0190060  stfs f0, 0x60(r25)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828D9590: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828D9594: 488CEC14  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D9598(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D9598 size=112
    let mut pc: u32 = 0x828D9598;
    'dispatch: loop {
        match pc {
            0x828D9598 => {
    //   block [0x828D9598..0x828D9608)
	// 828D9598: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D959C: 488CEBD1  bl 0x831a816c
	ctx.lr = 0x828D95A0;
	sub_831A8130(ctx, base);
	// 828D95A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D95A4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D95A8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D95AC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D95B0: 388BF878  addi r4, r11, -0x788
	ctx.r[4].s64 = ctx.r[11].s64 + -1928;
	// 828D95B4: 38A0009F  li r5, 0x9f
	ctx.r[5].s64 = 159;
	// 828D95B8: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 828D95BC: 48518E2D  bl 0x82df23e8
	ctx.lr = 0x828D95C0;
	sub_82DF23E8(ctx, base);
	// 828D95C0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828D95C4: 41820010  beq 0x828d95d4
	if ctx.cr[0].eq {
	pc = 0x828D95D4; continue 'dispatch;
	}
	// 828D95C8: 4BFFFB39  bl 0x828d9100
	ctx.lr = 0x828D95CC;
	sub_828D9100(ctx, base);
	// 828D95CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D95D0: 48000008  b 0x828d95d8
	pc = 0x828D95D8; continue 'dispatch;
	// 828D95D4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828D95D8: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828D95DC: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828D95E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D95E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D95E8: 4BFFF989  bl 0x828d8f70
	ctx.lr = 0x828D95EC;
	sub_828D8F70(ctx, base);
	// 828D95EC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D95F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D95F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D95F8: 4B9E6A09  bl 0x822c0000
	ctx.lr = 0x828D95FC;
	sub_822C0000(ctx, base);
	// 828D95FC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D9600: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D9604: 488CEBB8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D9608(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828D9608 size=624
    let mut pc: u32 = 0x828D9608;
    'dispatch: loop {
        match pc {
            0x828D9608 => {
    //   block [0x828D9608..0x828D9878)
	// 828D9608: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D960C: 488CEB51  bl 0x831a815c
	ctx.lr = 0x828D9610;
	sub_831A8130(ctx, base);
	// 828D9610: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D9614: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 828D9618: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 828D961C: 4887AFE5  bl 0x83154600
	ctx.lr = 0x828D9620;
	sub_83154600(ctx, base);
	// 828D9620: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D9624: 4BFDF6C5  bl 0x828b8ce8
	ctx.lr = 0x828D9628;
	sub_828B8CE8(ctx, base);
	// 828D9628: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828D962C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D9630: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D9634: 808BF3FC  lwz r4, -0xc04(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3076 as u32) ) } as u64;
	// 828D9638: 4851A3D1  bl 0x82df3a08
	ctx.lr = 0x828D963C;
	sub_82DF3A08(ctx, base);
	// 828D963C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D9640: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D9644: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D9648: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828D964C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D9650: 4E800421  bctrl
	ctx.lr = 0x828D9654;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D9654: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D9658: 48519DD1  bl 0x82df3428
	ctx.lr = 0x828D965C;
	sub_82DF3428(ctx, base);
	// 828D965C: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828D9660: 3BFE0010  addi r31, r30, 0x10
	ctx.r[31].s64 = ctx.r[30].s64 + 16;
	// 828D9664: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828D9668: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D966C: 816B00D0  lwz r11, 0xd0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(208 as u32) ) } as u64;
	// 828D9670: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D9674: 4E800421  bctrl
	ctx.lr = 0x828D9678;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D9678: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828D967C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D9680: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828D9684: 816B00D4  lwz r11, 0xd4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(212 as u32) ) } as u64;
	// 828D9688: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D968C: 4E800421  bctrl
	ctx.lr = 0x828D9690;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D9690: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828D9694: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D9698: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 828D969C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828D96A0: 480356D9  bl 0x8290ed78
	ctx.lr = 0x828D96A4;
	sub_8290ED78(ctx, base);
	// 828D96A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D96A8: 4802FEE1  bl 0x82909588
	ctx.lr = 0x828D96AC;
	sub_82909588(ctx, base);
	// 828D96AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D96B0: 48066DF9  bl 0x829404a8
	ctx.lr = 0x828D96B4;
	sub_829404A8(ctx, base);
	// 828D96B4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828D96B8: 48068C59  bl 0x82942310
	ctx.lr = 0x828D96BC;
	sub_82942310(ctx, base);
	// 828D96BC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D96C0: 4BF16079  bl 0x827ef738
	ctx.lr = 0x828D96C4;
	sub_827EF738(ctx, base);
	// 828D96C4: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 828D96C8: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 828D96CC: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 828D96D0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D96D4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D96D8: 13E350C7  vcmpequd (lvx128) v31, v3, v10
	tmp.u32 = ctx.r[3].u32 + ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828D96DC: 3BABF878  addi r29, r11, -0x788
	ctx.r[29].s64 = ctx.r[11].s64 + -1928;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D9878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D9878 size=112
    let mut pc: u32 = 0x828D9878;
    'dispatch: loop {
        match pc {
            0x828D9878 => {
    //   block [0x828D9878..0x828D98E8)
	// 828D9878: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D987C: 488CE8F1  bl 0x831a816c
	ctx.lr = 0x828D9880;
	sub_831A8130(ctx, base);
	// 828D9880: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D9884: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D9888: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D988C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828D9890: 388BF878  addi r4, r11, -0x788
	ctx.r[4].s64 = ctx.r[11].s64 + -1928;
	// 828D9894: 38A0010D  li r5, 0x10d
	ctx.r[5].s64 = 269;
	// 828D9898: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 828D989C: 48518B4D  bl 0x82df23e8
	ctx.lr = 0x828D98A0;
	sub_82DF23E8(ctx, base);
	// 828D98A0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828D98A4: 41820010  beq 0x828d98b4
	if ctx.cr[0].eq {
	pc = 0x828D98B4; continue 'dispatch;
	}
	// 828D98A8: 4BFFF4A9  bl 0x828d8d50
	ctx.lr = 0x828D98AC;
	sub_828D8D50(ctx, base);
	// 828D98AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D98B0: 48000008  b 0x828d98b8
	pc = 0x828D98B8; continue 'dispatch;
	// 828D98B4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828D98B8: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828D98BC: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828D98C0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D98C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D98C8: 4BFFF771  bl 0x828d9038
	ctx.lr = 0x828D98CC;
	sub_828D9038(ctx, base);
	// 828D98CC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828D98D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D98D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828D98D8: 4B9E6729  bl 0x822c0000
	ctx.lr = 0x828D98DC;
	sub_822C0000(ctx, base);
	// 828D98DC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828D98E0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D98E4: 488CE8D8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D98E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828D98E8 size=12
    let mut pc: u32 = 0x828D98E8;
    'dispatch: loop {
        match pc {
            0x828D98E8 => {
    //   block [0x828D98E8..0x828D98F4)
	// 828D98E8: 80630020  lwz r3, 0x20(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 828D98EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828D98F0: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D98F4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828D98F4 size=8
    let mut pc: u32 = 0x828D98F4;
    'dispatch: loop {
        match pc {
            0x828D98F4 => {
    //   block [0x828D98F4..0x828D98FC)
	// 828D98F4: 48005D94  b 0x828df688
	sub_828DF688(ctx, base);
	return;
	// 828D98F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D9900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D9900 size=204
    let mut pc: u32 = 0x828D9900;
    'dispatch: loop {
        match pc {
            0x828D9900 => {
    //   block [0x828D9900..0x828D99CC)
	// 828D9900: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D9904: 488CE869  bl 0x831a816c
	ctx.lr = 0x828D9908;
	sub_831A8130(ctx, base);
	// 828D9908: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D990C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D9910: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828D9914: 816B01A4  lwz r11, 0x1a4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(420 as u32) ) } as u64;
	// 828D9918: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D991C: 4E800421  bctrl
	ctx.lr = 0x828D9920;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D9920: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828D9924: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D9928: 388B5D2C  addi r4, r11, 0x5d2c
	ctx.r[4].s64 = ctx.r[11].s64 + 23852;
	// 828D992C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D9930: 4851A0D9  bl 0x82df3a08
	ctx.lr = 0x828D9934;
	sub_82DF3A08(ctx, base);
	// 828D9934: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D9938: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D993C: 485199CD  bl 0x82df3308
	ctx.lr = 0x828D9940;
	sub_82DF3308(ctx, base);
	// 828D9940: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D9944: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D9948: 48519AE1  bl 0x82df3428
	ctx.lr = 0x828D994C;
	sub_82DF3428(ctx, base);
	// 828D994C: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D9950: 40820070  bne 0x828d99c0
	if !ctx.cr[0].eq {
	pc = 0x828D99C0; continue 'dispatch;
	}
	// 828D9954: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828D9958: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D995C: 388B29C4  addi r4, r11, 0x29c4
	ctx.r[4].s64 = ctx.r[11].s64 + 10692;
	// 828D9960: 4851A0A9  bl 0x82df3a08
	ctx.lr = 0x828D9964;
	sub_82DF3A08(ctx, base);
	// 828D9964: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D9968: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D996C: 4851999D  bl 0x82df3308
	ctx.lr = 0x828D9970;
	sub_82DF3308(ctx, base);
	// 828D9970: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828D9974: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D9978: 48519AB1  bl 0x82df3428
	ctx.lr = 0x828D997C;
	sub_82DF3428(ctx, base);
	// 828D997C: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D9980: 4182000C  beq 0x828d998c
	if ctx.cr[0].eq {
	pc = 0x828D998C; continue 'dispatch;
	}
	// 828D9984: 387E0180  addi r3, r30, 0x180
	ctx.r[3].s64 = ctx.r[30].s64 + 384;
	// 828D9988: 4800003C  b 0x828d99c4
	pc = 0x828D99C4; continue 'dispatch;
	// 828D998C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828D9990: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D9994: 388B7C94  addi r4, r11, 0x7c94
	ctx.r[4].s64 = ctx.r[11].s64 + 31892;
	// 828D9998: 4851A071  bl 0x82df3a08
	ctx.lr = 0x828D999C;
	sub_82DF3A08(ctx, base);
	// 828D999C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828D99A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D99A4: 48519965  bl 0x82df3308
	ctx.lr = 0x828D99A8;
	sub_82DF3308(ctx, base);
	// 828D99A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D99AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D99B0: 48519A79  bl 0x82df3428
	ctx.lr = 0x828D99B4;
	sub_82DF3428(ctx, base);
	// 828D99B4: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D99B8: 387E0190  addi r3, r30, 0x190
	ctx.r[3].s64 = ctx.r[30].s64 + 400;
	// 828D99BC: 40820008  bne 0x828d99c4
	if !ctx.cr[0].eq {
	pc = 0x828D99C4; continue 'dispatch;
	}
	// 828D99C0: 387E0170  addi r3, r30, 0x170
	ctx.r[3].s64 = ctx.r[30].s64 + 368;
	// 828D99C4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828D99C8: 488CE7F4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D99D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828D99D0 size=16
    let mut pc: u32 = 0x828D99D0;
    'dispatch: loop {
        match pc {
            0x828D99D0 => {
    //   block [0x828D99D0..0x828D99E0)
	// 828D99D0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D99D4: 816B01A0  lwz r11, 0x1a0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(416 as u32) ) } as u64;
	// 828D99D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D99DC: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D99E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828D99E0 size=16
    let mut pc: u32 = 0x828D99E0;
    'dispatch: loop {
        match pc {
            0x828D99E0 => {
    //   block [0x828D99E0..0x828D99F0)
	// 828D99E0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D99E4: 816B01A4  lwz r11, 0x1a4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(420 as u32) ) } as u64;
	// 828D99E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D99EC: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D99F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D99F0 size=48
    let mut pc: u32 = 0x828D99F0;
    'dispatch: loop {
        match pc {
            0x828D99F0 => {
    //   block [0x828D99F0..0x828D9A20)
	// 828D99F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D99F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D99F8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D99FC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D9A00: 816B01A4  lwz r11, 0x1a4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(420 as u32) ) } as u64;
	// 828D9A04: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D9A08: 4E800421  bctrl
	ctx.lr = 0x828D9A0C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D9A0C: 386300AC  addi r3, r3, 0xac
	ctx.r[3].s64 = ctx.r[3].s64 + 172;
	// 828D9A10: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828D9A14: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D9A18: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D9A1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D9A20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D9A20 size=52
    let mut pc: u32 = 0x828D9A20;
    'dispatch: loop {
        match pc {
            0x828D9A20 => {
    //   block [0x828D9A20..0x828D9A54)
	// 828D9A20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D9A24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D9A28: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D9A2C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D9A30: 3BE40018  addi r31, r4, 0x18
	ctx.r[31].s64 = ctx.r[4].s64 + 24;
	// 828D9A34: 4BF1272D  bl 0x827ec160
	ctx.lr = 0x828D9A38;
	sub_827EC160(ctx, base);
	// 828D9A38: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828D9A3C: 4BF15D05  bl 0x827ef740
	ctx.lr = 0x828D9A40;
	sub_827EF740(ctx, base);
	// 828D9A40: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828D9A44: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D9A48: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D9A4C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D9A50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D9A58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D9A58 size=136
    let mut pc: u32 = 0x828D9A58;
    'dispatch: loop {
        match pc {
            0x828D9A58 => {
    //   block [0x828D9A58..0x828D9AE0)
	// 828D9A58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D9A5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D9A60: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828D9A64: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D9A68: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D9A6C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D9A70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D9A74: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828D9A78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D9A7C: 388BF918  addi r4, r11, -0x6e8
	ctx.r[4].s64 = ctx.r[11].s64 + -1768;
	// 828D9A80: 48519F89  bl 0x82df3a08
	ctx.lr = 0x828D9A84;
	sub_82DF3A08(ctx, base);
	// 828D9A84: 3BFFFCA0  addi r31, r31, -0x360
	ctx.r[31].s64 = ctx.r[31].s64 + -864;
	// 828D9A88: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828D9A8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D9A90: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828D9A94: 480343BD  bl 0x8290de50
	ctx.lr = 0x828D9A98;
	sub_8290DE50(ctx, base);
	// 828D9A98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D9A9C: 4851998D  bl 0x82df3428
	ctx.lr = 0x828D9AA0;
	sub_82DF3428(ctx, base);
	// 828D9AA0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D9AA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D9AA8: 388BF8FC  addi r4, r11, -0x704
	ctx.r[4].s64 = ctx.r[11].s64 + -1796;
	// 828D9AAC: 48519F5D  bl 0x82df3a08
	ctx.lr = 0x828D9AB0;
	sub_82DF3A08(ctx, base);
	// 828D9AB0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828D9AB4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828D9AB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D9ABC: 4803446D  bl 0x8290df28
	ctx.lr = 0x828D9AC0;
	sub_8290DF28(ctx, base);
	// 828D9AC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D9AC4: 48519965  bl 0x82df3428
	ctx.lr = 0x828D9AC8;
	sub_82DF3428(ctx, base);
	// 828D9AC8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D9ACC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D9AD0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D9AD4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828D9AD8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D9ADC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D9AE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828D9AE0 size=12
    let mut pc: u32 = 0x828D9AE0;
    'dispatch: loop {
        match pc {
            0x828D9AE0 => {
    //   block [0x828D9AE0..0x828D9AEC)
	// 828D9AE0: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828D9AE4: 386B1388  addi r3, r11, 0x1388
	ctx.r[3].s64 = ctx.r[11].s64 + 5000;
	// 828D9AE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D9AF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828D9AF0 size=24
    let mut pc: u32 = 0x828D9AF0;
    'dispatch: loop {
        match pc {
            0x828D9AF0 => {
    //   block [0x828D9AF0..0x828D9B08)
	// 828D9AF0: 81430388  lwz r10, 0x388(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(904 as u32) ) } as u64;
	// 828D9AF4: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828D9AF8: 396B1460  addi r11, r11, 0x1460
	ctx.r[11].s64 = ctx.r[11].s64 + 5216;
	// 828D9AFC: 1D4A01F4  mulli r10, r10, 0x1f4
	ctx.r[10].s64 = ctx.r[10].s64 * 500;
	// 828D9B00: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828D9B04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D9B08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D9B08 size=136
    let mut pc: u32 = 0x828D9B08;
    'dispatch: loop {
        match pc {
            0x828D9B08 => {
    //   block [0x828D9B08..0x828D9B90)
	// 828D9B08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D9B0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D9B10: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828D9B14: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D9B18: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D9B1C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D9B20: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828D9B24: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828D9B28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D9B2C: 388BF934  addi r4, r11, -0x6cc
	ctx.r[4].s64 = ctx.r[11].s64 + -1740;
	// 828D9B30: 48519ED9  bl 0x82df3a08
	ctx.lr = 0x828D9B34;
	sub_82DF3A08(ctx, base);
	// 828D9B34: 3BFFFCA0  addi r31, r31, -0x360
	ctx.r[31].s64 = ctx.r[31].s64 + -864;
	// 828D9B38: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828D9B3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D9B40: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828D9B44: 4803430D  bl 0x8290de50
	ctx.lr = 0x828D9B48;
	sub_8290DE50(ctx, base);
	// 828D9B48: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D9B4C: 485198DD  bl 0x82df3428
	ctx.lr = 0x828D9B50;
	sub_82DF3428(ctx, base);
	// 828D9B50: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D9B54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D9B58: 388BF8FC  addi r4, r11, -0x704
	ctx.r[4].s64 = ctx.r[11].s64 + -1796;
	// 828D9B5C: 48519EAD  bl 0x82df3a08
	ctx.lr = 0x828D9B60;
	sub_82DF3A08(ctx, base);
	// 828D9B60: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828D9B64: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828D9B68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828D9B6C: 480343BD  bl 0x8290df28
	ctx.lr = 0x828D9B70;
	sub_8290DF28(ctx, base);
	// 828D9B70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D9B74: 485198B5  bl 0x82df3428
	ctx.lr = 0x828D9B78;
	sub_82DF3428(ctx, base);
	// 828D9B78: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D9B7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D9B80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D9B84: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828D9B88: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D9B8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D9B90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828D9B90 size=12
    let mut pc: u32 = 0x828D9B90;
    'dispatch: loop {
        match pc {
            0x828D9B90 => {
    //   block [0x828D9B90..0x828D9B9C)
	// 828D9B90: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828D9B94: 386B27E8  addi r3, r11, 0x27e8
	ctx.r[3].s64 = ctx.r[11].s64 + 10216;
	// 828D9B98: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D9BA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828D9BA0 size=24
    let mut pc: u32 = 0x828D9BA0;
    'dispatch: loop {
        match pc {
            0x828D9BA0 => {
    //   block [0x828D9BA0..0x828D9BB8)
	// 828D9BA0: 81430388  lwz r10, 0x388(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(904 as u32) ) } as u64;
	// 828D9BA4: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828D9BA8: 396B28C0  addi r11, r11, 0x28c0
	ctx.r[11].s64 = ctx.r[11].s64 + 10432;
	// 828D9BAC: 1D4A01F4  mulli r10, r10, 0x1f4
	ctx.r[10].s64 = ctx.r[10].s64 * 500;
	// 828D9BB0: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828D9BB4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D9BB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D9BB8 size=116
    let mut pc: u32 = 0x828D9BB8;
    'dispatch: loop {
        match pc {
            0x828D9BB8 => {
    //   block [0x828D9BB8..0x828D9C2C)
	// 828D9BB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D9BBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D9BC0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828D9BC4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D9BC8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D9BCC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D9BD0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828D9BD4: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 828D9BD8: 409A000C  bne cr6, 0x828d9be4
	if !ctx.cr[6].eq {
	pc = 0x828D9BE4; continue 'dispatch;
	}
	// 828D9BDC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D9BE0: 48000030  b 0x828d9c10
	pc = 0x828D9C10; continue 'dispatch;
	// 828D9BE4: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 828D9BE8: 419A0024  beq cr6, 0x828d9c0c
	if ctx.cr[6].eq {
	pc = 0x828D9C0C; continue 'dispatch;
	}
	// 828D9BEC: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D9BF0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D9BF4: 388B6DA0  addi r4, r11, 0x6da0
	ctx.r[4].s64 = ctx.r[11].s64 + 28064;
	// 828D9BF8: 488CE501  bl 0x831a80f8
	ctx.lr = 0x828D9BFC;
	sub_831A80F8(ctx, base);
	// 828D9BFC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D9C00: 4182000C  beq 0x828d9c0c
	if ctx.cr[0].eq {
	pc = 0x828D9C0C; continue 'dispatch;
	}
	// 828D9C04: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828D9C08: 4800000C  b 0x828d9c14
	pc = 0x828D9C14; continue 'dispatch;
	// 828D9C0C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D9C10: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D9C14: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D9C18: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D9C1C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D9C20: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828D9C24: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D9C28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D9C30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D9C30 size=136
    let mut pc: u32 = 0x828D9C30;
    'dispatch: loop {
        match pc {
            0x828D9C30 => {
    //   block [0x828D9C30..0x828D9CB8)
	// 828D9C30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D9C34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D9C38: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828D9C3C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D9C40: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D9C44: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D9C48: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828D9C4C: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 828D9C50: 409A0020  bne cr6, 0x828d9c70
	if !ctx.cr[6].eq {
	pc = 0x828D9C70; continue 'dispatch;
	}
	// 828D9C54: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828D9C58: 419A0048  beq cr6, 0x828d9ca0
	if ctx.cr[6].eq {
	pc = 0x828D9CA0; continue 'dispatch;
	}
	// 828D9C5C: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 828D9C60: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 828D9C64: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 828D9C68: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 828D9C6C: 48000034  b 0x828d9ca0
	pc = 0x828D9CA0; continue 'dispatch;
	// 828D9C70: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 828D9C74: 419A002C  beq cr6, 0x828d9ca0
	if ctx.cr[6].eq {
	pc = 0x828D9CA0; continue 'dispatch;
	}
	// 828D9C78: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D9C7C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D9C80: 388B6DF0  addi r4, r11, 0x6df0
	ctx.r[4].s64 = ctx.r[11].s64 + 28144;
	// 828D9C84: 488CE475  bl 0x831a80f8
	ctx.lr = 0x828D9C88;
	sub_831A80F8(ctx, base);
	// 828D9C88: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D9C8C: 4182000C  beq 0x828d9c98
	if ctx.cr[0].eq {
	pc = 0x828D9C98; continue 'dispatch;
	}
	// 828D9C90: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828D9C94: 4800000C  b 0x828d9ca0
	pc = 0x828D9CA0; continue 'dispatch;
	// 828D9C98: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D9C9C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D9CA0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D9CA4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D9CA8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D9CAC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828D9CB0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D9CB4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D9CB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D9CB8 size=136
    let mut pc: u32 = 0x828D9CB8;
    'dispatch: loop {
        match pc {
            0x828D9CB8 => {
    //   block [0x828D9CB8..0x828D9D40)
	// 828D9CB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D9CBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D9CC0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828D9CC4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D9CC8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D9CCC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D9CD0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828D9CD4: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 828D9CD8: 409A0020  bne cr6, 0x828d9cf8
	if !ctx.cr[6].eq {
	pc = 0x828D9CF8; continue 'dispatch;
	}
	// 828D9CDC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828D9CE0: 419A0048  beq cr6, 0x828d9d28
	if ctx.cr[6].eq {
	pc = 0x828D9D28; continue 'dispatch;
	}
	// 828D9CE4: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 828D9CE8: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 828D9CEC: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 828D9CF0: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 828D9CF4: 48000034  b 0x828d9d28
	pc = 0x828D9D28; continue 'dispatch;
	// 828D9CF8: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 828D9CFC: 419A002C  beq cr6, 0x828d9d28
	if ctx.cr[6].eq {
	pc = 0x828D9D28; continue 'dispatch;
	}
	// 828D9D00: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D9D04: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D9D08: 388B6ED8  addi r4, r11, 0x6ed8
	ctx.r[4].s64 = ctx.r[11].s64 + 28376;
	// 828D9D0C: 488CE3ED  bl 0x831a80f8
	ctx.lr = 0x828D9D10;
	sub_831A80F8(ctx, base);
	// 828D9D10: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D9D14: 4182000C  beq 0x828d9d20
	if ctx.cr[0].eq {
	pc = 0x828D9D20; continue 'dispatch;
	}
	// 828D9D18: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828D9D1C: 4800000C  b 0x828d9d28
	pc = 0x828D9D28; continue 'dispatch;
	// 828D9D20: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D9D24: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D9D28: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D9D2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D9D30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D9D34: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828D9D38: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D9D3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D9D40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D9D40 size=144
    let mut pc: u32 = 0x828D9D40;
    'dispatch: loop {
        match pc {
            0x828D9D40 => {
    //   block [0x828D9D40..0x828D9DD0)
	// 828D9D40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D9D44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D9D48: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828D9D4C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D9D50: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D9D54: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D9D58: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828D9D5C: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 828D9D60: 409A0028  bne cr6, 0x828d9d88
	if !ctx.cr[6].eq {
	pc = 0x828D9D88; continue 'dispatch;
	}
	// 828D9D64: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828D9D68: 419A0050  beq cr6, 0x828d9db8
	if ctx.cr[6].eq {
	pc = 0x828D9DB8; continue 'dispatch;
	}
	// 828D9D6C: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 828D9D70: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 828D9D74: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 828D9D78: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 828D9D7C: E97E0010  ld r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	// 828D9D80: F97F0010  std r11, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 828D9D84: 48000034  b 0x828d9db8
	pc = 0x828D9DB8; continue 'dispatch;
	// 828D9D88: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 828D9D8C: 419A002C  beq cr6, 0x828d9db8
	if ctx.cr[6].eq {
	pc = 0x828D9DB8; continue 'dispatch;
	}
	// 828D9D90: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D9D94: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D9D98: 388B6F88  addi r4, r11, 0x6f88
	ctx.r[4].s64 = ctx.r[11].s64 + 28552;
	// 828D9D9C: 488CE35D  bl 0x831a80f8
	ctx.lr = 0x828D9DA0;
	sub_831A80F8(ctx, base);
	// 828D9DA0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D9DA4: 4182000C  beq 0x828d9db0
	if ctx.cr[0].eq {
	pc = 0x828D9DB0; continue 'dispatch;
	}
	// 828D9DA8: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828D9DAC: 4800000C  b 0x828d9db8
	pc = 0x828D9DB8; continue 'dispatch;
	// 828D9DB0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D9DB4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D9DB8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D9DBC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D9DC0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D9DC4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828D9DC8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D9DCC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D9DD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D9DD0 size=136
    let mut pc: u32 = 0x828D9DD0;
    'dispatch: loop {
        match pc {
            0x828D9DD0 => {
    //   block [0x828D9DD0..0x828D9E58)
	// 828D9DD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D9DD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D9DD8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828D9DDC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D9DE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D9DE4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D9DE8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828D9DEC: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 828D9DF0: 409A0020  bne cr6, 0x828d9e10
	if !ctx.cr[6].eq {
	pc = 0x828D9E10; continue 'dispatch;
	}
	// 828D9DF4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828D9DF8: 419A0048  beq cr6, 0x828d9e40
	if ctx.cr[6].eq {
	pc = 0x828D9E40; continue 'dispatch;
	}
	// 828D9DFC: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 828D9E00: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 828D9E04: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 828D9E08: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 828D9E0C: 48000034  b 0x828d9e40
	pc = 0x828D9E40; continue 'dispatch;
	// 828D9E10: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 828D9E14: 419A002C  beq cr6, 0x828d9e40
	if ctx.cr[6].eq {
	pc = 0x828D9E40; continue 'dispatch;
	}
	// 828D9E18: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D9E1C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D9E20: 388B7058  addi r4, r11, 0x7058
	ctx.r[4].s64 = ctx.r[11].s64 + 28760;
	// 828D9E24: 488CE2D5  bl 0x831a80f8
	ctx.lr = 0x828D9E28;
	sub_831A80F8(ctx, base);
	// 828D9E28: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D9E2C: 4182000C  beq 0x828d9e38
	if ctx.cr[0].eq {
	pc = 0x828D9E38; continue 'dispatch;
	}
	// 828D9E30: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828D9E34: 4800000C  b 0x828d9e40
	pc = 0x828D9E40; continue 'dispatch;
	// 828D9E38: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D9E3C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D9E40: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D9E44: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D9E48: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D9E4C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828D9E50: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D9E54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D9E58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D9E58 size=136
    let mut pc: u32 = 0x828D9E58;
    'dispatch: loop {
        match pc {
            0x828D9E58 => {
    //   block [0x828D9E58..0x828D9EE0)
	// 828D9E58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D9E5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D9E60: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828D9E64: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D9E68: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D9E6C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D9E70: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828D9E74: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 828D9E78: 409A0020  bne cr6, 0x828d9e98
	if !ctx.cr[6].eq {
	pc = 0x828D9E98; continue 'dispatch;
	}
	// 828D9E7C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828D9E80: 419A0048  beq cr6, 0x828d9ec8
	if ctx.cr[6].eq {
	pc = 0x828D9EC8; continue 'dispatch;
	}
	// 828D9E84: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 828D9E88: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 828D9E8C: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 828D9E90: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 828D9E94: 48000034  b 0x828d9ec8
	pc = 0x828D9EC8; continue 'dispatch;
	// 828D9E98: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 828D9E9C: 419A002C  beq cr6, 0x828d9ec8
	if ctx.cr[6].eq {
	pc = 0x828D9EC8; continue 'dispatch;
	}
	// 828D9EA0: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828D9EA4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D9EA8: 388B7110  addi r4, r11, 0x7110
	ctx.r[4].s64 = ctx.r[11].s64 + 28944;
	// 828D9EAC: 488CE24D  bl 0x831a80f8
	ctx.lr = 0x828D9EB0;
	sub_831A80F8(ctx, base);
	// 828D9EB0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828D9EB4: 4182000C  beq 0x828d9ec0
	if ctx.cr[0].eq {
	pc = 0x828D9EC0; continue 'dispatch;
	}
	// 828D9EB8: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828D9EBC: 4800000C  b 0x828d9ec8
	pc = 0x828D9EC8; continue 'dispatch;
	// 828D9EC0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D9EC4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D9EC8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828D9ECC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828D9ED0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828D9ED4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828D9ED8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828D9EDC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D9EE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828D9EE0 size=16
    let mut pc: u32 = 0x828D9EE0;
    'dispatch: loop {
        match pc {
            0x828D9EE0 => {
    //   block [0x828D9EE0..0x828D9EF0)
	// 828D9EE0: 81830000  lwz r12, 0(r3)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D9EE4: 816C0140  lwz r11, 0x140(r12)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[12].u32.wrapping_add(320 as u32) ) } as u64;
	// 828D9EE8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D9EEC: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D9EF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828D9EF0 size=16
    let mut pc: u32 = 0x828D9EF0;
    'dispatch: loop {
        match pc {
            0x828D9EF0 => {
    //   block [0x828D9EF0..0x828D9F00)
	// 828D9EF0: 81830000  lwz r12, 0(r3)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D9EF4: 816C01B0  lwz r11, 0x1b0(r12)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[12].u32.wrapping_add(432 as u32) ) } as u64;
	// 828D9EF8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D9EFC: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D9F00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828D9F00 size=16
    let mut pc: u32 = 0x828D9F00;
    'dispatch: loop {
        match pc {
            0x828D9F00 => {
    //   block [0x828D9F00..0x828D9F10)
	// 828D9F00: 81830000  lwz r12, 0(r3)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D9F04: 816C01B4  lwz r11, 0x1b4(r12)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[12].u32.wrapping_add(436 as u32) ) } as u64;
	// 828D9F08: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D9F0C: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D9F10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828D9F10 size=16
    let mut pc: u32 = 0x828D9F10;
    'dispatch: loop {
        match pc {
            0x828D9F10 => {
    //   block [0x828D9F10..0x828D9F20)
	// 828D9F10: 81830000  lwz r12, 0(r3)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D9F14: 816C01A8  lwz r11, 0x1a8(r12)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[12].u32.wrapping_add(424 as u32) ) } as u64;
	// 828D9F18: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D9F1C: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D9F20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828D9F20 size=16
    let mut pc: u32 = 0x828D9F20;
    'dispatch: loop {
        match pc {
            0x828D9F20 => {
    //   block [0x828D9F20..0x828D9F30)
	// 828D9F20: 81830000  lwz r12, 0(r3)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D9F24: 816C01AC  lwz r11, 0x1ac(r12)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[12].u32.wrapping_add(428 as u32) ) } as u64;
	// 828D9F28: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D9F2C: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D9F30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828D9F30 size=84
    let mut pc: u32 = 0x828D9F30;
    'dispatch: loop {
        match pc {
            0x828D9F30 => {
    //   block [0x828D9F30..0x828D9F84)
	// 828D9F30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D9F34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D9F38: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D9F3C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D9F40: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828D9F44: 4BF1221D  bl 0x827ec160
	ctx.lr = 0x828D9F48;
	sub_827EC160(ctx, base);
	// 828D9F48: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828D9F4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828D9F50: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 828D9F54: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D9F58: 816A0018  lwz r11, 0x18(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 828D9F5C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828D9F60: 4E800421  bctrl
	ctx.lr = 0x828D9F64;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828D9F64: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 828D9F68: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828D9F88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828D9F88 size=196
    let mut pc: u32 = 0x828D9F88;
    'dispatch: loop {
        match pc {
            0x828D9F88 => {
    //   block [0x828D9F88..0x828DA04C)
	// 828D9F88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828D9F8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828D9F90: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828D9F94: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828D9F98: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828D9F9C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828D9FA0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D9FA4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828D9FA8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828D9FAC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D9FB0: 4B9E6989  bl 0x822c0938
	ctx.lr = 0x828D9FB4;
	sub_822C0938(ctx, base);
	// 828D9FB4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828D9FB8: 41820028  beq 0x828d9fe0
	if ctx.cr[0].eq {
	pc = 0x828D9FE0; continue 'dispatch;
	}
	// 828D9FBC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828D9FC0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828D9FC4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828D9FC8: 392BF958  addi r9, r11, -0x6a8
	ctx.r[9].s64 = ctx.r[11].s64 + -1704;
	// 828D9FCC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828D9FD0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828D9FD4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828D9FD8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828D9FDC: 48000008  b 0x828d9fe4
	pc = 0x828D9FE4; continue 'dispatch;
	// 828D9FE0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828D9FE4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828D9FE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828D9FEC: 409A0044  bne cr6, 0x828da030
	if !ctx.cr[6].eq {
	pc = 0x828DA030; continue 'dispatch;
	}
	// 828D9FF0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828D9FF4: 419A001C  beq cr6, 0x828da010
	if ctx.cr[6].eq {
	pc = 0x828DA010; continue 'dispatch;
	}
	// 828D9FF8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828D9FFC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828DA000: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DA004: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DA008: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828DA00C: 4E800421  bctrl
	ctx.lr = 0x828DA010;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DA010: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828DA014: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828DA018: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DA01C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828DA020: 816B6C34  lwz r11, 0x6c34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27700 as u32) ) } as u64;
	// 828DA024: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828DA028: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828DA02C: 4B9E5FD5  bl 0x822c0000
	ctx.lr = 0x828DA030;
	sub_822C0000(ctx, base);
	// 828DA030: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DA034: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828DA038: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DA03C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DA040: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828DA044: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828DA048: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DA050(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DA050 size=196
    let mut pc: u32 = 0x828DA050;
    'dispatch: loop {
        match pc {
            0x828DA050 => {
    //   block [0x828DA050..0x828DA114)
	// 828DA050: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DA054: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DA058: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828DA05C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828DA060: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DA064: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828DA068: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DA06C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828DA070: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828DA074: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828DA078: 4B9E68C1  bl 0x822c0938
	ctx.lr = 0x828DA07C;
	sub_822C0938(ctx, base);
	// 828DA07C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828DA080: 41820028  beq 0x828da0a8
	if ctx.cr[0].eq {
	pc = 0x828DA0A8; continue 'dispatch;
	}
	// 828DA084: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828DA088: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828DA08C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828DA090: 392BF96C  addi r9, r11, -0x694
	ctx.r[9].s64 = ctx.r[11].s64 + -1684;
	// 828DA094: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828DA098: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828DA09C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828DA0A0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828DA0A4: 48000008  b 0x828da0ac
	pc = 0x828DA0AC; continue 'dispatch;
	// 828DA0A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DA0AC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828DA0B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DA0B4: 409A0044  bne cr6, 0x828da0f8
	if !ctx.cr[6].eq {
	pc = 0x828DA0F8; continue 'dispatch;
	}
	// 828DA0B8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828DA0BC: 419A001C  beq cr6, 0x828da0d8
	if ctx.cr[6].eq {
	pc = 0x828DA0D8; continue 'dispatch;
	}
	// 828DA0C0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DA0C4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828DA0C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DA0CC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DA0D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828DA0D4: 4E800421  bctrl
	ctx.lr = 0x828DA0D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DA0D8: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828DA0DC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828DA0E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DA0E4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828DA0E8: 816B6C34  lwz r11, 0x6c34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27700 as u32) ) } as u64;
	// 828DA0EC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828DA0F0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828DA0F4: 4B9E5F0D  bl 0x822c0000
	ctx.lr = 0x828DA0F8;
	sub_822C0000(ctx, base);
	// 828DA0F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DA0FC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828DA100: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DA104: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DA108: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828DA10C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828DA110: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DA118(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DA118 size=196
    let mut pc: u32 = 0x828DA118;
    'dispatch: loop {
        match pc {
            0x828DA118 => {
    //   block [0x828DA118..0x828DA1DC)
	// 828DA118: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DA11C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DA120: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828DA124: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828DA128: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DA12C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828DA130: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DA134: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828DA138: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828DA13C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828DA140: 4B9E67F9  bl 0x822c0938
	ctx.lr = 0x828DA144;
	sub_822C0938(ctx, base);
	// 828DA144: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828DA148: 41820028  beq 0x828da170
	if ctx.cr[0].eq {
	pc = 0x828DA170; continue 'dispatch;
	}
	// 828DA14C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828DA150: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828DA154: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828DA158: 392BF980  addi r9, r11, -0x680
	ctx.r[9].s64 = ctx.r[11].s64 + -1664;
	// 828DA15C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828DA160: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828DA164: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828DA168: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828DA16C: 48000008  b 0x828da174
	pc = 0x828DA174; continue 'dispatch;
	// 828DA170: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DA174: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828DA178: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DA17C: 409A0044  bne cr6, 0x828da1c0
	if !ctx.cr[6].eq {
	pc = 0x828DA1C0; continue 'dispatch;
	}
	// 828DA180: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828DA184: 419A001C  beq cr6, 0x828da1a0
	if ctx.cr[6].eq {
	pc = 0x828DA1A0; continue 'dispatch;
	}
	// 828DA188: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DA18C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828DA190: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DA194: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DA198: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828DA19C: 4E800421  bctrl
	ctx.lr = 0x828DA1A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DA1A0: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828DA1A4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828DA1A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DA1AC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828DA1B0: 816B6C34  lwz r11, 0x6c34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27700 as u32) ) } as u64;
	// 828DA1B4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828DA1B8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828DA1BC: 4B9E5E45  bl 0x822c0000
	ctx.lr = 0x828DA1C0;
	sub_822C0000(ctx, base);
	// 828DA1C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DA1C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828DA1C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DA1CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DA1D0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828DA1D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828DA1D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DA1E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DA1E0 size=196
    let mut pc: u32 = 0x828DA1E0;
    'dispatch: loop {
        match pc {
            0x828DA1E0 => {
    //   block [0x828DA1E0..0x828DA2A4)
	// 828DA1E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DA1E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DA1E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828DA1EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828DA1F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DA1F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828DA1F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DA1FC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828DA200: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828DA204: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828DA208: 4B9E6731  bl 0x822c0938
	ctx.lr = 0x828DA20C;
	sub_822C0938(ctx, base);
	// 828DA20C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828DA210: 41820028  beq 0x828da238
	if ctx.cr[0].eq {
	pc = 0x828DA238; continue 'dispatch;
	}
	// 828DA214: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828DA218: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828DA21C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828DA220: 392BF994  addi r9, r11, -0x66c
	ctx.r[9].s64 = ctx.r[11].s64 + -1644;
	// 828DA224: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828DA228: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828DA22C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828DA230: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828DA234: 48000008  b 0x828da23c
	pc = 0x828DA23C; continue 'dispatch;
	// 828DA238: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DA23C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828DA240: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DA244: 409A0044  bne cr6, 0x828da288
	if !ctx.cr[6].eq {
	pc = 0x828DA288; continue 'dispatch;
	}
	// 828DA248: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828DA24C: 419A001C  beq cr6, 0x828da268
	if ctx.cr[6].eq {
	pc = 0x828DA268; continue 'dispatch;
	}
	// 828DA250: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DA254: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828DA258: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DA25C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DA260: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828DA264: 4E800421  bctrl
	ctx.lr = 0x828DA268;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DA268: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828DA26C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828DA270: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DA274: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828DA278: 816B6C34  lwz r11, 0x6c34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27700 as u32) ) } as u64;
	// 828DA27C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828DA280: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828DA284: 4B9E5D7D  bl 0x822c0000
	ctx.lr = 0x828DA288;
	sub_822C0000(ctx, base);
	// 828DA288: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DA28C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828DA290: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DA294: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DA298: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828DA29C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828DA2A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DA2A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DA2A8 size=72
    let mut pc: u32 = 0x828DA2A8;
    'dispatch: loop {
        match pc {
            0x828DA2A8 => {
    //   block [0x828DA2A8..0x828DA2F0)
	// 828DA2A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DA2AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DA2B0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DA2B4: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 828DA2B8: 419A001C  beq cr6, 0x828da2d4
	if ctx.cr[6].eq {
	pc = 0x828DA2D4; continue 'dispatch;
	}
	// 828DA2BC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828DA2C0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828DA2C4: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 828DA2C8: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828DA2CC: 4BFFF8ED  bl 0x828d9bb8
	ctx.lr = 0x828DA2D0;
	sub_828D9BB8(ctx, base);
	// 828DA2D0: 48000010  b 0x828da2e0
	pc = 0x828DA2E0; continue 'dispatch;
	// 828DA2D4: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828DA2D8: 396B6DA0  addi r11, r11, 0x6da0
	ctx.r[11].s64 = ctx.r[11].s64 + 28064;
	// 828DA2DC: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828DA2E0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828DA2E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DA2E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DA2EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DA2F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DA2F0 size=180
    let mut pc: u32 = 0x828DA2F0;
    'dispatch: loop {
        match pc {
            0x828DA2F0 => {
    //   block [0x828DA2F0..0x828DA3A4)
	// 828DA2F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DA2F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DA2F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828DA2FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828DA300: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DA304: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DA308: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828DA30C: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828DA310: 396BFA2C  addi r11, r11, -0x5d4
	ctx.r[11].s64 = ctx.r[11].s64 + -1492;
	// 828DA314: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828DA318: 3D008209  lis r8, -0x7df7
	ctx.r[8].s64 = -2113339392;
	// 828DA31C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828DA320: 807F0380  lwz r3, 0x380(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(896 as u32) ) } as u64;
	// 828DA324: 394AFA14  addi r10, r10, -0x5ec
	ctx.r[10].s64 = ctx.r[10].s64 + -1516;
	// 828DA328: 3929F9F8  addi r9, r9, -0x608
	ctx.r[9].s64 = ctx.r[9].s64 + -1544;
	// 828DA32C: 3968F9AC  addi r11, r8, -0x654
	ctx.r[11].s64 = ctx.r[8].s64 + -1620;
	// 828DA330: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 828DA334: 3BDF0360  addi r30, r31, 0x360
	ctx.r[30].s64 = ctx.r[31].s64 + 864;
	// 828DA338: 913F0208  stw r9, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[9].u32 ) };
	// 828DA33C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DA340: 917F0360  stw r11, 0x360(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(864 as u32), ctx.r[11].u32 ) };
	// 828DA344: 419A0008  beq cr6, 0x828da34c
	if ctx.cr[6].eq {
	pc = 0x828DA34C; continue 'dispatch;
	}
	// 828DA348: 4B9E5F21  bl 0x822c0268
	ctx.lr = 0x828DA34C;
	sub_822C0268(ctx, base);
	// 828DA34C: 807F0378  lwz r3, 0x378(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(888 as u32) ) } as u64;
	// 828DA350: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DA354: 419A0008  beq cr6, 0x828da35c
	if ctx.cr[6].eq {
	pc = 0x828DA35C; continue 'dispatch;
	}
	// 828DA358: 4B9E6539  bl 0x822c0890
	ctx.lr = 0x828DA35C;
	sub_822C0890(ctx, base);
	// 828DA35C: 807F0370  lwz r3, 0x370(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(880 as u32) ) } as u64;
	// 828DA360: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DA364: 419A0008  beq cr6, 0x828da36c
	if ctx.cr[6].eq {
	pc = 0x828DA36C; continue 'dispatch;
	}
	// 828DA368: 4B9E6529  bl 0x822c0890
	ctx.lr = 0x828DA36C;
	sub_822C0890(ctx, base);
	// 828DA36C: 807F0368  lwz r3, 0x368(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(872 as u32) ) } as u64;
	// 828DA370: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DA374: 419A0008  beq cr6, 0x828da37c
	if ctx.cr[6].eq {
	pc = 0x828DA37C; continue 'dispatch;
	}
	// 828DA378: 4B9E6519  bl 0x822c0890
	ctx.lr = 0x828DA37C;
	sub_822C0890(ctx, base);
	// 828DA37C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DA380: 4BECD2D9  bl 0x827a7658
	ctx.lr = 0x828DA384;
	sub_827A7658(ctx, base);
	// 828DA384: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DA388: 48036909  bl 0x82910c90
	ctx.lr = 0x828DA38C;
	sub_82910C90(ctx, base);
	// 828DA38C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828DA390: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DA394: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DA398: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828DA39C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828DA3A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DA3A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828DA3A8 size=8
    let mut pc: u32 = 0x828DA3A8;
    'dispatch: loop {
        match pc {
            0x828DA3A8 => {
    //   block [0x828DA3A8..0x828DA3B0)
	// 828DA3A8: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 828DA3AC: 480011BC  b 0x828db568
	sub_828DB568(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DA3B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828DA3B0 size=8
    let mut pc: u32 = 0x828DA3B0;
    'dispatch: loop {
        match pc {
            0x828DA3B0 => {
    //   block [0x828DA3B0..0x828DA3B8)
	// 828DA3B0: 3863FDF8  addi r3, r3, -0x208
	ctx.r[3].s64 = ctx.r[3].s64 + -520;
	// 828DA3B4: 480011B4  b 0x828db568
	sub_828DB568(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DA3B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828DA3B8 size=8
    let mut pc: u32 = 0x828DA3B8;
    'dispatch: loop {
        match pc {
            0x828DA3B8 => {
    //   block [0x828DA3B8..0x828DA3C0)
	// 828DA3B8: 3863FCA0  addi r3, r3, -0x360
	ctx.r[3].s64 = ctx.r[3].s64 + -864;
	// 828DA3BC: 480011AC  b 0x828db568
	sub_828DB568(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DA3C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DA3C0 size=80
    let mut pc: u32 = 0x828DA3C0;
    'dispatch: loop {
        match pc {
            0x828DA3C0 => {
    //   block [0x828DA3C0..0x828DA410)
	// 828DA3C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DA3C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DA3C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828DA3CC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DA3D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DA3D4: 2F050009  cmpwi cr6, r5, 9
	ctx.cr[6].compare_i32(ctx.r[5].s32, 9, &mut ctx.xer);
	// 828DA3D8: 419A0014  beq cr6, 0x828da3ec
	if ctx.cr[6].eq {
	pc = 0x828DA3EC; continue 'dispatch;
	}
	// 828DA3DC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DA3E0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828DA3E4: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828DA3E8: 48000014  b 0x828da3fc
	pc = 0x828DA3FC; continue 'dispatch;
	// 828DA3EC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828DA3F0: 38ABFBE4  addi r5, r11, -0x41c
	ctx.r[5].s64 = ctx.r[11].s64 + -1052;
	// 828DA3F4: 4BC37D85  bl 0x82512178
	ctx.lr = 0x828DA3F8;
	sub_82512178(ctx, base);
	// 828DA3F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DA3FC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828DA400: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DA404: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DA408: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828DA40C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


