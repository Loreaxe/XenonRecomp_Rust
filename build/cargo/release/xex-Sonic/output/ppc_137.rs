pub fn sub_82ABB310(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ABB310 size=380
    let mut pc: u32 = 0x82ABB310;
    'dispatch: loop {
        match pc {
            0x82ABB310 => {
    //   block [0x82ABB310..0x82ABB48C)
	// 82ABB310: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABB314: 486ECE59  bl 0x831a816c
	ctx.lr = 0x82ABB318;
	sub_831A8130(ctx, base);
	// 82ABB318: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 82ABB31C: 486ED75D  bl 0x831a8a78
	ctx.lr = 0x82ABB320;
	sub_831A8A40(ctx, base);
	// 82ABB320: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABB324: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABB328: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82ABB32C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ABB330: C05F00D0  lfs f2, 0xd0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82ABB334: C02BE98C  lfs f1, -0x1674(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-5748 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82ABB338: 4BFF30C9  bl 0x82aae400
	ctx.lr = 0x82ABB33C;
	sub_82AAE400(ctx, base);
	// 82ABB33C: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82ABB340: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82ABB344: C05F00D0  lfs f2, 0xd0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82ABB348: C02BE990  lfs f1, -0x1670(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-5744 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82ABB34C: 4BFF30B5  bl 0x82aae400
	ctx.lr = 0x82ABB350;
	sub_82AAE400(ctx, base);
	// 82ABB350: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 82ABB354: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ABB358: 815F00D4  lwz r10, 0xd4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 82ABB35C: 3BBF00D8  addi r29, r31, 0xd8
	ctx.r[29].s64 = ctx.r[31].s64 + 216;
	// 82ABB360: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82ABB364: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 82ABB368: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ABB36C: C3AB08A8  lfs f29, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82ABB370: FC60F090  fmr f3, f30
	ctx.f[3].f64 = ctx.f[30].f64;
	// 82ABB374: 409A0028  bne cr6, 0x82abb39c
	if !ctx.cr[6].eq {
	pc = 0x82ABB39C; continue 'dispatch;
	}
	// 82ABB378: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ABB37C: D3BF00F0  stfs f29, 0xf0(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 82ABB380: 3D40832F  lis r10, -0x7cd1
	ctx.r[10].s64 = -2094071808;
	// 82ABB384: D3BF00F8  stfs f29, 0xf8(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 82ABB388: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ABB38C: D01F00EC  stfs f0, 0xec(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 82ABB390: D01F00F4  stfs f0, 0xf4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 82ABB394: C02AE994  lfs f1, -0x166c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-5740 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82ABB398: 4800000C  b 0x82abb3a4
	pc = 0x82ABB3A4; continue 'dispatch;
	// 82ABB39C: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82ABB3A0: C02BE974  lfs f1, -0x168c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-5772 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82ABB3A4: 4BFF32CD  bl 0x82aae670
	ctx.lr = 0x82ABB3A8;
	sub_82AAE670(ctx, base);
	// 82ABB3A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABB3AC: 4BFFFB35  bl 0x82abaee0
	ctx.lr = 0x82ABB3B0;
	sub_82ABAEE0(ctx, base);
	// 82ABB3B0: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 82ABB3B4: 13E0F0C7  vcmpequd (lvx128) v31, v0, v30
	tmp.u32 = ctx.r[30].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82ABB3B8: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 82ABB3BC: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82ABB3C0: FF800890  fmr f28, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[28].f64 = ctx.f[1].f64;
	// 82ABB3C4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82ABB3C8: 13DE58C7  vcmpequd (lvx128) v30, v30, v11
	tmp.u32 = ctx.r[30].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABB490(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ABB490 size=724
    let mut pc: u32 = 0x82ABB490;
    'dispatch: loop {
        match pc {
            0x82ABB490 => {
    //   block [0x82ABB490..0x82ABB764)
	// 82ABB490: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABB494: 486ECCC9  bl 0x831a815c
	ctx.lr = 0x82ABB498;
	sub_831A8130(ctx, base);
	// 82ABB498: DBC1FFB0  stfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 82ABB49C: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 82ABB4A0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABB4A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABB4A8: 39600070  li r11, 0x70
	ctx.r[11].s64 = 112;
	// 82ABB4AC: 3BBF0040  addi r29, r31, 0x40
	ctx.r[29].s64 = ctx.r[31].s64 + 64;
	// 82ABB4B0: 3B9F0050  addi r28, r31, 0x50
	ctx.r[28].s64 = ctx.r[31].s64 + 80;
	// 82ABB4B4: 39400080  li r10, 0x80
	ctx.r[10].s64 = 128;
	// 82ABB4B8: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82ABB4BC: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 82ABB4C0: 13E0E8C7  vcmpequd (lvx128) v31, v0, v29
	tmp.u32 = ctx.r[29].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82ABB4C4: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABB768(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ABB768 size=16
    let mut pc: u32 = 0x82ABB768;
    'dispatch: loop {
        match pc {
            0x82ABB768 => {
    //   block [0x82ABB768..0x82ABB778)
	// 82ABB768: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ABB76C: 396B8394  addi r11, r11, -0x7c6c
	ctx.r[11].s64 = ctx.r[11].s64 + -31852;
	// 82ABB770: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ABB774: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABB778(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABB778 size=68
    let mut pc: u32 = 0x82ABB778;
    'dispatch: loop {
        match pc {
            0x82ABB778 => {
    //   block [0x82ABB778..0x82ABB7BC)
	// 82ABB778: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABB77C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABB780: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABB784: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABB788: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABB78C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ABB790: 548A07FF  clrlwi. r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82ABB794: 396B8394  addi r11, r11, -0x7c6c
	ctx.r[11].s64 = ctx.r[11].s64 + -31852;
	// 82ABB798: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ABB79C: 41820008  beq 0x82abb7a4
	if ctx.cr[0].eq {
	pc = 0x82ABB7A4; continue 'dispatch;
	}
	// 82ABB7A0: 4B804AC9  bl 0x822c0268
	ctx.lr = 0x82ABB7A4;
	sub_822C0268(ctx, base);
	// 82ABB7A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABB7A8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82ABB7AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABB7B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABB7B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ABB7B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABB7C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ABB7C0 size=28
    let mut pc: u32 = 0x82ABB7C0;
    'dispatch: loop {
        match pc {
            0x82ABB7C0 => {
    //   block [0x82ABB7C0..0x82ABB7DC)
	// 82ABB7C0: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 82ABB7C4: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82ABB7C8: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82ABB7CC: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82ABB7D0: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82ABB7D4: 69630001  xori r3, r11, 1
	ctx.r[3].u64 = ctx.r[11].u64 ^ 1;
	// 82ABB7D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABB7E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ABB7E0 size=12
    let mut pc: u32 = 0x82ABB7E0;
    'dispatch: loop {
        match pc {
            0x82ABB7E0 => {
    //   block [0x82ABB7E0..0x82ABB7EC)
	// 82ABB7E0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82ABB7E4: 99630038  stb r11, 0x38(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), ctx.r[11].u8 ) };
	// 82ABB7E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABB7F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABB7F0 size=192
    let mut pc: u32 = 0x82ABB7F0;
    'dispatch: loop {
        match pc {
            0x82ABB7F0 => {
    //   block [0x82ABB7F0..0x82ABB8B0)
	// 82ABB7F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABB7F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABB7F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABB7FC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABB800: 89630038  lbz r11, 0x38(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) } as u64;
	// 82ABB804: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82ABB808: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ABB80C: 4182008C  beq 0x82abb898
	if ctx.cr[0].eq {
	pc = 0x82ABB898; continue 'dispatch;
	}
	// 82ABB810: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 82ABB814: 81430030  lwz r10, 0x30(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 82ABB818: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82ABB81C: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82ABB820: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ABB824: 409A0024  bne cr6, 0x82abb848
	if !ctx.cr[6].eq {
	pc = 0x82ABB848; continue 'dispatch;
	}
	// 82ABB828: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82ABB82C: 386B0E14  addi r3, r11, 0xe14
	ctx.r[3].s64 = ctx.r[11].s64 + 3604;
	// 82ABB830: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ABB834: 48337F95  bl 0x82df37c8
	ctx.lr = 0x82ABB838;
	sub_82DF37C8(ctx, base);
	// 82ABB838: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ABB83C: 4182005C  beq 0x82abb898
	if ctx.cr[0].eq {
	pc = 0x82ABB898; continue 'dispatch;
	}
	// 82ABB840: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ABB844: 48000058  b 0x82abb89c
	pc = 0x82ABB89C; continue 'dispatch;
	// 82ABB848: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82ABB84C: 409A0028  bne cr6, 0x82abb874
	if !ctx.cr[6].eq {
	pc = 0x82ABB874; continue 'dispatch;
	}
	// 82ABB850: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82ABB854: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ABB858: 386B0DB4  addi r3, r11, 0xdb4
	ctx.r[3].s64 = ctx.r[11].s64 + 3508;
	// 82ABB85C: 48337F6D  bl 0x82df37c8
	ctx.lr = 0x82ABB860;
	sub_82DF37C8(ctx, base);
	// 82ABB860: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ABB864: 4082FFDC  bne 0x82abb840
	if !ctx.cr[0].eq {
	pc = 0x82ABB840; continue 'dispatch;
	}
	// 82ABB868: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ABB86C: 386B89B0  addi r3, r11, -0x7650
	ctx.r[3].s64 = ctx.r[11].s64 + -30288;
	// 82ABB870: 4BFFFFC0  b 0x82abb830
	pc = 0x82ABB830; continue 'dispatch;
	// 82ABB874: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 82ABB878: 409A0020  bne cr6, 0x82abb898
	if !ctx.cr[6].eq {
	pc = 0x82ABB898; continue 'dispatch;
	}
	// 82ABB87C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ABB880: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ABB884: 386B89A4  addi r3, r11, -0x765c
	ctx.r[3].s64 = ctx.r[11].s64 + -30300;
	// 82ABB888: 48337F41  bl 0x82df37c8
	ctx.lr = 0x82ABB88C;
	sub_82DF37C8(ctx, base);
	// 82ABB88C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ABB890: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ABB894: 40820008  bne 0x82abb89c
	if !ctx.cr[0].eq {
	pc = 0x82ABB89C; continue 'dispatch;
	}
	// 82ABB898: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82ABB89C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82ABB8A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABB8A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABB8A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ABB8AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABB8B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABB8B0 size=136
    let mut pc: u32 = 0x82ABB8B0;
    'dispatch: loop {
        match pc {
            0x82ABB8B0 => {
    //   block [0x82ABB8B0..0x82ABB938)
	// 82ABB8B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABB8B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABB8B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ABB8BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABB8C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABB8C4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ABB8C8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82ABB8CC: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82ABB8D0: 409A0020  bne cr6, 0x82abb8f0
	if !ctx.cr[6].eq {
	pc = 0x82ABB8F0; continue 'dispatch;
	}
	// 82ABB8D4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82ABB8D8: 419A0048  beq cr6, 0x82abb920
	if ctx.cr[6].eq {
	pc = 0x82ABB920; continue 'dispatch;
	}
	// 82ABB8DC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABB8E0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ABB8E4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ABB8E8: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82ABB8EC: 48000034  b 0x82abb920
	pc = 0x82ABB920; continue 'dispatch;
	// 82ABB8F0: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 82ABB8F4: 419A002C  beq cr6, 0x82abb920
	if ctx.cr[6].eq {
	pc = 0x82ABB920; continue 'dispatch;
	}
	// 82ABB8F8: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82ABB8FC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABB900: 388BEA18  addi r4, r11, -0x15e8
	ctx.r[4].s64 = ctx.r[11].s64 + -5608;
	// 82ABB904: 486EC7F5  bl 0x831a80f8
	ctx.lr = 0x82ABB908;
	sub_831A80F8(ctx, base);
	// 82ABB908: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ABB90C: 4182000C  beq 0x82abb918
	if ctx.cr[0].eq {
	pc = 0x82ABB918; continue 'dispatch;
	}
	// 82ABB910: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82ABB914: 4800000C  b 0x82abb920
	pc = 0x82ABB920; continue 'dispatch;
	// 82ABB918: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ABB91C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ABB920: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ABB924: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABB928: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABB92C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ABB930: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ABB934: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABB938(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABB938 size=48
    let mut pc: u32 = 0x82ABB938;
    'dispatch: loop {
        match pc {
            0x82ABB938 => {
    //   block [0x82ABB938..0x82ABB968)
	// 82ABB938: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABB93C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABB940: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABB944: 80630018  lwz r3, 0x18(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ABB948: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ABB94C: 419A000C  beq cr6, 0x82abb958
	if ctx.cr[6].eq {
	pc = 0x82ABB958; continue 'dispatch;
	}
	// 82ABB950: 480D2BD1  bl 0x82b8e520
	ctx.lr = 0x82ABB954;
	sub_82B8E520(ctx, base);
	// 82ABB954: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82ABB958: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82ABB95C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABB960: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABB964: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABB968(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABB968 size=72
    let mut pc: u32 = 0x82ABB968;
    'dispatch: loop {
        match pc {
            0x82ABB968 => {
    //   block [0x82ABB968..0x82ABB9B0)
	// 82ABB968: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABB96C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABB970: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABB974: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 82ABB978: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82ABB97C: 419A0020  beq cr6, 0x82abb99c
	if ctx.cr[6].eq {
	pc = 0x82ABB99C; continue 'dispatch;
	}
	// 82ABB980: 80630018  lwz r3, 0x18(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ABB984: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ABB988: 419A0014  beq cr6, 0x82abb99c
	if ctx.cr[6].eq {
	pc = 0x82ABB99C; continue 'dispatch;
	}
	// 82ABB98C: 480D2BB5  bl 0x82b8e540
	ctx.lr = 0x82ABB990;
	sub_82B8E540(ctx, base);
	// 82ABB990: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ABB994: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82ABB998: 40820008  bne 0x82abb9a0
	if !ctx.cr[0].eq {
	pc = 0x82ABB9A0; continue 'dispatch;
	}
	// 82ABB99C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ABB9A0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82ABB9A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABB9A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABB9AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABB9B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ABB9B0 size=88
    let mut pc: u32 = 0x82ABB9B0;
    'dispatch: loop {
        match pc {
            0x82ABB9B0 => {
    //   block [0x82ABB9B0..0x82ABBA08)
	// 82ABB9B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABB9B4: 486EC7B9  bl 0x831a816c
	ctx.lr = 0x82ABB9B8;
	sub_831A8130(ctx, base);
	// 82ABB9B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABB9BC: 80630018  lwz r3, 0x18(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ABB9C0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82ABB9C4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82ABB9C8: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82ABB9CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ABB9D0: 419A0030  beq cr6, 0x82abba00
	if ctx.cr[6].eq {
	pc = 0x82ABBA00; continue 'dispatch;
	}
	// 82ABB9D4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82ABB9D8: 480D2C31  bl 0x82b8e608
	ctx.lr = 0x82ABB9DC;
	sub_82B8E608(ctx, base);
	// 82ABB9DC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82ABB9E0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82ABB9E4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABB9E8: C00B001C  lfs f0, 0x1c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ABB9EC: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82ABB9F0: C00B0020  lfs f0, 0x20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ABB9F4: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82ABB9F8: C00B0024  lfs f0, 0x24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ABB9FC: D01D0000  stfs f0, 0(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82ABBA00: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ABBA04: 486EC7B8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABBA08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABBA08 size=72
    let mut pc: u32 = 0x82ABBA08;
    'dispatch: loop {
        match pc {
            0x82ABBA08 => {
    //   block [0x82ABBA08..0x82ABBA50)
	// 82ABBA08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABBA0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABBA10: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABBA14: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 82ABBA18: 419A001C  beq cr6, 0x82abba34
	if ctx.cr[6].eq {
	pc = 0x82ABBA34; continue 'dispatch;
	}
	// 82ABBA1C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82ABBA20: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82ABBA24: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82ABBA28: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82ABBA2C: 4BFFFE85  bl 0x82abb8b0
	ctx.lr = 0x82ABBA30;
	sub_82ABB8B0(ctx, base);
	// 82ABBA30: 48000010  b 0x82abba40
	pc = 0x82ABBA40; continue 'dispatch;
	// 82ABBA34: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82ABBA38: 396BEA18  addi r11, r11, -0x15e8
	ctx.r[11].s64 = ctx.r[11].s64 + -5608;
	// 82ABBA3C: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ABBA40: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82ABBA44: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABBA48: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABBA4C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABBA50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ABBA50 size=152
    let mut pc: u32 = 0x82ABBA50;
    'dispatch: loop {
        match pc {
            0x82ABBA50 => {
    //   block [0x82ABBA50..0x82ABBAE8)
	// 82ABBA50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABBA54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABBA58: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABBA5C: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82ABBA60: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABBA64: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABBA68: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82ABBA6C: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82ABBA70: 815F0030  lwz r10, 0x30(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82ABBA74: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82ABBA78: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82ABBA7C: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82ABBA80: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ABBA84: 40980048  bge cr6, 0x82abbacc
	if !ctx.cr[6].lt {
	pc = 0x82ABBACC; continue 'dispatch;
	}
	// 82ABBA88: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ABBA8C: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 82ABBA90: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82ABBA94: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82ABBA98: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ABBA9C: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82ABBAA0: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82ABBAA4: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82ABBAA8: 4BFFFF09  bl 0x82abb9b0
	ctx.lr = 0x82ABBAAC;
	sub_82ABB9B0(ctx, base);
	// 82ABBAAC: C1A10054  lfs f13, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ABBAB0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82ABBAB4: C0010050  lfs f0, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ABBAB8: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82ABBABC: EC00F828  fsubs f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 82ABBAC0: C1BF0034  lfs f13, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ABBAC4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82ABBAC8: 40980008  bge cr6, 0x82abbad0
	if !ctx.cr[6].lt {
	pc = 0x82ABBAD0; continue 'dispatch;
	}
	// 82ABBACC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ABBAD0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82ABBAD4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABBAD8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABBADC: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ABBAE0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ABBAE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABBAE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ABBAE8 size=284
    let mut pc: u32 = 0x82ABBAE8;
    'dispatch: loop {
        match pc {
            0x82ABBAE8 => {
    //   block [0x82ABBAE8..0x82ABBC04)
	// 82ABBAE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABBAEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABBAF0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ABBAF4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABBAF8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABBAFC: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82ABBB00: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ABBB04: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ABBB08: 4BFFFCE9  bl 0x82abb7f0
	ctx.lr = 0x82ABBB0C;
	sub_82ABB7F0(ctx, base);
	// 82ABBB0C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ABBB10: 418200D8  beq 0x82abbbe8
	if ctx.cr[0].eq {
	pc = 0x82ABBBE8; continue 'dispatch;
	}
	// 82ABBB14: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82ABBB18: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82ABBB1C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82ABBB20: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 82ABBB24: 99410050  stb r10, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u8 ) };
	// 82ABBB28: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82ABBB2C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ABBB30: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82ABBB34: 4BFA2A3D  bl 0x82a5e570
	ctx.lr = 0x82ABBB38;
	sub_82A5E570(ctx, base);
	// 82ABBB38: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABBB3C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82ABBB40: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ABBB44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ABBB48: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82ABBB4C: 419A0024  beq cr6, 0x82abbb70
	if ctx.cr[6].eq {
	pc = 0x82ABBB70; continue 'dispatch;
	}
	// 82ABBB50: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82ABBB54: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82ABBB58: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ABBB5C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82ABBB60: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ABBB64: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82ABBB68: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ABBB6C: 4082FFE8  bne 0x82abbb54
	if !ctx.cr[0].eq {
	pc = 0x82ABBB54; continue 'dispatch;
	}
	// 82ABBB70: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82ABBB74: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ABBB78: 4BA53951  bl 0x8250f4c8
	ctx.lr = 0x82ABBB7C;
	sub_8250F4C8(ctx, base);
	// 82ABBB7C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABBB80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ABBB84: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82ABBB88: 409A0008  bne cr6, 0x82abbb90
	if !ctx.cr[6].eq {
	pc = 0x82ABBB90; continue 'dispatch;
	}
	// 82ABBB8C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ABBB90: 3BE10058  addi r31, r1, 0x58
	ctx.r[31].s64 = ctx.r[1].s64 + 88;
	// 82ABBB94: 4BA4CA85  bl 0x82508618
	ctx.lr = 0x82ABBB98;
	sub_82508618(ctx, base);
	// 82ABBB98: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82ABBB9C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ABBBA0: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 82ABBBA4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82ABBBA8: 388989C0  addi r4, r9, -0x7640
	ctx.r[4].s64 = ctx.r[9].s64 + -30272;
	// 82ABBBAC: 38A00243  li r5, 0x243
	ctx.r[5].s64 = 579;
	// 82ABBBB0: 386B0028  addi r3, r11, 0x28
	ctx.r[3].s64 = ctx.r[11].s64 + 40;
	// 82ABBBB4: C02A08A4  lfs f1, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82ABBBB8: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82ABBBBC: 4839CE85  bl 0x82e58a40
	ctx.lr = 0x82ABBBC0;
	sub_82E58A40(ctx, base);
	// 82ABBBC0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82ABBBC4: 483360CD  bl 0x82df1c90
	ctx.lr = 0x82ABBBC8;
	sub_82DF1C90(ctx, base);
	// 82ABBBC8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82ABBBCC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ABBBD0: 419A0008  beq cr6, 0x82abbbd8
	if ctx.cr[6].eq {
	pc = 0x82ABBBD8; continue 'dispatch;
	}
	// 82ABBBD4: 4B804CBD  bl 0x822c0890
	ctx.lr = 0x82ABBBD8;
	sub_822C0890(ctx, base);
	// 82ABBBD8: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82ABBBDC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ABBBE0: 419A0008  beq cr6, 0x82abbbe8
	if ctx.cr[6].eq {
	pc = 0x82ABBBE8; continue 'dispatch;
	}
	// 82ABBBE4: 4B804CAD  bl 0x822c0890
	ctx.lr = 0x82ABBBE8;
	sub_822C0890(ctx, base);
	// 82ABBBE8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82ABBBEC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82ABBBF0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABBBF4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABBBF8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ABBBFC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ABBC00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABBC08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABBC08 size=76
    let mut pc: u32 = 0x82ABBC08;
    'dispatch: loop {
        match pc {
            0x82ABBC08 => {
    //   block [0x82ABBC08..0x82ABBC54)
	// 82ABBC08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABBC0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABBC10: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABBC14: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABBC18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABBC1C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ABBC20: 396B8A18  addi r11, r11, -0x75e8
	ctx.r[11].s64 = ctx.r[11].s64 + -30184;
	// 82ABBC24: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ABBC28: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ABBC2C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ABBC30: 419A0008  beq cr6, 0x82abbc38
	if ctx.cr[6].eq {
	pc = 0x82ABBC38; continue 'dispatch;
	}
	// 82ABBC34: 4B804C5D  bl 0x822c0890
	ctx.lr = 0x82ABBC38;
	sub_822C0890(ctx, base);
	// 82ABBC38: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 82ABBC3C: 4B9F5665  bl 0x824b12a0
	ctx.lr = 0x82ABBC40;
	sub_824B12A0(ctx, base);
	// 82ABBC40: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82ABBC44: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABBC48: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABBC4C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ABBC50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABBC58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABBC58 size=128
    let mut pc: u32 = 0x82ABBC58;
    'dispatch: loop {
        match pc {
            0x82ABBC58 => {
    //   block [0x82ABBC58..0x82ABBCD8)
	// 82ABBC58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABBC5C: 486EC511  bl 0x831a816c
	ctx.lr = 0x82ABBC60;
	sub_831A8130(ctx, base);
	// 82ABBC60: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABBC64: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82ABBC68: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82ABBC6C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ABBC70: 3BEBE598  addi r31, r11, -0x1a68
	ctx.r[31].s64 = ctx.r[11].s64 + -6760;
	// 82ABBC74: 816AE5A0  lwz r11, -0x1a60(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-6752 as u32) ) } as u64;
	// 82ABBC78: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82ABBC7C: 40820024  bne 0x82abbca0
	if !ctx.cr[0].eq {
	pc = 0x82ABBCA0; continue 'dispatch;
	}
	// 82ABBC80: 3D208256  lis r9, -0x7daa
	ctx.r[9].s64 = -2108293120;
	// 82ABBC84: 3D0082AC  lis r8, -0x7d54
	ctx.r[8].s64 = -2102657024;
	// 82ABBC88: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82ABBC8C: 3929DA70  addi r9, r9, -0x2590
	ctx.r[9].s64 = ctx.r[9].s64 + -9616;
	// 82ABBC90: 3908BA08  addi r8, r8, -0x45f8
	ctx.r[8].s64 = ctx.r[8].s64 + -17912;
	// 82ABBC94: 916AE5A0  stw r11, -0x1a60(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-6752 as u32), ctx.r[11].u32 ) };
	// 82ABBC98: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82ABBC9C: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82ABBCA0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82ABBCA4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82ABBCA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABBCAC: 38BE0008  addi r5, r30, 8
	ctx.r[5].s64 = ctx.r[30].s64 + 8;
	// 82ABBCB0: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 82ABBCB4: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82ABBCB8: 4BB16C69  bl 0x825d2920
	ctx.lr = 0x82ABBCBC;
	sub_825D2920(ctx, base);
	// 82ABBCBC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ABBCC0: 4182000C  beq 0x82abbccc
	if ctx.cr[0].eq {
	pc = 0x82ABBCCC; continue 'dispatch;
	}
	// 82ABBCC4: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82ABBCC8: 48000008  b 0x82abbcd0
	pc = 0x82ABBCD0; continue 'dispatch;
	// 82ABBCCC: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82ABBCD0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82ABBCD4: 486EC4E8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABBCD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82ABBCD8 size=84
    let mut pc: u32 = 0x82ABBCD8;
    'dispatch: loop {
        match pc {
            0x82ABBCD8 => {
    //   block [0x82ABBCD8..0x82ABBD2C)
	// 82ABBCD8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ABBCDC: 90830004  stw r4, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 82ABBCE0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82ABBCE4: 392B8A18  addi r9, r11, -0x75e8
	ctx.r[9].s64 = ctx.r[11].s64 + -30184;
	// 82ABBCE8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ABBCEC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82ABBCF0: 3920FFFF  li r9, -1
	ctx.r[9].s64 = -1;
	// 82ABBCF4: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82ABBCF8: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82ABBCFC: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ABBD00: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82ABBD04: 91630018  stw r11, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82ABBD08: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82ABBD0C: D0030034  stfs f0, 0x34(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82ABBD10: 99630020  stb r11, 0x20(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[11].u8 ) };
	// 82ABBD14: 91230024  stw r9, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[9].u32 ) };
	// 82ABBD18: 91630028  stw r11, 0x28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 82ABBD1C: 9163002C  stw r11, 0x2c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 82ABBD20: 91630030  stw r11, 0x30(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 82ABBD24: 99630038  stb r11, 0x38(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), ctx.r[11].u8 ) };
	// 82ABBD28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABBD30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABBD30 size=76
    let mut pc: u32 = 0x82ABBD30;
    'dispatch: loop {
        match pc {
            0x82ABBD30 => {
    //   block [0x82ABBD30..0x82ABBD7C)
	// 82ABBD30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABBD34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABBD38: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ABBD3C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABBD40: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABBD44: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABBD48: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ABBD4C: 4BFFFEBD  bl 0x82abbc08
	ctx.lr = 0x82ABBD50;
	sub_82ABBC08(ctx, base);
	// 82ABBD50: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ABBD54: 4182000C  beq 0x82abbd60
	if ctx.cr[0].eq {
	pc = 0x82ABBD60; continue 'dispatch;
	}
	// 82ABBD58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABBD5C: 4B80450D  bl 0x822c0268
	ctx.lr = 0x82ABBD60;
	sub_822C0268(ctx, base);
	// 82ABBD60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABBD64: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ABBD68: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABBD6C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABBD70: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ABBD74: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ABBD78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABBD80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ABBD80 size=232
    let mut pc: u32 = 0x82ABBD80;
    'dispatch: loop {
        match pc {
            0x82ABBD80 => {
    //   block [0x82ABBD80..0x82ABBE68)
	// 82ABBD80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABBD84: 486EC3D1  bl 0x831a8154
	ctx.lr = 0x82ABBD88;
	sub_831A8130(ctx, base);
	// 82ABBD88: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABBD8C: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82ABBD90: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 82ABBD94: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82ABBD98: 897A0020  lbz r11, 0x20(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(32 as u32) ) } as u64;
	// 82ABBD9C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ABBDA0: 408200B0  bne 0x82abbe50
	if !ctx.cr[0].eq {
	pc = 0x82ABBE50; continue 'dispatch;
	}
	// 82ABBDA4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ABBDA8: 3AFA0008  addi r23, r26, 8
	ctx.r[23].s64 = ctx.r[26].s64 + 8;
	// 82ABBDAC: 3B6B8880  addi r27, r11, -0x7780
	ctx.r[27].s64 = ctx.r[11].s64 + -30592;
	// 82ABBDB0: 3B20002E  li r25, 0x2e
	ctx.r[25].s64 = 46;
	// 82ABBDB4: 3B800010  li r28, 0x10
	ctx.r[28].s64 = 16;
	// 82ABBDB8: 3BA00020  li r29, 0x20
	ctx.r[29].s64 = 32;
	// 82ABBDBC: 3BC00030  li r30, 0x30
	ctx.r[30].s64 = 48;
	// 82ABBDC0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82ABBDC4: 80980000  lwz r4, 0(r24)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABBDC8: 4BE590A9  bl 0x82914e70
	ctx.lr = 0x82ABBDCC;
	sub_82914E70(ctx, base);
	// 82ABBDCC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ABBDD0: 809B0000  lwz r4, 0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABBDD4: 48337C35  bl 0x82df3a08
	ctx.lr = 0x82ABBDD8;
	sub_82DF3A08(ctx, base);
	// 82ABBDD8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82ABBDDC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82ABBDE0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82ABBDE4: 480C3BFD  bl 0x82b7f9e0
	ctx.lr = 0x82ABBDE8;
	sub_82B7F9E0(ctx, base);
	// 82ABBDE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ABBDEC: 4833763D  bl 0x82df3428
	ctx.lr = 0x82ABBDF0;
	sub_82DF3428(ctx, base);
	// 82ABBDF0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82ABBDF4: 419A002C  beq cr6, 0x82abbe20
	if ctx.cr[6].eq {
	pc = 0x82ABBE20; continue 'dispatch;
	}
	// 82ABBDF8: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82ABBDFC: 13E0FC07  vcmpneb. (lvlx128) v31, v0, v31
	tmp.u32 = ctx.r[31].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82ABBE00: 13DCFC07  vcmpneb. (lvlx128) v30, v28, v31
	tmp.u32 = ctx.r[28].u32 + ctx.r[31].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82ABBE04: 396B0030  addi r11, r11, 0x30
	ctx.r[11].s64 = ctx.r[11].s64 + 48;
	// 82ABBE08: 13BDFC07  vcmpneb. (lvlx128) v29, v29, v31
	tmp.u32 = ctx.r[29].u32 + ctx.r[31].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82ABBE0C: 139EFC07  vcmpneb. (lvlx128) v28, v30, v31
	tmp.u32 = ctx.r[30].u32 + ctx.r[31].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABBE68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABBE68 size=396
    let mut pc: u32 = 0x82ABBE68;
    'dispatch: loop {
        match pc {
            0x82ABBE68 => {
    //   block [0x82ABBE68..0x82ABBFF4)
	// 82ABBE68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABBE6C: 486EC2F5  bl 0x831a8160
	ctx.lr = 0x82ABBE70;
	sub_831A8130(ctx, base);
	// 82ABBE70: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABBE74: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ABBE78: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82ABBE7C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82ABBE80: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82ABBE84: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82ABBE88: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82ABBE8C: 388B89C0  addi r4, r11, -0x7640
	ctx.r[4].s64 = ctx.r[11].s64 + -30272;
	// 82ABBE90: 38A001A5  li r5, 0x1a5
	ctx.r[5].s64 = 421;
	// 82ABBE94: 386000C4  li r3, 0xc4
	ctx.r[3].s64 = 196;
	// 82ABBE98: 48336551  bl 0x82df23e8
	ctx.lr = 0x82ABBE9C;
	sub_82DF23E8(ctx, base);
	// 82ABBE9C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ABBEA0: 41820020  beq 0x82abbec0
	if ctx.cr[0].eq {
	pc = 0x82ABBEC0; continue 'dispatch;
	}
	// 82ABBEA4: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ABBEA8: 57EA1838  slwi r10, r31, 3
	ctx.r[10].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82ABBEAC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82ABBEB0: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82ABBEB4: 480D5DDD  bl 0x82b91c90
	ctx.lr = 0x82ABBEB8;
	sub_82B91C90(ctx, base);
	// 82ABBEB8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82ABBEBC: 48000008  b 0x82abbec4
	pc = 0x82ABBEC4; continue 'dispatch;
	// 82ABBEC0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82ABBEC4: 3BFD0018  addi r31, r29, 0x18
	ctx.r[31].s64 = ctx.r[29].s64 + 24;
	// 82ABBEC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABBECC: 4BEFFCD5  bl 0x829bbba0
	ctx.lr = 0x82ABBED0;
	sub_829BBBA0(ctx, base);
	// 82ABBED0: 807D0018  lwz r3, 0x18(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ABBED4: 480D27AD  bl 0x82b8e680
	ctx.lr = 0x82ABBED8;
	sub_82B8E680(ctx, base);
	// 82ABBED8: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82ABBEDC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ABBEE0: 388B059C  addi r4, r11, 0x59c
	ctx.r[4].s64 = ctx.r[11].s64 + 1436;
	// 82ABBEE4: 48337B25  bl 0x82df3a08
	ctx.lr = 0x82ABBEE8;
	sub_82DF3A08(ctx, base);
	// 82ABBEE8: 817D001C  lwz r11, 0x1c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ABBEEC: 815D0018  lwz r10, 0x18(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ABBEF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ABBEF4: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82ABBEF8: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82ABBEFC: 419A0024  beq cr6, 0x82abbf20
	if ctx.cr[6].eq {
	pc = 0x82ABBF20; continue 'dispatch;
	}
	// 82ABBF00: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82ABBF04: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82ABBF08: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ABBF0C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82ABBF10: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ABBF14: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82ABBF18: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ABBF1C: 4082FFE8  bne 0x82abbf04
	if !ctx.cr[0].eq {
	pc = 0x82ABBF04; continue 'dispatch;
	}
	// 82ABBF20: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABBF24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ABBF28: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82ABBF2C: 409A000C  bne cr6, 0x82abbf38
	if !ctx.cr[6].eq {
	pc = 0x82ABBF38; continue 'dispatch;
	}
	// 82ABBF30: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82ABBF34: 419A000C  beq cr6, 0x82abbf40
	if ctx.cr[6].eq {
	pc = 0x82ABBF40; continue 'dispatch;
	}
	// 82ABBF38: 3BCBFFFC  addi r30, r11, -4
	ctx.r[30].s64 = ctx.r[11].s64 + -4;
	// 82ABBF3C: 48000008  b 0x82abbf44
	pc = 0x82ABBF44; continue 'dispatch;
	// 82ABBF40: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82ABBF44: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82ABBF48: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82ABBF4C: 3B410058  addi r26, r1, 0x58
	ctx.r[26].s64 = ctx.r[1].s64 + 88;
	// 82ABBF50: 4BA4F701  bl 0x8250b650
	ctx.lr = 0x82ABBF54;
	sub_8250B650(ctx, base);
	// 82ABBF54: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82ABBF58: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABBF5C: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82ABBF60: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82ABBF64: 4BA515A5  bl 0x8250d508
	ctx.lr = 0x82ABBF68;
	sub_8250D508(ctx, base);
	// 82ABBF68: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82ABBF6C: 48335D25  bl 0x82df1c90
	ctx.lr = 0x82ABBF70;
	sub_82DF1C90(ctx, base);
	// 82ABBF70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ABBF74: 483374B5  bl 0x82df3428
	ctx.lr = 0x82ABBF78;
	sub_82DF3428(ctx, base);
	// 82ABBF78: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABBF7C: 480D26C5  bl 0x82b8e640
	ctx.lr = 0x82ABBF80;
	sub_82B8E640(ctx, base);
	// 82ABBF80: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABBF84: 480D26CD  bl 0x82b8e650
	ctx.lr = 0x82ABBF88;
	sub_82B8E650(ctx, base);
	// 82ABBF88: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82ABBF8C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABBF90: 480D2701  bl 0x82b8e690
	ctx.lr = 0x82ABBF94;
	sub_82B8E690(ctx, base);
	// 82ABBF94: 3D6082AC  lis r11, -0x7d54
	ctx.r[11].s64 = -2102657024;
	// 82ABBF98: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82ABBF9C: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 82ABBFA0: 396BBAE8  addi r11, r11, -0x4518
	ctx.r[11].s64 = ctx.r[11].s64 + -17688;
	// 82ABBFA4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82ABBFA8: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 82ABBFAC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82ABBFB0: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82ABBFB4: 4BFFFCA5  bl 0x82abbc58
	ctx.lr = 0x82ABBFB8;
	sub_82ABBC58(ctx, base);
	// 82ABBFB8: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82ABBFBC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABBFC0: 480D3849  bl 0x82b8f808
	ctx.lr = 0x82ABBFC4;
	sub_82B8F808(ctx, base);
	// 82ABBFC4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82ABBFC8: 4B80CCF1  bl 0x822c8cb8
	ctx.lr = 0x82ABBFCC;
	sub_822C8CB8(ctx, base);
	// 82ABBFCC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABBFD0: 480D3621  bl 0x82b8f5f0
	ctx.lr = 0x82ABBFD4;
	sub_82B8F5F0(ctx, base);
	// 82ABBFD4: 807C0004  lwz r3, 4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ABBFD8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ABBFDC: 419A0008  beq cr6, 0x82abbfe4
	if ctx.cr[6].eq {
	pc = 0x82ABBFE4; continue 'dispatch;
	}
	// 82ABBFE0: 4B8048B1  bl 0x822c0890
	ctx.lr = 0x82ABBFE4;
	sub_822C0890(ctx, base);
	// 82ABBFE4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82ABBFE8: 48335CA9  bl 0x82df1c90
	ctx.lr = 0x82ABBFEC;
	sub_82DF1C90(ctx, base);
	// 82ABBFEC: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82ABBFF0: 486EC1C0  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABBFF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ABBFF8 size=332
    let mut pc: u32 = 0x82ABBFF8;
    'dispatch: loop {
        match pc {
            0x82ABBFF8 => {
    //   block [0x82ABBFF8..0x82ABC144)
	// 82ABBFF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABBFFC: 486EC169  bl 0x831a8164
	ctx.lr = 0x82ABC000;
	sub_831A8130(ctx, base);
	// 82ABC000: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABC004: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABC008: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82ABC00C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82ABC010: 394A8938  addi r10, r10, -0x76c8
	ctx.r[10].s64 = ctx.r[10].s64 + -30408;
	// 82ABC014: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82ABC018: 813F0024  lwz r9, 0x24(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82ABC01C: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82ABC020: 1D29000C  mulli r9, r9, 0xc
	ctx.r[9].s64 = ctx.r[9].s64 * 12;
	// 82ABC024: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82ABC028: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82ABC02C: 419A001C  beq cr6, 0x82abc048
	if ctx.cr[6].eq {
	pc = 0x82ABC048; continue 'dispatch;
	}
	// 82ABC030: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82ABC034: 419A000C  beq cr6, 0x82abc040
	if ctx.cr[6].eq {
	pc = 0x82ABC040; continue 'dispatch;
	}
	// 82ABC038: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABC03C: 48000010  b 0x82abc04c
	pc = 0x82ABC04C; continue 'dispatch;
	// 82ABC040: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ABC044: 48000008  b 0x82abc04c
	pc = 0x82ABC04C; continue 'dispatch;
	// 82ABC048: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ABC04C: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82ABC050: 409A0028  bne cr6, 0x82abc078
	if !ctx.cr[6].eq {
	pc = 0x82ABC078; continue 'dispatch;
	}
	// 82ABC054: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ABC058: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ABC05C: 419A0008  beq cr6, 0x82abc064
	if ctx.cr[6].eq {
	pc = 0x82ABC064; continue 'dispatch;
	}
	// 82ABC060: 4B804831  bl 0x822c0890
	ctx.lr = 0x82ABC064;
	sub_822C0890(ctx, base);
	// 82ABC064: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82ABC068: 48335C29  bl 0x82df1c90
	ctx.lr = 0x82ABC06C;
	sub_82DF1C90(ctx, base);
	// 82ABC06C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ABC070: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82ABC074: 486EC140  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
	// 82ABC078: 3D40832F  lis r10, -0x7cd1
	ctx.r[10].s64 = -2094071808;
	// 82ABC07C: 813F0028  lwz r9, 0x28(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82ABC080: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82ABC084: 394AE9B8  addi r10, r10, -0x1648
	ctx.r[10].s64 = ctx.r[10].s64 + -5704;
	// 82ABC088: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82ABC08C: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82ABC090: 917F0030  stw r11, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 82ABC094: 7F89582E  lwzx r28, r9, r11
	ctx.r[28].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82ABC098: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82ABC09C: 40980028  bge cr6, 0x82abc0c4
	if !ctx.cr[6].lt {
	pc = 0x82ABC0C4; continue 'dispatch;
	}
	// 82ABC0A0: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ABC0A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ABC0A8: 419A0008  beq cr6, 0x82abc0b0
	if ctx.cr[6].eq {
	pc = 0x82ABC0B0; continue 'dispatch;
	}
	// 82ABC0AC: 4B8047E5  bl 0x822c0890
	ctx.lr = 0x82ABC0B0;
	sub_822C0890(ctx, base);
	// 82ABC0B0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82ABC0B4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82ABC0B8: 48335BD9  bl 0x82df1c90
	ctx.lr = 0x82ABC0BC;
	sub_82DF1C90(ctx, base);
	// 82ABC0BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABC0C0: 4BFFFFB0  b 0x82abc070
	pc = 0x82ABC070; continue 'dispatch;
	// 82ABC0C4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82ABC0C8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82ABC0CC: 48335BA5  bl 0x82df1c70
	ctx.lr = 0x82ABC0D0;
	sub_82DF1C70(ctx, base);
	// 82ABC0D0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ABC0D4: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABC0D8: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82ABC0DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ABC0E0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82ABC0E4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82ABC0E8: 419A0024  beq cr6, 0x82abc10c
	if ctx.cr[6].eq {
	pc = 0x82ABC10C; continue 'dispatch;
	}
	// 82ABC0EC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82ABC0F0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82ABC0F4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ABC0F8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82ABC0FC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ABC100: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82ABC104: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ABC108: 4082FFE8  bne 0x82abc0f0
	if !ctx.cr[0].eq {
	pc = 0x82ABC0F0; continue 'dispatch;
	}
	// 82ABC10C: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82ABC110: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82ABC114: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82ABC118: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABC11C: 4BFFFD4D  bl 0x82abbe68
	ctx.lr = 0x82ABC120;
	sub_82ABBE68(ctx, base);
	// 82ABC120: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ABC124: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ABC128: D01F0034  stfs f0, 0x34(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82ABC12C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABC130: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ABC134: 419A0008  beq cr6, 0x82abc13c
	if ctx.cr[6].eq {
	pc = 0x82ABC13C; continue 'dispatch;
	}
	// 82ABC138: 4B804759  bl 0x822c0890
	ctx.lr = 0x82ABC13C;
	sub_822C0890(ctx, base);
	// 82ABC13C: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 82ABC140: 4BFFFF74  b 0x82abc0b4
	pc = 0x82ABC0B4; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABC148(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABC148 size=160
    let mut pc: u32 = 0x82ABC148;
    'dispatch: loop {
        match pc {
            0x82ABC148 => {
    //   block [0x82ABC148..0x82ABC1E8)
	// 82ABC148: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABC14C: 486EC01D  bl 0x831a8168
	ctx.lr = 0x82ABC150;
	sub_831A8130(ctx, base);
	// 82ABC150: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABC154: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABC158: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ABC15C: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82ABC160: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82ABC164: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82ABC168: 909F0024  stw r4, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[4].u32 ) };
	// 82ABC16C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82ABC170: 90BF002C  stw r5, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[5].u32 ) };
	// 82ABC174: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 82ABC178: 48335AF9  bl 0x82df1c70
	ctx.lr = 0x82ABC17C;
	sub_82DF1C70(ctx, base);
	// 82ABC17C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ABC180: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABC184: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82ABC188: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ABC18C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82ABC190: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82ABC194: 419A0024  beq cr6, 0x82abc1b8
	if ctx.cr[6].eq {
	pc = 0x82ABC1B8; continue 'dispatch;
	}
	// 82ABC198: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82ABC19C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82ABC1A0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ABC1A4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82ABC1A8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ABC1AC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82ABC1B0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ABC1B4: 4082FFE8  bne 0x82abc19c
	if !ctx.cr[0].eq {
	pc = 0x82ABC19C; continue 'dispatch;
	}
	// 82ABC1B8: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82ABC1BC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82ABC1C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABC1C4: 4BFFFE35  bl 0x82abbff8
	ctx.lr = 0x82ABC1C8;
	sub_82ABBFF8(ctx, base);
	// 82ABC1C8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABC1CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ABC1D0: 419A0008  beq cr6, 0x82abc1d8
	if ctx.cr[6].eq {
	pc = 0x82ABC1D8; continue 'dispatch;
	}
	// 82ABC1D4: 4B8046BD  bl 0x822c0890
	ctx.lr = 0x82ABC1D8;
	sub_822C0890(ctx, base);
	// 82ABC1D8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82ABC1DC: 48335AB5  bl 0x82df1c90
	ctx.lr = 0x82ABC1E0;
	sub_82DF1C90(ctx, base);
	// 82ABC1E0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82ABC1E4: 486EBFD4  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABC1E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ABC1E8 size=272
    let mut pc: u32 = 0x82ABC1E8;
    'dispatch: loop {
        match pc {
            0x82ABC1E8 => {
    //   block [0x82ABC1E8..0x82ABC2F8)
	// 82ABC1E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABC1EC: 486EBF79  bl 0x831a8164
	ctx.lr = 0x82ABC1F0;
	sub_831A8130(ctx, base);
	// 82ABC1F0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABC1F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABC1F8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82ABC1FC: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82ABC200: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82ABC204: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82ABC208: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ABC20C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ABC210: 419A0034  beq cr6, 0x82abc244
	if ctx.cr[6].eq {
	pc = 0x82ABC244; continue 'dispatch;
	}
	// 82ABC214: 480D232D  bl 0x82b8e540
	ctx.lr = 0x82ABC218;
	sub_82B8E540(ctx, base);
	// 82ABC218: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ABC21C: 40820028  bne 0x82abc244
	if !ctx.cr[0].eq {
	pc = 0x82ABC244; continue 'dispatch;
	}
	// 82ABC220: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82ABC224: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82ABC228: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 82ABC22C: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 82ABC230: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ABC234: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ABC238: 93DF001C  stw r30, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 82ABC23C: 419A0008  beq cr6, 0x82abc244
	if ctx.cr[6].eq {
	pc = 0x82ABC244; continue 'dispatch;
	}
	// 82ABC240: 4B804651  bl 0x822c0890
	ctx.lr = 0x82ABC244;
	sub_822C0890(ctx, base);
	// 82ABC244: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82ABC248: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82ABC24C: 419A008C  beq cr6, 0x82abc2d8
	if ctx.cr[6].eq {
	pc = 0x82ABC2D8; continue 'dispatch;
	}
	// 82ABC250: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ABC254: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ABC258: 409A0070  bne cr6, 0x82abc2c8
	if !ctx.cr[6].eq {
	pc = 0x82ABC2C8; continue 'dispatch;
	}
	// 82ABC25C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82ABC260: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82ABC264: 48335A0D  bl 0x82df1c70
	ctx.lr = 0x82ABC268;
	sub_82DF1C70(ctx, base);
	// 82ABC268: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ABC26C: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABC270: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ABC274: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82ABC278: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82ABC27C: 419A0024  beq cr6, 0x82abc2a0
	if ctx.cr[6].eq {
	pc = 0x82ABC2A0; continue 'dispatch;
	}
	// 82ABC280: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82ABC284: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82ABC288: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ABC28C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82ABC290: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ABC294: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82ABC298: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ABC29C: 4082FFE8  bne 0x82abc284
	if !ctx.cr[0].eq {
	pc = 0x82ABC284; continue 'dispatch;
	}
	// 82ABC2A0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82ABC2A4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82ABC2A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABC2AC: 4BFFFD4D  bl 0x82abbff8
	ctx.lr = 0x82ABC2B0;
	sub_82ABBFF8(ctx, base);
	// 82ABC2B0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ABC2B4: 40820024  bne 0x82abc2d8
	if !ctx.cr[0].eq {
	pc = 0x82ABC2D8; continue 'dispatch;
	}
	// 82ABC2B8: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82ABC2BC: 93DF0028  stw r30, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[30].u32 ) };
	// 82ABC2C0: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 82ABC2C4: 48000014  b 0x82abc2d8
	pc = 0x82ABC2D8; continue 'dispatch;
	// 82ABC2C8: C01F0034  lfs f0, 0x34(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ABC2CC: C1BD0000  lfs f13, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ABC2D0: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82ABC2D4: D01F0034  stfs f0, 0x34(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82ABC2D8: 807C0004  lwz r3, 4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ABC2DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ABC2E0: 419A0008  beq cr6, 0x82abc2e8
	if ctx.cr[6].eq {
	pc = 0x82ABC2E8; continue 'dispatch;
	}
	// 82ABC2E4: 4B8045AD  bl 0x822c0890
	ctx.lr = 0x82ABC2E8;
	sub_822C0890(ctx, base);
	// 82ABC2E8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82ABC2EC: 483359A5  bl 0x82df1c90
	ctx.lr = 0x82ABC2F0;
	sub_82DF1C90(ctx, base);
	// 82ABC2F0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82ABC2F4: 486EBEC0  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABC2F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABC2F8 size=76
    let mut pc: u32 = 0x82ABC2F8;
    'dispatch: loop {
        match pc {
            0x82ABC2F8 => {
    //   block [0x82ABC2F8..0x82ABC344)
	// 82ABC2F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABC2FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABC300: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ABC304: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABC308: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABC30C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABC310: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ABC314: 4839D36D  bl 0x82e59680
	ctx.lr = 0x82ABC318;
	sub_82E59680(ctx, base);
	// 82ABC318: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ABC31C: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 82ABC320: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABC324: 396B8A20  addi r11, r11, -0x75e0
	ctx.r[11].s64 = ctx.r[11].s64 + -30176;
	// 82ABC328: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ABC32C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ABC330: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABC334: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABC338: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ABC33C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ABC340: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABC348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABC348 size=76
    let mut pc: u32 = 0x82ABC348;
    'dispatch: loop {
        match pc {
            0x82ABC348 => {
    //   block [0x82ABC348..0x82ABC394)
	// 82ABC348: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABC34C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABC350: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ABC354: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABC358: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABC35C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABC360: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ABC364: 4839D31D  bl 0x82e59680
	ctx.lr = 0x82ABC368;
	sub_82E59680(ctx, base);
	// 82ABC368: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ABC36C: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 82ABC370: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABC374: 396B8A28  addi r11, r11, -0x75d8
	ctx.r[11].s64 = ctx.r[11].s64 + -30168;
	// 82ABC378: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ABC37C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ABC380: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABC384: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABC388: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ABC38C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ABC390: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABC398(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABC398 size=76
    let mut pc: u32 = 0x82ABC398;
    'dispatch: loop {
        match pc {
            0x82ABC398 => {
    //   block [0x82ABC398..0x82ABC3E4)
	// 82ABC398: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABC39C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABC3A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ABC3A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABC3A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABC3AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABC3B0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ABC3B4: 4839D2CD  bl 0x82e59680
	ctx.lr = 0x82ABC3B8;
	sub_82E59680(ctx, base);
	// 82ABC3B8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ABC3BC: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 82ABC3C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABC3C4: 396B8A30  addi r11, r11, -0x75d0
	ctx.r[11].s64 = ctx.r[11].s64 + -30160;
	// 82ABC3C8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ABC3CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ABC3D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABC3D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABC3D8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ABC3DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ABC3E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABC3E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABC3E8 size=76
    let mut pc: u32 = 0x82ABC3E8;
    'dispatch: loop {
        match pc {
            0x82ABC3E8 => {
    //   block [0x82ABC3E8..0x82ABC434)
	// 82ABC3E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABC3EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABC3F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ABC3F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABC3F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABC3FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABC400: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ABC404: 4839D27D  bl 0x82e59680
	ctx.lr = 0x82ABC408;
	sub_82E59680(ctx, base);
	// 82ABC408: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ABC40C: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 82ABC410: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABC414: 396B8A38  addi r11, r11, -0x75c8
	ctx.r[11].s64 = ctx.r[11].s64 + -30152;
	// 82ABC418: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ABC41C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ABC420: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABC424: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABC428: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ABC42C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ABC430: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABC438(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ABC438 size=76
    let mut pc: u32 = 0x82ABC438;
    'dispatch: loop {
        match pc {
            0x82ABC438 => {
    //   block [0x82ABC438..0x82ABC484)
	// 82ABC438: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABC43C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABC440: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABC444: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82ABC448: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABC44C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABC450: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82ABC454: 4839D22D  bl 0x82e59680
	ctx.lr = 0x82ABC458;
	sub_82E59680(ctx, base);
	// 82ABC458: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ABC45C: D3FF0018  stfs f31, 0x18(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82ABC460: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABC464: 396B8A40  addi r11, r11, -0x75c0
	ctx.r[11].s64 = ctx.r[11].s64 + -30144;
	// 82ABC468: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ABC46C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ABC470: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABC474: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABC478: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ABC47C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ABC480: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABC488(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABC488 size=76
    let mut pc: u32 = 0x82ABC488;
    'dispatch: loop {
        match pc {
            0x82ABC488 => {
    //   block [0x82ABC488..0x82ABC4D4)
	// 82ABC488: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABC48C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABC490: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ABC494: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABC498: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABC49C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABC4A0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ABC4A4: 4839D1DD  bl 0x82e59680
	ctx.lr = 0x82ABC4A8;
	sub_82E59680(ctx, base);
	// 82ABC4A8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ABC4AC: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 82ABC4B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABC4B4: 396B8A48  addi r11, r11, -0x75b8
	ctx.r[11].s64 = ctx.r[11].s64 + -30136;
	// 82ABC4B8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ABC4BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ABC4C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABC4C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABC4C8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ABC4CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ABC4D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABC4D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABC4D8 size=68
    let mut pc: u32 = 0x82ABC4D8;
    'dispatch: loop {
        match pc {
            0x82ABC4D8 => {
    //   block [0x82ABC4D8..0x82ABC51C)
	// 82ABC4D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABC4DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABC4E0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABC4E4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABC4E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABC4EC: 4839D1B5  bl 0x82e596a0
	ctx.lr = 0x82ABC4F0;
	sub_82E596A0(ctx, base);
	// 82ABC4F0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ABC4F4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82ABC4F8: 396B8A50  addi r11, r11, -0x75b0
	ctx.r[11].s64 = ctx.r[11].s64 + -30128;
	// 82ABC4FC: 995F0018  stb r10, 0x18(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[10].u8 ) };
	// 82ABC500: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABC504: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ABC508: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82ABC50C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABC510: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABC514: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ABC518: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABC520(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABC520 size=68
    let mut pc: u32 = 0x82ABC520;
    'dispatch: loop {
        match pc {
            0x82ABC520 => {
    //   block [0x82ABC520..0x82ABC564)
	// 82ABC520: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABC524: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABC528: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABC52C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABC530: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABC534: 4839D16D  bl 0x82e596a0
	ctx.lr = 0x82ABC538;
	sub_82E596A0(ctx, base);
	// 82ABC538: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ABC53C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82ABC540: 396B8A58  addi r11, r11, -0x75a8
	ctx.r[11].s64 = ctx.r[11].s64 + -30120;
	// 82ABC544: 995F0018  stb r10, 0x18(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[10].u8 ) };
	// 82ABC548: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABC54C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ABC550: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82ABC554: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABC558: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABC55C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ABC560: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABC568(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABC568 size=68
    let mut pc: u32 = 0x82ABC568;
    'dispatch: loop {
        match pc {
            0x82ABC568 => {
    //   block [0x82ABC568..0x82ABC5AC)
	// 82ABC568: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABC56C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABC570: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABC574: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABC578: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABC57C: 4839D125  bl 0x82e596a0
	ctx.lr = 0x82ABC580;
	sub_82E596A0(ctx, base);
	// 82ABC580: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ABC584: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82ABC588: 396B8A60  addi r11, r11, -0x75a0
	ctx.r[11].s64 = ctx.r[11].s64 + -30112;
	// 82ABC58C: 915F0018  stw r10, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82ABC590: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABC594: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ABC598: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82ABC59C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABC5A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABC5A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ABC5A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABC5B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABC5B0 size=72
    let mut pc: u32 = 0x82ABC5B0;
    'dispatch: loop {
        match pc {
            0x82ABC5B0 => {
    //   block [0x82ABC5B0..0x82ABC5F8)
	// 82ABC5B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABC5B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABC5B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABC5BC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABC5C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABC5C4: 4839D0DD  bl 0x82e596a0
	ctx.lr = 0x82ABC5C8;
	sub_82E596A0(ctx, base);
	// 82ABC5C8: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82ABC5CC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ABC5D0: 394A8A68  addi r10, r10, -0x7598
	ctx.r[10].s64 = ctx.r[10].s64 + -30104;
	// 82ABC5D4: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82ABC5D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABC5DC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82ABC5E0: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82ABC5E4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82ABC5E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABC5EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABC5F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ABC5F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABC5F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABC5F8 size=68
    let mut pc: u32 = 0x82ABC5F8;
    'dispatch: loop {
        match pc {
            0x82ABC5F8 => {
    //   block [0x82ABC5F8..0x82ABC63C)
	// 82ABC5F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABC5FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABC600: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABC604: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABC608: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABC60C: 4839D095  bl 0x82e596a0
	ctx.lr = 0x82ABC610;
	sub_82E596A0(ctx, base);
	// 82ABC610: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ABC614: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82ABC618: 396B8A70  addi r11, r11, -0x7590
	ctx.r[11].s64 = ctx.r[11].s64 + -30096;
	// 82ABC61C: 995F0018  stb r10, 0x18(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[10].u8 ) };
	// 82ABC620: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABC624: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ABC628: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82ABC62C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABC630: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABC634: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ABC638: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABC640(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABC640 size=68
    let mut pc: u32 = 0x82ABC640;
    'dispatch: loop {
        match pc {
            0x82ABC640 => {
    //   block [0x82ABC640..0x82ABC684)
	// 82ABC640: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABC644: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABC648: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABC64C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABC650: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABC654: 4839D04D  bl 0x82e596a0
	ctx.lr = 0x82ABC658;
	sub_82E596A0(ctx, base);
	// 82ABC658: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ABC65C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82ABC660: 396B8A78  addi r11, r11, -0x7588
	ctx.r[11].s64 = ctx.r[11].s64 + -30088;
	// 82ABC664: 995F0018  stb r10, 0x18(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[10].u8 ) };
	// 82ABC668: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABC66C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ABC670: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82ABC674: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABC678: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABC67C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ABC680: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABC688(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABC688 size=68
    let mut pc: u32 = 0x82ABC688;
    'dispatch: loop {
        match pc {
            0x82ABC688 => {
    //   block [0x82ABC688..0x82ABC6CC)
	// 82ABC688: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABC68C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABC690: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABC694: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABC698: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABC69C: 4839D005  bl 0x82e596a0
	ctx.lr = 0x82ABC6A0;
	sub_82E596A0(ctx, base);
	// 82ABC6A0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ABC6A4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82ABC6A8: 396B8A80  addi r11, r11, -0x7580
	ctx.r[11].s64 = ctx.r[11].s64 + -30080;
	// 82ABC6AC: 915F0018  stw r10, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82ABC6B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABC6B4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ABC6B8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82ABC6BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABC6C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABC6C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ABC6C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABC6D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABC6D0 size=68
    let mut pc: u32 = 0x82ABC6D0;
    'dispatch: loop {
        match pc {
            0x82ABC6D0 => {
    //   block [0x82ABC6D0..0x82ABC714)
	// 82ABC6D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABC6D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABC6D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABC6DC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABC6E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABC6E4: 4839CFBD  bl 0x82e596a0
	ctx.lr = 0x82ABC6E8;
	sub_82E596A0(ctx, base);
	// 82ABC6E8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ABC6EC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82ABC6F0: 396B8A88  addi r11, r11, -0x7578
	ctx.r[11].s64 = ctx.r[11].s64 + -30072;
	// 82ABC6F4: 995F0018  stb r10, 0x18(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[10].u8 ) };
	// 82ABC6F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABC6FC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ABC700: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82ABC704: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABC708: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABC70C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ABC710: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABC718(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABC718 size=60
    let mut pc: u32 = 0x82ABC718;
    'dispatch: loop {
        match pc {
            0x82ABC718 => {
    //   block [0x82ABC718..0x82ABC754)
	// 82ABC718: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABC71C: 486EBA51  bl 0x831a816c
	ctx.lr = 0x82ABC720;
	sub_831A8130(ctx, base);
	// 82ABC720: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABC724: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABC728: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ABC72C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82ABC730: 4839CF51  bl 0x82e59680
	ctx.lr = 0x82ABC734;
	sub_82E59680(ctx, base);
	// 82ABC734: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ABC738: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 82ABC73C: 9BBF001C  stb r29, 0x1c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[29].u8 ) };
	// 82ABC740: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABC744: 396B8A90  addi r11, r11, -0x7570
	ctx.r[11].s64 = ctx.r[11].s64 + -30064;
	// 82ABC748: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ABC74C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ABC750: 486EBA6C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABC758(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABC758 size=76
    let mut pc: u32 = 0x82ABC758;
    'dispatch: loop {
        match pc {
            0x82ABC758 => {
    //   block [0x82ABC758..0x82ABC7A4)
	// 82ABC758: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABC75C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABC760: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABC764: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABC768: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABC76C: 4839CF35  bl 0x82e596a0
	ctx.lr = 0x82ABC770;
	sub_82E596A0(ctx, base);
	// 82ABC770: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82ABC774: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ABC778: 394A8A98  addi r10, r10, -0x7568
	ctx.r[10].s64 = ctx.r[10].s64 + -30056;
	// 82ABC77C: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82ABC780: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABC784: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82ABC788: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82ABC78C: 997F0020  stb r11, 0x20(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u8 ) };
	// 82ABC790: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82ABC794: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABC798: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABC79C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ABC7A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABC7A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ABC7A8 size=120
    let mut pc: u32 = 0x82ABC7A8;
    'dispatch: loop {
        match pc {
            0x82ABC7A8 => {
    //   block [0x82ABC7A8..0x82ABC820)
	// 82ABC7A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABC7AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABC7B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ABC7B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABC7B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABC7BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABC7C0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ABC7C4: 4839CEDD  bl 0x82e596a0
	ctx.lr = 0x82ABC7C8;
	sub_82E596A0(ctx, base);
	// 82ABC7C8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ABC7CC: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82ABC7D0: 396B8AA0  addi r11, r11, -0x7560
	ctx.r[11].s64 = ctx.r[11].s64 + -30048;
	// 82ABC7D4: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 82ABC7D8: 394A6910  addi r10, r10, 0x6910
	ctx.r[10].s64 = ctx.r[10].s64 + 26896;
	// 82ABC7DC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ABC7E0: 39000040  li r8, 0x40
	ctx.r[8].s64 = 64;
	// 82ABC7E4: 13E0F0C7  vcmpequd (lvx128) v31, v0, v30
	tmp.u32 = ctx.r[30].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82ABC7E8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82ABC7EC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABC820(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ABC820 size=92
    let mut pc: u32 = 0x82ABC820;
    'dispatch: loop {
        match pc {
            0x82ABC820 => {
    //   block [0x82ABC820..0x82ABC87C)
	// 82ABC820: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABC824: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABC828: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABC82C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABC830: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABC834: 4839CE6D  bl 0x82e596a0
	ctx.lr = 0x82ABC838;
	sub_82E596A0(ctx, base);
	// 82ABC838: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82ABC83C: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82ABC840: 392B6910  addi r9, r11, 0x6910
	ctx.r[9].s64 = ctx.r[11].s64 + 26896;
	// 82ABC844: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 82ABC848: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ABC84C: 394A8AA8  addi r10, r10, -0x7558
	ctx.r[10].s64 = ctx.r[10].s64 + -30040;
	// 82ABC850: 997F0018  stb r11, 0x18(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u8 ) };
	// 82ABC854: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABC858: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82ABC85C: 13E048C7  vcmpequd (lvx128) v31, v0, v9
	tmp.u32 = ctx.r[9].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABC880(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ABC880 size=104
    let mut pc: u32 = 0x82ABC880;
    'dispatch: loop {
        match pc {
            0x82ABC880 => {
    //   block [0x82ABC880..0x82ABC8E8)
	// 82ABC880: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABC884: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABC888: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABC88C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABC890: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABC894: 4839CE0D  bl 0x82e596a0
	ctx.lr = 0x82ABC898;
	sub_82E596A0(ctx, base);
	// 82ABC898: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82ABC89C: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82ABC8A0: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 82ABC8A4: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 82ABC8A8: 394A8AB0  addi r10, r10, -0x7550
	ctx.r[10].s64 = ctx.r[10].s64 + -30032;
	// 82ABC8AC: 39000030  li r8, 0x30
	ctx.r[8].s64 = 48;
	// 82ABC8B0: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 82ABC8B4: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82ABC8B8: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82ABC8BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABC8E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ABC8E8 size=120
    let mut pc: u32 = 0x82ABC8E8;
    'dispatch: loop {
        match pc {
            0x82ABC8E8 => {
    //   block [0x82ABC8E8..0x82ABC960)
	// 82ABC8E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABC8EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABC8F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABC8F4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABC8F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABC8FC: 4839CDA5  bl 0x82e596a0
	ctx.lr = 0x82ABC900;
	sub_82E596A0(ctx, base);
	// 82ABC900: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82ABC904: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82ABC908: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 82ABC90C: 3D208332  lis r9, -0x7cce
	ctx.r[9].s64 = -2093875200;
	// 82ABC910: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 82ABC914: 394A8AB8  addi r10, r10, -0x7548
	ctx.r[10].s64 = ctx.r[10].s64 + -30024;
	// 82ABC918: 38E9BA80  addi r7, r9, -0x4580
	ctx.r[7].s64 = ctx.r[9].s64 + -17792;
	// 82ABC91C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82ABC920: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82ABC924: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABC960(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ABC960 size=88
    let mut pc: u32 = 0x82ABC960;
    'dispatch: loop {
        match pc {
            0x82ABC960 => {
    //   block [0x82ABC960..0x82ABC9B8)
	// 82ABC960: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABC964: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABC968: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABC96C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABC970: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABC974: 4839CD2D  bl 0x82e596a0
	ctx.lr = 0x82ABC978;
	sub_82E596A0(ctx, base);
	// 82ABC978: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82ABC97C: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82ABC980: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 82ABC984: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 82ABC988: 394A8AC0  addi r10, r10, -0x7540
	ctx.r[10].s64 = ctx.r[10].s64 + -30016;
	// 82ABC98C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82ABC990: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82ABC994: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABC998: 911F0018  stw r8, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[8].u32 ) };
	// 82ABC99C: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABC9B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ABC9B8 size=104
    let mut pc: u32 = 0x82ABC9B8;
    'dispatch: loop {
        match pc {
            0x82ABC9B8 => {
    //   block [0x82ABC9B8..0x82ABCA20)
	// 82ABC9B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABC9BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABC9C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ABC9C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABC9C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABC9CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABC9D0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ABC9D4: 4839CCCD  bl 0x82e596a0
	ctx.lr = 0x82ABC9D8;
	sub_82E596A0(ctx, base);
	// 82ABC9D8: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82ABC9DC: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 82ABC9E0: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82ABC9E4: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 82ABC9E8: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 82ABC9EC: 394A8AC8  addi r10, r10, -0x7538
	ctx.r[10].s64 = ctx.r[10].s64 + -30008;
	// 82ABC9F0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82ABC9F4: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82ABC9F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABC9FC: 991F001C  stb r8, 0x1c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[8].u8 ) };
	// 82ABCA00: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABCA20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ABCA20 size=84
    let mut pc: u32 = 0x82ABCA20;
    'dispatch: loop {
        match pc {
            0x82ABCA20 => {
    //   block [0x82ABCA20..0x82ABCA74)
	// 82ABCA20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABCA24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABCA28: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ABCA2C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABCA30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABCA34: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ABCA38: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABCA3C: 389E0004  addi r4, r30, 4
	ctx.r[4].s64 = ctx.r[30].s64 + 4;
	// 82ABCA40: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82ABCA44: C01E0000  lfs f0, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ABCA48: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82ABCA4C: 48337185  bl 0x82df3bd0
	ctx.lr = 0x82ABCA50;
	sub_82DF3BD0(ctx, base);
	// 82ABCA50: 897E0008  lbz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ABCA54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABCA58: 997F0008  stb r11, 8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u8 ) };
	// 82ABCA5C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ABCA60: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABCA64: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABCA68: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ABCA6C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ABCA70: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABCA78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ABCA78 size=8
    let mut pc: u32 = 0x82ABCA78;
    'dispatch: loop {
        match pc {
            0x82ABCA78 => {
    //   block [0x82ABCA78..0x82ABCA80)
	// 82ABCA78: 88630020  lbz r3, 0x20(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 82ABCA7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABCA80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ABCA80 size=104
    let mut pc: u32 = 0x82ABCA80;
    'dispatch: loop {
        match pc {
            0x82ABCA80 => {
    //   block [0x82ABCA80..0x82ABCAE8)
	// 82ABCA80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABCA84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABCA88: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ABCA8C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABCA90: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABCA94: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ABCA98: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABCA9C: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82ABCAA0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82ABCAA4: 394A8AD4  addi r10, r10, -0x752c
	ctx.r[10].s64 = ctx.r[10].s64 + -29996;
	// 82ABCAA8: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ABCAAC: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 82ABCAB0: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82ABCAB4: 909F0008  stw r4, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 82ABCAB8: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82ABCABC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82ABCAC0: 93DF0010  stw r30, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 82ABCAC4: 4833662D  bl 0x82df30f0
	ctx.lr = 0x82ABCAC8;
	sub_82DF30F0(ctx, base);
	// 82ABCAC8: 9BDF0020  stb r30, 0x20(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 82ABCACC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABCAD0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ABCAD4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABCAD8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABCADC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ABCAE0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ABCAE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABCAE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABCAE8 size=92
    let mut pc: u32 = 0x82ABCAE8;
    'dispatch: loop {
        match pc {
            0x82ABCAE8 => {
    //   block [0x82ABCAE8..0x82ABCB44)
	// 82ABCAE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABCAEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABCAF0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ABCAF4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABCAF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABCAFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABCB00: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ABCB04: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 82ABCB08: 396B8AD4  addi r11, r11, -0x752c
	ctx.r[11].s64 = ctx.r[11].s64 + -29996;
	// 82ABCB0C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ABCB10: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ABCB14: 48336915  bl 0x82df3428
	ctx.lr = 0x82ABCB18;
	sub_82DF3428(ctx, base);
	// 82ABCB18: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ABCB1C: 4182000C  beq 0x82abcb28
	if ctx.cr[0].eq {
	pc = 0x82ABCB28; continue 'dispatch;
	}
	// 82ABCB20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABCB24: 4B803745  bl 0x822c0268
	ctx.lr = 0x82ABCB28;
	sub_822C0268(ctx, base);
	// 82ABCB28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABCB2C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ABCB30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABCB34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABCB38: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ABCB3C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ABCB40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABCB48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABCB48 size=88
    let mut pc: u32 = 0x82ABCB48;
    'dispatch: loop {
        match pc {
            0x82ABCB48 => {
    //   block [0x82ABCB48..0x82ABCBA0)
	// 82ABCB48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABCB4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABCB50: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABCB54: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABCB58: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82ABCB5C: 548A103A  slwi r10, r4, 2
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82ABCB60: 396BEC4C  addi r11, r11, -0x13b4
	ctx.r[11].s64 = ctx.r[11].s64 + -5044;
	// 82ABCB64: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABCB68: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82ABCB6C: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 82ABCB70: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82ABCB74: 913F000C  stw r9, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82ABCB78: 5564003E  slwi r4, r11, 0
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82ABCB7C: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82ABCB80: 4BFFFEA1  bl 0x82abca20
	ctx.lr = 0x82ABCB84;
	sub_82ABCA20(ctx, base);
	// 82ABCB84: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82ABCB88: 997F0020  stb r11, 0x20(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u8 ) };
	// 82ABCB8C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82ABCB90: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABCB94: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABCB98: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ABCB9C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABCBA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ABCBA0 size=252
    let mut pc: u32 = 0x82ABCBA0;
    'dispatch: loop {
        match pc {
            0x82ABCBA0 => {
    //   block [0x82ABCBA0..0x82ABCC9C)
	// 82ABCBA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABCBA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABCBA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ABCBAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABCBB0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABCBB4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82ABCBB8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABCBBC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82ABCBC0: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82ABCBC4: 38BF001C  addi r5, r31, 0x1c
	ctx.r[5].s64 = ctx.r[31].s64 + 28;
	// 82ABCBC8: 389F0018  addi r4, r31, 0x18
	ctx.r[4].s64 = ctx.r[31].s64 + 24;
	// 82ABCBCC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82ABCBD0: 4BFA19A1  bl 0x82a5e570
	ctx.lr = 0x82ABCBD4;
	sub_82A5E570(ctx, base);
	// 82ABCBD4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABCBD8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82ABCBDC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ABCBE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ABCBE4: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82ABCBE8: 419A0024  beq cr6, 0x82abcc0c
	if ctx.cr[6].eq {
	pc = 0x82ABCC0C; continue 'dispatch;
	}
	// 82ABCBEC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82ABCBF0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82ABCBF4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ABCBF8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82ABCBFC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ABCC00: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82ABCC04: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ABCC08: 4082FFE8  bne 0x82abcbf0
	if !ctx.cr[0].eq {
	pc = 0x82ABCBF0; continue 'dispatch;
	}
	// 82ABCC0C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82ABCC10: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ABCC14: 4BA528B5  bl 0x8250f4c8
	ctx.lr = 0x82ABCC18;
	sub_8250F4C8(ctx, base);
	// 82ABCC18: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABCC1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ABCC20: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82ABCC24: 409A0008  bne cr6, 0x82abcc2c
	if !ctx.cr[6].eq {
	pc = 0x82ABCC2C; continue 'dispatch;
	}
	// 82ABCC28: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ABCC2C: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 82ABCC30: 4BA4B9E9  bl 0x82508618
	ctx.lr = 0x82ABCC34;
	sub_82508618(ctx, base);
	// 82ABCC34: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82ABCC38: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ABCC3C: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 82ABCC40: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82ABCC44: 38898AD8  addi r4, r9, -0x7528
	ctx.r[4].s64 = ctx.r[9].s64 + -29992;
	// 82ABCC48: 38A000C8  li r5, 0xc8
	ctx.r[5].s64 = 200;
	// 82ABCC4C: 386B0028  addi r3, r11, 0x28
	ctx.r[3].s64 = ctx.r[11].s64 + 40;
	// 82ABCC50: C02A964C  lfs f1, -0x69b4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82ABCC54: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82ABCC58: 4839BDE9  bl 0x82e58a40
	ctx.lr = 0x82ABCC5C;
	sub_82E58A40(ctx, base);
	// 82ABCC5C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82ABCC60: 48335031  bl 0x82df1c90
	ctx.lr = 0x82ABCC64;
	sub_82DF1C90(ctx, base);
	// 82ABCC64: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82ABCC68: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ABCC6C: 419A0008  beq cr6, 0x82abcc74
	if ctx.cr[6].eq {
	pc = 0x82ABCC74; continue 'dispatch;
	}
	// 82ABCC70: 4B803C21  bl 0x822c0890
	ctx.lr = 0x82ABCC74;
	sub_822C0890(ctx, base);
	// 82ABCC74: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82ABCC78: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ABCC7C: 419A0008  beq cr6, 0x82abcc84
	if ctx.cr[6].eq {
	pc = 0x82ABCC84; continue 'dispatch;
	}
	// 82ABCC80: 4B803C11  bl 0x822c0890
	ctx.lr = 0x82ABCC84;
	sub_822C0890(ctx, base);
	// 82ABCC84: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82ABCC88: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABCC8C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABCC90: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ABCC94: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ABCC98: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABCCA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ABCCA0 size=360
    let mut pc: u32 = 0x82ABCCA0;
    'dispatch: loop {
        match pc {
            0x82ABCCA0 => {
    //   block [0x82ABCCA0..0x82ABCE08)
	// 82ABCCA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABCCA4: 486EB4C5  bl 0x831a8168
	ctx.lr = 0x82ABCCA8;
	sub_831A8130(ctx, base);
	// 82ABCCA8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABCCAC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABCCB0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82ABCCB4: 3BDF0020  addi r30, r31, 0x20
	ctx.r[30].s64 = ctx.r[31].s64 + 32;
	// 82ABCCB8: 897F0020  lbz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82ABCCBC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ABCCC0: 41820140  beq 0x82abce00
	if ctx.cr[0].eq {
	pc = 0x82ABCE00; continue 'dispatch;
	}
	// 82ABCCC4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ABCCC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ABCCCC: 388B8ACC  addi r4, r11, -0x7534
	ctx.r[4].s64 = ctx.r[11].s64 + -30004;
	// 82ABCCD0: 48336D39  bl 0x82df3a08
	ctx.lr = 0x82ABCCD4;
	sub_82DF3A08(ctx, base);
	// 82ABCCD4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82ABCCD8: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 82ABCCDC: 4833662D  bl 0x82df3308
	ctx.lr = 0x82ABCCE0;
	sub_82DF3308(ctx, base);
	// 82ABCCE0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82ABCCE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ABCCE8: 48336741  bl 0x82df3428
	ctx.lr = 0x82ABCCEC;
	sub_82DF3428(ctx, base);
	// 82ABCCEC: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ABCCF0: 418200C0  beq 0x82abcdb0
	if ctx.cr[0].eq {
	pc = 0x82ABCDB0; continue 'dispatch;
	}
	// 82ABCCF4: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82ABCCF8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82ABCCFC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82ABCD00: 4BFE1491  bl 0x82a9e190
	ctx.lr = 0x82ABCD04;
	sub_82A9E190(ctx, base);
	// 82ABCD04: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABCD08: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82ABCD0C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ABCD10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ABCD14: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82ABCD18: 419A0024  beq cr6, 0x82abcd3c
	if ctx.cr[6].eq {
	pc = 0x82ABCD3C; continue 'dispatch;
	}
	// 82ABCD1C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82ABCD20: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82ABCD24: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ABCD28: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82ABCD2C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ABCD30: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82ABCD34: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ABCD38: 4082FFE8  bne 0x82abcd20
	if !ctx.cr[0].eq {
	pc = 0x82ABCD20; continue 'dispatch;
	}
	// 82ABCD3C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82ABCD40: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ABCD44: 4BA52785  bl 0x8250f4c8
	ctx.lr = 0x82ABCD48;
	sub_8250F4C8(ctx, base);
	// 82ABCD48: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABCD4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ABCD50: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82ABCD54: 409A0008  bne cr6, 0x82abcd5c
	if !ctx.cr[6].eq {
	pc = 0x82ABCD5C; continue 'dispatch;
	}
	// 82ABCD58: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ABCD5C: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 82ABCD60: 4BA4B8B9  bl 0x82508618
	ctx.lr = 0x82ABCD64;
	sub_82508618(ctx, base);
	// 82ABCD64: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ABCD68: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82ABCD6C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82ABCD70: 388A8AD8  addi r4, r10, -0x7528
	ctx.r[4].s64 = ctx.r[10].s64 + -29992;
	// 82ABCD74: 38A00092  li r5, 0x92
	ctx.r[5].s64 = 146;
	// 82ABCD78: 386B0028  addi r3, r11, 0x28
	ctx.r[3].s64 = ctx.r[11].s64 + 40;
	// 82ABCD7C: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82ABCD80: 4839A269  bl 0x82e56fe8
	ctx.lr = 0x82ABCD84;
	sub_82E56FE8(ctx, base);
	// 82ABCD84: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82ABCD88: 48334F09  bl 0x82df1c90
	ctx.lr = 0x82ABCD8C;
	sub_82DF1C90(ctx, base);
	// 82ABCD8C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82ABCD90: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ABCD94: 419A0008  beq cr6, 0x82abcd9c
	if ctx.cr[6].eq {
	pc = 0x82ABCD9C; continue 'dispatch;
	}
	// 82ABCD98: 4B803AF9  bl 0x822c0890
	ctx.lr = 0x82ABCD9C;
	sub_822C0890(ctx, base);
	// 82ABCD9C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82ABCDA0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ABCDA4: 419A005C  beq cr6, 0x82abce00
	if ctx.cr[6].eq {
	pc = 0x82ABCE00; continue 'dispatch;
	}
	// 82ABCDA8: 4B803AE9  bl 0x822c0890
	ctx.lr = 0x82ABCDAC;
	sub_822C0890(ctx, base);
	// 82ABCDAC: 48000054  b 0x82abce00
	pc = 0x82ABCE00; continue 'dispatch;
	// 82ABCDB0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ABCDB4: C01F0014  lfs f0, 0x14(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ABCDB8: 3BDF0014  addi r30, r31, 0x14
	ctx.r[30].s64 = ctx.r[31].s64 + 20;
	// 82ABCDBC: C1AB08A4  lfs f13, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ABCDC0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ABCDC4: 41990030  bgt cr6, 0x82abcdf4
	if ctx.cr[6].gt {
	pc = 0x82ABCDF4; continue 'dispatch;
	}
	// 82ABCDC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABCDCC: 4BFFFDD5  bl 0x82abcba0
	ctx.lr = 0x82ABCDD0;
	sub_82ABCBA0(ctx, base);
	// 82ABCDD0: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ABCDD4: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ABCDD8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABCDDC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82ABCDE0: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82ABCDE4: 1D6B000C  mulli r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 * 12;
	// 82ABCDE8: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82ABCDEC: 4BFFFC35  bl 0x82abca20
	ctx.lr = 0x82ABCDF0;
	sub_82ABCA20(ctx, base);
	// 82ABCDF0: 48000010  b 0x82abce00
	pc = 0x82ABCE00; continue 'dispatch;
	// 82ABCDF4: C1BD0000  lfs f13, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ABCDF8: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82ABCDFC: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82ABCE00: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82ABCE04: 486EB3B4  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABCE08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ABCE08 size=12
    let mut pc: u32 = 0x82ABCE08;
    'dispatch: loop {
        match pc {
            0x82ABCE08 => {
    //   block [0x82ABCE08..0x82ABCE14)
	// 82ABCE08: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82ABCE0C: 806BE630  lwz r3, -0x19d0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6608 as u32) ) } as u64;
	// 82ABCE10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABCE18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABCE18 size=136
    let mut pc: u32 = 0x82ABCE18;
    'dispatch: loop {
        match pc {
            0x82ABCE18 => {
    //   block [0x82ABCE18..0x82ABCEA0)
	// 82ABCE18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABCE1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABCE20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ABCE24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABCE28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABCE2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABCE30: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82ABCE34: 4BA54BA5  bl 0x825119d8
	ctx.lr = 0x82ABCE38;
	sub_825119D8(ctx, base);
	// 82ABCE38: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82ABCE3C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ABCE40: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 82ABCE44: 48336BC5  bl 0x82df3a08
	ctx.lr = 0x82ABCE48;
	sub_82DF3A08(ctx, base);
	// 82ABCE48: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82ABCE4C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82ABCE50: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABCE54: 4BA4B92D  bl 0x82508780
	ctx.lr = 0x82ABCE58;
	sub_82508780(ctx, base);
	// 82ABCE58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ABCE5C: 483365CD  bl 0x82df3428
	ctx.lr = 0x82ABCE60;
	sub_82DF3428(ctx, base);
	// 82ABCE60: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82ABCE64: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 82ABCE68: 409A0008  bne cr6, 0x82abce70
	if !ctx.cr[6].eq {
	pc = 0x82ABCE70; continue 'dispatch;
	}
	// 82ABCE6C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82ABCE70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABCE74: 4BA4B92D  bl 0x825087a0
	ctx.lr = 0x82ABCE78;
	sub_825087A0(ctx, base);
	// 82ABCE78: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82ABCE7C: 4854C13D  bl 0x83008fb8
	ctx.lr = 0x82ABCE80;
	sub_83008FB8(ctx, base);
	// 82ABCE80: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82ABCE84: 906BE630  stw r3, -0x19d0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-6608 as u32), ctx.r[3].u32 ) };
	// 82ABCE88: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ABCE8C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABCE90: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABCE94: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ABCE98: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ABCE9C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABCEA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABCEA0 size=44
    let mut pc: u32 = 0x82ABCEA0;
    'dispatch: loop {
        match pc {
            0x82ABCEA0 => {
    //   block [0x82ABCEA0..0x82ABCECC)
	// 82ABCEA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABCEA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABCEA8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABCEAC: 4BA551BD  bl 0x82512068
	ctx.lr = 0x82ABCEB0;
	sub_82512068(ctx, base);
	// 82ABCEB0: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82ABCEB4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ABCEB8: 916AE630  stw r11, -0x19d0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-6608 as u32), ctx.r[11].u32 ) };
	// 82ABCEBC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82ABCEC0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABCEC4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABCEC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABCED0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABCED0 size=196
    let mut pc: u32 = 0x82ABCED0;
    'dispatch: loop {
        match pc {
            0x82ABCED0 => {
    //   block [0x82ABCED0..0x82ABCF94)
	// 82ABCED0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABCED4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABCED8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ABCEDC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABCEE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABCEE4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ABCEE8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ABCEEC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82ABCEF0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82ABCEF4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ABCEF8: 4B803A41  bl 0x822c0938
	ctx.lr = 0x82ABCEFC;
	sub_822C0938(ctx, base);
	// 82ABCEFC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ABCF00: 41820028  beq 0x82abcf28
	if ctx.cr[0].eq {
	pc = 0x82ABCF28; continue 'dispatch;
	}
	// 82ABCF04: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ABCF08: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82ABCF0C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82ABCF10: 392B8BD4  addi r9, r11, -0x742c
	ctx.r[9].s64 = ctx.r[11].s64 + -29740;
	// 82ABCF14: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82ABCF18: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82ABCF1C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82ABCF20: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82ABCF24: 48000008  b 0x82abcf2c
	pc = 0x82ABCF2C; continue 'dispatch;
	// 82ABCF28: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ABCF2C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ABCF30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ABCF34: 409A0044  bne cr6, 0x82abcf78
	if !ctx.cr[6].eq {
	pc = 0x82ABCF78; continue 'dispatch;
	}
	// 82ABCF38: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82ABCF3C: 419A001C  beq cr6, 0x82abcf58
	if ctx.cr[6].eq {
	pc = 0x82ABCF58; continue 'dispatch;
	}
	// 82ABCF40: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABCF44: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82ABCF48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABCF4C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABCF50: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ABCF54: 4E800421  bctrl
	ctx.lr = 0x82ABCF58;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ABCF58: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82ABCF5C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82ABCF60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ABCF64: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82ABCF68: 816BED2C  lwz r11, -0x12d4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4820 as u32) ) } as u64;
	// 82ABCF6C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82ABCF70: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82ABCF74: 4B80308D  bl 0x822c0000
	ctx.lr = 0x82ABCF78;
	sub_822C0000(ctx, base);
	// 82ABCF78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABCF7C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ABCF80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABCF84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABCF88: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ABCF8C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ABCF90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABCF98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABCF98 size=368
    let mut pc: u32 = 0x82ABCF98;
    'dispatch: loop {
        match pc {
            0x82ABCF98 => {
    //   block [0x82ABCF98..0x82ABD108)
	// 82ABCF98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABCF9C: 486EB1D1  bl 0x831a816c
	ctx.lr = 0x82ABCFA0;
	sub_831A8130(ctx, base);
	// 82ABCFA0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABCFA4: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82ABCFA8: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82ABCFAC: 396BED20  addi r11, r11, -0x12e0
	ctx.r[11].s64 = ctx.r[11].s64 + -4832;
	// 82ABCFB0: 2B050002  cmplwi cr6, r5, 2
	ctx.cr[6].compare_u32(ctx.r[5].u32, 2 as u32, &mut ctx.xer);
	// 82ABCFB4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ABCFB8: 7CAA582E  lwzx r5, r10, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82ABCFBC: 419800A0  blt cr6, 0x82abd05c
	if ctx.cr[6].lt {
	pc = 0x82ABD05C; continue 'dispatch;
	}
	// 82ABCFC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ABCFC4: 4801BBC5  bl 0x82ad8b88
	ctx.lr = 0x82ABCFC8;
	sub_82AD8B88(ctx, base);
	// 82ABCFC8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82ABCFCC: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82ABCFD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ABCFD4: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82ABCFD8: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 82ABCFDC: 419A0024  beq cr6, 0x82abd000
	if ctx.cr[6].eq {
	pc = 0x82ABD000; continue 'dispatch;
	}
	// 82ABCFE0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82ABCFE4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82ABCFE8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ABCFEC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82ABCFF0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ABCFF4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82ABCFF8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ABCFFC: 4082FFE8  bne 0x82abcfe4
	if !ctx.cr[0].eq {
	pc = 0x82ABCFE4; continue 'dispatch;
	}
	// 82ABD000: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ABD004: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82ABD008: 4BA524C1  bl 0x8250f4c8
	ctx.lr = 0x82ABD00C;
	sub_8250F4C8(ctx, base);
	// 82ABD00C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABD010: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ABD014: 3BEBFFFC  addi r31, r11, -4
	ctx.r[31].s64 = ctx.r[11].s64 + -4;
	// 82ABD018: 409A0008  bne cr6, 0x82abd020
	if !ctx.cr[6].eq {
	pc = 0x82ABD020; continue 'dispatch;
	}
	// 82ABD01C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82ABD020: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ABD024: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82ABD028: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82ABD02C: 4BA524ED  bl 0x8250f518
	ctx.lr = 0x82ABD030;
	sub_8250F518(ctx, base);
	// 82ABD030: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82ABD034: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABD038: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82ABD03C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82ABD040: 4BA504C9  bl 0x8250d508
	ctx.lr = 0x82ABD044;
	sub_8250D508(ctx, base);
	// 82ABD044: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82ABD048: 48334C49  bl 0x82df1c90
	ctx.lr = 0x82ABD04C;
	sub_82DF1C90(ctx, base);
	// 82ABD04C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82ABD050: 48334C41  bl 0x82df1c90
	ctx.lr = 0x82ABD054;
	sub_82DF1C90(ctx, base);
	// 82ABD054: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82ABD058: 4800009C  b 0x82abd0f4
	pc = 0x82ABD0F4; continue 'dispatch;
	// 82ABD05C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82ABD060: 4801C0A9  bl 0x82ad9108
	ctx.lr = 0x82ABD064;
	sub_82AD9108(ctx, base);
	// 82ABD064: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82ABD068: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82ABD06C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ABD070: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82ABD074: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 82ABD078: 419A0024  beq cr6, 0x82abd09c
	if ctx.cr[6].eq {
	pc = 0x82ABD09C; continue 'dispatch;
	}
	// 82ABD07C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82ABD080: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82ABD084: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ABD088: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82ABD08C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ABD090: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82ABD094: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ABD098: 4082FFE8  bne 0x82abd080
	if !ctx.cr[0].eq {
	pc = 0x82ABD080; continue 'dispatch;
	}
	// 82ABD09C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ABD0A0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82ABD0A4: 4BA52425  bl 0x8250f4c8
	ctx.lr = 0x82ABD0A8;
	sub_8250F4C8(ctx, base);
	// 82ABD0A8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABD0AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ABD0B0: 3BEBFFFC  addi r31, r11, -4
	ctx.r[31].s64 = ctx.r[11].s64 + -4;
	// 82ABD0B4: 409A0008  bne cr6, 0x82abd0bc
	if !ctx.cr[6].eq {
	pc = 0x82ABD0BC; continue 'dispatch;
	}
	// 82ABD0B8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82ABD0BC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ABD0C0: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82ABD0C4: 3BA10068  addi r29, r1, 0x68
	ctx.r[29].s64 = ctx.r[1].s64 + 104;
	// 82ABD0C8: 4BA52451  bl 0x8250f518
	ctx.lr = 0x82ABD0CC;
	sub_8250F518(ctx, base);
	// 82ABD0CC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82ABD0D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABD0D4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82ABD0D8: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82ABD0DC: 4BA5042D  bl 0x8250d508
	ctx.lr = 0x82ABD0E0;
	sub_8250D508(ctx, base);
	// 82ABD0E0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82ABD0E4: 48334BAD  bl 0x82df1c90
	ctx.lr = 0x82ABD0E8;
	sub_82DF1C90(ctx, base);
	// 82ABD0E8: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82ABD0EC: 48334BA5  bl 0x82df1c90
	ctx.lr = 0x82ABD0F0;
	sub_82DF1C90(ctx, base);
	// 82ABD0F0: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82ABD0F4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ABD0F8: 419A0008  beq cr6, 0x82abd100
	if ctx.cr[6].eq {
	pc = 0x82ABD100; continue 'dispatch;
	}
	// 82ABD0FC: 4B803795  bl 0x822c0890
	ctx.lr = 0x82ABD100;
	sub_822C0890(ctx, base);
	// 82ABD100: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82ABD104: 486EB0B8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABD108(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ABD108 size=564
    let mut pc: u32 = 0x82ABD108;
    'dispatch: loop {
        match pc {
            0x82ABD108 => {
    //   block [0x82ABD108..0x82ABD33C)
	// 82ABD108: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABD10C: 486EB04D  bl 0x831a8158
	ctx.lr = 0x82ABD110;
	sub_831A8130(ctx, base);
	// 82ABD110: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABD114: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82ABD118: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82ABD11C: 396BED30  addi r11, r11, -0x12d0
	ctx.r[11].s64 = ctx.r[11].s64 + -4816;
	// 82ABD120: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82ABD124: 3BEB0030  addi r31, r11, 0x30
	ctx.r[31].s64 = ctx.r[11].s64 + 48;
	// 82ABD128: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82ABD12C: 3B000003  li r24, 3
	ctx.r[24].s64 = 3;
	// 82ABD130: 3BABBA80  addi r29, r11, -0x4580
	ctx.r[29].s64 = ctx.r[11].s64 + -17792;
	// 82ABD134: 817FFFD4  lwz r11, -0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-44 as u32) ) } as u64;
	// 82ABD138: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82ABD13C: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82ABD140: 419A0008  beq cr6, 0x82abd148
	if ctx.cr[6].eq {
	pc = 0x82ABD148; continue 'dispatch;
	}
	// 82ABD144: 3BC00003  li r30, 3
	ctx.r[30].s64 = 3;
	// 82ABD148: 3B7FFFF0  addi r27, r31, -0x10
	ctx.r[27].s64 = ctx.r[31].s64 + -16;
	// 82ABD14C: 3B5FFFE0  addi r26, r31, -0x20
	ctx.r[26].s64 = ctx.r[31].s64 + -32;
	// 82ABD150: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82ABD154: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82ABD158: 4BFF12C1  bl 0x82aae418
	ctx.lr = 0x82ABD15C;
	sub_82AAE418(ctx, base);
	// 82ABD15C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82ABD160: C01D0000  lfs f0, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ABD164: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 82ABD168: C1BD0004  lfs f13, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ABD16C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82ABD170: C19D0008  lfs f12, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ABD174: C17D000C  lfs f11, 0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82ABD178: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABD17C: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ABD180: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ABD184: D00100A0  stfs f0, 0xa0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82ABD188: D1A100A4  stfs f13, 0xa4(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82ABD18C: D18100A8  stfs f12, 0xa8(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82ABD190: D16100AC  stfs f11, 0xac(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 82ABD194: 91410090  stw r10, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[10].u32 ) };
	// 82ABD198: 91210094  stw r9, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[9].u32 ) };
	// 82ABD19C: 91610098  stw r11, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 82ABD1A0: 4BFF11A1  bl 0x82aae340
	ctx.lr = 0x82ABD1A4;
	sub_82AAE340(ctx, base);
	// 82ABD1A4: 38E100A0  addi r7, r1, 0xa0
	ctx.r[7].s64 = ctx.r[1].s64 + 160;
	// 82ABD1A8: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 82ABD1AC: C03F0000  lfs f1, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82ABD1B0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82ABD1B4: 80BFFFD4  lwz r5, -0x2c(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-44 as u32) ) } as u64;
	// 82ABD1B8: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82ABD1BC: 4BFFFDDD  bl 0x82abcf98
	ctx.lr = 0x82ABD1C0;
	sub_82ABCF98(ctx, base);
	// 82ABD1C0: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82ABD1C4: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82ABD1C8: 4082FF88  bne 0x82abd150
	if !ctx.cr[0].eq {
	pc = 0x82ABD150; continue 'dispatch;
	}
	// 82ABD1CC: 3718FFFF  addic. r24, r24, -1
	ctx.xer.ca = (ctx.r[24].u32 > (!(-1 as u32)));
	ctx.r[24].s64 = ctx.r[24].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[24].s32, 0, &mut ctx.xer);
	// 82ABD1D0: 3BFF0040  addi r31, r31, 0x40
	ctx.r[31].s64 = ctx.r[31].s64 + 64;
	// 82ABD1D4: 4082FF60  bne 0x82abd134
	if !ctx.cr[0].eq {
	pc = 0x82ABD134; continue 'dispatch;
	}
	// 82ABD1D8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ABD1DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ABD1E0: C02B093C  lfs f1, 0x93c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2364 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82ABD1E4: 48010DBD  bl 0x82acdfa0
	ctx.lr = 0x82ABD1E8;
	sub_82ACDFA0(ctx, base);
	// 82ABD1E8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82ABD1EC: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82ABD1F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ABD1F4: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82ABD1F8: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 82ABD1FC: 419A0024  beq cr6, 0x82abd220
	if ctx.cr[6].eq {
	pc = 0x82ABD220; continue 'dispatch;
	}
	// 82ABD200: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82ABD204: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82ABD208: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ABD20C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82ABD210: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ABD214: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82ABD218: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ABD21C: 4082FFE8  bne 0x82abd204
	if !ctx.cr[0].eq {
	pc = 0x82ABD204; continue 'dispatch;
	}
	// 82ABD220: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82ABD224: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82ABD228: 4BA522A1  bl 0x8250f4c8
	ctx.lr = 0x82ABD22C;
	sub_8250F4C8(ctx, base);
	// 82ABD22C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABD230: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ABD234: 3BEBFFFC  addi r31, r11, -4
	ctx.r[31].s64 = ctx.r[11].s64 + -4;
	// 82ABD238: 409A0008  bne cr6, 0x82abd240
	if !ctx.cr[6].eq {
	pc = 0x82ABD240; continue 'dispatch;
	}
	// 82ABD23C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82ABD240: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82ABD244: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82ABD248: 3BC10060  addi r30, r1, 0x60
	ctx.r[30].s64 = ctx.r[1].s64 + 96;
	// 82ABD24C: 4BA522CD  bl 0x8250f518
	ctx.lr = 0x82ABD250;
	sub_8250F518(ctx, base);
	// 82ABD250: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82ABD254: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABD258: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82ABD25C: 7F26CB78  mr r6, r25
	ctx.r[6].u64 = ctx.r[25].u64;
	// 82ABD260: 4BA502A9  bl 0x8250d508
	ctx.lr = 0x82ABD264;
	sub_8250D508(ctx, base);
	// 82ABD264: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82ABD268: 48334A29  bl 0x82df1c90
	ctx.lr = 0x82ABD26C;
	sub_82DF1C90(ctx, base);
	// 82ABD26C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82ABD270: 48334A21  bl 0x82df1c90
	ctx.lr = 0x82ABD274;
	sub_82DF1C90(ctx, base);
	// 82ABD274: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82ABD278: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ABD27C: 419A0008  beq cr6, 0x82abd284
	if ctx.cr[6].eq {
	pc = 0x82ABD284; continue 'dispatch;
	}
	// 82ABD280: 4B803611  bl 0x822c0890
	ctx.lr = 0x82ABD284;
	sub_822C0890(ctx, base);
	// 82ABD284: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82ABD288: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82ABD28C: C02BF524  lfs f1, -0xadc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2780 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82ABD290: 48010D11  bl 0x82acdfa0
	ctx.lr = 0x82ABD294;
	sub_82ACDFA0(ctx, base);
	// 82ABD294: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82ABD298: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82ABD29C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ABD2A0: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82ABD2A4: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 82ABD2A8: 419A0024  beq cr6, 0x82abd2cc
	if ctx.cr[6].eq {
	pc = 0x82ABD2CC; continue 'dispatch;
	}
	// 82ABD2AC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82ABD2B0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82ABD2B4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ABD2B8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82ABD2BC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ABD2C0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82ABD2C4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ABD2C8: 4082FFE8  bne 0x82abd2b0
	if !ctx.cr[0].eq {
	pc = 0x82ABD2B0; continue 'dispatch;
	}
	// 82ABD2CC: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82ABD2D0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82ABD2D4: 4BA521F5  bl 0x8250f4c8
	ctx.lr = 0x82ABD2D8;
	sub_8250F4C8(ctx, base);
	// 82ABD2D8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABD2DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ABD2E0: 3BEBFFFC  addi r31, r11, -4
	ctx.r[31].s64 = ctx.r[11].s64 + -4;
	// 82ABD2E4: 409A0008  bne cr6, 0x82abd2ec
	if !ctx.cr[6].eq {
	pc = 0x82ABD2EC; continue 'dispatch;
	}
	// 82ABD2E8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82ABD2EC: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82ABD2F0: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82ABD2F4: 3BC10060  addi r30, r1, 0x60
	ctx.r[30].s64 = ctx.r[1].s64 + 96;
	// 82ABD2F8: 4BA52221  bl 0x8250f518
	ctx.lr = 0x82ABD2FC;
	sub_8250F518(ctx, base);
	// 82ABD2FC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82ABD300: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABD304: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82ABD308: 7F26CB78  mr r6, r25
	ctx.r[6].u64 = ctx.r[25].u64;
	// 82ABD30C: 4BA501FD  bl 0x8250d508
	ctx.lr = 0x82ABD310;
	sub_8250D508(ctx, base);
	// 82ABD310: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82ABD314: 4833497D  bl 0x82df1c90
	ctx.lr = 0x82ABD318;
	sub_82DF1C90(ctx, base);
	// 82ABD318: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82ABD31C: 48334975  bl 0x82df1c90
	ctx.lr = 0x82ABD320;
	sub_82DF1C90(ctx, base);
	// 82ABD320: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82ABD324: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ABD328: 419A0008  beq cr6, 0x82abd330
	if ctx.cr[6].eq {
	pc = 0x82ABD330; continue 'dispatch;
	}
	// 82ABD32C: 4B803565  bl 0x822c0890
	ctx.lr = 0x82ABD330;
	sub_822C0890(ctx, base);
	// 82ABD330: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82ABD334: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 82ABD338: 486EAE70  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABD340(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABD340 size=88
    let mut pc: u32 = 0x82ABD340;
    'dispatch: loop {
        match pc {
            0x82ABD340 => {
    //   block [0x82ABD340..0x82ABD398)
	// 82ABD340: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABD344: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABD348: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ABD34C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABD350: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABD354: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ABD358: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABD35C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABD360: 4854ADC9  bl 0x83008128
	ctx.lr = 0x82ABD364;
	sub_83008128(ctx, base);
	// 82ABD364: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ABD368: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82ABD36C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82ABD370: 389F00E8  addi r4, r31, 0xe8
	ctx.r[4].s64 = ctx.r[31].s64 + 232;
	// 82ABD374: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82ABD378: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82ABD37C: 4BA5F80D  bl 0x8251cb88
	ctx.lr = 0x82ABD380;
	sub_8251CB88(ctx, base);
	// 82ABD380: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82ABD384: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABD388: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABD38C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ABD390: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ABD394: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABD398(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABD398 size=164
    let mut pc: u32 = 0x82ABD398;
    'dispatch: loop {
        match pc {
            0x82ABD398 => {
    //   block [0x82ABD398..0x82ABD43C)
	// 82ABD398: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABD39C: 486EADCD  bl 0x831a8168
	ctx.lr = 0x82ABD3A0;
	sub_831A8130(ctx, base);
	// 82ABD3A0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABD3A4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82ABD3A8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ABD3AC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82ABD3B0: 57BC063F  clrlwi. r28, r29, 0x18
	ctx.r[28].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82ABD3B4: 41820038  beq 0x82abd3ec
	if ctx.cr[0].eq {
	pc = 0x82ABD3EC; continue 'dispatch;
	}
	// 82ABD3B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABD3BC: 486EC5CD  bl 0x831a9988
	ctx.lr = 0x82ABD3C0;
	sub_831A9988(ctx, base);
	// 82ABD3C0: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82ABD3C4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82ABD3C8: 386B6698  addi r3, r11, 0x6698
	ctx.r[3].s64 = ctx.r[11].s64 + 26264;
	// 82ABD3CC: 486EAD2D  bl 0x831a80f8
	ctx.lr = 0x82ABD3D0;
	sub_831A80F8(ctx, base);
	// 82ABD3D0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ABD3D4: 41820018  beq 0x82abd3ec
	if ctx.cr[0].eq {
	pc = 0x82ABD3EC; continue 'dispatch;
	}
	// 82ABD3D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ABD3DC: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82ABD3E0: 4BFFFF61  bl 0x82abd340
	ctx.lr = 0x82ABD3E4;
	sub_82ABD340(ctx, base);
	// 82ABD3E4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82ABD3E8: 4800004C  b 0x82abd434
	pc = 0x82ABD434; continue 'dispatch;
	// 82ABD3EC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82ABD3F0: 419A0034  beq cr6, 0x82abd424
	if ctx.cr[6].eq {
	pc = 0x82ABD424; continue 'dispatch;
	}
	// 82ABD3F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABD3F8: 486EC591  bl 0x831a9988
	ctx.lr = 0x82ABD3FC;
	sub_831A9988(ctx, base);
	// 82ABD3FC: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82ABD400: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82ABD404: 386B6668  addi r3, r11, 0x6668
	ctx.r[3].s64 = ctx.r[11].s64 + 26216;
	// 82ABD408: 486EACF1  bl 0x831a80f8
	ctx.lr = 0x82ABD40C;
	sub_831A80F8(ctx, base);
	// 82ABD40C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ABD410: 41820014  beq 0x82abd424
	if ctx.cr[0].eq {
	pc = 0x82ABD424; continue 'dispatch;
	}
	// 82ABD414: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ABD418: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82ABD41C: 4BFA6605  bl 0x82a63a20
	ctx.lr = 0x82ABD420;
	sub_82A63A20(ctx, base);
	// 82ABD420: 4BFFFFC4  b 0x82abd3e4
	pc = 0x82ABD3E4; continue 'dispatch;
	// 82ABD424: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82ABD428: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ABD42C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABD430: 4BA551E9  bl 0x82512618
	ctx.lr = 0x82ABD434;
	sub_82512618(ctx, base);
	// 82ABD434: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82ABD438: 486EAD80  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABD440(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABD440 size=92
    let mut pc: u32 = 0x82ABD440;
    'dispatch: loop {
        match pc {
            0x82ABD440 => {
    //   block [0x82ABD440..0x82ABD49C)
	// 82ABD440: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABD444: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABD448: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABD44C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABD450: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABD454: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ABD458: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82ABD45C: 3D208338  lis r9, -0x7cc8
	ctx.r[9].s64 = -2093481984;
	// 82ABD460: 390B8BFC  addi r8, r11, -0x7404
	ctx.r[8].s64 = ctx.r[11].s64 + -29700;
	// 82ABD464: 394A8BE8  addi r10, r10, -0x7418
	ctx.r[10].s64 = ctx.r[10].s64 + -29720;
	// 82ABD468: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ABD46C: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82ABD470: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82ABD474: 387F00E8  addi r3, r31, 0xe8
	ctx.r[3].s64 = ctx.r[31].s64 + 232;
	// 82ABD478: 9169E630  stw r11, -0x19d0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(-6608 as u32), ctx.r[11].u32 ) };
	// 82ABD47C: 4BCEFD6D  bl 0x827ad1e8
	ctx.lr = 0x82ABD480;
	sub_827AD1E8(ctx, base);
	// 82ABD480: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABD484: 4B891ECD  bl 0x8234f350
	ctx.lr = 0x82ABD488;
	sub_8234F350(ctx, base);
	// 82ABD488: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82ABD48C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABD490: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABD494: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ABD498: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABD4A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ABD4A0 size=8
    let mut pc: u32 = 0x82ABD4A0;
    'dispatch: loop {
        match pc {
            0x82ABD4A0 => {
    //   block [0x82ABD4A0..0x82ABD4A8)
	// 82ABD4A0: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 82ABD4A4: 4800005C  b 0x82abd500
	sub_82ABD500(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABD4A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABD4A8 size=88
    let mut pc: u32 = 0x82ABD4A8;
    'dispatch: loop {
        match pc {
            0x82ABD4A8 => {
    //   block [0x82ABD4A8..0x82ABD500)
	// 82ABD4A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABD4AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABD4B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABD4B4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABD4B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABD4BC: 4BA54E75  bl 0x82512330
	ctx.lr = 0x82ABD4C0;
	sub_82512330(ctx, base);
	// 82ABD4C0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ABD4C4: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82ABD4C8: 396B8BFC  addi r11, r11, -0x7404
	ctx.r[11].s64 = ctx.r[11].s64 + -29700;
	// 82ABD4CC: 394A8BE8  addi r10, r10, -0x7418
	ctx.r[10].s64 = ctx.r[10].s64 + -29720;
	// 82ABD4D0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82ABD4D4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ABD4D8: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82ABD4DC: 387F00E8  addi r3, r31, 0xe8
	ctx.r[3].s64 = ctx.r[31].s64 + 232;
	// 82ABD4E0: 993F00E4  stb r9, 0xe4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u8 ) };
	// 82ABD4E4: 4B84BF45  bl 0x82309428
	ctx.lr = 0x82ABD4E8;
	sub_82309428(ctx, base);
	// 82ABD4E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABD4EC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82ABD4F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABD4F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABD4F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ABD4FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABD500(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABD500 size=76
    let mut pc: u32 = 0x82ABD500;
    'dispatch: loop {
        match pc {
            0x82ABD500 => {
    //   block [0x82ABD500..0x82ABD54C)
	// 82ABD500: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABD504: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABD508: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ABD50C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABD510: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABD514: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABD518: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ABD51C: 4BFFFF25  bl 0x82abd440
	ctx.lr = 0x82ABD520;
	sub_82ABD440(ctx, base);
	// 82ABD520: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ABD524: 4182000C  beq 0x82abd530
	if ctx.cr[0].eq {
	pc = 0x82ABD530; continue 'dispatch;
	}
	// 82ABD528: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABD52C: 48334EAD  bl 0x82df23d8
	ctx.lr = 0x82ABD530;
	sub_82DF23D8(ctx, base);
	// 82ABD530: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABD534: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ABD538: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABD53C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABD540: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ABD544: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ABD548: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABD550(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABD550 size=112
    let mut pc: u32 = 0x82ABD550;
    'dispatch: loop {
        match pc {
            0x82ABD550 => {
    //   block [0x82ABD550..0x82ABD5C0)
	// 82ABD550: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABD554: 486EAC19  bl 0x831a816c
	ctx.lr = 0x82ABD558;
	sub_831A8130(ctx, base);
	// 82ABD558: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABD55C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ABD560: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82ABD564: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82ABD568: 388B8C40  addi r4, r11, -0x73c0
	ctx.r[4].s64 = ctx.r[11].s64 + -29632;
	// 82ABD56C: 38A00048  li r5, 0x48
	ctx.r[5].s64 = 72;
	// 82ABD570: 386000F4  li r3, 0xf4
	ctx.r[3].s64 = 244;
	// 82ABD574: 48334E75  bl 0x82df23e8
	ctx.lr = 0x82ABD578;
	sub_82DF23E8(ctx, base);
	// 82ABD578: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ABD57C: 41820010  beq 0x82abd58c
	if ctx.cr[0].eq {
	pc = 0x82ABD58C; continue 'dispatch;
	}
	// 82ABD580: 4BFFFF29  bl 0x82abd4a8
	ctx.lr = 0x82ABD584;
	sub_82ABD4A8(ctx, base);
	// 82ABD584: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABD588: 48000008  b 0x82abd590
	pc = 0x82ABD590; continue 'dispatch;
	// 82ABD58C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82ABD590: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82ABD594: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82ABD598: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ABD59C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABD5A0: 4BFFF931  bl 0x82abced0
	ctx.lr = 0x82ABD5A4;
	sub_82ABCED0(ctx, base);
	// 82ABD5A4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82ABD5A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ABD5AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABD5B0: 4B802A51  bl 0x822c0000
	ctx.lr = 0x82ABD5B4;
	sub_822C0000(ctx, base);
	// 82ABD5B4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ABD5B8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ABD5BC: 486EAC00  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABD5C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ABD5C0 size=4
    let mut pc: u32 = 0x82ABD5C0;
    'dispatch: loop {
        match pc {
            0x82ABD5C0 => {
    //   block [0x82ABD5C0..0x82ABD5C4)
	// 82ABD5C0: 4839F8B8  b 0x82e5ce78
	sub_82E5CE78(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABD5C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABD5C8 size=88
    let mut pc: u32 = 0x82ABD5C8;
    'dispatch: loop {
        match pc {
            0x82ABD5C8 => {
    //   block [0x82ABD5C8..0x82ABD620)
	// 82ABD5C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABD5CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABD5D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ABD5D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABD5D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABD5DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABD5E0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ABD5E4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ABD5E8: 396B8CA0  addi r11, r11, -0x7360
	ctx.r[11].s64 = ctx.r[11].s64 + -29536;
	// 82ABD5EC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ABD5F0: 483A0259  bl 0x82e5d848
	ctx.lr = 0x82ABD5F4;
	sub_82E5D848(ctx, base);
	// 82ABD5F4: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ABD5F8: 4182000C  beq 0x82abd604
	if ctx.cr[0].eq {
	pc = 0x82ABD604; continue 'dispatch;
	}
	// 82ABD5FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABD600: 48334DD9  bl 0x82df23d8
	ctx.lr = 0x82ABD604;
	sub_82DF23D8(ctx, base);
	// 82ABD604: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABD608: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ABD60C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABD610: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABD614: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ABD618: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ABD61C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABD620(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABD620 size=196
    let mut pc: u32 = 0x82ABD620;
    'dispatch: loop {
        match pc {
            0x82ABD620 => {
    //   block [0x82ABD620..0x82ABD6E4)
	// 82ABD620: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABD624: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABD628: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ABD62C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABD630: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABD634: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ABD638: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ABD63C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82ABD640: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82ABD644: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ABD648: 4B8032F1  bl 0x822c0938
	ctx.lr = 0x82ABD64C;
	sub_822C0938(ctx, base);
	// 82ABD64C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ABD650: 41820028  beq 0x82abd678
	if ctx.cr[0].eq {
	pc = 0x82ABD678; continue 'dispatch;
	}
	// 82ABD654: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ABD658: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82ABD65C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82ABD660: 392B8CB0  addi r9, r11, -0x7350
	ctx.r[9].s64 = ctx.r[11].s64 + -29520;
	// 82ABD664: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82ABD668: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82ABD66C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82ABD670: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82ABD674: 48000008  b 0x82abd67c
	pc = 0x82ABD67C; continue 'dispatch;
	// 82ABD678: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ABD67C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ABD680: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ABD684: 409A0044  bne cr6, 0x82abd6c8
	if !ctx.cr[6].eq {
	pc = 0x82ABD6C8; continue 'dispatch;
	}
	// 82ABD688: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82ABD68C: 419A001C  beq cr6, 0x82abd6a8
	if ctx.cr[6].eq {
	pc = 0x82ABD6A8; continue 'dispatch;
	}
	// 82ABD690: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABD694: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82ABD698: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABD69C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ABD6A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ABD6A4: 4E800421  bctrl
	ctx.lr = 0x82ABD6A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ABD6A8: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82ABD6AC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82ABD6B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ABD6B4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82ABD6B8: 816BEEA8  lwz r11, -0x1158(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4440 as u32) ) } as u64;
	// 82ABD6BC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82ABD6C0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82ABD6C4: 4B80293D  bl 0x822c0000
	ctx.lr = 0x82ABD6C8;
	sub_822C0000(ctx, base);
	// 82ABD6C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABD6CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ABD6D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABD6D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABD6D8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ABD6DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ABD6E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABD6E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABD6E8 size=196
    let mut pc: u32 = 0x82ABD6E8;
    'dispatch: loop {
        match pc {
            0x82ABD6E8 => {
    //   block [0x82ABD6E8..0x82ABD7AC)
	// 82ABD6E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABD6EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABD6F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ABD6F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABD6F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABD6FC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ABD700: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ABD704: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82ABD708: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82ABD70C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ABD710: 4B803229  bl 0x822c0938
	ctx.lr = 0x82ABD714;
	sub_822C0938(ctx, base);
	// 82ABD714: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ABD718: 41820028  beq 0x82abd740
	if ctx.cr[0].eq {
	pc = 0x82ABD740; continue 'dispatch;
	}
	// 82ABD71C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ABD720: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82ABD724: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82ABD728: 392B8CC4  addi r9, r11, -0x733c
	ctx.r[9].s64 = ctx.r[11].s64 + -29500;
	// 82ABD72C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82ABD730: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82ABD734: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82ABD738: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82ABD73C: 48000008  b 0x82abd744
	pc = 0x82ABD744; continue 'dispatch;
	// 82ABD740: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ABD744: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ABD748: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ABD74C: 409A0044  bne cr6, 0x82abd790
	if !ctx.cr[6].eq {
	pc = 0x82ABD790; continue 'dispatch;
	}
	// 82ABD750: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82ABD754: 419A001C  beq cr6, 0x82abd770
	if ctx.cr[6].eq {
	pc = 0x82ABD770; continue 'dispatch;
	}
	// 82ABD758: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABD75C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82ABD760: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABD764: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ABD768: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ABD76C: 4E800421  bctrl
	ctx.lr = 0x82ABD770;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ABD770: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82ABD774: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82ABD778: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ABD77C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82ABD780: 816BEEA8  lwz r11, -0x1158(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4440 as u32) ) } as u64;
	// 82ABD784: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82ABD788: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82ABD78C: 4B802875  bl 0x822c0000
	ctx.lr = 0x82ABD790;
	sub_822C0000(ctx, base);
	// 82ABD790: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABD794: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ABD798: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABD79C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABD7A0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ABD7A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ABD7A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABD7B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABD7B0 size=196
    let mut pc: u32 = 0x82ABD7B0;
    'dispatch: loop {
        match pc {
            0x82ABD7B0 => {
    //   block [0x82ABD7B0..0x82ABD874)
	// 82ABD7B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABD7B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABD7B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ABD7BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABD7C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABD7C4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ABD7C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ABD7CC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82ABD7D0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82ABD7D4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ABD7D8: 4B803161  bl 0x822c0938
	ctx.lr = 0x82ABD7DC;
	sub_822C0938(ctx, base);
	// 82ABD7DC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ABD7E0: 41820028  beq 0x82abd808
	if ctx.cr[0].eq {
	pc = 0x82ABD808; continue 'dispatch;
	}
	// 82ABD7E4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ABD7E8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82ABD7EC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82ABD7F0: 392B8CD8  addi r9, r11, -0x7328
	ctx.r[9].s64 = ctx.r[11].s64 + -29480;
	// 82ABD7F4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82ABD7F8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82ABD7FC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82ABD800: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82ABD804: 48000008  b 0x82abd80c
	pc = 0x82ABD80C; continue 'dispatch;
	// 82ABD808: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ABD80C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ABD810: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ABD814: 409A0044  bne cr6, 0x82abd858
	if !ctx.cr[6].eq {
	pc = 0x82ABD858; continue 'dispatch;
	}
	// 82ABD818: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82ABD81C: 419A001C  beq cr6, 0x82abd838
	if ctx.cr[6].eq {
	pc = 0x82ABD838; continue 'dispatch;
	}
	// 82ABD820: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABD824: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82ABD828: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABD82C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ABD830: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ABD834: 4E800421  bctrl
	ctx.lr = 0x82ABD838;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ABD838: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82ABD83C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82ABD840: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ABD844: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82ABD848: 816BEEA8  lwz r11, -0x1158(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4440 as u32) ) } as u64;
	// 82ABD84C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82ABD850: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82ABD854: 4B8027AD  bl 0x822c0000
	ctx.lr = 0x82ABD858;
	sub_822C0000(ctx, base);
	// 82ABD858: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABD85C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ABD860: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABD864: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABD868: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ABD86C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ABD870: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABD878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABD878 size=196
    let mut pc: u32 = 0x82ABD878;
    'dispatch: loop {
        match pc {
            0x82ABD878 => {
    //   block [0x82ABD878..0x82ABD93C)
	// 82ABD878: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABD87C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABD880: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ABD884: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABD888: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABD88C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ABD890: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ABD894: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82ABD898: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82ABD89C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ABD8A0: 4B803099  bl 0x822c0938
	ctx.lr = 0x82ABD8A4;
	sub_822C0938(ctx, base);
	// 82ABD8A4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ABD8A8: 41820028  beq 0x82abd8d0
	if ctx.cr[0].eq {
	pc = 0x82ABD8D0; continue 'dispatch;
	}
	// 82ABD8AC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ABD8B0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82ABD8B4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82ABD8B8: 392B8CEC  addi r9, r11, -0x7314
	ctx.r[9].s64 = ctx.r[11].s64 + -29460;
	// 82ABD8BC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82ABD8C0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82ABD8C4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82ABD8C8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82ABD8CC: 48000008  b 0x82abd8d4
	pc = 0x82ABD8D4; continue 'dispatch;
	// 82ABD8D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ABD8D4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ABD8D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ABD8DC: 409A0044  bne cr6, 0x82abd920
	if !ctx.cr[6].eq {
	pc = 0x82ABD920; continue 'dispatch;
	}
	// 82ABD8E0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82ABD8E4: 419A001C  beq cr6, 0x82abd900
	if ctx.cr[6].eq {
	pc = 0x82ABD900; continue 'dispatch;
	}
	// 82ABD8E8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABD8EC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82ABD8F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABD8F4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ABD8F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ABD8FC: 4E800421  bctrl
	ctx.lr = 0x82ABD900;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ABD900: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82ABD904: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82ABD908: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ABD90C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82ABD910: 816BEEA8  lwz r11, -0x1158(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4440 as u32) ) } as u64;
	// 82ABD914: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82ABD918: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82ABD91C: 4B8026E5  bl 0x822c0000
	ctx.lr = 0x82ABD920;
	sub_822C0000(ctx, base);
	// 82ABD920: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABD924: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ABD928: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABD92C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABD930: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ABD934: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ABD938: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABD940(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABD940 size=196
    let mut pc: u32 = 0x82ABD940;
    'dispatch: loop {
        match pc {
            0x82ABD940 => {
    //   block [0x82ABD940..0x82ABDA04)
	// 82ABD940: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABD944: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABD948: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ABD94C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABD950: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABD954: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ABD958: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ABD95C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82ABD960: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82ABD964: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ABD968: 4B802FD1  bl 0x822c0938
	ctx.lr = 0x82ABD96C;
	sub_822C0938(ctx, base);
	// 82ABD96C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ABD970: 41820028  beq 0x82abd998
	if ctx.cr[0].eq {
	pc = 0x82ABD998; continue 'dispatch;
	}
	// 82ABD974: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ABD978: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82ABD97C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82ABD980: 392B8D00  addi r9, r11, -0x7300
	ctx.r[9].s64 = ctx.r[11].s64 + -29440;
	// 82ABD984: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82ABD988: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82ABD98C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82ABD990: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82ABD994: 48000008  b 0x82abd99c
	pc = 0x82ABD99C; continue 'dispatch;
	// 82ABD998: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ABD99C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ABD9A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ABD9A4: 409A0044  bne cr6, 0x82abd9e8
	if !ctx.cr[6].eq {
	pc = 0x82ABD9E8; continue 'dispatch;
	}
	// 82ABD9A8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82ABD9AC: 419A001C  beq cr6, 0x82abd9c8
	if ctx.cr[6].eq {
	pc = 0x82ABD9C8; continue 'dispatch;
	}
	// 82ABD9B0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABD9B4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82ABD9B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABD9BC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ABD9C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ABD9C4: 4E800421  bctrl
	ctx.lr = 0x82ABD9C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ABD9C8: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82ABD9CC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82ABD9D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ABD9D4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82ABD9D8: 816BEEA8  lwz r11, -0x1158(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4440 as u32) ) } as u64;
	// 82ABD9DC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82ABD9E0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82ABD9E4: 4B80261D  bl 0x822c0000
	ctx.lr = 0x82ABD9E8;
	sub_822C0000(ctx, base);
	// 82ABD9E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABD9EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ABD9F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABD9F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABD9F8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ABD9FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ABDA00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABDA08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABDA08 size=196
    let mut pc: u32 = 0x82ABDA08;
    'dispatch: loop {
        match pc {
            0x82ABDA08 => {
    //   block [0x82ABDA08..0x82ABDACC)
	// 82ABDA08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABDA0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABDA10: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ABDA14: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABDA18: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABDA1C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ABDA20: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ABDA24: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82ABDA28: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82ABDA2C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ABDA30: 4B802F09  bl 0x822c0938
	ctx.lr = 0x82ABDA34;
	sub_822C0938(ctx, base);
	// 82ABDA34: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ABDA38: 41820028  beq 0x82abda60
	if ctx.cr[0].eq {
	pc = 0x82ABDA60; continue 'dispatch;
	}
	// 82ABDA3C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ABDA40: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82ABDA44: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82ABDA48: 392B8D14  addi r9, r11, -0x72ec
	ctx.r[9].s64 = ctx.r[11].s64 + -29420;
	// 82ABDA4C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82ABDA50: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82ABDA54: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82ABDA58: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82ABDA5C: 48000008  b 0x82abda64
	pc = 0x82ABDA64; continue 'dispatch;
	// 82ABDA60: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ABDA64: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ABDA68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ABDA6C: 409A0044  bne cr6, 0x82abdab0
	if !ctx.cr[6].eq {
	pc = 0x82ABDAB0; continue 'dispatch;
	}
	// 82ABDA70: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82ABDA74: 419A001C  beq cr6, 0x82abda90
	if ctx.cr[6].eq {
	pc = 0x82ABDA90; continue 'dispatch;
	}
	// 82ABDA78: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABDA7C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82ABDA80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABDA84: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ABDA88: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ABDA8C: 4E800421  bctrl
	ctx.lr = 0x82ABDA90;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ABDA90: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82ABDA94: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82ABDA98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ABDA9C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82ABDAA0: 816BEEA8  lwz r11, -0x1158(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4440 as u32) ) } as u64;
	// 82ABDAA4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82ABDAA8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82ABDAAC: 4B802555  bl 0x822c0000
	ctx.lr = 0x82ABDAB0;
	sub_822C0000(ctx, base);
	// 82ABDAB0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABDAB4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ABDAB8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABDABC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABDAC0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ABDAC4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ABDAC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABDAD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABDAD0 size=196
    let mut pc: u32 = 0x82ABDAD0;
    'dispatch: loop {
        match pc {
            0x82ABDAD0 => {
    //   block [0x82ABDAD0..0x82ABDB94)
	// 82ABDAD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABDAD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABDAD8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ABDADC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABDAE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABDAE4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ABDAE8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ABDAEC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82ABDAF0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82ABDAF4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ABDAF8: 4B802E41  bl 0x822c0938
	ctx.lr = 0x82ABDAFC;
	sub_822C0938(ctx, base);
	// 82ABDAFC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ABDB00: 41820028  beq 0x82abdb28
	if ctx.cr[0].eq {
	pc = 0x82ABDB28; continue 'dispatch;
	}
	// 82ABDB04: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ABDB08: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82ABDB0C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82ABDB10: 392B8D28  addi r9, r11, -0x72d8
	ctx.r[9].s64 = ctx.r[11].s64 + -29400;
	// 82ABDB14: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82ABDB18: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82ABDB1C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82ABDB20: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82ABDB24: 48000008  b 0x82abdb2c
	pc = 0x82ABDB2C; continue 'dispatch;
	// 82ABDB28: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ABDB2C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ABDB30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ABDB34: 409A0044  bne cr6, 0x82abdb78
	if !ctx.cr[6].eq {
	pc = 0x82ABDB78; continue 'dispatch;
	}
	// 82ABDB38: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82ABDB3C: 419A001C  beq cr6, 0x82abdb58
	if ctx.cr[6].eq {
	pc = 0x82ABDB58; continue 'dispatch;
	}
	// 82ABDB40: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABDB44: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82ABDB48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABDB4C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ABDB50: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ABDB54: 4E800421  bctrl
	ctx.lr = 0x82ABDB58;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ABDB58: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82ABDB5C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82ABDB60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ABDB64: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82ABDB68: 816BEEA8  lwz r11, -0x1158(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4440 as u32) ) } as u64;
	// 82ABDB6C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82ABDB70: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82ABDB74: 4B80248D  bl 0x822c0000
	ctx.lr = 0x82ABDB78;
	sub_822C0000(ctx, base);
	// 82ABDB78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABDB7C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ABDB80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABDB84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABDB88: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ABDB8C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ABDB90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABDB98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABDB98 size=196
    let mut pc: u32 = 0x82ABDB98;
    'dispatch: loop {
        match pc {
            0x82ABDB98 => {
    //   block [0x82ABDB98..0x82ABDC5C)
	// 82ABDB98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABDB9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABDBA0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ABDBA4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABDBA8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABDBAC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ABDBB0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ABDBB4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82ABDBB8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82ABDBBC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ABDBC0: 4B802D79  bl 0x822c0938
	ctx.lr = 0x82ABDBC4;
	sub_822C0938(ctx, base);
	// 82ABDBC4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ABDBC8: 41820028  beq 0x82abdbf0
	if ctx.cr[0].eq {
	pc = 0x82ABDBF0; continue 'dispatch;
	}
	// 82ABDBCC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ABDBD0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82ABDBD4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82ABDBD8: 392B8D3C  addi r9, r11, -0x72c4
	ctx.r[9].s64 = ctx.r[11].s64 + -29380;
	// 82ABDBDC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82ABDBE0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82ABDBE4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82ABDBE8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82ABDBEC: 48000008  b 0x82abdbf4
	pc = 0x82ABDBF4; continue 'dispatch;
	// 82ABDBF0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ABDBF4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ABDBF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ABDBFC: 409A0044  bne cr6, 0x82abdc40
	if !ctx.cr[6].eq {
	pc = 0x82ABDC40; continue 'dispatch;
	}
	// 82ABDC00: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82ABDC04: 419A001C  beq cr6, 0x82abdc20
	if ctx.cr[6].eq {
	pc = 0x82ABDC20; continue 'dispatch;
	}
	// 82ABDC08: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABDC0C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82ABDC10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABDC14: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ABDC18: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ABDC1C: 4E800421  bctrl
	ctx.lr = 0x82ABDC20;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ABDC20: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82ABDC24: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82ABDC28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ABDC2C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82ABDC30: 816BEEA8  lwz r11, -0x1158(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4440 as u32) ) } as u64;
	// 82ABDC34: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82ABDC38: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82ABDC3C: 4B8023C5  bl 0x822c0000
	ctx.lr = 0x82ABDC40;
	sub_822C0000(ctx, base);
	// 82ABDC40: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABDC44: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ABDC48: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABDC4C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABDC50: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ABDC54: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ABDC58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABDC60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABDC60 size=196
    let mut pc: u32 = 0x82ABDC60;
    'dispatch: loop {
        match pc {
            0x82ABDC60 => {
    //   block [0x82ABDC60..0x82ABDD24)
	// 82ABDC60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABDC64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABDC68: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ABDC6C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABDC70: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABDC74: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ABDC78: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ABDC7C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82ABDC80: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82ABDC84: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ABDC88: 4B802CB1  bl 0x822c0938
	ctx.lr = 0x82ABDC8C;
	sub_822C0938(ctx, base);
	// 82ABDC8C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ABDC90: 41820028  beq 0x82abdcb8
	if ctx.cr[0].eq {
	pc = 0x82ABDCB8; continue 'dispatch;
	}
	// 82ABDC94: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ABDC98: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82ABDC9C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82ABDCA0: 392B8D50  addi r9, r11, -0x72b0
	ctx.r[9].s64 = ctx.r[11].s64 + -29360;
	// 82ABDCA4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82ABDCA8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82ABDCAC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82ABDCB0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82ABDCB4: 48000008  b 0x82abdcbc
	pc = 0x82ABDCBC; continue 'dispatch;
	// 82ABDCB8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ABDCBC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ABDCC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ABDCC4: 409A0044  bne cr6, 0x82abdd08
	if !ctx.cr[6].eq {
	pc = 0x82ABDD08; continue 'dispatch;
	}
	// 82ABDCC8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82ABDCCC: 419A001C  beq cr6, 0x82abdce8
	if ctx.cr[6].eq {
	pc = 0x82ABDCE8; continue 'dispatch;
	}
	// 82ABDCD0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABDCD4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82ABDCD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABDCDC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ABDCE0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ABDCE4: 4E800421  bctrl
	ctx.lr = 0x82ABDCE8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ABDCE8: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82ABDCEC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82ABDCF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ABDCF4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82ABDCF8: 816BEEA8  lwz r11, -0x1158(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4440 as u32) ) } as u64;
	// 82ABDCFC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82ABDD00: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82ABDD04: 4B8022FD  bl 0x822c0000
	ctx.lr = 0x82ABDD08;
	sub_822C0000(ctx, base);
	// 82ABDD08: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABDD0C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ABDD10: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABDD14: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABDD18: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ABDD1C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ABDD20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABDD28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABDD28 size=112
    let mut pc: u32 = 0x82ABDD28;
    'dispatch: loop {
        match pc {
            0x82ABDD28 => {
    //   block [0x82ABDD28..0x82ABDD98)
	// 82ABDD28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABDD2C: 486EA441  bl 0x831a816c
	ctx.lr = 0x82ABDD30;
	sub_831A8130(ctx, base);
	// 82ABDD30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABDD34: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82ABDD38: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82ABDD3C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82ABDD40: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 82ABDD44: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 82ABDD48: 38600078  li r3, 0x78
	ctx.r[3].s64 = 120;
	// 82ABDD4C: 4833469D  bl 0x82df23e8
	ctx.lr = 0x82ABDD50;
	sub_82DF23E8(ctx, base);
	// 82ABDD50: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ABDD54: 41820010  beq 0x82abdd64
	if ctx.cr[0].eq {
	pc = 0x82ABDD64; continue 'dispatch;
	}
	// 82ABDD58: 480013F9  bl 0x82abf150
	ctx.lr = 0x82ABDD5C;
	sub_82ABF150(ctx, base);
	// 82ABDD5C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABDD60: 48000008  b 0x82abdd68
	pc = 0x82ABDD68; continue 'dispatch;
	// 82ABDD64: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82ABDD68: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82ABDD6C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82ABDD70: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ABDD74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABDD78: 4BFFF8A9  bl 0x82abd620
	ctx.lr = 0x82ABDD7C;
	sub_82ABD620(ctx, base);
	// 82ABDD7C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82ABDD80: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ABDD84: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABDD88: 4B802279  bl 0x822c0000
	ctx.lr = 0x82ABDD8C;
	sub_822C0000(ctx, base);
	// 82ABDD8C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ABDD90: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ABDD94: 486EA428  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABDD98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABDD98 size=112
    let mut pc: u32 = 0x82ABDD98;
    'dispatch: loop {
        match pc {
            0x82ABDD98 => {
    //   block [0x82ABDD98..0x82ABDE08)
	// 82ABDD98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABDD9C: 486EA3D1  bl 0x831a816c
	ctx.lr = 0x82ABDDA0;
	sub_831A8130(ctx, base);
	// 82ABDDA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABDDA4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82ABDDA8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82ABDDAC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82ABDDB0: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 82ABDDB4: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 82ABDDB8: 386000B0  li r3, 0xb0
	ctx.r[3].s64 = 176;
	// 82ABDDBC: 4833462D  bl 0x82df23e8
	ctx.lr = 0x82ABDDC0;
	sub_82DF23E8(ctx, base);
	// 82ABDDC0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ABDDC4: 41820010  beq 0x82abddd4
	if ctx.cr[0].eq {
	pc = 0x82ABDDD4; continue 'dispatch;
	}
	// 82ABDDC8: 48003B41  bl 0x82ac1908
	ctx.lr = 0x82ABDDCC;
	sub_82AC1908(ctx, base);
	// 82ABDDCC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABDDD0: 48000008  b 0x82abddd8
	pc = 0x82ABDDD8; continue 'dispatch;
	// 82ABDDD4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82ABDDD8: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82ABDDDC: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82ABDDE0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ABDDE4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABDDE8: 4BFFF901  bl 0x82abd6e8
	ctx.lr = 0x82ABDDEC;
	sub_82ABD6E8(ctx, base);
	// 82ABDDEC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82ABDDF0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ABDDF4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABDDF8: 4B802209  bl 0x822c0000
	ctx.lr = 0x82ABDDFC;
	sub_822C0000(ctx, base);
	// 82ABDDFC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ABDE00: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ABDE04: 486EA3B8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABDE08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABDE08 size=112
    let mut pc: u32 = 0x82ABDE08;
    'dispatch: loop {
        match pc {
            0x82ABDE08 => {
    //   block [0x82ABDE08..0x82ABDE78)
	// 82ABDE08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABDE0C: 486EA361  bl 0x831a816c
	ctx.lr = 0x82ABDE10;
	sub_831A8130(ctx, base);
	// 82ABDE10: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABDE14: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82ABDE18: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82ABDE1C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82ABDE20: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 82ABDE24: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 82ABDE28: 386000A0  li r3, 0xa0
	ctx.r[3].s64 = 160;
	// 82ABDE2C: 483345BD  bl 0x82df23e8
	ctx.lr = 0x82ABDE30;
	sub_82DF23E8(ctx, base);
	// 82ABDE30: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ABDE34: 41820010  beq 0x82abde44
	if ctx.cr[0].eq {
	pc = 0x82ABDE44; continue 'dispatch;
	}
	// 82ABDE38: 48000C49  bl 0x82abea80
	ctx.lr = 0x82ABDE3C;
	sub_82ABEA80(ctx, base);
	// 82ABDE3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABDE40: 48000008  b 0x82abde48
	pc = 0x82ABDE48; continue 'dispatch;
	// 82ABDE44: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82ABDE48: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82ABDE4C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82ABDE50: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ABDE54: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABDE58: 4BFFF959  bl 0x82abd7b0
	ctx.lr = 0x82ABDE5C;
	sub_82ABD7B0(ctx, base);
	// 82ABDE5C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82ABDE60: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ABDE64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABDE68: 4B802199  bl 0x822c0000
	ctx.lr = 0x82ABDE6C;
	sub_822C0000(ctx, base);
	// 82ABDE6C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ABDE70: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ABDE74: 486EA348  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABDE78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABDE78 size=112
    let mut pc: u32 = 0x82ABDE78;
    'dispatch: loop {
        match pc {
            0x82ABDE78 => {
    //   block [0x82ABDE78..0x82ABDEE8)
	// 82ABDE78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABDE7C: 486EA2F1  bl 0x831a816c
	ctx.lr = 0x82ABDE80;
	sub_831A8130(ctx, base);
	// 82ABDE80: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABDE84: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82ABDE88: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82ABDE8C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82ABDE90: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 82ABDE94: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 82ABDE98: 38600074  li r3, 0x74
	ctx.r[3].s64 = 116;
	// 82ABDE9C: 4833454D  bl 0x82df23e8
	ctx.lr = 0x82ABDEA0;
	sub_82DF23E8(ctx, base);
	// 82ABDEA0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ABDEA4: 41820010  beq 0x82abdeb4
	if ctx.cr[0].eq {
	pc = 0x82ABDEB4; continue 'dispatch;
	}
	// 82ABDEA8: 480019B9  bl 0x82abf860
	ctx.lr = 0x82ABDEAC;
	sub_82ABF860(ctx, base);
	// 82ABDEAC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABDEB0: 48000008  b 0x82abdeb8
	pc = 0x82ABDEB8; continue 'dispatch;
	// 82ABDEB4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82ABDEB8: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82ABDEBC: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82ABDEC0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ABDEC4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABDEC8: 4BFFF9B1  bl 0x82abd878
	ctx.lr = 0x82ABDECC;
	sub_82ABD878(ctx, base);
	// 82ABDECC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82ABDED0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ABDED4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABDED8: 4B802129  bl 0x822c0000
	ctx.lr = 0x82ABDEDC;
	sub_822C0000(ctx, base);
	// 82ABDEDC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ABDEE0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ABDEE4: 486EA2D8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABDEE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABDEE8 size=112
    let mut pc: u32 = 0x82ABDEE8;
    'dispatch: loop {
        match pc {
            0x82ABDEE8 => {
    //   block [0x82ABDEE8..0x82ABDF58)
	// 82ABDEE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABDEEC: 486EA281  bl 0x831a816c
	ctx.lr = 0x82ABDEF0;
	sub_831A8130(ctx, base);
	// 82ABDEF0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABDEF4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82ABDEF8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82ABDEFC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82ABDF00: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 82ABDF04: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 82ABDF08: 38600084  li r3, 0x84
	ctx.r[3].s64 = 132;
	// 82ABDF0C: 483344DD  bl 0x82df23e8
	ctx.lr = 0x82ABDF10;
	sub_82DF23E8(ctx, base);
	// 82ABDF10: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ABDF14: 41820010  beq 0x82abdf24
	if ctx.cr[0].eq {
	pc = 0x82ABDF24; continue 'dispatch;
	}
	// 82ABDF18: 48002231  bl 0x82ac0148
	ctx.lr = 0x82ABDF1C;
	sub_82AC0148(ctx, base);
	// 82ABDF1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABDF20: 48000008  b 0x82abdf28
	pc = 0x82ABDF28; continue 'dispatch;
	// 82ABDF24: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82ABDF28: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82ABDF2C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82ABDF30: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ABDF34: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABDF38: 4BFFFA09  bl 0x82abd940
	ctx.lr = 0x82ABDF3C;
	sub_82ABD940(ctx, base);
	// 82ABDF3C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82ABDF40: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ABDF44: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABDF48: 4B8020B9  bl 0x822c0000
	ctx.lr = 0x82ABDF4C;
	sub_822C0000(ctx, base);
	// 82ABDF4C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ABDF50: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ABDF54: 486EA268  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABDF58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABDF58 size=112
    let mut pc: u32 = 0x82ABDF58;
    'dispatch: loop {
        match pc {
            0x82ABDF58 => {
    //   block [0x82ABDF58..0x82ABDFC8)
	// 82ABDF58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABDF5C: 486EA211  bl 0x831a816c
	ctx.lr = 0x82ABDF60;
	sub_831A8130(ctx, base);
	// 82ABDF60: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABDF64: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82ABDF68: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82ABDF6C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82ABDF70: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 82ABDF74: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 82ABDF78: 38600084  li r3, 0x84
	ctx.r[3].s64 = 132;
	// 82ABDF7C: 4833446D  bl 0x82df23e8
	ctx.lr = 0x82ABDF80;
	sub_82DF23E8(ctx, base);
	// 82ABDF80: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ABDF84: 41820010  beq 0x82abdf94
	if ctx.cr[0].eq {
	pc = 0x82ABDF94; continue 'dispatch;
	}
	// 82ABDF88: 480033A9  bl 0x82ac1330
	ctx.lr = 0x82ABDF8C;
	sub_82AC1330(ctx, base);
	// 82ABDF8C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABDF90: 48000008  b 0x82abdf98
	pc = 0x82ABDF98; continue 'dispatch;
	// 82ABDF94: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82ABDF98: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82ABDF9C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82ABDFA0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ABDFA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABDFA8: 4BFFFA61  bl 0x82abda08
	ctx.lr = 0x82ABDFAC;
	sub_82ABDA08(ctx, base);
	// 82ABDFAC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82ABDFB0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ABDFB4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABDFB8: 4B802049  bl 0x822c0000
	ctx.lr = 0x82ABDFBC;
	sub_822C0000(ctx, base);
	// 82ABDFBC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ABDFC0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ABDFC4: 486EA1F8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABDFC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABDFC8 size=112
    let mut pc: u32 = 0x82ABDFC8;
    'dispatch: loop {
        match pc {
            0x82ABDFC8 => {
    //   block [0x82ABDFC8..0x82ABE038)
	// 82ABDFC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABDFCC: 486EA1A1  bl 0x831a816c
	ctx.lr = 0x82ABDFD0;
	sub_831A8130(ctx, base);
	// 82ABDFD0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABDFD4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82ABDFD8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82ABDFDC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82ABDFE0: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 82ABDFE4: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 82ABDFE8: 3860007C  li r3, 0x7c
	ctx.r[3].s64 = 124;
	// 82ABDFEC: 483343FD  bl 0x82df23e8
	ctx.lr = 0x82ABDFF0;
	sub_82DF23E8(ctx, base);
	// 82ABDFF0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ABDFF4: 41820010  beq 0x82abe004
	if ctx.cr[0].eq {
	pc = 0x82ABE004; continue 'dispatch;
	}
	// 82ABDFF8: 48001A41  bl 0x82abfa38
	ctx.lr = 0x82ABDFFC;
	sub_82ABFA38(ctx, base);
	// 82ABDFFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABE000: 48000008  b 0x82abe008
	pc = 0x82ABE008; continue 'dispatch;
	// 82ABE004: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82ABE008: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82ABE00C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82ABE010: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ABE014: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABE018: 4BFFFAB9  bl 0x82abdad0
	ctx.lr = 0x82ABE01C;
	sub_82ABDAD0(ctx, base);
	// 82ABE01C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82ABE020: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ABE024: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABE028: 4B801FD9  bl 0x822c0000
	ctx.lr = 0x82ABE02C;
	sub_822C0000(ctx, base);
	// 82ABE02C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ABE030: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ABE034: 486EA188  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABE038(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABE038 size=112
    let mut pc: u32 = 0x82ABE038;
    'dispatch: loop {
        match pc {
            0x82ABE038 => {
    //   block [0x82ABE038..0x82ABE0A8)
	// 82ABE038: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABE03C: 486EA131  bl 0x831a816c
	ctx.lr = 0x82ABE040;
	sub_831A8130(ctx, base);
	// 82ABE040: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABE044: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82ABE048: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82ABE04C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82ABE050: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 82ABE054: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 82ABE058: 38600078  li r3, 0x78
	ctx.r[3].s64 = 120;
	// 82ABE05C: 4833438D  bl 0x82df23e8
	ctx.lr = 0x82ABE060;
	sub_82DF23E8(ctx, base);
	// 82ABE060: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ABE064: 41820010  beq 0x82abe074
	if ctx.cr[0].eq {
	pc = 0x82ABE074; continue 'dispatch;
	}
	// 82ABE068: 48001459  bl 0x82abf4c0
	ctx.lr = 0x82ABE06C;
	sub_82ABF4C0(ctx, base);
	// 82ABE06C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABE070: 48000008  b 0x82abe078
	pc = 0x82ABE078; continue 'dispatch;
	// 82ABE074: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82ABE078: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82ABE07C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82ABE080: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ABE084: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABE088: 4BFFFB11  bl 0x82abdb98
	ctx.lr = 0x82ABE08C;
	sub_82ABDB98(ctx, base);
	// 82ABE08C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82ABE090: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ABE094: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABE098: 4B801F69  bl 0x822c0000
	ctx.lr = 0x82ABE09C;
	sub_822C0000(ctx, base);
	// 82ABE09C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ABE0A0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ABE0A4: 486EA118  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABE0A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABE0A8 size=112
    let mut pc: u32 = 0x82ABE0A8;
    'dispatch: loop {
        match pc {
            0x82ABE0A8 => {
    //   block [0x82ABE0A8..0x82ABE118)
	// 82ABE0A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABE0AC: 486EA0C1  bl 0x831a816c
	ctx.lr = 0x82ABE0B0;
	sub_831A8130(ctx, base);
	// 82ABE0B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABE0B4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82ABE0B8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82ABE0BC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82ABE0C0: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 82ABE0C4: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 82ABE0C8: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 82ABE0CC: 4833431D  bl 0x82df23e8
	ctx.lr = 0x82ABE0D0;
	sub_82DF23E8(ctx, base);
	// 82ABE0D0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ABE0D4: 41820010  beq 0x82abe0e4
	if ctx.cr[0].eq {
	pc = 0x82ABE0E4; continue 'dispatch;
	}
	// 82ABE0D8: 480027E9  bl 0x82ac08c0
	ctx.lr = 0x82ABE0DC;
	sub_82AC08C0(ctx, base);
	// 82ABE0DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABE0E0: 48000008  b 0x82abe0e8
	pc = 0x82ABE0E8; continue 'dispatch;
	// 82ABE0E4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82ABE0E8: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82ABE0EC: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82ABE0F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ABE0F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABE0F8: 4BFFFB69  bl 0x82abdc60
	ctx.lr = 0x82ABE0FC;
	sub_82ABDC60(ctx, base);
	// 82ABE0FC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82ABE100: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ABE104: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABE108: 4B801EF9  bl 0x822c0000
	ctx.lr = 0x82ABE10C;
	sub_822C0000(ctx, base);
	// 82ABE10C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ABE110: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ABE114: 486EA0A8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABE118(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABE118 size=92
    let mut pc: u32 = 0x82ABE118;
    'dispatch: loop {
        match pc {
            0x82ABE118 => {
    //   block [0x82ABE118..0x82ABE174)
	// 82ABE118: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABE11C: 486EA051  bl 0x831a816c
	ctx.lr = 0x82ABE120;
	sub_831A8130(ctx, base);
	// 82ABE120: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABE124: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ABE128: 3D4082AC  lis r10, -0x7d54
	ctx.r[10].s64 = -2102657024;
	// 82ABE12C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82ABE130: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABE134: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ABE138: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82ABE13C: 388ADD28  addi r4, r10, -0x22d8
	ctx.r[4].s64 = ctx.r[10].s64 + -8920;
	// 82ABE140: 4B8A1931  bl 0x8235fa70
	ctx.lr = 0x82ABE144;
	sub_8235FA70(ctx, base);
	// 82ABE144: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ABE148: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ABE14C: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82ABE150: 48335AB1  bl 0x82df3c00
	ctx.lr = 0x82ABE154;
	sub_82DF3C00(ctx, base);
	// 82ABE154: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82ABE158: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABE15C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82ABE160: 4839DFF9  bl 0x82e5c158
	ctx.lr = 0x82ABE164;
	sub_82E5C158(ctx, base);
	// 82ABE164: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABE168: 483352C1  bl 0x82df3428
	ctx.lr = 0x82ABE16C;
	sub_82DF3428(ctx, base);
	// 82ABE16C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82ABE170: 486EA04C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABE178(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABE178 size=92
    let mut pc: u32 = 0x82ABE178;
    'dispatch: loop {
        match pc {
            0x82ABE178 => {
    //   block [0x82ABE178..0x82ABE1D4)
	// 82ABE178: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABE17C: 486E9FF1  bl 0x831a816c
	ctx.lr = 0x82ABE180;
	sub_831A8130(ctx, base);
	// 82ABE180: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABE184: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ABE188: 3D4082AC  lis r10, -0x7d54
	ctx.r[10].s64 = -2102657024;
	// 82ABE18C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82ABE190: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABE194: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ABE198: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82ABE19C: 388ADD98  addi r4, r10, -0x2268
	ctx.r[4].s64 = ctx.r[10].s64 + -8808;
	// 82ABE1A0: 4B8A18D1  bl 0x8235fa70
	ctx.lr = 0x82ABE1A4;
	sub_8235FA70(ctx, base);
	// 82ABE1A4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ABE1A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ABE1AC: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82ABE1B0: 48335A51  bl 0x82df3c00
	ctx.lr = 0x82ABE1B4;
	sub_82DF3C00(ctx, base);
	// 82ABE1B4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82ABE1B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABE1BC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82ABE1C0: 4839DF99  bl 0x82e5c158
	ctx.lr = 0x82ABE1C4;
	sub_82E5C158(ctx, base);
	// 82ABE1C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABE1C8: 48335261  bl 0x82df3428
	ctx.lr = 0x82ABE1CC;
	sub_82DF3428(ctx, base);
	// 82ABE1CC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82ABE1D0: 486E9FEC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABE1D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABE1D8 size=92
    let mut pc: u32 = 0x82ABE1D8;
    'dispatch: loop {
        match pc {
            0x82ABE1D8 => {
    //   block [0x82ABE1D8..0x82ABE234)
	// 82ABE1D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABE1DC: 486E9F91  bl 0x831a816c
	ctx.lr = 0x82ABE1E0;
	sub_831A8130(ctx, base);
	// 82ABE1E0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABE1E4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ABE1E8: 3D4082AC  lis r10, -0x7d54
	ctx.r[10].s64 = -2102657024;
	// 82ABE1EC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82ABE1F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABE1F4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ABE1F8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82ABE1FC: 388ADE08  addi r4, r10, -0x21f8
	ctx.r[4].s64 = ctx.r[10].s64 + -8696;
	// 82ABE200: 4B8A1871  bl 0x8235fa70
	ctx.lr = 0x82ABE204;
	sub_8235FA70(ctx, base);
	// 82ABE204: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ABE208: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ABE20C: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82ABE210: 483359F1  bl 0x82df3c00
	ctx.lr = 0x82ABE214;
	sub_82DF3C00(ctx, base);
	// 82ABE214: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82ABE218: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABE21C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82ABE220: 4839DF39  bl 0x82e5c158
	ctx.lr = 0x82ABE224;
	sub_82E5C158(ctx, base);
	// 82ABE224: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABE228: 48335201  bl 0x82df3428
	ctx.lr = 0x82ABE22C;
	sub_82DF3428(ctx, base);
	// 82ABE22C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82ABE230: 486E9F8C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABE238(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABE238 size=92
    let mut pc: u32 = 0x82ABE238;
    'dispatch: loop {
        match pc {
            0x82ABE238 => {
    //   block [0x82ABE238..0x82ABE294)
	// 82ABE238: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABE23C: 486E9F31  bl 0x831a816c
	ctx.lr = 0x82ABE240;
	sub_831A8130(ctx, base);
	// 82ABE240: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABE244: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ABE248: 3D4082AC  lis r10, -0x7d54
	ctx.r[10].s64 = -2102657024;
	// 82ABE24C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82ABE250: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABE254: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ABE258: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82ABE25C: 388ADE78  addi r4, r10, -0x2188
	ctx.r[4].s64 = ctx.r[10].s64 + -8584;
	// 82ABE260: 4B8A1811  bl 0x8235fa70
	ctx.lr = 0x82ABE264;
	sub_8235FA70(ctx, base);
	// 82ABE264: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ABE268: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ABE26C: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82ABE270: 48335991  bl 0x82df3c00
	ctx.lr = 0x82ABE274;
	sub_82DF3C00(ctx, base);
	// 82ABE274: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82ABE278: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABE27C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82ABE280: 4839DED9  bl 0x82e5c158
	ctx.lr = 0x82ABE284;
	sub_82E5C158(ctx, base);
	// 82ABE284: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABE288: 483351A1  bl 0x82df3428
	ctx.lr = 0x82ABE28C;
	sub_82DF3428(ctx, base);
	// 82ABE28C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82ABE290: 486E9F2C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABE298(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABE298 size=92
    let mut pc: u32 = 0x82ABE298;
    'dispatch: loop {
        match pc {
            0x82ABE298 => {
    //   block [0x82ABE298..0x82ABE2F4)
	// 82ABE298: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABE29C: 486E9ED1  bl 0x831a816c
	ctx.lr = 0x82ABE2A0;
	sub_831A8130(ctx, base);
	// 82ABE2A0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABE2A4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ABE2A8: 3D4082AC  lis r10, -0x7d54
	ctx.r[10].s64 = -2102657024;
	// 82ABE2AC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82ABE2B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABE2B4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ABE2B8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82ABE2BC: 388ADEE8  addi r4, r10, -0x2118
	ctx.r[4].s64 = ctx.r[10].s64 + -8472;
	// 82ABE2C0: 4B8A17B1  bl 0x8235fa70
	ctx.lr = 0x82ABE2C4;
	sub_8235FA70(ctx, base);
	// 82ABE2C4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ABE2C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ABE2CC: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82ABE2D0: 48335931  bl 0x82df3c00
	ctx.lr = 0x82ABE2D4;
	sub_82DF3C00(ctx, base);
	// 82ABE2D4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82ABE2D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABE2DC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82ABE2E0: 4839DE79  bl 0x82e5c158
	ctx.lr = 0x82ABE2E4;
	sub_82E5C158(ctx, base);
	// 82ABE2E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABE2E8: 48335141  bl 0x82df3428
	ctx.lr = 0x82ABE2EC;
	sub_82DF3428(ctx, base);
	// 82ABE2EC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82ABE2F0: 486E9ECC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABE2F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABE2F8 size=92
    let mut pc: u32 = 0x82ABE2F8;
    'dispatch: loop {
        match pc {
            0x82ABE2F8 => {
    //   block [0x82ABE2F8..0x82ABE354)
	// 82ABE2F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABE2FC: 486E9E71  bl 0x831a816c
	ctx.lr = 0x82ABE300;
	sub_831A8130(ctx, base);
	// 82ABE300: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABE304: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ABE308: 3D4082AC  lis r10, -0x7d54
	ctx.r[10].s64 = -2102657024;
	// 82ABE30C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82ABE310: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABE314: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ABE318: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82ABE31C: 388ADF58  addi r4, r10, -0x20a8
	ctx.r[4].s64 = ctx.r[10].s64 + -8360;
	// 82ABE320: 4B8A1751  bl 0x8235fa70
	ctx.lr = 0x82ABE324;
	sub_8235FA70(ctx, base);
	// 82ABE324: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ABE328: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ABE32C: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82ABE330: 483358D1  bl 0x82df3c00
	ctx.lr = 0x82ABE334;
	sub_82DF3C00(ctx, base);
	// 82ABE334: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82ABE338: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABE33C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82ABE340: 4839DE19  bl 0x82e5c158
	ctx.lr = 0x82ABE344;
	sub_82E5C158(ctx, base);
	// 82ABE344: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABE348: 483350E1  bl 0x82df3428
	ctx.lr = 0x82ABE34C;
	sub_82DF3428(ctx, base);
	// 82ABE34C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82ABE350: 486E9E6C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABE358(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABE358 size=92
    let mut pc: u32 = 0x82ABE358;
    'dispatch: loop {
        match pc {
            0x82ABE358 => {
    //   block [0x82ABE358..0x82ABE3B4)
	// 82ABE358: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABE35C: 486E9E11  bl 0x831a816c
	ctx.lr = 0x82ABE360;
	sub_831A8130(ctx, base);
	// 82ABE360: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABE364: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ABE368: 3D4082AC  lis r10, -0x7d54
	ctx.r[10].s64 = -2102657024;
	// 82ABE36C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82ABE370: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABE374: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ABE378: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82ABE37C: 388ADFC8  addi r4, r10, -0x2038
	ctx.r[4].s64 = ctx.r[10].s64 + -8248;
	// 82ABE380: 4B8A16F1  bl 0x8235fa70
	ctx.lr = 0x82ABE384;
	sub_8235FA70(ctx, base);
	// 82ABE384: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ABE388: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ABE38C: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82ABE390: 48335871  bl 0x82df3c00
	ctx.lr = 0x82ABE394;
	sub_82DF3C00(ctx, base);
	// 82ABE394: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82ABE398: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABE39C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82ABE3A0: 4839DDB9  bl 0x82e5c158
	ctx.lr = 0x82ABE3A4;
	sub_82E5C158(ctx, base);
	// 82ABE3A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABE3A8: 48335081  bl 0x82df3428
	ctx.lr = 0x82ABE3AC;
	sub_82DF3428(ctx, base);
	// 82ABE3AC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82ABE3B0: 486E9E0C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABE3B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABE3B8 size=92
    let mut pc: u32 = 0x82ABE3B8;
    'dispatch: loop {
        match pc {
            0x82ABE3B8 => {
    //   block [0x82ABE3B8..0x82ABE414)
	// 82ABE3B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABE3BC: 486E9DB1  bl 0x831a816c
	ctx.lr = 0x82ABE3C0;
	sub_831A8130(ctx, base);
	// 82ABE3C0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABE3C4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ABE3C8: 3D4082AC  lis r10, -0x7d54
	ctx.r[10].s64 = -2102657024;
	// 82ABE3CC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82ABE3D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABE3D4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ABE3D8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82ABE3DC: 388AE038  addi r4, r10, -0x1fc8
	ctx.r[4].s64 = ctx.r[10].s64 + -8136;
	// 82ABE3E0: 4B8A1691  bl 0x8235fa70
	ctx.lr = 0x82ABE3E4;
	sub_8235FA70(ctx, base);
	// 82ABE3E4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ABE3E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ABE3EC: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82ABE3F0: 48335811  bl 0x82df3c00
	ctx.lr = 0x82ABE3F4;
	sub_82DF3C00(ctx, base);
	// 82ABE3F4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82ABE3F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABE3FC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82ABE400: 4839DD59  bl 0x82e5c158
	ctx.lr = 0x82ABE404;
	sub_82E5C158(ctx, base);
	// 82ABE404: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABE408: 48335021  bl 0x82df3428
	ctx.lr = 0x82ABE40C;
	sub_82DF3428(ctx, base);
	// 82ABE40C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82ABE410: 486E9DAC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABE418(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABE418 size=92
    let mut pc: u32 = 0x82ABE418;
    'dispatch: loop {
        match pc {
            0x82ABE418 => {
    //   block [0x82ABE418..0x82ABE474)
	// 82ABE418: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABE41C: 486E9D51  bl 0x831a816c
	ctx.lr = 0x82ABE420;
	sub_831A8130(ctx, base);
	// 82ABE420: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABE424: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ABE428: 3D4082AC  lis r10, -0x7d54
	ctx.r[10].s64 = -2102657024;
	// 82ABE42C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82ABE430: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABE434: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ABE438: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82ABE43C: 388AE0A8  addi r4, r10, -0x1f58
	ctx.r[4].s64 = ctx.r[10].s64 + -8024;
	// 82ABE440: 4B8A1631  bl 0x8235fa70
	ctx.lr = 0x82ABE444;
	sub_8235FA70(ctx, base);
	// 82ABE444: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ABE448: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ABE44C: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82ABE450: 483357B1  bl 0x82df3c00
	ctx.lr = 0x82ABE454;
	sub_82DF3C00(ctx, base);
	// 82ABE454: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82ABE458: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABE45C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82ABE460: 4839DCF9  bl 0x82e5c158
	ctx.lr = 0x82ABE464;
	sub_82E5C158(ctx, base);
	// 82ABE464: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABE468: 48334FC1  bl 0x82df3428
	ctx.lr = 0x82ABE46C;
	sub_82DF3428(ctx, base);
	// 82ABE46C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82ABE470: 486E9D4C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABE478(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ABE478 size=408
    let mut pc: u32 = 0x82ABE478;
    'dispatch: loop {
        match pc {
            0x82ABE478 => {
    //   block [0x82ABE478..0x82ABE610)
	// 82ABE478: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABE47C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABE480: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ABE484: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABE488: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABE48C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABE490: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ABE494: 4839F43D  bl 0x82e5d8d0
	ctx.lr = 0x82ABE498;
	sub_82E5D8D0(ctx, base);
	// 82ABE498: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ABE49C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82ABE4A0: 396B8CA0  addi r11, r11, -0x7360
	ctx.r[11].s64 = ctx.r[11].s64 + -29536;
	// 82ABE4A4: 995F0060  stb r10, 0x60(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[10].u8 ) };
	// 82ABE4A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABE4AC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ABE4B0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ABE4B4: 48594E5D  bl 0x83053310
	ctx.lr = 0x82ABE4B8;
	sub_83053310(ctx, base);
	// 82ABE4B8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82ABE4BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ABE4C0: 3BCB893C  addi r30, r11, -0x76c4
	ctx.r[30].s64 = ctx.r[11].s64 + -30404;
	// 82ABE4C4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ABE4C8: 48335541  bl 0x82df3a08
	ctx.lr = 0x82ABE4CC;
	sub_82DF3A08(ctx, base);
	// 82ABE4CC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82ABE4D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABE4D4: 4BFFFC45  bl 0x82abe118
	ctx.lr = 0x82ABE4D8;
	sub_82ABE118(ctx, base);
	// 82ABE4D8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ABE4DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ABE4E0: 388B5E38  addi r4, r11, 0x5e38
	ctx.r[4].s64 = ctx.r[11].s64 + 24120;
	// 82ABE4E4: 48335525  bl 0x82df3a08
	ctx.lr = 0x82ABE4E8;
	sub_82DF3A08(ctx, base);
	// 82ABE4E8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82ABE4EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABE4F0: 4BFFFC89  bl 0x82abe178
	ctx.lr = 0x82ABE4F4;
	sub_82ABE178(ctx, base);
	// 82ABE4F4: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82ABE4F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ABE4FC: 388BCB24  addi r4, r11, -0x34dc
	ctx.r[4].s64 = ctx.r[11].s64 + -13532;
	// 82ABE500: 48335509  bl 0x82df3a08
	ctx.lr = 0x82ABE504;
	sub_82DF3A08(ctx, base);
	// 82ABE504: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82ABE508: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABE50C: 4BFFFCCD  bl 0x82abe1d8
	ctx.lr = 0x82ABE510;
	sub_82ABE1D8(ctx, base);
	// 82ABE510: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82ABE514: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ABE518: 388B0740  addi r4, r11, 0x740
	ctx.r[4].s64 = ctx.r[11].s64 + 1856;
	// 82ABE51C: 483354ED  bl 0x82df3a08
	ctx.lr = 0x82ABE520;
	sub_82DF3A08(ctx, base);
	// 82ABE520: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82ABE524: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABE528: 4BFFFD11  bl 0x82abe238
	ctx.lr = 0x82ABE52C;
	sub_82ABE238(ctx, base);
	// 82ABE52C: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 82ABE530: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ABE534: 388BECC4  addi r4, r11, -0x133c
	ctx.r[4].s64 = ctx.r[11].s64 + -4924;
	// 82ABE538: 483354D1  bl 0x82df3a08
	ctx.lr = 0x82ABE53C;
	sub_82DF3A08(ctx, base);
	// 82ABE53C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82ABE540: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABE544: 4BFFFD55  bl 0x82abe298
	ctx.lr = 0x82ABE548;
	sub_82ABE298(ctx, base);
	// 82ABE548: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 82ABE54C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ABE550: 388B09D0  addi r4, r11, 0x9d0
	ctx.r[4].s64 = ctx.r[11].s64 + 2512;
	// 82ABE554: 483354B5  bl 0x82df3a08
	ctx.lr = 0x82ABE558;
	sub_82DF3A08(ctx, base);
	// 82ABE558: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82ABE55C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABE560: 4BFFFD99  bl 0x82abe2f8
	ctx.lr = 0x82ABE564;
	sub_82ABE2F8(ctx, base);
	// 82ABE564: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82ABE568: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ABE56C: 388BC8D0  addi r4, r11, -0x3730
	ctx.r[4].s64 = ctx.r[11].s64 + -14128;
	// 82ABE570: 48335499  bl 0x82df3a08
	ctx.lr = 0x82ABE574;
	sub_82DF3A08(ctx, base);
	// 82ABE574: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82ABE578: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABE57C: 4BFFFDDD  bl 0x82abe358
	ctx.lr = 0x82ABE580;
	sub_82ABE358(ctx, base);
	// 82ABE580: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82ABE584: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ABE588: 388B7A38  addi r4, r11, 0x7a38
	ctx.r[4].s64 = ctx.r[11].s64 + 31288;
	// 82ABE58C: 4833547D  bl 0x82df3a08
	ctx.lr = 0x82ABE590;
	sub_82DF3A08(ctx, base);
	// 82ABE590: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82ABE594: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABE598: 4BFFFE21  bl 0x82abe3b8
	ctx.lr = 0x82ABE59C;
	sub_82ABE3B8(ctx, base);
	// 82ABE59C: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82ABE5A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ABE5A4: 388B31AC  addi r4, r11, 0x31ac
	ctx.r[4].s64 = ctx.r[11].s64 + 12716;
	// 82ABE5A8: 48335461  bl 0x82df3a08
	ctx.lr = 0x82ABE5AC;
	sub_82DF3A08(ctx, base);
	// 82ABE5AC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82ABE5B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABE5B4: 4BFFFE65  bl 0x82abe418
	ctx.lr = 0x82ABE5B8;
	sub_82ABE418(ctx, base);
	// 82ABE5B8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ABE5BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ABE5C0: 48335449  bl 0x82df3a08
	ctx.lr = 0x82ABE5C4;
	sub_82DF3A08(ctx, base);
	// 82ABE5C4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82ABE5C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ABE5CC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82ABE5D0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ABE5D4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82ABE5D8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82ABE5DC: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82ABE5E0: 483A0381  bl 0x82e5e960
	ctx.lr = 0x82ABE5E4;
	sub_82E5E960(ctx, base);
	// 82ABE5E4: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82ABE5E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ABE5EC: 419A0008  beq cr6, 0x82abe5f4
	if ctx.cr[6].eq {
	pc = 0x82ABE5F4; continue 'dispatch;
	}
	// 82ABE5F0: 4B8022A1  bl 0x822c0890
	ctx.lr = 0x82ABE5F4;
	sub_822C0890(ctx, base);
	// 82ABE5F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABE5F8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82ABE5FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABE600: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABE604: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ABE608: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ABE60C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABE610(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ABE610 size=84
    let mut pc: u32 = 0x82ABE610;
    'dispatch: loop {
        match pc {
            0x82ABE610 => {
    //   block [0x82ABE610..0x82ABE664)
	// 82ABE610: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABE614: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABE618: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABE61C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABE620: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABE624: 48695FDD  bl 0x83154600
	ctx.lr = 0x82ABE628;
	sub_83154600(ctx, base);
	// 82ABE628: 4BF54891  bl 0x82a12eb8
	ctx.lr = 0x82ABE62C;
	sub_82A12EB8(ctx, base);
	// 82ABE62C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ABE630: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82ABE634: 809F0074  lwz r4, 0x74(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82ABE638: C04B8398  lfs f2, -0x7c68(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-31848 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82ABE63C: C02A9450  lfs f1, -0x6bb0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82ABE640: 4BFFBAC1  bl 0x82aba100
	ctx.lr = 0x82ABE644;
	sub_82ABA100(ctx, base);
	// 82ABE644: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ABE648: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ABE64C: D01F009C  stfs f0, 0x9c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82ABE650: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82ABE654: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABE658: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABE65C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ABE660: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABE668(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ABE668 size=124
    let mut pc: u32 = 0x82ABE668;
    'dispatch: loop {
        match pc {
            0x82ABE668 => {
    //   block [0x82ABE668..0x82ABE6E4)
	// 82ABE668: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABE66C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABE670: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABE674: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABE678: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABE67C: 897F0096  lbz r11, 0x96(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(150 as u32) ) } as u64;
	// 82ABE680: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ABE684: 4082004C  bne 0x82abe6d0
	if !ctx.cr[0].eq {
	pc = 0x82ABE6D0; continue 'dispatch;
	}
	// 82ABE688: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ABE68C: C1BF0080  lfs f13, 0x80(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ABE690: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ABE694: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82ABE698: 41980024  blt cr6, 0x82abe6bc
	if ctx.cr[6].lt {
	pc = 0x82ABE6BC; continue 'dispatch;
	}
	// 82ABE69C: 4839B0DD  bl 0x82e59778
	ctx.lr = 0x82ABE6A0;
	sub_82E59778(ctx, base);
	// 82ABE6A0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ABE6A4: C1BF0080  lfs f13, 0x80(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ABE6A8: C00B8398  lfs f0, -0x7c68(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-31848 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ABE6AC: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ABE6B0: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82ABE6B4: D01F0080  stfs f0, 0x80(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82ABE6B8: 48000018  b 0x82abe6d0
	pc = 0x82ABE6D0; continue 'dispatch;
	// 82ABE6BC: 48695F45  bl 0x83154600
	ctx.lr = 0x82ABE6C0;
	sub_83154600(ctx, base);
	// 82ABE6C0: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82ABE6C4: 4BFF4A2D  bl 0x82ab30f0
	ctx.lr = 0x82ABE6C8;
	sub_82AB30F0(ctx, base);
	// 82ABE6C8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82ABE6CC: 997F0096  stb r11, 0x96(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(150 as u32), ctx.r[11].u8 ) };
	// 82ABE6D0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82ABE6D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABE6D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABE6DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ABE6E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABE6E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ABE6E8 size=124
    let mut pc: u32 = 0x82ABE6E8;
    'dispatch: loop {
        match pc {
            0x82ABE6E8 => {
    //   block [0x82ABE6E8..0x82ABE764)
	// 82ABE6E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABE6EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABE6F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABE6F4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABE6F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABE6FC: 897F0097  lbz r11, 0x97(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(151 as u32) ) } as u64;
	// 82ABE700: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ABE704: 4082004C  bne 0x82abe750
	if !ctx.cr[0].eq {
	pc = 0x82ABE750; continue 'dispatch;
	}
	// 82ABE708: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ABE70C: C1BF0088  lfs f13, 0x88(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ABE710: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ABE714: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82ABE718: 41980024  blt cr6, 0x82abe73c
	if ctx.cr[6].lt {
	pc = 0x82ABE73C; continue 'dispatch;
	}
	// 82ABE71C: 4839B05D  bl 0x82e59778
	ctx.lr = 0x82ABE720;
	sub_82E59778(ctx, base);
	// 82ABE720: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ABE724: C1BF0088  lfs f13, 0x88(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ABE728: C00B8398  lfs f0, -0x7c68(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-31848 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ABE72C: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ABE730: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82ABE734: D01F0088  stfs f0, 0x88(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82ABE738: 48000018  b 0x82abe750
	pc = 0x82ABE750; continue 'dispatch;
	// 82ABE73C: 48695EC5  bl 0x83154600
	ctx.lr = 0x82ABE740;
	sub_83154600(ctx, base);
	// 82ABE740: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82ABE744: 4BFF49AD  bl 0x82ab30f0
	ctx.lr = 0x82ABE748;
	sub_82AB30F0(ctx, base);
	// 82ABE748: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82ABE74C: 997F0097  stb r11, 0x97(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(151 as u32), ctx.r[11].u8 ) };
	// 82ABE750: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82ABE754: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABE758: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABE75C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ABE760: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABE768(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABE768 size=164
    let mut pc: u32 = 0x82ABE768;
    'dispatch: loop {
        match pc {
            0x82ABE768 => {
    //   block [0x82ABE768..0x82ABE80C)
	// 82ABE768: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABE76C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABE770: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABE774: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABE778: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABE77C: 897F0096  lbz r11, 0x96(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(150 as u32) ) } as u64;
	// 82ABE780: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ABE784: 41820010  beq 0x82abe794
	if ctx.cr[0].eq {
	pc = 0x82ABE794; continue 'dispatch;
	}
	// 82ABE788: 897F0097  lbz r11, 0x97(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(151 as u32) ) } as u64;
	// 82ABE78C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ABE790: 40820068  bne 0x82abe7f8
	if !ctx.cr[0].eq {
	pc = 0x82ABE7F8; continue 'dispatch;
	}
	// 82ABE794: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABE798: 48695E69  bl 0x83154600
	ctx.lr = 0x82ABE79C;
	sub_83154600(ctx, base);
	// 82ABE79C: 4BFF23F5  bl 0x82ab0b90
	ctx.lr = 0x82ABE7A0;
	sub_82AB0B90(ctx, base);
	// 82ABE7A0: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 82ABE7A4: 419A0044  beq cr6, 0x82abe7e8
	if ctx.cr[6].eq {
	pc = 0x82ABE7E8; continue 'dispatch;
	}
	// 82ABE7A8: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 82ABE7AC: 419A0014  beq cr6, 0x82abe7c0
	if ctx.cr[6].eq {
	pc = 0x82ABE7C0; continue 'dispatch;
	}
	// 82ABE7B0: 2F030003  cmpwi cr6, r3, 3
	ctx.cr[6].compare_i32(ctx.r[3].s32, 3, &mut ctx.xer);
	// 82ABE7B4: 419A0020  beq cr6, 0x82abe7d4
	if ctx.cr[6].eq {
	pc = 0x82ABE7D4; continue 'dispatch;
	}
	// 82ABE7B8: 2F030004  cmpwi cr6, r3, 4
	ctx.cr[6].compare_i32(ctx.r[3].s32, 4, &mut ctx.xer);
	// 82ABE7BC: 409A003C  bne cr6, 0x82abe7f8
	if !ctx.cr[6].eq {
	pc = 0x82ABE7F8; continue 'dispatch;
	}
	// 82ABE7C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABE7C4: 4BFFFEA5  bl 0x82abe668
	ctx.lr = 0x82ABE7C8;
	sub_82ABE668(ctx, base);
	// 82ABE7C8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82ABE7CC: 997F0097  stb r11, 0x97(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(151 as u32), ctx.r[11].u8 ) };
	// 82ABE7D0: 48000028  b 0x82abe7f8
	pc = 0x82ABE7F8; continue 'dispatch;
	// 82ABE7D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABE7D8: 4BFFFF11  bl 0x82abe6e8
	ctx.lr = 0x82ABE7DC;
	sub_82ABE6E8(ctx, base);
	// 82ABE7DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABE7E0: 4BFFFE89  bl 0x82abe668
	ctx.lr = 0x82ABE7E4;
	sub_82ABE668(ctx, base);
	// 82ABE7E4: 48000014  b 0x82abe7f8
	pc = 0x82ABE7F8; continue 'dispatch;
	// 82ABE7E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABE7EC: 4BFFFEFD  bl 0x82abe6e8
	ctx.lr = 0x82ABE7F0;
	sub_82ABE6E8(ctx, base);
	// 82ABE7F0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82ABE7F4: 997F0096  stb r11, 0x96(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(150 as u32), ctx.r[11].u8 ) };
	// 82ABE7F8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82ABE7FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABE800: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABE804: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ABE808: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABE810(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ABE810 size=240
    let mut pc: u32 = 0x82ABE810;
    'dispatch: loop {
        match pc {
            0x82ABE810 => {
    //   block [0x82ABE810..0x82ABE900)
	// 82ABE810: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABE814: 486E9955  bl 0x831a8168
	ctx.lr = 0x82ABE818;
	sub_831A8130(ctx, base);
	// 82ABE818: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82ABE81C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABE820: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABE824: 897F0098  lbz r11, 0x98(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 82ABE828: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ABE82C: 41820010  beq 0x82abe83c
	if ctx.cr[0].eq {
	pc = 0x82ABE83C; continue 'dispatch;
	}
	// 82ABE830: 897F0099  lbz r11, 0x99(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(153 as u32) ) } as u64;
	// 82ABE834: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ABE838: 408200BC  bne 0x82abe8f4
	if !ctx.cr[0].eq {
	pc = 0x82ABE8F4; continue 'dispatch;
	}
	// 82ABE83C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABE840: 48695DC1  bl 0x83154600
	ctx.lr = 0x82ABE844;
	sub_83154600(ctx, base);
	// 82ABE844: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ABE848: 895F0096  lbz r10, 0x96(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(150 as u32) ) } as u64;
	// 82ABE84C: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 82ABE850: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ABE854: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ABE858: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82ABE85C: 41820028  beq 0x82abe884
	if ctx.cr[0].eq {
	pc = 0x82ABE884; continue 'dispatch;
	}
	// 82ABE860: 897F0098  lbz r11, 0x98(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 82ABE864: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ABE868: 4082001C  bne 0x82abe884
	if !ctx.cr[0].eq {
	pc = 0x82ABE884; continue 'dispatch;
	}
	// 82ABE86C: C01F0084  lfs f0, 0x84(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ABE870: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82ABE874: 41990010  bgt cr6, 0x82abe884
	if ctx.cr[6].gt {
	pc = 0x82ABE884; continue 'dispatch;
	}
	// 82ABE878: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82ABE87C: 4BFF4C55  bl 0x82ab34d0
	ctx.lr = 0x82ABE880;
	sub_82AB34D0(ctx, base);
	// 82ABE880: 9B9F0098  stb r28, 0x98(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[28].u8 ) };
	// 82ABE884: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABE888: 4839AEF1  bl 0x82e59778
	ctx.lr = 0x82ABE88C;
	sub_82E59778(ctx, base);
	// 82ABE88C: 3FA0820C  lis r29, -0x7df4
	ctx.r[29].s64 = -2113142784;
	// 82ABE890: C1BF0084  lfs f13, 0x84(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ABE894: 897F0097  lbz r11, 0x97(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(151 as u32) ) } as u64;
	// 82ABE898: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ABE89C: C01D8398  lfs f0, -0x7c68(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-31848 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ABE8A0: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ABE8A4: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82ABE8A8: D01F0084  stfs f0, 0x84(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82ABE8AC: 4182002C  beq 0x82abe8d8
	if ctx.cr[0].eq {
	pc = 0x82ABE8D8; continue 'dispatch;
	}
	// 82ABE8B0: 897F0099  lbz r11, 0x99(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(153 as u32) ) } as u64;
	// 82ABE8B4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ABE8B8: 40820020  bne 0x82abe8d8
	if !ctx.cr[0].eq {
	pc = 0x82ABE8D8; continue 'dispatch;
	}
	// 82ABE8BC: C01F008C  lfs f0, 0x8c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ABE8C0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82ABE8C4: 41990014  bgt cr6, 0x82abe8d8
	if ctx.cr[6].gt {
	pc = 0x82ABE8D8; continue 'dispatch;
	}
	// 82ABE8C8: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82ABE8CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABE8D0: 4BFF4C01  bl 0x82ab34d0
	ctx.lr = 0x82ABE8D4;
	sub_82AB34D0(ctx, base);
	// 82ABE8D4: 9B9F0099  stb r28, 0x99(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(153 as u32), ctx.r[28].u8 ) };
	// 82ABE8D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABE8DC: 4839AE9D  bl 0x82e59778
	ctx.lr = 0x82ABE8E0;
	sub_82E59778(ctx, base);
	// 82ABE8E0: C01D8398  lfs f0, -0x7c68(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-31848 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ABE8E4: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ABE8E8: C1BF008C  lfs f13, 0x8c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ABE8EC: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82ABE8F0: D01F008C  stfs f0, 0x8c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82ABE8F4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82ABE8F8: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82ABE8FC: 486E98BC  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABE900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ABE900 size=128
    let mut pc: u32 = 0x82ABE900;
    'dispatch: loop {
        match pc {
            0x82ABE900 => {
    //   block [0x82ABE900..0x82ABE980)
	// 82ABE900: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABE904: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABE908: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABE90C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABE910: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABE914: 897F0094  lbz r11, 0x94(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 82ABE918: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82ABE91C: 419A0050  beq cr6, 0x82abe96c
	if ctx.cr[6].eq {
	pc = 0x82ABE96C; continue 'dispatch;
	}
	// 82ABE920: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ABE924: C1BF0078  lfs f13, 0x78(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ABE928: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ABE92C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82ABE930: 41980024  blt cr6, 0x82abe954
	if ctx.cr[6].lt {
	pc = 0x82ABE954; continue 'dispatch;
	}
	// 82ABE934: 4839AE45  bl 0x82e59778
	ctx.lr = 0x82ABE938;
	sub_82E59778(ctx, base);
	// 82ABE938: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ABE93C: C1BF0078  lfs f13, 0x78(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ABE940: C00B8398  lfs f0, -0x7c68(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-31848 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ABE944: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ABE948: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82ABE94C: D01F0078  stfs f0, 0x78(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82ABE950: 4800001C  b 0x82abe96c
	pc = 0x82ABE96C; continue 'dispatch;
	// 82ABE954: 48695CAD  bl 0x83154600
	ctx.lr = 0x82ABE958;
	sub_83154600(ctx, base);
	// 82ABE958: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82ABE95C: 809F0090  lwz r4, 0x90(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 82ABE960: 4BFF6FC1  bl 0x82ab5920
	ctx.lr = 0x82ABE964;
	sub_82AB5920(ctx, base);
	// 82ABE964: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82ABE968: 997F0094  stb r11, 0x94(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[11].u8 ) };
	// 82ABE96C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82ABE970: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABE974: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABE978: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ABE97C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABE980(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ABE980 size=188
    let mut pc: u32 = 0x82ABE980;
    'dispatch: loop {
        match pc {
            0x82ABE980 => {
    //   block [0x82ABE980..0x82ABEA3C)
	// 82ABE980: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABE984: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABE988: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ABE98C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABE990: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABE994: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ABE998: 897E0095  lbz r11, 0x95(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(149 as u32) ) } as u64;
	// 82ABE99C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82ABE9A0: 419A0084  beq cr6, 0x82abea24
	if ctx.cr[6].eq {
	pc = 0x82ABEA24; continue 'dispatch;
	}
	// 82ABE9A4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ABE9A8: C1BE007C  lfs f13, 0x7c(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(124 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ABE9AC: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ABE9B0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82ABE9B4: 41980024  blt cr6, 0x82abe9d8
	if ctx.cr[6].lt {
	pc = 0x82ABE9D8; continue 'dispatch;
	}
	// 82ABE9B8: 4839ADC1  bl 0x82e59778
	ctx.lr = 0x82ABE9BC;
	sub_82E59778(ctx, base);
	// 82ABE9BC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ABE9C0: C1BE007C  lfs f13, 0x7c(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(124 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ABE9C4: C00B8398  lfs f0, -0x7c68(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-31848 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ABE9C8: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ABE9CC: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82ABE9D0: D01E007C  stfs f0, 0x7c(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82ABE9D4: 48000050  b 0x82abea24
	pc = 0x82ABEA24; continue 'dispatch;
	// 82ABE9D8: 48695C29  bl 0x83154600
	ctx.lr = 0x82ABE9DC;
	sub_83154600(ctx, base);
	// 82ABE9DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABE9E0: 4BFF21B1  bl 0x82ab0b90
	ctx.lr = 0x82ABE9E4;
	sub_82AB0B90(ctx, base);
	// 82ABE9E4: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 82ABE9E8: 419A0028  beq cr6, 0x82abea10
	if ctx.cr[6].eq {
	pc = 0x82ABEA10; continue 'dispatch;
	}
	// 82ABE9EC: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 82ABE9F0: 419A0018  beq cr6, 0x82abea08
	if ctx.cr[6].eq {
	pc = 0x82ABEA08; continue 'dispatch;
	}
	// 82ABE9F4: 2F030003  cmpwi cr6, r3, 3
	ctx.cr[6].compare_i32(ctx.r[3].s32, 3, &mut ctx.xer);
	// 82ABE9F8: 409A0024  bne cr6, 0x82abea1c
	if !ctx.cr[6].eq {
	pc = 0x82ABEA1C; continue 'dispatch;
	}
	// 82ABE9FC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82ABEA00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABEA04: 4BFF46ED  bl 0x82ab30f0
	ctx.lr = 0x82ABEA08;
	sub_82AB30F0(ctx, base);
	// 82ABEA08: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82ABEA0C: 48000008  b 0x82abea14
	pc = 0x82ABEA14; continue 'dispatch;
	// 82ABEA10: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82ABEA14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABEA18: 4BFF46D9  bl 0x82ab30f0
	ctx.lr = 0x82ABEA1C;
	sub_82AB30F0(ctx, base);
	// 82ABEA1C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82ABEA20: 997E0095  stb r11, 0x95(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(149 as u32), ctx.r[11].u8 ) };
	// 82ABEA24: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ABEA28: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABEA2C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABEA30: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ABEA34: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ABEA38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABEA40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABEA40 size=64
    let mut pc: u32 = 0x82ABEA40;
    'dispatch: loop {
        match pc {
            0x82ABEA40 => {
    //   block [0x82ABEA40..0x82ABEA80)
	// 82ABEA40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABEA44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABEA48: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABEA4C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABEA50: 48695BB1  bl 0x83154600
	ctx.lr = 0x82ABEA54;
	sub_83154600(ctx, base);
	// 82ABEA54: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82ABEA58: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABEA5C: 4BFF4A75  bl 0x82ab34d0
	ctx.lr = 0x82ABEA60;
	sub_82AB34D0(ctx, base);
	// 82ABEA60: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82ABEA64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABEA68: 4BFF4A69  bl 0x82ab34d0
	ctx.lr = 0x82ABEA6C;
	sub_82AB34D0(ctx, base);
	// 82ABEA6C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82ABEA70: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABEA74: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABEA78: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ABEA7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABEA80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ABEA80 size=140
    let mut pc: u32 = 0x82ABEA80;
    'dispatch: loop {
        match pc {
            0x82ABEA80 => {
    //   block [0x82ABEA80..0x82ABEB0C)
	// 82ABEA80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABEA84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABEA88: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABEA8C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABEA90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABEA94: 48000305  bl 0x82abed98
	ctx.lr = 0x82ABEA98;
	sub_82ABED98(ctx, base);
	// 82ABEA98: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82ABEA9C: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 82ABEAA0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ABEAA4: 39298DE4  addi r9, r9, -0x721c
	ctx.r[9].s64 = ctx.r[9].s64 + -29212;
	// 82ABEAA8: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82ABEAAC: 3D008202  lis r8, -0x7dfe
	ctx.r[8].s64 = -2113798144;
	// 82ABEAB0: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ABEAB4: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82ABEAB8: D01F009C  stfs f0, 0x9c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82ABEABC: 997F0094  stb r11, 0x94(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[11].u8 ) };
	// 82ABEAC0: 997F0095  stb r11, 0x95(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(149 as u32), ctx.r[11].u8 ) };
	// 82ABEAC4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ABEAC8: 997F0096  stb r11, 0x96(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(150 as u32), ctx.r[11].u8 ) };
	// 82ABEACC: 3888CB24  addi r4, r8, -0x34dc
	ctx.r[4].s64 = ctx.r[8].s64 + -13532;
	// 82ABEAD0: 997F0097  stb r11, 0x97(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(151 as u32), ctx.r[11].u8 ) };
	// 82ABEAD4: 997F0098  stb r11, 0x98(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[11].u8 ) };
	// 82ABEAD8: 997F0099  stb r11, 0x99(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(153 as u32), ctx.r[11].u8 ) };
	// 82ABEADC: 48334F2D  bl 0x82df3a08
	ctx.lr = 0x82ABEAE0;
	sub_82DF3A08(ctx, base);
	// 82ABEAE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABEAE4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82ABEAE8: 4839AC01  bl 0x82e596e8
	ctx.lr = 0x82ABEAEC;
	sub_82E596E8(ctx, base);
	// 82ABEAEC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ABEAF0: 48334939  bl 0x82df3428
	ctx.lr = 0x82ABEAF4;
	sub_82DF3428(ctx, base);
	// 82ABEAF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABEAF8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ABEAFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABEB00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABEB04: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ABEB08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABEB10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABEB10 size=88
    let mut pc: u32 = 0x82ABEB10;
    'dispatch: loop {
        match pc {
            0x82ABEB10 => {
    //   block [0x82ABEB10..0x82ABEB68)
	// 82ABEB10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABEB14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABEB18: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ABEB1C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABEB20: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABEB24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABEB28: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ABEB2C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ABEB30: 396B8DE4  addi r11, r11, -0x721c
	ctx.r[11].s64 = ctx.r[11].s64 + -29212;
	// 82ABEB34: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ABEB38: 4839DA51  bl 0x82e5c588
	ctx.lr = 0x82ABEB3C;
	sub_82E5C588(ctx, base);
	// 82ABEB3C: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ABEB40: 4182000C  beq 0x82abeb4c
	if ctx.cr[0].eq {
	pc = 0x82ABEB4C; continue 'dispatch;
	}
	// 82ABEB44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABEB48: 48333891  bl 0x82df23d8
	ctx.lr = 0x82ABEB4C;
	sub_82DF23D8(ctx, base);
	// 82ABEB4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABEB50: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ABEB54: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABEB58: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABEB5C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ABEB60: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ABEB64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABEB68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ABEB68 size=112
    let mut pc: u32 = 0x82ABEB68;
    'dispatch: loop {
        match pc {
            0x82ABEB68 => {
    //   block [0x82ABEB68..0x82ABEBD8)
	// 82ABEB68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABEB6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABEB70: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ABEB74: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABEB78: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABEB7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABEB80: 48695A81  bl 0x83154600
	ctx.lr = 0x82ABEB84;
	sub_83154600(ctx, base);
	// 82ABEB84: 4BF54335  bl 0x82a12eb8
	ctx.lr = 0x82ABEB88;
	sub_82A12EB8(ctx, base);
	// 82ABEB88: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ABEB8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABEB90: 4BFFFD71  bl 0x82abe900
	ctx.lr = 0x82ABEB94;
	sub_82ABE900(ctx, base);
	// 82ABEB94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABEB98: 4BFFFDE9  bl 0x82abe980
	ctx.lr = 0x82ABEB9C;
	sub_82ABE980(ctx, base);
	// 82ABEB9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABEBA0: 4BA98F21  bl 0x82557ac0
	ctx.lr = 0x82ABEBA4;
	sub_82557AC0(ctx, base);
	// 82ABEBA4: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABEBA8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ABEBAC: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABEBB0: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82ABEBB4: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82ABEBB8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ABEBBC: 4E800421  bctrl
	ctx.lr = 0x82ABEBC0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ABEBC0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ABEBC4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABEBC8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABEBCC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ABEBD0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ABEBD4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABEBD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ABEBD8 size=224
    let mut pc: u32 = 0x82ABEBD8;
    'dispatch: loop {
        match pc {
            0x82ABEBD8 => {
    //   block [0x82ABEBD8..0x82ABECB8)
	// 82ABEBD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABEBDC: 486E958D  bl 0x831a8168
	ctx.lr = 0x82ABEBE0;
	sub_831A8130(ctx, base);
	// 82ABEBE0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABEBE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABEBE8: 48695A19  bl 0x83154600
	ctx.lr = 0x82ABEBEC;
	sub_83154600(ctx, base);
	// 82ABEBEC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ABEBF0: 4BD2D5E9  bl 0x827ec1d8
	ctx.lr = 0x82ABEBF4;
	sub_827EC1D8(ctx, base);
	// 82ABEBF4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82ABEBF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABEBFC: 4BF542BD  bl 0x82a12eb8
	ctx.lr = 0x82ABEC00;
	sub_82A12EB8(ctx, base);
	// 82ABEC00: 817F0070  lwz r11, 0x70(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82ABEC04: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82ABEC08: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82ABEC0C: 41980064  blt cr6, 0x82abec70
	if ctx.cr[6].lt {
	pc = 0x82ABEC70; continue 'dispatch;
	}
	// 82ABEC10: 419A001C  beq cr6, 0x82abec2c
	if ctx.cr[6].eq {
	pc = 0x82ABEC2C; continue 'dispatch;
	}
	// 82ABEC14: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82ABEC18: 40980098  bge cr6, 0x82abecb0
	if !ctx.cr[6].lt {
	pc = 0x82ABECB0; continue 'dispatch;
	}
	// 82ABEC1C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ABEC20: 4BFA50C1  bl 0x82a63ce0
	ctx.lr = 0x82ABEC24;
	sub_82A63CE0(ctx, base);
	// 82ABEC24: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82ABEC28: 48000084  b 0x82abecac
	pc = 0x82ABECAC; continue 'dispatch;
	// 82ABEC2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABEC30: 4BFFFB39  bl 0x82abe768
	ctx.lr = 0x82ABEC34;
	sub_82ABE768(ctx, base);
	// 82ABEC34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABEC38: 4BFFFBD9  bl 0x82abe810
	ctx.lr = 0x82ABEC3C;
	sub_82ABE810(ctx, base);
	// 82ABEC3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABEC40: 4BFFFF29  bl 0x82abeb68
	ctx.lr = 0x82ABEC44;
	sub_82ABEB68(ctx, base);
	// 82ABEC44: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ABEC48: 41820068  beq 0x82abecb0
	if ctx.cr[0].eq {
	pc = 0x82ABECB0; continue 'dispatch;
	}
	// 82ABEC4C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ABEC50: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82ABEC54: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82ABEC58: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82ABEC5C: C04B08A4  lfs f2, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82ABEC60: C02A9450  lfs f1, -0x6bb0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82ABEC64: 4BFFB3AD  bl 0x82aba010
	ctx.lr = 0x82ABEC68;
	sub_82ABA010(ctx, base);
	// 82ABEC68: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82ABEC6C: 48000040  b 0x82abecac
	pc = 0x82ABECAC; continue 'dispatch;
	// 82ABEC70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABEC74: 4BFF1F1D  bl 0x82ab0b90
	ctx.lr = 0x82ABEC78;
	sub_82AB0B90(ctx, base);
	// 82ABEC78: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ABEC7C: 546A2834  slwi r10, r3, 5
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82ABEC80: 396B8D60  addi r11, r11, -0x72a0
	ctx.r[11].s64 = ctx.r[11].s64 + -29344;
	// 82ABEC84: 387F0074  addi r3, r31, 0x74
	ctx.r[3].s64 = ctx.r[31].s64 + 116;
	// 82ABEC88: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82ABEC8C: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 82ABEC90: 388BFFE0  addi r4, r11, -0x20
	ctx.r[4].s64 = ctx.r[11].s64 + -32;
	// 82ABEC94: 486E987D  bl 0x831a8510
	ctx.lr = 0x82ABEC98;
	sub_831A8510(ctx, base);
	// 82ABEC98: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ABEC9C: 4BFA5035  bl 0x82a63cd0
	ctx.lr = 0x82ABECA0;
	sub_82A63CD0(ctx, base);
	// 82ABECA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABECA4: 4BFFF96D  bl 0x82abe610
	ctx.lr = 0x82ABECA8;
	sub_82ABE610(ctx, base);
	// 82ABECA8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82ABECAC: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82ABECB0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82ABECB4: 486E9504  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABECB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ABECB8 size=20
    let mut pc: u32 = 0x82ABECB8;
    'dispatch: loop {
        match pc {
            0x82ABECB8 => {
    //   block [0x82ABECB8..0x82ABECCC)
	// 82ABECB8: 89630061  lbz r11, 0x61(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(97 as u32) ) } as u64;
	// 82ABECBC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ABECC0: 4082000C  bne 0x82abeccc
	if !ctx.cr[0].eq {
		sub_82ABECCC(ctx, base);
		return;
	}
	// 82ABECC4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82ABECC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABECCC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82ABECCC size=16
    let mut pc: u32 = 0x82ABECCC;
    'dispatch: loop {
        match pc {
            0x82ABECCC => {
    //   block [0x82ABECCC..0x82ABECDC)
	// 82ABECCC: C0030068  lfs f0, 0x68(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ABECD0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82ABECD4: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82ABECD8: 4C980020  bgelr cr6
	if !ctx.cr[6].lt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABECDC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ABECDC size=8
    let mut pc: u32 = 0x82ABECDC;
    'dispatch: loop {
        match pc {
            0x82ABECDC => {
    //   block [0x82ABECDC..0x82ABECE4)
	// 82ABECDC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ABECE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABECE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ABECE8 size=8
    let mut pc: u32 = 0x82ABECE8;
    'dispatch: loop {
        match pc {
            0x82ABECE8 => {
    //   block [0x82ABECE8..0x82ABECF0)
	// 82ABECE8: 8063006C  lwz r3, 0x6c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(108 as u32) ) } as u64;
	// 82ABECEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABECF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ABECF0 size=8
    let mut pc: u32 = 0x82ABECF0;
    'dispatch: loop {
        match pc {
            0x82ABECF0 => {
    //   block [0x82ABECF0..0x82ABECF8)
	// 82ABECF0: 9083006C  stw r4, 0x6c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(108 as u32), ctx.r[4].u32 ) };
	// 82ABECF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABECF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ABECF8 size=160
    let mut pc: u32 = 0x82ABECF8;
    'dispatch: loop {
        match pc {
            0x82ABECF8 => {
    //   block [0x82ABECF8..0x82ABED98)
	// 82ABECF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABECFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABED00: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ABED04: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABED08: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82ABED0C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABED10: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABED14: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ABED18: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82ABED1C: 895F0060  lbz r10, 0x60(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82ABED20: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82ABED24: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82ABED28: 409A0024  bne cr6, 0x82abed4c
	if !ctx.cr[6].eq {
	pc = 0x82ABED4C; continue 'dispatch;
	}
	// 82ABED2C: 4839AA4D  bl 0x82e59778
	ctx.lr = 0x82ABED30;
	sub_82E59778(ctx, base);
	// 82ABED30: C01F0064  lfs f0, 0x64(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ABED34: EC000828  fsubs f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 82ABED38: D01F0064  stfs f0, 0x64(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82ABED3C: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82ABED40: 4199000C  bgt cr6, 0x82abed4c
	if ctx.cr[6].gt {
	pc = 0x82ABED4C; continue 'dispatch;
	}
	// 82ABED44: D3FF0064  stfs f31, 0x64(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82ABED48: 9BDF0060  stb r30, 0x60(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[30].u8 ) };
	// 82ABED4C: 897F0061  lbz r11, 0x61(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(97 as u32) ) } as u64;
	// 82ABED50: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82ABED54: 409A0028  bne cr6, 0x82abed7c
	if !ctx.cr[6].eq {
	pc = 0x82ABED7C; continue 'dispatch;
	}
	// 82ABED58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABED5C: 4839AA1D  bl 0x82e59778
	ctx.lr = 0x82ABED60;
	sub_82E59778(ctx, base);
	// 82ABED60: C01F0068  lfs f0, 0x68(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ABED64: EC000828  fsubs f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 82ABED68: D01F0068  stfs f0, 0x68(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82ABED6C: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82ABED70: 4199000C  bgt cr6, 0x82abed7c
	if ctx.cr[6].gt {
	pc = 0x82ABED7C; continue 'dispatch;
	}
	// 82ABED74: D3FF0068  stfs f31, 0x68(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82ABED78: 9BDF0061  stb r30, 0x61(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(97 as u32), ctx.r[30].u8 ) };
	// 82ABED7C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ABED80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABED84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABED88: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82ABED8C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ABED90: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ABED94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABED98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ABED98 size=100
    let mut pc: u32 = 0x82ABED98;
    'dispatch: loop {
        match pc {
            0x82ABED98 => {
    //   block [0x82ABED98..0x82ABEDFC)
	// 82ABED98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABED9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABEDA0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABEDA4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABEDA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABEDAC: 4839DB7D  bl 0x82e5c928
	ctx.lr = 0x82ABEDB0;
	sub_82E5C928(ctx, base);
	// 82ABEDB0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82ABEDB4: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 82ABEDB8: 3D000FFF  lis r8, 0xfff
	ctx.r[8].s64 = 268369920;
	// 82ABEDBC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ABEDC0: 39298E0C  addi r9, r9, -0x71f4
	ctx.r[9].s64 = ctx.r[9].s64 + -29172;
	// 82ABEDC4: 6108FFFF  ori r8, r8, 0xffff
	ctx.r[8].u64 = ctx.r[8].u64 | 65535;
	// 82ABEDC8: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ABEDCC: D01F0064  stfs f0, 0x64(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82ABEDD0: 997F0060  stb r11, 0x60(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u8 ) };
	// 82ABEDD4: D01F0068  stfs f0, 0x68(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82ABEDD8: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82ABEDDC: 997F0061  stb r11, 0x61(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(97 as u32), ctx.r[11].u8 ) };
	// 82ABEDE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABEDE4: 911F006C  stw r8, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[8].u32 ) };
	// 82ABEDE8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82ABEDEC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABEDF0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABEDF4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ABEDF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABEE00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ABEE00 size=524
    let mut pc: u32 = 0x82ABEE00;
    'dispatch: loop {
        match pc {
            0x82ABEE00 => {
    //   block [0x82ABEE00..0x82ABF00C)
	// 82ABEE00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABEE04: 486E9369  bl 0x831a816c
	ctx.lr = 0x82ABEE08;
	sub_831A8130(ctx, base);
	// 82ABEE08: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 82ABEE0C: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82ABEE10: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABEE14: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ABEE18: 908100DC  stw r4, 0xdc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), ctx.r[4].u32 ) };
	// 82ABEE1C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82ABEE20: 897E0060  lbz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82ABEE24: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ABEE28: 408201D0  bne 0x82abeff8
	if !ctx.cr[0].eq {
	pc = 0x82ABEFF8; continue 'dispatch;
	}
	// 82ABEE2C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ABEE30: 895E0061  lbz r10, 0x61(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(97 as u32) ) } as u64;
	// 82ABEE34: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ABEE38: C3CB08A4  lfs f30, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82ABEE3C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82ABEE40: 41820014  beq 0x82abee54
	if ctx.cr[0].eq {
	pc = 0x82ABEE54; continue 'dispatch;
	}
	// 82ABEE44: C01E0068  lfs f0, 0x68(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ABEE48: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 82ABEE4C: 40990008  ble cr6, 0x82abee54
	if !ctx.cr[6].gt {
	pc = 0x82ABEE54; continue 'dispatch;
	}
	// 82ABEE50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ABEE54: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ABEE58: 418201A0  beq 0x82abeff8
	if ctx.cr[0].eq {
	pc = 0x82ABEFF8; continue 'dispatch;
	}
	// 82ABEE5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABEE60: 486957A1  bl 0x83154600
	ctx.lr = 0x82ABEE64;
	sub_83154600(ctx, base);
	// 82ABEE64: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ABEE68: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82ABEE6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABEE70: 396B9450  addi r11, r11, -0x6bb0
	ctx.r[11].s64 = ctx.r[11].s64 + -27568;
	// 82ABEE74: 38A100DC  addi r5, r1, 0xdc
	ctx.r[5].s64 = ctx.r[1].s64 + 220;
	// 82ABEE78: C3EB0000  lfs f31, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82ABEE7C: 408200A4  bne 0x82abef20
	if !ctx.cr[0].eq {
	pc = 0x82ABEF20; continue 'dispatch;
	}
	// 82ABEE80: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82ABEE84: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82ABEE88: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82ABEE8C: 4BA75F4D  bl 0x82534dd8
	ctx.lr = 0x82ABEE90;
	sub_82534DD8(ctx, base);
	// 82ABEE90: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABEE94: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82ABEE98: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ABEE9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ABEEA0: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82ABEEA4: 419A0024  beq cr6, 0x82abeec8
	if ctx.cr[6].eq {
	pc = 0x82ABEEC8; continue 'dispatch;
	}
	// 82ABEEA8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82ABEEAC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82ABEEB0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ABEEB4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82ABEEB8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ABEEBC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82ABEEC0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ABEEC4: 4082FFE8  bne 0x82abeeac
	if !ctx.cr[0].eq {
	pc = 0x82ABEEAC; continue 'dispatch;
	}
	// 82ABEEC8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ABEECC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82ABEED0: 4BA50461  bl 0x8250f330
	ctx.lr = 0x82ABEED4;
	sub_8250F330(ctx, base);
	// 82ABEED4: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABEED8: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82ABEEDC: 4BA2A995  bl 0x824e9870
	ctx.lr = 0x82ABEEE0;
	sub_824E9870(ctx, base);
	// 82ABEEE0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ABEEE4: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82ABEEE8: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82ABEEEC: 388B8E30  addi r4, r11, -0x71d0
	ctx.r[4].s64 = ctx.r[11].s64 + -29136;
	// 82ABEEF0: 38A0003C  li r5, 0x3c
	ctx.r[5].s64 = 60;
	// 82ABEEF4: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82ABEEF8: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82ABEEFC: 48399B45  bl 0x82e58a40
	ctx.lr = 0x82ABEF00;
	sub_82E58A40(ctx, base);
	// 82ABEF00: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82ABEF04: 48332D8D  bl 0x82df1c90
	ctx.lr = 0x82ABEF08;
	sub_82DF1C90(ctx, base);
	// 82ABEF08: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82ABEF0C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ABEF10: 419A0008  beq cr6, 0x82abef18
	if ctx.cr[6].eq {
	pc = 0x82ABEF18; continue 'dispatch;
	}
	// 82ABEF14: 4B80197D  bl 0x822c0890
	ctx.lr = 0x82ABEF18;
	sub_822C0890(ctx, base);
	// 82ABEF18: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82ABEF1C: 480000BC  b 0x82abefd8
	pc = 0x82ABEFD8; continue 'dispatch;
	// 82ABEF20: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82ABEF24: D3E10058  stfs f31, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82ABEF28: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	// 82ABEF2C: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82ABEF30: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82ABEF34: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 82ABEF38: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82ABEF3C: C00A9534  lfs f0, -0x6acc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ABEF40: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82ABEF44: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82ABEF48: 4BA756F9  bl 0x82534640
	ctx.lr = 0x82ABEF4C;
	sub_82534640(ctx, base);
	// 82ABEF4C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABEF50: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82ABEF54: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ABEF58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ABEF5C: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82ABEF60: 419A0024  beq cr6, 0x82abef84
	if ctx.cr[6].eq {
	pc = 0x82ABEF84; continue 'dispatch;
	}
	// 82ABEF64: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82ABEF68: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82ABEF6C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ABEF70: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82ABEF74: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ABEF78: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82ABEF7C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ABEF80: 4082FFE8  bne 0x82abef68
	if !ctx.cr[0].eq {
	pc = 0x82ABEF68; continue 'dispatch;
	}
	// 82ABEF84: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ABEF88: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82ABEF8C: 4BA503A5  bl 0x8250f330
	ctx.lr = 0x82ABEF90;
	sub_8250F330(ctx, base);
	// 82ABEF90: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABEF94: 3BA10068  addi r29, r1, 0x68
	ctx.r[29].s64 = ctx.r[1].s64 + 104;
	// 82ABEF98: 4BA2A8D9  bl 0x824e9870
	ctx.lr = 0x82ABEF9C;
	sub_824E9870(ctx, base);
	// 82ABEF9C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ABEFA0: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82ABEFA4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82ABEFA8: 388B8E30  addi r4, r11, -0x71d0
	ctx.r[4].s64 = ctx.r[11].s64 + -29136;
	// 82ABEFAC: 38A00042  li r5, 0x42
	ctx.r[5].s64 = 66;
	// 82ABEFB0: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82ABEFB4: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82ABEFB8: 48399A89  bl 0x82e58a40
	ctx.lr = 0x82ABEFBC;
	sub_82E58A40(ctx, base);
	// 82ABEFBC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82ABEFC0: 48332CD1  bl 0x82df1c90
	ctx.lr = 0x82ABEFC4;
	sub_82DF1C90(ctx, base);
	// 82ABEFC4: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82ABEFC8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ABEFCC: 419A0008  beq cr6, 0x82abefd4
	if ctx.cr[6].eq {
	pc = 0x82ABEFD4; continue 'dispatch;
	}
	// 82ABEFD0: 4B8018C1  bl 0x822c0890
	ctx.lr = 0x82ABEFD4;
	sub_822C0890(ctx, base);
	// 82ABEFD4: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82ABEFD8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ABEFDC: 419A0008  beq cr6, 0x82abefe4
	if ctx.cr[6].eq {
	pc = 0x82ABEFE4; continue 'dispatch;
	}
	// 82ABEFE0: 4B8018B1  bl 0x822c0890
	ctx.lr = 0x82ABEFE4;
	sub_822C0890(ctx, base);
	// 82ABEFE4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82ABEFE8: D3FE0064  stfs f31, 0x64(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82ABEFEC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82ABEFF0: 997E0060  stb r11, 0x60(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(96 as u32), ctx.r[11].u8 ) };
	// 82ABEFF4: 48000008  b 0x82abeffc
	pc = 0x82ABEFFC; continue 'dispatch;
	// 82ABEFF8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ABEFFC: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82ABF000: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82ABF004: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82ABF008: 486E91B4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABF010(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ABF010 size=320
    let mut pc: u32 = 0x82ABF010;
    'dispatch: loop {
        match pc {
            0x82ABF010 => {
    //   block [0x82ABF010..0x82ABF150)
	// 82ABF010: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABF014: 486E9159  bl 0x831a816c
	ctx.lr = 0x82ABF018;
	sub_831A8130(ctx, base);
	// 82ABF018: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 82ABF01C: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82ABF020: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABF024: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ABF028: 908100BC  stw r4, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[4].u32 ) };
	// 82ABF02C: 897E0060  lbz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82ABF030: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ABF034: 40820108  bne 0x82abf13c
	if !ctx.cr[0].eq {
	pc = 0x82ABF13C; continue 'dispatch;
	}
	// 82ABF038: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ABF03C: 895E0061  lbz r10, 0x61(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(97 as u32) ) } as u64;
	// 82ABF040: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ABF044: C3CB08A4  lfs f30, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82ABF048: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82ABF04C: 41820014  beq 0x82abf060
	if ctx.cr[0].eq {
	pc = 0x82ABF060; continue 'dispatch;
	}
	// 82ABF050: C01E0068  lfs f0, 0x68(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ABF054: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 82ABF058: 40990008  ble cr6, 0x82abf060
	if !ctx.cr[6].gt {
	pc = 0x82ABF060; continue 'dispatch;
	}
	// 82ABF05C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ABF060: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ABF064: 418200D8  beq 0x82abf13c
	if ctx.cr[0].eq {
	pc = 0x82ABF13C; continue 'dispatch;
	}
	// 82ABF068: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABF06C: 48695595  bl 0x83154600
	ctx.lr = 0x82ABF070;
	sub_83154600(ctx, base);
	// 82ABF070: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82ABF074: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABF078: 38A100BC  addi r5, r1, 0xbc
	ctx.r[5].s64 = ctx.r[1].s64 + 188;
	// 82ABF07C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82ABF080: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82ABF084: C3EB9450  lfs f31, -0x6bb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82ABF088: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82ABF08C: 4BA75E55  bl 0x82534ee0
	ctx.lr = 0x82ABF090;
	sub_82534EE0(ctx, base);
	// 82ABF090: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABF094: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82ABF098: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ABF09C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ABF0A0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82ABF0A4: 419A0024  beq cr6, 0x82abf0c8
	if ctx.cr[6].eq {
	pc = 0x82ABF0C8; continue 'dispatch;
	}
	// 82ABF0A8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82ABF0AC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82ABF0B0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ABF0B4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82ABF0B8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ABF0BC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82ABF0C0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ABF0C4: 4082FFE8  bne 0x82abf0ac
	if !ctx.cr[0].eq {
	pc = 0x82ABF0AC; continue 'dispatch;
	}
	// 82ABF0C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ABF0CC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82ABF0D0: 4BA50261  bl 0x8250f330
	ctx.lr = 0x82ABF0D4;
	sub_8250F330(ctx, base);
	// 82ABF0D4: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABF0D8: 3BA10058  addi r29, r1, 0x58
	ctx.r[29].s64 = ctx.r[1].s64 + 88;
	// 82ABF0DC: 4BA2A795  bl 0x824e9870
	ctx.lr = 0x82ABF0E0;
	sub_824E9870(ctx, base);
	// 82ABF0E0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ABF0E4: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82ABF0E8: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82ABF0EC: 388B8E30  addi r4, r11, -0x71d0
	ctx.r[4].s64 = ctx.r[11].s64 + -29136;
	// 82ABF0F0: 38A0005A  li r5, 0x5a
	ctx.r[5].s64 = 90;
	// 82ABF0F4: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82ABF0F8: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82ABF0FC: 48399945  bl 0x82e58a40
	ctx.lr = 0x82ABF100;
	sub_82E58A40(ctx, base);
	// 82ABF100: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82ABF104: 48332B8D  bl 0x82df1c90
	ctx.lr = 0x82ABF108;
	sub_82DF1C90(ctx, base);
	// 82ABF108: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82ABF10C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ABF110: 419A0008  beq cr6, 0x82abf118
	if ctx.cr[6].eq {
	pc = 0x82ABF118; continue 'dispatch;
	}
	// 82ABF114: 4B80177D  bl 0x822c0890
	ctx.lr = 0x82ABF118;
	sub_822C0890(ctx, base);
	// 82ABF118: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82ABF11C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ABF120: 419A0008  beq cr6, 0x82abf128
	if ctx.cr[6].eq {
	pc = 0x82ABF128; continue 'dispatch;
	}
	// 82ABF124: 4B80176D  bl 0x822c0890
	ctx.lr = 0x82ABF128;
	sub_822C0890(ctx, base);
	// 82ABF128: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82ABF12C: D3FE0068  stfs f31, 0x68(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82ABF130: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82ABF134: 997E0061  stb r11, 0x61(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(97 as u32), ctx.r[11].u8 ) };
	// 82ABF138: 48000008  b 0x82abf140
	pc = 0x82ABF140; continue 'dispatch;
	// 82ABF13C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ABF140: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82ABF144: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82ABF148: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82ABF14C: 486E9070  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABF150(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ABF150 size=116
    let mut pc: u32 = 0x82ABF150;
    'dispatch: loop {
        match pc {
            0x82ABF150 => {
    //   block [0x82ABF150..0x82ABF1C4)
	// 82ABF150: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABF154: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABF158: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABF15C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABF160: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABF164: 4BFFFC35  bl 0x82abed98
	ctx.lr = 0x82ABF168;
	sub_82ABED98(ctx, base);
	// 82ABF168: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ABF16C: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82ABF170: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82ABF174: 394A8E90  addi r10, r10, -0x7170
	ctx.r[10].s64 = ctx.r[10].s64 + -29040;
	// 82ABF178: 913F0070  stw r9, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[9].u32 ) };
	// 82ABF17C: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 82ABF180: C00B8E88  lfs f0, -0x7178(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-29048 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ABF184: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82ABF188: D01F0074  stfs f0, 0x74(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82ABF18C: 3889893C  addi r4, r9, -0x76c4
	ctx.r[4].s64 = ctx.r[9].s64 + -30404;
	// 82ABF190: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ABF194: 48334875  bl 0x82df3a08
	ctx.lr = 0x82ABF198;
	sub_82DF3A08(ctx, base);
	// 82ABF198: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABF19C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82ABF1A0: 4839A549  bl 0x82e596e8
	ctx.lr = 0x82ABF1A4;
	sub_82E596E8(ctx, base);
	// 82ABF1A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ABF1A8: 48334281  bl 0x82df3428
	ctx.lr = 0x82ABF1AC;
	sub_82DF3428(ctx, base);
	// 82ABF1AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABF1B0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ABF1B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABF1B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABF1BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ABF1C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABF1C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ABF1C8 size=756
    let mut pc: u32 = 0x82ABF1C8;
    'dispatch: loop {
        match pc {
            0x82ABF1C8 => {
    //   block [0x82ABF1C8..0x82ABF4BC)
	// 82ABF1C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABF1CC: 486E8F99  bl 0x831a8164
	ctx.lr = 0x82ABF1D0;
	sub_831A8130(ctx, base);
	// 82ABF1D0: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82ABF1D4: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABF1D8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82ABF1DC: 48695425  bl 0x83154600
	ctx.lr = 0x82ABF1E0;
	sub_83154600(ctx, base);
	// 82ABF1E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABF1E4: 4BD2CFF5  bl 0x827ec1d8
	ctx.lr = 0x82ABF1E8;
	sub_827EC1D8(ctx, base);
	// 82ABF1E8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82ABF1EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABF1F0: 4BF53CC9  bl 0x82a12eb8
	ctx.lr = 0x82ABF1F4;
	sub_82A12EB8(ctx, base);
	// 82ABF1F4: 817D0070  lwz r11, 0x70(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(112 as u32) ) } as u64;
	// 82ABF1F8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ABF1FC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82ABF200: 419801AC  blt cr6, 0x82abf3ac
	if ctx.cr[6].lt {
	pc = 0x82ABF3AC; continue 'dispatch;
	}
	// 82ABF204: 419A0158  beq cr6, 0x82abf35c
	if ctx.cr[6].eq {
	pc = 0x82ABF35C; continue 'dispatch;
	}
	// 82ABF208: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82ABF20C: 41980110  blt cr6, 0x82abf31c
	if ctx.cr[6].lt {
	pc = 0x82ABF31C; continue 'dispatch;
	}
	// 82ABF210: 409A02A0  bne cr6, 0x82abf4b0
	if !ctx.cr[6].eq {
	pc = 0x82ABF4B0; continue 'dispatch;
	}
	// 82ABF214: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABF218: 4BFF5069  bl 0x82ab4280
	ctx.lr = 0x82ABF21C;
	sub_82AB4280(ctx, base);
	// 82ABF21C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82ABF220: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82ABF224: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 82ABF228: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82ABF22C: 4B9EAD3D  bl 0x824a9f68
	ctx.lr = 0x82ABF230;
	sub_824A9F68(ctx, base);
	// 82ABF230: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABF234: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82ABF238: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ABF23C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ABF240: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82ABF244: 419A0024  beq cr6, 0x82abf268
	if ctx.cr[6].eq {
	pc = 0x82ABF268; continue 'dispatch;
	}
	// 82ABF248: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82ABF24C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82ABF250: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ABF254: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82ABF258: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ABF25C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82ABF260: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ABF264: 4082FFE8  bne 0x82abf24c
	if !ctx.cr[0].eq {
	pc = 0x82ABF24C; continue 'dispatch;
	}
	// 82ABF268: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ABF26C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82ABF270: 4BA50259  bl 0x8250f4c8
	ctx.lr = 0x82ABF274;
	sub_8250F4C8(ctx, base);
	// 82ABF274: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABF278: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ABF27C: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82ABF280: 409A0008  bne cr6, 0x82abf288
	if !ctx.cr[6].eq {
	pc = 0x82ABF288; continue 'dispatch;
	}
	// 82ABF284: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ABF288: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 82ABF28C: 4BA492FD  bl 0x82508588
	ctx.lr = 0x82ABF290;
	sub_82508588(ctx, base);
	// 82ABF290: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ABF294: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82ABF298: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82ABF29C: 388A8EB8  addi r4, r10, -0x7148
	ctx.r[4].s64 = ctx.r[10].s64 + -29000;
	// 82ABF2A0: 38A00069  li r5, 0x69
	ctx.r[5].s64 = 105;
	// 82ABF2A4: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82ABF2A8: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82ABF2AC: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82ABF2B0: 48399791  bl 0x82e58a40
	ctx.lr = 0x82ABF2B4;
	sub_82E58A40(ctx, base);
	// 82ABF2B4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82ABF2B8: 483329D9  bl 0x82df1c90
	ctx.lr = 0x82ABF2BC;
	sub_82DF1C90(ctx, base);
	// 82ABF2BC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82ABF2C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ABF2C4: 419A0008  beq cr6, 0x82abf2cc
	if ctx.cr[6].eq {
	pc = 0x82ABF2CC; continue 'dispatch;
	}
	// 82ABF2C8: 4B8015C9  bl 0x822c0890
	ctx.lr = 0x82ABF2CC;
	sub_822C0890(ctx, base);
	// 82ABF2CC: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82ABF2D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ABF2D4: 419A0008  beq cr6, 0x82abf2dc
	if ctx.cr[6].eq {
	pc = 0x82ABF2DC; continue 'dispatch;
	}
	// 82ABF2D8: 4B8015B9  bl 0x822c0890
	ctx.lr = 0x82ABF2DC;
	sub_822C0890(ctx, base);
	// 82ABF2DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABF2E0: 4BFF72F1  bl 0x82ab65d0
	ctx.lr = 0x82ABF2E4;
	sub_82AB65D0(ctx, base);
	// 82ABF2E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ABF2E8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82ABF2EC: 4BFF36C5  bl 0x82ab29b0
	ctx.lr = 0x82ABF2F0;
	sub_82AB29B0(ctx, base);
	// 82ABF2F0: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 82ABF2F4: 80610068  lwz r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82ABF2F8: 4BFFD851  bl 0x82abcb48
	ctx.lr = 0x82ABF2FC;
	sub_82ABCB48(ctx, base);
	// 82ABF2FC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82ABF300: 4BFA49E1  bl 0x82a63ce0
	ctx.lr = 0x82ABF304;
	sub_82A63CE0(ctx, base);
	// 82ABF304: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82ABF308: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ABF30C: 419A0008  beq cr6, 0x82abf314
	if ctx.cr[6].eq {
	pc = 0x82ABF314; continue 'dispatch;
	}
	// 82ABF310: 4B801581  bl 0x822c0890
	ctx.lr = 0x82ABF314;
	sub_822C0890(ctx, base);
	// 82ABF314: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82ABF318: 48000194  b 0x82abf4ac
	pc = 0x82ABF4AC; continue 'dispatch;
	// 82ABF31C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ABF320: C1BD0074  lfs f13, 0x74(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(116 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ABF324: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ABF328: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82ABF32C: 4099001C  ble cr6, 0x82abf348
	if !ctx.cr[6].gt {
	pc = 0x82ABF348; continue 'dispatch;
	}
	// 82ABF330: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ABF334: 4839A445  bl 0x82e59778
	ctx.lr = 0x82ABF338;
	sub_82E59778(ctx, base);
	// 82ABF338: C01D0074  lfs f0, 0x74(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ABF33C: EC000828  fsubs f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 82ABF340: D01D0074  stfs f0, 0x74(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82ABF344: 4800016C  b 0x82abf4b0
	pc = 0x82ABF4B0; continue 'dispatch;
	// 82ABF348: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82ABF34C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABF350: 4BFF7821  bl 0x82ab6b70
	ctx.lr = 0x82ABF354;
	sub_82AB6B70(ctx, base);
	// 82ABF354: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82ABF358: 48000154  b 0x82abf4ac
	pc = 0x82ABF4AC; continue 'dispatch;
	// 82ABF35C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABF360: 4BA98761  bl 0x82557ac0
	ctx.lr = 0x82ABF364;
	sub_82557AC0(ctx, base);
	// 82ABF364: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABF368: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ABF36C: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABF370: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82ABF374: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82ABF378: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82ABF37C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ABF380: 4E800421  bctrl
	ctx.lr = 0x82ABF384;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ABF384: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ABF388: 41820128  beq 0x82abf4b0
	if ctx.cr[0].eq {
	pc = 0x82ABF4B0; continue 'dispatch;
	}
	// 82ABF38C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82ABF390: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82ABF394: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82ABF398: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABF39C: C02B9450  lfs f1, -0x6bb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82ABF3A0: 4BFFAC71  bl 0x82aba010
	ctx.lr = 0x82ABF3A4;
	sub_82ABA010(ctx, base);
	// 82ABF3A4: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82ABF3A8: 48000104  b 0x82abf4ac
	pc = 0x82ABF4AC; continue 'dispatch;
	// 82ABF3AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABF3B0: 4BFF4DE1  bl 0x82ab4190
	ctx.lr = 0x82ABF3B4;
	sub_82AB4190(ctx, base);
	// 82ABF3B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ABF3B8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82ABF3BC: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 82ABF3C0: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82ABF3C4: 4B9EABA5  bl 0x824a9f68
	ctx.lr = 0x82ABF3C8;
	sub_824A9F68(ctx, base);
	// 82ABF3C8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABF3CC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82ABF3D0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ABF3D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ABF3D8: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82ABF3DC: 419A0024  beq cr6, 0x82abf400
	if ctx.cr[6].eq {
	pc = 0x82ABF400; continue 'dispatch;
	}
	// 82ABF3E0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82ABF3E4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82ABF3E8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ABF3EC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82ABF3F0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ABF3F4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82ABF3F8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ABF3FC: 4082FFE8  bne 0x82abf3e4
	if !ctx.cr[0].eq {
	pc = 0x82ABF3E4; continue 'dispatch;
	}
	// 82ABF400: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ABF404: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82ABF408: 4BA500C1  bl 0x8250f4c8
	ctx.lr = 0x82ABF40C;
	sub_8250F4C8(ctx, base);
	// 82ABF40C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABF410: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ABF414: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82ABF418: 409A0008  bne cr6, 0x82abf420
	if !ctx.cr[6].eq {
	pc = 0x82ABF420; continue 'dispatch;
	}
	// 82ABF41C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ABF420: 3B610060  addi r27, r1, 0x60
	ctx.r[27].s64 = ctx.r[1].s64 + 96;
	// 82ABF424: 4BA49165  bl 0x82508588
	ctx.lr = 0x82ABF428;
	sub_82508588(ctx, base);
	// 82ABF428: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ABF42C: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82ABF430: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82ABF434: 388A8EB8  addi r4, r10, -0x7148
	ctx.r[4].s64 = ctx.r[10].s64 + -29000;
	// 82ABF438: 38A00043  li r5, 0x43
	ctx.r[5].s64 = 67;
	// 82ABF43C: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82ABF440: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82ABF444: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82ABF448: 483995F9  bl 0x82e58a40
	ctx.lr = 0x82ABF44C;
	sub_82E58A40(ctx, base);
	// 82ABF44C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82ABF450: 48332841  bl 0x82df1c90
	ctx.lr = 0x82ABF454;
	sub_82DF1C90(ctx, base);
	// 82ABF454: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82ABF458: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ABF45C: 419A0008  beq cr6, 0x82abf464
	if ctx.cr[6].eq {
	pc = 0x82ABF464; continue 'dispatch;
	}
	// 82ABF460: 4B801431  bl 0x822c0890
	ctx.lr = 0x82ABF464;
	sub_822C0890(ctx, base);
	// 82ABF464: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82ABF468: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ABF46C: 419A0008  beq cr6, 0x82abf474
	if ctx.cr[6].eq {
	pc = 0x82ABF474; continue 'dispatch;
	}
	// 82ABF470: 4B801421  bl 0x822c0890
	ctx.lr = 0x82ABF474;
	sub_822C0890(ctx, base);
	// 82ABF474: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABF478: 4BFF1CF1  bl 0x82ab1168
	ctx.lr = 0x82ABF47C;
	sub_82AB1168(ctx, base);
	// 82ABF47C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ABF480: 41820030  beq 0x82abf4b0
	if ctx.cr[0].eq {
	pc = 0x82ABF4B0; continue 'dispatch;
	}
	// 82ABF484: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82ABF488: 4BFA4849  bl 0x82a63cd0
	ctx.lr = 0x82ABF48C;
	sub_82A63CD0(ctx, base);
	// 82ABF48C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82ABF490: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABF494: 4BFFAF05  bl 0x82aba398
	ctx.lr = 0x82ABF498;
	sub_82ABA398(ctx, base);
	// 82ABF498: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 82ABF49C: 3880001C  li r4, 0x1c
	ctx.r[4].s64 = 28;
	// 82ABF4A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABF4A4: 4BFF1D4D  bl 0x82ab11f0
	ctx.lr = 0x82ABF4A8;
	sub_82AB11F0(ctx, base);
	// 82ABF4A8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82ABF4AC: 917D0070  stw r11, 0x70(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82ABF4B0: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82ABF4B4: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82ABF4B8: 486E8CFC  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABF4C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ABF4C0 size=116
    let mut pc: u32 = 0x82ABF4C0;
    'dispatch: loop {
        match pc {
            0x82ABF4C0 => {
    //   block [0x82ABF4C0..0x82ABF534)
	// 82ABF4C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABF4C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABF4C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABF4CC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABF4D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABF4D4: 4BFFF8C5  bl 0x82abed98
	ctx.lr = 0x82ABF4D8;
	sub_82ABED98(ctx, base);
	// 82ABF4D8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ABF4DC: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82ABF4E0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82ABF4E4: 394A8F1C  addi r10, r10, -0x70e4
	ctx.r[10].s64 = ctx.r[10].s64 + -28900;
	// 82ABF4E8: 913F0070  stw r9, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[9].u32 ) };
	// 82ABF4EC: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82ABF4F0: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ABF4F4: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82ABF4F8: D01F0074  stfs f0, 0x74(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82ABF4FC: 38897A38  addi r4, r9, 0x7a38
	ctx.r[4].s64 = ctx.r[9].s64 + 31288;
	// 82ABF500: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ABF504: 48334505  bl 0x82df3a08
	ctx.lr = 0x82ABF508;
	sub_82DF3A08(ctx, base);
	// 82ABF508: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABF50C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82ABF510: 4839A1D9  bl 0x82e596e8
	ctx.lr = 0x82ABF514;
	sub_82E596E8(ctx, base);
	// 82ABF514: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ABF518: 48333F11  bl 0x82df3428
	ctx.lr = 0x82ABF51C;
	sub_82DF3428(ctx, base);
	// 82ABF51C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABF520: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ABF524: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABF528: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABF52C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ABF530: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABF538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ABF538 size=608
    let mut pc: u32 = 0x82ABF538;
    'dispatch: loop {
        match pc {
            0x82ABF538 => {
    //   block [0x82ABF538..0x82ABF798)
	// 82ABF538: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABF53C: 486E8C2D  bl 0x831a8168
	ctx.lr = 0x82ABF540;
	sub_831A8130(ctx, base);
	// 82ABF540: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82ABF544: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABF548: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ABF54C: 4BFFF7AD  bl 0x82abecf8
	ctx.lr = 0x82ABF550;
	sub_82ABECF8(ctx, base);
	// 82ABF550: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABF554: 486950AD  bl 0x83154600
	ctx.lr = 0x82ABF558;
	sub_83154600(ctx, base);
	// 82ABF558: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABF55C: 4BD2CC7D  bl 0x827ec1d8
	ctx.lr = 0x82ABF560;
	sub_827EC1D8(ctx, base);
	// 82ABF560: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82ABF564: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABF568: 4BF53951  bl 0x82a12eb8
	ctx.lr = 0x82ABF56C;
	sub_82A12EB8(ctx, base);
	// 82ABF56C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82ABF570: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ABF574: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82ABF578: 4BFF3439  bl 0x82ab29b0
	ctx.lr = 0x82ABF57C;
	sub_82AB29B0(ctx, base);
	// 82ABF57C: 817E0070  lwz r11, 0x70(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(112 as u32) ) } as u64;
	// 82ABF580: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82ABF584: 419800BC  blt cr6, 0x82abf640
	if ctx.cr[6].lt {
	pc = 0x82ABF640; continue 'dispatch;
	}
	// 82ABF588: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82ABF58C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82ABF590: C3EA08A4  lfs f31, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82ABF594: 419A0034  beq cr6, 0x82abf5c8
	if ctx.cr[6].eq {
	pc = 0x82ABF5C8; continue 'dispatch;
	}
	// 82ABF598: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82ABF59C: 41980068  blt cr6, 0x82abf604
	if ctx.cr[6].lt {
	pc = 0x82ABF604; continue 'dispatch;
	}
	// 82ABF5A0: 2B0B0007  cmplwi cr6, r11, 7
	ctx.cr[6].compare_u32(ctx.r[11].u32, 7 as u32, &mut ctx.xer);
	// 82ABF5A4: 409A01C4  bne cr6, 0x82abf768
	if !ctx.cr[6].eq {
	pc = 0x82ABF768; continue 'dispatch;
	}
	// 82ABF5A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABF5AC: 4BFB1AAD  bl 0x82a71058
	ctx.lr = 0x82ABF5B0;
	sub_82A71058(ctx, base);
	// 82ABF5B0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ABF5B4: 418201B4  beq 0x82abf768
	if ctx.cr[0].eq {
	pc = 0x82ABF768; continue 'dispatch;
	}
	// 82ABF5B8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82ABF5BC: 4BFA4725  bl 0x82a63ce0
	ctx.lr = 0x82ABF5C0;
	sub_82A63CE0(ctx, base);
	// 82ABF5C0: 39600008  li r11, 8
	ctx.r[11].s64 = 8;
	// 82ABF5C4: 48000074  b 0x82abf638
	pc = 0x82ABF638; continue 'dispatch;
	// 82ABF5C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABF5CC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82ABF5D0: 4BFFF6E9  bl 0x82abecb8
	ctx.lr = 0x82ABF5D4;
	sub_82ABECB8(ctx, base);
	// 82ABF5D4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ABF5D8: 41820190  beq 0x82abf768
	if ctx.cr[0].eq {
	pc = 0x82ABF768; continue 'dispatch;
	}
	// 82ABF5DC: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82ABF5E0: 80610060  lwz r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82ABF5E4: 4BFFD565  bl 0x82abcb48
	ctx.lr = 0x82ABF5E8;
	sub_82ABCB48(ctx, base);
	// 82ABF5E8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ABF5EC: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 82ABF5F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABF5F4: 915E0070  stw r10, 0x70(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 82ABF5F8: C00B8F14  lfs f0, -0x70ec(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28908 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ABF5FC: D01E0074  stfs f0, 0x74(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82ABF600: 4BFF59A1  bl 0x82ab4fa0
	ctx.lr = 0x82ABF604;
	sub_82AB4FA0(ctx, base);
	// 82ABF604: C01E0074  lfs f0, 0x74(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ABF608: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82ABF60C: 4199015C  bgt cr6, 0x82abf768
	if ctx.cr[6].gt {
	pc = 0x82ABF768; continue 'dispatch;
	}
	// 82ABF610: 80610060  lwz r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82ABF614: 4BFFD465  bl 0x82abca78
	ctx.lr = 0x82ABF618;
	sub_82ABCA78(ctx, base);
	// 82ABF618: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ABF61C: 4082014C  bne 0x82abf768
	if !ctx.cr[0].eq {
	pc = 0x82ABF768; continue 'dispatch;
	}
	// 82ABF620: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82ABF624: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82ABF628: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABF62C: 808B9FA0  lwz r4, -0x6060(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24672 as u32) ) } as u64;
	// 82ABF630: 4BFFF7D1  bl 0x82abee00
	ctx.lr = 0x82ABF634;
	sub_82ABEE00(ctx, base);
	// 82ABF634: 39600007  li r11, 7
	ctx.r[11].s64 = 7;
	// 82ABF638: 917E0070  stw r11, 0x70(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82ABF63C: 4800012C  b 0x82abf768
	pc = 0x82ABF768; continue 'dispatch;
	// 82ABF640: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82ABF644: 4BFA468D  bl 0x82a63cd0
	ctx.lr = 0x82ABF648;
	sub_82A63CD0(ctx, base);
	// 82ABF648: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82ABF64C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABF650: 808B9FA0  lwz r4, -0x6060(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24672 as u32) ) } as u64;
	// 82ABF654: 4BFFF9BD  bl 0x82abf010
	ctx.lr = 0x82ABF658;
	sub_82ABF010(ctx, base);
	// 82ABF658: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82ABF65C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ABF660: 4BFFAD39  bl 0x82aba398
	ctx.lr = 0x82ABF664;
	sub_82ABA398(ctx, base);
	// 82ABF664: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82ABF668: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABF66C: 4BFF136D  bl 0x82ab09d8
	ctx.lr = 0x82ABF670;
	sub_82AB09D8(ctx, base);
	// 82ABF670: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82ABF674: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82ABF678: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABF67C: C02B964C  lfs f1, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82ABF680: 4BFF8461  bl 0x82ab7ae0
	ctx.lr = 0x82ABF684;
	sub_82AB7AE0(ctx, base);
	// 82ABF684: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82ABF688: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABF68C: 4BFF74E5  bl 0x82ab6b70
	ctx.lr = 0x82ABF690;
	sub_82AB6B70(ctx, base);
	// 82ABF690: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABF694: 4BFF7275  bl 0x82ab6908
	ctx.lr = 0x82ABF698;
	sub_82AB6908(ctx, base);
	// 82ABF698: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82ABF69C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82ABF6A0: 9BA10050  stb r29, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u8 ) };
	// 82ABF6A4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82ABF6A8: 4BAB9229  bl 0x825788d0
	ctx.lr = 0x82ABF6AC;
	sub_825788D0(ctx, base);
	// 82ABF6AC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABF6B0: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82ABF6B4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ABF6B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ABF6BC: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82ABF6C0: 419A0024  beq cr6, 0x82abf6e4
	if ctx.cr[6].eq {
	pc = 0x82ABF6E4; continue 'dispatch;
	}
	// 82ABF6C4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82ABF6C8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82ABF6CC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ABF6D0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82ABF6D4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ABF6D8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82ABF6DC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ABF6E0: 4082FFE8  bne 0x82abf6c8
	if !ctx.cr[0].eq {
	pc = 0x82ABF6C8; continue 'dispatch;
	}
	// 82ABF6E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ABF6E8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82ABF6EC: 4BA4FDDD  bl 0x8250f4c8
	ctx.lr = 0x82ABF6F0;
	sub_8250F4C8(ctx, base);
	// 82ABF6F0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABF6F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ABF6F8: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82ABF6FC: 409A0008  bne cr6, 0x82abf704
	if !ctx.cr[6].eq {
	pc = 0x82ABF704; continue 'dispatch;
	}
	// 82ABF700: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ABF704: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82ABF708: 3B810058  addi r28, r1, 0x58
	ctx.r[28].s64 = ctx.r[1].s64 + 88;
	// 82ABF70C: 4BA4930D  bl 0x82508a18
	ctx.lr = 0x82ABF710;
	sub_82508A18(ctx, base);
	// 82ABF710: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ABF714: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82ABF718: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82ABF71C: 388A8F40  addi r4, r10, -0x70c0
	ctx.r[4].s64 = ctx.r[10].s64 + -28864;
	// 82ABF720: 38A00054  li r5, 0x54
	ctx.r[5].s64 = 84;
	// 82ABF724: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82ABF728: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82ABF72C: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82ABF730: 48399311  bl 0x82e58a40
	ctx.lr = 0x82ABF734;
	sub_82E58A40(ctx, base);
	// 82ABF734: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82ABF738: 48332559  bl 0x82df1c90
	ctx.lr = 0x82ABF73C;
	sub_82DF1C90(ctx, base);
	// 82ABF73C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82ABF740: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ABF744: 419A0008  beq cr6, 0x82abf74c
	if ctx.cr[6].eq {
	pc = 0x82ABF74C; continue 'dispatch;
	}
	// 82ABF748: 4B801149  bl 0x822c0890
	ctx.lr = 0x82ABF74C;
	sub_822C0890(ctx, base);
	// 82ABF74C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82ABF750: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ABF754: 419A0008  beq cr6, 0x82abf75c
	if ctx.cr[6].eq {
	pc = 0x82ABF75C; continue 'dispatch;
	}
	// 82ABF758: 4B801139  bl 0x822c0890
	ctx.lr = 0x82ABF75C;
	sub_822C0890(ctx, base);
	// 82ABF75C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABF760: 4BFF7339  bl 0x82ab6a98
	ctx.lr = 0x82ABF764;
	sub_82AB6A98(ctx, base);
	// 82ABF764: 93BE0070  stw r29, 0x70(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 82ABF768: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABF76C: 4839A00D  bl 0x82e59778
	ctx.lr = 0x82ABF770;
	sub_82E59778(ctx, base);
	// 82ABF770: C01E0074  lfs f0, 0x74(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ABF774: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82ABF778: EC000828  fsubs f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 82ABF77C: D01E0074  stfs f0, 0x74(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82ABF780: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ABF784: 419A0008  beq cr6, 0x82abf78c
	if ctx.cr[6].eq {
	pc = 0x82ABF78C; continue 'dispatch;
	}
	// 82ABF788: 4B801109  bl 0x822c0890
	ctx.lr = 0x82ABF78C;
	sub_822C0890(ctx, base);
	// 82ABF78C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82ABF790: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82ABF794: 486E8A24  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABF798(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ABF798 size=128
    let mut pc: u32 = 0x82ABF798;
    'dispatch: loop {
        match pc {
            0x82ABF798 => {
    //   block [0x82ABF798..0x82ABF818)
	// 82ABF798: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABF79C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABF7A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ABF7A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABF7A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABF7AC: 48694E55  bl 0x83154600
	ctx.lr = 0x82ABF7B0;
	sub_83154600(ctx, base);
	// 82ABF7B0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ABF7B4: 4BF53705  bl 0x82a12eb8
	ctx.lr = 0x82ABF7B8;
	sub_82A12EB8(ctx, base);
	// 82ABF7B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABF7BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABF7C0: 4BFF13D1  bl 0x82ab0b90
	ctx.lr = 0x82ABF7C4;
	sub_82AB0B90(ctx, base);
	// 82ABF7C4: 2F030006  cmpwi cr6, r3, 6
	ctx.cr[6].compare_i32(ctx.r[3].s32, 6, &mut ctx.xer);
	// 82ABF7C8: 419A001C  beq cr6, 0x82abf7e4
	if ctx.cr[6].eq {
	pc = 0x82ABF7E4; continue 'dispatch;
	}
	// 82ABF7CC: 2F030007  cmpwi cr6, r3, 7
	ctx.cr[6].compare_i32(ctx.r[3].s32, 7, &mut ctx.xer);
	// 82ABF7D0: 419A000C  beq cr6, 0x82abf7dc
	if ctx.cr[6].eq {
	pc = 0x82ABF7DC; continue 'dispatch;
	}
	// 82ABF7D4: 3880000D  li r4, 0xd
	ctx.r[4].s64 = 13;
	// 82ABF7D8: 48000010  b 0x82abf7e8
	pc = 0x82ABF7E8; continue 'dispatch;
	// 82ABF7DC: 38800007  li r4, 7
	ctx.r[4].s64 = 7;
	// 82ABF7E0: 48000008  b 0x82abf7e8
	pc = 0x82ABF7E8; continue 'dispatch;
	// 82ABF7E4: 3880000E  li r4, 0xe
	ctx.r[4].s64 = 14;
	// 82ABF7E8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ABF7EC: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82ABF7F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABF7F4: C04B8398  lfs f2, -0x7c68(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-31848 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82ABF7F8: C02A9450  lfs f1, -0x6bb0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82ABF7FC: 4BFFA905  bl 0x82aba100
	ctx.lr = 0x82ABF800;
	sub_82ABA100(ctx, base);
	// 82ABF800: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ABF804: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABF808: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABF80C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ABF810: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ABF814: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABF818(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ABF818 size=68
    let mut pc: u32 = 0x82ABF818;
    'dispatch: loop {
        match pc {
            0x82ABF818 => {
    //   block [0x82ABF818..0x82ABF85C)
	// 82ABF818: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABF81C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABF820: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABF824: 48694DDD  bl 0x83154600
	ctx.lr = 0x82ABF828;
	sub_83154600(ctx, base);
	// 82ABF828: 4BF53691  bl 0x82a12eb8
	ctx.lr = 0x82ABF82C;
	sub_82A12EB8(ctx, base);
	// 82ABF82C: 4BA98295  bl 0x82557ac0
	ctx.lr = 0x82ABF830;
	sub_82557AC0(ctx, base);
	// 82ABF830: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABF834: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ABF838: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABF83C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82ABF840: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82ABF844: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ABF848: 4E800421  bctrl
	ctx.lr = 0x82ABF84C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ABF84C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82ABF850: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABF854: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABF858: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABF860(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABF860 size=104
    let mut pc: u32 = 0x82ABF860;
    'dispatch: loop {
        match pc {
            0x82ABF860 => {
    //   block [0x82ABF860..0x82ABF8C8)
	// 82ABF860: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABF864: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABF868: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABF86C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABF870: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABF874: 4BFFF525  bl 0x82abed98
	ctx.lr = 0x82ABF878;
	sub_82ABED98(ctx, base);
	// 82ABF878: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ABF87C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82ABF880: 396B8FA4  addi r11, r11, -0x705c
	ctx.r[11].s64 = ctx.r[11].s64 + -28764;
	// 82ABF884: 915F0070  stw r10, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 82ABF888: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82ABF88C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ABF890: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ABF894: 388A0740  addi r4, r10, 0x740
	ctx.r[4].s64 = ctx.r[10].s64 + 1856;
	// 82ABF898: 48334171  bl 0x82df3a08
	ctx.lr = 0x82ABF89C;
	sub_82DF3A08(ctx, base);
	// 82ABF89C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABF8A0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82ABF8A4: 48399E45  bl 0x82e596e8
	ctx.lr = 0x82ABF8A8;
	sub_82E596E8(ctx, base);
	// 82ABF8A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ABF8AC: 48333B7D  bl 0x82df3428
	ctx.lr = 0x82ABF8B0;
	sub_82DF3428(ctx, base);
	// 82ABF8B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABF8B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ABF8B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABF8BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABF8C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ABF8C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABF8C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ABF8C8 size=172
    let mut pc: u32 = 0x82ABF8C8;
    'dispatch: loop {
        match pc {
            0x82ABF8C8 => {
    //   block [0x82ABF8C8..0x82ABF974)
	// 82ABF8C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABF8CC: 486E88A1  bl 0x831a816c
	ctx.lr = 0x82ABF8D0;
	sub_831A8130(ctx, base);
	// 82ABF8D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABF8D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABF8D8: 48694D29  bl 0x83154600
	ctx.lr = 0x82ABF8DC;
	sub_83154600(ctx, base);
	// 82ABF8DC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82ABF8E0: 4BD2C8F9  bl 0x827ec1d8
	ctx.lr = 0x82ABF8E4;
	sub_827EC1D8(ctx, base);
	// 82ABF8E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ABF8E8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ABF8EC: 4BF535CD  bl 0x82a12eb8
	ctx.lr = 0x82ABF8F0;
	sub_82A12EB8(ctx, base);
	// 82ABF8F0: 817F0070  lwz r11, 0x70(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82ABF8F4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82ABF8F8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82ABF8FC: 41980058  blt cr6, 0x82abf954
	if ctx.cr[6].lt {
	pc = 0x82ABF954; continue 'dispatch;
	}
	// 82ABF900: 419A001C  beq cr6, 0x82abf91c
	if ctx.cr[6].eq {
	pc = 0x82ABF91C; continue 'dispatch;
	}
	// 82ABF904: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82ABF908: 40980064  bge cr6, 0x82abf96c
	if !ctx.cr[6].lt {
	pc = 0x82ABF96C; continue 'dispatch;
	}
	// 82ABF90C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABF910: 4BFA43D1  bl 0x82a63ce0
	ctx.lr = 0x82ABF914;
	sub_82A63CE0(ctx, base);
	// 82ABF914: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82ABF918: 48000050  b 0x82abf968
	pc = 0x82ABF968; continue 'dispatch;
	// 82ABF91C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABF920: 4BFFFEF9  bl 0x82abf818
	ctx.lr = 0x82ABF924;
	sub_82ABF818(ctx, base);
	// 82ABF924: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82ABF928: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82ABF92C: 409A0040  bne cr6, 0x82abf96c
	if !ctx.cr[6].eq {
	pc = 0x82ABF96C; continue 'dispatch;
	}
	// 82ABF930: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ABF934: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82ABF938: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82ABF93C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ABF940: C04B08A4  lfs f2, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82ABF944: C02A9450  lfs f1, -0x6bb0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82ABF948: 4BFFA6C9  bl 0x82aba010
	ctx.lr = 0x82ABF94C;
	sub_82ABA010(ctx, base);
	// 82ABF94C: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82ABF950: 48000018  b 0x82abf968
	pc = 0x82ABF968; continue 'dispatch;
	// 82ABF954: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABF958: 4BFA4379  bl 0x82a63cd0
	ctx.lr = 0x82ABF95C;
	sub_82A63CD0(ctx, base);
	// 82ABF95C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABF960: 4BFFFE39  bl 0x82abf798
	ctx.lr = 0x82ABF964;
	sub_82ABF798(ctx, base);
	// 82ABF964: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82ABF968: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82ABF96C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ABF970: 486E884C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABF978(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ABF978 size=192
    let mut pc: u32 = 0x82ABF978;
    'dispatch: loop {
        match pc {
            0x82ABF978 => {
    //   block [0x82ABF978..0x82ABFA38)
	// 82ABF978: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABF97C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABF980: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABF984: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABF988: 48694C79  bl 0x83154600
	ctx.lr = 0x82ABF98C;
	sub_83154600(ctx, base);
	// 82ABF98C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABF990: 4BFF7CE9  bl 0x82ab7678
	ctx.lr = 0x82ABF994;
	sub_82AB7678(ctx, base);
	// 82ABF994: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82ABF998: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82ABF99C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABF9A0: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABFA38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ABFA38 size=120
    let mut pc: u32 = 0x82ABFA38;
    'dispatch: loop {
        match pc {
            0x82ABFA38 => {
    //   block [0x82ABFA38..0x82ABFAB0)
	// 82ABFA38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABFA3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABFA40: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABFA44: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABFA48: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABFA4C: 4BFFF34D  bl 0x82abed98
	ctx.lr = 0x82ABFA50;
	sub_82ABED98(ctx, base);
	// 82ABFA50: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82ABFA54: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 82ABFA58: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ABFA5C: 39298FF0  addi r9, r9, -0x7010
	ctx.r[9].s64 = ctx.r[9].s64 + -28688;
	// 82ABFA60: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82ABFA64: 3D008202  lis r8, -0x7dfe
	ctx.r[8].s64 = -2113798144;
	// 82ABFA68: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ABFA6C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82ABFA70: D01F0074  stfs f0, 0x74(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82ABFA74: 997F0078  stb r11, 0x78(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[11].u8 ) };
	// 82ABFA78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ABFA7C: 3888C8D0  addi r4, r8, -0x3730
	ctx.r[4].s64 = ctx.r[8].s64 + -14128;
	// 82ABFA80: 48333F89  bl 0x82df3a08
	ctx.lr = 0x82ABFA84;
	sub_82DF3A08(ctx, base);
	// 82ABFA84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABFA88: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82ABFA8C: 48399C5D  bl 0x82e596e8
	ctx.lr = 0x82ABFA90;
	sub_82E596E8(ctx, base);
	// 82ABFA90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ABFA94: 48333995  bl 0x82df3428
	ctx.lr = 0x82ABFA98;
	sub_82DF3428(ctx, base);
	// 82ABFA98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABFA9C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ABFAA0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABFAA4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABFAA8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ABFAAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABFAB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABFAB0 size=196
    let mut pc: u32 = 0x82ABFAB0;
    'dispatch: loop {
        match pc {
            0x82ABFAB0 => {
    //   block [0x82ABFAB0..0x82ABFB74)
	// 82ABFAB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABFAB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ABFAB8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ABFABC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ABFAC0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABFAC4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ABFAC8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ABFACC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82ABFAD0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82ABFAD4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ABFAD8: 4B800E61  bl 0x822c0938
	ctx.lr = 0x82ABFADC;
	sub_822C0938(ctx, base);
	// 82ABFADC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ABFAE0: 41820028  beq 0x82abfb08
	if ctx.cr[0].eq {
	pc = 0x82ABFB08; continue 'dispatch;
	}
	// 82ABFAE4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ABFAE8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82ABFAEC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82ABFAF0: 392B8FDC  addi r9, r11, -0x7024
	ctx.r[9].s64 = ctx.r[11].s64 + -28708;
	// 82ABFAF4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82ABFAF8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82ABFAFC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82ABFB00: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82ABFB04: 48000008  b 0x82abfb0c
	pc = 0x82ABFB0C; continue 'dispatch;
	// 82ABFB08: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ABFB0C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ABFB10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ABFB14: 409A0044  bne cr6, 0x82abfb58
	if !ctx.cr[6].eq {
	pc = 0x82ABFB58; continue 'dispatch;
	}
	// 82ABFB18: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82ABFB1C: 419A001C  beq cr6, 0x82abfb38
	if ctx.cr[6].eq {
	pc = 0x82ABFB38; continue 'dispatch;
	}
	// 82ABFB20: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABFB24: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82ABFB28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABFB2C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABFB30: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ABFB34: 4E800421  bctrl
	ctx.lr = 0x82ABFB38;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ABFB38: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82ABFB3C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82ABFB40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ABFB44: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82ABFB48: 816BF4BC  lwz r11, -0xb44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2884 as u32) ) } as u64;
	// 82ABFB4C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82ABFB50: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82ABFB54: 4B8004AD  bl 0x822c0000
	ctx.lr = 0x82ABFB58;
	sub_822C0000(ctx, base);
	// 82ABFB58: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABFB5C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ABFB60: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ABFB64: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ABFB68: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ABFB6C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ABFB70: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABFB78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ABFB78 size=124
    let mut pc: u32 = 0x82ABFB78;
    'dispatch: loop {
        match pc {
            0x82ABFB78 => {
    //   block [0x82ABFB78..0x82ABFBF4)
	// 82ABFB78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABFB7C: 486E85F1  bl 0x831a816c
	ctx.lr = 0x82ABFB80;
	sub_831A8130(ctx, base);
	// 82ABFB80: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABFB84: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82ABFB88: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82ABFB8C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82ABFB90: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82ABFB94: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 82ABFB98: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 82ABFB9C: 4833284D  bl 0x82df23e8
	ctx.lr = 0x82ABFBA0;
	sub_82DF23E8(ctx, base);
	// 82ABFBA0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82ABFBA4: 4182001C  beq 0x82abfbc0
	if ctx.cr[0].eq {
	pc = 0x82ABFBC0; continue 'dispatch;
	}
	// 82ABFBA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABFBAC: 48399AD5  bl 0x82e59680
	ctx.lr = 0x82ABFBB0;
	sub_82E59680(ctx, base);
	// 82ABFBB0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ABFBB4: 396B8FD4  addi r11, r11, -0x702c
	ctx.r[11].s64 = ctx.r[11].s64 + -28716;
	// 82ABFBB8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ABFBBC: 48000008  b 0x82abfbc4
	pc = 0x82ABFBC4; continue 'dispatch;
	// 82ABFBC0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82ABFBC4: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82ABFBC8: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82ABFBCC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ABFBD0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABFBD4: 4BFFFEDD  bl 0x82abfab0
	ctx.lr = 0x82ABFBD8;
	sub_82ABFAB0(ctx, base);
	// 82ABFBD8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82ABFBDC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ABFBE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABFBE4: 4B80041D  bl 0x822c0000
	ctx.lr = 0x82ABFBE8;
	sub_822C0000(ctx, base);
	// 82ABFBE8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ABFBEC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ABFBF0: 486E85CC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ABFBF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ABFBF8 size=1168
    let mut pc: u32 = 0x82ABFBF8;
    'dispatch: loop {
        match pc {
            0x82ABFBF8 => {
    //   block [0x82ABFBF8..0x82AC0088)
	// 82ABFBF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ABFBFC: 486E8569  bl 0x831a8164
	ctx.lr = 0x82ABFC00;
	sub_831A8130(ctx, base);
	// 82ABFC00: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82ABFC04: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ABFC08: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82ABFC0C: 4BFFF0ED  bl 0x82abecf8
	ctx.lr = 0x82ABFC10;
	sub_82ABECF8(ctx, base);
	// 82ABFC10: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82ABFC14: 486949ED  bl 0x83154600
	ctx.lr = 0x82ABFC18;
	sub_83154600(ctx, base);
	// 82ABFC18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ABFC1C: 4BD2C5BD  bl 0x827ec1d8
	ctx.lr = 0x82ABFC20;
	sub_827EC1D8(ctx, base);
	// 82ABFC20: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ABFC24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABFC28: 4BF53291  bl 0x82a12eb8
	ctx.lr = 0x82ABFC2C;
	sub_82A12EB8(ctx, base);
	// 82ABFC2C: 817C0070  lwz r11, 0x70(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(112 as u32) ) } as u64;
	// 82ABFC30: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82ABFC34: 4198032C  blt cr6, 0x82abff60
	if ctx.cr[6].lt {
	pc = 0x82ABFF60; continue 'dispatch;
	}
	// 82ABFC38: 419A030C  beq cr6, 0x82abff44
	if ctx.cr[6].eq {
	pc = 0x82ABFF44; continue 'dispatch;
	}
	// 82ABFC3C: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82ABFC40: 41980290  blt cr6, 0x82abfed0
	if ctx.cr[6].lt {
	pc = 0x82ABFED0; continue 'dispatch;
	}
	// 82ABFC44: 419A0104  beq cr6, 0x82abfd48
	if ctx.cr[6].eq {
	pc = 0x82ABFD48; continue 'dispatch;
	}
	// 82ABFC48: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 82ABFC4C: 419A00E0  beq cr6, 0x82abfd2c
	if ctx.cr[6].eq {
	pc = 0x82ABFD2C; continue 'dispatch;
	}
	// 82ABFC50: 2B0B0006  cmplwi cr6, r11, 6
	ctx.cr[6].compare_u32(ctx.r[11].u32, 6 as u32, &mut ctx.xer);
	// 82ABFC54: 409A0414  bne cr6, 0x82ac0068
	if !ctx.cr[6].eq {
	pc = 0x82AC0068; continue 'dispatch;
	}
	// 82ABFC58: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ABFC5C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82ABFC60: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82ABFC64: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82ABFC68: 4BFFF051  bl 0x82abecb8
	ctx.lr = 0x82ABFC6C;
	sub_82ABECB8(ctx, base);
	// 82ABFC6C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ABFC70: 418203F8  beq 0x82ac0068
	if ctx.cr[0].eq {
	pc = 0x82AC0068; continue 'dispatch;
	}
	// 82ABFC74: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82ABFC78: 4BAD7E01  bl 0x82597a78
	ctx.lr = 0x82ABFC7C;
	sub_82597A78(ctx, base);
	// 82ABFC7C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABFC80: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82ABFC84: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ABFC88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ABFC8C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82ABFC90: 419A0024  beq cr6, 0x82abfcb4
	if ctx.cr[6].eq {
	pc = 0x82ABFCB4; continue 'dispatch;
	}
	// 82ABFC94: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82ABFC98: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82ABFC9C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ABFCA0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82ABFCA4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ABFCA8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82ABFCAC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ABFCB0: 4082FFE8  bne 0x82abfc98
	if !ctx.cr[0].eq {
	pc = 0x82ABFC98; continue 'dispatch;
	}
	// 82ABFCB4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ABFCB8: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82ABFCBC: 4BA4F80D  bl 0x8250f4c8
	ctx.lr = 0x82ABFCC0;
	sub_8250F4C8(ctx, base);
	// 82ABFCC0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABFCC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ABFCC8: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82ABFCCC: 409A0008  bne cr6, 0x82abfcd4
	if !ctx.cr[6].eq {
	pc = 0x82ABFCD4; continue 'dispatch;
	}
	// 82ABFCD0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ABFCD4: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 82ABFCD8: 4BA49189  bl 0x82508e60
	ctx.lr = 0x82ABFCDC;
	sub_82508E60(ctx, base);
	// 82ABFCDC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ABFCE0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82ABFCE4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82ABFCE8: 388B9018  addi r4, r11, -0x6fe8
	ctx.r[4].s64 = ctx.r[11].s64 + -28648;
	// 82ABFCEC: 38A0009F  li r5, 0x9f
	ctx.r[5].s64 = 159;
	// 82ABFCF0: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82ABFCF4: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82ABFCF8: 48398D49  bl 0x82e58a40
	ctx.lr = 0x82ABFCFC;
	sub_82E58A40(ctx, base);
	// 82ABFCFC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82ABFD00: 48331F91  bl 0x82df1c90
	ctx.lr = 0x82ABFD04;
	sub_82DF1C90(ctx, base);
	// 82ABFD04: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82ABFD08: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ABFD0C: 419A0008  beq cr6, 0x82abfd14
	if ctx.cr[6].eq {
	pc = 0x82ABFD14; continue 'dispatch;
	}
	// 82ABFD10: 4B800B81  bl 0x822c0890
	ctx.lr = 0x82ABFD14;
	sub_822C0890(ctx, base);
	// 82ABFD14: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82ABFD18: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ABFD1C: 419A0008  beq cr6, 0x82abfd24
	if ctx.cr[6].eq {
	pc = 0x82ABFD24; continue 'dispatch;
	}
	// 82ABFD20: 4B800B71  bl 0x822c0890
	ctx.lr = 0x82ABFD24;
	sub_822C0890(ctx, base);
	// 82ABFD24: 39600007  li r11, 7
	ctx.r[11].s64 = 7;
	// 82ABFD28: 4800033C  b 0x82ac0064
	pc = 0x82AC0064; continue 'dispatch;
	// 82ABFD2C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ABFD30: C1BC0074  lfs f13, 0x74(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(116 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ABFD34: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ABFD38: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82ABFD3C: 4199032C  bgt cr6, 0x82ac0068
	if ctx.cr[6].gt {
	pc = 0x82AC0068; continue 'dispatch;
	}
	// 82ABFD40: 39600006  li r11, 6
	ctx.r[11].s64 = 6;
	// 82ABFD44: 48000320  b 0x82ac0064
	pc = 0x82AC0064; continue 'dispatch;
	// 82ABFD48: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82ABFD4C: 4BFB130D  bl 0x82a71058
	ctx.lr = 0x82ABFD50;
	sub_82A71058(ctx, base);
	// 82ABFD50: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ABFD54: 41820314  beq 0x82ac0068
	if ctx.cr[0].eq {
	pc = 0x82AC0068; continue 'dispatch;
	}
	// 82ABFD58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABFD5C: 4BFF736D  bl 0x82ab70c8
	ctx.lr = 0x82ABFD60;
	sub_82AB70C8(ctx, base);
	// 82ABFD60: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ABFD64: 40820154  bne 0x82abfeb8
	if !ctx.cr[0].eq {
	pc = 0x82ABFEB8; continue 'dispatch;
	}
	// 82ABFD68: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82ABFD6C: 4B850F15  bl 0x82310c80
	ctx.lr = 0x82ABFD70;
	sub_82310C80(ctx, base);
	// 82ABFD70: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABFD74: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82ABFD78: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ABFD7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ABFD80: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82ABFD84: 419A0024  beq cr6, 0x82abfda8
	if ctx.cr[6].eq {
	pc = 0x82ABFDA8; continue 'dispatch;
	}
	// 82ABFD88: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82ABFD8C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82ABFD90: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ABFD94: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82ABFD98: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ABFD9C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82ABFDA0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ABFDA4: 4082FFE8  bne 0x82abfd8c
	if !ctx.cr[0].eq {
	pc = 0x82ABFD8C; continue 'dispatch;
	}
	// 82ABFDA8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ABFDAC: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82ABFDB0: 4BA4F581  bl 0x8250f330
	ctx.lr = 0x82ABFDB4;
	sub_8250F330(ctx, base);
	// 82ABFDB4: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABFDB8: 3BDF0028  addi r30, r31, 0x28
	ctx.r[30].s64 = ctx.r[31].s64 + 40;
	// 82ABFDBC: 3B610060  addi r27, r1, 0x60
	ctx.r[27].s64 = ctx.r[1].s64 + 96;
	// 82ABFDC0: 4BA29AE1  bl 0x824e98a0
	ctx.lr = 0x82ABFDC4;
	sub_824E98A0(ctx, base);
	// 82ABFDC4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ABFDC8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82ABFDCC: 3BAB9018  addi r29, r11, -0x6fe8
	ctx.r[29].s64 = ctx.r[11].s64 + -28648;
	// 82ABFDD0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82ABFDD4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82ABFDD8: 38A00084  li r5, 0x84
	ctx.r[5].s64 = 132;
	// 82ABFDDC: C3EA08A4  lfs f31, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82ABFDE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABFDE4: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82ABFDE8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82ABFDEC: 48398C55  bl 0x82e58a40
	ctx.lr = 0x82ABFDF0;
	sub_82E58A40(ctx, base);
	// 82ABFDF0: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82ABFDF4: 48331E9D  bl 0x82df1c90
	ctx.lr = 0x82ABFDF8;
	sub_82DF1C90(ctx, base);
	// 82ABFDF8: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82ABFDFC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ABFE00: 419A0008  beq cr6, 0x82abfe08
	if ctx.cr[6].eq {
	pc = 0x82ABFE08; continue 'dispatch;
	}
	// 82ABFE04: 4B800A8D  bl 0x822c0890
	ctx.lr = 0x82ABFE08;
	sub_822C0890(ctx, base);
	// 82ABFE08: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82ABFE0C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ABFE10: 419A0008  beq cr6, 0x82abfe18
	if ctx.cr[6].eq {
	pc = 0x82ABFE18; continue 'dispatch;
	}
	// 82ABFE14: 4B800A7D  bl 0x822c0890
	ctx.lr = 0x82ABFE18;
	sub_822C0890(ctx, base);
	// 82ABFE18: 3960000A  li r11, 0xa
	ctx.r[11].s64 = 10;
	// 82ABFE1C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82ABFE20: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82ABFE24: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82ABFE28: 4B8496C9  bl 0x823094f0
	ctx.lr = 0x82ABFE2C;
	sub_823094F0(ctx, base);
	// 82ABFE2C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABFE30: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82ABFE34: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ABFE38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ABFE3C: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82ABFE40: 419A0024  beq cr6, 0x82abfe64
	if ctx.cr[6].eq {
	pc = 0x82ABFE64; continue 'dispatch;
	}
	// 82ABFE44: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82ABFE48: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82ABFE4C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ABFE50: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82ABFE54: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ABFE58: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82ABFE5C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ABFE60: 4082FFE8  bne 0x82abfe48
	if !ctx.cr[0].eq {
	pc = 0x82ABFE48; continue 'dispatch;
	}
	// 82ABFE64: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ABFE68: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82ABFE6C: 4BA4F4C5  bl 0x8250f330
	ctx.lr = 0x82ABFE70;
	sub_8250F330(ctx, base);
	// 82ABFE70: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABFE74: 3BE10068  addi r31, r1, 0x68
	ctx.r[31].s64 = ctx.r[1].s64 + 104;
	// 82ABFE78: 4BA299E9  bl 0x824e9860
	ctx.lr = 0x82ABFE7C;
	sub_824E9860(ctx, base);
	// 82ABFE7C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82ABFE80: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82ABFE84: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82ABFE88: 38A00087  li r5, 0x87
	ctx.r[5].s64 = 135;
	// 82ABFE8C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABFE90: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82ABFE94: 48398BAD  bl 0x82e58a40
	ctx.lr = 0x82ABFE98;
	sub_82E58A40(ctx, base);
	// 82ABFE98: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82ABFE9C: 48331DF5  bl 0x82df1c90
	ctx.lr = 0x82ABFEA0;
	sub_82DF1C90(ctx, base);
	// 82ABFEA0: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82ABFEA4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ABFEA8: 419A0008  beq cr6, 0x82abfeb0
	if ctx.cr[6].eq {
	pc = 0x82ABFEB0; continue 'dispatch;
	}
	// 82ABFEAC: 4B8009E5  bl 0x822c0890
	ctx.lr = 0x82ABFEB0;
	sub_822C0890(ctx, base);
	// 82ABFEB0: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82ABFEB4: 4BFFFE64  b 0x82abfd18
	pc = 0x82ABFD18; continue 'dispatch;
	// 82ABFEB8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ABFEBC: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 82ABFEC0: 915C0070  stw r10, 0x70(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 82ABFEC4: C00B8FC8  lfs f0, -0x7038(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28728 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ABFEC8: D01C0074  stfs f0, 0x74(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82ABFECC: 4800019C  b 0x82ac0068
	pc = 0x82AC0068; continue 'dispatch;
	// 82ABFED0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ABFED4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82ABFED8: C02B08A4  lfs f1, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82ABFEDC: 4BFFEDDD  bl 0x82abecb8
	ctx.lr = 0x82ABFEE0;
	sub_82ABECB8(ctx, base);
	// 82ABFEE0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ABFEE4: 41820020  beq 0x82abff04
	if ctx.cr[0].eq {
	pc = 0x82ABFF04; continue 'dispatch;
	}
	// 82ABFEE8: 897C0078  lbz r11, 0x78(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(120 as u32) ) } as u64;
	// 82ABFEEC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ABFEF0: 40820014  bne 0x82abff04
	if !ctx.cr[0].eq {
	pc = 0x82ABFF04; continue 'dispatch;
	}
	// 82ABFEF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABFEF8: 4BFF6211  bl 0x82ab6108
	ctx.lr = 0x82ABFEFC;
	sub_82AB6108(ctx, base);
	// 82ABFEFC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82ABFF00: 997C0078  stb r11, 0x78(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(120 as u32), ctx.r[11].u8 ) };
	// 82ABFF04: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82ABFF08: 4BFFFA71  bl 0x82abf978
	ctx.lr = 0x82ABFF0C;
	sub_82ABF978(ctx, base);
	// 82ABFF0C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ABFF10: 41820158  beq 0x82ac0068
	if ctx.cr[0].eq {
	pc = 0x82AC0068; continue 'dispatch;
	}
	// 82ABFF14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABFF18: 4BFF0EA1  bl 0x82ab0db8
	ctx.lr = 0x82ABFF1C;
	sub_82AB0DB8(ctx, base);
	// 82ABFF1C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ABFF20: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82ABFF24: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82ABFF28: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82ABFF2C: 808B9FC0  lwz r4, -0x6040(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24640 as u32) ) } as u64;
	// 82ABFF30: 41820008  beq 0x82abff38
	if ctx.cr[0].eq {
	pc = 0x82ABFF38; continue 'dispatch;
	}
	// 82ABFF34: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82ABFF38: 4BFFEEC9  bl 0x82abee00
	ctx.lr = 0x82ABFF3C;
	sub_82ABEE00(ctx, base);
	// 82ABFF3C: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82ABFF40: 48000124  b 0x82ac0064
	pc = 0x82AC0064; continue 'dispatch;
	// 82ABFF44: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82ABFF48: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82ABFF4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABFF50: C02B964C  lfs f1, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82ABFF54: 4BFF7B8D  bl 0x82ab7ae0
	ctx.lr = 0x82ABFF58;
	sub_82AB7AE0(ctx, base);
	// 82ABFF58: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82ABFF5C: 48000108  b 0x82ac0064
	pc = 0x82AC0064; continue 'dispatch;
	// 82ABFF60: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ABFF64: 4BFA3D6D  bl 0x82a63cd0
	ctx.lr = 0x82ABFF68;
	sub_82A63CD0(ctx, base);
	// 82ABFF68: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82ABFF6C: 38800009  li r4, 9
	ctx.r[4].s64 = 9;
	// 82ABFF70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABFF74: 4BFF59AD  bl 0x82ab5920
	ctx.lr = 0x82ABFF78;
	sub_82AB5920(ctx, base);
	// 82ABFF78: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 82ABFF7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ABFF80: 4BFF6BF1  bl 0x82ab6b70
	ctx.lr = 0x82ABFF84;
	sub_82AB6B70(ctx, base);
	// 82ABFF84: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82ABFF88: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82ABFF8C: 808B9FC0  lwz r4, -0x6040(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24640 as u32) ) } as u64;
	// 82ABFF90: 4BFFF081  bl 0x82abf010
	ctx.lr = 0x82ABFF94;
	sub_82ABF010(ctx, base);
	// 82ABFF94: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82ABFF98: 4BFFFBE1  bl 0x82abfb78
	ctx.lr = 0x82ABFF9C;
	sub_82ABFB78(ctx, base);
	// 82ABFF9C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABFFA0: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82ABFFA4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ABFFA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ABFFAC: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82ABFFB0: 419A0024  beq cr6, 0x82abffd4
	if ctx.cr[6].eq {
	pc = 0x82ABFFD4; continue 'dispatch;
	}
	// 82ABFFB4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82ABFFB8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82ABFFBC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ABFFC0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82ABFFC4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ABFFC8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82ABFFCC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ABFFD0: 4082FFE8  bne 0x82abffb8
	if !ctx.cr[0].eq {
	pc = 0x82ABFFB8; continue 'dispatch;
	}
	// 82ABFFD4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ABFFD8: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82ABFFDC: 4BA4F4ED  bl 0x8250f4c8
	ctx.lr = 0x82ABFFE0;
	sub_8250F4C8(ctx, base);
	// 82ABFFE0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ABFFE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ABFFE8: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82ABFFEC: 409A0008  bne cr6, 0x82abfff4
	if !ctx.cr[6].eq {
	pc = 0x82ABFFF4; continue 'dispatch;
	}
	// 82ABFFF0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ABFFF4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82ABFFF8: 3BC10070  addi r30, r1, 0x70
	ctx.r[30].s64 = ctx.r[1].s64 + 112;
	// 82ABFFFC: 4BA48A1D  bl 0x82508a18
	ctx.lr = 0x82AC0000;
	sub_82508A18(ctx, base);
	// 82AC0000: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AC0004: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82AC0008: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82AC000C: 388A9018  addi r4, r10, -0x6fe8
	ctx.r[4].s64 = ctx.r[10].s64 + -28648;
	// 82AC0010: 38A0005A  li r5, 0x5a
	ctx.r[5].s64 = 90;
	// 82AC0014: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82AC0018: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC001C: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82AC0020: 48398A21  bl 0x82e58a40
	ctx.lr = 0x82AC0024;
	sub_82E58A40(ctx, base);
	// 82AC0024: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82AC0028: 48331C69  bl 0x82df1c90
	ctx.lr = 0x82AC002C;
	sub_82DF1C90(ctx, base);
	// 82AC002C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82AC0030: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC0034: 419A0008  beq cr6, 0x82ac003c
	if ctx.cr[6].eq {
	pc = 0x82AC003C; continue 'dispatch;
	}
	// 82AC0038: 4B800859  bl 0x822c0890
	ctx.lr = 0x82AC003C;
	sub_822C0890(ctx, base);
	// 82AC003C: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82AC0040: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC0044: 419A0008  beq cr6, 0x82ac004c
	if ctx.cr[6].eq {
	pc = 0x82AC004C; continue 'dispatch;
	}
	// 82AC0048: 4B800849  bl 0x822c0890
	ctx.lr = 0x82AC004C;
	sub_822C0890(ctx, base);
	// 82AC004C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AC0050: 486945B1  bl 0x83154600
	ctx.lr = 0x82AC0054;
	sub_83154600(ctx, base);
	// 82AC0054: 4BF52E65  bl 0x82a12eb8
	ctx.lr = 0x82AC0058;
	sub_82A12EB8(ctx, base);
	// 82AC0058: 38800014  li r4, 0x14
	ctx.r[4].s64 = 20;
	// 82AC005C: 4BFFA33D  bl 0x82aba398
	ctx.lr = 0x82AC0060;
	sub_82ABA398(ctx, base);
	// 82AC0060: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AC0064: 917C0070  stw r11, 0x70(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82AC0068: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AC006C: 4839970D  bl 0x82e59778
	ctx.lr = 0x82AC0070;
	sub_82E59778(ctx, base);
	// 82AC0070: C01C0074  lfs f0, 0x74(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC0074: EC000828  fsubs f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 82AC0078: D01C0074  stfs f0, 0x74(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82AC007C: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82AC0080: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82AC0084: 486E8130  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC0088(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC0088 size=40
    let mut pc: u32 = 0x82AC0088;
    'dispatch: loop {
        match pc {
            0x82AC0088 => {
    //   block [0x82AC0088..0x82AC00B0)
	// 82AC0088: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC008C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC0090: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC0094: 4869456D  bl 0x83154600
	ctx.lr = 0x82AC0098;
	sub_83154600(ctx, base);
	// 82AC0098: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AC009C: 4BFF0DCD  bl 0x82ab0e68
	ctx.lr = 0x82AC00A0;
	sub_82AB0E68(ctx, base);
	// 82AC00A0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AC00A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC00A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC00AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC00B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC00B0 size=152
    let mut pc: u32 = 0x82AC00B0;
    'dispatch: loop {
        match pc {
            0x82AC00B0 => {
    //   block [0x82AC00B0..0x82AC0148)
	// 82AC00B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC00B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC00B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC00BC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC00C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC00C4: 4869453D  bl 0x83154600
	ctx.lr = 0x82AC00C8;
	sub_83154600(ctx, base);
	// 82AC00C8: 4BFF0EA1  bl 0x82ab0f68
	ctx.lr = 0x82AC00CC;
	sub_82AB0F68(ctx, base);
	// 82AC00CC: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 82AC00D0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC00D4: 419A0044  beq cr6, 0x82ac0118
	if ctx.cr[6].eq {
	pc = 0x82AC0118; continue 'dispatch;
	}
	// 82AC00D8: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 82AC00DC: 419A0020  beq cr6, 0x82ac00fc
	if ctx.cr[6].eq {
	pc = 0x82AC00FC; continue 'dispatch;
	}
	// 82AC00E0: 394B9074  addi r10, r11, -0x6f8c
	ctx.r[10].s64 = ctx.r[11].s64 + -28556;
	// 82AC00E4: 816B9074  lwz r11, -0x6f8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28556 as u32) ) } as u64;
	// 82AC00E8: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82AC00EC: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AC00F0: 917F0078  stw r11, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82AC00F4: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AC00F8: 48000038  b 0x82ac0130
	pc = 0x82AC0130; continue 'dispatch;
	// 82AC00FC: 396B9074  addi r11, r11, -0x6f8c
	ctx.r[11].s64 = ctx.r[11].s64 + -28556;
	// 82AC0100: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82AC0104: 915F0074  stw r10, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 82AC0108: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82AC010C: 915F0078  stw r10, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 82AC0110: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82AC0114: 4800001C  b 0x82ac0130
	pc = 0x82AC0130; continue 'dispatch;
	// 82AC0118: 396B9074  addi r11, r11, -0x6f8c
	ctx.r[11].s64 = ctx.r[11].s64 + -28556;
	// 82AC011C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AC0120: 915F0074  stw r10, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 82AC0124: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82AC0128: 915F0078  stw r10, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 82AC012C: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82AC0130: 917F007C  stw r11, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82AC0134: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AC0138: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC013C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC0140: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC0144: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC0148(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC0148 size=140
    let mut pc: u32 = 0x82AC0148;
    'dispatch: loop {
        match pc {
            0x82AC0148 => {
    //   block [0x82AC0148..0x82AC01D4)
	// 82AC0148: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC014C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC0150: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC0154: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC0158: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC015C: 4BFFEC3D  bl 0x82abed98
	ctx.lr = 0x82AC0160;
	sub_82ABED98(ctx, base);
	// 82AC0160: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82AC0164: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 82AC0168: 390A9074  addi r8, r10, -0x6f8c
	ctx.r[8].s64 = ctx.r[10].s64 + -28556;
	// 82AC016C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC0170: 392990B0  addi r9, r9, -0x6f50
	ctx.r[9].s64 = ctx.r[9].s64 + -28496;
	// 82AC0174: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82AC0178: 3CE08207  lis r7, -0x7df9
	ctx.r[7].s64 = -2113470464;
	// 82AC017C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AC0180: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC0184: 3887ECC4  addi r4, r7, -0x133c
	ctx.r[4].s64 = ctx.r[7].s64 + -4924;
	// 82AC0188: 814A9074  lwz r10, -0x6f8c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-28556 as u32) ) } as u64;
	// 82AC018C: 915F0074  stw r10, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 82AC0190: 81480004  lwz r10, 4(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AC0194: 915F0078  stw r10, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 82AC0198: 81480008  lwz r10, 8(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AC019C: 997F0080  stb r11, 0x80(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[11].u8 ) };
	// 82AC01A0: 915F007C  stw r10, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[10].u32 ) };
	// 82AC01A4: 48333865  bl 0x82df3a08
	ctx.lr = 0x82AC01A8;
	sub_82DF3A08(ctx, base);
	// 82AC01A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC01AC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AC01B0: 48399539  bl 0x82e596e8
	ctx.lr = 0x82AC01B4;
	sub_82E596E8(ctx, base);
	// 82AC01B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC01B8: 48333271  bl 0x82df3428
	ctx.lr = 0x82AC01BC;
	sub_82DF3428(ctx, base);
	// 82AC01BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC01C0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC01C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC01C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC01CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC01D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC01D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC01D8 size=192
    let mut pc: u32 = 0x82AC01D8;
    'dispatch: loop {
        match pc {
            0x82AC01D8 => {
    //   block [0x82AC01D8..0x82AC0298)
	// 82AC01D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC01DC: 486E7F91  bl 0x831a816c
	ctx.lr = 0x82AC01E0;
	sub_831A8130(ctx, base);
	// 82AC01E0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC01E4: 4869441D  bl 0x83154600
	ctx.lr = 0x82AC01E8;
	sub_83154600(ctx, base);
	// 82AC01E8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AC01EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC01F0: 48009A49  bl 0x82ac9c38
	ctx.lr = 0x82AC01F4;
	sub_82AC9C38(ctx, base);
	// 82AC01F4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AC01F8: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AC01FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC0200: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82AC0204: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82AC0208: 419A0024  beq cr6, 0x82ac022c
	if ctx.cr[6].eq {
	pc = 0x82AC022C; continue 'dispatch;
	}
	// 82AC020C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AC0210: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AC0214: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AC0218: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AC021C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AC0220: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AC0224: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AC0228: 4082FFE8  bne 0x82ac0210
	if !ctx.cr[0].eq {
	pc = 0x82AC0210; continue 'dispatch;
	}
	// 82AC022C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AC0230: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AC0234: 4BA4F295  bl 0x8250f4c8
	ctx.lr = 0x82AC0238;
	sub_8250F4C8(ctx, base);
	// 82AC0238: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC023C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC0240: 3BEBFFFC  addi r31, r11, -4
	ctx.r[31].s64 = ctx.r[11].s64 + -4;
	// 82AC0244: 409A0008  bne cr6, 0x82ac024c
	if !ctx.cr[6].eq {
	pc = 0x82AC024C; continue 'dispatch;
	}
	// 82AC0248: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AC024C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AC0250: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82AC0254: 3BA10058  addi r29, r1, 0x58
	ctx.r[29].s64 = ctx.r[1].s64 + 88;
	// 82AC0258: 4BA4F2C1  bl 0x8250f518
	ctx.lr = 0x82AC025C;
	sub_8250F518(ctx, base);
	// 82AC025C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AC0260: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC0264: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82AC0268: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82AC026C: 4BA4D29D  bl 0x8250d508
	ctx.lr = 0x82AC0270;
	sub_8250D508(ctx, base);
	// 82AC0270: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AC0274: 48331A1D  bl 0x82df1c90
	ctx.lr = 0x82AC0278;
	sub_82DF1C90(ctx, base);
	// 82AC0278: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82AC027C: 48331A15  bl 0x82df1c90
	ctx.lr = 0x82AC0280;
	sub_82DF1C90(ctx, base);
	// 82AC0280: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AC0284: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC0288: 419A0008  beq cr6, 0x82ac0290
	if ctx.cr[6].eq {
	pc = 0x82AC0290; continue 'dispatch;
	}
	// 82AC028C: 4B800605  bl 0x822c0890
	ctx.lr = 0x82AC0290;
	sub_822C0890(ctx, base);
	// 82AC0290: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82AC0294: 486E7F28  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC0298(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC0298 size=224
    let mut pc: u32 = 0x82AC0298;
    'dispatch: loop {
        match pc {
            0x82AC0298 => {
    //   block [0x82AC0298..0x82AC0378)
	// 82AC0298: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC029C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC02A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC02A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC02A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC02AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC02B0: 9081009C  stw r4, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[4].u32 ) };
	// 82AC02B4: 48008C3D  bl 0x82ac8ef0
	ctx.lr = 0x82AC02B8;
	sub_82AC8EF0(ctx, base);
	// 82AC02B8: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82AC02BC: 4082000C  bne 0x82ac02c8
	if !ctx.cr[0].eq {
	pc = 0x82AC02C8; continue 'dispatch;
	}
	// 82AC02C0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AC02C4: 4800009C  b 0x82ac0360
	pc = 0x82AC0360; continue 'dispatch;
	// 82AC02C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC02CC: 48694335  bl 0x83154600
	ctx.lr = 0x82AC02D0;
	sub_83154600(ctx, base);
	// 82AC02D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC02D4: 3881009C  addi r4, r1, 0x9c
	ctx.r[4].s64 = ctx.r[1].s64 + 156;
	// 82AC02D8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AC02DC: 4BFB79CD  bl 0x82a77ca8
	ctx.lr = 0x82AC02E0;
	sub_82A77CA8(ctx, base);
	// 82AC02E0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC02E4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82AC02E8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AC02EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC02F0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AC02F4: 419A0024  beq cr6, 0x82ac0318
	if ctx.cr[6].eq {
	pc = 0x82AC0318; continue 'dispatch;
	}
	// 82AC02F8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AC02FC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AC0300: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AC0304: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AC0308: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AC030C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AC0310: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AC0314: 4082FFE8  bne 0x82ac02fc
	if !ctx.cr[0].eq {
	pc = 0x82AC02FC; continue 'dispatch;
	}
	// 82AC0318: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AC031C: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82AC0320: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82AC0324: 388A90D8  addi r4, r10, -0x6f28
	ctx.r[4].s64 = ctx.r[10].s64 + -28456;
	// 82AC0328: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82AC032C: 38A00124  li r5, 0x124
	ctx.r[5].s64 = 292;
	// 82AC0330: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC0334: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82AC0338: 48398709  bl 0x82e58a40
	ctx.lr = 0x82AC033C;
	sub_82E58A40(ctx, base);
	// 82AC033C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AC0340: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC0344: 419A0008  beq cr6, 0x82ac034c
	if ctx.cr[6].eq {
	pc = 0x82AC034C; continue 'dispatch;
	}
	// 82AC0348: 4B800549  bl 0x822c0890
	ctx.lr = 0x82AC034C;
	sub_822C0890(ctx, base);
	// 82AC034C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AC0350: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC0354: 419A0008  beq cr6, 0x82ac035c
	if ctx.cr[6].eq {
	pc = 0x82AC035C; continue 'dispatch;
	}
	// 82AC0358: 4B800539  bl 0x822c0890
	ctx.lr = 0x82AC035C;
	sub_822C0890(ctx, base);
	// 82AC035C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82AC0360: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AC0364: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC0368: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC036C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AC0370: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC0374: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC0378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC0378 size=808
    let mut pc: u32 = 0x82AC0378;
    'dispatch: loop {
        match pc {
            0x82AC0378 => {
    //   block [0x82AC0378..0x82AC06A0)
	// 82AC0378: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC037C: 486E7DE9  bl 0x831a8164
	ctx.lr = 0x82AC0380;
	sub_831A8130(ctx, base);
	// 82AC0380: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82AC0384: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC0388: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC038C: 48694275  bl 0x83154600
	ctx.lr = 0x82AC0390;
	sub_83154600(ctx, base);
	// 82AC0390: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AC0394: 4BD2BE45  bl 0x827ec1d8
	ctx.lr = 0x82AC0398;
	sub_827EC1D8(ctx, base);
	// 82AC0398: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82AC039C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC03A0: 4BF52B19  bl 0x82a12eb8
	ctx.lr = 0x82AC03A4;
	sub_82A12EB8(ctx, base);
	// 82AC03A4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC03A8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AC03AC: 3B6B9070  addi r27, r11, -0x6f90
	ctx.r[27].s64 = ctx.r[11].s64 + -28560;
	// 82AC03B0: 817F0070  lwz r11, 0x70(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82AC03B4: 2B0B0009  cmplwi cr6, r11, 9
	ctx.cr[6].compare_u32(ctx.r[11].u32, 9 as u32, &mut ctx.xer);
	// 82AC03B8: 419902BC  bgt cr6, 0x82ac0674
	if ctx.cr[6].gt {
	pc = 0x82AC0674; continue 'dispatch;
	}
	// 82AC03BC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AC03C0: C3EA08A4  lfs f31, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82AC03C4: 3D80820C  lis r12, -0x7df4
	ctx.r[12].s64 = -2113142784;
	// 82AC03C8: 398C90A0  addi r12, r12, -0x6f60
	ctx.r[12].s64 = ctx.r[12].s64 + -28512;
	// 82AC03CC: 7C0C58AE  lbzx r0, r12, r11
	ctx.r[0].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82AC03D0: 5400103A  slwi r0, r0, 2
	ctx.r[0].u32 = ctx.r[0].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 82AC03D4: 3D8082AC  lis r12, -0x7d54
	ctx.r[12].s64 = -2102657024;
	// 82AC03D8: 398C03EC  addi r12, r12, 0x3ec
	ctx.r[12].s64 = ctx.r[12].s64 + 1004;
	// 82AC03DC: 7D8C0214  add r12, r12, r0
	ctx.r[12].u64 = ctx.r[12].u64 + ctx.r[0].u64;
	// 82AC03E0: 7D8903A6  mtctr r12
	ctx.ctr.u64 = ctx.r[12].u64;
	// 82AC03E4: 60000000  nop
	// 82AC03E8: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
	// 82AC03EC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AC03F0: 4BFA38E1  bl 0x82a63cd0
	ctx.lr = 0x82AC03F4;
	sub_82A63CD0(ctx, base);
	// 82AC03F4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AC03F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC03FC: 4BFF0A6D  bl 0x82ab0e68
	ctx.lr = 0x82AC0400;
	sub_82AB0E68(ctx, base);
	// 82AC0400: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 82AC0404: 3880001F  li r4, 0x1f
	ctx.r[4].s64 = 31;
	// 82AC0408: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC040C: 4BFF0DE5  bl 0x82ab11f0
	ctx.lr = 0x82AC0410;
	sub_82AB11F0(ctx, base);
	// 82AC0410: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AC0414: 997F0080  stb r11, 0x80(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[11].u8 ) };
	// 82AC0418: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82AC041C: 48000258  b 0x82ac0674
	pc = 0x82AC0674; continue 'dispatch;
	// 82AC0420: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC0424: 4BFFFDB5  bl 0x82ac01d8
	ctx.lr = 0x82AC0428;
	sub_82AC01D8(ctx, base);
	// 82AC0428: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC042C: 4BFFFC85  bl 0x82ac00b0
	ctx.lr = 0x82AC0430;
	sub_82AC00B0(ctx, base);
	// 82AC0430: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82AC0434: 4BFFFFE4  b 0x82ac0418
	pc = 0x82AC0418; continue 'dispatch;
	// 82AC0438: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AC043C: C03B0000  lfs f1, 0(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC0440: 38800009  li r4, 9
	ctx.r[4].s64 = 9;
	// 82AC0444: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC0448: C04B08A4  lfs f2, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82AC044C: 4BFF9BC5  bl 0x82aba010
	ctx.lr = 0x82AC0450;
	sub_82ABA010(ctx, base);
	// 82AC0450: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AC0454: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC0458: 4BFFFE41  bl 0x82ac0298
	ctx.lr = 0x82AC045C;
	sub_82AC0298(ctx, base);
	// 82AC045C: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82AC0460: 4BFFFFB8  b 0x82ac0418
	pc = 0x82AC0418; continue 'dispatch;
	// 82AC0464: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC0468: 4BA97659  bl 0x82557ac0
	ctx.lr = 0x82AC046C;
	sub_82557AC0(ctx, base);
	// 82AC046C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC0470: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AC0474: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC0478: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82AC047C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AC0480: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82AC0484: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AC0488: 4E800421  bctrl
	ctx.lr = 0x82AC048C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AC048C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC0490: 41820020  beq 0x82ac04b0
	if ctx.cr[0].eq {
	pc = 0x82AC04B0; continue 'dispatch;
	}
	// 82AC0494: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 82AC0498: C03B0000  lfs f1, 0(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC049C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC04A0: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82AC04A4: 4BFF9B6D  bl 0x82aba010
	ctx.lr = 0x82AC04A8;
	sub_82ABA010(ctx, base);
	// 82AC04A8: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82AC04AC: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82AC04B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC04B4: 483992C5  bl 0x82e59778
	ctx.lr = 0x82AC04B8;
	sub_82E59778(ctx, base);
	// 82AC04B8: C01F0074  lfs f0, 0x74(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC04BC: EC000828  fsubs f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 82AC04C0: D01F0074  stfs f0, 0x74(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82AC04C4: 480001B0  b 0x82ac0674
	pc = 0x82AC0674; continue 'dispatch;
	// 82AC04C8: C01F0074  lfs f0, 0x74(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC04CC: C1BB0000  lfs f13, 0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AC04D0: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82AC04D4: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82AC04D8: 41990018  bgt cr6, 0x82ac04f0
	if ctx.cr[6].gt {
	pc = 0x82AC04F0; continue 'dispatch;
	}
	// 82AC04DC: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82AC04E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC04E4: 4BFFFDB5  bl 0x82ac0298
	ctx.lr = 0x82AC04E8;
	sub_82AC0298(ctx, base);
	// 82AC04E8: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 82AC04EC: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82AC04F0: C01F0074  lfs f0, 0x74(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC04F4: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82AC04F8: 4199FFB8  bgt cr6, 0x82ac04b0
	if ctx.cr[6].gt {
	pc = 0x82AC04B0; continue 'dispatch;
	}
	// 82AC04FC: 3880000C  li r4, 0xc
	ctx.r[4].s64 = 12;
	// 82AC0500: C03B0000  lfs f1, 0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC0504: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC0508: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82AC050C: 4BFF9B05  bl 0x82aba010
	ctx.lr = 0x82AC0510;
	sub_82ABA010(ctx, base);
	// 82AC0510: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82AC0514: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC0518: 4BFFFD81  bl 0x82ac0298
	ctx.lr = 0x82AC051C;
	sub_82AC0298(ctx, base);
	// 82AC051C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC0520: 39400006  li r10, 6
	ctx.r[10].s64 = 6;
	// 82AC0524: 997F0080  stb r11, 0x80(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[11].u8 ) };
	// 82AC0528: 915F0070  stw r10, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 82AC052C: 4BFFFF84  b 0x82ac04b0
	pc = 0x82AC04B0; continue 'dispatch;
	// 82AC0530: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC0534: 4BA9758D  bl 0x82557ac0
	ctx.lr = 0x82AC0538;
	sub_82557AC0(ctx, base);
	// 82AC0538: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC053C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AC0540: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC0544: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82AC0548: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AC054C: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82AC0550: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AC0554: 4E800421  bctrl
	ctx.lr = 0x82AC0558;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AC0558: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82AC055C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82AC0560: 409A0114  bne cr6, 0x82ac0674
	if !ctx.cr[6].eq {
	pc = 0x82AC0674; continue 'dispatch;
	}
	// 82AC0564: 3880000B  li r4, 0xb
	ctx.r[4].s64 = 11;
	// 82AC0568: C03B0000  lfs f1, 0(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC056C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC0570: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82AC0574: 4BFF9A9D  bl 0x82aba010
	ctx.lr = 0x82AC0578;
	sub_82ABA010(ctx, base);
	// 82AC0578: 39600007  li r11, 7
	ctx.r[11].s64 = 7;
	// 82AC057C: 4BFFFE9C  b 0x82ac0418
	pc = 0x82AC0418; continue 'dispatch;
	// 82AC0580: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AC0584: C01F0078  lfs f0, 0x78(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC0588: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82AC058C: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82AC0590: 4199002C  bgt cr6, 0x82ac05bc
	if ctx.cr[6].gt {
	pc = 0x82AC05BC; continue 'dispatch;
	}
	// 82AC0594: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82AC0598: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC059C: 4BFFFCFD  bl 0x82ac0298
	ctx.lr = 0x82AC05A0;
	sub_82AC0298(ctx, base);
	// 82AC05A0: 3880000A  li r4, 0xa
	ctx.r[4].s64 = 10;
	// 82AC05A4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC05A8: C03B0000  lfs f1, 0(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC05AC: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82AC05B0: 4BFF9A61  bl 0x82aba010
	ctx.lr = 0x82AC05B4;
	sub_82ABA010(ctx, base);
	// 82AC05B4: 39600009  li r11, 9
	ctx.r[11].s64 = 9;
	// 82AC05B8: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82AC05BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC05C0: 483991B9  bl 0x82e59778
	ctx.lr = 0x82AC05C4;
	sub_82E59778(ctx, base);
	// 82AC05C4: C01F0078  lfs f0, 0x78(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC05C8: EC000828  fsubs f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 82AC05CC: D01F0078  stfs f0, 0x78(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82AC05D0: 480000A4  b 0x82ac0674
	pc = 0x82AC0674; continue 'dispatch;
	// 82AC05D4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC05D8: 4BA974E9  bl 0x82557ac0
	ctx.lr = 0x82AC05DC;
	sub_82557AC0(ctx, base);
	// 82AC05DC: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC05E0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AC05E4: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC05E8: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82AC05EC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AC05F0: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82AC05F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AC05F8: 4E800421  bctrl
	ctx.lr = 0x82AC05FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AC05FC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82AC0600: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82AC0604: 409A0070  bne cr6, 0x82ac0674
	if !ctx.cr[6].eq {
	pc = 0x82AC0674; continue 'dispatch;
	}
	// 82AC0608: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AC060C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC0610: 4BFF0859  bl 0x82ab0e68
	ctx.lr = 0x82AC0614;
	sub_82AB0E68(ctx, base);
	// 82AC0614: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AC0618: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC061C: C03B0000  lfs f1, 0(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC0620: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82AC0624: 4BFF99ED  bl 0x82aba010
	ctx.lr = 0x82AC0628;
	sub_82ABA010(ctx, base);
	// 82AC0628: 39600008  li r11, 8
	ctx.r[11].s64 = 8;
	// 82AC062C: 4BFFFDEC  b 0x82ac0418
	pc = 0x82AC0418; continue 'dispatch;
	// 82AC0630: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AC0634: C1BF007C  lfs f13, 0x7c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AC0638: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC063C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82AC0640: 41990020  bgt cr6, 0x82ac0660
	if ctx.cr[6].gt {
	pc = 0x82AC0660; continue 'dispatch;
	}
	// 82AC0644: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 82AC0648: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC064C: 4BFFFC4D  bl 0x82ac0298
	ctx.lr = 0x82AC0650;
	sub_82AC0298(ctx, base);
	// 82AC0650: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AC0654: 4BFA368D  bl 0x82a63ce0
	ctx.lr = 0x82AC0658;
	sub_82A63CE0(ctx, base);
	// 82AC0658: 3960000A  li r11, 0xa
	ctx.r[11].s64 = 10;
	// 82AC065C: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82AC0660: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC0664: 48399115  bl 0x82e59778
	ctx.lr = 0x82AC0668;
	sub_82E59778(ctx, base);
	// 82AC0668: C01F007C  lfs f0, 0x7c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC066C: EC000828  fsubs f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 82AC0670: D01F007C  stfs f0, 0x7c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82AC0674: 897F0080  lbz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82AC0678: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC067C: 41820018  beq 0x82ac0694
	if ctx.cr[0].eq {
	pc = 0x82AC0694; continue 'dispatch;
	}
	// 82AC0680: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC0684: 48693F7D  bl 0x83154600
	ctx.lr = 0x82AC0688;
	sub_83154600(ctx, base);
	// 82AC0688: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AC068C: C03B0028  lfs f1, 0x28(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC0690: 4BFF7451  bl 0x82ab7ae0
	ctx.lr = 0x82AC0694;
	sub_82AB7AE0(ctx, base);
	// 82AC0694: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82AC0698: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82AC069C: 486E7B18  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC06A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AC06A0 size=16
    let mut pc: u32 = 0x82AC06A0;
    'dispatch: loop {
        match pc {
            0x82AC06A0 => {
    //   block [0x82AC06A0..0x82AC06B0)
	// 82AC06A0: 2F040009  cmpwi cr6, r4, 9
	ctx.cr[6].compare_i32(ctx.r[4].s32, 9, &mut ctx.xer);
	// 82AC06A4: 4198000C  blt cr6, 0x82ac06b0
	if ctx.cr[6].lt {
		sub_82AC06B0(ctx, base);
		return;
	}
	// 82AC06A8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AC06AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC06B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AC06B0 size=60
    let mut pc: u32 = 0x82AC06B0;
    'dispatch: loop {
        match pc {
            0x82AC06B0 => {
    //   block [0x82AC06B0..0x82AC06EC)
	// 82AC06B0: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82AC06B4: 90830070  stw r4, 0x70(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(112 as u32), ctx.r[4].u32 ) };
	// 82AC06B8: 1D640014  mulli r11, r4, 0x14
	ctx.r[11].s64 = ctx.r[4].s64 * 20;
	// 82AC06BC: 394A9130  addi r10, r10, -0x6ed0
	ctx.r[10].s64 = ctx.r[10].s64 + -28368;
	// 82AC06C0: 39230078  addi r9, r3, 0x78
	ctx.r[9].s64 = ctx.r[3].s64 + 120;
	// 82AC06C4: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82AC06C8: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 82AC06CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AC06D0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC06D4: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82AC06D8: 91690000  stw r11, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC06DC: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82AC06E0: 4200FFF0  bdnz 0x82ac06d0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82AC06D0; continue 'dispatch;
	}
	// 82AC06E4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82AC06E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC06F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC06F0 size=76
    let mut pc: u32 = 0x82AC06F0;
    'dispatch: loop {
        match pc {
            0x82AC06F0 => {
    //   block [0x82AC06F0..0x82AC073C)
	// 82AC06F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC06F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC06F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC06FC: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC0700: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC0704: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC0708: 480DFDC1  bl 0x82ba04c8
	ctx.lr = 0x82AC070C;
	sub_82BA04C8(ctx, base);
	// 82AC070C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC0710: C1A1005C  lfs f13, 0x5c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AC0714: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC0718: D1BF0094  stfs f13, 0x94(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82AC071C: C00B91E8  lfs f0, -0x6e18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC0720: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82AC0724: 480DFDDD  bl 0x82ba0500
	ctx.lr = 0x82AC0728;
	sub_82BA0500(ctx, base);
	// 82AC0728: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AC072C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC0730: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC0734: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC0738: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC0740(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC0740 size=76
    let mut pc: u32 = 0x82AC0740;
    'dispatch: loop {
        match pc {
            0x82AC0740 => {
    //   block [0x82AC0740..0x82AC078C)
	// 82AC0740: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC0744: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC0748: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC074C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC0750: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC0754: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AC0758: 48693EA9  bl 0x83154600
	ctx.lr = 0x82AC075C;
	sub_83154600(ctx, base);
	// 82AC075C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC0760: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AC0764: 4BA4F3DD  bl 0x8250fb40
	ctx.lr = 0x82AC0768;
	sub_8250FB40(ctx, base);
	// 82AC0768: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC076C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC0770: 4BFF5411  bl 0x82ab5b80
	ctx.lr = 0x82AC0774;
	sub_82AB5B80(ctx, base);
	// 82AC0774: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC0778: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC077C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC0780: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AC0784: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC0788: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC0790(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC0790 size=128
    let mut pc: u32 = 0x82AC0790;
    'dispatch: loop {
        match pc {
            0x82AC0790 => {
    //   block [0x82AC0790..0x82AC0810)
	// 82AC0790: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC0794: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC0798: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC079C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC07A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC07A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC07A8: 817F0084  lwz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 82AC07AC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC07B0: 419A0048  beq cr6, 0x82ac07f8
	if ctx.cr[6].eq {
	pc = 0x82AC07F8; continue 'dispatch;
	}
	// 82AC07B4: 897F0088  lbz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82AC07B8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC07BC: 4182003C  beq 0x82ac07f8
	if ctx.cr[0].eq {
	pc = 0x82AC07F8; continue 'dispatch;
	}
	// 82AC07C0: 48693E41  bl 0x83154600
	ctx.lr = 0x82AC07C4;
	sub_83154600(ctx, base);
	// 82AC07C4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AC07C8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AC07CC: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC07D0: 4BFF02F1  bl 0x82ab0ac0
	ctx.lr = 0x82AC07D4;
	sub_82AB0AC0(ctx, base);
	// 82AC07D4: 817F0084  lwz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 82AC07D8: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82AC07DC: 409A001C  bne cr6, 0x82ac07f8
	if !ctx.cr[6].eq {
	pc = 0x82AC07F8; continue 'dispatch;
	}
	// 82AC07E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC07E4: 4BFF02E5  bl 0x82ab0ac8
	ctx.lr = 0x82AC07E8;
	sub_82AB0AC8(ctx, base);
	// 82AC07E8: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82AC07EC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82AC07F0: 917F0084  stw r11, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82AC07F4: 995F0074  stb r10, 0x74(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[10].u8 ) };
	// 82AC07F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC07FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC0800: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC0804: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AC0808: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC080C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC0810(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC0810 size=108
    let mut pc: u32 = 0x82AC0810;
    'dispatch: loop {
        match pc {
            0x82AC0810 => {
    //   block [0x82AC0810..0x82AC087C)
	// 82AC0810: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC0814: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC0818: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC081C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC0820: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC0824: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC0828: 48693DD9  bl 0x83154600
	ctx.lr = 0x82AC082C;
	sub_83154600(ctx, base);
	// 82AC082C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AC0830: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AC0834: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC0838: 4BFF0289  bl 0x82ab0ac0
	ctx.lr = 0x82AC083C;
	sub_82AB0AC0(ctx, base);
	// 82AC083C: 897F0074  lbz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82AC0840: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC0844: 41820020  beq 0x82ac0864
	if ctx.cr[0].eq {
	pc = 0x82AC0864; continue 'dispatch;
	}
	// 82AC0848: 817F0084  lwz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 82AC084C: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82AC0850: 419A0014  beq cr6, 0x82ac0864
	if ctx.cr[6].eq {
	pc = 0x82AC0864; continue 'dispatch;
	}
	// 82AC0854: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC0858: 4BFF0271  bl 0x82ab0ac8
	ctx.lr = 0x82AC085C;
	sub_82AB0AC8(ctx, base);
	// 82AC085C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC0860: 997F0074  stb r11, 0x74(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u8 ) };
	// 82AC0864: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC0868: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC086C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC0870: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AC0874: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC0878: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC0880(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC0880 size=64
    let mut pc: u32 = 0x82AC0880;
    'dispatch: loop {
        match pc {
            0x82AC0880 => {
    //   block [0x82AC0880..0x82AC08C0)
	// 82AC0880: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC0884: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC0888: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC088C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC0890: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC0894: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC0898: 480DFC31  bl 0x82ba04c8
	ctx.lr = 0x82AC089C;
	sub_82BA04C8(ctx, base);
	// 82AC089C: C01F0094  lfs f0, 0x94(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC08A0: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82AC08A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC08A8: 480DFC59  bl 0x82ba0500
	ctx.lr = 0x82AC08AC;
	sub_82BA0500(ctx, base);
	// 82AC08AC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AC08B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC08B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC08B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC08BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC08C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC08C0 size=196
    let mut pc: u32 = 0x82AC08C0;
    'dispatch: loop {
        match pc {
            0x82AC08C0 => {
    //   block [0x82AC08C0..0x82AC0984)
	// 82AC08C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC08C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC08C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC08CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC08D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC08D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC08D8: 4BFFE4C1  bl 0x82abed98
	ctx.lr = 0x82AC08DC;
	sub_82ABED98(ctx, base);
	// 82AC08DC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AC08E0: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82AC08E4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82AC08E8: 394A920C  addi r10, r10, -0x6df4
	ctx.r[10].s64 = ctx.r[10].s64 + -28148;
	// 82AC08EC: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82AC08F0: 93DF0070  stw r30, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82AC08F4: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC08F8: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82AC08FC: D01F008C  stfs f0, 0x8c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82AC0900: 993F0074  stb r9, 0x74(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[9].u8 ) };
	// 82AC0904: D01F0094  stfs f0, 0x94(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82AC0908: 9BDF0090  stb r30, 0x90(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[30].u8 ) };
	// 82AC090C: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82AC0910: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC0914: 388B31AC  addi r4, r11, 0x31ac
	ctx.r[4].s64 = ctx.r[11].s64 + 12716;
	// 82AC0918: 483330F1  bl 0x82df3a08
	ctx.lr = 0x82AC091C;
	sub_82DF3A08(ctx, base);
	// 82AC091C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AC0920: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC0924: 48398DC5  bl 0x82e596e8
	ctx.lr = 0x82AC0928;
	sub_82E596E8(ctx, base);
	// 82AC0928: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC092C: 48332AFD  bl 0x82df3428
	ctx.lr = 0x82AC0930;
	sub_82DF3428(ctx, base);
	// 82AC0930: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AC0934: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC0938: 4BFFE3B9  bl 0x82abecf0
	ctx.lr = 0x82AC093C;
	sub_82ABECF0(ctx, base);
	// 82AC093C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC0940: 395F0078  addi r10, r31, 0x78
	ctx.r[10].s64 = ctx.r[31].s64 + 120;
	// 82AC0944: 93DF0070  stw r30, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82AC0948: 396B9130  addi r11, r11, -0x6ed0
	ctx.r[11].s64 = ctx.r[11].s64 + -28368;
	// 82AC094C: 39200005  li r9, 5
	ctx.r[9].s64 = 5;
	// 82AC0950: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82AC0954: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC0958: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AC095C: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AC0960: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82AC0964: 4200FFF0  bdnz 0x82ac0954
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82AC0954; continue 'dispatch;
	}
	// 82AC0968: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC096C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC0970: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC0974: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC0978: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AC097C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC0980: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC0988(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC0988 size=132
    let mut pc: u32 = 0x82AC0988;
    'dispatch: loop {
        match pc {
            0x82AC0988 => {
    //   block [0x82AC0988..0x82AC0A0C)
	// 82AC0988: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC098C: 486E77D9  bl 0x831a8164
	ctx.lr = 0x82AC0990;
	sub_831A8130(ctx, base);
	// 82AC0990: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC0994: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC0998: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AC099C: 48693C65  bl 0x83154600
	ctx.lr = 0x82AC09A0;
	sub_83154600(ctx, base);
	// 82AC09A0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AC09A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC09A8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AC09AC: 4BFF23F5  bl 0x82ab2da0
	ctx.lr = 0x82AC09B0;
	sub_82AB2DA0(ctx, base);
	// 82AC09B0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AC09B4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AC09B8: 83810050  lwz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AC09BC: 4BA4EB0D  bl 0x8250f4c8
	ctx.lr = 0x82AC09C0;
	sub_8250F4C8(ctx, base);
	// 82AC09C0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82AC09C4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AC09C8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AC09CC: 4BFF1805  bl 0x82ab21d0
	ctx.lr = 0x82AC09D0;
	sub_82AB21D0(ctx, base);
	// 82AC09D0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82AC09D4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82AC09D8: 809F0070  lwz r4, 0x70(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82AC09DC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AC09E0: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82AC09E4: 4BFFB765  bl 0x82abc148
	ctx.lr = 0x82AC09E8;
	sub_82ABC148(ctx, base);
	// 82AC09E8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AC09EC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AC09F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC09F4: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC09F8: D01F008C  stfs f0, 0x8c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82AC09FC: 419A0008  beq cr6, 0x82ac0a04
	if ctx.cr[6].eq {
	pc = 0x82AC0A04; continue 'dispatch;
	}
	// 82AC0A00: 4B7FFE91  bl 0x822c0890
	ctx.lr = 0x82AC0A04;
	sub_822C0890(ctx, base);
	// 82AC0A04: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82AC0A08: 486E77AC  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC0A10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC0A10 size=300
    let mut pc: u32 = 0x82AC0A10;
    'dispatch: loop {
        match pc {
            0x82AC0A10 => {
    //   block [0x82AC0A10..0x82AC0B3C)
	// 82AC0A10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC0A14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC0A18: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC0A1C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC0A20: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82AC0A24: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC0A28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC0A2C: 817F0084  lwz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 82AC0A30: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC0A34: 419A00EC  beq cr6, 0x82ac0b20
	if ctx.cr[6].eq {
	pc = 0x82AC0B20; continue 'dispatch;
	}
	// 82AC0A38: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AC0A3C: C01F0078  lfs f0, 0x78(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC0A40: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82AC0A44: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82AC0A48: 40990018  ble cr6, 0x82ac0a60
	if !ctx.cr[6].gt {
	pc = 0x82AC0A60; continue 'dispatch;
	}
	// 82AC0A4C: 48398D2D  bl 0x82e59778
	ctx.lr = 0x82AC0A50;
	sub_82E59778(ctx, base);
	// 82AC0A50: C01F0078  lfs f0, 0x78(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC0A54: EC000828  fsubs f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 82AC0A58: D01F0078  stfs f0, 0x78(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82AC0A5C: 480000C4  b 0x82ac0b20
	pc = 0x82AC0B20; continue 'dispatch;
	// 82AC0A60: 48693BA1  bl 0x83154600
	ctx.lr = 0x82AC0A64;
	sub_83154600(ctx, base);
	// 82AC0A64: 897F0088  lbz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82AC0A68: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AC0A6C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC0A70: 40820010  bne 0x82ac0a80
	if !ctx.cr[0].eq {
	pc = 0x82AC0A80; continue 'dispatch;
	}
	// 82AC0A74: 4BFF0065  bl 0x82ab0ad8
	ctx.lr = 0x82AC0A78;
	sub_82AB0AD8(ctx, base);
	// 82AC0A78: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AC0A7C: 997F0088  stb r11, 0x88(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[11].u8 ) };
	// 82AC0A80: C01F0080  lfs f0, 0x80(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC0A84: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82AC0A88: 41990010  bgt cr6, 0x82ac0a98
	if ctx.cr[6].gt {
	pc = 0x82AC0A98; continue 'dispatch;
	}
	// 82AC0A8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC0A90: 4BFFFD81  bl 0x82ac0810
	ctx.lr = 0x82AC0A94;
	sub_82AC0810(ctx, base);
	// 82AC0A94: 48000040  b 0x82ac0ad4
	pc = 0x82AC0AD4; continue 'dispatch;
	// 82AC0A98: C01F007C  lfs f0, 0x7c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC0A9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC0AA0: C1BF008C  lfs f13, 0x8c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AC0AA4: EC20682A  fadds f1, f0, f13
	ctx.f[1].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82AC0AA8: 4BFF0019  bl 0x82ab0ac0
	ctx.lr = 0x82AC0AAC;
	sub_82AB0AC0(ctx, base);
	// 82AC0AAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC0AB0: 48398CC9  bl 0x82e59778
	ctx.lr = 0x82AC0AB4;
	sub_82E59778(ctx, base);
	// 82AC0AB4: C01F0080  lfs f0, 0x80(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC0AB8: EC000828  fsubs f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 82AC0ABC: D01F0080  stfs f0, 0x80(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82AC0AC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC0AC4: 48398CB5  bl 0x82e59778
	ctx.lr = 0x82AC0AC8;
	sub_82E59778(ctx, base);
	// 82AC0AC8: C01F008C  lfs f0, 0x8c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC0ACC: EC01002A  fadds f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 82AC0AD0: D01F008C  stfs f0, 0x8c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82AC0AD4: 817F0084  lwz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 82AC0AD8: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82AC0ADC: 409A0044  bne cr6, 0x82ac0b20
	if !ctx.cr[6].eq {
	pc = 0x82AC0B20; continue 'dispatch;
	}
	// 82AC0AE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC0AE4: 4BFF0025  bl 0x82ab0b08
	ctx.lr = 0x82AC0AE8;
	sub_82AB0B08(ctx, base);
	// 82AC0AE8: 907F0084  stw r3, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 82AC0AEC: 2F030003  cmpwi cr6, r3, 3
	ctx.cr[6].compare_i32(ctx.r[3].s32, 3, &mut ctx.xer);
	// 82AC0AF0: 409A0030  bne cr6, 0x82ac0b20
	if !ctx.cr[6].eq {
	pc = 0x82AC0B20; continue 'dispatch;
	}
	// 82AC0AF4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AC0AF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC0AFC: 4BFF22A5  bl 0x82ab2da0
	ctx.lr = 0x82AC0B00;
	sub_82AB2DA0(ctx, base);
	// 82AC0B00: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AC0B04: 4BFFAE35  bl 0x82abb938
	ctx.lr = 0x82AC0B08;
	sub_82ABB938(ctx, base);
	// 82AC0B08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC0B0C: 4BFFFD05  bl 0x82ac0810
	ctx.lr = 0x82AC0B10;
	sub_82AC0810(ctx, base);
	// 82AC0B10: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AC0B14: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC0B18: 419A0008  beq cr6, 0x82ac0b20
	if ctx.cr[6].eq {
	pc = 0x82AC0B20; continue 'dispatch;
	}
	// 82AC0B1C: 4B7FFD75  bl 0x822c0890
	ctx.lr = 0x82AC0B20;
	sub_822C0890(ctx, base);
	// 82AC0B20: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AC0B24: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC0B28: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC0B2C: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82AC0B30: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AC0B34: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC0B38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC0B40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC0B40 size=96
    let mut pc: u32 = 0x82AC0B40;
    'dispatch: loop {
        match pc {
            0x82AC0B40 => {
    //   block [0x82AC0B40..0x82AC0BA0)
	// 82AC0B40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC0B44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC0B48: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC0B4C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC0B50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC0B54: 817F0070  lwz r11, 0x70(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82AC0B58: 388B0001  addi r4, r11, 1
	ctx.r[4].s64 = ctx.r[11].s64 + 1;
	// 82AC0B5C: 4BFFFB45  bl 0x82ac06a0
	ctx.lr = 0x82AC0B60;
	sub_82AC06A0(ctx, base);
	// 82AC0B60: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC0B64: 4082000C  bne 0x82ac0b70
	if !ctx.cr[0].eq {
	pc = 0x82AC0B70; continue 'dispatch;
	}
	// 82AC0B68: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82AC0B6C: 48000020  b 0x82ac0b8c
	pc = 0x82AC0B8C; continue 'dispatch;
	// 82AC0B70: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AC0B74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC0B78: 4BFFFE11  bl 0x82ac0988
	ctx.lr = 0x82AC0B7C;
	sub_82AC0988(ctx, base);
	// 82AC0B7C: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82AC0B80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC0B84: 4BFFE16D  bl 0x82abecf0
	ctx.lr = 0x82AC0B88;
	sub_82ABECF0(ctx, base);
	// 82AC0B88: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AC0B8C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AC0B90: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC0B94: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC0B98: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC0B9C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC0BA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC0BA0 size=124
    let mut pc: u32 = 0x82AC0BA0;
    'dispatch: loop {
        match pc {
            0x82AC0BA0 => {
    //   block [0x82AC0BA0..0x82AC0C1C)
	// 82AC0BA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC0BA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC0BA8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC0BAC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC0BB0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC0BB4: 817F0084  lwz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 82AC0BB8: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 82AC0BBC: 41980010  blt cr6, 0x82ac0bcc
	if ctx.cr[6].lt {
	pc = 0x82AC0BCC; continue 'dispatch;
	}
	// 82AC0BC0: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82AC0BC4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC0BC8: 40990008  ble cr6, 0x82ac0bd0
	if !ctx.cr[6].gt {
	pc = 0x82AC0BD0; continue 'dispatch;
	}
	// 82AC0BCC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AC0BD0: 997F0074  stb r11, 0x74(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u8 ) };
	// 82AC0BD4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82AC0BD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC0BDC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82AC0BE0: 409A0014  bne cr6, 0x82ac0bf4
	if !ctx.cr[6].eq {
	pc = 0x82AC0BF4; continue 'dispatch;
	}
	// 82AC0BE4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AC0BE8: 4BFFFDA1  bl 0x82ac0988
	ctx.lr = 0x82AC0BEC;
	sub_82AC0988(ctx, base);
	// 82AC0BEC: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82AC0BF0: 48000010  b 0x82ac0c00
	pc = 0x82AC0C00; continue 'dispatch;
	// 82AC0BF4: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82AC0BF8: 4BFFFD91  bl 0x82ac0988
	ctx.lr = 0x82AC0BFC;
	sub_82AC0988(ctx, base);
	// 82AC0BFC: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82AC0C00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC0C04: 4BFFE0ED  bl 0x82abecf0
	ctx.lr = 0x82AC0C08;
	sub_82ABECF0(ctx, base);
	// 82AC0C08: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AC0C0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC0C10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC0C14: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC0C18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC0C20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC0C20 size=212
    let mut pc: u32 = 0x82AC0C20;
    'dispatch: loop {
        match pc {
            0x82AC0C20 => {
    //   block [0x82AC0C20..0x82AC0CF4)
	// 82AC0C20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC0C24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC0C28: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC0C2C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC0C30: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC0C34: 486939CD  bl 0x83154600
	ctx.lr = 0x82AC0C38;
	sub_83154600(ctx, base);
	// 82AC0C38: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC0C3C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AC0C40: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC0C44: 4BA4E6ED  bl 0x8250f330
	ctx.lr = 0x82AC0C48;
	sub_8250F330(ctx, base);
	// 82AC0C48: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AC0C4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC0C50: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC0C54: 4BA2A66D  bl 0x824eb2c0
	ctx.lr = 0x82AC0C58;
	sub_824EB2C0(ctx, base);
	// 82AC0C58: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC0C5C: 4BA555CD  bl 0x82516228
	ctx.lr = 0x82AC0C60;
	sub_82516228(ctx, base);
	// 82AC0C60: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AC0C64: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AC0C68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC0C6C: 419A000C  beq cr6, 0x82ac0c78
	if ctx.cr[6].eq {
	pc = 0x82AC0C78; continue 'dispatch;
	}
	// 82AC0C70: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82AC0C74: 4B7FFC1D  bl 0x822c0890
	ctx.lr = 0x82AC0C78;
	sub_822C0890(ctx, base);
	// 82AC0C78: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AC0C7C: 48331015  bl 0x82df1c90
	ctx.lr = 0x82AC0C80;
	sub_82DF1C90(ctx, base);
	// 82AC0C80: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82AC0C84: 40990054  ble cr6, 0x82ac0cd8
	if !ctx.cr[6].gt {
	pc = 0x82AC0CD8; continue 'dispatch;
	}
	// 82AC0C88: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC0C8C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82AC0C90: 3BFEFFFF  addi r31, r30, -1
	ctx.r[31].s64 = ctx.r[30].s64 + -1;
	// 82AC0C94: 4BA4E69D  bl 0x8250f330
	ctx.lr = 0x82AC0C98;
	sub_8250F330(ctx, base);
	// 82AC0C98: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AC0C9C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AC0CA0: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC0CA4: 4BA2A61D  bl 0x824eb2c0
	ctx.lr = 0x82AC0CA8;
	sub_824EB2C0(ctx, base);
	// 82AC0CA8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC0CAC: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC0CB0: 4BA555A1  bl 0x82516250
	ctx.lr = 0x82AC0CB4;
	sub_82516250(ctx, base);
	// 82AC0CB4: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82AC0CB8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC0CBC: 419A0008  beq cr6, 0x82ac0cc4
	if ctx.cr[6].eq {
	pc = 0x82AC0CC4; continue 'dispatch;
	}
	// 82AC0CC0: 4B7FFBD1  bl 0x822c0890
	ctx.lr = 0x82AC0CC4;
	sub_822C0890(ctx, base);
	// 82AC0CC4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82AC0CC8: 48330FC9  bl 0x82df1c90
	ctx.lr = 0x82AC0CCC;
	sub_82DF1C90(ctx, base);
	// 82AC0CCC: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82AC0CD0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82AC0CD4: 41990008  bgt cr6, 0x82ac0cdc
	if ctx.cr[6].gt {
	pc = 0x82AC0CDC; continue 'dispatch;
	}
	// 82AC0CD8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AC0CDC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82AC0CE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC0CE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC0CE8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AC0CEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC0CF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC0CF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC0CF8 size=264
    let mut pc: u32 = 0x82AC0CF8;
    'dispatch: loop {
        match pc {
            0x82AC0CF8 => {
    //   block [0x82AC0CF8..0x82AC0E00)
	// 82AC0CF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC0CFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC0D00: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC0D04: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC0D08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC0D0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC0D10: 4BFFFD01  bl 0x82ac0a10
	ctx.lr = 0x82AC0D14;
	sub_82AC0A10(ctx, base);
	// 82AC0D14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC0D18: 486938E9  bl 0x83154600
	ctx.lr = 0x82AC0D1C;
	sub_83154600(ctx, base);
	// 82AC0D1C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AC0D20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC0D24: 4BFF207D  bl 0x82ab2da0
	ctx.lr = 0x82AC0D28;
	sub_82AB2DA0(ctx, base);
	// 82AC0D28: 817F0084  lwz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 82AC0D2C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AC0D30: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82AC0D34: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC0D38: 409A000C  bne cr6, 0x82ac0d44
	if !ctx.cr[6].eq {
	pc = 0x82AC0D44; continue 'dispatch;
	}
	// 82AC0D3C: 4BFFAA85  bl 0x82abb7c0
	ctx.lr = 0x82AC0D40;
	sub_82ABB7C0(ctx, base);
	// 82AC0D40: 48000008  b 0x82ac0d48
	pc = 0x82AC0D48; continue 'dispatch;
	// 82AC0D44: 4BFFAC25  bl 0x82abb968
	ctx.lr = 0x82AC0D48;
	sub_82ABB968(ctx, base);
	// 82AC0D48: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC0D4C: 40820038  bne 0x82ac0d84
	if !ctx.cr[0].eq {
	pc = 0x82AC0D84; continue 'dispatch;
	}
	// 82AC0D50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC0D54: 4BFFFA3D  bl 0x82ac0790
	ctx.lr = 0x82AC0D58;
	sub_82AC0790(ctx, base);
	// 82AC0D58: 817F0070  lwz r11, 0x70(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82AC0D5C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC0D60: 40990018  ble cr6, 0x82ac0d78
	if !ctx.cr[6].gt {
	pc = 0x82AC0D78; continue 'dispatch;
	}
	// 82AC0D64: 2F0B0007  cmpwi cr6, r11, 7
	ctx.cr[6].compare_i32(ctx.r[11].s32, 7, &mut ctx.xer);
	// 82AC0D68: 41990010  bgt cr6, 0x82ac0d78
	if ctx.cr[6].gt {
	pc = 0x82AC0D78; continue 'dispatch;
	}
	// 82AC0D6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC0D70: 4BFFFE31  bl 0x82ac0ba0
	ctx.lr = 0x82AC0D74;
	sub_82AC0BA0(ctx, base);
	// 82AC0D74: 48000010  b 0x82ac0d84
	pc = 0x82AC0D84; continue 'dispatch;
	// 82AC0D78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC0D7C: 4BFFFDC5  bl 0x82ac0b40
	ctx.lr = 0x82AC0D80;
	sub_82AC0B40(ctx, base);
	// 82AC0D80: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AC0D84: 817F0070  lwz r11, 0x70(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82AC0D88: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 82AC0D8C: 409A0048  bne cr6, 0x82ac0dd4
	if !ctx.cr[6].eq {
	pc = 0x82AC0DD4; continue 'dispatch;
	}
	// 82AC0D90: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 82AC0D94: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC0D98: 4082003C  bne 0x82ac0dd4
	if !ctx.cr[0].eq {
	pc = 0x82AC0DD4; continue 'dispatch;
	}
	// 82AC0D9C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC0DA0: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AC0DA4: C02B91E4  lfs f1, -0x6e1c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28188 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC0DA8: 4BFFACA9  bl 0x82abba50
	ctx.lr = 0x82AC0DAC;
	sub_82ABBA50(ctx, base);
	// 82AC0DAC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82AC0DB0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82AC0DB4: 409A0020  bne cr6, 0x82ac0dd4
	if !ctx.cr[6].eq {
	pc = 0x82AC0DD4; continue 'dispatch;
	}
	// 82AC0DB8: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82AC0DBC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82AC0DC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC0DC4: 808B9FC0  lwz r4, -0x6040(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24640 as u32) ) } as u64;
	// 82AC0DC8: 4BFFE039  bl 0x82abee00
	ctx.lr = 0x82AC0DCC;
	sub_82ABEE00(ctx, base);
	// 82AC0DCC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AC0DD0: 997F0090  stb r11, 0x90(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[11].u8 ) };
	// 82AC0DD4: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AC0DD8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC0DDC: 419A0008  beq cr6, 0x82ac0de4
	if ctx.cr[6].eq {
	pc = 0x82AC0DE4; continue 'dispatch;
	}
	// 82AC0DE0: 4B7FFAB1  bl 0x822c0890
	ctx.lr = 0x82AC0DE4;
	sub_822C0890(ctx, base);
	// 82AC0DE4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC0DE8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC0DEC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC0DF0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC0DF4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AC0DF8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC0DFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC0E00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC0E00 size=1224
    let mut pc: u32 = 0x82AC0E00;
    'dispatch: loop {
        match pc {
            0x82AC0E00 => {
    //   block [0x82AC0E00..0x82AC12C8)
	// 82AC0E00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC0E04: 486E7365  bl 0x831a8168
	ctx.lr = 0x82AC0E08;
	sub_831A8130(ctx, base);
	// 82AC0E08: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC0E0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC0E10: 4BFFDEE9  bl 0x82abecf8
	ctx.lr = 0x82AC0E14;
	sub_82ABECF8(ctx, base);
	// 82AC0E14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC0E18: 486937E9  bl 0x83154600
	ctx.lr = 0x82AC0E1C;
	sub_83154600(ctx, base);
	// 82AC0E1C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AC0E20: 4BD2B3B9  bl 0x827ec1d8
	ctx.lr = 0x82AC0E24;
	sub_827EC1D8(ctx, base);
	// 82AC0E24: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AC0E28: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AC0E2C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AC0E30: 4BFF1F71  bl 0x82ab2da0
	ctx.lr = 0x82AC0E34;
	sub_82AB2DA0(ctx, base);
	// 82AC0E34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC0E38: 4BFFDEB1  bl 0x82abece8
	ctx.lr = 0x82AC0E3C;
	sub_82ABECE8(ctx, base);
	// 82AC0E3C: 2B03000A  cmplwi cr6, r3, 0xa
	ctx.cr[6].compare_u32(ctx.r[3].u32, 10 as u32, &mut ctx.xer);
	// 82AC0E40: 41990470  bgt cr6, 0x82ac12b0
	if ctx.cr[6].gt {
	pc = 0x82AC12B0; continue 'dispatch;
	}
	// 82AC0E44: 3D80820C  lis r12, -0x7df4
	ctx.r[12].s64 = -2113142784;
	// 82AC0E48: 398C91F0  addi r12, r12, -0x6e10
	ctx.r[12].s64 = ctx.r[12].s64 + -28176;
	// 82AC0E4C: 5460083C  slwi r0, r3, 1
	ctx.r[0].u32 = ctx.r[3].u32.wrapping_shl(1);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 82AC0E50: 7C0C022E  lhzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 82AC0E54: 3D8082AC  lis r12, -0x7d54
	ctx.r[12].s64 = -2102657024;
	// 82AC0E58: 398C0E6C  addi r12, r12, 0xe6c
	ctx.r[12].s64 = ctx.r[12].s64 + 3692;
	// 82AC0E5C: 7D8C0214  add r12, r12, r0
	ctx.r[12].u64 = ctx.r[12].u64 + ctx.r[0].u64;
	// 82AC0E60: 7D8903A6  mtctr r12
	ctx.ctr.u64 = ctx.r[12].u64;
	// 82AC0E64: 60000000  nop
	// 82AC0E68: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
	// 82AC0E6C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC0E70: 4BFA2E61  bl 0x82a63cd0
	ctx.lr = 0x82AC0E74;
	sub_82A63CD0(ctx, base);
	// 82AC0E74: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AC0E78: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82AC0E7C: 388BF5B0  addi r4, r11, -0xa50
	ctx.r[4].s64 = ctx.r[11].s64 + -2640;
	// 82AC0E80: 483BB159  bl 0x82e7bfd8
	ctx.lr = 0x82AC0E84;
	sub_82E7BFD8(ctx, base);
	// 82AC0E84: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AC0E88: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 82AC0E8C: 3BA100C0  addi r29, r1, 0xc0
	ctx.r[29].s64 = ctx.r[1].s64 + 192;
	// 82AC0E90: 83810058  lwz r28, 0x58(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82AC0E94: 4BFF133D  bl 0x82ab21d0
	ctx.lr = 0x82AC0E98;
	sub_82AB21D0(ctx, base);
	// 82AC0E98: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AC0E9C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AC0EA0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82AC0EA4: 4BFFAEDD  bl 0x82abbd80
	ctx.lr = 0x82AC0EA8;
	sub_82ABBD80(ctx, base);
	// 82AC0EA8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AC0EAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC0EB0: 4BFFF891  bl 0x82ac0740
	ctx.lr = 0x82AC0EB4;
	sub_82AC0740(ctx, base);
	// 82AC0EB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC0EB8: 4BFFF839  bl 0x82ac06f0
	ctx.lr = 0x82AC0EBC;
	sub_82AC06F0(ctx, base);
	// 82AC0EBC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC0EC0: 4BFF3F01  bl 0x82ab4dc0
	ctx.lr = 0x82AC0EC4;
	sub_82AB4DC0(ctx, base);
	// 82AC0EC4: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 82AC0EC8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC0ECC: 4BFF5CA5  bl 0x82ab6b70
	ctx.lr = 0x82AC0ED0;
	sub_82AB6B70(ctx, base);
	// 82AC0ED0: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82AC0ED4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC0ED8: 808B9FA0  lwz r4, -0x6060(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24672 as u32) ) } as u64;
	// 82AC0EDC: 4BFFE135  bl 0x82abf010
	ctx.lr = 0x82AC0EE0;
	sub_82ABF010(ctx, base);
	// 82AC0EE0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AC0EE4: 480003B0  b 0x82ac1294
	pc = 0x82AC1294; continue 'dispatch;
	// 82AC0EE8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC0EEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC0EF0: 396B9130  addi r11, r11, -0x6ed0
	ctx.r[11].s64 = ctx.r[11].s64 + -28368;
	// 82AC0EF4: C02B00B4  lfs f1, 0xb4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(180 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC0EF8: 4BFFDDC1  bl 0x82abecb8
	ctx.lr = 0x82AC0EFC;
	sub_82ABECB8(ctx, base);
	// 82AC0EFC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC0F00: 418203B0  beq 0x82ac12b0
	if ctx.cr[0].eq {
	pc = 0x82AC12B0; continue 'dispatch;
	}
	// 82AC0F04: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AC0F08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC0F0C: 4BFFFA7D  bl 0x82ac0988
	ctx.lr = 0x82AC0F10;
	sub_82AC0988(ctx, base);
	// 82AC0F10: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82AC0F14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC0F18: 4BFFDDD9  bl 0x82abecf0
	ctx.lr = 0x82AC0F1C;
	sub_82ABECF0(ctx, base);
	// 82AC0F1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC0F20: 4BFFFDD9  bl 0x82ac0cf8
	ctx.lr = 0x82AC0F24;
	sub_82AC0CF8(ctx, base);
	// 82AC0F24: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC0F28: 41820388  beq 0x82ac12b0
	if ctx.cr[0].eq {
	pc = 0x82AC12B0; continue 'dispatch;
	}
	// 82AC0F2C: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 82AC0F30: 48000364  b 0x82ac1294
	pc = 0x82AC1294; continue 'dispatch;
	// 82AC0F34: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82AC0F38: 4BFFA889  bl 0x82abb7c0
	ctx.lr = 0x82AC0F3C;
	sub_82ABB7C0(ctx, base);
	// 82AC0F3C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC0F40: 40820370  bne 0x82ac12b0
	if !ctx.cr[0].eq {
	pc = 0x82AC12B0; continue 'dispatch;
	}
	// 82AC0F44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC0F48: 4BFFFBF9  bl 0x82ac0b40
	ctx.lr = 0x82AC0F4C;
	sub_82AC0B40(ctx, base);
	// 82AC0F4C: 4BFFFFD8  b 0x82ac0f24
	pc = 0x82AC0F24; continue 'dispatch;
	// 82AC0F50: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 82AC0F54: 48000340  b 0x82ac1294
	pc = 0x82AC1294; continue 'dispatch;
	// 82AC0F58: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 82AC0F5C: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82AC0F60: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC0F64: 4082003C  bne 0x82ac0fa0
	if !ctx.cr[0].eq {
	pc = 0x82AC0FA0; continue 'dispatch;
	}
	// 82AC0F68: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC0F6C: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82AC0F70: 396B9130  addi r11, r11, -0x6ed0
	ctx.r[11].s64 = ctx.r[11].s64 + -28368;
	// 82AC0F74: C02B00B4  lfs f1, 0xb4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(180 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC0F78: 4BFFAAD9  bl 0x82abba50
	ctx.lr = 0x82AC0F7C;
	sub_82ABBA50(ctx, base);
	// 82AC0F7C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82AC0F80: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82AC0F84: 409A001C  bne cr6, 0x82ac0fa0
	if !ctx.cr[6].eq {
	pc = 0x82AC0FA0; continue 'dispatch;
	}
	// 82AC0F88: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82AC0F8C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82AC0F90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC0F94: 808B9FA0  lwz r4, -0x6060(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24672 as u32) ) } as u64;
	// 82AC0F98: 4BFFDE69  bl 0x82abee00
	ctx.lr = 0x82AC0F9C;
	sub_82ABEE00(ctx, base);
	// 82AC0F9C: 9BBF0090  stb r29, 0x90(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[29].u8 ) };
	// 82AC0FA0: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82AC0FA4: 4BFFA81D  bl 0x82abb7c0
	ctx.lr = 0x82AC0FA8;
	sub_82ABB7C0(ctx, base);
	// 82AC0FA8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC0FAC: 40820304  bne 0x82ac12b0
	if !ctx.cr[0].eq {
	pc = 0x82AC12B0; continue 'dispatch;
	}
	// 82AC0FB0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC0FB4: 4BFF3F25  bl 0x82ab4ed8
	ctx.lr = 0x82AC0FB8;
	sub_82AB4ED8(ctx, base);
	// 82AC0FB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC0FBC: 4BFFFC65  bl 0x82ac0c20
	ctx.lr = 0x82AC0FC0;
	sub_82AC0C20(ctx, base);
	// 82AC0FC0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC0FC4: 4182000C  beq 0x82ac0fd0
	if ctx.cr[0].eq {
	pc = 0x82AC0FD0; continue 'dispatch;
	}
	// 82AC0FC8: 38800007  li r4, 7
	ctx.r[4].s64 = 7;
	// 82AC0FCC: 480002C8  b 0x82ac1294
	pc = 0x82AC1294; continue 'dispatch;
	// 82AC0FD0: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 82AC0FD4: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82AC0FD8: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82AC0FDC: 4B848515  bl 0x823094f0
	ctx.lr = 0x82AC0FE0;
	sub_823094F0(ctx, base);
	// 82AC0FE0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC0FE4: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82AC0FE8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AC0FEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC0FF0: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82AC0FF4: 419A0024  beq cr6, 0x82ac1018
	if ctx.cr[6].eq {
	pc = 0x82AC1018; continue 'dispatch;
	}
	// 82AC0FF8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AC0FFC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AC1000: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AC1004: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AC1008: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AC100C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AC1010: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AC1014: 4082FFE8  bne 0x82ac0ffc
	if !ctx.cr[0].eq {
	pc = 0x82AC0FFC; continue 'dispatch;
	}
	// 82AC1018: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AC101C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82AC1020: 4BA4E311  bl 0x8250f330
	ctx.lr = 0x82AC1024;
	sub_8250F330(ctx, base);
	// 82AC1024: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC1028: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82AC102C: 4BA28835  bl 0x824e9860
	ctx.lr = 0x82AC1030;
	sub_824E9860(ctx, base);
	// 82AC1030: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AC1034: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82AC1038: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82AC103C: 388A9230  addi r4, r10, -0x6dd0
	ctx.r[4].s64 = ctx.r[10].s64 + -28112;
	// 82AC1040: 38A000B6  li r5, 0xb6
	ctx.r[5].s64 = 182;
	// 82AC1044: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 82AC1048: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC104C: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82AC1050: 483979F1  bl 0x82e58a40
	ctx.lr = 0x82AC1054;
	sub_82E58A40(ctx, base);
	// 82AC1054: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82AC1058: 48330C39  bl 0x82df1c90
	ctx.lr = 0x82AC105C;
	sub_82DF1C90(ctx, base);
	// 82AC105C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82AC1060: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC1064: 419A0008  beq cr6, 0x82ac106c
	if ctx.cr[6].eq {
	pc = 0x82AC106C; continue 'dispatch;
	}
	// 82AC1068: 4B7FF829  bl 0x822c0890
	ctx.lr = 0x82AC106C;
	sub_822C0890(ctx, base);
	// 82AC106C: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82AC1070: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC1074: 419A0008  beq cr6, 0x82ac107c
	if ctx.cr[6].eq {
	pc = 0x82AC107C; continue 'dispatch;
	}
	// 82AC1078: 4B7FF819  bl 0x822c0890
	ctx.lr = 0x82AC107C;
	sub_822C0890(ctx, base);
	// 82AC107C: 3880000A  li r4, 0xa
	ctx.r[4].s64 = 10;
	// 82AC1080: 48000214  b 0x82ac1294
	pc = 0x82AC1294; continue 'dispatch;
	// 82AC1084: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC1088: 4BFAFFD1  bl 0x82a71058
	ctx.lr = 0x82AC108C;
	sub_82A71058(ctx, base);
	// 82AC108C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC1090: 41820220  beq 0x82ac12b0
	if ctx.cr[0].eq {
	pc = 0x82AC12B0; continue 'dispatch;
	}
	// 82AC1094: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AC1098: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AC109C: 4BFF1D05  bl 0x82ab2da0
	ctx.lr = 0x82AC10A0;
	sub_82AB2DA0(ctx, base);
	// 82AC10A0: 80610078  lwz r3, 0x78(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 82AC10A4: 4BFFA73D  bl 0x82abb7e0
	ctx.lr = 0x82AC10A8;
	sub_82ABB7E0(ctx, base);
	// 82AC10A8: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82AC10AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC10B0: 419A0008  beq cr6, 0x82ac10b8
	if ctx.cr[6].eq {
	pc = 0x82AC10B8; continue 'dispatch;
	}
	// 82AC10B4: 4B7FF7DD  bl 0x822c0890
	ctx.lr = 0x82AC10B8;
	sub_822C0890(ctx, base);
	// 82AC10B8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82AC10BC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC10C0: 395F0078  addi r10, r31, 0x78
	ctx.r[10].s64 = ctx.r[31].s64 + 120;
	// 82AC10C4: 9BBF0090  stb r29, 0x90(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[29].u8 ) };
	// 82AC10C8: 396B9130  addi r11, r11, -0x6ed0
	ctx.r[11].s64 = ctx.r[11].s64 + -28368;
	// 82AC10CC: 93BF0070  stw r29, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 82AC10D0: 39200005  li r9, 5
	ctx.r[9].s64 = 5;
	// 82AC10D4: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82AC10D8: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC10DC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AC10E0: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AC10E4: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82AC10E8: 4200FFF0  bdnz 0x82ac10d8
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82AC10D8; continue 'dispatch;
	}
	// 82AC10EC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AC10F0: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 82AC10F4: 997F0074  stb r11, 0x74(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u8 ) };
	// 82AC10F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC10FC: 808A9FA0  lwz r4, -0x6060(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-24672 as u32) ) } as u64;
	// 82AC1100: 4BFFDF11  bl 0x82abf010
	ctx.lr = 0x82AC1104;
	sub_82ABF010(ctx, base);
	// 82AC1104: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC1108: 4BFF3CB9  bl 0x82ab4dc0
	ctx.lr = 0x82AC110C;
	sub_82AB4DC0(ctx, base);
	// 82AC110C: 4BFFFDD4  b 0x82ac0ee0
	pc = 0x82AC0EE0; continue 'dispatch;
	// 82AC1110: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC1114: 4BFAFF45  bl 0x82a71058
	ctx.lr = 0x82AC1118;
	sub_82A71058(ctx, base);
	// 82AC1118: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC111C: 41820194  beq 0x82ac12b0
	if ctx.cr[0].eq {
	pc = 0x82AC12B0; continue 'dispatch;
	}
	// 82AC1120: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC1124: 4BFA2BBD  bl 0x82a63ce0
	ctx.lr = 0x82AC1128;
	sub_82A63CE0(ctx, base);
	// 82AC1128: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AC112C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC1130: 4BFFF611  bl 0x82ac0740
	ctx.lr = 0x82AC1134;
	sub_82AC0740(ctx, base);
	// 82AC1134: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC1138: 4BFEF991  bl 0x82ab0ac8
	ctx.lr = 0x82AC113C;
	sub_82AB0AC8(ctx, base);
	// 82AC113C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82AC1140: 480DF389  bl 0x82ba04c8
	ctx.lr = 0x82AC1144;
	sub_82BA04C8(ctx, base);
	// 82AC1144: C01F0094  lfs f0, 0x94(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC1148: D00100AC  stfs f0, 0xac(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 82AC114C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82AC1150: 480DF3B1  bl 0x82ba0500
	ctx.lr = 0x82AC1154;
	sub_82BA0500(ctx, base);
	// 82AC1154: 4BFFFF28  b 0x82ac107c
	pc = 0x82AC107C; continue 'dispatch;
	// 82AC1158: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82AC115C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AC1160: 9BA10050  stb r29, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u8 ) };
	// 82AC1164: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82AC1168: 4BAB7769  bl 0x825788d0
	ctx.lr = 0x82AC116C;
	sub_825788D0(ctx, base);
	// 82AC116C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC1170: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82AC1174: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AC1178: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC117C: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82AC1180: 419A0024  beq cr6, 0x82ac11a4
	if ctx.cr[6].eq {
	pc = 0x82AC11A4; continue 'dispatch;
	}
	// 82AC1184: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AC1188: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AC118C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AC1190: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AC1194: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AC1198: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AC119C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AC11A0: 4082FFE8  bne 0x82ac1188
	if !ctx.cr[0].eq {
	pc = 0x82AC1188; continue 'dispatch;
	}
	// 82AC11A4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AC11A8: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82AC11AC: 4BA4E31D  bl 0x8250f4c8
	ctx.lr = 0x82AC11B0;
	sub_8250F4C8(ctx, base);
	// 82AC11B0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC11B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC11B8: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82AC11BC: 409A0008  bne cr6, 0x82ac11c4
	if !ctx.cr[6].eq {
	pc = 0x82AC11C4; continue 'dispatch;
	}
	// 82AC11C0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC11C4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AC11C8: 3BE10068  addi r31, r1, 0x68
	ctx.r[31].s64 = ctx.r[1].s64 + 104;
	// 82AC11CC: 4BA4784D  bl 0x82508a18
	ctx.lr = 0x82AC11D0;
	sub_82508A18(ctx, base);
	// 82AC11D0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AC11D4: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82AC11D8: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82AC11DC: 388A9230  addi r4, r10, -0x6dd0
	ctx.r[4].s64 = ctx.r[10].s64 + -28112;
	// 82AC11E0: 38A000DF  li r5, 0xdf
	ctx.r[5].s64 = 223;
	// 82AC11E4: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 82AC11E8: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC11EC: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82AC11F0: 48397851  bl 0x82e58a40
	ctx.lr = 0x82AC11F4;
	sub_82E58A40(ctx, base);
	// 82AC11F4: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82AC11F8: 48330A99  bl 0x82df1c90
	ctx.lr = 0x82AC11FC;
	sub_82DF1C90(ctx, base);
	// 82AC11FC: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82AC1200: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC1204: 419A0008  beq cr6, 0x82ac120c
	if ctx.cr[6].eq {
	pc = 0x82AC120C; continue 'dispatch;
	}
	// 82AC1208: 4B7FF689  bl 0x822c0890
	ctx.lr = 0x82AC120C;
	sub_822C0890(ctx, base);
	// 82AC120C: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82AC1210: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC1214: 419A0008  beq cr6, 0x82ac121c
	if ctx.cr[6].eq {
	pc = 0x82AC121C; continue 'dispatch;
	}
	// 82AC1218: 4B7FF679  bl 0x822c0890
	ctx.lr = 0x82AC121C;
	sub_822C0890(ctx, base);
	// 82AC121C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC1220: 4BFF3CB9  bl 0x82ab4ed8
	ctx.lr = 0x82AC1224;
	sub_82AB4ED8(ctx, base);
	// 82AC1224: 4800008C  b 0x82ac12b0
	pc = 0x82AC12B0; continue 'dispatch;
	// 82AC1228: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC122C: 4BFAFE2D  bl 0x82a71058
	ctx.lr = 0x82AC1230;
	sub_82A71058(ctx, base);
	// 82AC1230: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC1234: 4182007C  beq 0x82ac12b0
	if ctx.cr[0].eq {
	pc = 0x82AC12B0; continue 'dispatch;
	}
	// 82AC1238: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82AC123C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC1240: 808B9FC0  lwz r4, -0x6040(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24640 as u32) ) } as u64;
	// 82AC1244: 4BFFDDCD  bl 0x82abf010
	ctx.lr = 0x82AC1248;
	sub_82ABF010(ctx, base);
	// 82AC1248: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC124C: 4BFF524D  bl 0x82ab6498
	ctx.lr = 0x82AC1250;
	sub_82AB6498(ctx, base);
	// 82AC1250: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC1254: 38800009  li r4, 9
	ctx.r[4].s64 = 9;
	// 82AC1258: 396B9130  addi r11, r11, -0x6ed0
	ctx.r[11].s64 = ctx.r[11].s64 + -28368;
	// 82AC125C: C00B00BC  lfs f0, 0xbc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(188 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC1260: D01F008C  stfs f0, 0x8c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82AC1264: 48000030  b 0x82ac1294
	pc = 0x82AC1294; continue 'dispatch;
	// 82AC1268: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AC126C: C1BF008C  lfs f13, 0x8c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AC1270: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC1274: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC1278: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82AC127C: 41990024  bgt cr6, 0x82ac12a0
	if ctx.cr[6].gt {
	pc = 0x82AC12A0; continue 'dispatch;
	}
	// 82AC1280: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82AC1284: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82AC1288: 808B9FC0  lwz r4, -0x6040(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24640 as u32) ) } as u64;
	// 82AC128C: 4BFFDB75  bl 0x82abee00
	ctx.lr = 0x82AC1290;
	sub_82ABEE00(ctx, base);
	// 82AC1290: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 82AC1294: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC1298: 4BFFDA59  bl 0x82abecf0
	ctx.lr = 0x82AC129C;
	sub_82ABECF0(ctx, base);
	// 82AC129C: 48000014  b 0x82ac12b0
	pc = 0x82AC12B0; continue 'dispatch;
	// 82AC12A0: 483984D9  bl 0x82e59778
	ctx.lr = 0x82AC12A4;
	sub_82E59778(ctx, base);
	// 82AC12A4: C01F008C  lfs f0, 0x8c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC12A8: EC000828  fsubs f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 82AC12AC: D01F008C  stfs f0, 0x8c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82AC12B0: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AC12B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC12B8: 419A0008  beq cr6, 0x82ac12c0
	if ctx.cr[6].eq {
	pc = 0x82AC12C0; continue 'dispatch;
	}
	// 82AC12BC: 4B7FF5D5  bl 0x822c0890
	ctx.lr = 0x82AC12C0;
	sub_822C0890(ctx, base);
	// 82AC12C0: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 82AC12C4: 486E6EF4  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC12C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC12C8 size=100
    let mut pc: u32 = 0x82AC12C8;
    'dispatch: loop {
        match pc {
            0x82AC12C8 => {
    //   block [0x82AC12C8..0x82AC132C)
	// 82AC12C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC12CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC12D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC12D4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC12D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC12DC: 48693325  bl 0x83154600
	ctx.lr = 0x82AC12E0;
	sub_83154600(ctx, base);
	// 82AC12E0: 4BFEFC89  bl 0x82ab0f68
	ctx.lr = 0x82AC12E4;
	sub_82AB0F68(ctx, base);
	// 82AC12E4: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 82AC12E8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC12EC: 419A0020  beq cr6, 0x82ac130c
	if ctx.cr[6].eq {
	pc = 0x82AC130C; continue 'dispatch;
	}
	// 82AC12F0: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 82AC12F4: 419A000C  beq cr6, 0x82ac1300
	if ctx.cr[6].eq {
	pc = 0x82AC1300; continue 'dispatch;
	}
	// 82AC12F8: E96B92A8  ld r11, -0x6d58(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-27992 as u32) ) };
	// 82AC12FC: 48000018  b 0x82ac1314
	pc = 0x82AC1314; continue 'dispatch;
	// 82AC1300: 396B92A8  addi r11, r11, -0x6d58
	ctx.r[11].s64 = ctx.r[11].s64 + -27992;
	// 82AC1304: E96B0010  ld r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 82AC1308: 4800000C  b 0x82ac1314
	pc = 0x82AC1314; continue 'dispatch;
	// 82AC130C: 396B92A8  addi r11, r11, -0x6d58
	ctx.r[11].s64 = ctx.r[11].s64 + -27992;
	// 82AC1310: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 82AC1314: F97F0074  std r11, 0x74(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u64 ) };
	// 82AC1318: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AC131C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC1320: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC1324: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC1328: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC1330(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC1330 size=124
    let mut pc: u32 = 0x82AC1330;
    'dispatch: loop {
        match pc {
            0x82AC1330 => {
    //   block [0x82AC1330..0x82AC13AC)
	// 82AC1330: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC1334: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC1338: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC133C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC1340: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC1344: 4BFFDA55  bl 0x82abed98
	ctx.lr = 0x82AC1348;
	sub_82ABED98(ctx, base);
	// 82AC1348: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82AC134C: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 82AC1350: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC1354: 394A92C8  addi r10, r10, -0x6d38
	ctx.r[10].s64 = ctx.r[10].s64 + -27960;
	// 82AC1358: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82AC135C: 3D008207  lis r8, -0x7df9
	ctx.r[8].s64 = -2113470464;
	// 82AC1360: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82AC1364: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC1368: 388809D0  addi r4, r8, 0x9d0
	ctx.r[4].s64 = ctx.r[8].s64 + 2512;
	// 82AC136C: E94992A8  ld r10, -0x6d58(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(-27992 as u32) ) };
	// 82AC1370: 997F007C  stb r11, 0x7c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[11].u8 ) };
	// 82AC1374: 917F0080  stw r11, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82AC1378: F95F0074  std r10, 0x74(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[10].u64 ) };
	// 82AC137C: 4833268D  bl 0x82df3a08
	ctx.lr = 0x82AC1380;
	sub_82DF3A08(ctx, base);
	// 82AC1380: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC1384: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AC1388: 48398361  bl 0x82e596e8
	ctx.lr = 0x82AC138C;
	sub_82E596E8(ctx, base);
	// 82AC138C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC1390: 48332099  bl 0x82df3428
	ctx.lr = 0x82AC1394;
	sub_82DF3428(ctx, base);
	// 82AC1394: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC1398: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC139C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC13A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC13A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC13A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC13B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC13B0 size=112
    let mut pc: u32 = 0x82AC13B0;
    'dispatch: loop {
        match pc {
            0x82AC13B0 => {
    //   block [0x82AC13B0..0x82AC1420)
	// 82AC13B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC13B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC13B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC13BC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC13C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC13C4: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82AC13C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC13CC: 419A0030  beq cr6, 0x82ac13fc
	if ctx.cr[6].eq {
	pc = 0x82AC13FC; continue 'dispatch;
	}
	// 82AC13D0: 48693231  bl 0x83154600
	ctx.lr = 0x82AC13D4;
	sub_83154600(ctx, base);
	// 82AC13D4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AC13D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC13DC: 4BFF1975  bl 0x82ab2d50
	ctx.lr = 0x82AC13E0;
	sub_82AB2D50(ctx, base);
	// 82AC13E0: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AC13E4: 809F0080  lwz r4, 0x80(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82AC13E8: 480196D9  bl 0x82adaac0
	ctx.lr = 0x82AC13EC;
	sub_82ADAAC0(ctx, base);
	// 82AC13EC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AC13F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC13F4: 419A0008  beq cr6, 0x82ac13fc
	if ctx.cr[6].eq {
	pc = 0x82AC13FC; continue 'dispatch;
	}
	// 82AC13F8: 4B7FF499  bl 0x822c0890
	ctx.lr = 0x82AC13FC;
	sub_822C0890(ctx, base);
	// 82AC13FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC1400: 48693201  bl 0x83154600
	ctx.lr = 0x82AC1404;
	sub_83154600(ctx, base);
	// 82AC1404: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AC1408: 4BFEFA61  bl 0x82ab0e68
	ctx.lr = 0x82AC140C;
	sub_82AB0E68(ctx, base);
	// 82AC140C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC1410: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC1414: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC1418: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC141C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC1420(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC1420 size=408
    let mut pc: u32 = 0x82AC1420;
    'dispatch: loop {
        match pc {
            0x82AC1420 => {
    //   block [0x82AC1420..0x82AC15B8)
	// 82AC1420: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC1424: 486E6D3D  bl 0x831a8160
	ctx.lr = 0x82AC1428;
	sub_831A8130(ctx, base);
	// 82AC1428: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 82AC142C: 486E764D  bl 0x831a8a78
	ctx.lr = 0x82AC1430;
	sub_831A8A40(ctx, base);
	// 82AC1430: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC1434: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82AC1438: 486931C9  bl 0x83154600
	ctx.lr = 0x82AC143C;
	sub_83154600(ctx, base);
	// 82AC143C: 817B0074  lwz r11, 0x74(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(116 as u32) ) } as u64;
	// 82AC1440: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82AC1444: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82AC1448: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC144C: 4099015C  ble cr6, 0x82ac15a8
	if !ctx.cr[6].gt {
	pc = 0x82AC15A8; continue 'dispatch;
	}
	// 82AC1450: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC1454: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82AC1458: 3BAB9288  addi r29, r11, -0x6d78
	ctx.r[29].s64 = ctx.r[11].s64 + -28024;
	// 82AC145C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AC1460: C3EAF770  lfs f31, -0x890(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-2192 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82AC1464: C3CB9450  lfs f30, -0x6bb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82AC1468: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AC146C: 4BFEF6A5  bl 0x82ab0b10
	ctx.lr = 0x82AC1470;
	sub_82AB0B10(ctx, base);
	// 82AC1470: 7C6B07B4  extsw r11, r3
	ctx.r[11].s64 = ctx.r[3].s32 as i64;
	// 82AC1474: C01D0000  lfs f0, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC1478: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AC147C: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 82AC1480: C9A10060  lfd f13, 0x60(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82AC1484: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82AC1488: C3BD0004  lfs f29, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82AC148C: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82AC1490: EF8D07FA  fmadds f28, f13, f31, f0
	ctx.f[28].f64 = (((ctx.f[13].f64 * ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64);
	// 82AC1494: 4BF521ED  bl 0x82a13680
	ctx.lr = 0x82AC1498;
	sub_82A13680(ctx, base);
	// 82AC1498: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AC149C: FC20E090  fmr f1, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[28].f64;
	// 82AC14A0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82AC14A4: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 82AC14A8: 4BFED449  bl 0x82aae8f0
	ctx.lr = 0x82AC14AC;
	sub_82AAE8F0(ctx, base);
	// 82AC14AC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82AC14B0: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82AC14B4: 4BA295D5  bl 0x824eaa88
	ctx.lr = 0x82AC14B8;
	sub_824EAA88(ctx, base);
	// 82AC14B8: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC14BC: 4BA28395  bl 0x824e9850
	ctx.lr = 0x82AC14C0;
	sub_824E9850(ctx, base);
	// 82AC14C0: FF01F000  fcmpu cr6, f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[30].f64);
	// 82AC14C4: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 82AC14C8: 41980008  blt cr6, 0x82ac14d0
	if ctx.cr[6].lt {
	pc = 0x82AC14D0; continue 'dispatch;
	}
	// 82AC14CC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AC14D0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82AC14D4: 483307BD  bl 0x82df1c90
	ctx.lr = 0x82AC14D8;
	sub_82DF1C90(ctx, base);
	// 82AC14D8: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC14DC: 41820008  beq 0x82ac14e4
	if ctx.cr[0].eq {
	pc = 0x82AC14E4; continue 'dispatch;
	}
	// 82AC14E0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82AC14E4: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82AC14E8: C05D0004  lfs f2, 4(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82AC14EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC14F0: C03D0000  lfs f1, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC14F4: 4800A62D  bl 0x82acbb20
	ctx.lr = 0x82AC14F8;
	sub_82ACBB20(ctx, base);
	// 82AC14F8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AC14FC: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AC1500: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC1504: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82AC1508: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82AC150C: 419A0024  beq cr6, 0x82ac1530
	if ctx.cr[6].eq {
	pc = 0x82AC1530; continue 'dispatch;
	}
	// 82AC1510: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AC1514: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AC1518: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AC151C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AC1520: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AC1524: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AC1528: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AC152C: 4082FFE8  bne 0x82ac1514
	if !ctx.cr[0].eq {
	pc = 0x82AC1514; continue 'dispatch;
	}
	// 82AC1530: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82AC1534: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AC1538: 4BA4DF91  bl 0x8250f4c8
	ctx.lr = 0x82AC153C;
	sub_8250F4C8(ctx, base);
	// 82AC153C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC1540: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC1544: 3BEBFFFC  addi r31, r11, -4
	ctx.r[31].s64 = ctx.r[11].s64 + -4;
	// 82AC1548: 409A0008  bne cr6, 0x82ac1550
	if !ctx.cr[6].eq {
	pc = 0x82AC1550; continue 'dispatch;
	}
	// 82AC154C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AC1550: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82AC1554: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AC1558: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 82AC155C: 4BA4DFBD  bl 0x8250f518
	ctx.lr = 0x82AC1560;
	sub_8250F518(ctx, base);
	// 82AC1560: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AC1564: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC1568: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82AC156C: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82AC1570: 4BA4BF99  bl 0x8250d508
	ctx.lr = 0x82AC1574;
	sub_8250D508(ctx, base);
	// 82AC1574: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AC1578: 48330719  bl 0x82df1c90
	ctx.lr = 0x82AC157C;
	sub_82DF1C90(ctx, base);
	// 82AC157C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AC1580: 48330711  bl 0x82df1c90
	ctx.lr = 0x82AC1584;
	sub_82DF1C90(ctx, base);
	// 82AC1584: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AC1588: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC158C: 419A0008  beq cr6, 0x82ac1594
	if ctx.cr[6].eq {
	pc = 0x82AC1594; continue 'dispatch;
	}
	// 82AC1590: 4B7FF301  bl 0x822c0890
	ctx.lr = 0x82AC1594;
	sub_822C0890(ctx, base);
	// 82AC1594: 817B0074  lwz r11, 0x74(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(116 as u32) ) } as u64;
	// 82AC1598: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 82AC159C: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 82AC15A0: 7F1A5840  cmplw cr6, r26, r11
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82AC15A4: 4198FEC4  blt cr6, 0x82ac1468
	if ctx.cr[6].lt {
	pc = 0x82AC1468; continue 'dispatch;
	}
	// 82AC15A8: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82AC15AC: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 82AC15B0: 486E7515  bl 0x831a8ac4
	ctx.lr = 0x82AC15B4;
	sub_831A8A8C(ctx, base);
	// 82AC15B4: 486E6BFC  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC15B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC15B8 size=728
    let mut pc: u32 = 0x82AC15B8;
    'dispatch: loop {
        match pc {
            0x82AC15B8 => {
    //   block [0x82AC15B8..0x82AC1890)
	// 82AC15B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC15BC: 486E6BAD  bl 0x831a8168
	ctx.lr = 0x82AC15C0;
	sub_831A8130(ctx, base);
	// 82AC15C0: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82AC15C4: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC15C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC15CC: 48693035  bl 0x83154600
	ctx.lr = 0x82AC15D0;
	sub_83154600(ctx, base);
	// 82AC15D0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AC15D4: 4BD2AC05  bl 0x827ec1d8
	ctx.lr = 0x82AC15D8;
	sub_827EC1D8(ctx, base);
	// 82AC15D8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82AC15DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC15E0: 4BF518D9  bl 0x82a12eb8
	ctx.lr = 0x82AC15E4;
	sub_82A12EB8(ctx, base);
	// 82AC15E4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AC15E8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AC15EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC15F0: 4BFF1761  bl 0x82ab2d50
	ctx.lr = 0x82AC15F4;
	sub_82AB2D50(ctx, base);
	// 82AC15F4: 817F0070  lwz r11, 0x70(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82AC15F8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82AC15FC: 41980224  blt cr6, 0x82ac1820
	if ctx.cr[6].lt {
	pc = 0x82AC1820; continue 'dispatch;
	}
	// 82AC1600: 419A020C  beq cr6, 0x82ac180c
	if ctx.cr[6].eq {
	pc = 0x82AC180C; continue 'dispatch;
	}
	// 82AC1604: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82AC1608: 419801A4  blt cr6, 0x82ac17ac
	if ctx.cr[6].lt {
	pc = 0x82AC17AC; continue 'dispatch;
	}
	// 82AC160C: 419A0134  beq cr6, 0x82ac1740
	if ctx.cr[6].eq {
	pc = 0x82AC1740; continue 'dispatch;
	}
	// 82AC1610: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 82AC1614: 419800AC  blt cr6, 0x82ac16c0
	if ctx.cr[6].lt {
	pc = 0x82AC16C0; continue 'dispatch;
	}
	// 82AC1618: 419A0048  beq cr6, 0x82ac1660
	if ctx.cr[6].eq {
	pc = 0x82AC1660; continue 'dispatch;
	}
	// 82AC161C: 2B0B0007  cmplwi cr6, r11, 7
	ctx.cr[6].compare_u32(ctx.r[11].u32, 7 as u32, &mut ctx.xer);
	// 82AC1620: 40980230  bge cr6, 0x82ac1850
	if !ctx.cr[6].lt {
	pc = 0x82AC1850; continue 'dispatch;
	}
	// 82AC1624: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AC1628: C1BF0078  lfs f13, 0x78(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AC162C: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC1630: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82AC1634: 41990014  bgt cr6, 0x82ac1648
	if ctx.cr[6].gt {
	pc = 0x82AC1648; continue 'dispatch;
	}
	// 82AC1638: 39600007  li r11, 7
	ctx.r[11].s64 = 7;
	// 82AC163C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AC1640: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82AC1644: 4BFA269D  bl 0x82a63ce0
	ctx.lr = 0x82AC1648;
	sub_82A63CE0(ctx, base);
	// 82AC1648: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC164C: 4839812D  bl 0x82e59778
	ctx.lr = 0x82AC1650;
	sub_82E59778(ctx, base);
	// 82AC1650: C01F0078  lfs f0, 0x78(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC1654: EC000828  fsubs f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 82AC1658: D01F0078  stfs f0, 0x78(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82AC165C: 480001F4  b 0x82ac1850
	pc = 0x82AC1850; continue 'dispatch;
	// 82AC1660: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC1664: 4BA9645D  bl 0x82557ac0
	ctx.lr = 0x82AC1668;
	sub_82557AC0(ctx, base);
	// 82AC1668: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC166C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AC1670: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC1674: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82AC1678: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AC167C: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82AC1680: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AC1684: 4E800421  bctrl
	ctx.lr = 0x82AC1688;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AC1688: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82AC168C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82AC1690: 409A01C0  bne cr6, 0x82ac1850
	if !ctx.cr[6].eq {
	pc = 0x82AC1850; continue 'dispatch;
	}
	// 82AC1694: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AC1698: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC169C: 4BFEF7CD  bl 0x82ab0e68
	ctx.lr = 0x82AC16A0;
	sub_82AB0E68(ctx, base);
	// 82AC16A0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AC16A4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AC16A8: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82AC16AC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC16B0: C02B9450  lfs f1, -0x6bb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC16B4: 4BFF895D  bl 0x82aba010
	ctx.lr = 0x82AC16B8;
	sub_82ABA010(ctx, base);
	// 82AC16B8: 39600006  li r11, 6
	ctx.r[11].s64 = 6;
	// 82AC16BC: 4800015C  b 0x82ac1818
	pc = 0x82AC1818; continue 'dispatch;
	// 82AC16C0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC16C4: 4BA963FD  bl 0x82557ac0
	ctx.lr = 0x82AC16C8;
	sub_82557AC0(ctx, base);
	// 82AC16C8: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC16CC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AC16D0: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC16D4: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82AC16D8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AC16DC: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82AC16E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AC16E4: 4E800421  bctrl
	ctx.lr = 0x82AC16E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AC16E8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82AC16EC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82AC16F0: 409A0160  bne cr6, 0x82ac1850
	if !ctx.cr[6].eq {
	pc = 0x82AC1850; continue 'dispatch;
	}
	// 82AC16F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC16F8: 48692F09  bl 0x83154600
	ctx.lr = 0x82AC16FC;
	sub_83154600(ctx, base);
	// 82AC16FC: 4BFF30ED  bl 0x82ab47e8
	ctx.lr = 0x82AC1700;
	sub_82AB47E8(ctx, base);
	// 82AC1700: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82AC1704: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82AC1708: 409A0148  bne cr6, 0x82ac1850
	if !ctx.cr[6].eq {
	pc = 0x82AC1850; continue 'dispatch;
	}
	// 82AC170C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC1710: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC1714: 997F007C  stb r11, 0x7c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[11].u8 ) };
	// 82AC1718: 48692EE9  bl 0x83154600
	ctx.lr = 0x82AC171C;
	sub_83154600(ctx, base);
	// 82AC171C: 4BFF31DD  bl 0x82ab48f8
	ctx.lr = 0x82AC1720;
	sub_82AB48F8(ctx, base);
	// 82AC1720: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AC1724: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82AC1728: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82AC172C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC1730: C02B9450  lfs f1, -0x6bb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC1734: 4BFF88DD  bl 0x82aba010
	ctx.lr = 0x82AC1738;
	sub_82ABA010(ctx, base);
	// 82AC1738: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 82AC173C: 480000DC  b 0x82ac1818
	pc = 0x82AC1818; continue 'dispatch;
	// 82AC1740: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC1744: 4BA9637D  bl 0x82557ac0
	ctx.lr = 0x82AC1748;
	sub_82557AC0(ctx, base);
	// 82AC1748: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC174C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AC1750: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC1754: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82AC1758: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AC175C: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82AC1760: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AC1764: 4E800421  bctrl
	ctx.lr = 0x82AC1768;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AC1768: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82AC176C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82AC1770: 409A00E0  bne cr6, 0x82ac1850
	if !ctx.cr[6].eq {
	pc = 0x82AC1850; continue 'dispatch;
	}
	// 82AC1774: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AC1778: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82AC177C: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 82AC1780: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC1784: C02B9450  lfs f1, -0x6bb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC1788: 4BFF8889  bl 0x82aba010
	ctx.lr = 0x82AC178C;
	sub_82ABA010(ctx, base);
	// 82AC178C: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82AC1790: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AC1794: 809F0080  lwz r4, 0x80(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82AC1798: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82AC179C: 48019325  bl 0x82adaac0
	ctx.lr = 0x82AC17A0;
	sub_82ADAAC0(ctx, base);
	// 82AC17A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC17A4: 917F0080  stw r11, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82AC17A8: 480000A8  b 0x82ac1850
	pc = 0x82AC1850; continue 'dispatch;
	// 82AC17AC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AC17B0: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82AC17B4: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 82AC17B8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC17BC: C04B08A4  lfs f2, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82AC17C0: C02A9450  lfs f1, -0x6bb0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC17C4: 4BFF884D  bl 0x82aba010
	ctx.lr = 0x82AC17C8;
	sub_82ABA010(ctx, base);
	// 82AC17C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC17CC: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AC17D0: 4BF51EB1  bl 0x82a13680
	ctx.lr = 0x82AC17D4;
	sub_82A13680(ctx, base);
	// 82AC17D4: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 82AC17D8: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 82AC17DC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AC17E0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AC17E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC17E8: 38C00003  li r6, 3
	ctx.r[6].s64 = 3;
	// 82AC17EC: C02B4430  lfs f1, 0x4430(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(17456 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC17F0: C04A6218  lfs f2, 0x6218(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25112 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82AC17F4: 480193FD  bl 0x82adabf0
	ctx.lr = 0x82AC17F8;
	sub_82ADABF0(ctx, base);
	// 82AC17F8: 907F0080  stw r3, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[3].u32 ) };
	// 82AC17FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC1800: 4BFFFC21  bl 0x82ac1420
	ctx.lr = 0x82AC1804;
	sub_82AC1420(ctx, base);
	// 82AC1804: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82AC1808: 48000010  b 0x82ac1818
	pc = 0x82AC1818; continue 'dispatch;
	// 82AC180C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC1810: 4BFFFAB9  bl 0x82ac12c8
	ctx.lr = 0x82AC1814;
	sub_82AC12C8(ctx, base);
	// 82AC1814: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82AC1818: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82AC181C: 48000034  b 0x82ac1850
	pc = 0x82AC1850; continue 'dispatch;
	// 82AC1820: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AC1824: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC1828: 4BFEF641  bl 0x82ab0e68
	ctx.lr = 0x82AC182C;
	sub_82AB0E68(ctx, base);
	// 82AC182C: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 82AC1830: 3880001D  li r4, 0x1d
	ctx.r[4].s64 = 29;
	// 82AC1834: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC1838: 4BFEF9B9  bl 0x82ab11f0
	ctx.lr = 0x82AC183C;
	sub_82AB11F0(ctx, base);
	// 82AC183C: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82AC1840: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AC1844: 9BDF007C  stb r30, 0x7c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[30].u8 ) };
	// 82AC1848: 4BFA2489  bl 0x82a63cd0
	ctx.lr = 0x82AC184C;
	sub_82A63CD0(ctx, base);
	// 82AC184C: 93DF0070  stw r30, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82AC1850: 897F007C  lbz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82AC1854: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC1858: 4182001C  beq 0x82ac1874
	if ctx.cr[0].eq {
	pc = 0x82AC1874; continue 'dispatch;
	}
	// 82AC185C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC1860: 48692DA1  bl 0x83154600
	ctx.lr = 0x82AC1864;
	sub_83154600(ctx, base);
	// 82AC1864: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC1868: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AC186C: C02B92C0  lfs f1, -0x6d40(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27968 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC1870: 4BFF6271  bl 0x82ab7ae0
	ctx.lr = 0x82AC1874;
	sub_82AB7AE0(ctx, base);
	// 82AC1874: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AC1878: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC187C: 419A0008  beq cr6, 0x82ac1884
	if ctx.cr[6].eq {
	pc = 0x82AC1884; continue 'dispatch;
	}
	// 82AC1880: 4B7FF011  bl 0x822c0890
	ctx.lr = 0x82AC1884;
	sub_822C0890(ctx, base);
	// 82AC1884: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82AC1888: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82AC188C: 486E692C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC1890(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC1890 size=116
    let mut pc: u32 = 0x82AC1890;
    'dispatch: loop {
        match pc {
            0x82AC1890 => {
    //   block [0x82AC1890..0x82AC1904)
	// 82AC1890: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC1894: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC1898: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC189C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC18A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC18A4: 48692D5D  bl 0x83154600
	ctx.lr = 0x82AC18A8;
	sub_83154600(ctx, base);
	// 82AC18A8: 4BF51611  bl 0x82a12eb8
	ctx.lr = 0x82AC18AC;
	sub_82A12EB8(ctx, base);
	// 82AC18AC: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82AC18B0: 817F0098  lwz r11, 0x98(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 82AC18B4: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82AC18B8: C02A9450  lfs f1, -0x6bb0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC18BC: 419A0024  beq cr6, 0x82ac18e0
	if ctx.cr[6].eq {
	pc = 0x82AC18E0; continue 'dispatch;
	}
	// 82AC18C0: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82AC18C4: 419A0014  beq cr6, 0x82ac18d8
	if ctx.cr[6].eq {
	pc = 0x82AC18D8; continue 'dispatch;
	}
	// 82AC18C8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AC18CC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AC18D0: C04B08A4  lfs f2, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82AC18D4: 48000018  b 0x82ac18ec
	pc = 0x82AC18EC; continue 'dispatch;
	// 82AC18D8: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82AC18DC: 48000008  b 0x82ac18e4
	pc = 0x82AC18E4; continue 'dispatch;
	// 82AC18E0: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82AC18E4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC18E8: C04B92F0  lfs f2, -0x6d10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27920 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82AC18EC: 4BFF8725  bl 0x82aba010
	ctx.lr = 0x82AC18F0;
	sub_82ABA010(ctx, base);
	// 82AC18F0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AC18F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC18F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC18FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC1900: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC1908(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC1908 size=144
    let mut pc: u32 = 0x82AC1908;
    'dispatch: loop {
        match pc {
            0x82AC1908 => {
    //   block [0x82AC1908..0x82AC1998)
	// 82AC1908: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC190C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC1910: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC1914: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC1918: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC191C: 4BFFD47D  bl 0x82abed98
	ctx.lr = 0x82AC1920;
	sub_82ABED98(ctx, base);
	// 82AC1920: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82AC1924: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AC1928: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 82AC192C: 390B6910  addi r8, r11, 0x6910
	ctx.r[8].s64 = ctx.r[11].s64 + 26896;
	// 82AC1930: 38E000A0  li r7, 0xa0
	ctx.r[7].s64 = 160;
	// 82AC1934: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC1938: 392992F8  addi r9, r9, -0x6d08
	ctx.r[9].s64 = ctx.r[9].s64 + -27912;
	// 82AC193C: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC1940: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82AC1944: D01F0090  stfs f0, 0x90(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82AC1948: 917F0098  stw r11, 0x98(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 82AC194C: D01F0094  stfs f0, 0x94(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82AC1950: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AC1954: 13E040C7  vcmpequd (lvx128) v31, v0, v8
	tmp.u32 = ctx.r[8].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC1998(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC1998 size=272
    let mut pc: u32 = 0x82AC1998;
    'dispatch: loop {
        match pc {
            0x82AC1998 => {
    //   block [0x82AC1998..0x82AC1AA8)
	// 82AC1998: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC199C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC19A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC19A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC19A8: DBA1FFD0  stfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[29].u64 ) };
	// 82AC19AC: DBC1FFD8  stfd f30, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 82AC19B0: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82AC19B4: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC19B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC19BC: 48692C45  bl 0x83154600
	ctx.lr = 0x82AC19C0;
	sub_83154600(ctx, base);
	// 82AC19C0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AC19C4: 4BFEF14D  bl 0x82ab0b10
	ctx.lr = 0x82AC19C8;
	sub_82AB0B10(ctx, base);
	// 82AC19C8: 7C6B07B4  extsw r11, r3
	ctx.r[11].s64 = ctx.r[3].s32 as i64;
	// 82AC19CC: C1BF0090  lfs f13, 0x90(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AC19D0: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82AC19D4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82AC19D8: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82AC19DC: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82AC19E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC19E4: FD800018  frsp f12, f0
	ctx.f[12].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82AC19E8: C00AF770  lfs f0, -0x890(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-2192 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC19EC: EFEC0032  fmuls f31, f12, f0
	ctx.f[31].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82AC19F0: EFADF828  fsubs f29, f13, f31
	ctx.f[29].f64 = (((ctx.f[13].f64 - ctx.f[31].f64) as f32) as f64);
	// 82AC19F4: 48397D85  bl 0x82e59778
	ctx.lr = 0x82AC19F8;
	sub_82E59778(ctx, base);
	// 82AC19F8: FC400890  fmr f2, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[1].f64;
	// 82AC19FC: C03F0094  lfs f1, 0x94(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC1A00: 4BFECA01  bl 0x82aae400
	ctx.lr = 0x82AC1A04;
	sub_82AAE400(ctx, base);
	// 82AC1A04: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC1A08: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 82AC1A0C: 4BF514AD  bl 0x82a12eb8
	ctx.lr = 0x82AC1A10;
	sub_82A12EB8(ctx, base);
	// 82AC1A10: FC00F210  fabs f0, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = ctx.f[30].u64 & !0x8000_0000_0000_0000u64;
	// 82AC1A14: FDA0EA10  fabs f13, f29
	ctx.f[13].u64 = ctx.f[29].u64 & !0x8000_0000_0000_0000u64;
	// 82AC1A18: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82AC1A1C: 40980054  bge cr6, 0x82ac1a70
	if !ctx.cr[6].lt {
	pc = 0x82AC1A70; continue 'dispatch;
	}
	// 82AC1A20: 4BA960A1  bl 0x82557ac0
	ctx.lr = 0x82AC1A24;
	sub_82557AC0(ctx, base);
	// 82AC1A24: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC1A28: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AC1A2C: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC1A30: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC1A34: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82AC1A38: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AC1A3C: 4E800421  bctrl
	ctx.lr = 0x82AC1A40;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AC1A40: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC1A44: 4082002C  bne 0x82ac1a70
	if !ctx.cr[0].eq {
	pc = 0x82AC1A70; continue 'dispatch;
	}
	// 82AC1A48: EDBEF82A  fadds f13, f30, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = ((ctx.f[30].f64 + ctx.f[31].f64) as f32) as f64;
	// 82AC1A4C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AC1A50: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC1A54: C00BF774  lfs f0, -0x88c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2188 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC1A58: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82AC1A5C: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82AC1A60: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 82AC1A64: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AC1A68: 4BFEF4A9  bl 0x82ab0f10
	ctx.lr = 0x82AC1A6C;
	sub_82AB0F10(ctx, base);
	// 82AC1A6C: 48000018  b 0x82ac1a84
	pc = 0x82AC1A84; continue 'dispatch;
	// 82AC1A70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC1A74: 48692B8D  bl 0x83154600
	ctx.lr = 0x82AC1A78;
	sub_83154600(ctx, base);
	// 82AC1A78: 4BFEF121  bl 0x82ab0b98
	ctx.lr = 0x82AC1A7C;
	sub_82AB0B98(ctx, base);
	// 82AC1A7C: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82AC1A80: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82AC1A84: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82AC1A88: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC1A8C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC1A90: CBA1FFD0  lfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82AC1A94: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82AC1A98: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82AC1A9C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AC1AA0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC1AA4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC1AA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AC1AA8 size=508
    let mut pc: u32 = 0x82AC1AA8;
    'dispatch: loop {
        match pc {
            0x82AC1AA8 => {
    //   block [0x82AC1AA8..0x82AC1CA4)
	// 82AC1AA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC1AAC: 486E66C1  bl 0x831a816c
	ctx.lr = 0x82AC1AB0;
	sub_831A8130(ctx, base);
	// 82AC1AB0: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 82AC1AB4: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82AC1AB8: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC1CA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC1CA8 size=588
    let mut pc: u32 = 0x82AC1CA8;
    'dispatch: loop {
        match pc {
            0x82AC1CA8 => {
    //   block [0x82AC1CA8..0x82AC1EF4)
	// 82AC1CA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC1CAC: 486E64C1  bl 0x831a816c
	ctx.lr = 0x82AC1CB0;
	sub_831A8130(ctx, base);
	// 82AC1CB0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC1CB4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AC1CB8: 48692949  bl 0x83154600
	ctx.lr = 0x82AC1CBC;
	sub_83154600(ctx, base);
	// 82AC1CBC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC1CC0: 4BD2A519  bl 0x827ec1d8
	ctx.lr = 0x82AC1CC4;
	sub_827EC1D8(ctx, base);
	// 82AC1CC4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AC1CC8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC1CCC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AC1CD0: 4BFF1081  bl 0x82ab2d50
	ctx.lr = 0x82AC1CD4;
	sub_82AB2D50(ctx, base);
	// 82AC1CD4: 817E0070  lwz r11, 0x70(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(112 as u32) ) } as u64;
	// 82AC1CD8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82AC1CDC: 419801F0  blt cr6, 0x82ac1ecc
	if ctx.cr[6].lt {
	pc = 0x82AC1ECC; continue 'dispatch;
	}
	// 82AC1CE0: 419A0050  beq cr6, 0x82ac1d30
	if ctx.cr[6].eq {
	pc = 0x82AC1D30; continue 'dispatch;
	}
	// 82AC1CE4: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82AC1CE8: 4198003C  blt cr6, 0x82ac1d24
	if ctx.cr[6].lt {
	pc = 0x82AC1D24; continue 'dispatch;
	}
	// 82AC1CEC: 409A01F0  bne cr6, 0x82ac1edc
	if !ctx.cr[6].eq {
	pc = 0x82AC1EDC; continue 'dispatch;
	}
	// 82AC1CF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC1CF4: 4BF511C5  bl 0x82a12eb8
	ctx.lr = 0x82AC1CF8;
	sub_82A12EB8(ctx, base);
	// 82AC1CF8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AC1CFC: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82AC1D00: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AC1D04: C04B08A4  lfs f2, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82AC1D08: C02A9450  lfs f1, -0x6bb0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC1D0C: 4BFF8305  bl 0x82aba010
	ctx.lr = 0x82AC1D10;
	sub_82ABA010(ctx, base);
	// 82AC1D10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC1D14: 4BD2A4C5  bl 0x827ec1d8
	ctx.lr = 0x82AC1D18;
	sub_827EC1D8(ctx, base);
	// 82AC1D18: 4BFA1FC9  bl 0x82a63ce0
	ctx.lr = 0x82AC1D1C;
	sub_82A63CE0(ctx, base);
	// 82AC1D1C: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82AC1D20: 480001B8  b 0x82ac1ed8
	pc = 0x82AC1ED8; continue 'dispatch;
	// 82AC1D24: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC1D28: 4BFFFC71  bl 0x82ac1998
	ctx.lr = 0x82AC1D2C;
	sub_82AC1998(ctx, base);
	// 82AC1D2C: 480001B0  b 0x82ac1edc
	pc = 0x82AC1EDC; continue 'dispatch;
	// 82AC1D30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC1D34: 4BFFFD75  bl 0x82ac1aa8
	ctx.lr = 0x82AC1D38;
	sub_82AC1AA8(ctx, base);
	// 82AC1D38: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AC1D3C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC1D40: 4BFFFB51  bl 0x82ac1890
	ctx.lr = 0x82AC1D44;
	sub_82AC1890(ctx, base);
	// 82AC1D44: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 82AC1D48: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82AC1D4C: 409A016C  bne cr6, 0x82ac1eb8
	if !ctx.cr[6].eq {
	pc = 0x82AC1EB8; continue 'dispatch;
	}
	// 82AC1D50: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82AC1D54: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 82AC1D58: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 82AC1D5C: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 82AC1D60: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AC1D64: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82AC1D68: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AC1D6C: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC1EF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AC1EF8 size=12
    let mut pc: u32 = 0x82AC1EF8;
    'dispatch: loop {
        match pc {
            0x82AC1EF8 => {
    //   block [0x82AC1EF8..0x82AC1F04)
	// 82AC1EF8: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82AC1EFC: 806BE634  lwz r3, -0x19cc(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6604 as u32) ) } as u64;
	// 82AC1F00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC1F08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC1F08 size=64
    let mut pc: u32 = 0x82AC1F08;
    'dispatch: loop {
        match pc {
            0x82AC1F08 => {
    //   block [0x82AC1F08..0x82AC1F48)
	// 82AC1F08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC1F0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC1F10: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC1F14: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC1F18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC1F1C: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82AC1F20: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82AC1F24: 4BAC917D  bl 0x8258b0a0
	ctx.lr = 0x82AC1F28;
	sub_8258B0A0(ctx, base);
	// 82AC1F28: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AC1F2C: 387FFF1C  addi r3, r31, -0xe4
	ctx.r[3].s64 = ctx.r[31].s64 + -228;
	// 82AC1F30: 4BA4D489  bl 0x8250f3b8
	ctx.lr = 0x82AC1F34;
	sub_8250F3B8(ctx, base);
	// 82AC1F34: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AC1F38: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC1F3C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC1F40: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC1F44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC1F48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC1F48 size=72
    let mut pc: u32 = 0x82AC1F48;
    'dispatch: loop {
        match pc {
            0x82AC1F48 => {
    //   block [0x82AC1F48..0x82AC1F90)
	// 82AC1F48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC1F4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC1F50: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC1F54: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC1F58: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC1F5C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82AC1F60: 807F00F4  lwz r3, 0xf4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 82AC1F64: 48003FFD  bl 0x82ac5f60
	ctx.lr = 0x82AC1F68;
	sub_82AC5F60(ctx, base);
	// 82AC1F68: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC1F6C: 41820010  beq 0x82ac1f7c
	if ctx.cr[0].eq {
	pc = 0x82AC1F7C; continue 'dispatch;
	}
	// 82AC1F70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC1F74: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AC1F78: 4BA4FD29  bl 0x82511ca0
	ctx.lr = 0x82AC1F7C;
	sub_82511CA0(ctx, base);
	// 82AC1F7C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC1F80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC1F84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC1F88: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC1F8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC1F90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AC1F90 size=4
    let mut pc: u32 = 0x82AC1F90;
    'dispatch: loop {
        match pc {
            0x82AC1F90 => {
    //   block [0x82AC1F90..0x82AC1F94)
	// 82AC1F90: 4BA4FAF0  b 0x82511a80
	sub_82511A80(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC1F98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AC1F98 size=8
    let mut pc: u32 = 0x82AC1F98;
    'dispatch: loop {
        match pc {
            0x82AC1F98 => {
    //   block [0x82AC1F98..0x82AC1FA0)
	// 82AC1F98: 80630114  lwz r3, 0x114(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(276 as u32) ) } as u64;
	// 82AC1F9C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC1FA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AC1FA0 size=8
    let mut pc: u32 = 0x82AC1FA0;
    'dispatch: loop {
        match pc {
            0x82AC1FA0 => {
    //   block [0x82AC1FA0..0x82AC1FA8)
	// 82AC1FA0: 8863011C  lbz r3, 0x11c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(284 as u32) ) } as u64;
	// 82AC1FA4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC1FA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC1FA8 size=72
    let mut pc: u32 = 0x82AC1FA8;
    'dispatch: loop {
        match pc {
            0x82AC1FA8 => {
    //   block [0x82AC1FA8..0x82AC1FF0)
	// 82AC1FA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC1FAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC1FB0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC1FB4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC1FB8: 806300EC  lwz r3, 0xec(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(236 as u32) ) } as u64;
	// 82AC1FBC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AC1FC0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC1FC4: 409A000C  bne cr6, 0x82ac1fd0
	if !ctx.cr[6].eq {
	pc = 0x82AC1FD0; continue 'dispatch;
	}
	// 82AC1FC8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82AC1FCC: 48000008  b 0x82ac1fd4
	pc = 0x82AC1FD4; continue 'dispatch;
	// 82AC1FD0: 4BFA1D21  bl 0x82a63cf0
	ctx.lr = 0x82AC1FD4;
	sub_82A63CF0(ctx, base);
	// 82AC1FD4: 987F0018  stb r3, 0x18(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[3].u8 ) };
	// 82AC1FD8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82AC1FDC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AC1FE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC1FE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC1FE8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC1FEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC1FF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AC1FF0 size=8
    let mut pc: u32 = 0x82AC1FF0;
    'dispatch: loop {
        match pc {
            0x82AC1FF0 => {
    //   block [0x82AC1FF0..0x82AC1FF8)
	// 82AC1FF0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AC1FF4: 4BA4DB4C  b 0x8250fb40
	sub_8250FB40(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC1FF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AC1FF8 size=8
    let mut pc: u32 = 0x82AC1FF8;
    'dispatch: loop {
        match pc {
            0x82AC1FF8 => {
    //   block [0x82AC1FF8..0x82AC2000)
	// 82AC1FF8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AC1FFC: 4BA4DB44  b 0x8250fb40
	sub_8250FB40(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC2000(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AC2000 size=12
    let mut pc: u32 = 0x82AC2000;
    'dispatch: loop {
        match pc {
            0x82AC2000 => {
    //   block [0x82AC2000..0x82AC200C)
	// 82AC2000: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AC2004: 9963011C  stb r11, 0x11c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(284 as u32), ctx.r[11].u8 ) };
	// 82AC2008: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC2010(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82AC2010 size=28
    let mut pc: u32 = 0x82AC2010;
    'dispatch: loop {
        match pc {
            0x82AC2010 => {
    //   block [0x82AC2010..0x82AC202C)
	// 82AC2010: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC2014: C00300F8  lfs f0, 0xf8(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(248 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC2018: D0040018  stfs f0, 0x18(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82AC201C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82AC2020: C00B93AC  lfs f0, -0x6c54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27732 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC2024: D004001C  stfs f0, 0x1c(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82AC2028: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC2030(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC2030 size=136
    let mut pc: u32 = 0x82AC2030;
    'dispatch: loop {
        match pc {
            0x82AC2030 => {
    //   block [0x82AC2030..0x82AC20B8)
	// 82AC2030: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC2034: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC2038: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC203C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC2040: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC2044: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC2048: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AC204C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC2050: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC2054: 4BA4D475  bl 0x8250f4c8
	ctx.lr = 0x82AC2058;
	sub_8250F4C8(ctx, base);
	// 82AC2058: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC205C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC2060: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82AC2064: 409A0008  bne cr6, 0x82ac206c
	if !ctx.cr[6].eq {
	pc = 0x82AC206C; continue 'dispatch;
	}
	// 82AC2068: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AC206C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AC2070: 4BA488E1  bl 0x8250a950
	ctx.lr = 0x82AC2074;
	sub_8250A950(ctx, base);
	// 82AC2074: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC2078: 4832FC19  bl 0x82df1c90
	ctx.lr = 0x82AC207C;
	sub_82DF1C90(ctx, base);
	// 82AC207C: 397E0025  addi r11, r30, 0x25
	ctx.r[11].s64 = ctx.r[30].s64 + 37;
	// 82AC2080: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AC2084: 7C6BF82E  lwzx r3, r11, r31
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82AC2088: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC208C: 419A000C  beq cr6, 0x82ac2098
	if ctx.cr[6].eq {
	pc = 0x82AC2098; continue 'dispatch;
	}
	// 82AC2090: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AC2094: 483BF6AD  bl 0x82e81740
	ctx.lr = 0x82AC2098;
	sub_82E81740(ctx, base);
	// 82AC2098: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AC209C: 4832FBF5  bl 0x82df1c90
	ctx.lr = 0x82AC20A0;
	sub_82DF1C90(ctx, base);
	// 82AC20A0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AC20A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC20A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC20AC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AC20B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC20B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC20B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC20B8 size=108
    let mut pc: u32 = 0x82AC20B8;
    'dispatch: loop {
        match pc {
            0x82AC20B8 => {
    //   block [0x82AC20B8..0x82AC2124)
	// 82AC20B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC20BC: 486E60B1  bl 0x831a816c
	ctx.lr = 0x82AC20C0;
	sub_831A8130(ctx, base);
	// 82AC20C0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC20C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC20C8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AC20CC: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82AC20D0: 4BA4FA19  bl 0x82511ae8
	ctx.lr = 0x82AC20D4;
	sub_82511AE8(ctx, base);
	// 82AC20D4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC20D8: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82AC20DC: 807F0170  lwz r3, 0x170(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 82AC20E0: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 82AC20E4: 390B93AC  addi r8, r11, -0x6c54
	ctx.r[8].s64 = ctx.r[11].s64 + -27732;
	// 82AC20E8: 3CE08203  lis r7, -0x7dfd
	ctx.r[7].s64 = -2113732608;
	// 82AC20EC: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82AC20F0: C04B93AC  lfs f2, -0x6c54(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27732 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82AC20F4: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82AC20F8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC2128(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC2128 size=76
    let mut pc: u32 = 0x82AC2128;
    'dispatch: loop {
        match pc {
            0x82AC2128 => {
    //   block [0x82AC2128..0x82AC2174)
	// 82AC2128: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC212C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC2130: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC2134: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC2138: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AC213C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC2140: 48394289  bl 0x82e563c8
	ctx.lr = 0x82AC2144;
	sub_82E563C8(ctx, base);
	// 82AC2144: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AC2148: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC214C: 4BA4D9F5  bl 0x8250fb40
	ctx.lr = 0x82AC2150;
	sub_8250FB40(ctx, base);
	// 82AC2150: 807F0170  lwz r3, 0x170(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 82AC2154: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC2158: 419A0008  beq cr6, 0x82ac2160
	if ctx.cr[6].eq {
	pc = 0x82AC2160; continue 'dispatch;
	}
	// 82AC215C: 480188FD  bl 0x82adaa58
	ctx.lr = 0x82AC2160;
	sub_82ADAA58(ctx, base);
	// 82AC2160: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AC2164: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC2168: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC216C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC2170: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC2178(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC2178 size=236
    let mut pc: u32 = 0x82AC2178;
    'dispatch: loop {
        match pc {
            0x82AC2178 => {
    //   block [0x82AC2178..0x82AC2264)
	// 82AC2178: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC217C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC2180: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC2184: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC2188: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC218C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AC2190: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AC2194: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AC2198: 4BA4D199  bl 0x8250f330
	ctx.lr = 0x82AC219C;
	sub_8250F330(ctx, base);
	// 82AC219C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AC21A0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AC21A4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC21A8: 4BA28FB1  bl 0x824eb158
	ctx.lr = 0x82AC21AC;
	sub_824EB158(ctx, base);
	// 82AC21AC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AC21B0: 4832FAE1  bl 0x82df1c90
	ctx.lr = 0x82AC21B4;
	sub_82DF1C90(ctx, base);
	// 82AC21B4: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 82AC21B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC21BC: 388B57F4  addi r4, r11, 0x57f4
	ctx.r[4].s64 = ctx.r[11].s64 + 22516;
	// 82AC21C0: 48331849  bl 0x82df3a08
	ctx.lr = 0x82AC21C4;
	sub_82DF3A08(ctx, base);
	// 82AC21C4: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82AC21C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC21CC: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82AC21D0: 409A000C  bne cr6, 0x82ac21dc
	if !ctx.cr[6].eq {
	pc = 0x82AC21DC; continue 'dispatch;
	}
	// 82AC21D4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AC21D8: 419A000C  beq cr6, 0x82ac21e4
	if ctx.cr[6].eq {
	pc = 0x82AC21E4; continue 'dispatch;
	}
	// 82AC21DC: 3BEBFFFC  addi r31, r11, -4
	ctx.r[31].s64 = ctx.r[11].s64 + -4;
	// 82AC21E0: 48000008  b 0x82ac21e8
	pc = 0x82AC21E8; continue 'dispatch;
	// 82AC21E4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AC21E8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82AC21EC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AC21F0: 4BA3F289  bl 0x82501478
	ctx.lr = 0x82AC21F4;
	sub_82501478(ctx, base);
	// 82AC21F4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AC21F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC21FC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82AC2200: 4BA3DCE9  bl 0x824ffee8
	ctx.lr = 0x82AC2204;
	sub_824FFEE8(ctx, base);
	// 82AC2204: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82AC2208: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC220C: 396B0000  addi r11, r11, 0
	ctx.r[11].s64 = ctx.r[11].s64 + 0;
	// 82AC2210: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82AC2214: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82AC2218: 697F0001  xori r31, r11, 1
	ctx.r[31].u64 = ctx.r[11].u64 ^ 1;
	// 82AC221C: 4833120D  bl 0x82df3428
	ctx.lr = 0x82AC2220;
	sub_82DF3428(ctx, base);
	// 82AC2220: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC2224: 41820038  beq 0x82ac225c
	if ctx.cr[0].eq {
	pc = 0x82AC225C; continue 'dispatch;
	}
	// 82AC2228: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC222C: 4BFFFEFD  bl 0x82ac2128
	ctx.lr = 0x82AC2230;
	sub_82AC2128(ctx, base);
	// 82AC2230: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 82AC2234: 9BFE0124  stb r31, 0x124(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(292 as u32), ctx.r[31].u8 ) };
	// 82AC2238: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AC223C: 4832FA55  bl 0x82df1c90
	ctx.lr = 0x82AC2240;
	sub_82DF1C90(ctx, base);
	// 82AC2240: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC2244: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AC2248: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC224C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC2250: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AC2254: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC2258: 4E800020  blr
	return;
	// 82AC225C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AC2260: 4BFFFFD8  b 0x82ac2238
	pc = 0x82AC2238; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC2268(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC2268 size=196
    let mut pc: u32 = 0x82AC2268;
    'dispatch: loop {
        match pc {
            0x82AC2268 => {
    //   block [0x82AC2268..0x82AC232C)
	// 82AC2268: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC226C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC2270: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC2274: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC2278: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC227C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AC2280: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC2284: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82AC2288: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AC228C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC2290: 4B7FE6A9  bl 0x822c0938
	ctx.lr = 0x82AC2294;
	sub_822C0938(ctx, base);
	// 82AC2294: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC2298: 41820028  beq 0x82ac22c0
	if ctx.cr[0].eq {
	pc = 0x82AC22C0; continue 'dispatch;
	}
	// 82AC229C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC22A0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82AC22A4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AC22A8: 392B9400  addi r9, r11, -0x6c00
	ctx.r[9].s64 = ctx.r[11].s64 + -27648;
	// 82AC22AC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AC22B0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AC22B4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AC22B8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AC22BC: 48000008  b 0x82ac22c4
	pc = 0x82AC22C4; continue 'dispatch;
	// 82AC22C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC22C4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC22C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC22CC: 409A0044  bne cr6, 0x82ac2310
	if !ctx.cr[6].eq {
	pc = 0x82AC2310; continue 'dispatch;
	}
	// 82AC22D0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AC22D4: 419A001C  beq cr6, 0x82ac22f0
	if ctx.cr[6].eq {
	pc = 0x82AC22F0; continue 'dispatch;
	}
	// 82AC22D8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC22DC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AC22E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC22E4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC22E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AC22EC: 4E800421  bctrl
	ctx.lr = 0x82AC22F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AC22F0: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AC22F4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AC22F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC22FC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82AC2300: 816BF684  lwz r11, -0x97c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2428 as u32) ) } as u64;
	// 82AC2304: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AC2308: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AC230C: 4B7FDCF5  bl 0x822c0000
	ctx.lr = 0x82AC2310;
	sub_822C0000(ctx, base);
	// 82AC2310: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC2314: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC2318: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC231C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC2320: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AC2324: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC2328: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC2330(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC2330 size=196
    let mut pc: u32 = 0x82AC2330;
    'dispatch: loop {
        match pc {
            0x82AC2330 => {
    //   block [0x82AC2330..0x82AC23F4)
	// 82AC2330: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC2334: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC2338: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC233C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC2340: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC2344: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AC2348: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC234C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82AC2350: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AC2354: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC2358: 4B7FE5E1  bl 0x822c0938
	ctx.lr = 0x82AC235C;
	sub_822C0938(ctx, base);
	// 82AC235C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC2360: 41820028  beq 0x82ac2388
	if ctx.cr[0].eq {
	pc = 0x82AC2388; continue 'dispatch;
	}
	// 82AC2364: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC2368: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82AC236C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AC2370: 392B9414  addi r9, r11, -0x6bec
	ctx.r[9].s64 = ctx.r[11].s64 + -27628;
	// 82AC2374: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AC2378: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AC237C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AC2380: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AC2384: 48000008  b 0x82ac238c
	pc = 0x82AC238C; continue 'dispatch;
	// 82AC2388: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC238C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC2390: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC2394: 409A0044  bne cr6, 0x82ac23d8
	if !ctx.cr[6].eq {
	pc = 0x82AC23D8; continue 'dispatch;
	}
	// 82AC2398: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AC239C: 419A001C  beq cr6, 0x82ac23b8
	if ctx.cr[6].eq {
	pc = 0x82AC23B8; continue 'dispatch;
	}
	// 82AC23A0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC23A4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AC23A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC23AC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC23B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AC23B4: 4E800421  bctrl
	ctx.lr = 0x82AC23B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AC23B8: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AC23BC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AC23C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC23C4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82AC23C8: 816BF684  lwz r11, -0x97c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2428 as u32) ) } as u64;
	// 82AC23CC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AC23D0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AC23D4: 4B7FDC2D  bl 0x822c0000
	ctx.lr = 0x82AC23D8;
	sub_822C0000(ctx, base);
	// 82AC23D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC23DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC23E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC23E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC23E8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AC23EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC23F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC23F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC23F8 size=196
    let mut pc: u32 = 0x82AC23F8;
    'dispatch: loop {
        match pc {
            0x82AC23F8 => {
    //   block [0x82AC23F8..0x82AC24BC)
	// 82AC23F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC23FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC2400: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC2404: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC2408: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC240C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AC2410: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC2414: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82AC2418: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AC241C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC2420: 4B7FE519  bl 0x822c0938
	ctx.lr = 0x82AC2424;
	sub_822C0938(ctx, base);
	// 82AC2424: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC2428: 41820028  beq 0x82ac2450
	if ctx.cr[0].eq {
	pc = 0x82AC2450; continue 'dispatch;
	}
	// 82AC242C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC2430: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82AC2434: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AC2438: 392B9428  addi r9, r11, -0x6bd8
	ctx.r[9].s64 = ctx.r[11].s64 + -27608;
	// 82AC243C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AC2440: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AC2444: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AC2448: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AC244C: 48000008  b 0x82ac2454
	pc = 0x82AC2454; continue 'dispatch;
	// 82AC2450: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC2454: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC2458: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC245C: 409A0044  bne cr6, 0x82ac24a0
	if !ctx.cr[6].eq {
	pc = 0x82AC24A0; continue 'dispatch;
	}
	// 82AC2460: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AC2464: 419A001C  beq cr6, 0x82ac2480
	if ctx.cr[6].eq {
	pc = 0x82AC2480; continue 'dispatch;
	}
	// 82AC2468: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC246C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AC2470: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC2474: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC2478: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AC247C: 4E800421  bctrl
	ctx.lr = 0x82AC2480;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AC2480: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AC2484: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AC2488: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC248C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82AC2490: 816BF684  lwz r11, -0x97c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2428 as u32) ) } as u64;
	// 82AC2494: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AC2498: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AC249C: 4B7FDB65  bl 0x822c0000
	ctx.lr = 0x82AC24A0;
	sub_822C0000(ctx, base);
	// 82AC24A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC24A4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC24A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC24AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC24B0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AC24B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC24B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC24C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC24C0 size=196
    let mut pc: u32 = 0x82AC24C0;
    'dispatch: loop {
        match pc {
            0x82AC24C0 => {
    //   block [0x82AC24C0..0x82AC2584)
	// 82AC24C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC24C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC24C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC24CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC24D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC24D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AC24D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC24DC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82AC24E0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AC24E4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC24E8: 4B7FE451  bl 0x822c0938
	ctx.lr = 0x82AC24EC;
	sub_822C0938(ctx, base);
	// 82AC24EC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC24F0: 41820028  beq 0x82ac2518
	if ctx.cr[0].eq {
	pc = 0x82AC2518; continue 'dispatch;
	}
	// 82AC24F4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC24F8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82AC24FC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AC2500: 392B943C  addi r9, r11, -0x6bc4
	ctx.r[9].s64 = ctx.r[11].s64 + -27588;
	// 82AC2504: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AC2508: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AC250C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AC2510: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AC2514: 48000008  b 0x82ac251c
	pc = 0x82AC251C; continue 'dispatch;
	// 82AC2518: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC251C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC2520: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC2524: 409A0044  bne cr6, 0x82ac2568
	if !ctx.cr[6].eq {
	pc = 0x82AC2568; continue 'dispatch;
	}
	// 82AC2528: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AC252C: 419A001C  beq cr6, 0x82ac2548
	if ctx.cr[6].eq {
	pc = 0x82AC2548; continue 'dispatch;
	}
	// 82AC2530: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC2534: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AC2538: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC253C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC2540: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AC2544: 4E800421  bctrl
	ctx.lr = 0x82AC2548;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AC2548: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AC254C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AC2550: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC2554: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82AC2558: 816BF684  lwz r11, -0x97c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2428 as u32) ) } as u64;
	// 82AC255C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AC2560: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AC2564: 4B7FDA9D  bl 0x822c0000
	ctx.lr = 0x82AC2568;
	sub_822C0000(ctx, base);
	// 82AC2568: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC256C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC2570: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC2574: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC2578: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AC257C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC2580: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC2588(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC2588 size=196
    let mut pc: u32 = 0x82AC2588;
    'dispatch: loop {
        match pc {
            0x82AC2588 => {
    //   block [0x82AC2588..0x82AC264C)
	// 82AC2588: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC258C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC2590: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC2594: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC2598: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC259C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AC25A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC25A4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82AC25A8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AC25AC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC25B0: 4B7FE389  bl 0x822c0938
	ctx.lr = 0x82AC25B4;
	sub_822C0938(ctx, base);
	// 82AC25B4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC25B8: 41820028  beq 0x82ac25e0
	if ctx.cr[0].eq {
	pc = 0x82AC25E0; continue 'dispatch;
	}
	// 82AC25BC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC25C0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82AC25C4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AC25C8: 392B9450  addi r9, r11, -0x6bb0
	ctx.r[9].s64 = ctx.r[11].s64 + -27568;
	// 82AC25CC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AC25D0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AC25D4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AC25D8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AC25DC: 48000008  b 0x82ac25e4
	pc = 0x82AC25E4; continue 'dispatch;
	// 82AC25E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC25E4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC25E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC25EC: 409A0044  bne cr6, 0x82ac2630
	if !ctx.cr[6].eq {
	pc = 0x82AC2630; continue 'dispatch;
	}
	// 82AC25F0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AC25F4: 419A001C  beq cr6, 0x82ac2610
	if ctx.cr[6].eq {
	pc = 0x82AC2610; continue 'dispatch;
	}
	// 82AC25F8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC25FC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AC2600: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC2604: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC2608: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AC260C: 4E800421  bctrl
	ctx.lr = 0x82AC2610;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AC2610: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AC2614: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AC2618: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC261C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82AC2620: 816BF684  lwz r11, -0x97c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2428 as u32) ) } as u64;
	// 82AC2624: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AC2628: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AC262C: 4B7FD9D5  bl 0x822c0000
	ctx.lr = 0x82AC2630;
	sub_822C0000(ctx, base);
	// 82AC2630: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC2634: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC2638: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC263C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC2640: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AC2644: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC2648: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC2650(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC2650 size=196
    let mut pc: u32 = 0x82AC2650;
    'dispatch: loop {
        match pc {
            0x82AC2650 => {
    //   block [0x82AC2650..0x82AC2714)
	// 82AC2650: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC2654: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC2658: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC265C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC2660: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC2664: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AC2668: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC266C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82AC2670: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AC2674: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC2678: 4B7FE2C1  bl 0x822c0938
	ctx.lr = 0x82AC267C;
	sub_822C0938(ctx, base);
	// 82AC267C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC2680: 41820028  beq 0x82ac26a8
	if ctx.cr[0].eq {
	pc = 0x82AC26A8; continue 'dispatch;
	}
	// 82AC2684: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC2688: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82AC268C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AC2690: 392B9464  addi r9, r11, -0x6b9c
	ctx.r[9].s64 = ctx.r[11].s64 + -27548;
	// 82AC2694: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AC2698: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AC269C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AC26A0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AC26A4: 48000008  b 0x82ac26ac
	pc = 0x82AC26AC; continue 'dispatch;
	// 82AC26A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC26AC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC26B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC26B4: 409A0044  bne cr6, 0x82ac26f8
	if !ctx.cr[6].eq {
	pc = 0x82AC26F8; continue 'dispatch;
	}
	// 82AC26B8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AC26BC: 419A001C  beq cr6, 0x82ac26d8
	if ctx.cr[6].eq {
	pc = 0x82AC26D8; continue 'dispatch;
	}
	// 82AC26C0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC26C4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AC26C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC26CC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC26D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AC26D4: 4E800421  bctrl
	ctx.lr = 0x82AC26D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AC26D8: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AC26DC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AC26E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC26E4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82AC26E8: 816BF684  lwz r11, -0x97c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2428 as u32) ) } as u64;
	// 82AC26EC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AC26F0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AC26F4: 4B7FD90D  bl 0x822c0000
	ctx.lr = 0x82AC26F8;
	sub_822C0000(ctx, base);
	// 82AC26F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC26FC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC2700: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC2704: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC2708: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AC270C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC2710: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC2718(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC2718 size=196
    let mut pc: u32 = 0x82AC2718;
    'dispatch: loop {
        match pc {
            0x82AC2718 => {
    //   block [0x82AC2718..0x82AC27DC)
	// 82AC2718: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC271C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC2720: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC2724: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC2728: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC272C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AC2730: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC2734: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82AC2738: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AC273C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC2740: 4B7FE1F9  bl 0x822c0938
	ctx.lr = 0x82AC2744;
	sub_822C0938(ctx, base);
	// 82AC2744: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC2748: 41820028  beq 0x82ac2770
	if ctx.cr[0].eq {
	pc = 0x82AC2770; continue 'dispatch;
	}
	// 82AC274C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC2750: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82AC2754: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AC2758: 392B9478  addi r9, r11, -0x6b88
	ctx.r[9].s64 = ctx.r[11].s64 + -27528;
	// 82AC275C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AC2760: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AC2764: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AC2768: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AC276C: 48000008  b 0x82ac2774
	pc = 0x82AC2774; continue 'dispatch;
	// 82AC2770: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC2774: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC2778: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC277C: 409A0044  bne cr6, 0x82ac27c0
	if !ctx.cr[6].eq {
	pc = 0x82AC27C0; continue 'dispatch;
	}
	// 82AC2780: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AC2784: 419A001C  beq cr6, 0x82ac27a0
	if ctx.cr[6].eq {
	pc = 0x82AC27A0; continue 'dispatch;
	}
	// 82AC2788: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC278C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AC2790: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC2794: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC2798: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AC279C: 4E800421  bctrl
	ctx.lr = 0x82AC27A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AC27A0: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AC27A4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AC27A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC27AC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82AC27B0: 816BF684  lwz r11, -0x97c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2428 as u32) ) } as u64;
	// 82AC27B4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AC27B8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AC27BC: 4B7FD845  bl 0x822c0000
	ctx.lr = 0x82AC27C0;
	sub_822C0000(ctx, base);
	// 82AC27C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC27C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC27C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC27CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC27D0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AC27D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC27D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC27E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC27E0 size=196
    let mut pc: u32 = 0x82AC27E0;
    'dispatch: loop {
        match pc {
            0x82AC27E0 => {
    //   block [0x82AC27E0..0x82AC28A4)
	// 82AC27E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC27E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC27E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC27EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC27F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC27F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AC27F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC27FC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82AC2800: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AC2804: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC2808: 4B7FE131  bl 0x822c0938
	ctx.lr = 0x82AC280C;
	sub_822C0938(ctx, base);
	// 82AC280C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC2810: 41820028  beq 0x82ac2838
	if ctx.cr[0].eq {
	pc = 0x82AC2838; continue 'dispatch;
	}
	// 82AC2814: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC2818: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82AC281C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AC2820: 392B948C  addi r9, r11, -0x6b74
	ctx.r[9].s64 = ctx.r[11].s64 + -27508;
	// 82AC2824: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AC2828: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AC282C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AC2830: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AC2834: 48000008  b 0x82ac283c
	pc = 0x82AC283C; continue 'dispatch;
	// 82AC2838: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC283C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC2840: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC2844: 409A0044  bne cr6, 0x82ac2888
	if !ctx.cr[6].eq {
	pc = 0x82AC2888; continue 'dispatch;
	}
	// 82AC2848: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AC284C: 419A001C  beq cr6, 0x82ac2868
	if ctx.cr[6].eq {
	pc = 0x82AC2868; continue 'dispatch;
	}
	// 82AC2850: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC2854: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AC2858: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC285C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC2860: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AC2864: 4E800421  bctrl
	ctx.lr = 0x82AC2868;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AC2868: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AC286C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AC2870: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC2874: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82AC2878: 816BF684  lwz r11, -0x97c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2428 as u32) ) } as u64;
	// 82AC287C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AC2880: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AC2884: 4B7FD77D  bl 0x822c0000
	ctx.lr = 0x82AC2888;
	sub_822C0000(ctx, base);
	// 82AC2888: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC288C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC2890: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC2894: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC2898: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AC289C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC28A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC28A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC28A8 size=196
    let mut pc: u32 = 0x82AC28A8;
    'dispatch: loop {
        match pc {
            0x82AC28A8 => {
    //   block [0x82AC28A8..0x82AC296C)
	// 82AC28A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC28AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC28B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC28B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC28B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC28BC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AC28C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC28C4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82AC28C8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AC28CC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC28D0: 4B7FE069  bl 0x822c0938
	ctx.lr = 0x82AC28D4;
	sub_822C0938(ctx, base);
	// 82AC28D4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC28D8: 41820028  beq 0x82ac2900
	if ctx.cr[0].eq {
	pc = 0x82AC2900; continue 'dispatch;
	}
	// 82AC28DC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC28E0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82AC28E4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AC28E8: 392B94A0  addi r9, r11, -0x6b60
	ctx.r[9].s64 = ctx.r[11].s64 + -27488;
	// 82AC28EC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AC28F0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AC28F4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AC28F8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AC28FC: 48000008  b 0x82ac2904
	pc = 0x82AC2904; continue 'dispatch;
	// 82AC2900: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC2904: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC2908: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC290C: 409A0044  bne cr6, 0x82ac2950
	if !ctx.cr[6].eq {
	pc = 0x82AC2950; continue 'dispatch;
	}
	// 82AC2910: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AC2914: 419A001C  beq cr6, 0x82ac2930
	if ctx.cr[6].eq {
	pc = 0x82AC2930; continue 'dispatch;
	}
	// 82AC2918: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC291C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AC2920: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC2924: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC2928: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AC292C: 4E800421  bctrl
	ctx.lr = 0x82AC2930;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AC2930: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AC2934: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AC2938: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC293C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82AC2940: 816BF684  lwz r11, -0x97c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2428 as u32) ) } as u64;
	// 82AC2944: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AC2948: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AC294C: 4B7FD6B5  bl 0x822c0000
	ctx.lr = 0x82AC2950;
	sub_822C0000(ctx, base);
	// 82AC2950: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC2954: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC2958: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC295C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC2960: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AC2964: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC2968: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC2970(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC2970 size=196
    let mut pc: u32 = 0x82AC2970;
    'dispatch: loop {
        match pc {
            0x82AC2970 => {
    //   block [0x82AC2970..0x82AC2A34)
	// 82AC2970: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC2974: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC2978: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC297C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC2980: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC2984: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AC2988: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC298C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82AC2990: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AC2994: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC2998: 4B7FDFA1  bl 0x822c0938
	ctx.lr = 0x82AC299C;
	sub_822C0938(ctx, base);
	// 82AC299C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC29A0: 41820028  beq 0x82ac29c8
	if ctx.cr[0].eq {
	pc = 0x82AC29C8; continue 'dispatch;
	}
	// 82AC29A4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC29A8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82AC29AC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AC29B0: 392B94B4  addi r9, r11, -0x6b4c
	ctx.r[9].s64 = ctx.r[11].s64 + -27468;
	// 82AC29B4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AC29B8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AC29BC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AC29C0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AC29C4: 48000008  b 0x82ac29cc
	pc = 0x82AC29CC; continue 'dispatch;
	// 82AC29C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC29CC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC29D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC29D4: 409A0044  bne cr6, 0x82ac2a18
	if !ctx.cr[6].eq {
	pc = 0x82AC2A18; continue 'dispatch;
	}
	// 82AC29D8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AC29DC: 419A001C  beq cr6, 0x82ac29f8
	if ctx.cr[6].eq {
	pc = 0x82AC29F8; continue 'dispatch;
	}
	// 82AC29E0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC29E4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AC29E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC29EC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC29F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AC29F4: 4E800421  bctrl
	ctx.lr = 0x82AC29F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AC29F8: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AC29FC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AC2A00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC2A04: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82AC2A08: 816BF684  lwz r11, -0x97c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2428 as u32) ) } as u64;
	// 82AC2A0C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AC2A10: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AC2A14: 4B7FD5ED  bl 0x822c0000
	ctx.lr = 0x82AC2A18;
	sub_822C0000(ctx, base);
	// 82AC2A18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC2A1C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC2A20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC2A24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC2A28: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AC2A2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC2A30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC2A38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AC2A38 size=12
    let mut pc: u32 = 0x82AC2A38;
    'dispatch: loop {
        match pc {
            0x82AC2A38 => {
    //   block [0x82AC2A38..0x82AC2A44)
	// 82AC2A38: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AC2A3C: 99630124  stb r11, 0x124(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(292 as u32), ctx.r[11].u8 ) };
	// 82AC2A40: 4BFFF6E8  b 0x82ac2128
	sub_82AC2128(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC2A48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC2A48 size=84
    let mut pc: u32 = 0x82AC2A48;
    'dispatch: loop {
        match pc {
            0x82AC2A48 => {
    //   block [0x82AC2A48..0x82AC2A9C)
	// 82AC2A48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC2A4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC2A50: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC2A54: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC2A58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC2A5C: 39630038  addi r11, r3, 0x38
	ctx.r[11].s64 = ctx.r[3].s64 + 56;
	// 82AC2A60: 3BC00006  li r30, 6
	ctx.r[30].s64 = 6;
	// 82AC2A64: 3BEB0004  addi r31, r11, 4
	ctx.r[31].s64 = ctx.r[11].s64 + 4;
	// 82AC2A68: 3BFFFFF8  addi r31, r31, -8
	ctx.r[31].s64 = ctx.r[31].s64 + -8;
	// 82AC2A6C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC2A70: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC2A74: 419A0008  beq cr6, 0x82ac2a7c
	if ctx.cr[6].eq {
	pc = 0x82AC2A7C; continue 'dispatch;
	}
	// 82AC2A78: 4B7FDE19  bl 0x822c0890
	ctx.lr = 0x82AC2A7C;
	sub_822C0890(ctx, base);
	// 82AC2A7C: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82AC2A80: 4080FFE8  bge 0x82ac2a68
	if !ctx.cr[0].lt {
	pc = 0x82AC2A68; continue 'dispatch;
	}
	// 82AC2A84: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC2A88: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC2A8C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC2A90: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AC2A94: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC2A98: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC2AA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC2AA0 size=236
    let mut pc: u32 = 0x82AC2AA0;
    'dispatch: loop {
        match pc {
            0x82AC2AA0 => {
    //   block [0x82AC2AA0..0x82AC2B8C)
	// 82AC2AA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC2AA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC2AA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC2AAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC2AB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC2AB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC2AB8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC2ABC: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82AC2AC0: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 82AC2AC4: 396B952C  addi r11, r11, -0x6ad4
	ctx.r[11].s64 = ctx.r[11].s64 + -27348;
	// 82AC2AC8: 807F00EC  lwz r3, 0xec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82AC2ACC: 394A9518  addi r10, r10, -0x6ae8
	ctx.r[10].s64 = ctx.r[10].s64 + -27368;
	// 82AC2AD0: 392994CC  addi r9, r9, -0x6b34
	ctx.r[9].s64 = ctx.r[9].s64 + -27444;
	// 82AC2AD4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC2AD8: 3BDF00E4  addi r30, r31, 0xe4
	ctx.r[30].s64 = ctx.r[31].s64 + 228;
	// 82AC2ADC: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82AC2AE0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC2AE4: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 82AC2AE8: 419A0018  beq cr6, 0x82ac2b00
	if ctx.cr[6].eq {
	pc = 0x82AC2B00; continue 'dispatch;
	}
	// 82AC2AEC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC2AF0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AC2AF4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AC2AF8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AC2AFC: 4E800421  bctrl
	ctx.lr = 0x82AC2B00;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AC2B00: 807F00F0  lwz r3, 0xf0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 82AC2B04: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC2B08: 419A0018  beq cr6, 0x82ac2b20
	if ctx.cr[6].eq {
	pc = 0x82AC2B20; continue 'dispatch;
	}
	// 82AC2B0C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC2B10: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AC2B14: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC2B18: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AC2B1C: 4E800421  bctrl
	ctx.lr = 0x82AC2B20;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AC2B20: 807F00F4  lwz r3, 0xf4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 82AC2B24: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC2B28: 419A0018  beq cr6, 0x82ac2b40
	if ctx.cr[6].eq {
	pc = 0x82AC2B40; continue 'dispatch;
	}
	// 82AC2B2C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC2B30: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AC2B34: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC2B38: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AC2B3C: 4E800421  bctrl
	ctx.lr = 0x82AC2B40;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AC2B40: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82AC2B44: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC2B48: 916AE634  stw r11, -0x19cc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-6604 as u32), ctx.r[11].u32 ) };
	// 82AC2B4C: 807F0174  lwz r3, 0x174(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(372 as u32) ) } as u64;
	// 82AC2B50: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC2B54: 419A0008  beq cr6, 0x82ac2b5c
	if ctx.cr[6].eq {
	pc = 0x82AC2B5C; continue 'dispatch;
	}
	// 82AC2B58: 4B7FDD39  bl 0x822c0890
	ctx.lr = 0x82AC2B5C;
	sub_822C0890(ctx, base);
	// 82AC2B5C: 387F0128  addi r3, r31, 0x128
	ctx.r[3].s64 = ctx.r[31].s64 + 296;
	// 82AC2B60: 4BFFFEE9  bl 0x82ac2a48
	ctx.lr = 0x82AC2B64;
	sub_82AC2A48(ctx, base);
	// 82AC2B64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC2B68: 4BCE4AF1  bl 0x827a7658
	ctx.lr = 0x82AC2B6C;
	sub_827A7658(ctx, base);
	// 82AC2B6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC2B70: 4B88C7E1  bl 0x8234f350
	ctx.lr = 0x82AC2B74;
	sub_8234F350(ctx, base);
	// 82AC2B74: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC2B78: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC2B7C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC2B80: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AC2B84: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC2B88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC2B90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AC2B90 size=8
    let mut pc: u32 = 0x82AC2B90;
    'dispatch: loop {
        match pc {
            0x82AC2B90 => {
    //   block [0x82AC2B90..0x82AC2B98)
	// 82AC2B90: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 82AC2B94: 4800127C  b 0x82ac3e10
	sub_82AC3E10(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC2B98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AC2B98 size=8
    let mut pc: u32 = 0x82AC2B98;
    'dispatch: loop {
        match pc {
            0x82AC2B98 => {
    //   block [0x82AC2B98..0x82AC2BA0)
	// 82AC2B98: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 82AC2B9C: 48001274  b 0x82ac3e10
	sub_82AC3E10(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC2BA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC2BA0 size=584
    let mut pc: u32 = 0x82AC2BA0;
    'dispatch: loop {
        match pc {
            0x82AC2BA0 => {
    //   block [0x82AC2BA0..0x82AC2DE8)
	// 82AC2BA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC2BA4: 486E55BD  bl 0x831a8160
	ctx.lr = 0x82AC2BA8;
	sub_831A8130(ctx, base);
	// 82AC2BA8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC2BAC: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82AC2BB0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC2BB4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82AC2BB8: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 82AC2BBC: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82AC2BC0: 4BA4EE19  bl 0x825119d8
	ctx.lr = 0x82AC2BC4;
	sub_825119D8(ctx, base);
	// 82AC2BC4: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82AC2BC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC2BCC: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 82AC2BD0: 48330E39  bl 0x82df3a08
	ctx.lr = 0x82AC2BD4;
	sub_82DF3A08(ctx, base);
	// 82AC2BD4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AC2BD8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AC2BDC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC2BE0: 4BA45BA1  bl 0x82508780
	ctx.lr = 0x82AC2BE4;
	sub_82508780(ctx, base);
	// 82AC2BE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC2BE8: 48330841  bl 0x82df3428
	ctx.lr = 0x82AC2BEC;
	sub_82DF3428(ctx, base);
	// 82AC2BEC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AC2BF0: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 82AC2BF4: 409A0008  bne cr6, 0x82ac2bfc
	if !ctx.cr[6].eq {
	pc = 0x82AC2BFC; continue 'dispatch;
	}
	// 82AC2BF8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AC2BFC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC2C00: 4BA45BA1  bl 0x825087a0
	ctx.lr = 0x82AC2C04;
	sub_825087A0(ctx, base);
	// 82AC2C04: 3B5F0028  addi r26, r31, 0x28
	ctx.r[26].s64 = ctx.r[31].s64 + 40;
	// 82AC2C08: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82AC2C0C: 485463AD  bl 0x83008fb8
	ctx.lr = 0x82AC2C10;
	sub_83008FB8(ctx, base);
	// 82AC2C10: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82AC2C14: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC2C18: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AC2C1C: 3BAB9568  addi r29, r11, -0x6a98
	ctx.r[29].s64 = ctx.r[11].s64 + -27288;
	// 82AC2C20: 38A000B6  li r5, 0xb6
	ctx.r[5].s64 = 182;
	// 82AC2C24: 906AE634  stw r3, -0x19cc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-6604 as u32), ctx.r[3].u32 ) };
	// 82AC2C28: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AC2C2C: 38600044  li r3, 0x44
	ctx.r[3].s64 = 68;
	// 82AC2C30: 4B7FD7A9  bl 0x822c03d8
	ctx.lr = 0x82AC2C34;
	sub_822C03D8(ctx, base);
	// 82AC2C34: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82AC2C38: 4182002C  beq 0x82ac2c64
	if ctx.cr[0].eq {
	pc = 0x82AC2C64; continue 'dispatch;
	}
	// 82AC2C3C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC2C40: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AC2C44: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 82AC2C48: 4BA4C881  bl 0x8250f4c8
	ctx.lr = 0x82AC2C4C;
	sub_8250F4C8(ctx, base);
	// 82AC2C4C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82AC2C50: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82AC2C54: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC2C58: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC2C5C: 480031F5  bl 0x82ac5e50
	ctx.lr = 0x82AC2C60;
	sub_82AC5E50(ctx, base);
	// 82AC2C60: 48000008  b 0x82ac2c68
	pc = 0x82AC2C68; continue 'dispatch;
	// 82AC2C64: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AC2C68: 576B07FF  clrlwi. r11, r27, 0x1f
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC2C6C: 907F00F0  stw r3, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[3].u32 ) };
	// 82AC2C70: 4182000C  beq 0x82ac2c7c
	if ctx.cr[0].eq {
	pc = 0x82AC2C7C; continue 'dispatch;
	}
	// 82AC2C74: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AC2C78: 4832F019  bl 0x82df1c90
	ctx.lr = 0x82AC2C7C;
	sub_82DF1C90(ctx, base);
	// 82AC2C7C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AC2C80: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AC2C84: 38A000B8  li r5, 0xb8
	ctx.r[5].s64 = 184;
	// 82AC2C88: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82AC2C8C: 4B7FD74D  bl 0x822c03d8
	ctx.lr = 0x82AC2C90;
	sub_822C03D8(ctx, base);
	// 82AC2C90: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC2C94: 41820010  beq 0x82ac2ca4
	if ctx.cr[0].eq {
	pc = 0x82AC2CA4; continue 'dispatch;
	}
	// 82AC2C98: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC2C9C: 4800325D  bl 0x82ac5ef8
	ctx.lr = 0x82AC2CA0;
	sub_82AC5EF8(ctx, base);
	// 82AC2CA0: 48000008  b 0x82ac2ca8
	pc = 0x82AC2CA8; continue 'dispatch;
	// 82AC2CA4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AC2CA8: 907F00F4  stw r3, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[3].u32 ) };
	// 82AC2CAC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AC2CB0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AC2CB4: 38A000BA  li r5, 0xba
	ctx.r[5].s64 = 186;
	// 82AC2CB8: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 82AC2CBC: 4832F72D  bl 0x82df23e8
	ctx.lr = 0x82AC2CC0;
	sub_82DF23E8(ctx, base);
	// 82AC2CC0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC2CC4: 41820010  beq 0x82ac2cd4
	if ctx.cr[0].eq {
	pc = 0x82AC2CD4; continue 'dispatch;
	}
	// 82AC2CC8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC2CCC: 48003FC5  bl 0x82ac6c90
	ctx.lr = 0x82AC2CD0;
	sub_82AC6C90(ctx, base);
	// 82AC2CD0: 48000008  b 0x82ac2cd8
	pc = 0x82AC2CD8; continue 'dispatch;
	// 82AC2CD4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AC2CD8: 907F00EC  stw r3, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[3].u32 ) };
	// 82AC2CDC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AC2CE0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AC2CE4: 38A000BD  li r5, 0xbd
	ctx.r[5].s64 = 189;
	// 82AC2CE8: 38600124  li r3, 0x124
	ctx.r[3].s64 = 292;
	// 82AC2CEC: 4832F6FD  bl 0x82df23e8
	ctx.lr = 0x82AC2CF0;
	sub_82DF23E8(ctx, base);
	// 82AC2CF0: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82AC2CF4: 4182002C  beq 0x82ac2d20
	if ctx.cr[0].eq {
	pc = 0x82AC2D20; continue 'dispatch;
	}
	// 82AC2CF8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82AC2CFC: 485462BD  bl 0x83008fb8
	ctx.lr = 0x82AC2D00;
	sub_83008FB8(ctx, base);
	// 82AC2D00: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AC2D04: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AC2D08: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC2D0C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82AC2D10: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC2D14: 4800E7CD  bl 0x82ad14e0
	ctx.lr = 0x82AC2D18;
	sub_82AD14E0(ctx, base);
	// 82AC2D18: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AC2D1C: 48000008  b 0x82ac2d24
	pc = 0x82AC2D24; continue 'dispatch;
	// 82AC2D20: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82AC2D24: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82AC2D28: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AC2D2C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AC2D30: 4BFFF601  bl 0x82ac2330
	ctx.lr = 0x82AC2D34;
	sub_82AC2330(ctx, base);
	// 82AC2D34: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82AC2D38: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AC2D3C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AC2D40: 4B7FD2C1  bl 0x822c0000
	ctx.lr = 0x82AC2D44;
	sub_822C0000(ctx, base);
	// 82AC2D44: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AC2D48: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AC2D4C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82AC2D50: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82AC2D54: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82AC2D58: 419A0024  beq cr6, 0x82ac2d7c
	if ctx.cr[6].eq {
	pc = 0x82AC2D7C; continue 'dispatch;
	}
	// 82AC2D5C: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82AC2D60: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AC2D64: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AC2D68: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AC2D6C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AC2D70: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AC2D74: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AC2D78: 4082FFE8  bne 0x82ac2d60
	if !ctx.cr[0].eq {
	pc = 0x82AC2D60; continue 'dispatch;
	}
	// 82AC2D7C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC2D80: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AC2D84: 4BA4C745  bl 0x8250f4c8
	ctx.lr = 0x82AC2D88;
	sub_8250F4C8(ctx, base);
	// 82AC2D88: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC2D8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC2D90: 3BCBFFFC  addi r30, r11, -4
	ctx.r[30].s64 = ctx.r[11].s64 + -4;
	// 82AC2D94: 409A0008  bne cr6, 0x82ac2d9c
	if !ctx.cr[6].eq {
	pc = 0x82AC2D9C; continue 'dispatch;
	}
	// 82AC2D98: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82AC2D9C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC2DA0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82AC2DA4: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 82AC2DA8: 4BA4C771  bl 0x8250f518
	ctx.lr = 0x82AC2DAC;
	sub_8250F518(ctx, base);
	// 82AC2DAC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AC2DB0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC2DB4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82AC2DB8: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82AC2DBC: 4BA4A74D  bl 0x8250d508
	ctx.lr = 0x82AC2DC0;
	sub_8250D508(ctx, base);
	// 82AC2DC0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AC2DC4: 4832EECD  bl 0x82df1c90
	ctx.lr = 0x82AC2DC8;
	sub_82DF1C90(ctx, base);
	// 82AC2DC8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82AC2DCC: 4832EEC5  bl 0x82df1c90
	ctx.lr = 0x82AC2DD0;
	sub_82DF1C90(ctx, base);
	// 82AC2DD0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82AC2DD4: 419A000C  beq cr6, 0x82ac2de0
	if ctx.cr[6].eq {
	pc = 0x82AC2DE0; continue 'dispatch;
	}
	// 82AC2DD8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC2DDC: 4B7FDAB5  bl 0x822c0890
	ctx.lr = 0x82AC2DE0;
	sub_822C0890(ctx, base);
	// 82AC2DE0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82AC2DE4: 486E53CC  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC2DE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AC2DE8 size=208
    let mut pc: u32 = 0x82AC2DE8;
    'dispatch: loop {
        match pc {
            0x82AC2DE8 => {
    //   block [0x82AC2DE8..0x82AC2EB8)
	// 82AC2DE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC2DEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC2DF0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC2DF4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC2DF8: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82AC2DFC: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC2EB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC2EB8 size=448
    let mut pc: u32 = 0x82AC2EB8;
    'dispatch: loop {
        match pc {
            0x82AC2EB8 => {
    //   block [0x82AC2EB8..0x82AC3078)
	// 82AC2EB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC2EBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC2EC0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC2EC4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC2EC8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC2ECC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC2ED0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AC2ED4: 54AB063F  clrlwi. r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC2ED8: 40820028  bne 0x82ac2f00
	if !ctx.cr[0].eq {
	pc = 0x82AC2F00; continue 'dispatch;
	}
	// 82AC2EDC: 807F00EC  lwz r3, 0xec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82AC2EE0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC2EE4: 409A000C  bne cr6, 0x82ac2ef0
	if !ctx.cr[6].eq {
	pc = 0x82AC2EF0; continue 'dispatch;
	}
	// 82AC2EE8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82AC2EEC: 48000008  b 0x82ac2ef4
	pc = 0x82AC2EF4; continue 'dispatch;
	// 82AC2EF0: 4BFA0E01  bl 0x82a63cf0
	ctx.lr = 0x82AC2EF4;
	sub_82A63CF0(ctx, base);
	// 82AC2EF4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82AC2EF8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82AC2EFC: 419A0160  beq cr6, 0x82ac305c
	if ctx.cr[6].eq {
	pc = 0x82AC305C; continue 'dispatch;
	}
	// 82AC2F00: 2B1E0009  cmplwi cr6, r30, 9
	ctx.cr[6].compare_u32(ctx.r[30].u32, 9 as u32, &mut ctx.xer);
	// 82AC2F04: 41990158  bgt cr6, 0x82ac305c
	if ctx.cr[6].gt {
	pc = 0x82AC305C; continue 'dispatch;
	}
	// 82AC2F08: 3D80820C  lis r12, -0x7df4
	ctx.r[12].s64 = -2113142784;
	// 82AC2F0C: 398C93D8  addi r12, r12, -0x6c28
	ctx.r[12].s64 = ctx.r[12].s64 + -27688;
	// 82AC2F10: 7C0CF0AE  lbzx r0, r12, r30
	ctx.r[0].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82AC2F14: 5400103A  slwi r0, r0, 2
	ctx.r[0].u32 = ctx.r[0].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 82AC2F18: 3D8082AC  lis r12, -0x7d54
	ctx.r[12].s64 = -2102657024;
	// 82AC2F1C: 398C2F30  addi r12, r12, 0x2f30
	ctx.r[12].s64 = ctx.r[12].s64 + 12080;
	// 82AC2F20: 7D8C0214  add r12, r12, r0
	ctx.r[12].u64 = ctx.r[12].u64 + ctx.r[0].u64;
	// 82AC2F24: 7D8903A6  mtctr r12
	ctx.ctr.u64 = ctx.r[12].u64;
	// 82AC2F28: 60000000  nop
	// 82AC2F2C: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
	// 82AC2F30: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 82AC2F34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC2F38: 388B6564  addi r4, r11, 0x6564
	ctx.r[4].s64 = ctx.r[11].s64 + 25956;
	// 82AC2F3C: 48330ACD  bl 0x82df3a08
	ctx.lr = 0x82AC2F40;
	sub_82DF3A08(ctx, base);
	// 82AC2F40: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AC2F44: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AC2F48: 809F00EC  lwz r4, 0xec(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82AC2F4C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82AC2F50: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AC2F54: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82AC2F58: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC2F5C: 4839BA05  bl 0x82e5e960
	ctx.lr = 0x82AC2F60;
	sub_82E5E960(ctx, base);
	// 82AC2F60: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82AC2F64: 480000E0  b 0x82ac3044
	pc = 0x82AC3044; continue 'dispatch;
	// 82AC2F68: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC2F6C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AC2F70: 388B95B0  addi r4, r11, -0x6a50
	ctx.r[4].s64 = ctx.r[11].s64 + -27216;
	// 82AC2F74: 48330A95  bl 0x82df3a08
	ctx.lr = 0x82AC2F78;
	sub_82DF3A08(ctx, base);
	// 82AC2F78: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AC2F7C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AC2F80: 809F00EC  lwz r4, 0xec(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82AC2F84: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AC2F88: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AC2F8C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82AC2F90: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC2F94: 4839B9CD  bl 0x82e5e960
	ctx.lr = 0x82AC2F98;
	sub_82E5E960(ctx, base);
	// 82AC2F98: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82AC2F9C: 480000A8  b 0x82ac3044
	pc = 0x82AC3044; continue 'dispatch;
	// 82AC2FA0: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82AC2FA4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AC2FA8: 388BCB24  addi r4, r11, -0x34dc
	ctx.r[4].s64 = ctx.r[11].s64 + -13532;
	// 82AC2FAC: 48330A5D  bl 0x82df3a08
	ctx.lr = 0x82AC2FB0;
	sub_82DF3A08(ctx, base);
	// 82AC2FB0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AC2FB4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AC2FB8: 809F00EC  lwz r4, 0xec(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82AC2FBC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AC2FC0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AC2FC4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82AC2FC8: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC2FCC: 4839B995  bl 0x82e5e960
	ctx.lr = 0x82AC2FD0;
	sub_82E5E960(ctx, base);
	// 82AC2FD0: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82AC2FD4: 48000070  b 0x82ac3044
	pc = 0x82AC3044; continue 'dispatch;
	// 82AC2FD8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AC2FDC: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82AC2FE0: 388B0740  addi r4, r11, 0x740
	ctx.r[4].s64 = ctx.r[11].s64 + 1856;
	// 82AC2FE4: 48330A25  bl 0x82df3a08
	ctx.lr = 0x82AC2FE8;
	sub_82DF3A08(ctx, base);
	// 82AC2FE8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AC2FEC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AC2FF0: 809F00EC  lwz r4, 0xec(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82AC2FF4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82AC2FF8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AC2FFC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82AC3000: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC3004: 4839B95D  bl 0x82e5e960
	ctx.lr = 0x82AC3008;
	sub_82E5E960(ctx, base);
	// 82AC3008: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82AC300C: 48000038  b 0x82ac3044
	pc = 0x82AC3044; continue 'dispatch;
	// 82AC3010: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82AC3014: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AC3018: 388B4418  addi r4, r11, 0x4418
	ctx.r[4].s64 = ctx.r[11].s64 + 17432;
	// 82AC301C: 483309ED  bl 0x82df3a08
	ctx.lr = 0x82AC3020;
	sub_82DF3A08(ctx, base);
	// 82AC3020: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AC3024: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AC3028: 809F00EC  lwz r4, 0xec(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82AC302C: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82AC3030: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AC3034: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82AC3038: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC303C: 4839B925  bl 0x82e5e960
	ctx.lr = 0x82AC3040;
	sub_82E5E960(ctx, base);
	// 82AC3040: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82AC3044: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC3048: 419A0008  beq cr6, 0x82ac3050
	if ctx.cr[6].eq {
	pc = 0x82AC3050; continue 'dispatch;
	}
	// 82AC304C: 4B7FD845  bl 0x822c0890
	ctx.lr = 0x82AC3050;
	sub_822C0890(ctx, base);
	// 82AC3050: 93DF0114  stw r30, 0x114(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), ctx.r[30].u32 ) };
	// 82AC3054: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82AC3058: 48000008  b 0x82ac3060
	pc = 0x82AC3060; continue 'dispatch;
	// 82AC305C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AC3060: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82AC3064: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC3068: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC306C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AC3070: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC3074: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC3078(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC3078 size=1148
    let mut pc: u32 = 0x82AC3078;
    'dispatch: loop {
        match pc {
            0x82AC3078 => {
    //   block [0x82AC3078..0x82AC34F4)
	// 82AC3078: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC307C: 486E50E5  bl 0x831a8160
	ctx.lr = 0x82AC3080;
	sub_831A8130(ctx, base);
	// 82AC3080: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC3084: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AC3088: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AC308C: 397E0025  addi r11, r30, 0x25
	ctx.r[11].s64 = ctx.r[30].s64 + 37;
	// 82AC3090: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AC3094: 7F8BEA14  add r28, r11, r29
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82AC3098: 7C6BE82E  lwzx r3, r11, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82AC309C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC30A0: 419A0018  beq cr6, 0x82ac30b8
	if ctx.cr[6].eq {
	pc = 0x82AC30B8; continue 'dispatch;
	}
	// 82AC30A4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC30A8: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82AC30AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AC30B0: 4E800421  bctrl
	ctx.lr = 0x82AC30B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AC30B4: 48000244  b 0x82ac32f8
	pc = 0x82AC32F8; continue 'dispatch;
	// 82AC30B8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AC30BC: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82AC30C0: 4BA4C409  bl 0x8250f4c8
	ctx.lr = 0x82AC30C4;
	sub_8250F4C8(ctx, base);
	// 82AC30C4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC30C8: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82AC30CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC30D0: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82AC30D4: 409A0008  bne cr6, 0x82ac30dc
	if !ctx.cr[6].eq {
	pc = 0x82AC30DC; continue 'dispatch;
	}
	// 82AC30D8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82AC30DC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82AC30E0: 4BA47871  bl 0x8250a950
	ctx.lr = 0x82AC30E4;
	sub_8250A950(ctx, base);
	// 82AC30E4: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82AC30E8: 4832EBA9  bl 0x82df1c90
	ctx.lr = 0x82AC30EC;
	sub_82DF1C90(ctx, base);
	// 82AC30EC: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 82AC30F0: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 82AC30F4: 807D00F0  lwz r3, 0xf0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(240 as u32) ) } as u64;
	// 82AC30F8: 4BF55E11  bl 0x82a18f08
	ctx.lr = 0x82AC30FC;
	sub_82A18F08(ctx, base);
	// 82AC30FC: 83430004  lwz r26, 4(r3)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AC3100: 83E30000  lwz r31, 0(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC3104: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82AC3108: 419A0024  beq cr6, 0x82ac312c
	if ctx.cr[6].eq {
	pc = 0x82AC312C; continue 'dispatch;
	}
	// 82AC310C: 397A0004  addi r11, r26, 4
	ctx.r[11].s64 = ctx.r[26].s64 + 4;
	// 82AC3110: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AC3114: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AC3118: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AC311C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AC3120: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AC3124: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AC3128: 4082FFE8  bne 0x82ac3110
	if !ctx.cr[0].eq {
	pc = 0x82AC3110; continue 'dispatch;
	}
	// 82AC312C: 2F1E0001  cmpwi cr6, r30, 1
	ctx.cr[6].compare_i32(ctx.r[30].s32, 1, &mut ctx.xer);
	// 82AC3130: 419A0204  beq cr6, 0x82ac3334
	if ctx.cr[6].eq {
	pc = 0x82AC3334; continue 'dispatch;
	}
	// 82AC3134: 2F1E0002  cmpwi cr6, r30, 2
	ctx.cr[6].compare_i32(ctx.r[30].s32, 2, &mut ctx.xer);
	// 82AC3138: 419A01C8  beq cr6, 0x82ac3300
	if ctx.cr[6].eq {
	pc = 0x82AC3300; continue 'dispatch;
	}
	// 82AC313C: 2F1E0003  cmpwi cr6, r30, 3
	ctx.cr[6].compare_i32(ctx.r[30].s32, 3, &mut ctx.xer);
	// 82AC3140: 419A00B8  beq cr6, 0x82ac31f8
	if ctx.cr[6].eq {
	pc = 0x82AC31F8; continue 'dispatch;
	}
	// 82AC3144: 2F1E0004  cmpwi cr6, r30, 4
	ctx.cr[6].compare_i32(ctx.r[30].s32, 4, &mut ctx.xer);
	// 82AC3148: 419A01EC  beq cr6, 0x82ac3334
	if ctx.cr[6].eq {
	pc = 0x82AC3334; continue 'dispatch;
	}
	// 82AC314C: 2F1E0006  cmpwi cr6, r30, 6
	ctx.cr[6].compare_i32(ctx.r[30].s32, 6, &mut ctx.xer);
	// 82AC3150: 419A0054  beq cr6, 0x82ac31a4
	if ctx.cr[6].eq {
	pc = 0x82AC31A4; continue 'dispatch;
	}
	// 82AC3154: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AC3158: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82AC315C: 388B1EC8  addi r4, r11, 0x1ec8
	ctx.r[4].s64 = ctx.r[11].s64 + 7880;
	// 82AC3160: 483308A9  bl 0x82df3a08
	ctx.lr = 0x82AC3164;
	sub_82DF3A08(ctx, base);
	// 82AC3164: 38A10064  addi r5, r1, 0x64
	ctx.r[5].s64 = ctx.r[1].s64 + 100;
	// 82AC3168: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC316C: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82AC3170: 48351EC1  bl 0x82e15030
	ctx.lr = 0x82AC3174;
	sub_82E15030(ctx, base);
	// 82AC3174: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AC3178: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AC317C: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82AC3180: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC3184: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82AC3188: 4B8012D9  bl 0x822c4460
	ctx.lr = 0x82AC318C;
	sub_822C4460(ctx, base);
	// 82AC318C: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82AC3190: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC3194: 419A0008  beq cr6, 0x82ac319c
	if ctx.cr[6].eq {
	pc = 0x82AC319C; continue 'dispatch;
	}
	// 82AC3198: 4B7FD6F9  bl 0x822c0890
	ctx.lr = 0x82AC319C;
	sub_822C0890(ctx, base);
	// 82AC319C: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82AC31A0: 480001E0  b 0x82ac3380
	pc = 0x82AC3380; continue 'dispatch;
	// 82AC31A4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AC31A8: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82AC31AC: 388B3568  addi r4, r11, 0x3568
	ctx.r[4].s64 = ctx.r[11].s64 + 13672;
	// 82AC31B0: 48330859  bl 0x82df3a08
	ctx.lr = 0x82AC31B4;
	sub_82DF3A08(ctx, base);
	// 82AC31B4: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 82AC31B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC31BC: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82AC31C0: 48351E71  bl 0x82e15030
	ctx.lr = 0x82AC31C4;
	sub_82E15030(ctx, base);
	// 82AC31C4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AC31C8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AC31CC: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82AC31D0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC31D4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82AC31D8: 4B801289  bl 0x822c4460
	ctx.lr = 0x82AC31DC;
	sub_822C4460(ctx, base);
	// 82AC31DC: 806100C4  lwz r3, 0xc4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82AC31E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC31E4: 419A0008  beq cr6, 0x82ac31ec
	if ctx.cr[6].eq {
	pc = 0x82AC31EC; continue 'dispatch;
	}
	// 82AC31E8: 4B7FD6A9  bl 0x822c0890
	ctx.lr = 0x82AC31EC;
	sub_822C0890(ctx, base);
	// 82AC31EC: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82AC31F0: 48330239  bl 0x82df3428
	ctx.lr = 0x82AC31F4;
	sub_82DF3428(ctx, base);
	// 82AC31F4: 480001A8  b 0x82ac339c
	pc = 0x82AC339C; continue 'dispatch;
	// 82AC31F8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AC31FC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AC3200: 388BFFBC  addi r4, r11, -0x44
	ctx.r[4].s64 = ctx.r[11].s64 + -68;
	// 82AC3204: 48330805  bl 0x82df3a08
	ctx.lr = 0x82AC3208;
	sub_82DF3A08(ctx, base);
	// 82AC3208: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82AC320C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC3210: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 82AC3214: 48351E1D  bl 0x82e15030
	ctx.lr = 0x82AC3218;
	sub_82E15030(ctx, base);
	// 82AC3218: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AC321C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AC3220: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82AC3224: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC3228: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82AC322C: 4B801235  bl 0x822c4460
	ctx.lr = 0x82AC3230;
	sub_822C4460(ctx, base);
	// 82AC3230: 806100CC  lwz r3, 0xcc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 82AC3234: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC3238: 419A0008  beq cr6, 0x82ac3240
	if ctx.cr[6].eq {
	pc = 0x82AC3240; continue 'dispatch;
	}
	// 82AC323C: 4B7FD655  bl 0x822c0890
	ctx.lr = 0x82AC3240;
	sub_822C0890(ctx, base);
	// 82AC3240: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AC3244: 483301E5  bl 0x82df3428
	ctx.lr = 0x82AC3248;
	sub_82DF3428(ctx, base);
	// 82AC3248: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC324C: 57CA103A  slwi r10, r30, 2
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82AC3250: 396B93AC  addi r11, r11, -0x6c54
	ctx.r[11].s64 = ctx.r[11].s64 + -27732;
	// 82AC3254: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82AC3258: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82AC325C: 7C8A582E  lwzx r4, r10, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82AC3260: 483307A9  bl 0x82df3a08
	ctx.lr = 0x82AC3264;
	sub_82DF3A08(ctx, base);
	// 82AC3264: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82AC3268: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC326C: 388BFF40  addi r4, r11, -0xc0
	ctx.r[4].s64 = ctx.r[11].s64 + -192;
	// 82AC3270: 409A0008  bne cr6, 0x82ac3278
	if !ctx.cr[6].eq {
	pc = 0x82AC3278; continue 'dispatch;
	}
	// 82AC3274: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82AC3278: 38E0000B  li r7, 0xb
	ctx.r[7].s64 = 11;
	// 82AC327C: 38C1005C  addi r6, r1, 0x5c
	ctx.r[6].s64 = ctx.r[1].s64 + 92;
	// 82AC3280: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82AC3284: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82AC3288: 4BD11A29  bl 0x827d4cb0
	ctx.lr = 0x82AC328C;
	sub_827D4CB0(ctx, base);
	// 82AC328C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AC3290: 387C0004  addi r3, r28, 4
	ctx.r[3].s64 = ctx.r[28].s64 + 4;
	// 82AC3294: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82AC3298: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC329C: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC32A0: 4B8011C1  bl 0x822c4460
	ctx.lr = 0x82AC32A4;
	sub_822C4460(ctx, base);
	// 82AC32A4: 806100AC  lwz r3, 0xac(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82AC32A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC32AC: 419A0008  beq cr6, 0x82ac32b4
	if ctx.cr[6].eq {
	pc = 0x82AC32B4; continue 'dispatch;
	}
	// 82AC32B0: 4B7FD5E1  bl 0x822c0890
	ctx.lr = 0x82AC32B4;
	sub_822C0890(ctx, base);
	// 82AC32B4: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82AC32B8: 48330171  bl 0x82df3428
	ctx.lr = 0x82AC32BC;
	sub_82DF3428(ctx, base);
	// 82AC32BC: 2F1E0003  cmpwi cr6, r30, 3
	ctx.cr[6].compare_i32(ctx.r[30].s32, 3, &mut ctx.xer);
	// 82AC32C0: 409A0010  bne cr6, 0x82ac32d0
	if !ctx.cr[6].eq {
	pc = 0x82AC32D0; continue 'dispatch;
	}
	// 82AC32C4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AC32C8: 9B7D0167  stb r27, 0x167(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(359 as u32), ctx.r[27].u8 ) };
	// 82AC32CC: 997D0166  stb r11, 0x166(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(358 as u32), ctx.r[11].u8 ) };
	// 82AC32D0: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82AC32D4: 419A000C  beq cr6, 0x82ac32e0
	if ctx.cr[6].eq {
	pc = 0x82AC32E0; continue 'dispatch;
	}
	// 82AC32D8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82AC32DC: 4B7FD5B5  bl 0x822c0890
	ctx.lr = 0x82AC32E0;
	sub_822C0890(ctx, base);
	// 82AC32E0: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AC32E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC32E8: 419A0008  beq cr6, 0x82ac32f0
	if ctx.cr[6].eq {
	pc = 0x82AC32F0; continue 'dispatch;
	}
	// 82AC32EC: 4B7FD5A5  bl 0x822c0890
	ctx.lr = 0x82AC32F0;
	sub_822C0890(ctx, base);
	// 82AC32F0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82AC32F4: 4832E99D  bl 0x82df1c90
	ctx.lr = 0x82AC32F8;
	sub_82DF1C90(ctx, base);
	// 82AC32F8: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 82AC32FC: 486E4EB4  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
	// 82AC3300: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AC3304: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AC3308: 4BA4EE11  bl 0x82512118
	ctx.lr = 0x82AC330C;
	sub_82512118(ctx, base);
	// 82AC330C: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82AC3310: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82AC3314: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AC3318: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82AC331C: 4B801145  bl 0x822c4460
	ctx.lr = 0x82AC3320;
	sub_822C4460(ctx, base);
	// 82AC3320: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82AC3324: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC3328: 419AFF20  beq cr6, 0x82ac3248
	if ctx.cr[6].eq {
	pc = 0x82AC3248; continue 'dispatch;
	}
	// 82AC332C: 4B7FD565  bl 0x822c0890
	ctx.lr = 0x82AC3330;
	sub_822C0890(ctx, base);
	// 82AC3330: 4BFFFF18  b 0x82ac3248
	pc = 0x82AC3248; continue 'dispatch;
	// 82AC3334: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AC3338: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AC333C: 388B1EBC  addi r4, r11, 0x1ebc
	ctx.r[4].s64 = ctx.r[11].s64 + 7868;
	// 82AC3340: 483306C9  bl 0x82df3a08
	ctx.lr = 0x82AC3344;
	sub_82DF3A08(ctx, base);
	// 82AC3344: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82AC3348: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC334C: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 82AC3350: 48351CE1  bl 0x82e15030
	ctx.lr = 0x82AC3354;
	sub_82E15030(ctx, base);
	// 82AC3354: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AC3358: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AC335C: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82AC3360: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC3364: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82AC3368: 4B8010F9  bl 0x822c4460
	ctx.lr = 0x82AC336C;
	sub_822C4460(ctx, base);
	// 82AC336C: 806100BC  lwz r3, 0xbc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82AC3370: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC3374: 419A0008  beq cr6, 0x82ac337c
	if ctx.cr[6].eq {
	pc = 0x82AC337C; continue 'dispatch;
	}
	// 82AC3378: 4B7FD519  bl 0x822c0890
	ctx.lr = 0x82AC337C;
	sub_822C0890(ctx, base);
	// 82AC337C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AC3380: 483300A9  bl 0x82df3428
	ctx.lr = 0x82AC3384;
	sub_82DF3428(ctx, base);
	// 82AC3384: 2F1E0004  cmpwi cr6, r30, 4
	ctx.cr[6].compare_i32(ctx.r[30].s32, 4, &mut ctx.xer);
	// 82AC3388: 4198FEC0  blt cr6, 0x82ac3248
	if ctx.cr[6].lt {
	pc = 0x82AC3248; continue 'dispatch;
	}
	// 82AC338C: 2F1E0005  cmpwi cr6, r30, 5
	ctx.cr[6].compare_i32(ctx.r[30].s32, 5, &mut ctx.xer);
	// 82AC3390: 40990074  ble cr6, 0x82ac3404
	if !ctx.cr[6].gt {
	pc = 0x82AC3404; continue 'dispatch;
	}
	// 82AC3394: 2F1E0006  cmpwi cr6, r30, 6
	ctx.cr[6].compare_i32(ctx.r[30].s32, 6, &mut ctx.xer);
	// 82AC3398: 409AFEB0  bne cr6, 0x82ac3248
	if !ctx.cr[6].eq {
	pc = 0x82AC3248; continue 'dispatch;
	}
	// 82AC339C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC33A0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AC33A4: 396B93AC  addi r11, r11, -0x6c54
	ctx.r[11].s64 = ctx.r[11].s64 + -27732;
	// 82AC33A8: 808B0024  lwz r4, 0x24(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82AC33AC: 4833065D  bl 0x82df3a08
	ctx.lr = 0x82AC33B0;
	sub_82DF3A08(ctx, base);
	// 82AC33B0: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82AC33B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC33B8: 3BEBFF40  addi r31, r11, -0xc0
	ctx.r[31].s64 = ctx.r[11].s64 + -192;
	// 82AC33BC: 409A0008  bne cr6, 0x82ac33c4
	if !ctx.cr[6].eq {
	pc = 0x82AC33C4; continue 'dispatch;
	}
	// 82AC33C0: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82AC33C4: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AC33C8: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 82AC33CC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC33D0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AC33D4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AC33D8: 4E800421  bctrl
	ctx.lr = 0x82AC33DC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AC33DC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AC33E0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AC33E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC33E8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82AC33EC: 38C0000B  li r6, 0xb
	ctx.r[6].s64 = 11;
	// 82AC33F0: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC33F4: 4BD1175D  bl 0x827d4b50
	ctx.lr = 0x82AC33F8;
	sub_827D4B50(ctx, base);
	// 82AC33F8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AC33FC: 4833002D  bl 0x82df3428
	ctx.lr = 0x82AC3400;
	sub_82DF3428(ctx, base);
	// 82AC3400: 4BFFFED0  b 0x82ac32d0
	pc = 0x82AC32D0; continue 'dispatch;
	// 82AC3404: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AC3408: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC340C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AC3410: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AC3414: 4E800421  bctrl
	ctx.lr = 0x82AC3418;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AC3418: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AC341C: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 82AC3420: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82AC3424: C00B003C  lfs f0, 0x3c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC3428: C1AB0038  lfs f13, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AC342C: C18B0034  lfs f12, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82AC3430: C16B0030  lfs f11, 0x30(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82AC3434: D1610090  stfs f11, 0x90(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82AC3438: D1810094  stfs f12, 0x94(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82AC343C: D1A10098  stfs f13, 0x98(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82AC3440: D001009C  stfs f0, 0x9c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82AC3444: 483B8B95  bl 0x82e7bfd8
	ctx.lr = 0x82AC3448;
	sub_82E7BFD8(ctx, base);
	// 82AC3448: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC344C: 57CA103A  slwi r10, r30, 2
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82AC3450: 3BEB93AC  addi r31, r11, -0x6c54
	ctx.r[31].s64 = ctx.r[11].s64 + -27732;
	// 82AC3454: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AC3458: 397F000C  addi r11, r31, 0xc
	ctx.r[11].s64 = ctx.r[31].s64 + 12;
	// 82AC345C: 7C8A582E  lwzx r4, r10, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82AC3460: 483305A9  bl 0x82df3a08
	ctx.lr = 0x82AC3464;
	sub_82DF3A08(ctx, base);
	// 82AC3464: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82AC3468: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC346C: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 82AC3470: 409A0008  bne cr6, 0x82ac3478
	if !ctx.cr[6].eq {
	pc = 0x82AC3478; continue 'dispatch;
	}
	// 82AC3474: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82AC3478: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AC347C: 38C0000B  li r6, 0xb
	ctx.r[6].s64 = 11;
	// 82AC3480: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82AC3484: 388100D0  addi r4, r1, 0xd0
	ctx.r[4].s64 = ctx.r[1].s64 + 208;
	// 82AC3488: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC348C: 4BD116C5  bl 0x827d4b50
	ctx.lr = 0x82AC3490;
	sub_827D4B50(ctx, base);
	// 82AC3490: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AC3494: 4832FF95  bl 0x82df3428
	ctx.lr = 0x82AC3498;
	sub_82DF3428(ctx, base);
	// 82AC3498: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AC349C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC34A0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AC34A4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AC34A8: 4E800421  bctrl
	ctx.lr = 0x82AC34AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AC34AC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AC34B0: 3D408203  lis r10, -0x7dfd
	ctx.r[10].s64 = -2113732608;
	// 82AC34B4: C05F0000  lfs f2, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82AC34B8: 38C00003  li r6, 3
	ctx.r[6].s64 = 3;
	// 82AC34BC: 807D0170  lwz r3, 0x170(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(368 as u32) ) } as u64;
	// 82AC34C0: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 82AC34C4: 3880000B  li r4, 0xb
	ctx.r[4].s64 = 11;
	// 82AC34C8: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC34CC: C1AB0038  lfs f13, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AC34D0: C18B0034  lfs f12, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82AC34D4: C16B0030  lfs f11, 0x30(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82AC34D8: D1610080  stfs f11, 0x80(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82AC34DC: D1810084  stfs f12, 0x84(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82AC34E0: D1A10088  stfs f13, 0x88(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82AC34E4: D001008C  stfs f0, 0x8c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82AC34E8: C02A4430  lfs f1, 0x4430(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(17456 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC34EC: 48017705  bl 0x82adabf0
	ctx.lr = 0x82AC34F0;
	sub_82ADABF0(ctx, base);
	// 82AC34F0: 4BFFFDCC  b 0x82ac32bc
	pc = 0x82AC32BC; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC34F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC34F8 size=248
    let mut pc: u32 = 0x82AC34F8;
    'dispatch: loop {
        match pc {
            0x82AC34F8 => {
    //   block [0x82AC34F8..0x82AC35F0)
	// 82AC34F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC34FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC3500: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC3504: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC3508: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC350C: 39640025  addi r11, r4, 0x25
	ctx.r[11].s64 = ctx.r[4].s64 + 37;
	// 82AC3510: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AC3514: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 82AC3518: 83CB0004  lwz r30, 4(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AC351C: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC3520: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82AC3524: 419A0024  beq cr6, 0x82ac3548
	if ctx.cr[6].eq {
	pc = 0x82AC3548; continue 'dispatch;
	}
	// 82AC3528: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 82AC352C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AC3530: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AC3534: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AC3538: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AC353C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AC3540: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AC3544: 4082FFE8  bne 0x82ac352c
	if !ctx.cr[0].eq {
	pc = 0x82AC352C; continue 'dispatch;
	}
	// 82AC3548: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 82AC354C: 483BBD55  bl 0x82e7f2a0
	ctx.lr = 0x82AC3550;
	sub_82E7F2A0(ctx, base);
	// 82AC3550: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC3554: 41820070  beq 0x82ac35c4
	if ctx.cr[0].eq {
	pc = 0x82AC35C4; continue 'dispatch;
	}
	// 82AC3558: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC355C: 483BBE95  bl 0x82e7f3f0
	ctx.lr = 0x82AC3560;
	sub_82E7F3F0(ctx, base);
	// 82AC3560: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AC3564: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC3568: 4800003C  b 0x82ac35a4
	pc = 0x82AC35A4; continue 'dispatch;
	// 82AC356C: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AC3570: 392B0108  addi r9, r11, 0x108
	ctx.r[9].s64 = ctx.r[11].s64 + 264;
	// 82AC3574: 810B010C  lwz r8, 0x10c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(268 as u32) ) } as u64;
	// 82AC3578: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC357C: 48000018  b 0x82ac3594
	pc = 0x82AC3594; continue 'dispatch;
	// 82AC3580: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AC3584: 38E00007  li r7, 7
	ctx.r[7].s64 = 7;
	// 82AC3588: 90E80198  stw r7, 0x198(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(408 as u32), ctx.r[7].u32 ) };
	// 82AC358C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC3590: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AC3594: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82AC3598: 409AFFE8  bne cr6, 0x82ac3580
	if !ctx.cr[6].eq {
	pc = 0x82AC3580; continue 'dispatch;
	}
	// 82AC359C: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC35A0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AC35A4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82AC35A8: 409AFFC4  bne cr6, 0x82ac356c
	if !ctx.cr[6].eq {
	pc = 0x82AC356C; continue 'dispatch;
	}
	// 82AC35AC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82AC35B0: 419A000C  beq cr6, 0x82ac35bc
	if ctx.cr[6].eq {
	pc = 0x82AC35BC; continue 'dispatch;
	}
	// 82AC35B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC35B8: 4B7FD2D9  bl 0x822c0890
	ctx.lr = 0x82AC35BC;
	sub_822C0890(ctx, base);
	// 82AC35BC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82AC35C0: 48000018  b 0x82ac35d8
	pc = 0x82AC35D8; continue 'dispatch;
	// 82AC35C4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82AC35C8: 419A000C  beq cr6, 0x82ac35d4
	if ctx.cr[6].eq {
	pc = 0x82AC35D4; continue 'dispatch;
	}
	// 82AC35CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC35D0: 4B7FD2C1  bl 0x822c0890
	ctx.lr = 0x82AC35D4;
	sub_822C0890(ctx, base);
	// 82AC35D4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AC35D8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC35DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC35E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC35E4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AC35E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC35EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC35F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC35F0 size=168
    let mut pc: u32 = 0x82AC35F0;
    'dispatch: loop {
        match pc {
            0x82AC35F0 => {
    //   block [0x82AC35F0..0x82AC3698)
	// 82AC35F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC35F4: 486E4B79  bl 0x831a816c
	ctx.lr = 0x82AC35F8;
	sub_831A8130(ctx, base);
	// 82AC35F8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC35FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC3600: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AC3604: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC3608: 4BA4BEC1  bl 0x8250f4c8
	ctx.lr = 0x82AC360C;
	sub_8250F4C8(ctx, base);
	// 82AC360C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC3610: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82AC3614: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC3618: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82AC361C: 409A0008  bne cr6, 0x82ac3624
	if !ctx.cr[6].eq {
	pc = 0x82AC3624; continue 'dispatch;
	}
	// 82AC3620: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AC3624: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC3628: 4BA47329  bl 0x8250a950
	ctx.lr = 0x82AC362C;
	sub_8250A950(ctx, base);
	// 82AC362C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AC3630: 4832E661  bl 0x82df1c90
	ctx.lr = 0x82AC3634;
	sub_82DF1C90(ctx, base);
	// 82AC3634: 3BFF0128  addi r31, r31, 0x128
	ctx.r[31].s64 = ctx.r[31].s64 + 296;
	// 82AC3638: 3BC00007  li r30, 7
	ctx.r[30].s64 = 7;
	// 82AC363C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC3640: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC3644: 419A0038  beq cr6, 0x82ac367c
	if ctx.cr[6].eq {
	pc = 0x82AC367C; continue 'dispatch;
	}
	// 82AC3648: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AC364C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC3650: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 82AC3654: 409A0008  bne cr6, 0x82ac365c
	if !ctx.cr[6].eq {
	pc = 0x82AC365C; continue 'dispatch;
	}
	// 82AC3658: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC365C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC3660: 4BD103A1  bl 0x827d3a00
	ctx.lr = 0x82AC3664;
	sub_827D3A00(ctx, base);
	// 82AC3664: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82AC3668: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AC366C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC3670: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82AC3674: 419A0008  beq cr6, 0x82ac367c
	if ctx.cr[6].eq {
	pc = 0x82AC367C; continue 'dispatch;
	}
	// 82AC3678: 4B7FD219  bl 0x822c0890
	ctx.lr = 0x82AC367C;
	sub_822C0890(ctx, base);
	// 82AC367C: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82AC3680: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 82AC3684: 4082FFB8  bne 0x82ac363c
	if !ctx.cr[0].eq {
	pc = 0x82AC363C; continue 'dispatch;
	}
	// 82AC3688: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC368C: 4832E605  bl 0x82df1c90
	ctx.lr = 0x82AC3690;
	sub_82DF1C90(ctx, base);
	// 82AC3690: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AC3694: 486E4B28  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC3698(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AC3698 size=12
    let mut pc: u32 = 0x82AC3698;
    'dispatch: loop {
        match pc {
            0x82AC3698 => {
    //   block [0x82AC3698..0x82AC36A4)
	// 82AC3698: 88A4001C  lbz r5, 0x1c(r4)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) } as u64;
	// 82AC369C: 80840018  lwz r4, 0x18(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 82AC36A0: 4BFFF818  b 0x82ac2eb8
	sub_82AC2EB8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC36A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AC36A8 size=24
    let mut pc: u32 = 0x82AC36A8;
    'dispatch: loop {
        match pc {
            0x82AC36A8 => {
    //   block [0x82AC36A8..0x82AC36C0)
	// 82AC36A8: 81640170  lwz r11, 0x170(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(368 as u32) ) } as u64;
	// 82AC36AC: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC36B0: 81640174  lwz r11, 0x174(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(372 as u32) ) } as u64;
	// 82AC36B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC36B8: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82AC36BC: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC36C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AC36C0 size=36
    let mut pc: u32 = 0x82AC36C0;
    'dispatch: loop {
        match pc {
            0x82AC36C0 => {
    //   block [0x82AC36C0..0x82AC36E4)
	// 82AC36C0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AC36C4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AC36C8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AC36CC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AC36D0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AC36D4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AC36D8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AC36DC: 4082FFE8  bne 0x82ac36c4
	if !ctx.cr[0].eq {
	pc = 0x82AC36C4; continue 'dispatch;
	}
	// 82AC36E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC36E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC36E8 size=124
    let mut pc: u32 = 0x82AC36E8;
    'dispatch: loop {
        match pc {
            0x82AC36E8 => {
    //   block [0x82AC36E8..0x82AC3764)
	// 82AC36E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC36EC: 486E4A81  bl 0x831a816c
	ctx.lr = 0x82AC36F0;
	sub_831A8130(ctx, base);
	// 82AC36F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC36F4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AC36F8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AC36FC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AC3700: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82AC3704: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 82AC3708: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 82AC370C: 4832ECDD  bl 0x82df23e8
	ctx.lr = 0x82AC3710;
	sub_82DF23E8(ctx, base);
	// 82AC3710: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82AC3714: 4182001C  beq 0x82ac3730
	if ctx.cr[0].eq {
	pc = 0x82AC3730; continue 'dispatch;
	}
	// 82AC3718: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC371C: 48395F65  bl 0x82e59680
	ctx.lr = 0x82AC3720;
	sub_82E59680(ctx, base);
	// 82AC3720: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC3724: 396B93E8  addi r11, r11, -0x6c18
	ctx.r[11].s64 = ctx.r[11].s64 + -27672;
	// 82AC3728: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC372C: 48000008  b 0x82ac3734
	pc = 0x82AC3734; continue 'dispatch;
	// 82AC3730: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AC3734: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82AC3738: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82AC373C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC3740: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC3744: 4BFFECB5  bl 0x82ac23f8
	ctx.lr = 0x82AC3748;
	sub_82AC23F8(ctx, base);
	// 82AC3748: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AC374C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC3750: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC3754: 4B7FC8AD  bl 0x822c0000
	ctx.lr = 0x82AC3758;
	sub_822C0000(ctx, base);
	// 82AC3758: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC375C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC3760: 486E4A5C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC3768(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC3768 size=112
    let mut pc: u32 = 0x82AC3768;
    'dispatch: loop {
        match pc {
            0x82AC3768 => {
    //   block [0x82AC3768..0x82AC37D8)
	// 82AC3768: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC376C: 486E4A01  bl 0x831a816c
	ctx.lr = 0x82AC3770;
	sub_831A8130(ctx, base);
	// 82AC3770: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC3774: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AC3778: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AC377C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AC3780: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82AC3784: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 82AC3788: 38600050  li r3, 0x50
	ctx.r[3].s64 = 80;
	// 82AC378C: 4832EC5D  bl 0x82df23e8
	ctx.lr = 0x82AC3790;
	sub_82DF23E8(ctx, base);
	// 82AC3790: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC3794: 41820010  beq 0x82ac37a4
	if ctx.cr[0].eq {
	pc = 0x82AC37A4; continue 'dispatch;
	}
	// 82AC3798: 4BFF90E9  bl 0x82abc880
	ctx.lr = 0x82AC379C;
	sub_82ABC880(ctx, base);
	// 82AC379C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC37A0: 48000008  b 0x82ac37a8
	pc = 0x82AC37A8; continue 'dispatch;
	// 82AC37A4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AC37A8: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82AC37AC: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82AC37B0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC37B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC37B8: 4BFFED09  bl 0x82ac24c0
	ctx.lr = 0x82AC37BC;
	sub_82AC24C0(ctx, base);
	// 82AC37BC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AC37C0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC37C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC37C8: 4B7FC839  bl 0x822c0000
	ctx.lr = 0x82AC37CC;
	sub_822C0000(ctx, base);
	// 82AC37CC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC37D0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC37D4: 486E49E8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC37D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC37D8 size=124
    let mut pc: u32 = 0x82AC37D8;
    'dispatch: loop {
        match pc {
            0x82AC37D8 => {
    //   block [0x82AC37D8..0x82AC3854)
	// 82AC37D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC37DC: 486E4991  bl 0x831a816c
	ctx.lr = 0x82AC37E0;
	sub_831A8130(ctx, base);
	// 82AC37E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC37E4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AC37E8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AC37EC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AC37F0: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82AC37F4: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 82AC37F8: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 82AC37FC: 4832EBED  bl 0x82df23e8
	ctx.lr = 0x82AC3800;
	sub_82DF23E8(ctx, base);
	// 82AC3800: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82AC3804: 4182001C  beq 0x82ac3820
	if ctx.cr[0].eq {
	pc = 0x82AC3820; continue 'dispatch;
	}
	// 82AC3808: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC380C: 48395E75  bl 0x82e59680
	ctx.lr = 0x82AC3810;
	sub_82E59680(ctx, base);
	// 82AC3810: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC3814: 396B93F0  addi r11, r11, -0x6c10
	ctx.r[11].s64 = ctx.r[11].s64 + -27664;
	// 82AC3818: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC381C: 48000008  b 0x82ac3824
	pc = 0x82AC3824; continue 'dispatch;
	// 82AC3820: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AC3824: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82AC3828: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82AC382C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC3830: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC3834: 4BFFED55  bl 0x82ac2588
	ctx.lr = 0x82AC3838;
	sub_82AC2588(ctx, base);
	// 82AC3838: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AC383C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC3840: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC3844: 4B7FC7BD  bl 0x822c0000
	ctx.lr = 0x82AC3848;
	sub_822C0000(ctx, base);
	// 82AC3848: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC384C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC3850: 486E496C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC3858(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC3858 size=112
    let mut pc: u32 = 0x82AC3858;
    'dispatch: loop {
        match pc {
            0x82AC3858 => {
    //   block [0x82AC3858..0x82AC38C8)
	// 82AC3858: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC385C: 486E4911  bl 0x831a816c
	ctx.lr = 0x82AC3860;
	sub_831A8130(ctx, base);
	// 82AC3860: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC3864: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AC3868: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AC386C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AC3870: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82AC3874: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 82AC3878: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82AC387C: 4832EB6D  bl 0x82df23e8
	ctx.lr = 0x82AC3880;
	sub_82DF23E8(ctx, base);
	// 82AC3880: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC3884: 41820010  beq 0x82ac3894
	if ctx.cr[0].eq {
	pc = 0x82AC3894; continue 'dispatch;
	}
	// 82AC3888: 4BFF8C51  bl 0x82abc4d8
	ctx.lr = 0x82AC388C;
	sub_82ABC4D8(ctx, base);
	// 82AC388C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC3890: 48000008  b 0x82ac3898
	pc = 0x82AC3898; continue 'dispatch;
	// 82AC3894: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AC3898: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82AC389C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82AC38A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC38A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC38A8: 4BFFEDA9  bl 0x82ac2650
	ctx.lr = 0x82AC38AC;
	sub_82AC2650(ctx, base);
	// 82AC38AC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AC38B0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC38B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC38B8: 4B7FC749  bl 0x822c0000
	ctx.lr = 0x82AC38BC;
	sub_822C0000(ctx, base);
	// 82AC38BC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC38C0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC38C4: 486E48F8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC38C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC38C8 size=112
    let mut pc: u32 = 0x82AC38C8;
    'dispatch: loop {
        match pc {
            0x82AC38C8 => {
    //   block [0x82AC38C8..0x82AC3938)
	// 82AC38C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC38CC: 486E48A1  bl 0x831a816c
	ctx.lr = 0x82AC38D0;
	sub_831A8130(ctx, base);
	// 82AC38D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC38D4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AC38D8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AC38DC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AC38E0: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82AC38E4: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 82AC38E8: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82AC38EC: 4832EAFD  bl 0x82df23e8
	ctx.lr = 0x82AC38F0;
	sub_82DF23E8(ctx, base);
	// 82AC38F0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC38F4: 41820010  beq 0x82ac3904
	if ctx.cr[0].eq {
	pc = 0x82AC3904; continue 'dispatch;
	}
	// 82AC38F8: 4BFF8C71  bl 0x82abc568
	ctx.lr = 0x82AC38FC;
	sub_82ABC568(ctx, base);
	// 82AC38FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC3900: 48000008  b 0x82ac3908
	pc = 0x82AC3908; continue 'dispatch;
	// 82AC3904: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AC3908: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82AC390C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82AC3910: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC3914: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC3918: 4BFFEE01  bl 0x82ac2718
	ctx.lr = 0x82AC391C;
	sub_82AC2718(ctx, base);
	// 82AC391C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AC3920: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC3924: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC3928: 4B7FC6D9  bl 0x822c0000
	ctx.lr = 0x82AC392C;
	sub_822C0000(ctx, base);
	// 82AC392C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC3930: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC3934: 486E4888  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC3938(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC3938 size=120
    let mut pc: u32 = 0x82AC3938;
    'dispatch: loop {
        match pc {
            0x82AC3938 => {
    //   block [0x82AC3938..0x82AC39B0)
	// 82AC3938: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC393C: 486E4831  bl 0x831a816c
	ctx.lr = 0x82AC3940;
	sub_831A8130(ctx, base);
	// 82AC3940: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC3944: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AC3948: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AC394C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AC3950: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AC3954: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82AC3958: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 82AC395C: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82AC3960: 4832EA89  bl 0x82df23e8
	ctx.lr = 0x82AC3964;
	sub_82DF23E8(ctx, base);
	// 82AC3964: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC3968: 41820014  beq 0x82ac397c
	if ctx.cr[0].eq {
	pc = 0x82AC397C; continue 'dispatch;
	}
	// 82AC396C: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC3970: 4BFF8989  bl 0x82abc2f8
	ctx.lr = 0x82AC3974;
	sub_82ABC2F8(ctx, base);
	// 82AC3974: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC3978: 48000008  b 0x82ac3980
	pc = 0x82AC3980; continue 'dispatch;
	// 82AC397C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AC3980: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82AC3984: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82AC3988: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC398C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC3990: 4BFFEE51  bl 0x82ac27e0
	ctx.lr = 0x82AC3994;
	sub_82AC27E0(ctx, base);
	// 82AC3994: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AC3998: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC399C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC39A0: 4B7FC661  bl 0x822c0000
	ctx.lr = 0x82AC39A4;
	sub_822C0000(ctx, base);
	// 82AC39A4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC39A8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC39AC: 486E4810  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC39B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC39B0 size=112
    let mut pc: u32 = 0x82AC39B0;
    'dispatch: loop {
        match pc {
            0x82AC39B0 => {
    //   block [0x82AC39B0..0x82AC3A20)
	// 82AC39B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC39B4: 486E47B9  bl 0x831a816c
	ctx.lr = 0x82AC39B8;
	sub_831A8130(ctx, base);
	// 82AC39B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC39BC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AC39C0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AC39C4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AC39C8: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82AC39CC: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 82AC39D0: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82AC39D4: 4832EA15  bl 0x82df23e8
	ctx.lr = 0x82AC39D8;
	sub_82DF23E8(ctx, base);
	// 82AC39D8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC39DC: 41820010  beq 0x82ac39ec
	if ctx.cr[0].eq {
	pc = 0x82AC39EC; continue 'dispatch;
	}
	// 82AC39E0: 4BFF8C61  bl 0x82abc640
	ctx.lr = 0x82AC39E4;
	sub_82ABC640(ctx, base);
	// 82AC39E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC39E8: 48000008  b 0x82ac39f0
	pc = 0x82AC39F0; continue 'dispatch;
	// 82AC39EC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AC39F0: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82AC39F4: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82AC39F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC39FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC3A00: 4BFFEEA9  bl 0x82ac28a8
	ctx.lr = 0x82AC3A04;
	sub_82AC28A8(ctx, base);
	// 82AC3A04: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AC3A08: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC3A0C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC3A10: 4B7FC5F1  bl 0x822c0000
	ctx.lr = 0x82AC3A14;
	sub_822C0000(ctx, base);
	// 82AC3A14: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC3A18: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC3A1C: 486E47A0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC3A20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC3A20 size=124
    let mut pc: u32 = 0x82AC3A20;
    'dispatch: loop {
        match pc {
            0x82AC3A20 => {
    //   block [0x82AC3A20..0x82AC3A9C)
	// 82AC3A20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC3A24: 486E4749  bl 0x831a816c
	ctx.lr = 0x82AC3A28;
	sub_831A8130(ctx, base);
	// 82AC3A28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC3A2C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AC3A30: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AC3A34: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AC3A38: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82AC3A3C: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 82AC3A40: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 82AC3A44: 4832E9A5  bl 0x82df23e8
	ctx.lr = 0x82AC3A48;
	sub_82DF23E8(ctx, base);
	// 82AC3A48: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82AC3A4C: 4182001C  beq 0x82ac3a68
	if ctx.cr[0].eq {
	pc = 0x82AC3A68; continue 'dispatch;
	}
	// 82AC3A50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC3A54: 48395C2D  bl 0x82e59680
	ctx.lr = 0x82AC3A58;
	sub_82E59680(ctx, base);
	// 82AC3A58: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC3A5C: 396B93F8  addi r11, r11, -0x6c08
	ctx.r[11].s64 = ctx.r[11].s64 + -27656;
	// 82AC3A60: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC3A64: 48000008  b 0x82ac3a6c
	pc = 0x82AC3A6C; continue 'dispatch;
	// 82AC3A68: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AC3A6C: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82AC3A70: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82AC3A74: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC3A78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC3A7C: 4BFFEEF5  bl 0x82ac2970
	ctx.lr = 0x82AC3A80;
	sub_82AC2970(ctx, base);
	// 82AC3A80: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AC3A84: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC3A88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC3A8C: 4B7FC575  bl 0x822c0000
	ctx.lr = 0x82AC3A90;
	sub_822C0000(ctx, base);
	// 82AC3A90: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC3A94: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC3A98: 486E4724  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC3AA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC3AA0 size=500
    let mut pc: u32 = 0x82AC3AA0;
    'dispatch: loop {
        match pc {
            0x82AC3AA0 => {
    //   block [0x82AC3AA0..0x82AC3C94)
	// 82AC3AA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC3AA4: 486E46C5  bl 0x831a8168
	ctx.lr = 0x82AC3AA8;
	sub_831A8130(ctx, base);
	// 82AC3AA8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC3AAC: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82AC3AB0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AC3AB4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AC3AB8: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82AC3ABC: 41820038  beq 0x82ac3af4
	if ctx.cr[0].eq {
	pc = 0x82AC3AF4; continue 'dispatch;
	}
	// 82AC3AC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC3AC4: 486E5EC5  bl 0x831a9988
	ctx.lr = 0x82AC3AC8;
	sub_831A9988(ctx, base);
	// 82AC3AC8: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 82AC3ACC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AC3AD0: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 82AC3AD4: 486E4625  bl 0x831a80f8
	ctx.lr = 0x82AC3AD8;
	sub_831A80F8(ctx, base);
	// 82AC3AD8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC3ADC: 41820018  beq 0x82ac3af4
	if ctx.cr[0].eq {
	pc = 0x82AC3AF4; continue 'dispatch;
	}
	// 82AC3AE0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC3AE4: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82AC3AE8: 4BFFE461  bl 0x82ac1f48
	ctx.lr = 0x82AC3AEC;
	sub_82AC1F48(ctx, base);
	// 82AC3AEC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82AC3AF0: 4800019C  b 0x82ac3c8c
	pc = 0x82AC3C8C; continue 'dispatch;
	// 82AC3AF4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82AC3AF8: 419A0184  beq cr6, 0x82ac3c7c
	if ctx.cr[6].eq {
	pc = 0x82AC3C7C; continue 'dispatch;
	}
	// 82AC3AFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC3B00: 486E5E89  bl 0x831a9988
	ctx.lr = 0x82AC3B04;
	sub_831A9988(ctx, base);
	// 82AC3B04: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AC3B08: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AC3B0C: 386BEBC0  addi r3, r11, -0x1440
	ctx.r[3].s64 = ctx.r[11].s64 + -5184;
	// 82AC3B10: 486E45E9  bl 0x831a80f8
	ctx.lr = 0x82AC3B14;
	sub_831A80F8(ctx, base);
	// 82AC3B14: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC3B18: 41820014  beq 0x82ac3b2c
	if ctx.cr[0].eq {
	pc = 0x82AC3B2C; continue 'dispatch;
	}
	// 82AC3B1C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC3B20: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82AC3B24: 4BFFE485  bl 0x82ac1fa8
	ctx.lr = 0x82AC3B28;
	sub_82AC1FA8(ctx, base);
	// 82AC3B28: 48000164  b 0x82ac3c8c
	pc = 0x82AC3C8C; continue 'dispatch;
	// 82AC3B2C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82AC3B30: 419A014C  beq cr6, 0x82ac3c7c
	if ctx.cr[6].eq {
	pc = 0x82AC3C7C; continue 'dispatch;
	}
	// 82AC3B34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC3B38: 486E5E51  bl 0x831a9988
	ctx.lr = 0x82AC3B3C;
	sub_831A9988(ctx, base);
	// 82AC3B3C: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AC3B40: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AC3B44: 386BD834  addi r3, r11, -0x27cc
	ctx.r[3].s64 = ctx.r[11].s64 + -10188;
	// 82AC3B48: 486E45B1  bl 0x831a80f8
	ctx.lr = 0x82AC3B4C;
	sub_831A80F8(ctx, base);
	// 82AC3B4C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC3B50: 41820014  beq 0x82ac3b64
	if ctx.cr[0].eq {
	pc = 0x82AC3B64; continue 'dispatch;
	}
	// 82AC3B54: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC3B58: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82AC3B5C: 4BFFE495  bl 0x82ac1ff0
	ctx.lr = 0x82AC3B60;
	sub_82AC1FF0(ctx, base);
	// 82AC3B60: 4BFFFF8C  b 0x82ac3aec
	pc = 0x82AC3AEC; continue 'dispatch;
	// 82AC3B64: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82AC3B68: 419A0114  beq cr6, 0x82ac3c7c
	if ctx.cr[6].eq {
	pc = 0x82AC3C7C; continue 'dispatch;
	}
	// 82AC3B6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC3B70: 486E5E19  bl 0x831a9988
	ctx.lr = 0x82AC3B74;
	sub_831A9988(ctx, base);
	// 82AC3B74: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AC3B78: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AC3B7C: 386BD7D8  addi r3, r11, -0x2828
	ctx.r[3].s64 = ctx.r[11].s64 + -10280;
	// 82AC3B80: 486E4579  bl 0x831a80f8
	ctx.lr = 0x82AC3B84;
	sub_831A80F8(ctx, base);
	// 82AC3B84: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC3B88: 41820014  beq 0x82ac3b9c
	if ctx.cr[0].eq {
	pc = 0x82AC3B9C; continue 'dispatch;
	}
	// 82AC3B8C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC3B90: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82AC3B94: 4BFFE465  bl 0x82ac1ff8
	ctx.lr = 0x82AC3B98;
	sub_82AC1FF8(ctx, base);
	// 82AC3B98: 4BFFFF54  b 0x82ac3aec
	pc = 0x82AC3AEC; continue 'dispatch;
	// 82AC3B9C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82AC3BA0: 419A00DC  beq cr6, 0x82ac3c7c
	if ctx.cr[6].eq {
	pc = 0x82AC3C7C; continue 'dispatch;
	}
	// 82AC3BA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC3BA8: 486E5DE1  bl 0x831a9988
	ctx.lr = 0x82AC3BAC;
	sub_831A9988(ctx, base);
	// 82AC3BAC: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AC3BB0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AC3BB4: 386BE158  addi r3, r11, -0x1ea8
	ctx.r[3].s64 = ctx.r[11].s64 + -7848;
	// 82AC3BB8: 486E4541  bl 0x831a80f8
	ctx.lr = 0x82AC3BBC;
	sub_831A80F8(ctx, base);
	// 82AC3BBC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC3BC0: 41820014  beq 0x82ac3bd4
	if ctx.cr[0].eq {
	pc = 0x82AC3BD4; continue 'dispatch;
	}
	// 82AC3BC4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC3BC8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82AC3BCC: 4BFFFACD  bl 0x82ac3698
	ctx.lr = 0x82AC3BD0;
	sub_82AC3698(ctx, base);
	// 82AC3BD0: 4BFFFF1C  b 0x82ac3aec
	pc = 0x82AC3AEC; continue 'dispatch;
	// 82AC3BD4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82AC3BD8: 419A00A4  beq cr6, 0x82ac3c7c
	if ctx.cr[6].eq {
	pc = 0x82AC3C7C; continue 'dispatch;
	}
	// 82AC3BDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC3BE0: 486E5DA9  bl 0x831a9988
	ctx.lr = 0x82AC3BE4;
	sub_831A9988(ctx, base);
	// 82AC3BE4: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AC3BE8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AC3BEC: 386BD800  addi r3, r11, -0x2800
	ctx.r[3].s64 = ctx.r[11].s64 + -10240;
	// 82AC3BF0: 486E4509  bl 0x831a80f8
	ctx.lr = 0x82AC3BF4;
	sub_831A80F8(ctx, base);
	// 82AC3BF4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC3BF8: 41820014  beq 0x82ac3c0c
	if ctx.cr[0].eq {
	pc = 0x82AC3C0C; continue 'dispatch;
	}
	// 82AC3BFC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC3C00: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82AC3C04: 4BFFE3FD  bl 0x82ac2000
	ctx.lr = 0x82AC3C08;
	sub_82AC2000(ctx, base);
	// 82AC3C08: 4BFFFEE4  b 0x82ac3aec
	pc = 0x82AC3AEC; continue 'dispatch;
	// 82AC3C0C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82AC3C10: 419A006C  beq cr6, 0x82ac3c7c
	if ctx.cr[6].eq {
	pc = 0x82AC3C7C; continue 'dispatch;
	}
	// 82AC3C14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC3C18: 486E5D71  bl 0x831a9988
	ctx.lr = 0x82AC3C1C;
	sub_831A9988(ctx, base);
	// 82AC3C1C: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 82AC3C20: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AC3C24: 386B2F78  addi r3, r11, 0x2f78
	ctx.r[3].s64 = ctx.r[11].s64 + 12152;
	// 82AC3C28: 486E44D1  bl 0x831a80f8
	ctx.lr = 0x82AC3C2C;
	sub_831A80F8(ctx, base);
	// 82AC3C2C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC3C30: 41820014  beq 0x82ac3c44
	if ctx.cr[0].eq {
	pc = 0x82AC3C44; continue 'dispatch;
	}
	// 82AC3C34: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC3C38: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82AC3C3C: 4BFFE3D5  bl 0x82ac2010
	ctx.lr = 0x82AC3C40;
	sub_82AC2010(ctx, base);
	// 82AC3C40: 4800004C  b 0x82ac3c8c
	pc = 0x82AC3C8C; continue 'dispatch;
	// 82AC3C44: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82AC3C48: 419A0034  beq cr6, 0x82ac3c7c
	if ctx.cr[6].eq {
	pc = 0x82AC3C7C; continue 'dispatch;
	}
	// 82AC3C4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC3C50: 486E5D39  bl 0x831a9988
	ctx.lr = 0x82AC3C54;
	sub_831A9988(ctx, base);
	// 82AC3C54: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 82AC3C58: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AC3C5C: 386B59B0  addi r3, r11, 0x59b0
	ctx.r[3].s64 = ctx.r[11].s64 + 22960;
	// 82AC3C60: 486E4499  bl 0x831a80f8
	ctx.lr = 0x82AC3C64;
	sub_831A80F8(ctx, base);
	// 82AC3C64: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC3C68: 41820014  beq 0x82ac3c7c
	if ctx.cr[0].eq {
	pc = 0x82AC3C7C; continue 'dispatch;
	}
	// 82AC3C6C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC3C70: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82AC3C74: 4BFFEDC5  bl 0x82ac2a38
	ctx.lr = 0x82AC3C78;
	sub_82AC2A38(ctx, base);
	// 82AC3C78: 4BFFFE74  b 0x82ac3aec
	pc = 0x82AC3AEC; continue 'dispatch;
	// 82AC3C7C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82AC3C80: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC3C84: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC3C88: 4BA4E991  bl 0x82512618
	ctx.lr = 0x82AC3C8C;
	sub_82512618(ctx, base);
	// 82AC3C8C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AC3C90: 486E4528  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC3C98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC3C98 size=376
    let mut pc: u32 = 0x82AC3C98;
    'dispatch: loop {
        match pc {
            0x82AC3C98 => {
    //   block [0x82AC3C98..0x82AC3E10)
	// 82AC3C98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC3C9C: 486E44CD  bl 0x831a8168
	ctx.lr = 0x82AC3CA0;
	sub_831A8130(ctx, base);
	// 82AC3CA0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC3CA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC3CA8: 4BA4E689  bl 0x82512330
	ctx.lr = 0x82AC3CAC;
	sub_82512330(ctx, base);
	// 82AC3CAC: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82AC3CB0: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82AC3CB4: 38AA6910  addi r5, r10, 0x6910
	ctx.r[5].s64 = ctx.r[10].s64 + 26896;
	// 82AC3CB8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC3CBC: 3949A214  addi r10, r9, -0x5dec
	ctx.r[10].s64 = ctx.r[9].s64 + -24044;
	// 82AC3CC0: 3D00820C  lis r8, -0x7df4
	ctx.r[8].s64 = -2113142784;
	// 82AC3CC4: 396B93A8  addi r11, r11, -0x6c58
	ctx.r[11].s64 = ctx.r[11].s64 + -27736;
	// 82AC3CC8: 915F00E4  stw r10, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[10].u32 ) };
	// 82AC3CCC: 3CE0820C  lis r7, -0x7df4
	ctx.r[7].s64 = -2113142784;
	// 82AC3CD0: 3CC0820C  lis r6, -0x7df4
	ctx.r[6].s64 = -2113142784;
	// 82AC3CD4: 3948952C  addi r10, r8, -0x6ad4
	ctx.r[10].s64 = ctx.r[8].s64 + -27348;
	// 82AC3CD8: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82AC3CDC: 39079518  addi r8, r7, -0x6ae8
	ctx.r[8].s64 = ctx.r[7].s64 + -27368;
	// 82AC3CE0: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC3CE4: 38800100  li r4, 0x100
	ctx.r[4].s64 = 256;
	// 82AC3CE8: D01F00F8  stfs f0, 0xf8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 82AC3CEC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82AC3CF0: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82AC3CF4: 38E694CC  addi r7, r6, -0x6b34
	ctx.r[7].s64 = ctx.r[6].s64 + -27444;
	// 82AC3CF8: 911F0028  stw r8, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[8].u32 ) };
	// 82AC3CFC: 93DF00E8  stw r30, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[30].u32 ) };
	// 82AC3D00: C00908A4  lfs f0, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC3D04: 90FF00E4  stw r7, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[7].u32 ) };
	// 82AC3D08: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AC3D0C: 93DF00EC  stw r30, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[30].u32 ) };
	// 82AC3D10: 395F0128  addi r10, r31, 0x128
	ctx.r[10].s64 = ctx.r[31].s64 + 296;
	// 82AC3D14: 93DF00F0  stw r30, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[30].u32 ) };
	// 82AC3D18: 39200006  li r9, 6
	ctx.r[9].s64 = 6;
	// 82AC3D1C: 93DF00F4  stw r30, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[30].u32 ) };
	// 82AC3D20: 13E028C7  vcmpequd (lvx128) v31, v0, v5
	tmp.u32 = ctx.r[5].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC3E10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC3E10 size=76
    let mut pc: u32 = 0x82AC3E10;
    'dispatch: loop {
        match pc {
            0x82AC3E10 => {
    //   block [0x82AC3E10..0x82AC3E5C)
	// 82AC3E10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC3E14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC3E18: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC3E1C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC3E20: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC3E24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC3E28: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AC3E2C: 4BFFEC75  bl 0x82ac2aa0
	ctx.lr = 0x82AC3E30;
	sub_82AC2AA0(ctx, base);
	// 82AC3E30: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC3E34: 4182000C  beq 0x82ac3e40
	if ctx.cr[0].eq {
	pc = 0x82AC3E40; continue 'dispatch;
	}
	// 82AC3E38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC3E3C: 4832E59D  bl 0x82df23d8
	ctx.lr = 0x82AC3E40;
	sub_82DF23D8(ctx, base);
	// 82AC3E40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC3E44: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC3E48: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC3E4C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC3E50: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AC3E54: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC3E58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC3E60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC3E60 size=88
    let mut pc: u32 = 0x82AC3E60;
    'dispatch: loop {
        match pc {
            0x82AC3E60 => {
    //   block [0x82AC3E60..0x82AC3EB8)
	// 82AC3E60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC3E64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC3E68: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC3E6C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC3E70: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC3E74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC3E78: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AC3E7C: 4BA4E1ED  bl 0x82512068
	ctx.lr = 0x82AC3E80;
	sub_82512068(ctx, base);
	// 82AC3E80: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AC3E84: 807F00F0  lwz r3, 0xf0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 82AC3E88: 480018E9  bl 0x82ac5770
	ctx.lr = 0x82AC3E8C;
	sub_82AC5770(ctx, base);
	// 82AC3E8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC3E90: 4BFFF761  bl 0x82ac35f0
	ctx.lr = 0x82AC3E94;
	sub_82AC35F0(ctx, base);
	// 82AC3E94: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82AC3E98: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC3E9C: 916AE634  stw r11, -0x19cc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-6604 as u32), ctx.r[11].u32 ) };
	// 82AC3EA0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC3EA4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC3EA8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC3EAC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AC3EB0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC3EB4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC3EB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC3EB8 size=340
    let mut pc: u32 = 0x82AC3EB8;
    'dispatch: loop {
        match pc {
            0x82AC3EB8 => {
    //   block [0x82AC3EB8..0x82AC400C)
	// 82AC3EB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC3EBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC3EC0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC3EC4: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82AC3EC8: 9421FEC0  stwu r1, -0x140(r1)
	ea = ctx.r[1].u32.wrapping_add(-320 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC3ECC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC3ED0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AC3ED4: 419A0120  beq cr6, 0x82ac3ff4
	if ctx.cr[6].eq {
	pc = 0x82AC3FF4; continue 'dispatch;
	}
	// 82AC3ED8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC3EDC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC3EE0: 388B95EC  addi r4, r11, -0x6a14
	ctx.r[4].s64 = ctx.r[11].s64 + -27156;
	// 82AC3EE4: 4832FB25  bl 0x82df3a08
	ctx.lr = 0x82AC3EE8;
	sub_82DF3A08(ctx, base);
	// 82AC3EE8: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82AC3EEC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AC3EF0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AC3EF4: 3D00832F  lis r8, -0x7cd1
	ctx.r[8].s64 = -2094071808;
	// 82AC3EF8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AC3EFC: C3E908A4  lfs f31, 0x8a4(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82AC3F00: 3888FE80  addi r4, r8, -0x180
	ctx.r[4].s64 = ctx.r[8].s64 + -384;
	// 82AC3F04: C06B9528  lfs f3, -0x6ad8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82AC3F08: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AC3F0C: C04A08A8  lfs f2, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82AC3F10: 4BADF2A1  bl 0x825a31b0
	ctx.lr = 0x82AC3F14;
	sub_825A31B0(ctx, base);
	// 82AC3F14: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AC3F18: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AC3F1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC3F20: 4BADD851  bl 0x825a1770
	ctx.lr = 0x82AC3F24;
	sub_825A1770(ctx, base);
	// 82AC3F24: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82AC3F28: 4832F501  bl 0x82df3428
	ctx.lr = 0x82AC3F2C;
	sub_82DF3428(ctx, base);
	// 82AC3F2C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AC3F30: 4B804D89  bl 0x822c8cb8
	ctx.lr = 0x82AC3F34;
	sub_822C8CB8(ctx, base);
	// 82AC3F34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC3F38: 4832F4F1  bl 0x82df3428
	ctx.lr = 0x82AC3F3C;
	sub_82DF3428(ctx, base);
	// 82AC3F3C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC3F40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC3F44: 388B95D8  addi r4, r11, -0x6a28
	ctx.r[4].s64 = ctx.r[11].s64 + -27176;
	// 82AC3F48: 4832FAC1  bl 0x82df3a08
	ctx.lr = 0x82AC3F4C;
	sub_82DF3A08(ctx, base);
	// 82AC3F4C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82AC3F50: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82AC3F54: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AC3F58: 3D20832F  lis r9, -0x7cd1
	ctx.r[9].s64 = -2094071808;
	// 82AC3F5C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82AC3F60: 3889FE84  addi r4, r9, -0x17c
	ctx.r[4].s64 = ctx.r[9].s64 + -380;
	// 82AC3F64: C06B89AC  lfs f3, -0x7654(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82AC3F68: C04ADD6C  lfs f2, -0x2294(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8852 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82AC3F6C: 4BADF245  bl 0x825a31b0
	ctx.lr = 0x82AC3F70;
	sub_825A31B0(ctx, base);
	// 82AC3F70: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AC3F74: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AC3F78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC3F7C: 4BADD7F5  bl 0x825a1770
	ctx.lr = 0x82AC3F80;
	sub_825A1770(ctx, base);
	// 82AC3F80: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 82AC3F84: 4832F4A5  bl 0x82df3428
	ctx.lr = 0x82AC3F88;
	sub_82DF3428(ctx, base);
	// 82AC3F88: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 82AC3F8C: 4B804D2D  bl 0x822c8cb8
	ctx.lr = 0x82AC3F90;
	sub_822C8CB8(ctx, base);
	// 82AC3F90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC3F94: 4832F495  bl 0x82df3428
	ctx.lr = 0x82AC3F98;
	sub_82DF3428(ctx, base);
	// 82AC3F98: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC3F9C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC3FA0: 388B95BC  addi r4, r11, -0x6a44
	ctx.r[4].s64 = ctx.r[11].s64 + -27204;
	// 82AC3FA4: 4832FA65  bl 0x82df3a08
	ctx.lr = 0x82AC3FA8;
	sub_82DF3A08(ctx, base);
	// 82AC3FA8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AC3FAC: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82AC3FB0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AC3FB4: 3D20832F  lis r9, -0x7cd1
	ctx.r[9].s64 = -2094071808;
	// 82AC3FB8: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82AC3FBC: 3889FE88  addi r4, r9, -0x178
	ctx.r[4].s64 = ctx.r[9].s64 + -376;
	// 82AC3FC0: C06B964C  lfs f3, -0x69b4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82AC3FC4: C04A93AC  lfs f2, -0x6c54(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27732 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82AC3FC8: 4BADF1E9  bl 0x825a31b0
	ctx.lr = 0x82AC3FCC;
	sub_825A31B0(ctx, base);
	// 82AC3FCC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AC3FD0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AC3FD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC3FD8: 4BADD799  bl 0x825a1770
	ctx.lr = 0x82AC3FDC;
	sub_825A1770(ctx, base);
	// 82AC3FDC: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 82AC3FE0: 4832F449  bl 0x82df3428
	ctx.lr = 0x82AC3FE4;
	sub_82DF3428(ctx, base);
	// 82AC3FE4: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 82AC3FE8: 4B804CD1  bl 0x822c8cb8
	ctx.lr = 0x82AC3FEC;
	sub_822C8CB8(ctx, base);
	// 82AC3FEC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC3FF0: 4832F439  bl 0x82df3428
	ctx.lr = 0x82AC3FF4;
	sub_82DF3428(ctx, base);
	// 82AC3FF4: 38210140  addi r1, r1, 0x140
	ctx.r[1].s64 = ctx.r[1].s64 + 320;
	// 82AC3FF8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC3FFC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC4000: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AC4004: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC4008: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC4010(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC4010 size=108
    let mut pc: u32 = 0x82AC4010;
    'dispatch: loop {
        match pc {
            0x82AC4010 => {
    //   block [0x82AC4010..0x82AC407C)
	// 82AC4010: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC4014: 486E4155  bl 0x831a8168
	ctx.lr = 0x82AC4018;
	sub_831A8130(ctx, base);
	// 82AC4018: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC401C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AC4020: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82AC4024: 3BFD0161  addi r31, r29, 0x161
	ctx.r[31].s64 = ctx.r[29].s64 + 353;
	// 82AC4028: 3B9D0128  addi r28, r29, 0x128
	ctx.r[28].s64 = ctx.r[29].s64 + 296;
	// 82AC402C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC4030: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC4034: 419A002C  beq cr6, 0x82ac4060
	if ctx.cr[6].eq {
	pc = 0x82AC4060; continue 'dispatch;
	}
	// 82AC4038: 897FFFFF  lbz r11, -1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(-1 as u32) ) } as u64;
	// 82AC403C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC4040: 41820020  beq 0x82ac4060
	if ctx.cr[0].eq {
	pc = 0x82AC4060; continue 'dispatch;
	}
	// 82AC4044: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC4048: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC404C: 40820014  bne 0x82ac4060
	if !ctx.cr[0].eq {
	pc = 0x82AC4060; continue 'dispatch;
	}
	// 82AC4050: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AC4054: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC4058: 4BFFF4A1  bl 0x82ac34f8
	ctx.lr = 0x82AC405C;
	sub_82AC34F8(ctx, base);
	// 82AC405C: 987F0000  stb r3, 0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u8 ) };
	// 82AC4060: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82AC4064: 3B9C0008  addi r28, r28, 8
	ctx.r[28].s64 = ctx.r[28].s64 + 8;
	// 82AC4068: 3BFF0002  addi r31, r31, 2
	ctx.r[31].s64 = ctx.r[31].s64 + 2;
	// 82AC406C: 2B1E0007  cmplwi cr6, r30, 7
	ctx.cr[6].compare_u32(ctx.r[30].u32, 7 as u32, &mut ctx.xer);
	// 82AC4070: 4198FFBC  blt cr6, 0x82ac402c
	if ctx.cr[6].lt {
	pc = 0x82AC402C; continue 'dispatch;
	}
	// 82AC4074: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AC4078: 486E4140  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC4080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC4080 size=196
    let mut pc: u32 = 0x82AC4080;
    'dispatch: loop {
        match pc {
            0x82AC4080 => {
    //   block [0x82AC4080..0x82AC4144)
	// 82AC4080: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC4084: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC4088: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC408C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC4090: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC4094: 817F0118  lwz r11, 0x118(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 82AC4098: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC409C: 409A000C  bne cr6, 0x82ac40a8
	if !ctx.cr[6].eq {
	pc = 0x82AC40A8; continue 'dispatch;
	}
	// 82AC40A0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AC40A4: 4800008C  b 0x82ac4130
	pc = 0x82AC4130; continue 'dispatch;
	// 82AC40A8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AC40AC: 4BFFF63D  bl 0x82ac36e8
	ctx.lr = 0x82AC40B0;
	sub_82AC36E8(ctx, base);
	// 82AC40B0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC40B4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82AC40B8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AC40BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC40C0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AC40C4: 419A0024  beq cr6, 0x82ac40e8
	if ctx.cr[6].eq {
	pc = 0x82AC40E8; continue 'dispatch;
	}
	// 82AC40C8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AC40CC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AC40D0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AC40D4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AC40D8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AC40DC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AC40E0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AC40E4: 4082FFE8  bne 0x82ac40cc
	if !ctx.cr[0].eq {
	pc = 0x82AC40CC; continue 'dispatch;
	}
	// 82AC40E8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AC40EC: 80DF0118  lwz r6, 0x118(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 82AC40F0: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82AC40F4: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82AC40F8: 388A9568  addi r4, r10, -0x6a98
	ctx.r[4].s64 = ctx.r[10].s64 + -27288;
	// 82AC40FC: 38A00359  li r5, 0x359
	ctx.r[5].s64 = 857;
	// 82AC4100: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82AC4104: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC4108: 48394939  bl 0x82e58a40
	ctx.lr = 0x82AC410C;
	sub_82E58A40(ctx, base);
	// 82AC410C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AC4110: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC4114: 419A0008  beq cr6, 0x82ac411c
	if ctx.cr[6].eq {
	pc = 0x82AC411C; continue 'dispatch;
	}
	// 82AC4118: 4B7FC779  bl 0x822c0890
	ctx.lr = 0x82AC411C;
	sub_822C0890(ctx, base);
	// 82AC411C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AC4120: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC4124: 419A0008  beq cr6, 0x82ac412c
	if ctx.cr[6].eq {
	pc = 0x82AC412C; continue 'dispatch;
	}
	// 82AC4128: 4B7FC769  bl 0x822c0890
	ctx.lr = 0x82AC412C;
	sub_822C0890(ctx, base);
	// 82AC412C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82AC4130: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC4134: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC4138: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC413C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC4140: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC4148(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC4148 size=244
    let mut pc: u32 = 0x82AC4148;
    'dispatch: loop {
        match pc {
            0x82AC4148 => {
    //   block [0x82AC4148..0x82AC423C)
	// 82AC4148: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC414C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC4150: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC4154: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC4158: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC415C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC4160: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AC4164: 817F0118  lwz r11, 0x118(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 82AC4168: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC416C: 409A000C  bne cr6, 0x82ac4178
	if !ctx.cr[6].eq {
	pc = 0x82AC4178; continue 'dispatch;
	}
	// 82AC4170: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AC4174: 480000B0  b 0x82ac4224
	pc = 0x82AC4224; continue 'dispatch;
	// 82AC4178: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82AC417C: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 82AC4180: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 82AC4184: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 82AC4188: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AC418C: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82AC4190: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AC4194: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC4240(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC4240 size=256
    let mut pc: u32 = 0x82AC4240;
    'dispatch: loop {
        match pc {
            0x82AC4240 => {
    //   block [0x82AC4240..0x82AC4340)
	// 82AC4240: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC4244: 486E3F1D  bl 0x831a8160
	ctx.lr = 0x82AC4248;
	sub_831A8130(ctx, base);
	// 82AC4248: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC424C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AC4250: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82AC4254: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82AC4258: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 82AC425C: 817E0118  lwz r11, 0x118(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(280 as u32) ) } as u64;
	// 82AC4260: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC4264: 419A00D0  beq cr6, 0x82ac4334
	if ctx.cr[6].eq {
	pc = 0x82AC4334; continue 'dispatch;
	}
	// 82AC4268: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AC426C: 4BFFF4FD  bl 0x82ac3768
	ctx.lr = 0x82AC4270;
	sub_82AC3768(ctx, base);
	// 82AC4270: 83A1005C  lwz r29, 0x5c(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AC4274: 83E10058  lwz r31, 0x58(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82AC4278: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82AC427C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82AC4280: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82AC4284: 419A0024  beq cr6, 0x82ac42a8
	if ctx.cr[6].eq {
	pc = 0x82AC42A8; continue 'dispatch;
	}
	// 82AC4288: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82AC428C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AC4290: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AC4294: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AC4298: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AC429C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AC42A0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AC42A4: 4082FFE8  bne 0x82ac428c
	if !ctx.cr[0].eq {
	pc = 0x82AC428C; continue 'dispatch;
	}
	// 82AC42A8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC42AC: 80DE0118  lwz r6, 0x118(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(280 as u32) ) } as u64;
	// 82AC42B0: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82AC42B4: 388B9568  addi r4, r11, -0x6a98
	ctx.r[4].s64 = ctx.r[11].s64 + -27288;
	// 82AC42B8: 38A0037E  li r5, 0x37e
	ctx.r[5].s64 = 894;
	// 82AC42BC: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 82AC42C0: 48392D29  bl 0x82e56fe8
	ctx.lr = 0x82AC42C4;
	sub_82E56FE8(ctx, base);
	// 82AC42C4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82AC42C8: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AC42CC: 396B0000  addi r11, r11, 0
	ctx.r[11].s64 = ctx.r[11].s64 + 0;
	// 82AC42D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC42D4: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82AC42D8: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82AC42DC: 697E0001  xori r30, r11, 1
	ctx.r[30].u64 = ctx.r[11].u64 ^ 1;
	// 82AC42E0: 419A0008  beq cr6, 0x82ac42e8
	if ctx.cr[6].eq {
	pc = 0x82AC42E8; continue 'dispatch;
	}
	// 82AC42E4: 4B7FC5AD  bl 0x822c0890
	ctx.lr = 0x82AC42E8;
	sub_822C0890(ctx, base);
	// 82AC42E8: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC42EC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82AC42F0: 41820038  beq 0x82ac4328
	if ctx.cr[0].eq {
	pc = 0x82AC4328; continue 'dispatch;
	}
	// 82AC42F4: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 82AC42F8: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
	// 82AC42FC: 13FF58C7  vcmpequd (lvx128) v31, v31, v11
	tmp.u32 = ctx.r[31].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC4340(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC4340 size=196
    let mut pc: u32 = 0x82AC4340;
    'dispatch: loop {
        match pc {
            0x82AC4340 => {
    //   block [0x82AC4340..0x82AC4404)
	// 82AC4340: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC4344: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC4348: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC434C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC4350: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC4354: 817F0118  lwz r11, 0x118(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 82AC4358: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC435C: 409A000C  bne cr6, 0x82ac4368
	if !ctx.cr[6].eq {
	pc = 0x82AC4368; continue 'dispatch;
	}
	// 82AC4360: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AC4364: 4800008C  b 0x82ac43f0
	pc = 0x82AC43F0; continue 'dispatch;
	// 82AC4368: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AC436C: 4BFFF46D  bl 0x82ac37d8
	ctx.lr = 0x82AC4370;
	sub_82AC37D8(ctx, base);
	// 82AC4370: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC4374: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82AC4378: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AC437C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC4380: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AC4384: 419A0024  beq cr6, 0x82ac43a8
	if ctx.cr[6].eq {
	pc = 0x82AC43A8; continue 'dispatch;
	}
	// 82AC4388: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AC438C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AC4390: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AC4394: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AC4398: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AC439C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AC43A0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AC43A4: 4082FFE8  bne 0x82ac438c
	if !ctx.cr[0].eq {
	pc = 0x82AC438C; continue 'dispatch;
	}
	// 82AC43A8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AC43AC: 80DF0118  lwz r6, 0x118(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 82AC43B0: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82AC43B4: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82AC43B8: 388A9568  addi r4, r10, -0x6a98
	ctx.r[4].s64 = ctx.r[10].s64 + -27288;
	// 82AC43BC: 38A00393  li r5, 0x393
	ctx.r[5].s64 = 915;
	// 82AC43C0: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82AC43C4: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC43C8: 48394679  bl 0x82e58a40
	ctx.lr = 0x82AC43CC;
	sub_82E58A40(ctx, base);
	// 82AC43CC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AC43D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC43D4: 419A0008  beq cr6, 0x82ac43dc
	if ctx.cr[6].eq {
	pc = 0x82AC43DC; continue 'dispatch;
	}
	// 82AC43D8: 4B7FC4B9  bl 0x822c0890
	ctx.lr = 0x82AC43DC;
	sub_822C0890(ctx, base);
	// 82AC43DC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AC43E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC43E4: 419A0008  beq cr6, 0x82ac43ec
	if ctx.cr[6].eq {
	pc = 0x82AC43EC; continue 'dispatch;
	}
	// 82AC43E8: 4B7FC4A9  bl 0x822c0890
	ctx.lr = 0x82AC43EC;
	sub_822C0890(ctx, base);
	// 82AC43EC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82AC43F0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC43F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC43F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC43FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC4400: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC4408(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC4408 size=216
    let mut pc: u32 = 0x82AC4408;
    'dispatch: loop {
        match pc {
            0x82AC4408 => {
    //   block [0x82AC4408..0x82AC44E0)
	// 82AC4408: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC440C: 486E3D61  bl 0x831a816c
	ctx.lr = 0x82AC4410;
	sub_831A8130(ctx, base);
	// 82AC4410: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC4414: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AC4418: 817E0118  lwz r11, 0x118(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(280 as u32) ) } as u64;
	// 82AC441C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC4420: 419A00B4  beq cr6, 0x82ac44d4
	if ctx.cr[6].eq {
	pc = 0x82AC44D4; continue 'dispatch;
	}
	// 82AC4424: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AC4428: 4BFFF431  bl 0x82ac3858
	ctx.lr = 0x82AC442C;
	sub_82AC3858(ctx, base);
	// 82AC442C: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AC4430: 83A10058  lwz r29, 0x58(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82AC4434: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AC4438: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82AC443C: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82AC4440: 419A0024  beq cr6, 0x82ac4464
	if ctx.cr[6].eq {
	pc = 0x82AC4464; continue 'dispatch;
	}
	// 82AC4444: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82AC4448: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AC444C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AC4450: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AC4454: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AC4458: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AC445C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AC4460: 4082FFE8  bne 0x82ac4448
	if !ctx.cr[0].eq {
	pc = 0x82AC4448; continue 'dispatch;
	}
	// 82AC4464: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC4468: 80DE0118  lwz r6, 0x118(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(280 as u32) ) } as u64;
	// 82AC446C: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82AC4470: 388B9568  addi r4, r11, -0x6a98
	ctx.r[4].s64 = ctx.r[11].s64 + -27288;
	// 82AC4474: 38A003B2  li r5, 0x3b2
	ctx.r[5].s64 = 946;
	// 82AC4478: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 82AC447C: 48392B6D  bl 0x82e56fe8
	ctx.lr = 0x82AC4480;
	sub_82E56FE8(ctx, base);
	// 82AC4480: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82AC4484: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AC4488: 396B0000  addi r11, r11, 0
	ctx.r[11].s64 = ctx.r[11].s64 + 0;
	// 82AC448C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC4490: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82AC4494: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82AC4498: 697E0001  xori r30, r11, 1
	ctx.r[30].u64 = ctx.r[11].u64 ^ 1;
	// 82AC449C: 419A0008  beq cr6, 0x82ac44a4
	if ctx.cr[6].eq {
	pc = 0x82AC44A4; continue 'dispatch;
	}
	// 82AC44A0: 4B7FC3F1  bl 0x822c0890
	ctx.lr = 0x82AC44A4;
	sub_822C0890(ctx, base);
	// 82AC44A4: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC44A8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AC44AC: 4182001C  beq 0x82ac44c8
	if ctx.cr[0].eq {
	pc = 0x82AC44C8; continue 'dispatch;
	}
	// 82AC44B0: 8BDD0018  lbz r30, 0x18(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82AC44B4: 419A000C  beq cr6, 0x82ac44c0
	if ctx.cr[6].eq {
	pc = 0x82AC44C0; continue 'dispatch;
	}
	// 82AC44B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC44BC: 4B7FC3D5  bl 0x822c0890
	ctx.lr = 0x82AC44C0;
	sub_822C0890(ctx, base);
	// 82AC44C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC44C4: 48000014  b 0x82ac44d8
	pc = 0x82AC44D8; continue 'dispatch;
	// 82AC44C8: 419A000C  beq cr6, 0x82ac44d4
	if ctx.cr[6].eq {
	pc = 0x82AC44D4; continue 'dispatch;
	}
	// 82AC44CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC44D0: 4B7FC3C1  bl 0x822c0890
	ctx.lr = 0x82AC44D4;
	sub_822C0890(ctx, base);
	// 82AC44D4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AC44D8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AC44DC: 486E3CE0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC44E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC44E0 size=216
    let mut pc: u32 = 0x82AC44E0;
    'dispatch: loop {
        match pc {
            0x82AC44E0 => {
    //   block [0x82AC44E0..0x82AC45B8)
	// 82AC44E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC44E4: 486E3C89  bl 0x831a816c
	ctx.lr = 0x82AC44E8;
	sub_831A8130(ctx, base);
	// 82AC44E8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC44EC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AC44F0: 817E0118  lwz r11, 0x118(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(280 as u32) ) } as u64;
	// 82AC44F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC44F8: 419A00B4  beq cr6, 0x82ac45ac
	if ctx.cr[6].eq {
	pc = 0x82AC45AC; continue 'dispatch;
	}
	// 82AC44FC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AC4500: 4BFFF3C9  bl 0x82ac38c8
	ctx.lr = 0x82AC4504;
	sub_82AC38C8(ctx, base);
	// 82AC4504: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AC4508: 83A10058  lwz r29, 0x58(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82AC450C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AC4510: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82AC4514: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82AC4518: 419A0024  beq cr6, 0x82ac453c
	if ctx.cr[6].eq {
	pc = 0x82AC453C; continue 'dispatch;
	}
	// 82AC451C: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82AC4520: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AC4524: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AC4528: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AC452C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AC4530: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AC4534: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AC4538: 4082FFE8  bne 0x82ac4520
	if !ctx.cr[0].eq {
	pc = 0x82AC4520; continue 'dispatch;
	}
	// 82AC453C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC4540: 80DE0118  lwz r6, 0x118(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(280 as u32) ) } as u64;
	// 82AC4544: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82AC4548: 388B9568  addi r4, r11, -0x6a98
	ctx.r[4].s64 = ctx.r[11].s64 + -27288;
	// 82AC454C: 38A003C4  li r5, 0x3c4
	ctx.r[5].s64 = 964;
	// 82AC4550: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 82AC4554: 48392A95  bl 0x82e56fe8
	ctx.lr = 0x82AC4558;
	sub_82E56FE8(ctx, base);
	// 82AC4558: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82AC455C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AC4560: 396B0000  addi r11, r11, 0
	ctx.r[11].s64 = ctx.r[11].s64 + 0;
	// 82AC4564: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC4568: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82AC456C: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82AC4570: 697E0001  xori r30, r11, 1
	ctx.r[30].u64 = ctx.r[11].u64 ^ 1;
	// 82AC4574: 419A0008  beq cr6, 0x82ac457c
	if ctx.cr[6].eq {
	pc = 0x82AC457C; continue 'dispatch;
	}
	// 82AC4578: 4B7FC319  bl 0x822c0890
	ctx.lr = 0x82AC457C;
	sub_822C0890(ctx, base);
	// 82AC457C: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC4580: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AC4584: 4182001C  beq 0x82ac45a0
	if ctx.cr[0].eq {
	pc = 0x82AC45A0; continue 'dispatch;
	}
	// 82AC4588: 83DD0018  lwz r30, 0x18(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82AC458C: 419A000C  beq cr6, 0x82ac4598
	if ctx.cr[6].eq {
	pc = 0x82AC4598; continue 'dispatch;
	}
	// 82AC4590: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC4594: 4B7FC2FD  bl 0x822c0890
	ctx.lr = 0x82AC4598;
	sub_822C0890(ctx, base);
	// 82AC4598: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC459C: 48000014  b 0x82ac45b0
	pc = 0x82AC45B0; continue 'dispatch;
	// 82AC45A0: 419A000C  beq cr6, 0x82ac45ac
	if ctx.cr[6].eq {
	pc = 0x82AC45AC; continue 'dispatch;
	}
	// 82AC45A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC45A8: 4B7FC2E9  bl 0x822c0890
	ctx.lr = 0x82AC45AC;
	sub_822C0890(ctx, base);
	// 82AC45AC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AC45B0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AC45B4: 486E3C08  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC45B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC45B8 size=212
    let mut pc: u32 = 0x82AC45B8;
    'dispatch: loop {
        match pc {
            0x82AC45B8 => {
    //   block [0x82AC45B8..0x82AC468C)
	// 82AC45B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC45BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC45C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC45C4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC45C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC45CC: 9081008C  stw r4, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[4].u32 ) };
	// 82AC45D0: 98A10097  stb r5, 0x97(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(151 as u32), ctx.r[5].u8 ) };
	// 82AC45D4: 817F0118  lwz r11, 0x118(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 82AC45D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC45DC: 409A000C  bne cr6, 0x82ac45e8
	if !ctx.cr[6].eq {
	pc = 0x82AC45E8; continue 'dispatch;
	}
	// 82AC45E0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AC45E4: 48000094  b 0x82ac4678
	pc = 0x82AC4678; continue 'dispatch;
	// 82AC45E8: 38A10097  addi r5, r1, 0x97
	ctx.r[5].s64 = ctx.r[1].s64 + 151;
	// 82AC45EC: 3881008C  addi r4, r1, 0x8c
	ctx.r[4].s64 = ctx.r[1].s64 + 140;
	// 82AC45F0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AC45F4: 4BFEF6BD  bl 0x82ab3cb0
	ctx.lr = 0x82AC45F8;
	sub_82AB3CB0(ctx, base);
	// 82AC45F8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC45FC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82AC4600: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AC4604: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC4608: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AC460C: 419A0024  beq cr6, 0x82ac4630
	if ctx.cr[6].eq {
	pc = 0x82AC4630; continue 'dispatch;
	}
	// 82AC4610: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AC4614: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AC4618: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AC461C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AC4620: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AC4624: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AC4628: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AC462C: 4082FFE8  bne 0x82ac4614
	if !ctx.cr[0].eq {
	pc = 0x82AC4614; continue 'dispatch;
	}
	// 82AC4630: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AC4634: 80DF0118  lwz r6, 0x118(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 82AC4638: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82AC463C: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82AC4640: 388A9568  addi r4, r10, -0x6a98
	ctx.r[4].s64 = ctx.r[10].s64 + -27288;
	// 82AC4644: 38A003D7  li r5, 0x3d7
	ctx.r[5].s64 = 983;
	// 82AC4648: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82AC464C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC4650: 483943F1  bl 0x82e58a40
	ctx.lr = 0x82AC4654;
	sub_82E58A40(ctx, base);
	// 82AC4654: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AC4658: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC465C: 419A0008  beq cr6, 0x82ac4664
	if ctx.cr[6].eq {
	pc = 0x82AC4664; continue 'dispatch;
	}
	// 82AC4660: 4B7FC231  bl 0x822c0890
	ctx.lr = 0x82AC4664;
	sub_822C0890(ctx, base);
	// 82AC4664: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AC4668: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC466C: 419A0008  beq cr6, 0x82ac4674
	if ctx.cr[6].eq {
	pc = 0x82AC4674; continue 'dispatch;
	}
	// 82AC4670: 4B7FC221  bl 0x822c0890
	ctx.lr = 0x82AC4674;
	sub_822C0890(ctx, base);
	// 82AC4674: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82AC4678: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC467C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC4680: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC4684: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC4688: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC4690(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC4690 size=216
    let mut pc: u32 = 0x82AC4690;
    'dispatch: loop {
        match pc {
            0x82AC4690 => {
    //   block [0x82AC4690..0x82AC4768)
	// 82AC4690: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC4694: 486E3AD9  bl 0x831a816c
	ctx.lr = 0x82AC4698;
	sub_831A8130(ctx, base);
	// 82AC4698: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC469C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AC46A0: 817E0118  lwz r11, 0x118(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(280 as u32) ) } as u64;
	// 82AC46A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC46A8: 419A00B4  beq cr6, 0x82ac475c
	if ctx.cr[6].eq {
	pc = 0x82AC475C; continue 'dispatch;
	}
	// 82AC46AC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AC46B0: 4BFB7409  bl 0x82a7bab8
	ctx.lr = 0x82AC46B4;
	sub_82A7BAB8(ctx, base);
	// 82AC46B4: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AC46B8: 83A10058  lwz r29, 0x58(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82AC46BC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AC46C0: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82AC46C4: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82AC46C8: 419A0024  beq cr6, 0x82ac46ec
	if ctx.cr[6].eq {
	pc = 0x82AC46EC; continue 'dispatch;
	}
	// 82AC46CC: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82AC46D0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AC46D4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AC46D8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AC46DC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AC46E0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AC46E4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AC46E8: 4082FFE8  bne 0x82ac46d0
	if !ctx.cr[0].eq {
	pc = 0x82AC46D0; continue 'dispatch;
	}
	// 82AC46EC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC46F0: 80DE0118  lwz r6, 0x118(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(280 as u32) ) } as u64;
	// 82AC46F4: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82AC46F8: 388B9568  addi r4, r11, -0x6a98
	ctx.r[4].s64 = ctx.r[11].s64 + -27288;
	// 82AC46FC: 38A003E9  li r5, 0x3e9
	ctx.r[5].s64 = 1001;
	// 82AC4700: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 82AC4704: 483928E5  bl 0x82e56fe8
	ctx.lr = 0x82AC4708;
	sub_82E56FE8(ctx, base);
	// 82AC4708: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82AC470C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AC4710: 396B0000  addi r11, r11, 0
	ctx.r[11].s64 = ctx.r[11].s64 + 0;
	// 82AC4714: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC4718: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82AC471C: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82AC4720: 697E0001  xori r30, r11, 1
	ctx.r[30].u64 = ctx.r[11].u64 ^ 1;
	// 82AC4724: 419A0008  beq cr6, 0x82ac472c
	if ctx.cr[6].eq {
	pc = 0x82AC472C; continue 'dispatch;
	}
	// 82AC4728: 4B7FC169  bl 0x822c0890
	ctx.lr = 0x82AC472C;
	sub_822C0890(ctx, base);
	// 82AC472C: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC4730: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AC4734: 4182001C  beq 0x82ac4750
	if ctx.cr[0].eq {
	pc = 0x82AC4750; continue 'dispatch;
	}
	// 82AC4738: 8BDD0018  lbz r30, 0x18(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82AC473C: 419A000C  beq cr6, 0x82ac4748
	if ctx.cr[6].eq {
	pc = 0x82AC4748; continue 'dispatch;
	}
	// 82AC4740: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC4744: 4B7FC14D  bl 0x822c0890
	ctx.lr = 0x82AC4748;
	sub_822C0890(ctx, base);
	// 82AC4748: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC474C: 48000014  b 0x82ac4760
	pc = 0x82AC4760; continue 'dispatch;
	// 82AC4750: 419A000C  beq cr6, 0x82ac475c
	if ctx.cr[6].eq {
	pc = 0x82AC475C; continue 'dispatch;
	}
	// 82AC4754: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC4758: 4B7FC139  bl 0x822c0890
	ctx.lr = 0x82AC475C;
	sub_822C0890(ctx, base);
	// 82AC475C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AC4760: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AC4764: 486E3A58  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC4768(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC4768 size=204
    let mut pc: u32 = 0x82AC4768;
    'dispatch: loop {
        match pc {
            0x82AC4768 => {
    //   block [0x82AC4768..0x82AC4834)
	// 82AC4768: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC476C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC4770: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC4774: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC4778: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC477C: 9081008C  stw r4, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[4].u32 ) };
	// 82AC4780: 817F0118  lwz r11, 0x118(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 82AC4784: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC4788: 409A000C  bne cr6, 0x82ac4794
	if !ctx.cr[6].eq {
	pc = 0x82AC4794; continue 'dispatch;
	}
	// 82AC478C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AC4790: 48000090  b 0x82ac4820
	pc = 0x82AC4820; continue 'dispatch;
	// 82AC4794: 3881008C  addi r4, r1, 0x8c
	ctx.r[4].s64 = ctx.r[1].s64 + 140;
	// 82AC4798: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AC479C: 4BFFF19D  bl 0x82ac3938
	ctx.lr = 0x82AC47A0;
	sub_82AC3938(ctx, base);
	// 82AC47A0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC47A4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82AC47A8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AC47AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC47B0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AC47B4: 419A0024  beq cr6, 0x82ac47d8
	if ctx.cr[6].eq {
	pc = 0x82AC47D8; continue 'dispatch;
	}
	// 82AC47B8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AC47BC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AC47C0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AC47C4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AC47C8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AC47CC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AC47D0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AC47D4: 4082FFE8  bne 0x82ac47bc
	if !ctx.cr[0].eq {
	pc = 0x82AC47BC; continue 'dispatch;
	}
	// 82AC47D8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AC47DC: 80DF0118  lwz r6, 0x118(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 82AC47E0: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82AC47E4: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82AC47E8: 388A9568  addi r4, r10, -0x6a98
	ctx.r[4].s64 = ctx.r[10].s64 + -27288;
	// 82AC47EC: 38A003F6  li r5, 0x3f6
	ctx.r[5].s64 = 1014;
	// 82AC47F0: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82AC47F4: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC47F8: 48394249  bl 0x82e58a40
	ctx.lr = 0x82AC47FC;
	sub_82E58A40(ctx, base);
	// 82AC47FC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AC4800: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC4804: 419A0008  beq cr6, 0x82ac480c
	if ctx.cr[6].eq {
	pc = 0x82AC480C; continue 'dispatch;
	}
	// 82AC4808: 4B7FC089  bl 0x822c0890
	ctx.lr = 0x82AC480C;
	sub_822C0890(ctx, base);
	// 82AC480C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AC4810: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC4814: 419A0008  beq cr6, 0x82ac481c
	if ctx.cr[6].eq {
	pc = 0x82AC481C; continue 'dispatch;
	}
	// 82AC4818: 4B7FC079  bl 0x822c0890
	ctx.lr = 0x82AC481C;
	sub_822C0890(ctx, base);
	// 82AC481C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82AC4820: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC4824: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC4828: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC482C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC4830: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC4838(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC4838 size=216
    let mut pc: u32 = 0x82AC4838;
    'dispatch: loop {
        match pc {
            0x82AC4838 => {
    //   block [0x82AC4838..0x82AC4910)
	// 82AC4838: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC483C: 486E3931  bl 0x831a816c
	ctx.lr = 0x82AC4840;
	sub_831A8130(ctx, base);
	// 82AC4840: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC4844: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AC4848: 817E0118  lwz r11, 0x118(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(280 as u32) ) } as u64;
	// 82AC484C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC4850: 419A00B4  beq cr6, 0x82ac4904
	if ctx.cr[6].eq {
	pc = 0x82AC4904; continue 'dispatch;
	}
	// 82AC4854: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AC4858: 4BFFF159  bl 0x82ac39b0
	ctx.lr = 0x82AC485C;
	sub_82AC39B0(ctx, base);
	// 82AC485C: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AC4860: 83A10058  lwz r29, 0x58(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82AC4864: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AC4868: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82AC486C: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82AC4870: 419A0024  beq cr6, 0x82ac4894
	if ctx.cr[6].eq {
	pc = 0x82AC4894; continue 'dispatch;
	}
	// 82AC4874: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82AC4878: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AC487C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AC4880: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AC4884: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AC4888: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AC488C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AC4890: 4082FFE8  bne 0x82ac4878
	if !ctx.cr[0].eq {
	pc = 0x82AC4878; continue 'dispatch;
	}
	// 82AC4894: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC4898: 80DE0118  lwz r6, 0x118(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(280 as u32) ) } as u64;
	// 82AC489C: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82AC48A0: 388B9568  addi r4, r11, -0x6a98
	ctx.r[4].s64 = ctx.r[11].s64 + -27288;
	// 82AC48A4: 38A00407  li r5, 0x407
	ctx.r[5].s64 = 1031;
	// 82AC48A8: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 82AC48AC: 4839273D  bl 0x82e56fe8
	ctx.lr = 0x82AC48B0;
	sub_82E56FE8(ctx, base);
	// 82AC48B0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82AC48B4: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AC48B8: 396B0000  addi r11, r11, 0
	ctx.r[11].s64 = ctx.r[11].s64 + 0;
	// 82AC48BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC48C0: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82AC48C4: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82AC48C8: 697E0001  xori r30, r11, 1
	ctx.r[30].u64 = ctx.r[11].u64 ^ 1;
	// 82AC48CC: 419A0008  beq cr6, 0x82ac48d4
	if ctx.cr[6].eq {
	pc = 0x82AC48D4; continue 'dispatch;
	}
	// 82AC48D0: 4B7FBFC1  bl 0x822c0890
	ctx.lr = 0x82AC48D4;
	sub_822C0890(ctx, base);
	// 82AC48D4: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC48D8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AC48DC: 4182001C  beq 0x82ac48f8
	if ctx.cr[0].eq {
	pc = 0x82AC48F8; continue 'dispatch;
	}
	// 82AC48E0: 8BDD0018  lbz r30, 0x18(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82AC48E4: 419A000C  beq cr6, 0x82ac48f0
	if ctx.cr[6].eq {
	pc = 0x82AC48F0; continue 'dispatch;
	}
	// 82AC48E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC48EC: 4B7FBFA5  bl 0x822c0890
	ctx.lr = 0x82AC48F0;
	sub_822C0890(ctx, base);
	// 82AC48F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC48F4: 48000014  b 0x82ac4908
	pc = 0x82AC4908; continue 'dispatch;
	// 82AC48F8: 419A000C  beq cr6, 0x82ac4904
	if ctx.cr[6].eq {
	pc = 0x82AC4904; continue 'dispatch;
	}
	// 82AC48FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC4900: 4B7FBF91  bl 0x822c0890
	ctx.lr = 0x82AC4904;
	sub_822C0890(ctx, base);
	// 82AC4904: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AC4908: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AC490C: 486E38B0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC4910(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC4910 size=184
    let mut pc: u32 = 0x82AC4910;
    'dispatch: loop {
        match pc {
            0x82AC4910 => {
    //   block [0x82AC4910..0x82AC49C8)
	// 82AC4910: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC4914: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC4918: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC491C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC4920: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC4924: 817F0118  lwz r11, 0x118(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 82AC4928: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC492C: 419A0088  beq cr6, 0x82ac49b4
	if ctx.cr[6].eq {
	pc = 0x82AC49B4; continue 'dispatch;
	}
	// 82AC4930: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AC4934: 4BFFF0ED  bl 0x82ac3a20
	ctx.lr = 0x82AC4938;
	sub_82AC3A20(ctx, base);
	// 82AC4938: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC493C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82AC4940: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AC4944: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC4948: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AC494C: 419A0024  beq cr6, 0x82ac4970
	if ctx.cr[6].eq {
	pc = 0x82AC4970; continue 'dispatch;
	}
	// 82AC4950: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AC4954: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AC4958: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AC495C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AC4960: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AC4964: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AC4968: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AC496C: 4082FFE8  bne 0x82ac4954
	if !ctx.cr[0].eq {
	pc = 0x82AC4954; continue 'dispatch;
	}
	// 82AC4970: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AC4974: 80DF0118  lwz r6, 0x118(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 82AC4978: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82AC497C: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82AC4980: 388A9568  addi r4, r10, -0x6a98
	ctx.r[4].s64 = ctx.r[10].s64 + -27288;
	// 82AC4984: 38A00414  li r5, 0x414
	ctx.r[5].s64 = 1044;
	// 82AC4988: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82AC498C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC4990: 483940B1  bl 0x82e58a40
	ctx.lr = 0x82AC4994;
	sub_82E58A40(ctx, base);
	// 82AC4994: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AC4998: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC499C: 419A0008  beq cr6, 0x82ac49a4
	if ctx.cr[6].eq {
	pc = 0x82AC49A4; continue 'dispatch;
	}
	// 82AC49A0: 4B7FBEF1  bl 0x822c0890
	ctx.lr = 0x82AC49A4;
	sub_822C0890(ctx, base);
	// 82AC49A4: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AC49A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC49AC: 419A0008  beq cr6, 0x82ac49b4
	if ctx.cr[6].eq {
	pc = 0x82AC49B4; continue 'dispatch;
	}
	// 82AC49B0: 4B7FBEE1  bl 0x822c0890
	ctx.lr = 0x82AC49B4;
	sub_822C0890(ctx, base);
	// 82AC49B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC49B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC49BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC49C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC49C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC49C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC49C8 size=192
    let mut pc: u32 = 0x82AC49C8;
    'dispatch: loop {
        match pc {
            0x82AC49C8 => {
    //   block [0x82AC49C8..0x82AC4A88)
	// 82AC49C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC49CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC49D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC49D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC49D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC49DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC49E0: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AC49E4: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82AC49E8: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82AC49EC: C19F00F8  lfs f12, 0xf8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82AC49F0: C00BFE80  lfs f0, -0x180(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-384 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC49F4: C1AA93AC  lfs f13, -0x6c54(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27732 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AC49F8: EDA0637C  fnmsubs f13, f0, f13, f12
	ctx.f[13].f64 = -(((ctx.f[0].f64 * ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 82AC49FC: C00908A4  lfs f0, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC4A00: D1BF00F8  stfs f13, 0xf8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 82AC4A04: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82AC4A08: 41990064  bgt cr6, 0x82ac4a6c
	if ctx.cr[6].gt {
	pc = 0x82AC4A6C; continue 'dispatch;
	}
	// 82AC4A0C: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82AC4A10: D01F00F8  stfs f0, 0xf8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 82AC4A14: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 82AC4A18: 4BFFFEF9  bl 0x82ac4910
	ctx.lr = 0x82AC4A1C;
	sub_82AC4910(ctx, base);
	// 82AC4A1C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC4A20: 4BA26069  bl 0x824eaa88
	ctx.lr = 0x82AC4A24;
	sub_824EAA88(ctx, base);
	// 82AC4A24: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC4A28: 4BA24E29  bl 0x824e9850
	ctx.lr = 0x82AC4A2C;
	sub_824E9850(ctx, base);
	// 82AC4A2C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AC4A30: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82AC4A34: C00B9450  lfs f0, -0x6bb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC4A38: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82AC4A3C: 41990008  bgt cr6, 0x82ac4a44
	if ctx.cr[6].gt {
	pc = 0x82AC4A44; continue 'dispatch;
	}
	// 82AC4A40: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82AC4A44: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC4A48: 4832D249  bl 0x82df1c90
	ctx.lr = 0x82AC4A4C;
	sub_82DF1C90(ctx, base);
	// 82AC4A4C: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC4A50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC4A54: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82AC4A58: 40820008  bne 0x82ac4a60
	if !ctx.cr[0].eq {
	pc = 0x82AC4A60; continue 'dispatch;
	}
	// 82AC4A5C: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82AC4A60: 4BFFFD09  bl 0x82ac4768
	ctx.lr = 0x82AC4A64;
	sub_82AC4768(ctx, base);
	// 82AC4A64: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82AC4A68: 48000008  b 0x82ac4a70
	pc = 0x82AC4A70; continue 'dispatch;
	// 82AC4A6C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AC4A70: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC4A74: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC4A78: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC4A7C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AC4A80: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC4A84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC4A88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC4A88 size=596
    let mut pc: u32 = 0x82AC4A88;
    'dispatch: loop {
        match pc {
            0x82AC4A88 => {
    //   block [0x82AC4A88..0x82AC4CDC)
	// 82AC4A88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC4A8C: 486E36E1  bl 0x831a816c
	ctx.lr = 0x82AC4A90;
	sub_831A8130(ctx, base);
	// 82AC4A90: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC4A94: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AC4A98: 4BFFFDA1  bl 0x82ac4838
	ctx.lr = 0x82AC4A9C;
	sub_82AC4838(ctx, base);
	// 82AC4A9C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC4AA0: 40820234  bne 0x82ac4cd4
	if !ctx.cr[0].eq {
	pc = 0x82AC4CD4; continue 'dispatch;
	}
	// 82AC4AA4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82AC4AA8: 4BA25FE1  bl 0x824eaa88
	ctx.lr = 0x82AC4AAC;
	sub_824EAA88(ctx, base);
	// 82AC4AAC: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC4AB0: 4BA24DA1  bl 0x824e9850
	ctx.lr = 0x82AC4AB4;
	sub_824E9850(ctx, base);
	// 82AC4AB4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AC4AB8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82AC4ABC: C00BA1C4  lfs f0, -0x5e3c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC4AC0: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82AC4AC4: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82AC4AC8: D8010070  stfd f0, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.f[0].u64 ) };
	// 82AC4ACC: 83C10074  lwz r30, 0x74(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82AC4AD0: 4832D1C1  bl 0x82df1c90
	ctx.lr = 0x82AC4AD4;
	sub_82DF1C90(ctx, base);
	// 82AC4AD4: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AC4AD8: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82AC4ADC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AC4AE0: C00BFE80  lfs f0, -0x180(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-384 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC4AE4: C1AA93AC  lfs f13, -0x6c54(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27732 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AC4AE8: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82AC4AEC: C1BD00F8  lfs f13, 0xf8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(248 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AC4AF0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82AC4AF4: 41980008  blt cr6, 0x82ac4afc
	if ctx.cr[6].lt {
	pc = 0x82AC4AFC; continue 'dispatch;
	}
	// 82AC4AF8: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 82AC4AFC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AC4B00: 4832E5F1  bl 0x82df30f0
	ctx.lr = 0x82AC4B04;
	sub_82DF30F0(ctx, base);
	// 82AC4B04: 2F1E0001  cmpwi cr6, r30, 1
	ctx.cr[6].compare_i32(ctx.r[30].s32, 1, &mut ctx.xer);
	// 82AC4B08: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC4B0C: 419A00A4  beq cr6, 0x82ac4bb0
	if ctx.cr[6].eq {
	pc = 0x82AC4BB0; continue 'dispatch;
	}
	// 82AC4B10: 2F1E0002  cmpwi cr6, r30, 2
	ctx.cr[6].compare_i32(ctx.r[30].s32, 2, &mut ctx.xer);
	// 82AC4B14: 419A0050  beq cr6, 0x82ac4b64
	if ctx.cr[6].eq {
	pc = 0x82AC4B64; continue 'dispatch;
	}
	// 82AC4B18: 40820028  bne 0x82ac4b40
	if !ctx.cr[0].eq {
	pc = 0x82AC4B40; continue 'dispatch;
	}
	// 82AC4B1C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AC4B20: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AC4B24: 388B021C  addi r4, r11, 0x21c
	ctx.r[4].s64 = ctx.r[11].s64 + 540;
	// 82AC4B28: 4832EEE1  bl 0x82df3a08
	ctx.lr = 0x82AC4B2C;
	sub_82DF3A08(ctx, base);
	// 82AC4B2C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82AC4B30: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AC4B34: 4832EFA5  bl 0x82df3ad8
	ctx.lr = 0x82AC4B38;
	sub_82DF3AD8(ctx, base);
	// 82AC4B38: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AC4B3C: 480000BC  b 0x82ac4bf8
	pc = 0x82AC4BF8; continue 'dispatch;
	// 82AC4B40: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AC4B44: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82AC4B48: 388B0234  addi r4, r11, 0x234
	ctx.r[4].s64 = ctx.r[11].s64 + 564;
	// 82AC4B4C: 4832EEBD  bl 0x82df3a08
	ctx.lr = 0x82AC4B50;
	sub_82DF3A08(ctx, base);
	// 82AC4B50: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 82AC4B54: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AC4B58: 4832EF81  bl 0x82df3ad8
	ctx.lr = 0x82AC4B5C;
	sub_82DF3AD8(ctx, base);
	// 82AC4B5C: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82AC4B60: 48000098  b 0x82ac4bf8
	pc = 0x82AC4BF8; continue 'dispatch;
	// 82AC4B64: 40820028  bne 0x82ac4b8c
	if !ctx.cr[0].eq {
	pc = 0x82AC4B8C; continue 'dispatch;
	}
	// 82AC4B68: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC4B6C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AC4B70: 388B9604  addi r4, r11, -0x69fc
	ctx.r[4].s64 = ctx.r[11].s64 + -27132;
	// 82AC4B74: 4832EE95  bl 0x82df3a08
	ctx.lr = 0x82AC4B78;
	sub_82DF3A08(ctx, base);
	// 82AC4B78: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82AC4B7C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AC4B80: 4832EF59  bl 0x82df3ad8
	ctx.lr = 0x82AC4B84;
	sub_82DF3AD8(ctx, base);
	// 82AC4B84: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AC4B88: 48000070  b 0x82ac4bf8
	pc = 0x82AC4BF8; continue 'dispatch;
	// 82AC4B8C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AC4B90: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82AC4B94: 388B0234  addi r4, r11, 0x234
	ctx.r[4].s64 = ctx.r[11].s64 + 564;
	// 82AC4B98: 4832EE71  bl 0x82df3a08
	ctx.lr = 0x82AC4B9C;
	sub_82DF3A08(ctx, base);
	// 82AC4B9C: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 82AC4BA0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AC4BA4: 4832EF35  bl 0x82df3ad8
	ctx.lr = 0x82AC4BA8;
	sub_82DF3AD8(ctx, base);
	// 82AC4BA8: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82AC4BAC: 4800004C  b 0x82ac4bf8
	pc = 0x82AC4BF8; continue 'dispatch;
	// 82AC4BB0: 40820028  bne 0x82ac4bd8
	if !ctx.cr[0].eq {
	pc = 0x82AC4BD8; continue 'dispatch;
	}
	// 82AC4BB4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AC4BB8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82AC4BBC: 388B0210  addi r4, r11, 0x210
	ctx.r[4].s64 = ctx.r[11].s64 + 528;
	// 82AC4BC0: 4832EE49  bl 0x82df3a08
	ctx.lr = 0x82AC4BC4;
	sub_82DF3A08(ctx, base);
	// 82AC4BC4: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82AC4BC8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AC4BCC: 4832EF0D  bl 0x82df3ad8
	ctx.lr = 0x82AC4BD0;
	sub_82DF3AD8(ctx, base);
	// 82AC4BD0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82AC4BD4: 48000024  b 0x82ac4bf8
	pc = 0x82AC4BF8; continue 'dispatch;
	// 82AC4BD8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AC4BDC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AC4BE0: 388B0234  addi r4, r11, 0x234
	ctx.r[4].s64 = ctx.r[11].s64 + 564;
	// 82AC4BE4: 4832EE25  bl 0x82df3a08
	ctx.lr = 0x82AC4BE8;
	sub_82DF3A08(ctx, base);
	// 82AC4BE8: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82AC4BEC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AC4BF0: 4832EEE9  bl 0x82df3ad8
	ctx.lr = 0x82AC4BF4;
	sub_82DF3AD8(ctx, base);
	// 82AC4BF4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AC4BF8: 4832E831  bl 0x82df3428
	ctx.lr = 0x82AC4BFC;
	sub_82DF3428(ctx, base);
	// 82AC4BFC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC4C00: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AC4C04: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 82AC4C08: 4832E5A9  bl 0x82df31b0
	ctx.lr = 0x82AC4C0C;
	sub_82DF31B0(ctx, base);
	// 82AC4C0C: 90610070  stw r3, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[3].u32 ) };
	// 82AC4C10: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82AC4C14: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82AC4C18: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82AC4C1C: 4BF2B36D  bl 0x829eff88
	ctx.lr = 0x82AC4C20;
	sub_829EFF88(ctx, base);
	// 82AC4C20: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC4C24: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82AC4C28: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AC4C2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC4C30: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82AC4C34: 419A0024  beq cr6, 0x82ac4c58
	if ctx.cr[6].eq {
	pc = 0x82AC4C58; continue 'dispatch;
	}
	// 82AC4C38: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AC4C3C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AC4C40: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AC4C44: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AC4C48: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AC4C4C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AC4C50: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AC4C54: 4082FFE8  bne 0x82ac4c3c
	if !ctx.cr[0].eq {
	pc = 0x82AC4C3C; continue 'dispatch;
	}
	// 82AC4C58: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AC4C5C: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82AC4C60: 4BA4A869  bl 0x8250f4c8
	ctx.lr = 0x82AC4C64;
	sub_8250F4C8(ctx, base);
	// 82AC4C64: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC4C68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC4C6C: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82AC4C70: 409A0008  bne cr6, 0x82ac4c78
	if !ctx.cr[6].eq {
	pc = 0x82AC4C78; continue 'dispatch;
	}
	// 82AC4C74: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AC4C78: 3BE10078  addi r31, r1, 0x78
	ctx.r[31].s64 = ctx.r[1].s64 + 120;
	// 82AC4C7C: 4BA4399D  bl 0x82508618
	ctx.lr = 0x82AC4C80;
	sub_82508618(ctx, base);
	// 82AC4C80: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AC4C84: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82AC4C88: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82AC4C8C: 388A9568  addi r4, r10, -0x6a98
	ctx.r[4].s64 = ctx.r[10].s64 + -27288;
	// 82AC4C90: 38A00103  li r5, 0x103
	ctx.r[5].s64 = 259;
	// 82AC4C94: 387D0028  addi r3, r29, 0x28
	ctx.r[3].s64 = ctx.r[29].s64 + 40;
	// 82AC4C98: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC4C9C: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82AC4CA0: 48393DA1  bl 0x82e58a40
	ctx.lr = 0x82AC4CA4;
	sub_82E58A40(ctx, base);
	// 82AC4CA4: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82AC4CA8: 4832CFE9  bl 0x82df1c90
	ctx.lr = 0x82AC4CAC;
	sub_82DF1C90(ctx, base);
	// 82AC4CAC: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82AC4CB0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC4CB4: 419A0008  beq cr6, 0x82ac4cbc
	if ctx.cr[6].eq {
	pc = 0x82AC4CBC; continue 'dispatch;
	}
	// 82AC4CB8: 4B7FBBD9  bl 0x822c0890
	ctx.lr = 0x82AC4CBC;
	sub_822C0890(ctx, base);
	// 82AC4CBC: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82AC4CC0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC4CC4: 419A0008  beq cr6, 0x82ac4ccc
	if ctx.cr[6].eq {
	pc = 0x82AC4CCC; continue 'dispatch;
	}
	// 82AC4CC8: 4B7FBBC9  bl 0x822c0890
	ctx.lr = 0x82AC4CCC;
	sub_822C0890(ctx, base);
	// 82AC4CCC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AC4CD0: 4832E759  bl 0x82df3428
	ctx.lr = 0x82AC4CD4;
	sub_82DF3428(ctx, base);
	// 82AC4CD4: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82AC4CD8: 486E34E4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC4CE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC4CE0 size=412
    let mut pc: u32 = 0x82AC4CE0;
    'dispatch: loop {
        match pc {
            0x82AC4CE0 => {
    //   block [0x82AC4CE0..0x82AC4E7C)
	// 82AC4CE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC4CE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC4CE8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC4CEC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC4CF0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC4CF4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC4CF8: 4BFFFB41  bl 0x82ac4838
	ctx.lr = 0x82AC4CFC;
	sub_82AC4838(ctx, base);
	// 82AC4CFC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC4D00: 40820164  bne 0x82ac4e64
	if !ctx.cr[0].eq {
	pc = 0x82AC4E64; continue 'dispatch;
	}
	// 82AC4D04: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AC4D08: 4BA25D81  bl 0x824eaa88
	ctx.lr = 0x82AC4D0C;
	sub_824EAA88(ctx, base);
	// 82AC4D0C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC4D10: 4BA24B41  bl 0x824e9850
	ctx.lr = 0x82AC4D14;
	sub_824E9850(ctx, base);
	// 82AC4D14: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AC4D18: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AC4D1C: C00B9524  lfs f0, -0x6adc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC4D20: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82AC4D24: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82AC4D28: D8010060  stfd f0, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.f[0].u64 ) };
	// 82AC4D2C: 83C10064  lwz r30, 0x64(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82AC4D30: 4832CF61  bl 0x82df1c90
	ctx.lr = 0x82AC4D34;
	sub_82DF1C90(ctx, base);
	// 82AC4D34: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AC4D38: 4832E3B9  bl 0x82df30f0
	ctx.lr = 0x82AC4D3C;
	sub_82DF30F0(ctx, base);
	// 82AC4D3C: 2F1E0001  cmpwi cr6, r30, 1
	ctx.cr[6].compare_i32(ctx.r[30].s32, 1, &mut ctx.xer);
	// 82AC4D40: 419A0028  beq cr6, 0x82ac4d68
	if ctx.cr[6].eq {
	pc = 0x82AC4D68; continue 'dispatch;
	}
	// 82AC4D44: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AC4D48: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AC4D4C: 388B01E0  addi r4, r11, 0x1e0
	ctx.r[4].s64 = ctx.r[11].s64 + 480;
	// 82AC4D50: 4832ECB9  bl 0x82df3a08
	ctx.lr = 0x82AC4D54;
	sub_82DF3A08(ctx, base);
	// 82AC4D54: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82AC4D58: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AC4D5C: 4832ED7D  bl 0x82df3ad8
	ctx.lr = 0x82AC4D60;
	sub_82DF3AD8(ctx, base);
	// 82AC4D60: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AC4D64: 48000024  b 0x82ac4d88
	pc = 0x82AC4D88; continue 'dispatch;
	// 82AC4D68: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AC4D6C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AC4D70: 388B01D4  addi r4, r11, 0x1d4
	ctx.r[4].s64 = ctx.r[11].s64 + 468;
	// 82AC4D74: 4832EC95  bl 0x82df3a08
	ctx.lr = 0x82AC4D78;
	sub_82DF3A08(ctx, base);
	// 82AC4D78: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82AC4D7C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AC4D80: 4832ED59  bl 0x82df3ad8
	ctx.lr = 0x82AC4D84;
	sub_82DF3AD8(ctx, base);
	// 82AC4D84: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AC4D88: 4832E6A1  bl 0x82df3428
	ctx.lr = 0x82AC4D8C;
	sub_82DF3428(ctx, base);
	// 82AC4D8C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC4D90: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AC4D94: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 82AC4D98: 4832E419  bl 0x82df31b0
	ctx.lr = 0x82AC4D9C;
	sub_82DF31B0(ctx, base);
	// 82AC4D9C: 90610060  stw r3, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 82AC4DA0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82AC4DA4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82AC4DA8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82AC4DAC: 4BF2B1DD  bl 0x829eff88
	ctx.lr = 0x82AC4DB0;
	sub_829EFF88(ctx, base);
	// 82AC4DB0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC4DB4: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82AC4DB8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AC4DBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC4DC0: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82AC4DC4: 419A0024  beq cr6, 0x82ac4de8
	if ctx.cr[6].eq {
	pc = 0x82AC4DE8; continue 'dispatch;
	}
	// 82AC4DC8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AC4DCC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AC4DD0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AC4DD4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AC4DD8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AC4DDC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AC4DE0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AC4DE4: 4082FFE8  bne 0x82ac4dcc
	if !ctx.cr[0].eq {
	pc = 0x82AC4DCC; continue 'dispatch;
	}
	// 82AC4DE8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC4DEC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AC4DF0: 4BA4A6D9  bl 0x8250f4c8
	ctx.lr = 0x82AC4DF4;
	sub_8250F4C8(ctx, base);
	// 82AC4DF4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC4DF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC4DFC: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82AC4E00: 409A0008  bne cr6, 0x82ac4e08
	if !ctx.cr[6].eq {
	pc = 0x82AC4E08; continue 'dispatch;
	}
	// 82AC4E04: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AC4E08: 3BC10068  addi r30, r1, 0x68
	ctx.r[30].s64 = ctx.r[1].s64 + 104;
	// 82AC4E0C: 4BA4380D  bl 0x82508618
	ctx.lr = 0x82AC4E10;
	sub_82508618(ctx, base);
	// 82AC4E10: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AC4E14: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82AC4E18: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82AC4E1C: 388A9568  addi r4, r10, -0x6a98
	ctx.r[4].s64 = ctx.r[10].s64 + -27288;
	// 82AC4E20: 38A0011C  li r5, 0x11c
	ctx.r[5].s64 = 284;
	// 82AC4E24: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82AC4E28: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC4E2C: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82AC4E30: 48393C11  bl 0x82e58a40
	ctx.lr = 0x82AC4E34;
	sub_82E58A40(ctx, base);
	// 82AC4E34: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AC4E38: 4832CE59  bl 0x82df1c90
	ctx.lr = 0x82AC4E3C;
	sub_82DF1C90(ctx, base);
	// 82AC4E3C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82AC4E40: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC4E44: 419A0008  beq cr6, 0x82ac4e4c
	if ctx.cr[6].eq {
	pc = 0x82AC4E4C; continue 'dispatch;
	}
	// 82AC4E48: 4B7FBA49  bl 0x822c0890
	ctx.lr = 0x82AC4E4C;
	sub_822C0890(ctx, base);
	// 82AC4E4C: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82AC4E50: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC4E54: 419A0008  beq cr6, 0x82ac4e5c
	if ctx.cr[6].eq {
	pc = 0x82AC4E5C; continue 'dispatch;
	}
	// 82AC4E58: 4B7FBA39  bl 0x822c0890
	ctx.lr = 0x82AC4E5C;
	sub_822C0890(ctx, base);
	// 82AC4E5C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AC4E60: 4832E5C9  bl 0x82df3428
	ctx.lr = 0x82AC4E64;
	sub_82DF3428(ctx, base);
	// 82AC4E64: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82AC4E68: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC4E6C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC4E70: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AC4E74: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC4E78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC4E80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC4E80 size=456
    let mut pc: u32 = 0x82AC4E80;
    'dispatch: loop {
        match pc {
            0x82AC4E80 => {
    //   block [0x82AC4E80..0x82AC5048)
	// 82AC4E80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC4E84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC4E88: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC4E8C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC4E90: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82AC4E94: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC4E98: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC4E9C: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 82AC4EA0: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82AC4EA4: 409A0178  bne cr6, 0x82ac501c
	if !ctx.cr[6].eq {
	pc = 0x82AC501C; continue 'dispatch;
	}
	// 82AC4EA8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AC4EAC: C01F0120  lfs f0, 0x120(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC4EB0: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82AC4EB4: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82AC4EB8: 40990014  ble cr6, 0x82ac4ecc
	if !ctx.cr[6].gt {
	pc = 0x82AC4ECC; continue 'dispatch;
	}
	// 82AC4EBC: C1A40000  lfs f13, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AC4EC0: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82AC4EC4: D01F0120  stfs f0, 0x120(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), tmp.u32 ) };
	// 82AC4EC8: 48000154  b 0x82ac501c
	pc = 0x82AC501C; continue 'dispatch;
	// 82AC4ECC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC4ED0: 4BFFF969  bl 0x82ac4838
	ctx.lr = 0x82AC4ED4;
	sub_82AC4838(ctx, base);
	// 82AC4ED4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC4ED8: 40820144  bne 0x82ac501c
	if !ctx.cr[0].eq {
	pc = 0x82AC501C; continue 'dispatch;
	}
	// 82AC4EDC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC4EE0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82AC4EE4: 4BA4A44D  bl 0x8250f330
	ctx.lr = 0x82AC4EE8;
	sub_8250F330(ctx, base);
	// 82AC4EE8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AC4EEC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AC4EF0: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC4EF4: 4BA263CD  bl 0x824eb2c0
	ctx.lr = 0x82AC4EF8;
	sub_824EB2C0(ctx, base);
	// 82AC4EF8: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC4EFC: 4BA5132D  bl 0x82516228
	ctx.lr = 0x82AC4F00;
	sub_82516228(ctx, base);
	// 82AC4F00: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82AC4F04: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AC4F08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC4F0C: 419A000C  beq cr6, 0x82ac4f18
	if ctx.cr[6].eq {
	pc = 0x82AC4F18; continue 'dispatch;
	}
	// 82AC4F10: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82AC4F14: 4B7FB97D  bl 0x822c0890
	ctx.lr = 0x82AC4F18;
	sub_822C0890(ctx, base);
	// 82AC4F18: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82AC4F1C: 4832CD75  bl 0x82df1c90
	ctx.lr = 0x82AC4F20;
	sub_82DF1C90(ctx, base);
	// 82AC4F20: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82AC4F24: 40990044  ble cr6, 0x82ac4f68
	if !ctx.cr[6].gt {
	pc = 0x82AC4F68; continue 'dispatch;
	}
	// 82AC4F28: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC4F2C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AC4F30: 4BA4A401  bl 0x8250f330
	ctx.lr = 0x82AC4F34;
	sub_8250F330(ctx, base);
	// 82AC4F34: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AC4F38: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AC4F3C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC4F40: 4BA26381  bl 0x824eb2c0
	ctx.lr = 0x82AC4F44;
	sub_824EB2C0(ctx, base);
	// 82AC4F44: 389EFFFF  addi r4, r30, -1
	ctx.r[4].s64 = ctx.r[30].s64 + -1;
	// 82AC4F48: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC4F4C: 4BA51305  bl 0x82516250
	ctx.lr = 0x82AC4F50;
	sub_82516250(ctx, base);
	// 82AC4F50: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82AC4F54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC4F58: 419A0008  beq cr6, 0x82ac4f60
	if ctx.cr[6].eq {
	pc = 0x82AC4F60; continue 'dispatch;
	}
	// 82AC4F5C: 4B7FB935  bl 0x822c0890
	ctx.lr = 0x82AC4F60;
	sub_822C0890(ctx, base);
	// 82AC4F60: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AC4F64: 4832CD2D  bl 0x82df1c90
	ctx.lr = 0x82AC4F68;
	sub_82DF1C90(ctx, base);
	// 82AC4F68: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AC4F6C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AC4F70: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82AC4F74: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82AC4F78: 4B844579  bl 0x823094f0
	ctx.lr = 0x82AC4F7C;
	sub_823094F0(ctx, base);
	// 82AC4F7C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC4F80: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82AC4F84: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AC4F88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC4F8C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82AC4F90: 419A0024  beq cr6, 0x82ac4fb4
	if ctx.cr[6].eq {
	pc = 0x82AC4FB4; continue 'dispatch;
	}
	// 82AC4F94: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AC4F98: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AC4F9C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AC4FA0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AC4FA4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AC4FA8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AC4FAC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AC4FB0: 4082FFE8  bne 0x82ac4f98
	if !ctx.cr[0].eq {
	pc = 0x82AC4F98; continue 'dispatch;
	}
	// 82AC4FB4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC4FB8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82AC4FBC: 4BA4A375  bl 0x8250f330
	ctx.lr = 0x82AC4FC0;
	sub_8250F330(ctx, base);
	// 82AC4FC0: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC4FC4: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 82AC4FC8: 4BA24899  bl 0x824e9860
	ctx.lr = 0x82AC4FCC;
	sub_824E9860(ctx, base);
	// 82AC4FCC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC4FD0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AC4FD4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82AC4FD8: 388B9568  addi r4, r11, -0x6a98
	ctx.r[4].s64 = ctx.r[11].s64 + -27288;
	// 82AC4FDC: 38A00166  li r5, 0x166
	ctx.r[5].s64 = 358;
	// 82AC4FE0: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82AC4FE4: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82AC4FE8: 48393A59  bl 0x82e58a40
	ctx.lr = 0x82AC4FEC;
	sub_82E58A40(ctx, base);
	// 82AC4FEC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82AC4FF0: 4832CCA1  bl 0x82df1c90
	ctx.lr = 0x82AC4FF4;
	sub_82DF1C90(ctx, base);
	// 82AC4FF4: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AC4FF8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC4FFC: 419A0008  beq cr6, 0x82ac5004
	if ctx.cr[6].eq {
	pc = 0x82AC5004; continue 'dispatch;
	}
	// 82AC5000: 4B7FB891  bl 0x822c0890
	ctx.lr = 0x82AC5004;
	sub_822C0890(ctx, base);
	// 82AC5004: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82AC5008: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC500C: 419A0008  beq cr6, 0x82ac5014
	if ctx.cr[6].eq {
	pc = 0x82AC5014; continue 'dispatch;
	}
	// 82AC5010: 4B7FB881  bl 0x822c0890
	ctx.lr = 0x82AC5014;
	sub_822C0890(ctx, base);
	// 82AC5014: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82AC5018: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 82AC501C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC5020: 4BFFDDC9  bl 0x82ac2de8
	ctx.lr = 0x82AC5024;
	sub_82AC2DE8(ctx, base);
	// 82AC5024: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC5028: 4BFFEFE9  bl 0x82ac4010
	ctx.lr = 0x82AC502C;
	sub_82AC4010(ctx, base);
	// 82AC502C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82AC5030: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC5034: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC5038: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82AC503C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AC5040: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC5044: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC5048(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC5048 size=188
    let mut pc: u32 = 0x82AC5048;
    'dispatch: loop {
        match pc {
            0x82AC5048 => {
    //   block [0x82AC5048..0x82AC5104)
	// 82AC5048: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC504C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC5050: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC5054: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC5058: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC505C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC5060: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AC5064: 4BA4B6A5  bl 0x82510708
	ctx.lr = 0x82AC5068;
	sub_82510708(ctx, base);
	// 82AC5068: 897F0124  lbz r11, 0x124(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(292 as u32) ) } as u64;
	// 82AC506C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC5070: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC5074: 4182000C  beq 0x82ac5080
	if ctx.cr[0].eq {
	pc = 0x82AC5080; continue 'dispatch;
	}
	// 82AC5078: 4BFFD0B1  bl 0x82ac2128
	ctx.lr = 0x82AC507C;
	sub_82AC2128(ctx, base);
	// 82AC507C: 48000070  b 0x82ac50ec
	pc = 0x82AC50EC; continue 'dispatch;
	// 82AC5080: 4BFFD0F9  bl 0x82ac2178
	ctx.lr = 0x82AC5084;
	sub_82AC2178(ctx, base);
	// 82AC5084: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC5088: 40820064  bne 0x82ac50ec
	if !ctx.cr[0].eq {
	pc = 0x82AC50EC; continue 'dispatch;
	}
	// 82AC508C: 4BFEB93D  bl 0x82ab09c8
	ctx.lr = 0x82AC5090;
	sub_82AB09C8(ctx, base);
	// 82AC5090: 907F0118  stw r3, 0x118(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), ctx.r[3].u32 ) };
	// 82AC5094: 807F00F0  lwz r3, 0xf0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 82AC5098: 4BF53E71  bl 0x82a18f08
	ctx.lr = 0x82AC509C;
	sub_82A18F08(ctx, base);
	// 82AC509C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC50A0: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AC50A4: 4833973D  bl 0x82dfe7e0
	ctx.lr = 0x82AC50A8;
	sub_82DFE7E0(ctx, base);
	// 82AC50A8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC50AC: 41820040  beq 0x82ac50ec
	if ctx.cr[0].eq {
	pc = 0x82AC50EC; continue 'dispatch;
	}
	// 82AC50B0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AC50B4: 807F00EC  lwz r3, 0xec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82AC50B8: 4BFF8509  bl 0x82abd5c0
	ctx.lr = 0x82AC50BC;
	sub_82ABD5C0(ctx, base);
	// 82AC50BC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AC50C0: 807F00F0  lwz r3, 0xf0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 82AC50C4: 4800036D  bl 0x82ac5430
	ctx.lr = 0x82AC50C8;
	sub_82AC5430(ctx, base);
	// 82AC50C8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AC50CC: 807F00F4  lwz r3, 0xf4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 82AC50D0: 48001161  bl 0x82ac6230
	ctx.lr = 0x82AC50D4;
	sub_82AC6230(ctx, base);
	// 82AC50D4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AC50D8: 807F0170  lwz r3, 0x170(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 82AC50DC: 48015D25  bl 0x82adae00
	ctx.lr = 0x82AC50E0;
	sub_82ADAE00(ctx, base);
	// 82AC50E0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AC50E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC50E8: 4BFFFD99  bl 0x82ac4e80
	ctx.lr = 0x82AC50EC;
	sub_82AC4E80(ctx, base);
	// 82AC50EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC50F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC50F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC50F8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AC50FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC5100: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC5108(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC5108 size=424
    let mut pc: u32 = 0x82AC5108;
    'dispatch: loop {
        match pc {
            0x82AC5108 => {
    //   block [0x82AC5108..0x82AC52B0)
	// 82AC5108: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC510C: 486E305D  bl 0x831a8168
	ctx.lr = 0x82AC5110;
	sub_831A8130(ctx, base);
	// 82AC5110: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC5114: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC5118: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82AC511C: 3BCB9568  addi r30, r11, -0x6a98
	ctx.r[30].s64 = ctx.r[11].s64 + -27288;
	// 82AC5120: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AC5124: 38A0006C  li r5, 0x6c
	ctx.r[5].s64 = 108;
	// 82AC5128: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AC512C: 38600180  li r3, 0x180
	ctx.r[3].s64 = 384;
	// 82AC5130: 4832D2B9  bl 0x82df23e8
	ctx.lr = 0x82AC5134;
	sub_82DF23E8(ctx, base);
	// 82AC5134: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC5138: 41820010  beq 0x82ac5148
	if ctx.cr[0].eq {
	pc = 0x82AC5148; continue 'dispatch;
	}
	// 82AC513C: 4BFFEB5D  bl 0x82ac3c98
	ctx.lr = 0x82AC5140;
	sub_82AC3C98(ctx, base);
	// 82AC5140: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC5144: 48000008  b 0x82ac514c
	pc = 0x82AC514C; continue 'dispatch;
	// 82AC5148: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AC514C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82AC5150: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC5154: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AC5158: 4BFFD111  bl 0x82ac2268
	ctx.lr = 0x82AC515C;
	sub_82AC2268(ctx, base);
	// 82AC515C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AC5160: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC5164: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AC5168: 4B7FAE99  bl 0x822c0000
	ctx.lr = 0x82AC516C;
	sub_822C0000(ctx, base);
	// 82AC516C: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AC5170: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AC5174: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 82AC5178: 409A0008  bne cr6, 0x82ac5180
	if !ctx.cr[6].eq {
	pc = 0x82AC5180; continue 'dispatch;
	}
	// 82AC517C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC5180: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AC5184: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82AC5188: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82AC518C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82AC5190: 419A0024  beq cr6, 0x82ac51b4
	if ctx.cr[6].eq {
	pc = 0x82AC51B4; continue 'dispatch;
	}
	// 82AC5194: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82AC5198: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82AC519C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AC51A0: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82AC51A4: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82AC51A8: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AC51AC: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AC51B0: 4082FFE8  bne 0x82ac5198
	if !ctx.cr[0].eq {
	pc = 0x82AC5198; continue 'dispatch;
	}
	// 82AC51B4: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82AC51B8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82AC51BC: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 82AC51C0: 419A0024  beq cr6, 0x82ac51e4
	if ctx.cr[6].eq {
	pc = 0x82AC51E4; continue 'dispatch;
	}
	// 82AC51C4: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82AC51C8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AC51CC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AC51D0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AC51D4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AC51D8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AC51DC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AC51E0: 4082FFE8  bne 0x82ac51c8
	if !ctx.cr[0].eq {
	pc = 0x82AC51C8; continue 'dispatch;
	}
	// 82AC51E4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AC51E8: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 82AC51EC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82AC51F0: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 82AC51F4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82AC51F8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82AC51FC: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC5200: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AC5204: 4BCD3D2D  bl 0x82798f30
	ctx.lr = 0x82AC5208;
	sub_82798F30(ctx, base);
	// 82AC5208: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC520C: 3D40832F  lis r10, -0x7cd1
	ctx.r[10].s64 = -2094071808;
	// 82AC5210: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AC5214: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AC5218: 38A00072  li r5, 0x72
	ctx.r[5].s64 = 114;
	// 82AC521C: C00B93A8  lfs f0, -0x6c58(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27736 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC5220: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82AC5224: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82AC5228: C00AF688  lfs f0, -0x978(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-2424 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC522C: D0010094  stfs f0, 0x94(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82AC5230: 4B7FB1A9  bl 0x822c03d8
	ctx.lr = 0x82AC5234;
	sub_822C03D8(ctx, base);
	// 82AC5234: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC5238: 41820014  beq 0x82ac524c
	if ctx.cr[0].eq {
	pc = 0x82AC524C; continue 'dispatch;
	}
	// 82AC523C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82AC5240: 4BCD6429  bl 0x8279b668
	ctx.lr = 0x82AC5244;
	sub_8279B668(ctx, base);
	// 82AC5244: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC5248: 48000008  b 0x82ac5250
	pc = 0x82AC5250; continue 'dispatch;
	// 82AC524C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AC5250: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82AC5254: 3BDC0004  addi r30, r28, 4
	ctx.r[30].s64 = ctx.r[28].s64 + 4;
	// 82AC5258: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC525C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC5260: 4BAD29F1  bl 0x82597c50
	ctx.lr = 0x82AC5264;
	sub_82597C50(ctx, base);
	// 82AC5264: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AC5268: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC526C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC5270: 4B7FAD91  bl 0x822c0000
	ctx.lr = 0x82AC5274;
	sub_822C0000(ctx, base);
	// 82AC5274: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82AC5278: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC527C: 419A0008  beq cr6, 0x82ac5284
	if ctx.cr[6].eq {
	pc = 0x82AC5284; continue 'dispatch;
	}
	// 82AC5280: 4B7FB611  bl 0x822c0890
	ctx.lr = 0x82AC5284;
	sub_822C0890(ctx, base);
	// 82AC5284: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82AC5288: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC528C: 419A0008  beq cr6, 0x82ac5294
	if ctx.cr[6].eq {
	pc = 0x82AC5294; continue 'dispatch;
	}
	// 82AC5290: 4B7FB601  bl 0x822c0890
	ctx.lr = 0x82AC5294;
	sub_822C0890(ctx, base);
	// 82AC5294: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82AC5298: 419A000C  beq cr6, 0x82ac52a4
	if ctx.cr[6].eq {
	pc = 0x82AC52A4; continue 'dispatch;
	}
	// 82AC529C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC52A0: 4B7FB5F1  bl 0x822c0890
	ctx.lr = 0x82AC52A4;
	sub_822C0890(ctx, base);
	// 82AC52A4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AC52A8: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82AC52AC: 486E2F0C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC52B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AC52B0 size=8
    let mut pc: u32 = 0x82AC52B0;
    'dispatch: loop {
        match pc {
            0x82AC52B0 => {
    //   block [0x82AC52B0..0x82AC52B8)
	// 82AC52B0: 38630028  addi r3, r3, 0x28
	ctx.r[3].s64 = ctx.r[3].s64 + 40;
	// 82AC52B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC52B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC52B8 size=92
    let mut pc: u32 = 0x82AC52B8;
    'dispatch: loop {
        match pc {
            0x82AC52B8 => {
    //   block [0x82AC52B8..0x82AC5314)
	// 82AC52B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC52BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC52C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC52C4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC52C8: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AC52CC: 1D440030  mulli r10, r4, 0x30
	ctx.r[10].s64 = ctx.r[4].s64 * 48;
	// 82AC52D0: 396BFA28  addi r11, r11, -0x5d8
	ctx.r[11].s64 = ctx.r[11].s64 + -1496;
	// 82AC52D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC52D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC52DC: 7C8A582E  lwzx r4, r10, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82AC52E0: 4832E729  bl 0x82df3a08
	ctx.lr = 0x82AC52E4;
	sub_82DF3A08(ctx, base);
	// 82AC52E4: 389F0014  addi r4, r31, 0x14
	ctx.r[4].s64 = ctx.r[31].s64 + 20;
	// 82AC52E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC52EC: 4832E01D  bl 0x82df3308
	ctx.lr = 0x82AC52F0;
	sub_82DF3308(ctx, base);
	// 82AC52F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC52F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC52F8: 4832E131  bl 0x82df3428
	ctx.lr = 0x82AC52FC;
	sub_82DF3428(ctx, base);
	// 82AC52FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC5300: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC5304: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC5308: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC530C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC5310: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC5318(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC5318 size=136
    let mut pc: u32 = 0x82AC5318;
    'dispatch: loop {
        match pc {
            0x82AC5318 => {
    //   block [0x82AC5318..0x82AC53A0)
	// 82AC5318: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC531C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC5320: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC5324: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC5328: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC532C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AC5330: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AC5334: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82AC5338: 409A0020  bne cr6, 0x82ac5358
	if !ctx.cr[6].eq {
	pc = 0x82AC5358; continue 'dispatch;
	}
	// 82AC533C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AC5340: 419A0048  beq cr6, 0x82ac5388
	if ctx.cr[6].eq {
	pc = 0x82AC5388; continue 'dispatch;
	}
	// 82AC5344: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC5348: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC534C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AC5350: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82AC5354: 48000034  b 0x82ac5388
	pc = 0x82AC5388; continue 'dispatch;
	// 82AC5358: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 82AC535C: 419A002C  beq cr6, 0x82ac5388
	if ctx.cr[6].eq {
	pc = 0x82AC5388; continue 'dispatch;
	}
	// 82AC5360: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AC5364: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC5368: 388BFD28  addi r4, r11, -0x2d8
	ctx.r[4].s64 = ctx.r[11].s64 + -728;
	// 82AC536C: 486E2D8D  bl 0x831a80f8
	ctx.lr = 0x82AC5370;
	sub_831A80F8(ctx, base);
	// 82AC5370: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC5374: 4182000C  beq 0x82ac5380
	if ctx.cr[0].eq {
	pc = 0x82AC5380; continue 'dispatch;
	}
	// 82AC5378: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82AC537C: 4800000C  b 0x82ac5388
	pc = 0x82AC5388; continue 'dispatch;
	// 82AC5380: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC5384: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC5388: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC538C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC5390: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC5394: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AC5398: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC539C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC53A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC53A0 size=140
    let mut pc: u32 = 0x82AC53A0;
    'dispatch: loop {
        match pc {
            0x82AC53A0 => {
    //   block [0x82AC53A0..0x82AC542C)
	// 82AC53A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC53A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC53A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC53AC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC53B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC53B4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC53B8: 396B9614  addi r11, r11, -0x69ec
	ctx.r[11].s64 = ctx.r[11].s64 + -27116;
	// 82AC53BC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC53C0: 807F003C  lwz r3, 0x3c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82AC53C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC53C8: 419A0008  beq cr6, 0x82ac53d0
	if ctx.cr[6].eq {
	pc = 0x82AC53D0; continue 'dispatch;
	}
	// 82AC53CC: 4B7FB4C5  bl 0x822c0890
	ctx.lr = 0x82AC53D0;
	sub_822C0890(ctx, base);
	// 82AC53D0: 807F0034  lwz r3, 0x34(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82AC53D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC53D8: 419A0008  beq cr6, 0x82ac53e0
	if ctx.cr[6].eq {
	pc = 0x82AC53E0; continue 'dispatch;
	}
	// 82AC53DC: 4B7FB4B5  bl 0x822c0890
	ctx.lr = 0x82AC53E0;
	sub_822C0890(ctx, base);
	// 82AC53E0: 807F002C  lwz r3, 0x2c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82AC53E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC53E8: 419A0008  beq cr6, 0x82ac53f0
	if ctx.cr[6].eq {
	pc = 0x82AC53F0; continue 'dispatch;
	}
	// 82AC53EC: 4B7FB4A5  bl 0x822c0890
	ctx.lr = 0x82AC53F0;
	sub_822C0890(ctx, base);
	// 82AC53F0: 807F0024  lwz r3, 0x24(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82AC53F4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC53F8: 419A0008  beq cr6, 0x82ac5400
	if ctx.cr[6].eq {
	pc = 0x82AC5400; continue 'dispatch;
	}
	// 82AC53FC: 4B7FB495  bl 0x822c0890
	ctx.lr = 0x82AC5400;
	sub_822C0890(ctx, base);
	// 82AC5400: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82AC5404: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC5408: 419A0008  beq cr6, 0x82ac5410
	if ctx.cr[6].eq {
	pc = 0x82AC5410; continue 'dispatch;
	}
	// 82AC540C: 4B7FB485  bl 0x822c0890
	ctx.lr = 0x82AC5410;
	sub_822C0890(ctx, base);
	// 82AC5410: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 82AC5414: 4832E015  bl 0x82df3428
	ctx.lr = 0x82AC5418;
	sub_82DF3428(ctx, base);
	// 82AC5418: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AC541C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC5420: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC5424: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC5428: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC5430(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC5430 size=180
    let mut pc: u32 = 0x82AC5430;
    'dispatch: loop {
        match pc {
            0x82AC5430 => {
    //   block [0x82AC5430..0x82AC54E4)
	// 82AC5430: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC5434: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC5438: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC543C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC5440: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC5444: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC5448: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AC544C: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82AC5450: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AC5454: 4833938D  bl 0x82dfe7e0
	ctx.lr = 0x82AC5458;
	sub_82DFE7E0(ctx, base);
	// 82AC5458: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC545C: 41820064  beq 0x82ac54c0
	if ctx.cr[0].eq {
	pc = 0x82AC54C0; continue 'dispatch;
	}
	// 82AC5460: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82AC5464: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC5468: 419A0058  beq cr6, 0x82ac54c0
	if ctx.cr[6].eq {
	pc = 0x82AC54C0; continue 'dispatch;
	}
	// 82AC546C: 480EF3AD  bl 0x82bb4818
	ctx.lr = 0x82AC5470;
	sub_82BB4818(ctx, base);
	// 82AC5470: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC5474: 4182004C  beq 0x82ac54c0
	if ctx.cr[0].eq {
	pc = 0x82AC54C0; continue 'dispatch;
	}
	// 82AC5478: C03E0000  lfs f1, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC547C: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82AC5480: 480F0071  bl 0x82bb54f0
	ctx.lr = 0x82AC5484;
	sub_82BB54F0(ctx, base);
	// 82AC5484: C1BF0040  lfs f13, 0x40(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AC5488: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC548C: 809F0030  lwz r4, 0x30(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82AC5490: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82AC5494: D01F0040  stfs f0, 0x40(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 82AC5498: C1A40018  lfs f13, 0x18(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AC549C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82AC54A0: 4198000C  blt cr6, 0x82ac54ac
	if ctx.cr[6].lt {
	pc = 0x82AC54AC; continue 'dispatch;
	}
	// 82AC54A4: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82AC54A8: D01F0040  stfs f0, 0x40(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 82AC54AC: C004001C  lfs f0, 0x1c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC54B0: 807F0038  lwz r3, 0x38(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82AC54B4: C1BF0040  lfs f13, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AC54B8: EC200372  fmuls f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82AC54BC: 4837937D  bl 0x82e3e838
	ctx.lr = 0x82AC54C0;
	sub_82E3E838(ctx, base);
	// 82AC54C0: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AC54C4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82AC54C8: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82AC54CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC54D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC54D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC54D8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AC54DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC54E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC54E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC54E8 size=180
    let mut pc: u32 = 0x82AC54E8;
    'dispatch: loop {
        match pc {
            0x82AC54E8 => {
    //   block [0x82AC54E8..0x82AC559C)
	// 82AC54E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC54EC: 486E2C81  bl 0x831a816c
	ctx.lr = 0x82AC54F0;
	sub_831A8130(ctx, base);
	// 82AC54F0: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82AC54F4: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC54F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC54FC: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82AC5500: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AC5504: 897F0010  lbz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82AC5508: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC550C: 41820084  beq 0x82ac5590
	if ctx.cr[0].eq {
	pc = 0x82AC5590; continue 'dispatch;
	}
	// 82AC5510: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AC5514: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AC5518: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82AC551C: 419A0074  beq cr6, 0x82ac5590
	if ctx.cr[6].eq {
	pc = 0x82AC5590; continue 'dispatch;
	}
	// 82AC5520: 3BBF0014  addi r29, r31, 0x14
	ctx.r[29].s64 = ctx.r[31].s64 + 20;
	// 82AC5524: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC5528: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AC552C: 4832DDDD  bl 0x82df3308
	ctx.lr = 0x82AC5530;
	sub_82DF3308(ctx, base);
	// 82AC5530: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC5534: 4082005C  bne 0x82ac5590
	if !ctx.cr[0].eq {
	pc = 0x82AC5590; continue 'dispatch;
	}
	// 82AC5538: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AC553C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC5540: 4832E691  bl 0x82df3bd0
	ctx.lr = 0x82AC5544;
	sub_82DF3BD0(ctx, base);
	// 82AC5544: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82AC5548: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC554C: 809F0020  lwz r4, 0x20(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82AC5550: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82AC5554: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AC5558: 480EDE21  bl 0x82bb3378
	ctx.lr = 0x82AC555C;
	sub_82BB3378(ctx, base);
	// 82AC555C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AC5560: 395F0028  addi r10, r31, 0x28
	ctx.r[10].s64 = ctx.r[31].s64 + 40;
	// 82AC5564: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82AC5568: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 82AC556C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC5570: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 82AC5574: 4B7FEEED  bl 0x822c4460
	ctx.lr = 0x82AC5578;
	sub_822C4460(ctx, base);
	// 82AC5578: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AC557C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC5580: 419A0008  beq cr6, 0x82ac5588
	if ctx.cr[6].eq {
	pc = 0x82AC5588; continue 'dispatch;
	}
	// 82AC5584: 4B7FB30D  bl 0x822c0890
	ctx.lr = 0x82AC5588;
	sub_822C0890(ctx, base);
	// 82AC5588: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AC558C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82AC5590: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AC5594: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82AC5598: 486E2C24  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC55A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC55A0 size=152
    let mut pc: u32 = 0x82AC55A0;
    'dispatch: loop {
        match pc {
            0x82AC55A0 => {
    //   block [0x82AC55A0..0x82AC5638)
	// 82AC55A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC55A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC55A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC55AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC55B0: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82AC55B4: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC55B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC55BC: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82AC55C0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AC55C4: 897F0010  lbz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82AC55C8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC55CC: 41820050  beq 0x82ac561c
	if ctx.cr[0].eq {
	pc = 0x82AC561C; continue 'dispatch;
	}
	// 82AC55D0: 4BFFFCE9  bl 0x82ac52b8
	ctx.lr = 0x82AC55D4;
	sub_82AC52B8(ctx, base);
	// 82AC55D4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC55D8: 40820044  bne 0x82ac561c
	if !ctx.cr[0].eq {
	pc = 0x82AC561C; continue 'dispatch;
	}
	// 82AC55DC: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AC55E0: 1D5E0030  mulli r10, r30, 0x30
	ctx.r[10].s64 = ctx.r[30].s64 * 48;
	// 82AC55E4: 396BFA28  addi r11, r11, -0x5d8
	ctx.r[11].s64 = ctx.r[11].s64 + -1496;
	// 82AC55E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC55EC: 7C8A582E  lwzx r4, r10, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82AC55F0: 4832E419  bl 0x82df3a08
	ctx.lr = 0x82AC55F4;
	sub_82DF3A08(ctx, base);
	// 82AC55F4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AC55F8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AC55FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC5600: 4BFFFEE9  bl 0x82ac54e8
	ctx.lr = 0x82AC5604;
	sub_82AC54E8(ctx, base);
	// 82AC5604: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC5608: 4832DE21  bl 0x82df3428
	ctx.lr = 0x82AC560C;
	sub_82DF3428(ctx, base);
	// 82AC560C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AC5610: 807F0028  lwz r3, 0x28(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82AC5614: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC5618: 480F3459  bl 0x82bb8a70
	ctx.lr = 0x82AC561C;
	sub_82BB8A70(ctx, base);
	// 82AC561C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AC5620: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC5624: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC5628: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82AC562C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AC5630: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC5634: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC5638(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC5638 size=160
    let mut pc: u32 = 0x82AC5638;
    'dispatch: loop {
        match pc {
            0x82AC5638 => {
    //   block [0x82AC5638..0x82AC56D8)
	// 82AC5638: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC563C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC5640: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC5644: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC5648: DBC1FFD8  stfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 82AC564C: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82AC5650: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC5654: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC5658: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82AC565C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AC5660: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 82AC5664: 897F0010  lbz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82AC5668: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC566C: 4182004C  beq 0x82ac56b8
	if ctx.cr[0].eq {
	pc = 0x82AC56B8; continue 'dispatch;
	}
	// 82AC5670: 4BFFFC49  bl 0x82ac52b8
	ctx.lr = 0x82AC5674;
	sub_82AC52B8(ctx, base);
	// 82AC5674: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC5678: 40820040  bne 0x82ac56b8
	if !ctx.cr[0].eq {
	pc = 0x82AC56B8; continue 'dispatch;
	}
	// 82AC567C: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AC5680: 1D5E0030  mulli r10, r30, 0x30
	ctx.r[10].s64 = ctx.r[30].s64 * 48;
	// 82AC5684: 396BFA28  addi r11, r11, -0x5d8
	ctx.r[11].s64 = ctx.r[11].s64 + -1496;
	// 82AC5688: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC568C: 7C8A582E  lwzx r4, r10, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82AC5690: 4832E379  bl 0x82df3a08
	ctx.lr = 0x82AC5694;
	sub_82DF3A08(ctx, base);
	// 82AC5694: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AC5698: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AC569C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC56A0: 4BFFFE49  bl 0x82ac54e8
	ctx.lr = 0x82AC56A4;
	sub_82AC54E8(ctx, base);
	// 82AC56A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC56A8: 4832DD81  bl 0x82df3428
	ctx.lr = 0x82AC56AC;
	sub_82DF3428(ctx, base);
	// 82AC56AC: 807F0028  lwz r3, 0x28(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82AC56B0: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82AC56B4: 480F33BD  bl 0x82bb8a70
	ctx.lr = 0x82AC56B8;
	sub_82BB8A70(ctx, base);
	// 82AC56B8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AC56BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC56C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC56C4: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82AC56C8: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82AC56CC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AC56D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC56D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC56D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC56D8 size=72
    let mut pc: u32 = 0x82AC56D8;
    'dispatch: loop {
        match pc {
            0x82AC56D8 => {
    //   block [0x82AC56D8..0x82AC5720)
	// 82AC56D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC56DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC56E0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC56E4: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 82AC56E8: 419A001C  beq cr6, 0x82ac5704
	if ctx.cr[6].eq {
	pc = 0x82AC5704; continue 'dispatch;
	}
	// 82AC56EC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82AC56F0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82AC56F4: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82AC56F8: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AC56FC: 4BFFFC1D  bl 0x82ac5318
	ctx.lr = 0x82AC5700;
	sub_82AC5318(ctx, base);
	// 82AC5700: 48000010  b 0x82ac5710
	pc = 0x82AC5710; continue 'dispatch;
	// 82AC5704: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AC5708: 396BFD28  addi r11, r11, -0x2d8
	ctx.r[11].s64 = ctx.r[11].s64 + -728;
	// 82AC570C: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC5710: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AC5714: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC5718: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC571C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC5720(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC5720 size=76
    let mut pc: u32 = 0x82AC5720;
    'dispatch: loop {
        match pc {
            0x82AC5720 => {
    //   block [0x82AC5720..0x82AC576C)
	// 82AC5720: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC5724: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC5728: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC572C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC5730: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC5734: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC5738: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AC573C: 4BFFFC65  bl 0x82ac53a0
	ctx.lr = 0x82AC5740;
	sub_82AC53A0(ctx, base);
	// 82AC5740: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC5744: 4182000C  beq 0x82ac5750
	if ctx.cr[0].eq {
	pc = 0x82AC5750; continue 'dispatch;
	}
	// 82AC5748: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC574C: 4B7FAB1D  bl 0x822c0268
	ctx.lr = 0x82AC5750;
	sub_822C0268(ctx, base);
	// 82AC5750: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC5754: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC5758: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC575C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC5760: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AC5764: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC5768: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC5770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC5770 size=124
    let mut pc: u32 = 0x82AC5770;
    'dispatch: loop {
        match pc {
            0x82AC5770 => {
    //   block [0x82AC5770..0x82AC57EC)
	// 82AC5770: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC5774: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC5778: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC577C: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82AC5780: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82AC5784: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC5788: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AC578C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AC5790: 419A0024  beq cr6, 0x82ac57b4
	if ctx.cr[6].eq {
	pc = 0x82AC57B4; continue 'dispatch;
	}
	// 82AC5794: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AC5798: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AC579C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AC57A0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AC57A4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AC57A8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AC57AC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AC57B0: 4082FFE8  bne 0x82ac5798
	if !ctx.cr[0].eq {
	pc = 0x82AC5798; continue 'dispatch;
	}
	// 82AC57B4: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82AC57B8: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AC57BC: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82AC57C0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82AC57C4: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 82AC57C8: 4BA4A8F9  bl 0x825100c0
	ctx.lr = 0x82AC57CC;
	sub_825100C0(ctx, base);
	// 82AC57CC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AC57D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC57D4: 419A0008  beq cr6, 0x82ac57dc
	if ctx.cr[6].eq {
	pc = 0x82AC57DC; continue 'dispatch;
	}
	// 82AC57D8: 4B7FB0B9  bl 0x822c0890
	ctx.lr = 0x82AC57DC;
	sub_822C0890(ctx, base);
	// 82AC57DC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AC57E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC57E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC57E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC57F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC57F0 size=160
    let mut pc: u32 = 0x82AC57F0;
    'dispatch: loop {
        match pc {
            0x82AC57F0 => {
    //   block [0x82AC57F0..0x82AC5890)
	// 82AC57F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC57F4: 486E2979  bl 0x831a816c
	ctx.lr = 0x82AC57F8;
	sub_831A8130(ctx, base);
	// 82AC57F8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC57FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC5800: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AC5804: 897F0010  lbz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82AC5808: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC580C: 4182007C  beq 0x82ac5888
	if ctx.cr[0].eq {
	pc = 0x82AC5888; continue 'dispatch;
	}
	// 82AC5810: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AC5814: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AC5818: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82AC581C: 419A006C  beq cr6, 0x82ac5888
	if ctx.cr[6].eq {
	pc = 0x82AC5888; continue 'dispatch;
	}
	// 82AC5820: 3BBF0014  addi r29, r31, 0x14
	ctx.r[29].s64 = ctx.r[31].s64 + 20;
	// 82AC5824: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC5828: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AC582C: 4832DADD  bl 0x82df3308
	ctx.lr = 0x82AC5830;
	sub_82DF3308(ctx, base);
	// 82AC5830: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC5834: 40820054  bne 0x82ac5888
	if !ctx.cr[0].eq {
	pc = 0x82AC5888; continue 'dispatch;
	}
	// 82AC5838: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AC583C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC5840: 4832E391  bl 0x82df3bd0
	ctx.lr = 0x82AC5844;
	sub_82DF3BD0(ctx, base);
	// 82AC5844: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82AC5848: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC584C: 809F0020  lwz r4, 0x20(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82AC5850: 480EDAC1  bl 0x82bb3310
	ctx.lr = 0x82AC5854;
	sub_82BB3310(ctx, base);
	// 82AC5854: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AC5858: 395F0028  addi r10, r31, 0x28
	ctx.r[10].s64 = ctx.r[31].s64 + 40;
	// 82AC585C: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82AC5860: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 82AC5864: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC5868: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 82AC586C: 4B7FEBF5  bl 0x822c4460
	ctx.lr = 0x82AC5870;
	sub_822C4460(ctx, base);
	// 82AC5870: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AC5874: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC5878: 419A0008  beq cr6, 0x82ac5880
	if ctx.cr[6].eq {
	pc = 0x82AC5880; continue 'dispatch;
	}
	// 82AC587C: 4B7FB015  bl 0x822c0890
	ctx.lr = 0x82AC5880;
	sub_822C0890(ctx, base);
	// 82AC5880: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AC5884: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82AC5888: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AC588C: 486E2930  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC5890(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC5890 size=136
    let mut pc: u32 = 0x82AC5890;
    'dispatch: loop {
        match pc {
            0x82AC5890 => {
    //   block [0x82AC5890..0x82AC5918)
	// 82AC5890: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC5894: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC5898: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC589C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC58A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC58A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC58A8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AC58AC: 897F0010  lbz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82AC58B0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC58B4: 4182004C  beq 0x82ac5900
	if ctx.cr[0].eq {
	pc = 0x82AC5900; continue 'dispatch;
	}
	// 82AC58B8: 4BFFFA01  bl 0x82ac52b8
	ctx.lr = 0x82AC58BC;
	sub_82AC52B8(ctx, base);
	// 82AC58BC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC58C0: 40820040  bne 0x82ac5900
	if !ctx.cr[0].eq {
	pc = 0x82AC5900; continue 'dispatch;
	}
	// 82AC58C4: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AC58C8: 1D5E0030  mulli r10, r30, 0x30
	ctx.r[10].s64 = ctx.r[30].s64 * 48;
	// 82AC58CC: 396BFA28  addi r11, r11, -0x5d8
	ctx.r[11].s64 = ctx.r[11].s64 + -1496;
	// 82AC58D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC58D4: 7C8A582E  lwzx r4, r10, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82AC58D8: 4832E131  bl 0x82df3a08
	ctx.lr = 0x82AC58DC;
	sub_82DF3A08(ctx, base);
	// 82AC58DC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AC58E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC58E4: 4BFFFF0D  bl 0x82ac57f0
	ctx.lr = 0x82AC58E8;
	sub_82AC57F0(ctx, base);
	// 82AC58E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC58EC: 4832DB3D  bl 0x82df3428
	ctx.lr = 0x82AC58F0;
	sub_82DF3428(ctx, base);
	// 82AC58F0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AC58F4: 807F0028  lwz r3, 0x28(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82AC58F8: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC58FC: 480F3175  bl 0x82bb8a70
	ctx.lr = 0x82AC5900;
	sub_82BB8A70(ctx, base);
	// 82AC5900: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC5904: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC5908: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC590C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AC5910: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC5914: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC5918(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC5918 size=392
    let mut pc: u32 = 0x82AC5918;
    'dispatch: loop {
        match pc {
            0x82AC5918 => {
    //   block [0x82AC5918..0x82AC5AA0)
	// 82AC5918: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC591C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC5920: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC5924: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC5928: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC592C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC5930: 80840000  lwz r4, 0(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC5934: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82AC5938: 483651B1  bl 0x82e2aae8
	ctx.lr = 0x82AC593C;
	sub_82E2AAE8(ctx, base);
	// 82AC593C: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AC5940: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC5944: 808BFA10  lwz r4, -0x5f0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1520 as u32) ) } as u64;
	// 82AC5948: 4832E0C1  bl 0x82df3a08
	ctx.lr = 0x82AC594C;
	sub_82DF3A08(ctx, base);
	// 82AC594C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AC5950: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82AC5954: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82AC5958: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AC595C: 48369515  bl 0x82e2ee70
	ctx.lr = 0x82AC5960;
	sub_82E2EE70(ctx, base);
	// 82AC5960: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC5964: 4832DAC5  bl 0x82df3428
	ctx.lr = 0x82AC5968;
	sub_82DF3428(ctx, base);
	// 82AC5968: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC596C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AC5970: 388B9618  addi r4, r11, -0x69e8
	ctx.r[4].s64 = ctx.r[11].s64 + -27112;
	// 82AC5974: 38A000FB  li r5, 0xfb
	ctx.r[5].s64 = 251;
	// 82AC5978: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 82AC597C: 4832CA6D  bl 0x82df23e8
	ctx.lr = 0x82AC5980;
	sub_82DF23E8(ctx, base);
	// 82AC5980: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC5984: 41820014  beq 0x82ac5998
	if ctx.cr[0].eq {
	pc = 0x82AC5998; continue 'dispatch;
	}
	// 82AC5988: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82AC598C: 48350F05  bl 0x82e16890
	ctx.lr = 0x82AC5990;
	sub_82E16890(ctx, base);
	// 82AC5990: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AC5994: 48000008  b 0x82ac599c
	pc = 0x82AC599C; continue 'dispatch;
	// 82AC5998: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AC599C: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 82AC59A0: 4B8979D1  bl 0x8235d370
	ctx.lr = 0x82AC59A4;
	sub_8235D370(ctx, base);
	// 82AC59A4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AC59A8: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AC59AC: 83DF0018  lwz r30, 0x18(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82AC59B0: 4800D6B9  bl 0x82ad3068
	ctx.lr = 0x82AC59B4;
	sub_82AD3068(ctx, base);
	// 82AC59B4: 815E0084  lwz r10, 0x84(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(132 as u32) ) } as u64;
	// 82AC59B8: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82AC59BC: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 82AC59C0: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 82AC59C4: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 82AC59C8: 396A0010  addi r11, r10, 0x10
	ctx.r[11].s64 = ctx.r[10].s64 + 16;
	// 82AC59CC: 13E03407  vcmpneb. (lvlx128) v31, v0, v6
	tmp.u32 = ctx.r[6].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82AC59D0: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 82AC59D4: 13C73407  vcmpneb. (lvlx128) v30, v7, v6
	tmp.u32 = ctx.r[7].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82AC59D8: 13A83407  vcmpneb. (lvlx128) v29, v8, v6
	tmp.u32 = ctx.r[8].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82AC59DC: 13893407  vcmpneb. (lvlx128) v28, v9, v6
	tmp.u32 = ctx.r[9].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC5AA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC5AA0 size=128
    let mut pc: u32 = 0x82AC5AA0;
    'dispatch: loop {
        match pc {
            0x82AC5AA0 => {
    //   block [0x82AC5AA0..0x82AC5B20)
	// 82AC5AA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC5AA4: 486E26C9  bl 0x831a816c
	ctx.lr = 0x82AC5AA8;
	sub_831A8130(ctx, base);
	// 82AC5AA8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC5AAC: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82AC5AB0: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82AC5AB4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AC5AB8: 3BEBE638  addi r31, r11, -0x19c8
	ctx.r[31].s64 = ctx.r[11].s64 + -6600;
	// 82AC5ABC: 816AE640  lwz r11, -0x19c0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-6592 as u32) ) } as u64;
	// 82AC5AC0: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82AC5AC4: 40820024  bne 0x82ac5ae8
	if !ctx.cr[0].eq {
	pc = 0x82AC5AE8; continue 'dispatch;
	}
	// 82AC5AC8: 3D208256  lis r9, -0x7daa
	ctx.r[9].s64 = -2108293120;
	// 82AC5ACC: 3D0082AC  lis r8, -0x7d54
	ctx.r[8].s64 = -2102657024;
	// 82AC5AD0: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82AC5AD4: 3929DA70  addi r9, r9, -0x2590
	ctx.r[9].s64 = ctx.r[9].s64 + -9616;
	// 82AC5AD8: 390856D8  addi r8, r8, 0x56d8
	ctx.r[8].s64 = ctx.r[8].s64 + 22232;
	// 82AC5ADC: 916AE640  stw r11, -0x19c0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-6592 as u32), ctx.r[11].u32 ) };
	// 82AC5AE0: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82AC5AE4: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82AC5AE8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82AC5AEC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82AC5AF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC5AF4: 38BE0008  addi r5, r30, 8
	ctx.r[5].s64 = ctx.r[30].s64 + 8;
	// 82AC5AF8: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 82AC5AFC: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AC5B00: 4BB0CE21  bl 0x825d2920
	ctx.lr = 0x82AC5B04;
	sub_825D2920(ctx, base);
	// 82AC5B04: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC5B08: 4182000C  beq 0x82ac5b14
	if ctx.cr[0].eq {
	pc = 0x82AC5B14; continue 'dispatch;
	}
	// 82AC5B0C: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82AC5B10: 48000008  b 0x82ac5b18
	pc = 0x82AC5B18; continue 'dispatch;
	// 82AC5B14: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82AC5B18: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AC5B1C: 486E26A0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC5B20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC5B20 size=176
    let mut pc: u32 = 0x82AC5B20;
    'dispatch: loop {
        match pc {
            0x82AC5B20 => {
    //   block [0x82AC5B20..0x82AC5BD0)
	// 82AC5B20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC5B24: 486E2649  bl 0x831a816c
	ctx.lr = 0x82AC5B28;
	sub_831A8130(ctx, base);
	// 82AC5B28: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC5B2C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC5B30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC5B34: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82AC5B38: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AC5B3C: 388B9618  addi r4, r11, -0x69e8
	ctx.r[4].s64 = ctx.r[11].s64 + -27112;
	// 82AC5B40: 38A0012F  li r5, 0x12f
	ctx.r[5].s64 = 303;
	// 82AC5B44: 38600050  li r3, 0x50
	ctx.r[3].s64 = 80;
	// 82AC5B48: 4832C8A1  bl 0x82df23e8
	ctx.lr = 0x82AC5B4C;
	sub_82DF23E8(ctx, base);
	// 82AC5B4C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC5B50: 41820010  beq 0x82ac5b60
	if ctx.cr[0].eq {
	pc = 0x82AC5B60; continue 'dispatch;
	}
	// 82AC5B54: 4BB3741D  bl 0x825fcf70
	ctx.lr = 0x82AC5B58;
	sub_825FCF70(ctx, base);
	// 82AC5B58: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AC5B5C: 48000008  b 0x82ac5b64
	pc = 0x82AC5B64; continue 'dispatch;
	// 82AC5B60: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AC5B64: 3BDF0038  addi r30, r31, 0x38
	ctx.r[30].s64 = ctx.r[31].s64 + 56;
	// 82AC5B68: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC5B6C: 4BB35C8D  bl 0x825fb7f8
	ctx.lr = 0x82AC5B70;
	sub_825FB7F8(ctx, base);
	// 82AC5B70: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82AC5B74: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AC5B78: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82AC5B7C: 48350CC5  bl 0x82e16840
	ctx.lr = 0x82AC5B80;
	sub_82E16840(ctx, base);
	// 82AC5B80: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AC5B84: 807F0038  lwz r3, 0x38(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82AC5B88: 483517D9  bl 0x82e17360
	ctx.lr = 0x82AC5B8C;
	sub_82E17360(ctx, base);
	// 82AC5B8C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AC5B90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC5B94: 388B51D0  addi r4, r11, 0x51d0
	ctx.r[4].s64 = ctx.r[11].s64 + 20944;
	// 82AC5B98: 83DF0038  lwz r30, 0x38(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82AC5B9C: 48333995  bl 0x82df9530
	ctx.lr = 0x82AC5BA0;
	sub_82DF9530(ctx, base);
	// 82AC5BA0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AC5BA4: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82AC5BA8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC5BAC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC5BB0: 48351B99  bl 0x82e17748
	ctx.lr = 0x82AC5BB4;
	sub_82E17748(ctx, base);
	// 82AC5BB4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AC5BB8: 809F0030  lwz r4, 0x30(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82AC5BBC: 807F0038  lwz r3, 0x38(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82AC5BC0: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC5BC4: 48378C75  bl 0x82e3e838
	ctx.lr = 0x82AC5BC8;
	sub_82E3E838(ctx, base);
	// 82AC5BC8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AC5BCC: 486E25F0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC5BD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC5BD0 size=356
    let mut pc: u32 = 0x82AC5BD0;
    'dispatch: loop {
        match pc {
            0x82AC5BD0 => {
    //   block [0x82AC5BD0..0x82AC5D34)
	// 82AC5BD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC5BD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC5BD8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC5BDC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC5BE0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC5BE4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AC5BE8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC5BEC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AC5BF0: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC5BF4: 48364EF5  bl 0x82e2aae8
	ctx.lr = 0x82AC5BF8;
	sub_82E2AAE8(ctx, base);
	// 82AC5BF8: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AC5BFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC5C00: 808BFA18  lwz r4, -0x5e8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1512 as u32) ) } as u64;
	// 82AC5C04: 4832DE05  bl 0x82df3a08
	ctx.lr = 0x82AC5C08;
	sub_82DF3A08(ctx, base);
	// 82AC5C08: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AC5C0C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82AC5C10: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82AC5C14: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82AC5C18: 48368B89  bl 0x82e2e7a0
	ctx.lr = 0x82AC5C1C;
	sub_82E2E7A0(ctx, base);
	// 82AC5C1C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC5C20: 4832D809  bl 0x82df3428
	ctx.lr = 0x82AC5C24;
	sub_82DF3428(ctx, base);
	// 82AC5C24: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AC5C28: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC5C2C: 4837A2DD  bl 0x82e3ff08
	ctx.lr = 0x82AC5C30;
	sub_82E3FF08(ctx, base);
	// 82AC5C30: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AC5C34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC5C38: 808BFA1C  lwz r4, -0x5e4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1508 as u32) ) } as u64;
	// 82AC5C3C: 4832DDCD  bl 0x82df3a08
	ctx.lr = 0x82AC5C40;
	sub_82DF3A08(ctx, base);
	// 82AC5C40: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AC5C44: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82AC5C48: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82AC5C4C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AC5C50: 4837AE19  bl 0x82e40a68
	ctx.lr = 0x82AC5C54;
	sub_82E40A68(ctx, base);
	// 82AC5C54: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AC5C58: 395F0030  addi r10, r31, 0x30
	ctx.r[10].s64 = ctx.r[31].s64 + 48;
	// 82AC5C5C: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82AC5C60: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 82AC5C64: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC5C68: 917F0030  stw r11, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 82AC5C6C: 4B7FE7F5  bl 0x822c4460
	ctx.lr = 0x82AC5C70;
	sub_822C4460(ctx, base);
	// 82AC5C70: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82AC5C74: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC5C78: 419A0008  beq cr6, 0x82ac5c80
	if ctx.cr[6].eq {
	pc = 0x82AC5C80; continue 'dispatch;
	}
	// 82AC5C7C: 4B7FAC15  bl 0x822c0890
	ctx.lr = 0x82AC5C80;
	sub_822C0890(ctx, base);
	// 82AC5C80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC5C84: 4832D7A5  bl 0x82df3428
	ctx.lr = 0x82AC5C88;
	sub_82DF3428(ctx, base);
	// 82AC5C88: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82AC5C8C: 81410068  lwz r10, 0x68(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82AC5C90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC5C94: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82AC5C98: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 82AC5C9C: 419A0024  beq cr6, 0x82ac5cc0
	if ctx.cr[6].eq {
	pc = 0x82AC5CC0; continue 'dispatch;
	}
	// 82AC5CA0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AC5CA4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AC5CA8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AC5CAC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AC5CB0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AC5CB4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AC5CB8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AC5CBC: 4082FFE8  bne 0x82ac5ca4
	if !ctx.cr[0].eq {
	pc = 0x82AC5CA4; continue 'dispatch;
	}
	// 82AC5CC0: 3D6082AC  lis r11, -0x7d54
	ctx.r[11].s64 = -2102657024;
	// 82AC5CC4: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82AC5CC8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82AC5CCC: 396B5B20  addi r11, r11, 0x5b20
	ctx.r[11].s64 = ctx.r[11].s64 + 23328;
	// 82AC5CD0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82AC5CD4: 91410080  stw r10, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 82AC5CD8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82AC5CDC: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82AC5CE0: 4BFFFDC1  bl 0x82ac5aa0
	ctx.lr = 0x82AC5CE4;
	sub_82AC5AA0(ctx, base);
	// 82AC5CE4: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 82AC5CE8: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AC5CEC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82AC5CF0: 4800D771  bl 0x82ad3460
	ctx.lr = 0x82AC5CF4;
	sub_82AD3460(ctx, base);
	// 82AC5CF4: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82AC5CF8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC5CFC: 419A0008  beq cr6, 0x82ac5d04
	if ctx.cr[6].eq {
	pc = 0x82AC5D04; continue 'dispatch;
	}
	// 82AC5D00: 4B7FAB91  bl 0x822c0890
	ctx.lr = 0x82AC5D04;
	sub_822C0890(ctx, base);
	// 82AC5D04: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82AC5D08: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC5D0C: 419A0008  beq cr6, 0x82ac5d14
	if ctx.cr[6].eq {
	pc = 0x82AC5D14; continue 'dispatch;
	}
	// 82AC5D10: 4B7FAB81  bl 0x822c0890
	ctx.lr = 0x82AC5D14;
	sub_822C0890(ctx, base);
	// 82AC5D14: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AC5D18: 48364DE9  bl 0x82e2ab00
	ctx.lr = 0x82AC5D1C;
	sub_82E2AB00(ctx, base);
	// 82AC5D1C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82AC5D20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC5D24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC5D28: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AC5D2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC5D30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC5D38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC5D38 size=276
    let mut pc: u32 = 0x82AC5D38;
    'dispatch: loop {
        match pc {
            0x82AC5D38 => {
    //   block [0x82AC5D38..0x82AC5E4C)
	// 82AC5D38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC5D3C: 486E2429  bl 0x831a8164
	ctx.lr = 0x82AC5D40;
	sub_831A8130(ctx, base);
	// 82AC5D40: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC5D44: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82AC5D48: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC5D4C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82AC5D50: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AC5D54: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82AC5D58: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82AC5D5C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AC5D60: 388B9618  addi r4, r11, -0x69e8
	ctx.r[4].s64 = ctx.r[11].s64 + -27112;
	// 82AC5D64: 38A00109  li r5, 0x109
	ctx.r[5].s64 = 265;
	// 82AC5D68: 38600140  li r3, 0x140
	ctx.r[3].s64 = 320;
	// 82AC5D6C: 4832C67D  bl 0x82df23e8
	ctx.lr = 0x82AC5D70;
	sub_82DF23E8(ctx, base);
	// 82AC5D70: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82AC5D74: 41820030  beq 0x82ac5da4
	if ctx.cr[0].eq {
	pc = 0x82AC5DA4; continue 'dispatch;
	}
	// 82AC5D78: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AC5D7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC5D80: 808BFA14  lwz r4, -0x5ec(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1516 as u32) ) } as u64;
	// 82AC5D84: 4832DC85  bl 0x82df3a08
	ctx.lr = 0x82AC5D88;
	sub_82DF3A08(ctx, base);
	// 82AC5D88: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82AC5D8C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82AC5D90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC5D94: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82AC5D98: 480EDE69  bl 0x82bb3c00
	ctx.lr = 0x82AC5D9C;
	sub_82BB3C00(ctx, base);
	// 82AC5D9C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AC5DA0: 48000008  b 0x82ac5da8
	pc = 0x82AC5DA8; continue 'dispatch;
	// 82AC5DA4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AC5DA8: 3BFD0020  addi r31, r29, 0x20
	ctx.r[31].s64 = ctx.r[29].s64 + 32;
	// 82AC5DAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC5DB0: 4B897631  bl 0x8235d3e0
	ctx.lr = 0x82AC5DB4;
	sub_8235D3E0(ctx, base);
	// 82AC5DB4: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC5DB8: 4182000C  beq 0x82ac5dc4
	if ctx.cr[0].eq {
	pc = 0x82AC5DC4; continue 'dispatch;
	}
	// 82AC5DBC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC5DC0: 4832D669  bl 0x82df3428
	ctx.lr = 0x82AC5DC4;
	sub_82DF3428(ctx, base);
	// 82AC5DC4: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AC5DC8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC5DCC: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 82AC5DD0: 388BFA28  addi r4, r11, -0x5d8
	ctx.r[4].s64 = ctx.r[11].s64 + -1496;
	// 82AC5DD4: 480EF18D  bl 0x82bb4f60
	ctx.lr = 0x82AC5DD8;
	sub_82BB4F60(ctx, base);
	// 82AC5DD8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AC5DDC: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC5DE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC5DE4: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82AC5DE8: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82AC5DEC: 419A0024  beq cr6, 0x82ac5e10
	if ctx.cr[6].eq {
	pc = 0x82AC5E10; continue 'dispatch;
	}
	// 82AC5DF0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AC5DF4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AC5DF8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AC5DFC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AC5E00: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AC5E04: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AC5E08: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AC5E0C: 4082FFE8  bne 0x82ac5df4
	if !ctx.cr[0].eq {
	pc = 0x82AC5DF4; continue 'dispatch;
	}
	// 82AC5E10: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82AC5E14: 807D0018  lwz r3, 0x18(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82AC5E18: 4834F159  bl 0x82e14f70
	ctx.lr = 0x82AC5E1C;
	sub_82E14F70(ctx, base);
	// 82AC5E1C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AC5E20: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC5E24: 419A0008  beq cr6, 0x82ac5e2c
	if ctx.cr[6].eq {
	pc = 0x82AC5E2C; continue 'dispatch;
	}
	// 82AC5E28: 4B7FAA69  bl 0x822c0890
	ctx.lr = 0x82AC5E2C;
	sub_822C0890(ctx, base);
	// 82AC5E2C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82AC5E30: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82AC5E34: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC5E38: 4BFFFD99  bl 0x82ac5bd0
	ctx.lr = 0x82AC5E3C;
	sub_82AC5BD0(ctx, base);
	// 82AC5E3C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AC5E40: 997D0010  stb r11, 0x10(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(16 as u32), ctx.r[11].u8 ) };
	// 82AC5E44: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82AC5E48: 486E236C  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC5E50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC5E50 size=168
    let mut pc: u32 = 0x82AC5E50;
    'dispatch: loop {
        match pc {
            0x82AC5E50 => {
    //   block [0x82AC5E50..0x82AC5EF8)
	// 82AC5E50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC5E54: 486E2315  bl 0x831a8168
	ctx.lr = 0x82AC5E58;
	sub_831A8130(ctx, base);
	// 82AC5E58: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC5E5C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC5E60: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC5E64: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82AC5E68: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82AC5E6C: 396B9614  addi r11, r11, -0x69ec
	ctx.r[11].s64 = ctx.r[11].s64 + -27116;
	// 82AC5E70: 909F0004  stw r4, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 82AC5E74: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 82AC5E78: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AC5E7C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82AC5E80: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82AC5E84: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82AC5E88: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC5E8C: 388A9BC9  addi r4, r10, -0x6437
	ctx.r[4].s64 = ctx.r[10].s64 + -25655;
	// 82AC5E90: 9BDF0010  stb r30, 0x10(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u8 ) };
	// 82AC5E94: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82AC5E98: 4832DB71  bl 0x82df3a08
	ctx.lr = 0x82AC5E9C;
	sub_82DF3A08(ctx, base);
	// 82AC5E9C: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 82AC5EA0: 93DF001C  stw r30, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 82AC5EA4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AC5EA8: 93DF0020  stw r30, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
	// 82AC5EAC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AC5EB0: 93DF0024  stw r30, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[30].u32 ) };
	// 82AC5EB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC5EB8: 93DF0028  stw r30, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[30].u32 ) };
	// 82AC5EBC: 93DF002C  stw r30, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[30].u32 ) };
	// 82AC5EC0: 93DF0030  stw r30, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[30].u32 ) };
	// 82AC5EC4: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC5EC8: 93DF0034  stw r30, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[30].u32 ) };
	// 82AC5ECC: 93DF0038  stw r30, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[30].u32 ) };
	// 82AC5ED0: 93DF003C  stw r30, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[30].u32 ) };
	// 82AC5ED4: D01F0040  stfs f0, 0x40(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 82AC5ED8: 4BFFFA41  bl 0x82ac5918
	ctx.lr = 0x82AC5EDC;
	sub_82AC5918(ctx, base);
	// 82AC5EDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC5EE0: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82AC5EE4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AC5EE8: 4BFFFE51  bl 0x82ac5d38
	ctx.lr = 0x82AC5EEC;
	sub_82AC5D38(ctx, base);
	// 82AC5EEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC5EF0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AC5EF4: 486E22C4  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC5EF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AC5EF8 size=28
    let mut pc: u32 = 0x82AC5EF8;
    'dispatch: loop {
        match pc {
            0x82AC5EF8 => {
    //   block [0x82AC5EF8..0x82AC5F14)
	// 82AC5EF8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC5EFC: 90830004  stw r4, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 82AC5F00: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82AC5F04: 396B97A0  addi r11, r11, -0x6860
	ctx.r[11].s64 = ctx.r[11].s64 + -26720;
	// 82AC5F08: 9943000C  stb r10, 0xc(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[10].u8 ) };
	// 82AC5F0C: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC5F10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


