pub fn sub_830E1E78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830E1E78 size=24
    let mut pc: u32 = 0x830E1E78;
    'dispatch: loop {
        match pc {
            0x830E1E78 => {
    //   block [0x830E1E78..0x830E1E90)
	// 830E1E78: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E1E7C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830E1E80: 409A0010  bne cr6, 0x830e1e90
	if !ctx.cr[6].eq {
		sub_830E1E90(ctx, base);
		return;
	}
	// 830E1E84: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 830E1E88: 6063FFFF  ori r3, r3, 0xffff
	ctx.r[3].u64 = ctx.r[3].u64 | 65535;
	// 830E1E8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E1E90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830E1E90 size=4
    let mut pc: u32 = 0x830E1E90;
    'dispatch: loop {
        match pc {
            0x830E1E90 => {
    //   block [0x830E1E90..0x830E1E94)
	// 830E1E90: 4BFF0678  b 0x830d2508
	sub_830D2508(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E1E98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E1E98 size=136
    let mut pc: u32 = 0x830E1E98;
    'dispatch: loop {
        match pc {
            0x830E1E98 => {
    //   block [0x830E1E98..0x830E1F20)
	// 830E1E98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E1E9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E1EA0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830E1EA4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E1EA8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E1EAC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E1EB0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830E1EB4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830E1EB8: 419A004C  beq cr6, 0x830e1f04
	if ctx.cr[6].eq {
	pc = 0x830E1F04; continue 'dispatch;
	}
	// 830E1EBC: 4BFECE4D  bl 0x830ced08
	ctx.lr = 0x830E1EC0;
	sub_830CED08(ctx, base);
	// 830E1EC0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830E1EC4: 41820040  beq 0x830e1f04
	if ctx.cr[0].eq {
	pc = 0x830E1F04; continue 'dispatch;
	}
	// 830E1EC8: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 830E1ECC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E1ED0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E1ED4: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 830E1ED8: 4BFF0341  bl 0x830d2218
	ctx.lr = 0x830E1EDC;
	sub_830D2218(ctx, base);
	// 830E1EDC: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E1EE0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830E1EE4: 419A0020  beq cr6, 0x830e1f04
	if ctx.cr[6].eq {
	pc = 0x830E1F04; continue 'dispatch;
	}
	// 830E1EE8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 830E1EEC: 4BFFFC95  bl 0x830e1b80
	ctx.lr = 0x830E1EF0;
	sub_830E1B80(ctx, base);
	// 830E1EF0: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830E1EF4: 4B1DE10D  bl 0x822c0000
	ctx.lr = 0x830E1EF8;
	sub_822C0000(ctx, base);
	// 830E1EF8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830E1EFC: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E1F00: 4BFFB5D9  bl 0x830dd4d8
	ctx.lr = 0x830E1F04;
	sub_830DD4D8(ctx, base);
	// 830E1F04: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E1F08: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E1F0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E1F10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E1F14: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830E1F18: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E1F1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E1F20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E1F20 size=388
    let mut pc: u32 = 0x830E1F20;
    'dispatch: loop {
        match pc {
            0x830E1F20 => {
    //   block [0x830E1F20..0x830E20A4)
	// 830E1F20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E1F24: 480C6231  bl 0x831a8154
	ctx.lr = 0x830E1F28;
	sub_831A8130(ctx, base);
	// 830E1F28: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E1F2C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 830E1F30: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 830E1F34: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 830E1F38: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 830E1F3C: 7CF73B78  mr r23, r7
	ctx.r[23].u64 = ctx.r[7].u64;
	// 830E1F40: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 830E1F44: 419A0150  beq cr6, 0x830e2094
	if ctx.cr[6].eq {
	pc = 0x830E2094; continue 'dispatch;
	}
	// 830E1F48: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 830E1F4C: 419A0148  beq cr6, 0x830e2094
	if ctx.cr[6].eq {
	pc = 0x830E2094; continue 'dispatch;
	}
	// 830E1F50: 2B170000  cmplwi cr6, r23, 0
	ctx.cr[6].compare_u32(ctx.r[23].u32, 0 as u32, &mut ctx.xer);
	// 830E1F54: 419A0140  beq cr6, 0x830e2094
	if ctx.cr[6].eq {
	pc = 0x830E2094; continue 'dispatch;
	}
	// 830E1F58: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 830E1F5C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 830E1F60: 933A0000  stw r25, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 830E1F64: 93380000  stw r25, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 830E1F68: 93370000  stw r25, 0(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 830E1F6C: 409A000C  bne cr6, 0x830e1f78
	if !ctx.cr[6].eq {
	pc = 0x830E1F78; continue 'dispatch;
	}
	// 830E1F70: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 830E1F74: 48000074  b 0x830e1fe8
	pc = 0x830E1FE8; continue 'dispatch;
	// 830E1F78: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830E1F7C: 480C714D  bl 0x831a90c8
	ctx.lr = 0x830E1F80;
	sub_831A90C8(ctx, base);
	// 830E1F80: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830E1F84: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830E1F88: 480C7141  bl 0x831a90c8
	ctx.lr = 0x830E1F8C;
	sub_831A90C8(ctx, base);
	// 830E1F8C: 7D63EA14  add r11, r3, r29
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[29].u64;
	// 830E1F90: 3BCB0001  addi r30, r11, 1
	ctx.r[30].s64 = ctx.r[11].s64 + 1;
	// 830E1F94: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 830E1F98: 409900F0  ble cr6, 0x830e2088
	if !ctx.cr[6].gt {
	pc = 0x830E2088; continue 'dispatch;
	}
	// 830E1F9C: 7F1E1840  cmplw cr6, r30, r3
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[3].u32, &mut ctx.xer);
	// 830E1FA0: 409900E8  ble cr6, 0x830e2088
	if !ctx.cr[6].gt {
	pc = 0x830E2088; continue 'dispatch;
	}
	// 830E1FA4: 3D607FFF  lis r11, 0x7fff
	ctx.r[11].s64 = 2147418112;
	// 830E1FA8: 616BFFFF  ori r11, r11, 0xffff
	ctx.r[11].u64 = ctx.r[11].u64 | 65535;
	// 830E1FAC: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830E1FB0: 409800D8  bge cr6, 0x830e2088
	if !ctx.cr[6].lt {
	pc = 0x830E2088; continue 'dispatch;
	}
	// 830E1FB4: 57C3083C  slwi r3, r30, 1
	ctx.r[3].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 830E1FB8: 4BFFB4F9  bl 0x830dd4b0
	ctx.lr = 0x830E1FBC;
	sub_830DD4B0(ctx, base);
	// 830E1FBC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830E1FC0: 418200C8  beq 0x830e2088
	if ctx.cr[0].eq {
	pc = 0x830E2088; continue 'dispatch;
	}
	// 830E1FC4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 830E1FC8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830E1FCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E1FD0: 480CFEE9  bl 0x831b1eb8
	ctx.lr = 0x830E1FD4;
	sub_831B1EB8(ctx, base);
	// 830E1FD4: 57AB083C  slwi r11, r29, 1
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830E1FD8: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 830E1FDC: 7C9DF050  subf r4, r29, r30
	ctx.r[4].s64 = ctx.r[30].s64 - ctx.r[29].s64;
	// 830E1FE0: 7C6BFA14  add r3, r11, r31
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 830E1FE4: 480CFED5  bl 0x831b1eb8
	ctx.lr = 0x830E1FE8;
	sub_831B1EB8(ctx, base);
	// 830E1FE8: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830E1FEC: 3B8BD7A8  addi r28, r11, -0x2858
	ctx.r[28].s64 = ctx.r[11].s64 + -10328;
	// 830E1FF0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830E1FF4: 48160979  bl 0x8324296c
	ctx.lr = 0x830E1FF8;
	// extern call 0x8324296C → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 830E1FF8: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830E1FFC: 3BABD828  addi r29, r11, -0x27d8
	ctx.r[29].s64 = ctx.r[11].s64 + -10200;
	// 830E2000: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830E2004: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E2008: 4BFFBD59  bl 0x830ddd60
	ctx.lr = 0x830E200C;
	sub_830DDD60(ctx, base);
	// 830E200C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830E2010: 7F1FD840  cmplw cr6, r31, r27
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[27].u32, &mut ctx.xer);
	// 830E2014: 419A0030  beq cr6, 0x830e2044
	if ctx.cr[6].eq {
	pc = 0x830E2044; continue 'dispatch;
	}
	// 830E2018: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E201C: 4BFFB4BD  bl 0x830dd4d8
	ctx.lr = 0x830E2020;
	sub_830DD4D8(ctx, base);
	// 830E2020: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830E2024: 4098000C  bge cr6, 0x830e2030
	if !ctx.cr[6].lt {
	pc = 0x830E2030; continue 'dispatch;
	}
	// 830E2028: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 830E202C: 48000010  b 0x830e203c
	pc = 0x830E203C; continue 'dispatch;
	// 830E2030: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830E2034: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 830E2038: 91770000  stw r11, 0(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830E203C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830E2040: 409AFFC0  bne cr6, 0x830e2000
	if !ctx.cr[6].eq {
	pc = 0x830E2000; continue 'dispatch;
	}
	// 830E2044: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830E2048: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830E204C: 40980014  bge cr6, 0x830e2060
	if !ctx.cr[6].lt {
	pc = 0x830E2060; continue 'dispatch;
	}
	// 830E2050: 4816090D  bl 0x8324295c
	ctx.lr = 0x830E2054;
	// extern call 0x8324295C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 830E2054: 3C608030  lis r3, -0x7fd0
	ctx.r[3].s64 = -2144337920;
	// 830E2058: 60630026  ori r3, r3, 0x26
	ctx.r[3].u64 = ctx.r[3].u64 | 38;
	// 830E205C: 48000040  b 0x830e209c
	pc = 0x830E209C; continue 'dispatch;
	// 830E2060: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E2064: 57CA1838  slwi r10, r30, 3
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830E2068: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 830E206C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E2070: 915A0000  stw r10, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830E2074: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E2078: 91780000  stw r11, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830E207C: 481608E1  bl 0x8324295c
	ctx.lr = 0x830E2080;
	// extern call 0x8324295C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 830E2080: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E2084: 48000018  b 0x830e209c
	pc = 0x830E209C; continue 'dispatch;
	// 830E2088: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 830E208C: 6063000E  ori r3, r3, 0xe
	ctx.r[3].u64 = ctx.r[3].u64 | 14;
	// 830E2090: 4800000C  b 0x830e209c
	pc = 0x830E209C; continue 'dispatch;
	// 830E2094: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 830E2098: 60630057  ori r3, r3, 0x57
	ctx.r[3].u64 = ctx.r[3].u64 | 87;
	// 830E209C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830E20A0: 480C6104  b 0x831a81a4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E20A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E20A8 size=832
    let mut pc: u32 = 0x830E20A8;
    'dispatch: loop {
        match pc {
            0x830E20A8 => {
    //   block [0x830E20A8..0x830E23E8)
	// 830E20A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E20AC: 480C6095  bl 0x831a8140
	ctx.lr = 0x830E20B0;
	sub_831A8130(ctx, base);
	// 830E20B0: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E20B4: 7CB62B78  mr r22, r5
	ctx.r[22].u64 = ctx.r[5].u64;
	// 830E20B8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830E20BC: 3D601555  lis r11, 0x1555
	ctx.r[11].s64 = 357892096;
	// 830E20C0: 7C751B78  mr r21, r3
	ctx.r[21].u64 = ctx.r[3].u64;
	// 830E20C4: 616B5555  ori r11, r11, 0x5555
	ctx.r[11].u64 = ctx.r[11].u64 | 21845;
	// 830E20C8: 92B60018  stw r21, 0x18(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(24 as u32), ctx.r[21].u32 ) };
	// 830E20CC: 7CD33378  mr r19, r6
	ctx.r[19].u64 = ctx.r[6].u64;
	// 830E20D0: 829E0008  lwz r20, 8(r30)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E20D4: 7CF23B78  mr r18, r7
	ctx.r[18].u64 = ctx.r[7].u64;
	// 830E20D8: 7F145840  cmplw cr6, r20, r11
	ctx.cr[6].compare_u32(ctx.r[20].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830E20DC: 1C74000C  mulli r3, r20, 0xc
	ctx.r[3].s64 = ctx.r[20].s64 * 12;
	// 830E20E0: 40990008  ble cr6, 0x830e20e8
	if !ctx.cr[6].gt {
	pc = 0x830E20E8; continue 'dispatch;
	}
	// 830E20E4: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 830E20E8: 4BFFB3C9  bl 0x830dd4b0
	ctx.lr = 0x830E20EC;
	sub_830DD4B0(ctx, base);
	// 830E20EC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830E20F0: 90760038  stw r3, 0x38(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(56 as u32), ctx.r[3].u32 ) };
	// 830E20F4: 40820010  bne 0x830e2104
	if !ctx.cr[0].eq {
	pc = 0x830E2104; continue 'dispatch;
	}
	// 830E20F8: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 830E20FC: 6063000E  ori r3, r3, 0xe
	ctx.r[3].u64 = ctx.r[3].u64 | 14;
	// 830E2100: 480002C8  b 0x830e23c8
	pc = 0x830E23C8; continue 'dispatch;
	// 830E2104: 92960034  stw r20, 0x34(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(52 as u32), ctx.r[20].u32 ) };
	// 830E2108: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 830E210C: 2F140000  cmpwi cr6, r20, 0
	ctx.cr[6].compare_i32(ctx.r[20].s32, 0, &mut ctx.xer);
	// 830E2110: 40990150  ble cr6, 0x830e2260
	if !ctx.cr[6].gt {
	pc = 0x830E2260; continue 'dispatch;
	}
	// 830E2114: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830E2118: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 830E211C: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 830E2120: 3B0B92C0  addi r24, r11, -0x6d40
	ctx.r[24].s64 = ctx.r[11].s64 + -27968;
	// 830E2124: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 830E2128: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 830E212C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E2130: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 830E2134: 409900D8  ble cr6, 0x830e220c
	if !ctx.cr[6].gt {
	pc = 0x830E220C; continue 'dispatch;
	}
	// 830E2138: 92A1005C  stw r21, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[21].u32 ) };
	// 830E213C: 3B410058  addi r26, r1, 0x58
	ctx.r[26].s64 = ctx.r[1].s64 + 88;
	// 830E2140: 93010058  stw r24, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[24].u32 ) };
	// 830E2144: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 830E2148: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E214C: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 830E2150: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E2154: 409900A0  ble cr6, 0x830e21f4
	if !ctx.cr[6].gt {
	pc = 0x830E21F4; continue 'dispatch;
	}
	// 830E2158: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830E215C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830E2160: 48020359  bl 0x831024b8
	ctx.lr = 0x830E2164;
	sub_831024B8(ctx, base);
	// 830E2164: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 830E2168: 815A0000  lwz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E216C: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 830E2170: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 830E2174: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830E2178: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830E217C: 814A0010  lwz r10, 0x10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 830E2180: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E2184: 7D6BE82E  lwzx r11, r11, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 830E2188: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E218C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 830E2190: 4E800421  bctrl
	ctx.lr = 0x830E2194;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830E2194: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E2198: 418000F4  blt 0x830e228c
	if ctx.cr[0].lt {
	pc = 0x830E228C; continue 'dispatch;
	}
	// 830E219C: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 830E21A0: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 830E21A4: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E21A8: 7D4AE82E  lwzx r10, r10, r29
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 830E21AC: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E21B0: 55290739  rlwinm. r9, r9, 0, 0x1c, 0x1c
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830E21B4: 408200EC  bne 0x830e22a0
	if !ctx.cr[0].eq {
	pc = 0x830E22A0; continue 'dispatch;
	}
	// 830E21B8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E21BC: 7D5C5378  mr r28, r10
	ctx.r[28].u64 = ctx.r[10].u64;
	// 830E21C0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830E21C4: 7F1B5800  cmpw cr6, r27, r11
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830E21C8: 419A0008  beq cr6, 0x830e21d0
	if ctx.cr[6].eq {
	pc = 0x830E21D0; continue 'dispatch;
	}
	// 830E21CC: 83410064  lwz r26, 0x64(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 830E21D0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830E21D4: 480208B5  bl 0x83102a88
	ctx.lr = 0x830E21D8;
	sub_83102A88(ctx, base);
	// 830E21D8: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 830E21DC: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 830E21E0: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 830E21E4: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 830E21E8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E21EC: 7F1B5800  cmpw cr6, r27, r11
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830E21F0: 4198FF6C  blt cr6, 0x830e215c
	if ctx.cr[6].lt {
	pc = 0x830E215C; continue 'dispatch;
	}
	// 830E21F4: 81760038  lwz r11, 0x38(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(56 as u32) ) } as u64;
	// 830E21F8: 7F4BF92E  stwx r26, r11, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32), ctx.r[26].u32) };
	// 830E21FC: 81760038  lwz r11, 0x38(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(56 as u32) ) } as u64;
	// 830E2200: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 830E2204: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 830E2208: 48000030  b 0x830e2238
	pc = 0x830E2238; continue 'dispatch;
	// 830E220C: 409A0040  bne cr6, 0x830e224c
	if !ctx.cr[6].eq {
	pc = 0x830E224C; continue 'dispatch;
	}
	// 830E2210: 81760038  lwz r11, 0x38(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(56 as u32) ) } as u64;
	// 830E2214: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830E2218: 7D4BF92E  stwx r10, r11, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32), ctx.r[10].u32) };
	// 830E221C: 81760038  lwz r11, 0x38(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(56 as u32) ) } as u64;
	// 830E2220: 7D4BFA14  add r10, r11, r31
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 830E2224: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 830E2228: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 830E222C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E2230: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E2234: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830E2238: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830E223C: 81760038  lwz r11, 0x38(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(56 as u32) ) } as u64;
	// 830E2240: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 830E2244: 7D4AC82E  lwzx r10, r10, r25
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 830E2248: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830E224C: 3AF70001  addi r23, r23, 1
	ctx.r[23].s64 = ctx.r[23].s64 + 1;
	// 830E2250: 3B390004  addi r25, r25, 4
	ctx.r[25].s64 = ctx.r[25].s64 + 4;
	// 830E2254: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 830E2258: 7F17A000  cmpw cr6, r23, r20
	ctx.cr[6].compare_i32(ctx.r[23].s32, ctx.r[20].s32, &mut ctx.xer);
	// 830E225C: 4198FEC8  blt cr6, 0x830e2124
	if ctx.cr[6].lt {
	pc = 0x830E2124; continue 'dispatch;
	}
	// 830E2260: 2F130000  cmpwi cr6, r19, 0
	ctx.cr[6].compare_i32(ctx.r[19].s32, 0, &mut ctx.xer);
	// 830E2264: 419A0048  beq cr6, 0x830e22ac
	if ctx.cr[6].eq {
	pc = 0x830E22AC; continue 'dispatch;
	}
	// 830E2268: 809E001C  lwz r4, 0x1c(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 830E226C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830E2270: 419A003C  beq cr6, 0x830e22ac
	if ctx.cr[6].eq {
	pc = 0x830E22AC; continue 'dispatch;
	}
	// 830E2274: 7E479378  mr r7, r18
	ctx.r[7].u64 = ctx.r[18].u64;
	// 830E2278: 80BE0014  lwz r5, 0x14(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 830E227C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 830E2280: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 830E2284: 4801CFFD  bl 0x830ff280
	ctx.lr = 0x830E2288;
	sub_830FF280(ctx, base);
	// 830E2288: 4800013C  b 0x830e23c4
	pc = 0x830E23C4; continue 'dispatch;
	// 830E228C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E2290: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830E2294: 480207F5  bl 0x83102a88
	ctx.lr = 0x830E2298;
	sub_83102A88(ctx, base);
	// 830E2298: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E229C: 4800012C  b 0x830e23c8
	pc = 0x830E23C8; continue 'dispatch;
	// 830E22A0: 3FE08007  lis r31, -0x7ff9
	ctx.r[31].s64 = -2147024896;
	// 830E22A4: 63FF0057  ori r31, r31, 0x57
	ctx.r[31].u64 = ctx.r[31].u64 | 87;
	// 830E22A8: 4BFFFFE8  b 0x830e2290
	pc = 0x830E2290; continue 'dispatch;
	// 830E22AC: 833E0014  lwz r25, 0x14(r30)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 830E22B0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830E22B4: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 830E22B8: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 830E22BC: 48024D7D  bl 0x83107038
	ctx.lr = 0x830E22C0;
	sub_83107038(ctx, base);
	// 830E22C0: 7C781B79  or. r24, r3, r3
	ctx.r[24].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[24].s32, 0, &mut ctx.xer);
	// 830E22C4: 4182FE34  beq 0x830e20f8
	if ctx.cr[0].eq {
	pc = 0x830E20F8; continue 'dispatch;
	}
	// 830E22C8: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 830E22CC: 2F190000  cmpwi cr6, r25, 0
	ctx.cr[6].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 830E22D0: 409900D0  ble cr6, 0x830e23a0
	if !ctx.cr[6].gt {
	pc = 0x830E23A0; continue 'dispatch;
	}
	// 830E22D4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 830E22D8: 3B780004  addi r27, r24, 4
	ctx.r[27].s64 = ctx.r[24].s64 + 4;
	// 830E22DC: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 830E22E0: 7D7F582E  lwzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830E22E4: 917BFFFC  stw r11, -4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(-4 as u32), ctx.r[11].u32 ) };
	// 830E22E8: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 830E22EC: 7D7F5A14  add r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 830E22F0: 896B0004  lbz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E22F4: 556A07BD  rlwinm. r10, r11, 0, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830E22F8: 4182000C  beq 0x830e2304
	if ctx.cr[0].eq {
	pc = 0x830E2304; continue 'dispatch;
	}
	// 830E22FC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830E2300: 48000010  b 0x830e2310
	pc = 0x830E2310; continue 'dispatch;
	// 830E2304: 556B077B  rlwinm. r11, r11, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E2308: 4182000C  beq 0x830e2314
	if ctx.cr[0].eq {
	pc = 0x830E2314; continue 'dispatch;
	}
	// 830E230C: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 830E2310: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830E2314: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 830E2318: 38FB000C  addi r7, r27, 0xc
	ctx.r[7].s64 = ctx.r[27].s64 + 12;
	// 830E231C: 38DB0004  addi r6, r27, 4
	ctx.r[6].s64 = ctx.r[27].s64 + 4;
	// 830E2320: 7D7F5A14  add r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 830E2324: 894B0007  lbz r10, 7(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(7 as u32) ) } as u64;
	// 830E2328: 892B0006  lbz r9, 6(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6 as u32) ) } as u64;
	// 830E232C: 896B0005  lbz r11, 5(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(5 as u32) ) } as u64;
	// 830E2330: 7D450774  extsb r5, r10
	ctx.r[5].s64 = ctx.r[10].s8 as i64;
	// 830E2334: 7D240774  extsb r4, r9
	ctx.r[4].s64 = ctx.r[9].s8 as i64;
	// 830E2338: 7D630774  extsb r3, r11
	ctx.r[3].s64 = ctx.r[11].s8 as i64;
	// 830E233C: 4BFFEB25  bl 0x830e0e60
	ctx.lr = 0x830E2340;
	sub_830E0E60(ctx, base);
	// 830E2340: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 830E2344: 2F140000  cmpwi cr6, r20, 0
	ctx.cr[6].compare_i32(ctx.r[20].s32, 0, &mut ctx.xer);
	// 830E2348: 40990044  ble cr6, 0x830e238c
	if !ctx.cr[6].gt {
	pc = 0x830E238C; continue 'dispatch;
	}
	// 830E234C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 830E2350: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 830E2354: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E2358: 7D7F5A14  add r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 830E235C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830E2360: 7C8BE214  add r4, r11, r28
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 830E2364: 4802053D  bl 0x831028a0
	ctx.lr = 0x830E2368;
	sub_831028A0(ctx, base);
	// 830E2368: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830E236C: 41800064  blt 0x830e23d0
	if ctx.cr[0].lt {
	pc = 0x830E23D0; continue 'dispatch;
	}
	// 830E2370: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E2374: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 830E2378: 3B9C0014  addi r28, r28, 0x14
	ctx.r[28].s64 = ctx.r[28].s64 + 20;
	// 830E237C: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 830E2380: 7F1AA000  cmpw cr6, r26, r20
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[20].s32, &mut ctx.xer);
	// 830E2384: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830E2388: 4198FFC8  blt cr6, 0x830e2350
	if ctx.cr[6].lt {
	pc = 0x830E2350; continue 'dispatch;
	}
	// 830E238C: 3AF70001  addi r23, r23, 1
	ctx.r[23].s64 = ctx.r[23].s64 + 1;
	// 830E2390: 3B7B001C  addi r27, r27, 0x1c
	ctx.r[27].s64 = ctx.r[27].s64 + 28;
	// 830E2394: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 830E2398: 7F17C800  cmpw cr6, r23, r25
	ctx.cr[6].compare_i32(ctx.r[23].s32, ctx.r[25].s32, &mut ctx.xer);
	// 830E239C: 4198FF40  blt cr6, 0x830e22dc
	if ctx.cr[6].lt {
	pc = 0x830E22DC; continue 'dispatch;
	}
	// 830E23A0: 7E479378  mr r7, r18
	ctx.r[7].u64 = ctx.r[18].u64;
	// 830E23A4: 7E669B78  mr r6, r19
	ctx.r[6].u64 = ctx.r[19].u64;
	// 830E23A8: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 830E23AC: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 830E23B0: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 830E23B4: 4801CECD  bl 0x830ff280
	ctx.lr = 0x830E23B8;
	sub_830FF280(ctx, base);
	// 830E23B8: 2F130000  cmpwi cr6, r19, 0
	ctx.cr[6].compare_i32(ctx.r[19].s32, 0, &mut ctx.xer);
	// 830E23BC: 419A0008  beq cr6, 0x830e23c4
	if ctx.cr[6].eq {
	pc = 0x830E23C4; continue 'dispatch;
	}
	// 830E23C0: 931E001C  stw r24, 0x1c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), ctx.r[24].u32 ) };
	// 830E23C4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E23C8: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 830E23CC: 480C5DC4  b 0x831a8190
	sub_831A8180(ctx, base);
	return;
	// 830E23D0: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 830E23D4: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 830E23D8: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 830E23DC: 48024BDD  bl 0x83106fb8
	ctx.lr = 0x830E23E0;
	sub_83106FB8(ctx, base);
	// 830E23E0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830E23E4: 4BFFFFE4  b 0x830e23c8
	pc = 0x830E23C8; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E23E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E23E8 size=356
    let mut pc: u32 = 0x830E23E8;
    'dispatch: loop {
        match pc {
            0x830E23E8 => {
    //   block [0x830E23E8..0x830E254C)
	// 830E23E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E23EC: 480C5D6D  bl 0x831a8158
	ctx.lr = 0x830E23F0;
	sub_831A8130(ctx, base);
	// 830E23F0: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E23F4: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 830E23F8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 830E23FC: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 830E2400: 2B190001  cmplwi cr6, r25, 1
	ctx.cr[6].compare_u32(ctx.r[25].u32, 1 as u32, &mut ctx.xer);
	// 830E2404: 419A000C  beq cr6, 0x830e2410
	if ctx.cr[6].eq {
	pc = 0x830E2410; continue 'dispatch;
	}
	// 830E2408: 2B190002  cmplwi cr6, r25, 2
	ctx.cr[6].compare_u32(ctx.r[25].u32, 2 as u32, &mut ctx.xer);
	// 830E240C: 409A003C  bne cr6, 0x830e2448
	if !ctx.cr[6].eq {
	pc = 0x830E2448; continue 'dispatch;
	}
	// 830E2410: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 830E2414: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E2418: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830E241C: 4BFFE22D  bl 0x830e0648
	ctx.lr = 0x830E2420;
	sub_830E0648(ctx, base);
	// 830E2420: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 830E2424: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830E2428: 4BFF37A1  bl 0x830d5bc8
	ctx.lr = 0x830E242C;
	sub_830D5BC8(ctx, base);
	// 830E242C: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E2430: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830E2434: 419A000C  beq cr6, 0x830e2440
	if ctx.cr[6].eq {
	pc = 0x830E2440; continue 'dispatch;
	}
	// 830E2438: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830E243C: 4BFFF635  bl 0x830e1a70
	ctx.lr = 0x830E2440;
	sub_830E1A70(ctx, base);
	// 830E2440: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830E2444: 4BFFD2CD  bl 0x830df710
	ctx.lr = 0x830E2448;
	sub_830DF710(ctx, base);
	// 830E2448: 3FC08339  lis r30, -0x7cc7
	ctx.r[30].s64 = -2093416448;
	// 830E244C: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 830E2450: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830E2454: 7F5CD378  mr r28, r26
	ctx.r[28].u64 = ctx.r[26].u64;
	// 830E2458: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 830E245C: 809EC080  lwz r4, -0x3f80(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-16256 as u32) ) } as u64;
	// 830E2460: 4BFFC689  bl 0x830deae8
	ctx.lr = 0x830E2464;
	sub_830DEAE8(ctx, base);
	// 830E2464: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830E2468: 418200DC  beq 0x830e2544
	if ctx.cr[0].eq {
	pc = 0x830E2544; continue 'dispatch;
	}
	// 830E246C: 807D0024  lwz r3, 0x24(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 830E2470: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830E2474: 419A0048  beq cr6, 0x830e24bc
	if ctx.cr[6].eq {
	pc = 0x830E24BC; continue 'dispatch;
	}
	// 830E2478: 809EC080  lwz r4, -0x3f80(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-16256 as u32) ) } as u64;
	// 830E247C: 4BFFC66D  bl 0x830deae8
	ctx.lr = 0x830E2480;
	sub_830DEAE8(ctx, base);
	// 830E2480: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830E2484: 41820010  beq 0x830e2494
	if ctx.cr[0].eq {
	pc = 0x830E2494; continue 'dispatch;
	}
	// 830E2488: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 830E248C: 556B07BF  clrlwi. r11, r11, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E2490: 40820064  bne 0x830e24f4
	if !ctx.cr[0].eq {
	pc = 0x830E24F4; continue 'dispatch;
	}
	// 830E2494: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830E2498: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830E249C: 4BFFD185  bl 0x830df620
	ctx.lr = 0x830E24A0;
	sub_830DF620(ctx, base);
	// 830E24A0: 807D0024  lwz r3, 0x24(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 830E24A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830E24A8: 419A002C  beq cr6, 0x830e24d4
	if ctx.cr[6].eq {
	pc = 0x830E24D4; continue 'dispatch;
	}
	// 830E24AC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830E24B0: 4BFFD171  bl 0x830df620
	ctx.lr = 0x830E24B4;
	sub_830DF620(ctx, base);
	// 830E24B4: 935D0024  stw r26, 0x24(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), ctx.r[26].u32 ) };
	// 830E24B8: 4800003C  b 0x830e24f4
	pc = 0x830E24F4; continue 'dispatch;
	// 830E24BC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830E24C0: 48005E41  bl 0x830e8300
	ctx.lr = 0x830E24C4;
	sub_830E8300(ctx, base);
	// 830E24C4: 7C7C1B79  or. r28, r3, r3
	ctx.r[28].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 830E24C8: 4182FFCC  beq 0x830e2494
	if ctx.cr[0].eq {
	pc = 0x830E2494; continue 'dispatch;
	}
	// 830E24CC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830E24D0: 4BFFFFA8  b 0x830e2478
	pc = 0x830E2478; continue 'dispatch;
	// 830E24D4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 830E24D8: 419A001C  beq cr6, 0x830e24f4
	if ctx.cr[6].eq {
	pc = 0x830E24F4; continue 'dispatch;
	}
	// 830E24DC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830E24E0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830E24E4: 4BFFD13D  bl 0x830df620
	ctx.lr = 0x830E24E8;
	sub_830DF620(ctx, base);
	// 830E24E8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830E24EC: 419A0008  beq cr6, 0x830e24f4
	if ctx.cr[6].eq {
	pc = 0x830E24F4; continue 'dispatch;
	}
	// 830E24F0: 935F0024  stw r26, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[26].u32 ) };
	// 830E24F4: 7F26CB78  mr r6, r25
	ctx.r[6].u64 = ctx.r[25].u64;
	// 830E24F8: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 830E24FC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830E2500: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 830E2504: 4BFFE48D  bl 0x830e0990
	ctx.lr = 0x830E2508;
	sub_830E0990(ctx, base);
	// 830E2508: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830E250C: 3BE10090  addi r31, r1, 0x90
	ctx.r[31].s64 = ctx.r[1].s64 + 144;
	// 830E2510: 4BFEC701  bl 0x830cec10
	ctx.lr = 0x830E2514;
	sub_830CEC10(ctx, base);
	// 830E2514: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E2518: 4BFF36B1  bl 0x830d5bc8
	ctx.lr = 0x830E251C;
	sub_830D5BC8(ctx, base);
	// 830E251C: 2B180004  cmplwi cr6, r24, 4
	ctx.cr[6].compare_u32(ctx.r[24].u32, 4 as u32, &mut ctx.xer);
	// 830E2520: 409A0010  bne cr6, 0x830e2530
	if !ctx.cr[6].eq {
	pc = 0x830E2530; continue 'dispatch;
	}
	// 830E2524: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830E2528: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830E252C: 4BFFE6BD  bl 0x830e0be8
	ctx.lr = 0x830E2530;
	sub_830E0BE8(ctx, base);
	// 830E2530: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830E2534: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 830E2538: 409A000C  bne cr6, 0x830e2544
	if !ctx.cr[6].eq {
	pc = 0x830E2544; continue 'dispatch;
	}
	// 830E253C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830E2540: 4BFF72E9  bl 0x830d9828
	ctx.lr = 0x830E2544;
	sub_830D9828(ctx, base);
	// 830E2544: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 830E2548: 480C5C60  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E2550(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E2550 size=548
    let mut pc: u32 = 0x830E2550;
    'dispatch: loop {
        match pc {
            0x830E2550 => {
    //   block [0x830E2550..0x830E2774)
	// 830E2550: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E2554: 480C5C05  bl 0x831a8158
	ctx.lr = 0x830E2558;
	sub_831A8130(ctx, base);
	// 830E2558: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E255C: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 830E2560: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830E2564: 573A063E  clrlwi r26, r25, 0x18
	ctx.r[26].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	// 830E2568: 2B1A0004  cmplwi cr6, r26, 4
	ctx.cr[6].compare_u32(ctx.r[26].u32, 4 as u32, &mut ctx.xer);
	// 830E256C: 41980018  blt cr6, 0x830e2584
	if ctx.cr[6].lt {
	pc = 0x830E2584; continue 'dispatch;
	}
	// 830E2570: 2B1A00FF  cmplwi cr6, r26, 0xff
	ctx.cr[6].compare_u32(ctx.r[26].u32, 255 as u32, &mut ctx.xer);
	// 830E2574: 419A0010  beq cr6, 0x830e2584
	if ctx.cr[6].eq {
	pc = 0x830E2584; continue 'dispatch;
	}
	// 830E2578: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 830E257C: 60630057  ori r3, r3, 0x57
	ctx.r[3].u64 = ctx.r[3].u64 | 87;
	// 830E2580: 480001EC  b 0x830e276c
	pc = 0x830E276C; continue 'dispatch;
	// 830E2584: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830E2588: 3D408339  lis r10, -0x7cc7
	ctx.r[10].s64 = -2093416448;
	// 830E258C: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 830E2590: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 830E2594: 3B8BD848  addi r28, r11, -0x27b8
	ctx.r[28].s64 = ctx.r[11].s64 + -10168;
	// 830E2598: 3B6AD84C  addi r27, r10, -0x27b4
	ctx.r[27].s64 = ctx.r[10].s64 + -10164;
	// 830E259C: 419A005C  beq cr6, 0x830e25f8
	if ctx.cr[6].eq {
	pc = 0x830E25F8; continue 'dispatch;
	}
	// 830E25A0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830E25A4: 4BFEC66D  bl 0x830cec10
	ctx.lr = 0x830E25A8;
	sub_830CEC10(ctx, base);
	// 830E25A8: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830E25AC: 4182004C  beq 0x830e25f8
	if ctx.cr[0].eq {
	pc = 0x830E25F8; continue 'dispatch;
	}
	// 830E25B0: 2B1A00FF  cmplwi cr6, r26, 0xff
	ctx.cr[6].compare_u32(ctx.r[26].u32, 255 as u32, &mut ctx.xer);
	// 830E25B4: 419A0044  beq cr6, 0x830e25f8
	if ctx.cr[6].eq {
	pc = 0x830E25F8; continue 'dispatch;
	}
	// 830E25B8: 7F0AC378  mr r10, r24
	ctx.r[10].u64 = ctx.r[24].u64;
	// 830E25BC: 554B063E  clrlwi r11, r10, 0x18
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 830E25C0: 2B0B00FF  cmplwi cr6, r11, 0xff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 255 as u32, &mut ctx.xer);
	// 830E25C4: 409A000C  bne cr6, 0x830e25d0
	if !ctx.cr[6].eq {
	pc = 0x830E25D0; continue 'dispatch;
	}
	// 830E25C8: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 830E25CC: 4800000C  b 0x830e25d8
	pc = 0x830E25D8; continue 'dispatch;
	// 830E25D0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830E25D4: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 830E25D8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E25DC: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 830E25E0: 409A000C  bne cr6, 0x830e25ec
	if !ctx.cr[6].eq {
	pc = 0x830E25EC; continue 'dispatch;
	}
	// 830E25E4: 7F0AD040  cmplw cr6, r10, r26
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[26].u32, &mut ctx.xer);
	// 830E25E8: 409AFF90  bne cr6, 0x830e2578
	if !ctx.cr[6].eq {
	pc = 0x830E2578; continue 'dispatch;
	}
	// 830E25EC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830E25F0: 2B0A0004  cmplwi cr6, r10, 4
	ctx.cr[6].compare_u32(ctx.r[10].u32, 4 as u32, &mut ctx.xer);
	// 830E25F4: 4198FFC8  blt cr6, 0x830e25bc
	if ctx.cr[6].lt {
	pc = 0x830E25BC; continue 'dispatch;
	}
	// 830E25F8: 2B1A0004  cmplwi cr6, r26, 4
	ctx.cr[6].compare_u32(ctx.r[26].u32, 4 as u32, &mut ctx.xer);
	// 830E25FC: 40980040  bge cr6, 0x830e263c
	if !ctx.cr[6].lt {
	pc = 0x830E263C; continue 'dispatch;
	}
	// 830E2600: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 830E2604: 419A00BC  beq cr6, 0x830e26c0
	if ctx.cr[6].eq {
	pc = 0x830E26C0; continue 'dispatch;
	}
	// 830E2608: 3D008334  lis r8, -0x7ccc
	ctx.r[8].s64 = -2093744128;
	// 830E260C: 813C0000  lwz r9, 0(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E2610: 3CE08339  lis r7, -0x7cc7
	ctx.r[7].s64 = -2093416448;
	// 830E2614: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 830E2618: 7F0AC378  mr r10, r24
	ctx.r[10].u64 = ctx.r[24].u64;
	// 830E261C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 830E2620: 916856F0  stw r11, 0x56f0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(22256 as u32), ctx.r[11].u32 ) };
	// 830E2624: 9147D800  stw r10, -0x2800(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(-10240 as u32), ctx.r[10].u32 ) };
	// 830E2628: 419A006C  beq cr6, 0x830e2694
	if ctx.cr[6].eq {
	pc = 0x830E2694; continue 'dispatch;
	}
	// 830E262C: 388000FF  li r4, 0xff
	ctx.r[4].s64 = 255;
	// 830E2630: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E2634: 4BFFFF1D  bl 0x830e2550
	ctx.lr = 0x830E2638;
	sub_830E2550(ctx, base);
	// 830E2638: 4800005C  b 0x830e2694
	pc = 0x830E2694; continue 'dispatch;
	// 830E263C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 830E2640: 419A0080  beq cr6, 0x830e26c0
	if ctx.cr[6].eq {
	pc = 0x830E26C0; continue 'dispatch;
	}
	// 830E2644: 3D408334  lis r10, -0x7ccc
	ctx.r[10].s64 = -2093744128;
	// 830E2648: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830E264C: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 830E2650: 7F1FC378  mr r31, r24
	ctx.r[31].u64 = ctx.r[24].u64;
	// 830E2654: 916A56F0  stw r11, 0x56f0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(22256 as u32), ctx.r[11].u32 ) };
	// 830E2658: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830E265C: 3BCBD804  addi r30, r11, -0x27fc
	ctx.r[30].s64 = ctx.r[11].s64 + -10236;
	// 830E2660: 57EB103A  slwi r11, r31, 2
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830E2664: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 830E2668: 7F0BF12E  stwx r24, r11, r30
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32), ctx.r[24].u32) };
	// 830E266C: 4BFFC7CD  bl 0x830dee38
	ctx.lr = 0x830E2670;
	sub_830DEE38(ctx, base);
	// 830E2670: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830E2674: 4182000C  beq 0x830e2680
	if ctx.cr[0].eq {
	pc = 0x830E2680; continue 'dispatch;
	}
	// 830E2678: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E267C: 4BFFFED5  bl 0x830e2550
	ctx.lr = 0x830E2680;
	sub_830E2550(ctx, base);
	// 830E2680: 397F0001  addi r11, r31, 1
	ctx.r[11].s64 = ctx.r[31].s64 + 1;
	// 830E2684: 5564063E  clrlwi r4, r11, 0x18
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 830E2688: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830E268C: 2B040004  cmplwi cr6, r4, 4
	ctx.cr[6].compare_u32(ctx.r[4].u32, 4 as u32, &mut ctx.xer);
	// 830E2690: 4198FFD0  blt cr6, 0x830e2660
	if ctx.cr[6].lt {
	pc = 0x830E2660; continue 'dispatch;
	}
	// 830E2694: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E2698: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830E269C: 4BFFECED  bl 0x830e1388
	ctx.lr = 0x830E26A0;
	sub_830E1388(ctx, base);
	// 830E26A0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E26A4: 418000C8  blt 0x830e276c
	if ctx.cr[0].lt {
	pc = 0x830E276C; continue 'dispatch;
	}
	// 830E26A8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E26AC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E26B0: 409A0010  bne cr6, 0x830e26c0
	if !ctx.cr[6].eq {
	pc = 0x830E26C0; continue 'dispatch;
	}
	// 830E26B4: 3C608030  lis r3, -0x7fd0
	ctx.r[3].s64 = -2144337920;
	// 830E26B8: 60630014  ori r3, r3, 0x14
	ctx.r[3].u64 = ctx.r[3].u64 | 20;
	// 830E26BC: 480000B0  b 0x830e276c
	pc = 0x830E276C; continue 'dispatch;
	// 830E26C0: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 830E26C4: 4BFFC775  bl 0x830dee38
	ctx.lr = 0x830E26C8;
	sub_830DEE38(ctx, base);
	// 830E26C8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830E26CC: 41820024  beq 0x830e26f0
	if ctx.cr[0].eq {
	pc = 0x830E26F0; continue 'dispatch;
	}
	// 830E26D0: 7F26CB78  mr r6, r25
	ctx.r[6].u64 = ctx.r[25].u64;
	// 830E26D4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830E26D8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E26DC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830E26E0: 4BFFDE61  bl 0x830e0540
	ctx.lr = 0x830E26E4;
	sub_830E0540(ctx, base);
	// 830E26E4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830E26E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E26EC: 4BFF34DD  bl 0x830d5bc8
	ctx.lr = 0x830E26F0;
	sub_830D5BC8(ctx, base);
	// 830E26F0: 2B1A00FF  cmplwi cr6, r26, 0xff
	ctx.cr[6].compare_u32(ctx.r[26].u32, 255 as u32, &mut ctx.xer);
	// 830E26F4: 409A000C  bne cr6, 0x830e2700
	if !ctx.cr[6].eq {
	pc = 0x830E2700; continue 'dispatch;
	}
	// 830E26F8: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 830E26FC: 4800000C  b 0x830e2708
	pc = 0x830E2708; continue 'dispatch;
	// 830E2700: 574B103A  slwi r11, r26, 2
	ctx.r[11].u32 = ctx.r[26].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830E2704: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 830E2708: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 830E270C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 830E2710: 419A0058  beq cr6, 0x830e2768
	if ctx.cr[6].eq {
	pc = 0x830E2768; continue 'dispatch;
	}
	// 830E2714: 7F26CB78  mr r6, r25
	ctx.r[6].u64 = ctx.r[25].u64;
	// 830E2718: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830E271C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E2720: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830E2724: 4BFFDE5D  bl 0x830e0580
	ctx.lr = 0x830E2728;
	sub_830E0580(ctx, base);
	// 830E2728: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830E272C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830E2730: 4BFF3499  bl 0x830d5bc8
	ctx.lr = 0x830E2734;
	sub_830D5BC8(ctx, base);
	// 830E2734: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 830E2738: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E273C: 409A002C  bne cr6, 0x830e2768
	if !ctx.cr[6].eq {
	pc = 0x830E2768; continue 'dispatch;
	}
	// 830E2740: 2B1A00FF  cmplwi cr6, r26, 0xff
	ctx.cr[6].compare_u32(ctx.r[26].u32, 255 as u32, &mut ctx.xer);
	// 830E2744: 409A000C  bne cr6, 0x830e2750
	if !ctx.cr[6].eq {
	pc = 0x830E2750; continue 'dispatch;
	}
	// 830E2748: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 830E274C: 4800000C  b 0x830e2758
	pc = 0x830E2758; continue 'dispatch;
	// 830E2750: 574B103A  slwi r11, r26, 2
	ctx.r[11].u32 = ctx.r[26].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830E2754: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 830E2758: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 830E275C: 930B0000  stw r24, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 830E2760: 60634005  ori r3, r3, 0x4005
	ctx.r[3].u64 = ctx.r[3].u64 | 16389;
	// 830E2764: 48000008  b 0x830e276c
	pc = 0x830E276C; continue 'dispatch;
	// 830E2768: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E276C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 830E2770: 480C5A38  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E2778(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E2778 size=104
    let mut pc: u32 = 0x830E2778;
    'dispatch: loop {
        match pc {
            0x830E2778 => {
    //   block [0x830E2778..0x830E27E0)
	// 830E2778: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E277C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E2780: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E2784: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E2788: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E278C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E2790: 4BFFEBF9  bl 0x830e1388
	ctx.lr = 0x830E2794;
	sub_830E1388(ctx, base);
	// 830E2794: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E2798: 41800030  blt 0x830e27c8
	if ctx.cr[0].lt {
	pc = 0x830E27C8; continue 'dispatch;
	}
	// 830E279C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E27A0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E27A4: 419A0024  beq cr6, 0x830e27c8
	if ctx.cr[6].eq {
	pc = 0x830E27C8; continue 'dispatch;
	}
	// 830E27A8: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830E27AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E27B0: 808BC078  lwz r4, -0x3f88(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16264 as u32) ) } as u64;
	// 830E27B4: 4BFFC335  bl 0x830deae8
	ctx.lr = 0x830E27B8;
	sub_830DEAE8(ctx, base);
	// 830E27B8: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 830E27BC: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830E27C0: 69630001  xori r3, r11, 1
	ctx.r[3].u64 = ctx.r[11].u64 ^ 1;
	// 830E27C4: 48000008  b 0x830e27cc
	pc = 0x830E27CC; continue 'dispatch;
	// 830E27C8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E27CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E27D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E27D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E27D8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E27DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E27E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E27E0 size=248
    let mut pc: u32 = 0x830E27E0;
    'dispatch: loop {
        match pc {
            0x830E27E0 => {
    //   block [0x830E27E0..0x830E28D8)
	// 830E27E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E27E4: 480C5985  bl 0x831a8168
	ctx.lr = 0x830E27E8;
	sub_831A8130(ctx, base);
	// 830E27E8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E27EC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830E27F0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E27F4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 830E27F8: 4BFFCFD9  bl 0x830df7d0
	ctx.lr = 0x830E27FC;
	sub_830DF7D0(ctx, base);
	// 830E27FC: 480000B0  b 0x830e28ac
	pc = 0x830E28AC; continue 'dispatch;
	// 830E2800: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830E2804: 419A0014  beq cr6, 0x830e2818
	if ctx.cr[6].eq {
	pc = 0x830E2818; continue 'dispatch;
	}
	// 830E2808: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E280C: 4BFFE275  bl 0x830e0a80
	ctx.lr = 0x830E2810;
	sub_830E0A80(ctx, base);
	// 830E2810: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E2814: 4182008C  beq 0x830e28a0
	if ctx.cr[0].eq {
	pc = 0x830E28A0; continue 'dispatch;
	}
	// 830E2818: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830E281C: 419A0014  beq cr6, 0x830e2830
	if ctx.cr[6].eq {
	pc = 0x830E2830; continue 'dispatch;
	}
	// 830E2820: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E2824: 4BFFE37D  bl 0x830e0ba0
	ctx.lr = 0x830E2828;
	sub_830E0BA0(ctx, base);
	// 830E2828: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E282C: 41820074  beq 0x830e28a0
	if ctx.cr[0].eq {
	pc = 0x830E28A0; continue 'dispatch;
	}
	// 830E2830: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830E2834: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E2838: 4BFFE291  bl 0x830e0ac8
	ctx.lr = 0x830E283C;
	sub_830E0AC8(ctx, base);
	// 830E283C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E2840: 40820060  bne 0x830e28a0
	if !ctx.cr[0].eq {
	pc = 0x830E28A0; continue 'dispatch;
	}
	// 830E2844: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E2848: 4BFEC3C9  bl 0x830cec10
	ctx.lr = 0x830E284C;
	sub_830CEC10(ctx, base);
	// 830E284C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 830E2850: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 830E2854: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830E2858: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830E285C: 4BFFE0B5  bl 0x830e0910
	ctx.lr = 0x830E2860;
	sub_830E0910(ctx, base);
	// 830E2860: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E2864: 3B810070  addi r28, r1, 0x70
	ctx.r[28].s64 = ctx.r[1].s64 + 112;
	// 830E2868: 4BFEC3A9  bl 0x830cec10
	ctx.lr = 0x830E286C;
	sub_830CEC10(ctx, base);
	// 830E286C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830E2870: 4BFF3359  bl 0x830d5bc8
	ctx.lr = 0x830E2874;
	sub_830D5BC8(ctx, base);
	// 830E2874: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 830E2878: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E287C: 419A0010  beq cr6, 0x830e288c
	if ctx.cr[6].eq {
	pc = 0x830E288C; continue 'dispatch;
	}
	// 830E2880: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 830E2884: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E2888: 419A003C  beq cr6, 0x830e28c4
	if ctx.cr[6].eq {
	pc = 0x830E28C4; continue 'dispatch;
	}
	// 830E288C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E2890: 4BFEC381  bl 0x830cec10
	ctx.lr = 0x830E2894;
	sub_830CEC10(ctx, base);
	// 830E2894: 4BFFFEE5  bl 0x830e2778
	ctx.lr = 0x830E2898;
	sub_830E2778(ctx, base);
	// 830E2898: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E289C: 40820030  bne 0x830e28cc
	if !ctx.cr[0].eq {
	pc = 0x830E28CC; continue 'dispatch;
	}
	// 830E28A0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E28A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E28A8: 4BFFD019  bl 0x830df8c0
	ctx.lr = 0x830E28AC;
	sub_830DF8C0(ctx, base);
	// 830E28AC: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E28B0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830E28B4: 409AFF4C  bne cr6, 0x830e2800
	if !ctx.cr[6].eq {
	pc = 0x830E2800; continue 'dispatch;
	}
	// 830E28B8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E28BC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 830E28C0: 480C58F8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
	// 830E28C4: 80610068  lwz r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 830E28C8: 4BFFFFF4  b 0x830e28bc
	pc = 0x830E28BC; continue 'dispatch;
	// 830E28CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E28D0: 4BFEC341  bl 0x830cec10
	ctx.lr = 0x830E28D4;
	sub_830CEC10(ctx, base);
	// 830E28D4: 4BFFFFE8  b 0x830e28bc
	pc = 0x830E28BC; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E28D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E28D8 size=248
    let mut pc: u32 = 0x830E28D8;
    'dispatch: loop {
        match pc {
            0x830E28D8 => {
    //   block [0x830E28D8..0x830E29D0)
	// 830E28D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E28DC: 480C588D  bl 0x831a8168
	ctx.lr = 0x830E28E0;
	sub_831A8130(ctx, base);
	// 830E28E0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E28E4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830E28E8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E28EC: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 830E28F0: 4BFFCF59  bl 0x830df848
	ctx.lr = 0x830E28F4;
	sub_830DF848(ctx, base);
	// 830E28F4: 480000B0  b 0x830e29a4
	pc = 0x830E29A4; continue 'dispatch;
	// 830E28F8: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830E28FC: 419A0014  beq cr6, 0x830e2910
	if ctx.cr[6].eq {
	pc = 0x830E2910; continue 'dispatch;
	}
	// 830E2900: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E2904: 4BFFE17D  bl 0x830e0a80
	ctx.lr = 0x830E2908;
	sub_830E0A80(ctx, base);
	// 830E2908: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E290C: 4182008C  beq 0x830e2998
	if ctx.cr[0].eq {
	pc = 0x830E2998; continue 'dispatch;
	}
	// 830E2910: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830E2914: 419A0014  beq cr6, 0x830e2928
	if ctx.cr[6].eq {
	pc = 0x830E2928; continue 'dispatch;
	}
	// 830E2918: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E291C: 4BFFE285  bl 0x830e0ba0
	ctx.lr = 0x830E2920;
	sub_830E0BA0(ctx, base);
	// 830E2920: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E2924: 41820074  beq 0x830e2998
	if ctx.cr[0].eq {
	pc = 0x830E2998; continue 'dispatch;
	}
	// 830E2928: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830E292C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E2930: 4BFFE199  bl 0x830e0ac8
	ctx.lr = 0x830E2934;
	sub_830E0AC8(ctx, base);
	// 830E2934: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E2938: 40820060  bne 0x830e2998
	if !ctx.cr[0].eq {
	pc = 0x830E2998; continue 'dispatch;
	}
	// 830E293C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E2940: 4BFEC2D1  bl 0x830cec10
	ctx.lr = 0x830E2944;
	sub_830CEC10(ctx, base);
	// 830E2944: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 830E2948: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 830E294C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830E2950: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830E2954: 4BFFDFBD  bl 0x830e0910
	ctx.lr = 0x830E2958;
	sub_830E0910(ctx, base);
	// 830E2958: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E295C: 3B810070  addi r28, r1, 0x70
	ctx.r[28].s64 = ctx.r[1].s64 + 112;
	// 830E2960: 4BFEC2B1  bl 0x830cec10
	ctx.lr = 0x830E2964;
	sub_830CEC10(ctx, base);
	// 830E2964: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830E2968: 4BFF3261  bl 0x830d5bc8
	ctx.lr = 0x830E296C;
	sub_830D5BC8(ctx, base);
	// 830E296C: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 830E2970: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E2974: 419A0010  beq cr6, 0x830e2984
	if ctx.cr[6].eq {
	pc = 0x830E2984; continue 'dispatch;
	}
	// 830E2978: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 830E297C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E2980: 419A003C  beq cr6, 0x830e29bc
	if ctx.cr[6].eq {
	pc = 0x830E29BC; continue 'dispatch;
	}
	// 830E2984: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E2988: 4BFEC289  bl 0x830cec10
	ctx.lr = 0x830E298C;
	sub_830CEC10(ctx, base);
	// 830E298C: 4BFFFDED  bl 0x830e2778
	ctx.lr = 0x830E2990;
	sub_830E2778(ctx, base);
	// 830E2990: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E2994: 40820030  bne 0x830e29c4
	if !ctx.cr[0].eq {
	pc = 0x830E29C4; continue 'dispatch;
	}
	// 830E2998: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E299C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E29A0: 4BFFCF99  bl 0x830df938
	ctx.lr = 0x830E29A4;
	sub_830DF938(ctx, base);
	// 830E29A4: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E29A8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830E29AC: 409AFF4C  bne cr6, 0x830e28f8
	if !ctx.cr[6].eq {
	pc = 0x830E28F8; continue 'dispatch;
	}
	// 830E29B0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E29B4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 830E29B8: 480C5800  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
	// 830E29BC: 80610068  lwz r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 830E29C0: 4BFFFFF4  b 0x830e29b4
	pc = 0x830E29B4; continue 'dispatch;
	// 830E29C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E29C8: 4BFEC249  bl 0x830cec10
	ctx.lr = 0x830E29CC;
	sub_830CEC10(ctx, base);
	// 830E29CC: 4BFFFFE8  b 0x830e29b4
	pc = 0x830E29B4; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E29D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E29D0 size=292
    let mut pc: u32 = 0x830E29D0;
    'dispatch: loop {
        match pc {
            0x830E29D0 => {
    //   block [0x830E29D0..0x830E2AF4)
	// 830E29D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E29D4: 480C5791  bl 0x831a8164
	ctx.lr = 0x830E29D8;
	sub_831A8130(ctx, base);
	// 830E29D8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E29DC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830E29E0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830E29E4: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 830E29E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E29EC: 480000A8  b 0x830e2a94
	pc = 0x830E2A94; continue 'dispatch;
	// 830E29F0: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 830E29F4: 419A0014  beq cr6, 0x830e2a08
	if ctx.cr[6].eq {
	pc = 0x830E2A08; continue 'dispatch;
	}
	// 830E29F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E29FC: 4BFFE085  bl 0x830e0a80
	ctx.lr = 0x830E2A00;
	sub_830E0A80(ctx, base);
	// 830E2A00: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E2A04: 4182008C  beq 0x830e2a90
	if ctx.cr[0].eq {
	pc = 0x830E2A90; continue 'dispatch;
	}
	// 830E2A08: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830E2A0C: 419A0014  beq cr6, 0x830e2a20
	if ctx.cr[6].eq {
	pc = 0x830E2A20; continue 'dispatch;
	}
	// 830E2A10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E2A14: 4BFFE18D  bl 0x830e0ba0
	ctx.lr = 0x830E2A18;
	sub_830E0BA0(ctx, base);
	// 830E2A18: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E2A1C: 41820074  beq 0x830e2a90
	if ctx.cr[0].eq {
	pc = 0x830E2A90; continue 'dispatch;
	}
	// 830E2A20: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830E2A24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E2A28: 4BFFE0A1  bl 0x830e0ac8
	ctx.lr = 0x830E2A2C;
	sub_830E0AC8(ctx, base);
	// 830E2A2C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E2A30: 40820060  bne 0x830e2a90
	if !ctx.cr[0].eq {
	pc = 0x830E2A90; continue 'dispatch;
	}
	// 830E2A34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E2A38: 4BFEC1D9  bl 0x830cec10
	ctx.lr = 0x830E2A3C;
	sub_830CEC10(ctx, base);
	// 830E2A3C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 830E2A40: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 830E2A44: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830E2A48: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830E2A4C: 4BFFDEC5  bl 0x830e0910
	ctx.lr = 0x830E2A50;
	sub_830E0910(ctx, base);
	// 830E2A50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E2A54: 3B610070  addi r27, r1, 0x70
	ctx.r[27].s64 = ctx.r[1].s64 + 112;
	// 830E2A58: 4BFEC1B9  bl 0x830cec10
	ctx.lr = 0x830E2A5C;
	sub_830CEC10(ctx, base);
	// 830E2A5C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830E2A60: 4BFF3169  bl 0x830d5bc8
	ctx.lr = 0x830E2A64;
	sub_830D5BC8(ctx, base);
	// 830E2A64: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 830E2A68: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E2A6C: 419A0010  beq cr6, 0x830e2a7c
	if ctx.cr[6].eq {
	pc = 0x830E2A7C; continue 'dispatch;
	}
	// 830E2A70: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 830E2A74: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E2A78: 419A0050  beq cr6, 0x830e2ac8
	if ctx.cr[6].eq {
	pc = 0x830E2AC8; continue 'dispatch;
	}
	// 830E2A7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E2A80: 4BFEC191  bl 0x830cec10
	ctx.lr = 0x830E2A84;
	sub_830CEC10(ctx, base);
	// 830E2A84: 4BFFFCF5  bl 0x830e2778
	ctx.lr = 0x830E2A88;
	sub_830E2778(ctx, base);
	// 830E2A88: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E2A8C: 40820044  bne 0x830e2ad0
	if !ctx.cr[0].eq {
	pc = 0x830E2AD0; continue 'dispatch;
	}
	// 830E2A90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E2A94: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E2A98: 4BFFCE29  bl 0x830df8c0
	ctx.lr = 0x830E2A9C;
	sub_830DF8C0(ctx, base);
	// 830E2A9C: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E2AA0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830E2AA4: 409AFF4C  bne cr6, 0x830e29f0
	if !ctx.cr[6].eq {
	pc = 0x830E29F0; continue 'dispatch;
	}
	// 830E2AA8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E2AAC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E2AB0: 4BFFCCA9  bl 0x830df758
	ctx.lr = 0x830E2AB4;
	sub_830DF758(ctx, base);
	// 830E2AB4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E2AB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830E2ABC: 419A0020  beq cr6, 0x830e2adc
	if ctx.cr[6].eq {
	pc = 0x830E2ADC; continue 'dispatch;
	}
	// 830E2AC0: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 830E2AC4: 4BFFFF24  b 0x830e29e8
	pc = 0x830E29E8; continue 'dispatch;
	// 830E2AC8: 80610068  lwz r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 830E2ACC: 48000020  b 0x830e2aec
	pc = 0x830E2AEC; continue 'dispatch;
	// 830E2AD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E2AD4: 4BFEC13D  bl 0x830cec10
	ctx.lr = 0x830E2AD8;
	sub_830CEC10(ctx, base);
	// 830E2AD8: 48000014  b 0x830e2aec
	pc = 0x830E2AEC; continue 'dispatch;
	// 830E2ADC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 830E2AE0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830E2AE4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E2AE8: 4BFFFCF9  bl 0x830e27e0
	ctx.lr = 0x830E2AEC;
	sub_830E27E0(ctx, base);
	// 830E2AEC: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 830E2AF0: 480C56C4  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E2AF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E2AF8 size=292
    let mut pc: u32 = 0x830E2AF8;
    'dispatch: loop {
        match pc {
            0x830E2AF8 => {
    //   block [0x830E2AF8..0x830E2C1C)
	// 830E2AF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E2AFC: 480C5669  bl 0x831a8164
	ctx.lr = 0x830E2B00;
	sub_831A8130(ctx, base);
	// 830E2B00: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E2B04: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830E2B08: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830E2B0C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 830E2B10: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E2B14: 480000A8  b 0x830e2bbc
	pc = 0x830E2BBC; continue 'dispatch;
	// 830E2B18: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 830E2B1C: 419A0014  beq cr6, 0x830e2b30
	if ctx.cr[6].eq {
	pc = 0x830E2B30; continue 'dispatch;
	}
	// 830E2B20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E2B24: 4BFFDF5D  bl 0x830e0a80
	ctx.lr = 0x830E2B28;
	sub_830E0A80(ctx, base);
	// 830E2B28: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E2B2C: 4182008C  beq 0x830e2bb8
	if ctx.cr[0].eq {
	pc = 0x830E2BB8; continue 'dispatch;
	}
	// 830E2B30: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830E2B34: 419A0014  beq cr6, 0x830e2b48
	if ctx.cr[6].eq {
	pc = 0x830E2B48; continue 'dispatch;
	}
	// 830E2B38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E2B3C: 4BFFE065  bl 0x830e0ba0
	ctx.lr = 0x830E2B40;
	sub_830E0BA0(ctx, base);
	// 830E2B40: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E2B44: 41820074  beq 0x830e2bb8
	if ctx.cr[0].eq {
	pc = 0x830E2BB8; continue 'dispatch;
	}
	// 830E2B48: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830E2B4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E2B50: 4BFFDF79  bl 0x830e0ac8
	ctx.lr = 0x830E2B54;
	sub_830E0AC8(ctx, base);
	// 830E2B54: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E2B58: 40820060  bne 0x830e2bb8
	if !ctx.cr[0].eq {
	pc = 0x830E2BB8; continue 'dispatch;
	}
	// 830E2B5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E2B60: 4BFEC0B1  bl 0x830cec10
	ctx.lr = 0x830E2B64;
	sub_830CEC10(ctx, base);
	// 830E2B64: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 830E2B68: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 830E2B6C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830E2B70: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830E2B74: 4BFFDD9D  bl 0x830e0910
	ctx.lr = 0x830E2B78;
	sub_830E0910(ctx, base);
	// 830E2B78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E2B7C: 3B610070  addi r27, r1, 0x70
	ctx.r[27].s64 = ctx.r[1].s64 + 112;
	// 830E2B80: 4BFEC091  bl 0x830cec10
	ctx.lr = 0x830E2B84;
	sub_830CEC10(ctx, base);
	// 830E2B84: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830E2B88: 4BFF3041  bl 0x830d5bc8
	ctx.lr = 0x830E2B8C;
	sub_830D5BC8(ctx, base);
	// 830E2B8C: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 830E2B90: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E2B94: 419A0010  beq cr6, 0x830e2ba4
	if ctx.cr[6].eq {
	pc = 0x830E2BA4; continue 'dispatch;
	}
	// 830E2B98: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 830E2B9C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E2BA0: 419A0050  beq cr6, 0x830e2bf0
	if ctx.cr[6].eq {
	pc = 0x830E2BF0; continue 'dispatch;
	}
	// 830E2BA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E2BA8: 4BFEC069  bl 0x830cec10
	ctx.lr = 0x830E2BAC;
	sub_830CEC10(ctx, base);
	// 830E2BAC: 4BFFFBCD  bl 0x830e2778
	ctx.lr = 0x830E2BB0;
	sub_830E2778(ctx, base);
	// 830E2BB0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E2BB4: 40820044  bne 0x830e2bf8
	if !ctx.cr[0].eq {
	pc = 0x830E2BF8; continue 'dispatch;
	}
	// 830E2BB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E2BBC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E2BC0: 4BFFCD79  bl 0x830df938
	ctx.lr = 0x830E2BC4;
	sub_830DF938(ctx, base);
	// 830E2BC4: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E2BC8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830E2BCC: 409AFF4C  bne cr6, 0x830e2b18
	if !ctx.cr[6].eq {
	pc = 0x830E2B18; continue 'dispatch;
	}
	// 830E2BD0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E2BD4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E2BD8: 4BFFCB81  bl 0x830df758
	ctx.lr = 0x830E2BDC;
	sub_830DF758(ctx, base);
	// 830E2BDC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E2BE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830E2BE4: 419A0020  beq cr6, 0x830e2c04
	if ctx.cr[6].eq {
	pc = 0x830E2C04; continue 'dispatch;
	}
	// 830E2BE8: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 830E2BEC: 4BFFFF24  b 0x830e2b10
	pc = 0x830E2B10; continue 'dispatch;
	// 830E2BF0: 80610068  lwz r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 830E2BF4: 48000020  b 0x830e2c14
	pc = 0x830E2C14; continue 'dispatch;
	// 830E2BF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E2BFC: 4BFEC015  bl 0x830cec10
	ctx.lr = 0x830E2C00;
	sub_830CEC10(ctx, base);
	// 830E2C00: 48000014  b 0x830e2c14
	pc = 0x830E2C14; continue 'dispatch;
	// 830E2C04: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 830E2C08: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830E2C0C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E2C10: 4BFFFCC9  bl 0x830e28d8
	ctx.lr = 0x830E2C14;
	sub_830E28D8(ctx, base);
	// 830E2C14: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 830E2C18: 480C559C  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E2C20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830E2C20 size=4
    let mut pc: u32 = 0x830E2C20;
    'dispatch: loop {
        match pc {
            0x830E2C20 => {
    //   block [0x830E2C20..0x830E2C24)
	// 830E2C20: 4BFFF930  b 0x830e2550
	sub_830E2550(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E2C28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E2C28 size=108
    let mut pc: u32 = 0x830E2C28;
    'dispatch: loop {
        match pc {
            0x830E2C28 => {
    //   block [0x830E2C28..0x830E2C94)
	// 830E2C28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E2C2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E2C30: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E2C34: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 830E2C38: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 830E2C3C: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 830E2C40: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830E2C44: 409A000C  bne cr6, 0x830e2c50
	if !ctx.cr[6].eq {
	pc = 0x830E2C50; continue 'dispatch;
	}
	// 830E2C48: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E2C4C: 48000038  b 0x830e2c84
	pc = 0x830E2C84; continue 'dispatch;
	// 830E2C50: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830E2C54: 4198002C  blt cr6, 0x830e2c80
	if ctx.cr[6].lt {
	pc = 0x830E2C80; continue 'dispatch;
	}
	// 830E2C58: 419A0020  beq cr6, 0x830e2c78
	if ctx.cr[6].eq {
	pc = 0x830E2C78; continue 'dispatch;
	}
	// 830E2C5C: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 830E2C60: 41980010  blt cr6, 0x830e2c70
	if ctx.cr[6].lt {
	pc = 0x830E2C70; continue 'dispatch;
	}
	// 830E2C64: 409AFFE4  bne cr6, 0x830e2c48
	if !ctx.cr[6].eq {
	pc = 0x830E2C48; continue 'dispatch;
	}
	// 830E2C68: 4BFFFC71  bl 0x830e28d8
	ctx.lr = 0x830E2C6C;
	sub_830E28D8(ctx, base);
	// 830E2C6C: 48000018  b 0x830e2c84
	pc = 0x830E2C84; continue 'dispatch;
	// 830E2C70: 4BFFFB71  bl 0x830e27e0
	ctx.lr = 0x830E2C74;
	sub_830E27E0(ctx, base);
	// 830E2C74: 48000010  b 0x830e2c84
	pc = 0x830E2C84; continue 'dispatch;
	// 830E2C78: 4BFFFE81  bl 0x830e2af8
	ctx.lr = 0x830E2C7C;
	sub_830E2AF8(ctx, base);
	// 830E2C7C: 48000008  b 0x830e2c84
	pc = 0x830E2C84; continue 'dispatch;
	// 830E2C80: 4BFFFD51  bl 0x830e29d0
	ctx.lr = 0x830E2C84;
	sub_830E29D0(ctx, base);
	// 830E2C84: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830E2C88: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E2C8C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E2C90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E2C98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830E2C98 size=100
    let mut pc: u32 = 0x830E2C98;
    'dispatch: loop {
        match pc {
            0x830E2C98 => {
    //   block [0x830E2C98..0x830E2CFC)
	// 830E2C98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E2C9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E2CA0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E2CA4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E2CA8: 3D408339  lis r10, -0x7cc7
	ctx.r[10].s64 = -2093416448;
	// 830E2CAC: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830E2CB0: 3BEBD85C  addi r31, r11, -0x27a4
	ctx.r[31].s64 = ctx.r[11].s64 + -10148;
	// 830E2CB4: 816AD870  lwz r11, -0x2790(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10128 as u32) ) } as u64;
	// 830E2CB8: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830E2CBC: 40820028  bne 0x830e2ce4
	if !ctx.cr[0].eq {
	pc = 0x830E2CE4; continue 'dispatch;
	}
	// 830E2CC0: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 830E2CC4: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 830E2CC8: 916AD870  stw r11, -0x2790(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-10128 as u32), ctx.r[11].u32 ) };
	// 830E2CCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E2CD0: C02908A4  lfs f1, 0x8a4(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830E2CD4: 4801F815  bl 0x831024e8
	ctx.lr = 0x830E2CD8;
	sub_831024E8(ctx, base);
	// 830E2CD8: 3D608324  lis r11, -0x7cdc
	ctx.r[11].s64 = -2094792704;
	// 830E2CDC: 386B2400  addi r3, r11, 0x2400
	ctx.r[3].s64 = ctx.r[11].s64 + 9216;
	// 830E2CE0: 480C57F9  bl 0x831a84d8
	ctx.lr = 0x830E2CE4;
	sub_831A84D8(ctx, base);
	// 830E2CE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E2CE8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830E2CEC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E2CF0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E2CF4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E2CF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E2D00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830E2D00 size=100
    let mut pc: u32 = 0x830E2D00;
    'dispatch: loop {
        match pc {
            0x830E2D00 => {
    //   block [0x830E2D00..0x830E2D64)
	// 830E2D00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E2D04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E2D08: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E2D0C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E2D10: 3D408339  lis r10, -0x7cc7
	ctx.r[10].s64 = -2093416448;
	// 830E2D14: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830E2D18: 3BEBD874  addi r31, r11, -0x278c
	ctx.r[31].s64 = ctx.r[11].s64 + -10124;
	// 830E2D1C: 816AD888  lwz r11, -0x2778(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10104 as u32) ) } as u64;
	// 830E2D20: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830E2D24: 40820028  bne 0x830e2d4c
	if !ctx.cr[0].eq {
	pc = 0x830E2D4C; continue 'dispatch;
	}
	// 830E2D28: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 830E2D2C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 830E2D30: 916AD888  stw r11, -0x2778(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-10104 as u32), ctx.r[11].u32 ) };
	// 830E2D34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E2D38: C02908A8  lfs f1, 0x8a8(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830E2D3C: 4801F7AD  bl 0x831024e8
	ctx.lr = 0x830E2D40;
	sub_831024E8(ctx, base);
	// 830E2D40: 3D608324  lis r11, -0x7cdc
	ctx.r[11].s64 = -2094792704;
	// 830E2D44: 386B2410  addi r3, r11, 0x2410
	ctx.r[3].s64 = ctx.r[11].s64 + 9232;
	// 830E2D48: 480C5791  bl 0x831a84d8
	ctx.lr = 0x830E2D4C;
	sub_831A84D8(ctx, base);
	// 830E2D4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E2D50: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830E2D54: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E2D58: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E2D5C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E2D60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E2D68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830E2D68 size=116
    let mut pc: u32 = 0x830E2D68;
    'dispatch: loop {
        match pc {
            0x830E2D68 => {
    //   block [0x830E2D68..0x830E2DDC)
	// 830E2D68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E2D6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E2D70: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E2D74: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E2D78: 3D408339  lis r10, -0x7cc7
	ctx.r[10].s64 = -2093416448;
	// 830E2D7C: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830E2D80: 3BEBD88C  addi r31, r11, -0x2774
	ctx.r[31].s64 = ctx.r[11].s64 + -10100;
	// 830E2D84: 816AD8A0  lwz r11, -0x2760(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10080 as u32) ) } as u64;
	// 830E2D88: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830E2D8C: 40820038  bne 0x830e2dc4
	if !ctx.cr[0].eq {
	pc = 0x830E2DC4; continue 'dispatch;
	}
	// 830E2D90: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 830E2D94: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 830E2D98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E2D9C: 916AD8A0  stw r11, -0x2760(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-10080 as u32), ctx.r[11].u32 ) };
	// 830E2DA0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E2DA4: C00908A4  lfs f0, 0x8a4(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E2DA8: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 830E2DAC: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 830E2DB0: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 830E2DB4: 4801F745  bl 0x831024f8
	ctx.lr = 0x830E2DB8;
	sub_831024F8(ctx, base);
	// 830E2DB8: 3D608324  lis r11, -0x7cdc
	ctx.r[11].s64 = -2094792704;
	// 830E2DBC: 386B2420  addi r3, r11, 0x2420
	ctx.r[3].s64 = ctx.r[11].s64 + 9248;
	// 830E2DC0: 480C5719  bl 0x831a84d8
	ctx.lr = 0x830E2DC4;
	sub_831A84D8(ctx, base);
	// 830E2DC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E2DC8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E2DCC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E2DD0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E2DD4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E2DD8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E2DE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830E2DE0 size=116
    let mut pc: u32 = 0x830E2DE0;
    'dispatch: loop {
        match pc {
            0x830E2DE0 => {
    //   block [0x830E2DE0..0x830E2E54)
	// 830E2DE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E2DE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E2DE8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E2DEC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E2DF0: 3D408339  lis r10, -0x7cc7
	ctx.r[10].s64 = -2093416448;
	// 830E2DF4: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830E2DF8: 3BEBD8A4  addi r31, r11, -0x275c
	ctx.r[31].s64 = ctx.r[11].s64 + -10076;
	// 830E2DFC: 816AD8B8  lwz r11, -0x2748(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10056 as u32) ) } as u64;
	// 830E2E00: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830E2E04: 40820038  bne 0x830e2e3c
	if !ctx.cr[0].eq {
	pc = 0x830E2E3C; continue 'dispatch;
	}
	// 830E2E08: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 830E2E0C: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 830E2E10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E2E14: 916AD8B8  stw r11, -0x2748(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-10056 as u32), ctx.r[11].u32 ) };
	// 830E2E18: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E2E1C: C00908A8  lfs f0, 0x8a8(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E2E20: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 830E2E24: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 830E2E28: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 830E2E2C: 4801F6CD  bl 0x831024f8
	ctx.lr = 0x830E2E30;
	sub_831024F8(ctx, base);
	// 830E2E30: 3D608324  lis r11, -0x7cdc
	ctx.r[11].s64 = -2094792704;
	// 830E2E34: 386B2430  addi r3, r11, 0x2430
	ctx.r[3].s64 = ctx.r[11].s64 + 9264;
	// 830E2E38: 480C56A1  bl 0x831a84d8
	ctx.lr = 0x830E2E3C;
	sub_831A84D8(ctx, base);
	// 830E2E3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E2E40: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E2E44: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E2E48: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E2E4C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E2E50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E2E58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830E2E58 size=128
    let mut pc: u32 = 0x830E2E58;
    'dispatch: loop {
        match pc {
            0x830E2E58 => {
    //   block [0x830E2E58..0x830E2ED8)
	// 830E2E58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E2E5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E2E60: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E2E64: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E2E68: 3D408339  lis r10, -0x7cc7
	ctx.r[10].s64 = -2093416448;
	// 830E2E6C: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830E2E70: 3BEBD8BC  addi r31, r11, -0x2744
	ctx.r[31].s64 = ctx.r[11].s64 + -10052;
	// 830E2E74: 816AD8D0  lwz r11, -0x2730(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10032 as u32) ) } as u64;
	// 830E2E78: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830E2E7C: 40820044  bne 0x830e2ec0
	if !ctx.cr[0].eq {
	pc = 0x830E2EC0; continue 'dispatch;
	}
	// 830E2E80: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 830E2E84: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 830E2E88: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 830E2E8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E2E90: 916AD8D0  stw r11, -0x2730(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-10032 as u32), ctx.r[11].u32 ) };
	// 830E2E94: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E2E98: C00908A4  lfs f0, 0x8a4(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E2E9C: C1A808A8  lfs f13, 0x8a8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830E2EA0: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 830E2EA4: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 830E2EA8: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 830E2EAC: D1A1005C  stfs f13, 0x5c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 830E2EB0: 4801FBE1  bl 0x83102a90
	ctx.lr = 0x830E2EB4;
	sub_83102A90(ctx, base);
	// 830E2EB4: 3D608324  lis r11, -0x7cdc
	ctx.r[11].s64 = -2094792704;
	// 830E2EB8: 386B2440  addi r3, r11, 0x2440
	ctx.r[3].s64 = ctx.r[11].s64 + 9280;
	// 830E2EBC: 480C561D  bl 0x831a84d8
	ctx.lr = 0x830E2EC0;
	sub_831A84D8(ctx, base);
	// 830E2EC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E2EC4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E2EC8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E2ECC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E2ED0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E2ED4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E2ED8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E2ED8 size=96
    let mut pc: u32 = 0x830E2ED8;
    'dispatch: loop {
        match pc {
            0x830E2ED8 => {
    //   block [0x830E2ED8..0x830E2F38)
	// 830E2ED8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E2EDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E2EE0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E2EE4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E2EE8: 3D408339  lis r10, -0x7cc7
	ctx.r[10].s64 = -2093416448;
	// 830E2EEC: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830E2EF0: 3BEBD8D4  addi r31, r11, -0x272c
	ctx.r[31].s64 = ctx.r[11].s64 + -10028;
	// 830E2EF4: 816AD8E8  lwz r11, -0x2718(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10008 as u32) ) } as u64;
	// 830E2EF8: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830E2EFC: 40820024  bne 0x830e2f20
	if !ctx.cr[0].eq {
	pc = 0x830E2F20; continue 'dispatch;
	}
	// 830E2F00: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 830E2F04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E2F08: 916AD8E8  stw r11, -0x2718(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-10008 as u32), ctx.r[11].u32 ) };
	// 830E2F0C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830E2F10: 4801F5C9  bl 0x831024d8
	ctx.lr = 0x830E2F14;
	sub_831024D8(ctx, base);
	// 830E2F14: 3D608324  lis r11, -0x7cdc
	ctx.r[11].s64 = -2094792704;
	// 830E2F18: 386B2450  addi r3, r11, 0x2450
	ctx.r[3].s64 = ctx.r[11].s64 + 9296;
	// 830E2F1C: 480C55BD  bl 0x831a84d8
	ctx.lr = 0x830E2F20;
	sub_831A84D8(ctx, base);
	// 830E2F20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E2F24: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830E2F28: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E2F2C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E2F30: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E2F34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E2F38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E2F38 size=120
    let mut pc: u32 = 0x830E2F38;
    'dispatch: loop {
        match pc {
            0x830E2F38 => {
    //   block [0x830E2F38..0x830E2FB0)
	// 830E2F38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E2F3C: 480C5231  bl 0x831a816c
	ctx.lr = 0x830E2F40;
	sub_831A8130(ctx, base);
	// 830E2F40: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E2F44: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830E2F48: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E2F4C: 3BABD7C4  addi r29, r11, -0x283c
	ctx.r[29].s64 = ctx.r[11].s64 + -10300;
	// 830E2F50: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830E2F54: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830E2F58: 4815FA15  bl 0x8324296c
	ctx.lr = 0x830E2F5C;
	// extern call 0x8324296C → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 830E2F5C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830E2F60: 409A0010  bne cr6, 0x830e2f70
	if !ctx.cr[6].eq {
	pc = 0x830E2F70; continue 'dispatch;
	}
	// 830E2F64: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830E2F68: 83CBD838  lwz r30, -0x27c8(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10184 as u32) ) } as u64;
	// 830E2F6C: 48000030  b 0x830e2f9c
	pc = 0x830E2F9C; continue 'dispatch;
	// 830E2F70: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830E2F74: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E2F78: 3BEBD818  addi r31, r11, -0x27e8
	ctx.r[31].s64 = ctx.r[11].s64 + -10216;
	// 830E2F7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E2F80: 4BFFADE1  bl 0x830ddd60
	ctx.lr = 0x830E2F84;
	sub_830DDD60(ctx, base);
	// 830E2F84: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 830E2F88: 419A0014  beq cr6, 0x830e2f9c
	if ctx.cr[6].eq {
	pc = 0x830E2F9C; continue 'dispatch;
	}
	// 830E2F8C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E2F90: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830E2F94: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830E2F98: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E2F9C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830E2FA0: 4815F9BD  bl 0x8324295c
	ctx.lr = 0x830E2FA4;
	// extern call 0x8324295C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 830E2FA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E2FA8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E2FAC: 480C5210  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E2FB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E2FB0 size=132
    let mut pc: u32 = 0x830E2FB0;
    'dispatch: loop {
        match pc {
            0x830E2FB0 => {
    //   block [0x830E2FB0..0x830E3034)
	// 830E2FB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E2FB4: 480C51B1  bl 0x831a8164
	ctx.lr = 0x830E2FB8;
	sub_831A8130(ctx, base);
	// 830E2FB8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E2FBC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830E2FC0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830E2FC4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830E2FC8: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 830E2FCC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830E2FD0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830E2FD4: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 830E2FD8: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E2FDC: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 830E2FE0: 4BFFCD01  bl 0x830dfce0
	ctx.lr = 0x830E2FE4;
	sub_830DFCE0(ctx, base);
	// 830E2FE4: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E2FE8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830E2FEC: 409A002C  bne cr6, 0x830e3018
	if !ctx.cr[6].eq {
	pc = 0x830E3018; continue 'dispatch;
	}
	// 830E2FF0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830E2FF4: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E2FF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E2FFC: 4BFFCD6D  bl 0x830dfd68
	ctx.lr = 0x830E3000;
	sub_830DFD68(ctx, base);
	// 830E3000: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E3004: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830E3008: 409A0010  bne cr6, 0x830e3018
	if !ctx.cr[6].eq {
	pc = 0x830E3018; continue 'dispatch;
	}
	// 830E300C: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 830E3010: 60634005  ori r3, r3, 0x4005
	ctx.r[3].u64 = ctx.r[3].u64 | 16389;
	// 830E3014: 48000018  b 0x830e302c
	pc = 0x830E302C; continue 'dispatch;
	// 830E3018: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 830E301C: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 830E3020: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830E3024: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E3028: 4BFFF081  bl 0x830e20a8
	ctx.lr = 0x830E302C;
	sub_830E20A8(ctx, base);
	// 830E302C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830E3030: 480C5184  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E3038(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E3038 size=740
    let mut pc: u32 = 0x830E3038;
    'dispatch: loop {
        match pc {
            0x830E3038 => {
    //   block [0x830E3038..0x830E331C)
	// 830E3038: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E303C: 480C5105  bl 0x831a8140
	ctx.lr = 0x830E3040;
	sub_831A8130(ctx, base);
	// 830E3040: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E3044: 7CD33378  mr r19, r6
	ctx.r[19].u64 = ctx.r[6].u64;
	// 830E3048: 7C721B78  mr r18, r3
	ctx.r[18].u64 = ctx.r[3].u64;
	// 830E304C: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 830E3050: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 830E3054: 7CF43B78  mr r20, r7
	ctx.r[20].u64 = ctx.r[7].u64;
	// 830E3058: 3AC0FFFF  li r22, -1
	ctx.r[22].s64 = -1;
	// 830E305C: 3AA0FFFB  li r21, -5
	ctx.r[21].s64 = -5;
	// 830E3060: 2F130000  cmpwi cr6, r19, 0
	ctx.cr[6].compare_i32(ctx.r[19].s32, 0, &mut ctx.xer);
	// 830E3064: 419A0020  beq cr6, 0x830e3084
	if ctx.cr[6].eq {
	pc = 0x830E3084; continue 'dispatch;
	}
	// 830E3068: 81790014  lwz r11, 0x14(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(20 as u32) ) } as u64;
	// 830E306C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830E3070: 419A0014  beq cr6, 0x830e3084
	if ctx.cr[6].eq {
	pc = 0x830E3084; continue 'dispatch;
	}
	// 830E3074: 91770024  stw r11, 0x24(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 830E3078: 81790010  lwz r11, 0x10(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(16 as u32) ) } as u64;
	// 830E307C: 91770028  stw r11, 0x28(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 830E3080: 48000188  b 0x830e3208
	pc = 0x830E3208; continue 'dispatch;
	// 830E3084: 83F90010  lwz r31, 0x10(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(16 as u32) ) } as u64;
	// 830E3088: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830E308C: 40990190  ble cr6, 0x830e321c
	if !ctx.cr[6].gt {
	pc = 0x830E321C; continue 'dispatch;
	}
	// 830E3090: 3D600FFF  lis r11, 0xfff
	ctx.r[11].s64 = 268369920;
	// 830E3094: 616BFFFF  ori r11, r11, 0xffff
	ctx.r[11].u64 = ctx.r[11].u64 | 65535;
	// 830E3098: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830E309C: 57EB2036  slwi r11, r31, 4
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830E30A0: 40990008  ble cr6, 0x830e30a8
	if !ctx.cr[6].gt {
	pc = 0x830E30A8; continue 'dispatch;
	}
	// 830E30A4: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	// 830E30A8: 7F0BA840  cmplw cr6, r11, r21
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[21].u32, &mut ctx.xer);
	// 830E30AC: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 830E30B0: 40990008  ble cr6, 0x830e30b8
	if !ctx.cr[6].gt {
	pc = 0x830E30B8; continue 'dispatch;
	}
	// 830E30B4: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 830E30B8: 4BFFA3F9  bl 0x830dd4b0
	ctx.lr = 0x830E30BC;
	sub_830DD4B0(ctx, base);
	// 830E30BC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830E30C0: 4182002C  beq 0x830e30ec
	if ctx.cr[0].eq {
	pc = 0x830E30EC; continue 'dispatch;
	}
	// 830E30C4: 3BA30004  addi r29, r3, 4
	ctx.r[29].s64 = ctx.r[3].s64 + 4;
	// 830E30C8: 93E30000  stw r31, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 830E30CC: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 830E30D0: 48000010  b 0x830e30e0
	pc = 0x830E30E0; continue 'dispatch;
	// 830E30D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E30D8: 48023BD9  bl 0x83106cb0
	ctx.lr = 0x830E30DC;
	sub_83106CB0(ctx, base);
	// 830E30DC: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 830E30E0: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830E30E4: 4080FFF0  bge 0x830e30d4
	if !ctx.cr[0].lt {
	pc = 0x830E30D4; continue 'dispatch;
	}
	// 830E30E8: 48000008  b 0x830e30f0
	pc = 0x830E30F0; continue 'dispatch;
	// 830E30EC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830E30F0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 830E30F4: 93B70024  stw r29, 0x24(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(36 as u32), ctx.r[29].u32 ) };
	// 830E30F8: 409A0010  bne cr6, 0x830e3108
	if !ctx.cr[6].eq {
	pc = 0x830E3108; continue 'dispatch;
	}
	// 830E30FC: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 830E3100: 6063000E  ori r3, r3, 0xe
	ctx.r[3].u64 = ctx.r[3].u64 | 14;
	// 830E3104: 480001FC  b 0x830e3300
	pc = 0x830E3300; continue 'dispatch;
	// 830E3108: 81790010  lwz r11, 0x10(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(16 as u32) ) } as u64;
	// 830E310C: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 830E3110: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E3114: 409900E4  ble cr6, 0x830e31f8
	if !ctx.cr[6].gt {
	pc = 0x830E31F8; continue 'dispatch;
	}
	// 830E3118: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 830E311C: 8159000C  lwz r10, 0xc(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(12 as u32) ) } as u64;
	// 830E3120: 81770024  lwz r11, 0x24(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(36 as u32) ) } as u64;
	// 830E3124: 7FBF5A14  add r29, r31, r11
	ctx.r[29].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 830E3128: 7C7F502E  lwzx r3, r31, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830E312C: 480C5F9D  bl 0x831a90c8
	ctx.lr = 0x830E3130;
	sub_831A90C8(ctx, base);
	// 830E3130: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830E3134: 397E0001  addi r11, r30, 1
	ctx.r[11].s64 = ctx.r[30].s64 + 1;
	// 830E3138: 5563083C  slwi r3, r11, 1
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 830E313C: 4BFFA375  bl 0x830dd4b0
	ctx.lr = 0x830E3140;
	sub_830DD4B0(ctx, base);
	// 830E3140: 907D0000  stw r3, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 830E3144: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830E3148: 4182FFB4  beq 0x830e30fc
	if ctx.cr[0].eq {
	pc = 0x830E30FC; continue 'dispatch;
	}
	// 830E314C: 8179000C  lwz r11, 0xc(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(12 as u32) ) } as u64;
	// 830E3150: 389E0001  addi r4, r30, 1
	ctx.r[4].s64 = ctx.r[30].s64 + 1;
	// 830E3154: 7CBF582E  lwzx r5, r31, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830E3158: 480CED61  bl 0x831b1eb8
	ctx.lr = 0x830E315C;
	sub_831B1EB8(ctx, base);
	// 830E315C: 8179000C  lwz r11, 0xc(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(12 as u32) ) } as u64;
	// 830E3160: 7D7F5A14  add r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 830E3164: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E3168: 917D0004  stw r11, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830E316C: 8179000C  lwz r11, 0xc(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(12 as u32) ) } as u64;
	// 830E3170: 7D7F5A14  add r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 830E3174: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E3178: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E317C: 917D0008  stw r11, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830E3180: 419A0058  beq cr6, 0x830e31d8
	if ctx.cr[6].eq {
	pc = 0x830E31D8; continue 'dispatch;
	}
	// 830E3184: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830E3188: 419A0050  beq cr6, 0x830e31d8
	if ctx.cr[6].eq {
	pc = 0x830E31D8; continue 'dispatch;
	}
	// 830E318C: 8179000C  lwz r11, 0xc(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(12 as u32) ) } as u64;
	// 830E3190: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830E3194: 83990010  lwz r28, 0x10(r25)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(16 as u32) ) } as u64;
	// 830E3198: 7D5F5A14  add r10, r31, r11
	ctx.r[10].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 830E319C: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 830E31A0: 834A000C  lwz r26, 0xc(r10)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 830E31A4: 4099002C  ble cr6, 0x830e31d0
	if !ctx.cr[6].gt {
	pc = 0x830E31D0; continue 'dispatch;
	}
	// 830E31A8: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 830E31AC: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 830E31B0: 807B0000  lwz r3, 0(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E31B4: 480CEC7D  bl 0x831b1e30
	ctx.lr = 0x830E31B8;
	sub_831B1E30(ctx, base);
	// 830E31B8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E31BC: 41820018  beq 0x830e31d4
	if ctx.cr[0].eq {
	pc = 0x830E31D4; continue 'dispatch;
	}
	// 830E31C0: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 830E31C4: 3B7B0010  addi r27, r27, 0x10
	ctx.r[27].s64 = ctx.r[27].s64 + 16;
	// 830E31C8: 7F1EE000  cmpw cr6, r30, r28
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[28].s32, &mut ctx.xer);
	// 830E31CC: 4198FFE0  blt cr6, 0x830e31ac
	if ctx.cr[6].lt {
	pc = 0x830E31AC; continue 'dispatch;
	}
	// 830E31D0: 3BC0FFFF  li r30, -1
	ctx.r[30].s64 = -1;
	// 830E31D4: 93DD000C  stw r30, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 830E31D8: 81770028  lwz r11, 0x28(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(40 as u32) ) } as u64;
	// 830E31DC: 3B180001  addi r24, r24, 1
	ctx.r[24].s64 = ctx.r[24].s64 + 1;
	// 830E31E0: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 830E31E4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830E31E8: 91770028  stw r11, 0x28(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 830E31EC: 81790010  lwz r11, 0x10(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(16 as u32) ) } as u64;
	// 830E31F0: 7F185800  cmpw cr6, r24, r11
	ctx.cr[6].compare_i32(ctx.r[24].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830E31F4: 4198FF28  blt cr6, 0x830e311c
	if ctx.cr[6].lt {
	pc = 0x830E311C; continue 'dispatch;
	}
	// 830E31F8: 2F130000  cmpwi cr6, r19, 0
	ctx.cr[6].compare_i32(ctx.r[19].s32, 0, &mut ctx.xer);
	// 830E31FC: 419A0020  beq cr6, 0x830e321c
	if ctx.cr[6].eq {
	pc = 0x830E321C; continue 'dispatch;
	}
	// 830E3200: 81770024  lwz r11, 0x24(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(36 as u32) ) } as u64;
	// 830E3204: 91790014  stw r11, 0x14(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 830E3208: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830E320C: 92970030  stw r20, 0x30(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(48 as u32), ctx.r[20].u32 ) };
	// 830E3210: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 830E3214: 9157002C  stw r10, 0x2c(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(44 as u32), ctx.r[10].u32 ) };
	// 830E3218: 4801FC31  bl 0x83102e48
	ctx.lr = 0x830E321C;
	sub_83102E48(ctx, base);
	// 830E321C: 8359001C  lwz r26, 0x1c(r25)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(28 as u32) ) } as u64;
	// 830E3220: 2F1A0001  cmpwi cr6, r26, 1
	ctx.cr[6].compare_i32(ctx.r[26].s32, 1, &mut ctx.xer);
	// 830E3224: 419800D8  blt cr6, 0x830e32fc
	if ctx.cr[6].lt {
	pc = 0x830E32FC; continue 'dispatch;
	}
	// 830E3228: 3D6003C3  lis r11, 0x3c3
	ctx.r[11].s64 = 63111168;
	// 830E322C: 616BC3C3  ori r11, r11, 0xc3c3
	ctx.r[11].u64 = ctx.r[11].u64 | 50115;
	// 830E3230: 7F1A5840  cmplw cr6, r26, r11
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830E3234: 1D7A0044  mulli r11, r26, 0x44
	ctx.r[11].s64 = ctx.r[26].s64 * 68;
	// 830E3238: 40990008  ble cr6, 0x830e3240
	if !ctx.cr[6].gt {
	pc = 0x830E3240; continue 'dispatch;
	}
	// 830E323C: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	// 830E3240: 7F0BA840  cmplw cr6, r11, r21
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[21].u32, &mut ctx.xer);
	// 830E3244: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 830E3248: 40990008  ble cr6, 0x830e3250
	if !ctx.cr[6].gt {
	pc = 0x830E3250; continue 'dispatch;
	}
	// 830E324C: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 830E3250: 4BFFA261  bl 0x830dd4b0
	ctx.lr = 0x830E3254;
	sub_830DD4B0(ctx, base);
	// 830E3254: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830E3258: 4182003C  beq 0x830e3294
	if ctx.cr[0].eq {
	pc = 0x830E3294; continue 'dispatch;
	}
	// 830E325C: 3BA30004  addi r29, r3, 4
	ctx.r[29].s64 = ctx.r[3].s64 + 4;
	// 830E3260: 93430000  stw r26, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 830E3264: 37FAFFFF  addic. r31, r26, -1
	ctx.xer.ca = (ctx.r[26].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[26].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830E3268: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 830E326C: 41800020  blt 0x830e328c
	if ctx.cr[0].lt {
	pc = 0x830E328C; continue 'dispatch;
	}
	// 830E3270: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E3274: 48023A5D  bl 0x83106cd0
	ctx.lr = 0x830E3278;
	sub_83106CD0(ctx, base);
	// 830E3278: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E327C: 4801C5F5  bl 0x830ff870
	ctx.lr = 0x830E3280;
	sub_830FF870(ctx, base);
	// 830E3280: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830E3284: 3BDE0044  addi r30, r30, 0x44
	ctx.r[30].s64 = ctx.r[30].s64 + 68;
	// 830E3288: 4080FFE8  bge 0x830e3270
	if !ctx.cr[0].lt {
	pc = 0x830E3270; continue 'dispatch;
	}
	// 830E328C: 7FBBEB78  mr r27, r29
	ctx.r[27].u64 = ctx.r[29].u64;
	// 830E3290: 48000008  b 0x830e3298
	pc = 0x830E3298; continue 'dispatch;
	// 830E3294: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 830E3298: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 830E329C: 419AFE60  beq cr6, 0x830e30fc
	if ctx.cr[6].eq {
	pc = 0x830E30FC; continue 'dispatch;
	}
	// 830E32A0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 830E32A4: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 830E32A8: 40990044  ble cr6, 0x830e32ec
	if !ctx.cr[6].gt {
	pc = 0x830E32EC; continue 'dispatch;
	}
	// 830E32AC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830E32B0: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 830E32B4: 81790020  lwz r11, 0x20(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(32 as u32) ) } as u64;
	// 830E32B8: 7E87A378  mr r7, r20
	ctx.r[7].u64 = ctx.r[20].u64;
	// 830E32BC: 7E669B78  mr r6, r19
	ctx.r[6].u64 = ctx.r[19].u64;
	// 830E32C0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830E32C4: 7C8BF214  add r4, r11, r30
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 830E32C8: 7E439378  mr r3, r18
	ctx.r[3].u64 = ctx.r[18].u64;
	// 830E32CC: 4BFFFCE5  bl 0x830e2fb0
	ctx.lr = 0x830E32D0;
	sub_830E2FB0(ctx, base);
	// 830E32D0: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830E32D4: 41800034  blt 0x830e3308
	if ctx.cr[0].lt {
	pc = 0x830E3308; continue 'dispatch;
	}
	// 830E32D8: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 830E32DC: 3BFF0044  addi r31, r31, 0x44
	ctx.r[31].s64 = ctx.r[31].s64 + 68;
	// 830E32E0: 3BDE0020  addi r30, r30, 0x20
	ctx.r[30].s64 = ctx.r[30].s64 + 32;
	// 830E32E4: 7F1CD000  cmpw cr6, r28, r26
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[26].s32, &mut ctx.xer);
	// 830E32E8: 4198FFCC  blt cr6, 0x830e32b4
	if ctx.cr[6].lt {
	pc = 0x830E32B4; continue 'dispatch;
	}
	// 830E32EC: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 830E32F0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830E32F4: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 830E32F8: 4801CA51  bl 0x830ffd48
	ctx.lr = 0x830E32FC;
	sub_830FFD48(ctx, base);
	// 830E32FC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E3300: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 830E3304: 480C4E8C  b 0x831a8190
	sub_831A8180(ctx, base);
	return;
	// 830E3308: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 830E330C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830E3310: 4BFFDE59  bl 0x830e1168
	ctx.lr = 0x830E3314;
	sub_830E1168(ctx, base);
	// 830E3314: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830E3318: 4BFFFFE8  b 0x830e3300
	pc = 0x830E3300; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E3320(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E3320 size=36
    let mut pc: u32 = 0x830E3320;
    'dispatch: loop {
        match pc {
            0x830E3320 => {
    //   block [0x830E3320..0x830E3344)
	// 830E3320: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E3324: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E3328: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E332C: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 830E3330: 4BFFEBF1  bl 0x830e1f20
	ctx.lr = 0x830E3334;
	sub_830E1F20(ctx, base);
	// 830E3334: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830E3338: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E333C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E3340: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E3348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E3348 size=100
    let mut pc: u32 = 0x830E3348;
    'dispatch: loop {
        match pc {
            0x830E3348 => {
    //   block [0x830E3348..0x830E33AC)
	// 830E3348: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E334C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E3350: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830E3354: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E3358: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E335C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E3360: 83DF000C  lwz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830E3364: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830E3368: 419A0014  beq cr6, 0x830e337c
	if ctx.cr[6].eq {
	pc = 0x830E337C; continue 'dispatch;
	}
	// 830E336C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E3370: 480209C9  bl 0x83103d38
	ctx.lr = 0x830E3374;
	sub_83103D38(ctx, base);
	// 830E3374: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E3378: 4BFFA161  bl 0x830dd4d8
	ctx.lr = 0x830E337C;
	sub_830DD4D8(ctx, base);
	// 830E337C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E3380: 4BFFA159  bl 0x830dd4d8
	ctx.lr = 0x830E3384;
	sub_830DD4D8(ctx, base);
	// 830E3384: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830E3388: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830E338C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830E3390: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830E3394: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E3398: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E339C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E33A0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830E33A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E33A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E33B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E33B0 size=824
    let mut pc: u32 = 0x830E33B0;
    'dispatch: loop {
        match pc {
            0x830E33B0 => {
    //   block [0x830E33B0..0x830E36E8)
	// 830E33B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E33B4: 480C4D99  bl 0x831a814c
	ctx.lr = 0x830E33B8;
	sub_831A8130(ctx, base);
	// 830E33B8: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E33BC: 7C952378  mr r21, r4
	ctx.r[21].u64 = ctx.r[4].u64;
	// 830E33C0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830E33C4: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 830E33C8: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 830E33CC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E33D0: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 830E33D4: 93D50000  stw r30, 0(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 830E33D8: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 830E33DC: 7CF93B78  mr r25, r7
	ctx.r[25].u64 = ctx.r[7].u64;
	// 830E33E0: 80780000  lwz r3, 0(r24)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E33E4: 7D1C4378  mr r28, r8
	ctx.r[28].u64 = ctx.r[8].u64;
	// 830E33E8: 7D3B4B78  mr r27, r9
	ctx.r[27].u64 = ctx.r[9].u64;
	// 830E33EC: 4BFF63CD  bl 0x830d97b8
	ctx.lr = 0x830E33F0;
	sub_830D97B8(ctx, base);
	// 830E33F0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E33F4: 418002EC  blt 0x830e36e0
	if ctx.cr[0].lt {
	pc = 0x830E36E0; continue 'dispatch;
	}
	// 830E33F8: 3EC08339  lis r22, -0x7cc7
	ctx.r[22].s64 = -2093416448;
	// 830E33FC: 2F170000  cmpwi cr6, r23, 0
	ctx.cr[6].compare_i32(ctx.r[23].s32, 0, &mut ctx.xer);
	// 830E3400: 409A0044  bne cr6, 0x830e3444
	if !ctx.cr[6].eq {
	pc = 0x830E3444; continue 'dispatch;
	}
	// 830E3404: 8096C06C  lwz r4, -0x3f94(r22)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(-16276 as u32) ) } as u64;
	// 830E3408: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E340C: 4BFEB765  bl 0x830ceb70
	ctx.lr = 0x830E3410;
	sub_830CEB70(ctx, base);
	// 830E3410: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830E3414: 41820030  beq 0x830e3444
	if ctx.cr[0].eq {
	pc = 0x830E3444; continue 'dispatch;
	}
	// 830E3418: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 830E341C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 830E3420: 4BFEB051  bl 0x830ce470
	ctx.lr = 0x830E3424;
	sub_830CE470(ctx, base);
	// 830E3424: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E3428: 4180001C  blt 0x830e3444
	if ctx.cr[0].lt {
	pc = 0x830E3444; continue 'dispatch;
	}
	// 830E342C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830E3430: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830E3434: 419A0010  beq cr6, 0x830e3444
	if ctx.cr[6].eq {
	pc = 0x830E3444; continue 'dispatch;
	}
	// 830E3438: 814B00F0  lwz r10, 0xf0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(240 as u32) ) } as u64;
	// 830E343C: 614A2000  ori r10, r10, 0x2000
	ctx.r[10].u64 = ctx.r[10].u64 | 8192;
	// 830E3440: 914B00F0  stw r10, 0xf0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(240 as u32), ctx.r[10].u32 ) };
	// 830E3444: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E3448: 3D408219  lis r10, -0x7de7
	ctx.r[10].s64 = -2112290816;
	// 830E344C: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 830E3450: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 830E3454: 394A92C0  addi r10, r10, -0x6d40
	ctx.r[10].s64 = ctx.r[10].s64 + -27968;
	// 830E3458: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 830E345C: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 830E3460: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E3464: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 830E3468: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830E346C: 419A0008  beq cr6, 0x830e3474
	if ctx.cr[6].eq {
	pc = 0x830E3474; continue 'dispatch;
	}
	// 830E3470: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E3474: 7F1D5000  cmpw cr6, r29, r10
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830E3478: 40980030  bge cr6, 0x830e34a8
	if !ctx.cr[6].lt {
	pc = 0x830E34A8; continue 'dispatch;
	}
	// 830E347C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E3480: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 830E3484: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 830E3488: 7D4AE9D6  mullw r10, r10, r29
	ctx.r[10].s64 = (ctx.r[10].s32 as i64) * (ctx.r[29].s32 as i64);
	// 830E348C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 830E3490: 388B0008  addi r4, r11, 8
	ctx.r[4].s64 = ctx.r[11].s64 + 8;
	// 830E3494: 4BFFD79D  bl 0x830e0c30
	ctx.lr = 0x830E3498;
	sub_830E0C30(ctx, base);
	// 830E3498: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830E349C: 41800220  blt 0x830e36bc
	if ctx.cr[0].lt {
	pc = 0x830E36BC; continue 'dispatch;
	}
	// 830E34A0: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 830E34A4: 4BFFFFBC  b 0x830e3460
	pc = 0x830E3460; continue 'dispatch;
	// 830E34A8: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830E34AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830E34B0: 419A00BC  beq cr6, 0x830e356c
	if ctx.cr[6].eq {
	pc = 0x830E356C; continue 'dispatch;
	}
	// 830E34B4: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 830E34B8: 4BFF25B1  bl 0x830d5a68
	ctx.lr = 0x830E34BC;
	sub_830D5A68(ctx, base);
	// 830E34BC: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 830E34C0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830E34C4: 40820038  bne 0x830e34fc
	if !ctx.cr[0].eq {
	pc = 0x830E34FC; continue 'dispatch;
	}
	// 830E34C8: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830E34CC: 806BC18C  lwz r3, -0x3e74(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-15988 as u32) ) } as u64;
	// 830E34D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830E34D4: 419A0028  beq cr6, 0x830e34fc
	if ctx.cr[6].eq {
	pc = 0x830E34FC; continue 'dispatch;
	}
	// 830E34D8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E34DC: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 830E34E0: 80810058  lwz r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830E34E4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E34E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830E34EC: 4E800421  bctrl
	ctx.lr = 0x830E34F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830E34F0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E34F4: 40800008  bge 0x830e34fc
	if !ctx.cr[0].lt {
	pc = 0x830E34FC; continue 'dispatch;
	}
	// 830E34F8: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 830E34FC: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E3500: 4BFEB0C1  bl 0x830ce5c0
	ctx.lr = 0x830E3504;
	sub_830CE5C0(ctx, base);
	// 830E3504: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830E3508: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830E350C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830E3510: 419A005C  beq cr6, 0x830e356c
	if ctx.cr[6].eq {
	pc = 0x830E356C; continue 'dispatch;
	}
	// 830E3514: 7F0B2040  cmplw cr6, r11, r4
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[4].u32, &mut ctx.xer);
	// 830E3518: 419A0054  beq cr6, 0x830e356c
	if ctx.cr[6].eq {
	pc = 0x830E356C; continue 'dispatch;
	}
	// 830E351C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 830E3520: 4BFEED89  bl 0x830d22a8
	ctx.lr = 0x830E3524;
	sub_830D22A8(ctx, base);
	// 830E3524: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E3528: 40820020  bne 0x830e3548
	if !ctx.cr[0].eq {
	pc = 0x830E3548; continue 'dispatch;
	}
	// 830E352C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830E3530: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E3534: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 830E3538: 4BFFC749  bl 0x830dfc80
	ctx.lr = 0x830E353C;
	sub_830DFC80(ctx, base);
	// 830E353C: 3FE08030  lis r31, -0x7fd0
	ctx.r[31].s64 = -2144337920;
	// 830E3540: 63FF0016  ori r31, r31, 0x16
	ctx.r[31].u64 = ctx.r[31].u64 | 22;
	// 830E3544: 48000178  b 0x830e36bc
	pc = 0x830E36BC; continue 'dispatch;
	// 830E3548: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 830E354C: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 830E3550: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E3554: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830E3558: 4BFF5D09  bl 0x830d9260
	ctx.lr = 0x830E355C;
	sub_830D9260(ctx, base);
	// 830E355C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830E3560: 4180015C  blt 0x830e36bc
	if ctx.cr[0].lt {
	pc = 0x830E36BC; continue 'dispatch;
	}
	// 830E3564: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 830E3568: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830E356C: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 830E3570: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E3574: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 830E3578: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830E357C: 419A0008  beq cr6, 0x830e3584
	if ctx.cr[6].eq {
	pc = 0x830E3584; continue 'dispatch;
	}
	// 830E3580: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E3584: 7F1D5000  cmpw cr6, r29, r10
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830E3588: 4098007C  bge cr6, 0x830e3604
	if !ctx.cr[6].lt {
	pc = 0x830E3604; continue 'dispatch;
	}
	// 830E358C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E3590: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 830E3594: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 830E3598: 7D4AE9D6  mullw r10, r10, r29
	ctx.r[10].s64 = (ctx.r[10].s32 as i64) * (ctx.r[29].s32 as i64);
	// 830E359C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 830E35A0: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 830E35A4: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 830E35A8: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 830E35AC: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 830E35B0: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 830E35B4: 4BFFFDFD  bl 0x830e33b0
	ctx.lr = 0x830E35B8;
	sub_830E33B0(ctx, base);
	// 830E35B8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830E35BC: 41800100  blt 0x830e36bc
	if ctx.cr[0].lt {
	pc = 0x830E36BC; continue 'dispatch;
	}
	// 830E35C0: 8081005C  lwz r4, 0x5c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 830E35C4: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E35C8: 4BFFC0F9  bl 0x830df6c0
	ctx.lr = 0x830E35CC;
	sub_830DF6C0(ctx, base);
	// 830E35CC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830E35D0: 418000EC  blt 0x830e36bc
	if ctx.cr[0].lt {
	pc = 0x830E36BC; continue 'dispatch;
	}
	// 830E35D4: 8096C06C  lwz r4, -0x3f94(r22)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(-16276 as u32) ) } as u64;
	// 830E35D8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 830E35DC: 4BFFB50D  bl 0x830deae8
	ctx.lr = 0x830E35E0;
	sub_830DEAE8(ctx, base);
	// 830E35E0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830E35E4: 41820018  beq 0x830e35fc
	if ctx.cr[0].eq {
	pc = 0x830E35FC; continue 'dispatch;
	}
	// 830E35E8: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E35EC: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830E35F0: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E35F4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830E35F8: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830E35FC: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 830E3600: 4BFFFF70  b 0x830e3570
	pc = 0x830E3570; continue 'dispatch;
	// 830E3604: 81780020  lwz r11, 0x20(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(32 as u32) ) } as u64;
	// 830E3608: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830E360C: 409A0010  bne cr6, 0x830e361c
	if !ctx.cr[6].eq {
	pc = 0x830E361C; continue 'dispatch;
	}
	// 830E3610: 8178000C  lwz r11, 0xc(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(12 as u32) ) } as u64;
	// 830E3614: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830E3618: 419A00BC  beq cr6, 0x830e36d4
	if ctx.cr[6].eq {
	pc = 0x830E36D4; continue 'dispatch;
	}
	// 830E361C: 38600050  li r3, 0x50
	ctx.r[3].s64 = 80;
	// 830E3620: 4BFF9E91  bl 0x830dd4b0
	ctx.lr = 0x830E3624;
	sub_830DD4B0(ctx, base);
	// 830E3624: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830E3628: 41820018  beq 0x830e3640
	if ctx.cr[0].eq {
	pc = 0x830E3640; continue 'dispatch;
	}
	// 830E362C: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 830E3630: 480236A1  bl 0x83106cd0
	ctx.lr = 0x830E3634;
	sub_83106CD0(ctx, base);
	// 830E3634: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E3638: 4801BA29  bl 0x830ff060
	ctx.lr = 0x830E363C;
	sub_830FF060(ctx, base);
	// 830E363C: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 830E3640: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830E3644: 409A0010  bne cr6, 0x830e3654
	if !ctx.cr[6].eq {
	pc = 0x830E3654; continue 'dispatch;
	}
	// 830E3648: 3FE08007  lis r31, -0x7ff9
	ctx.r[31].s64 = -2147024896;
	// 830E364C: 63FF000E  ori r31, r31, 0xe
	ctx.r[31].u64 = ctx.r[31].u64 | 14;
	// 830E3650: 4800006C  b 0x830e36bc
	pc = 0x830E36BC; continue 'dispatch;
	// 830E3654: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 830E3658: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E365C: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 830E3660: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830E3664: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 830E3668: 4BFFF9D1  bl 0x830e3038
	ctx.lr = 0x830E366C;
	sub_830E3038(ctx, base);
	// 830E366C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830E3670: 4180003C  blt 0x830e36ac
	if ctx.cr[0].lt {
	pc = 0x830E36AC; continue 'dispatch;
	}
	// 830E3674: 2F170000  cmpwi cr6, r23, 0
	ctx.cr[6].compare_i32(ctx.r[23].s32, 0, &mut ctx.xer);
	// 830E3678: 419A0020  beq cr6, 0x830e3698
	if ctx.cr[6].eq {
	pc = 0x830E3698; continue 'dispatch;
	}
	// 830E367C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 830E3680: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 830E3684: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 830E3688: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830E368C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830E3690: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E3694: 4801BA65  bl 0x830ff0f8
	ctx.lr = 0x830E3698;
	sub_830FF0F8(ctx, base);
	// 830E3698: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830E369C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E36A0: 4BFFC9C1  bl 0x830e0060
	ctx.lr = 0x830E36A4;
	sub_830E0060(ctx, base);
	// 830E36A4: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830E36A8: 4080002C  bge 0x830e36d4
	if !ctx.cr[0].lt {
	pc = 0x830E36D4; continue 'dispatch;
	}
	// 830E36AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E36B0: 4801C759  bl 0x830ffe08
	ctx.lr = 0x830E36B4;
	sub_830FFE08(ctx, base);
	// 830E36B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E36B8: 4BFF9E21  bl 0x830dd4d8
	ctx.lr = 0x830E36BC;
	sub_830DD4D8(ctx, base);
	// 830E36BC: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E36C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830E36C4: 419A0008  beq cr6, 0x830e36cc
	if ctx.cr[6].eq {
	pc = 0x830E36CC; continue 'dispatch;
	}
	// 830E36C8: 4BFF6161  bl 0x830d9828
	ctx.lr = 0x830E36CC;
	sub_830D9828(ctx, base);
	// 830E36CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E36D0: 48000010  b 0x830e36e0
	pc = 0x830E36E0; continue 'dispatch;
	// 830E36D4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E36D8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E36DC: 91750000  stw r11, 0(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830E36E0: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 830E36E4: 480C4AB8  b 0x831a819c
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E36E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830E36E8 size=1120
    let mut pc: u32 = 0x830E36E8;
    'dispatch: loop {
        match pc {
            0x830E36E8 => {
    //   block [0x830E36E8..0x830E3B48)
	// 830E36E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E36EC: 480C4A69  bl 0x831a8154
	ctx.lr = 0x830E36F0;
	sub_831A8130(ctx, base);
	// 830E36F0: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E36F4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830E36F8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830E36FC: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 830E3700: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 830E3704: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 830E3708: 409A0010  bne cr6, 0x830e3718
	if !ctx.cr[6].eq {
	pc = 0x830E3718; continue 'dispatch;
	}
	// 830E370C: 3C608030  lis r3, -0x7fd0
	ctx.r[3].s64 = -2144337920;
	// 830E3710: 6063000A  ori r3, r3, 0xa
	ctx.r[3].u64 = ctx.r[3].u64 | 10;
	// 830E3714: 4800042C  b 0x830e3b40
	pc = 0x830E3B40; continue 'dispatch;
	// 830E3718: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830E371C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830E3720: 4BFFC039  bl 0x830df758
	ctx.lr = 0x830E3724;
	sub_830DF758(ctx, base);
	// 830E3724: 83210058  lwz r25, 0x58(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830E3728: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 830E372C: 409A0010  bne cr6, 0x830e373c
	if !ctx.cr[6].eq {
	pc = 0x830E373C; continue 'dispatch;
	}
	// 830E3730: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 830E3734: 60630057  ori r3, r3, 0x57
	ctx.r[3].u64 = ctx.r[3].u64 | 87;
	// 830E3738: 48000408  b 0x830e3b40
	pc = 0x830E3B40; continue 'dispatch;
	// 830E373C: 3D608218  lis r11, -0x7de8
	ctx.r[11].s64 = -2112356352;
	// 830E3740: 3B8B7D10  addi r28, r11, 0x7d10
	ctx.r[28].s64 = ctx.r[11].s64 + 32016;
	// 830E3744: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830E3748: 4BFF2321  bl 0x830d5a68
	ctx.lr = 0x830E374C;
	sub_830D5A68(ctx, base);
	// 830E374C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830E3750: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 830E3754: 4BFEB39D  bl 0x830ceaf0
	ctx.lr = 0x830E3758;
	sub_830CEAF0(ctx, base);
	// 830E3758: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E375C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830E3760: 41820020  beq 0x830e3780
	if ctx.cr[0].eq {
	pc = 0x830E3780; continue 'dispatch;
	}
	// 830E3764: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830E3768: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830E376C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 830E3770: 4BFFC511  bl 0x830dfc80
	ctx.lr = 0x830E3774;
	sub_830DFC80(ctx, base);
	// 830E3774: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 830E3778: 6063FFFF  ori r3, r3, 0xffff
	ctx.r[3].u64 = ctx.r[3].u64 | 65535;
	// 830E377C: 480003C4  b 0x830e3b40
	pc = 0x830E3B40; continue 'dispatch;
	// 830E3780: 4BFFB3D1  bl 0x830deb50
	ctx.lr = 0x830E3784;
	sub_830DEB50(ctx, base);
	// 830E3784: 7C771B79  or. r23, r3, r3
	ctx.r[23].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[23].s32, 0, &mut ctx.xer);
	// 830E3788: 4182FF84  beq 0x830e370c
	if ctx.cr[0].eq {
	pc = 0x830E370C; continue 'dispatch;
	}
	// 830E378C: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 830E3790: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 830E3794: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 830E3798: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 830E379C: 4BFFD1B5  bl 0x830e0950
	ctx.lr = 0x830E37A0;
	sub_830E0950(ctx, base);
	// 830E37A0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830E37A4: 3BE10090  addi r31, r1, 0x90
	ctx.r[31].s64 = ctx.r[1].s64 + 144;
	// 830E37A8: 4BFEB469  bl 0x830cec10
	ctx.lr = 0x830E37AC;
	sub_830CEC10(ctx, base);
	// 830E37AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E37B0: 4BFF2419  bl 0x830d5bc8
	ctx.lr = 0x830E37B4;
	sub_830D5BC8(ctx, base);
	// 830E37B4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E37B8: 41800034  blt 0x830e37ec
	if ctx.cr[0].lt {
	pc = 0x830E37EC; continue 'dispatch;
	}
	// 830E37BC: 81610098  lwz r11, 0x98(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 830E37C0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E37C4: 419A0028  beq cr6, 0x830e37ec
	if ctx.cr[6].eq {
	pc = 0x830E37EC; continue 'dispatch;
	}
	// 830E37C8: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 830E37CC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E37D0: 419A001C  beq cr6, 0x830e37ec
	if ctx.cr[6].eq {
	pc = 0x830E37EC; continue 'dispatch;
	}
	// 830E37D4: 81770038  lwz r11, 0x38(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(56 as u32) ) } as u64;
	// 830E37D8: 93770040  stw r27, 0x40(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(64 as u32), ctx.r[27].u32 ) };
	// 830E37DC: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 830E37E0: 91770038  stw r11, 0x38(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 830E37E4: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 830E37E8: 91770044  stw r11, 0x44(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(68 as u32), ctx.r[11].u32 ) };
	// 830E37EC: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 830E37F0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830E37F4: 93010058  stw r24, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[24].u32 ) };
	// 830E37F8: 419A0054  beq cr6, 0x830e384c
	if ctx.cr[6].eq {
	pc = 0x830E384C; continue 'dispatch;
	}
	// 830E37FC: A17E0000  lhz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E3800: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830E3804: 41820048  beq 0x830e384c
	if ctx.cr[0].eq {
	pc = 0x830E384C; continue 'dispatch;
	}
	// 830E3808: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830E380C: 48003F4D  bl 0x830e7758
	ctx.lr = 0x830E3810;
	sub_830E7758(ctx, base);
	// 830E3810: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830E3814: 38E10064  addi r7, r1, 0x64
	ctx.r[7].s64 = ctx.r[1].s64 + 100;
	// 830E3818: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 830E381C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 830E3820: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E3824: 4BFFE6FD  bl 0x830e1f20
	ctx.lr = 0x830E3828;
	sub_830E1F20(ctx, base);
	// 830E3828: 83410058  lwz r26, 0x58(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830E382C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E3830: 41800014  blt 0x830e3844
	if ctx.cr[0].lt {
	pc = 0x830E3844; continue 'dispatch;
	}
	// 830E3834: 817A001C  lwz r11, 0x1c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(28 as u32) ) } as u64;
	// 830E3838: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830E383C: 40980008  bge cr6, 0x830e3844
	if !ctx.cr[6].lt {
	pc = 0x830E3844; continue 'dispatch;
	}
	// 830E3840: 7F1AC378  mr r26, r24
	ctx.r[26].u64 = ctx.r[24].u64;
	// 830E3844: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 830E3848: 409A002C  bne cr6, 0x830e3874
	if !ctx.cr[6].eq {
	pc = 0x830E3874; continue 'dispatch;
	}
	// 830E384C: 81770038  lwz r11, 0x38(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(56 as u32) ) } as u64;
	// 830E3850: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 830E3854: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830E3858: 419A02E4  beq cr6, 0x830e3b3c
	if ctx.cr[6].eq {
	pc = 0x830E3B3C; continue 'dispatch;
	}
	// 830E385C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830E3860: 80A10070  lwz r5, 0x70(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 830E3864: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830E3868: 4BFFEB81  bl 0x830e23e8
	ctx.lr = 0x830E386C;
	sub_830E23E8(ctx, base);
	// 830E386C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830E3870: 480002D0  b 0x830e3b40
	pc = 0x830E3B40; continue 'dispatch;
	// 830E3874: 93010054  stw r24, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[24].u32 ) };
	// 830E3878: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830E387C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E3880: 4BFF5F39  bl 0x830d97b8
	ctx.lr = 0x830E3884;
	sub_830D97B8(ctx, base);
	// 830E3884: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830E3888: 41800244  blt 0x830e3acc
	if ctx.cr[0].lt {
	pc = 0x830E3ACC; continue 'dispatch;
	}
	// 830E388C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 830E3890: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E3894: 4BFEABDD  bl 0x830ce470
	ctx.lr = 0x830E3898;
	sub_830CE470(ctx, base);
	// 830E3898: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830E389C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830E38A0: 409A0010  bne cr6, 0x830e38b0
	if !ctx.cr[6].eq {
	pc = 0x830E38B0; continue 'dispatch;
	}
	// 830E38A4: 3FC08000  lis r30, -0x8000
	ctx.r[30].s64 = -2147483648;
	// 830E38A8: 63DEFFFF  ori r30, r30, 0xffff
	ctx.r[30].u64 = ctx.r[30].u64 | 65535;
	// 830E38AC: 48000220  b 0x830e3acc
	pc = 0x830E3ACC; continue 'dispatch;
	// 830E38B0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830E38B4: 480024BD  bl 0x830e5d70
	ctx.lr = 0x830E38B8;
	sub_830E5D70(ctx, base);
	// 830E38B8: 80810070  lwz r4, 0x70(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 830E38BC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830E38C0: 480024C9  bl 0x830e5d88
	ctx.lr = 0x830E38C4;
	sub_830E5D88(ctx, base);
	// 830E38C4: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 830E38C8: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 830E38CC: 419A001C  beq cr6, 0x830e38e8
	if ctx.cr[6].eq {
	pc = 0x830E38E8; continue 'dispatch;
	}
	// 830E38D0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830E38D4: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830E38D8: 80BA0020  lwz r5, 0x20(r26)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(32 as u32) ) } as u64;
	// 830E38DC: 4800D975  bl 0x830f1250
	ctx.lr = 0x830E38E0;
	sub_830F1250(ctx, base);
	// 830E38E0: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830E38E4: 418001E8  blt 0x830e3acc
	if ctx.cr[0].lt {
	pc = 0x830E3ACC; continue 'dispatch;
	}
	// 830E38E8: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E38EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830E38F0: 419A0098  beq cr6, 0x830e3988
	if ctx.cr[6].eq {
	pc = 0x830E3988; continue 'dispatch;
	}
	// 830E38F4: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830E38F8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E38FC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E3900: 40990088  ble cr6, 0x830e3988
	if !ctx.cr[6].gt {
	pc = 0x830E3988; continue 'dispatch;
	}
	// 830E3904: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E3908: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 830E390C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 830E3910: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 830E3914: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 830E3918: 4BFFD729  bl 0x830e1040
	ctx.lr = 0x830E391C;
	sub_830E1040(ctx, base);
	// 830E391C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E3920: 41800068  blt 0x830e3988
	if ctx.cr[0].lt {
	pc = 0x830E3988; continue 'dispatch;
	}
	// 830E3924: 38A10064  addi r5, r1, 0x64
	ctx.r[5].s64 = ctx.r[1].s64 + 100;
	// 830E3928: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 830E392C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830E3930: 48003ED9  bl 0x830e7808
	ctx.lr = 0x830E3934;
	sub_830E7808(ctx, base);
	// 830E3934: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 830E3938: C1A10058  lfs f13, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830E393C: C00B9528  lfs f0, -0x6ad8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E3940: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 830E3944: 40990018  ble cr6, 0x830e395c
	if !ctx.cr[6].gt {
	pc = 0x830E395C; continue 'dispatch;
	}
	// 830E3948: C1810078  lfs f12, 0x78(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830E394C: EDAC6824  fdivs f13, f12, f13
	ctx.f[13].f64 = ((ctx.f[12].f64 / ctx.f[13].f64) as f32) as f64;
	// 830E3950: C181005C  lfs f12, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830E3954: EDAD0332  fmuls f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 830E3958: D1A10078  stfs f13, 0x78(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 830E395C: C1A10060  lfs f13, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830E3960: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 830E3964: 40990018  ble cr6, 0x830e397c
	if !ctx.cr[6].gt {
	pc = 0x830E397C; continue 'dispatch;
	}
	// 830E3968: C001007C  lfs f0, 0x7c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E396C: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 830E3970: C1A10064  lfs f13, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830E3974: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 830E3978: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 830E397C: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 830E3980: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830E3984: 4BFFC25D  bl 0x830dfbe0
	ctx.lr = 0x830E3988;
	sub_830DFBE0(ctx, base);
	// 830E3988: 3FE08334  lis r31, -0x7ccc
	ctx.r[31].s64 = -2093744128;
	// 830E398C: 807F56F8  lwz r3, 0x56f8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(22264 as u32) ) } as u64;
	// 830E3990: 4815F31D  bl 0x83242cac
	ctx.lr = 0x830E3994;
	// extern call 0x83242CAC → crate::xboxkrnl::KeTlsGetValue
	crate::xboxkrnl::KeTlsGetValue(ctx, base);
	// 830E3994: 817F56F8  lwz r11, 0x56f8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(22264 as u32) ) } as u64;
	// 830E3998: 38830001  addi r4, r3, 1
	ctx.r[4].s64 = ctx.r[3].s64 + 1;
	// 830E399C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 830E39A0: 4815F31D  bl 0x83242cbc
	ctx.lr = 0x830E39A4;
	// extern call 0x83242CBC → crate::xboxkrnl::KeTlsSetValue
	crate::xboxkrnl::KeTlsSetValue(ctx, base);
	// 830E39A4: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 830E39A8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830E39AC: 4BFFBF15  bl 0x830df8c0
	ctx.lr = 0x830E39B0;
	sub_830DF8C0(ctx, base);
	// 830E39B0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830E39B4: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 830E39B8: 80C10064  lwz r6, 0x64(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 830E39BC: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E39C0: 4BFFBFF1  bl 0x830df9b0
	ctx.lr = 0x830E39C4;
	sub_830DF9B0(ctx, base);
	// 830E39C4: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830E39C8: 40980020  bge cr6, 0x830e39e8
	if !ctx.cr[6].lt {
	pc = 0x830E39E8; continue 'dispatch;
	}
	// 830E39CC: 807F56F8  lwz r3, 0x56f8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(22264 as u32) ) } as u64;
	// 830E39D0: 4815F2DD  bl 0x83242cac
	ctx.lr = 0x830E39D4;
	// extern call 0x83242CAC → crate::xboxkrnl::KeTlsGetValue
	crate::xboxkrnl::KeTlsGetValue(ctx, base);
	// 830E39D4: 817F56F8  lwz r11, 0x56f8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(22264 as u32) ) } as u64;
	// 830E39D8: 3883FFFF  addi r4, r3, -1
	ctx.r[4].s64 = ctx.r[3].s64 + -1;
	// 830E39DC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 830E39E0: 4815F2DD  bl 0x83242cbc
	ctx.lr = 0x830E39E4;
	// extern call 0x83242CBC → crate::xboxkrnl::KeTlsSetValue
	crate::xboxkrnl::KeTlsSetValue(ctx, base);
	// 830E39E4: 480000E8  b 0x830e3acc
	pc = 0x830E3ACC; continue 'dispatch;
	// 830E39E8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830E39EC: 4BFFBD25  bl 0x830df710
	ctx.lr = 0x830E39F0;
	sub_830DF710(ctx, base);
	// 830E39F0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830E39F4: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E39F8: 4BFFBCC9  bl 0x830df6c0
	ctx.lr = 0x830E39FC;
	sub_830DF6C0(ctx, base);
	// 830E39FC: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830E3A00: 807F56F8  lwz r3, 0x56f8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(22264 as u32) ) } as u64;
	// 830E3A04: 4180FFCC  blt 0x830e39d0
	if ctx.cr[0].lt {
	pc = 0x830E39D0; continue 'dispatch;
	}
	// 830E3A08: 4815F2A5  bl 0x83242cac
	ctx.lr = 0x830E3A0C;
	// extern call 0x83242CAC → crate::xboxkrnl::KeTlsGetValue
	crate::xboxkrnl::KeTlsGetValue(ctx, base);
	// 830E3A0C: 817F56F8  lwz r11, 0x56f8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(22264 as u32) ) } as u64;
	// 830E3A10: 3883FFFF  addi r4, r3, -1
	ctx.r[4].s64 = ctx.r[3].s64 + -1;
	// 830E3A14: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 830E3A18: 4815F2A5  bl 0x83242cbc
	ctx.lr = 0x830E3A1C;
	// extern call 0x83242CBC → crate::xboxkrnl::KeTlsSetValue
	crate::xboxkrnl::KeTlsSetValue(ctx, base);
	// 830E3A1C: 38600048  li r3, 0x48
	ctx.r[3].s64 = 72;
	// 830E3A20: 4BFF9A91  bl 0x830dd4b0
	ctx.lr = 0x830E3A24;
	sub_830DD4B0(ctx, base);
	// 830E3A24: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830E3A28: 41820028  beq 0x830e3a50
	if ctx.cr[0].eq {
	pc = 0x830E3A50; continue 'dispatch;
	}
	// 830E3A2C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830E3A30: 3BE30004  addi r31, r3, 4
	ctx.r[31].s64 = ctx.r[3].s64 + 4;
	// 830E3A34: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830E3A38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E3A3C: 48023295  bl 0x83106cd0
	ctx.lr = 0x830E3A40;
	sub_83106CD0(ctx, base);
	// 830E3A40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E3A44: 4801BE2D  bl 0x830ff870
	ctx.lr = 0x830E3A48;
	sub_830FF870(ctx, base);
	// 830E3A48: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 830E3A4C: 48000008  b 0x830e3a54
	pc = 0x830E3A54; continue 'dispatch;
	// 830E3A50: 7F1CC378  mr r28, r24
	ctx.r[28].u64 = ctx.r[24].u64;
	// 830E3A54: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 830E3A58: 409A0010  bne cr6, 0x830e3a68
	if !ctx.cr[6].eq {
	pc = 0x830E3A68; continue 'dispatch;
	}
	// 830E3A5C: 3FC08007  lis r30, -0x7ff9
	ctx.r[30].s64 = -2147024896;
	// 830E3A60: 63DE000E  ori r30, r30, 0xe
	ctx.r[30].u64 = ctx.r[30].u64 | 14;
	// 830E3A64: 48000068  b 0x830e3acc
	pc = 0x830E3ACC; continue 'dispatch;
	// 830E3A68: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 830E3A6C: 809A0020  lwz r4, 0x20(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(32 as u32) ) } as u64;
	// 830E3A70: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830E3A74: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 830E3A78: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830E3A7C: 4BFFE62D  bl 0x830e20a8
	ctx.lr = 0x830E3A80;
	sub_830E20A8(ctx, base);
	// 830E3A80: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830E3A84: 4180003C  blt 0x830e3ac0
	if ctx.cr[0].lt {
	pc = 0x830E3AC0; continue 'dispatch;
	}
	// 830E3A88: 38600050  li r3, 0x50
	ctx.r[3].s64 = 80;
	// 830E3A8C: 4BFF9A25  bl 0x830dd4b0
	ctx.lr = 0x830E3A90;
	sub_830DD4B0(ctx, base);
	// 830E3A90: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830E3A94: 41820018  beq 0x830e3aac
	if ctx.cr[0].eq {
	pc = 0x830E3AAC; continue 'dispatch;
	}
	// 830E3A98: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 830E3A9C: 48023235  bl 0x83106cd0
	ctx.lr = 0x830E3AA0;
	sub_83106CD0(ctx, base);
	// 830E3AA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E3AA4: 4801B5BD  bl 0x830ff060
	ctx.lr = 0x830E3AA8;
	sub_830FF060(ctx, base);
	// 830E3AA8: 48000008  b 0x830e3ab0
	pc = 0x830E3AB0; continue 'dispatch;
	// 830E3AAC: 7F1FC378  mr r31, r24
	ctx.r[31].u64 = ctx.r[24].u64;
	// 830E3AB0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830E3AB4: 409A0030  bne cr6, 0x830e3ae4
	if !ctx.cr[6].eq {
	pc = 0x830E3AE4; continue 'dispatch;
	}
	// 830E3AB8: 3FC08007  lis r30, -0x7ff9
	ctx.r[30].s64 = -2147024896;
	// 830E3ABC: 63DE000E  ori r30, r30, 0xe
	ctx.r[30].u64 = ctx.r[30].u64 | 14;
	// 830E3AC0: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 830E3AC4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830E3AC8: 4BFFD6A1  bl 0x830e1168
	ctx.lr = 0x830E3ACC;
	sub_830E1168(ctx, base);
	// 830E3ACC: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E3AD0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830E3AD4: 419A0008  beq cr6, 0x830e3adc
	if ctx.cr[6].eq {
	pc = 0x830E3ADC; continue 'dispatch;
	}
	// 830E3AD8: 4BFF5D51  bl 0x830d9828
	ctx.lr = 0x830E3ADC;
	sub_830D9828(ctx, base);
	// 830E3ADC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E3AE0: 48000060  b 0x830e3b40
	pc = 0x830E3B40; continue 'dispatch;
	// 830E3AE4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830E3AE8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830E3AEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E3AF0: 4801C259  bl 0x830ffd48
	ctx.lr = 0x830E3AF4;
	sub_830FFD48(ctx, base);
	// 830E3AF4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E3AF8: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E3AFC: 4BFFC565  bl 0x830e0060
	ctx.lr = 0x830E3B00;
	sub_830E0060(ctx, base);
	// 830E3B00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E3B04: 4B3786A5  bl 0x8245c1a8
	ctx.lr = 0x830E3B08;
	sub_8245C1A8(ctx, base);
	// 830E3B08: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 830E3B0C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 830E3B10: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E3B14: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 830E3B18: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830E3B1C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830E3B20: 4BFFC639  bl 0x830e0158
	ctx.lr = 0x830E3B24;
	sub_830E0158(ctx, base);
	// 830E3B24: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830E3B28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E3B2C: 4801C04D  bl 0x830ffb78
	ctx.lr = 0x830E3B30;
	sub_830FFB78(ctx, base);
	// 830E3B30: 81770038  lwz r11, 0x38(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(56 as u32) ) } as u64;
	// 830E3B34: 616B0002  ori r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u64 | 2;
	// 830E3B38: 91770038  stw r11, 0x38(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 830E3B3C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E3B40: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 830E3B44: 480C4660  b 0x831a81a4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E3B48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E3B48 size=280
    let mut pc: u32 = 0x830E3B48;
    'dispatch: loop {
        match pc {
            0x830E3B48 => {
    //   block [0x830E3B48..0x830E3C60)
	// 830E3B48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E3B4C: 480C460D  bl 0x831a8158
	ctx.lr = 0x830E3B50;
	sub_831A8130(ctx, base);
	// 830E3B50: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E3B54: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830E3B58: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830E3B5C: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 830E3B60: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 830E3B64: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 830E3B68: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 830E3B6C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 830E3B70: 409A0010  bne cr6, 0x830e3b80
	if !ctx.cr[6].eq {
	pc = 0x830E3B80; continue 'dispatch;
	}
	// 830E3B74: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 830E3B78: 60630057  ori r3, r3, 0x57
	ctx.r[3].u64 = ctx.r[3].u64 | 87;
	// 830E3B7C: 480000DC  b 0x830e3c58
	pc = 0x830E3C58; continue 'dispatch;
	// 830E3B80: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 830E3B84: 3F008334  lis r24, -0x7ccc
	ctx.r[24].s64 = -2093744128;
	// 830E3B88: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 830E3B8C: 807856F8  lwz r3, 0x56f8(r24)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(22264 as u32) ) } as u64;
	// 830E3B90: 4815F11D  bl 0x83242cac
	ctx.lr = 0x830E3B94;
	// extern call 0x83242CAC → crate::xboxkrnl::KeTlsGetValue
	crate::xboxkrnl::KeTlsGetValue(ctx, base);
	// 830E3B94: 817856F8  lwz r11, 0x56f8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(22264 as u32) ) } as u64;
	// 830E3B98: 38830001  addi r4, r3, 1
	ctx.r[4].s64 = ctx.r[3].s64 + 1;
	// 830E3B9C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 830E3BA0: 4815F11D  bl 0x83242cbc
	ctx.lr = 0x830E3BA4;
	// extern call 0x83242CBC → crate::xboxkrnl::KeTlsSetValue
	crate::xboxkrnl::KeTlsSetValue(ctx, base);
	// 830E3BA4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830E3BA8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 830E3BAC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 830E3BB0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 830E3BB4: 39010054  addi r8, r1, 0x54
	ctx.r[8].s64 = ctx.r[1].s64 + 84;
	// 830E3BB8: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 830E3BBC: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 830E3BC0: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 830E3BC4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E3BC8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E3BCC: 4BFFF7E5  bl 0x830e33b0
	ctx.lr = 0x830E3BD0;
	sub_830E33B0(ctx, base);
	// 830E3BD0: 817856F8  lwz r11, 0x56f8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(22264 as u32) ) } as u64;
	// 830E3BD4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E3BD8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 830E3BDC: 4815F0D1  bl 0x83242cac
	ctx.lr = 0x830E3BE0;
	// extern call 0x83242CAC → crate::xboxkrnl::KeTlsGetValue
	crate::xboxkrnl::KeTlsGetValue(ctx, base);
	// 830E3BE0: 817856F8  lwz r11, 0x56f8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(22264 as u32) ) } as u64;
	// 830E3BE4: 3883FFFF  addi r4, r3, -1
	ctx.r[4].s64 = ctx.r[3].s64 + -1;
	// 830E3BE8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 830E3BEC: 4815F0D1  bl 0x83242cbc
	ctx.lr = 0x830E3BF0;
	// extern call 0x83242CBC → crate::xboxkrnl::KeTlsSetValue
	crate::xboxkrnl::KeTlsSetValue(ctx, base);
	// 830E3BF0: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830E3BF4: 4098000C  bge cr6, 0x830e3c00
	if !ctx.cr[6].lt {
	pc = 0x830E3C00; continue 'dispatch;
	}
	// 830E3BF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E3BFC: 4800005C  b 0x830e3c58
	pc = 0x830E3C58; continue 'dispatch;
	// 830E3C00: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E3C04: 2F190000  cmpwi cr6, r25, 0
	ctx.cr[6].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 830E3C08: 419A0028  beq cr6, 0x830e3c30
	if ctx.cr[6].eq {
	pc = 0x830E3C30; continue 'dispatch;
	}
	// 830E3C0C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830E3C10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E3C14: 4BFFE14D  bl 0x830e1d60
	ctx.lr = 0x830E3C18;
	sub_830E1D60(ctx, base);
	// 830E3C18: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830E3C1C: 40800014  bge 0x830e3c30
	if !ctx.cr[0].lt {
	pc = 0x830E3C30; continue 'dispatch;
	}
	// 830E3C20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E3C24: 4BFF5C05  bl 0x830d9828
	ctx.lr = 0x830E3C28;
	sub_830D9828(ctx, base);
	// 830E3C28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E3C2C: 4800002C  b 0x830e3c58
	pc = 0x830E3C58; continue 'dispatch;
	// 830E3C30: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830E3C34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E3C38: 808BC06C  lwz r4, -0x3f94(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16276 as u32) ) } as u64;
	// 830E3C3C: 4BFFAEAD  bl 0x830deae8
	ctx.lr = 0x830E3C40;
	sub_830DEAE8(ctx, base);
	// 830E3C40: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830E3C44: 4182000C  beq 0x830e3c50
	if ctx.cr[0].eq {
	pc = 0x830E3C50; continue 'dispatch;
	}
	// 830E3C48: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830E3C4C: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830E3C50: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 830E3C54: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E3C58: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830E3C5C: 480C454C  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E3C60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E3C60 size=252
    let mut pc: u32 = 0x830E3C60;
    'dispatch: loop {
        match pc {
            0x830E3C60 => {
    //   block [0x830E3C60..0x830E3D5C)
	// 830E3C60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E3C64: 480C4501  bl 0x831a8164
	ctx.lr = 0x830E3C68;
	sub_831A8130(ctx, base);
	// 830E3C68: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E3C6C: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 830E3C70: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830E3C74: 3F808339  lis r28, -0x7cc7
	ctx.r[28].s64 = -2093416448;
	// 830E3C78: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 830E3C7C: 419A0010  beq cr6, 0x830e3c8c
	if ctx.cr[6].eq {
	pc = 0x830E3C8C; continue 'dispatch;
	}
	// 830E3C80: 817CD814  lwz r11, -0x27ec(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-10220 as u32) ) } as u64;
	// 830E3C84: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830E3C88: 917CD814  stw r11, -0x27ec(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(-10220 as u32), ctx.r[11].u32 ) };
	// 830E3C8C: 4BFEAF85  bl 0x830cec10
	ctx.lr = 0x830E3C90;
	sub_830CEC10(ctx, base);
	// 830E3C90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E3C94: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 830E3C98: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830E3C9C: 4BFFC925  bl 0x830e05c0
	ctx.lr = 0x830E3CA0;
	sub_830E05C0(ctx, base);
	// 830E3CA0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830E3CA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E3CA8: 4BFF1F21  bl 0x830d5bc8
	ctx.lr = 0x830E3CAC;
	sub_830D5BC8(ctx, base);
	// 830E3CAC: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830E3CB0: 4180008C  blt 0x830e3d3c
	if ctx.cr[0].lt {
	pc = 0x830E3D3C; continue 'dispatch;
	}
	// 830E3CB4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830E3CB8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E3CBC: 419A0018  beq cr6, 0x830e3cd4
	if ctx.cr[6].eq {
	pc = 0x830E3CD4; continue 'dispatch;
	}
	// 830E3CC0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830E3CC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E3CC8: 4BFFE889  bl 0x830e2550
	ctx.lr = 0x830E3CCC;
	sub_830E2550(ctx, base);
	// 830E3CCC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830E3CD0: 4800006C  b 0x830e3d3c
	pc = 0x830E3D3C; continue 'dispatch;
	// 830E3CD4: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 830E3CD8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E3CDC: 409A0058  bne cr6, 0x830e3d34
	if !ctx.cr[6].eq {
	pc = 0x830E3D34; continue 'dispatch;
	}
	// 830E3CE0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E3CE4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830E3CE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E3CEC: 4BFFBAE5  bl 0x830df7d0
	ctx.lr = 0x830E3CF0;
	sub_830DF7D0(ctx, base);
	// 830E3CF0: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E3CF4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830E3CF8: 419A003C  beq cr6, 0x830e3d34
	if ctx.cr[6].eq {
	pc = 0x830E3D34; continue 'dispatch;
	}
	// 830E3CFC: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 830E3D00: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830E3D04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E3D08: 4BFFFF59  bl 0x830e3c60
	ctx.lr = 0x830E3D0C;
	sub_830E3C60(ctx, base);
	// 830E3D0C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E3D10: 4182001C  beq 0x830e3d2c
	if ctx.cr[0].eq {
	pc = 0x830E3D2C; continue 'dispatch;
	}
	// 830E3D14: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E3D18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E3D1C: 4BFFBBA5  bl 0x830df8c0
	ctx.lr = 0x830E3D20;
	sub_830DF8C0(ctx, base);
	// 830E3D20: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E3D24: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830E3D28: 409AFFD4  bne cr6, 0x830e3cfc
	if !ctx.cr[6].eq {
	pc = 0x830E3CFC; continue 'dispatch;
	}
	// 830E3D2C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830E3D30: 409A000C  bne cr6, 0x830e3d3c
	if !ctx.cr[6].eq {
	pc = 0x830E3D3C; continue 'dispatch;
	}
	// 830E3D34: 3FC08000  lis r30, -0x8000
	ctx.r[30].s64 = -2147483648;
	// 830E3D38: 63DE4005  ori r30, r30, 0x4005
	ctx.r[30].u64 = ctx.r[30].u64 | 16389;
	// 830E3D3C: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 830E3D40: 419A0010  beq cr6, 0x830e3d50
	if ctx.cr[6].eq {
	pc = 0x830E3D50; continue 'dispatch;
	}
	// 830E3D44: 817CD814  lwz r11, -0x27ec(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-10220 as u32) ) } as u64;
	// 830E3D48: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830E3D4C: 917CD814  stw r11, -0x27ec(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(-10220 as u32), ctx.r[11].u32 ) };
	// 830E3D50: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E3D54: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 830E3D58: 480C445C  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E3D60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E3D60 size=692
    let mut pc: u32 = 0x830E3D60;
    'dispatch: loop {
        match pc {
            0x830E3D60 => {
    //   block [0x830E3D60..0x830E4014)
	// 830E3D60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E3D64: 480C43F1  bl 0x831a8154
	ctx.lr = 0x830E3D68;
	sub_831A8130(ctx, base);
	// 830E3D68: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E3D6C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830E3D70: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830E3D74: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 830E3D78: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 830E3D7C: 7CF73B78  mr r23, r7
	ctx.r[23].u64 = ctx.r[7].u64;
	// 830E3D80: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830E3D84: 419A0280  beq cr6, 0x830e4004
	if ctx.cr[6].eq {
	pc = 0x830E4004; continue 'dispatch;
	}
	// 830E3D88: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 830E3D8C: 419A0278  beq cr6, 0x830e4004
	if ctx.cr[6].eq {
	pc = 0x830E4004; continue 'dispatch;
	}
	// 830E3D90: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830E3D94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E3D98: 93D80000  stw r30, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 830E3D9C: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 830E3DA0: 93C10064  stw r30, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 830E3DA4: 93C10068  stw r30, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[30].u32 ) };
	// 830E3DA8: 4BFF9CC9  bl 0x830dda70
	ctx.lr = 0x830E3DAC;
	sub_830DDA70(ctx, base);
	// 830E3DAC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E3DB0: 4182002C  beq 0x830e3ddc
	if ctx.cr[0].eq {
	pc = 0x830E3DDC; continue 'dispatch;
	}
	// 830E3DB4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E3DB8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830E3DBC: 4BFE919D  bl 0x830ccf58
	ctx.lr = 0x830E3DC0;
	sub_830CCF58(ctx, base);
	// 830E3DC0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E3DC4: 4082009C  bne 0x830e3e60
	if !ctx.cr[0].eq {
	pc = 0x830E3E60; continue 'dispatch;
	}
	// 830E3DC8: 80610060  lwz r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830E3DCC: 4BFF970D  bl 0x830dd4d8
	ctx.lr = 0x830E3DD0;
	sub_830DD4D8(ctx, base);
	// 830E3DD0: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 830E3DD4: 6063000E  ori r3, r3, 0xe
	ctx.r[3].u64 = ctx.r[3].u64 | 14;
	// 830E3DD8: 48000234  b 0x830e400c
	pc = 0x830E400C; continue 'dispatch;
	// 830E3DDC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 830E3DE0: 409A001C  bne cr6, 0x830e3dfc
	if !ctx.cr[6].eq {
	pc = 0x830E3DFC; continue 'dispatch;
	}
	// 830E3DE4: 3FE08030  lis r31, -0x7fd0
	ctx.r[31].s64 = -2144337920;
	// 830E3DE8: 63FF0012  ori r31, r31, 0x12
	ctx.r[31].u64 = ctx.r[31].u64 | 18;
	// 830E3DEC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E3DF0: 4BFF96E9  bl 0x830dd4d8
	ctx.lr = 0x830E3DF4;
	sub_830DD4D8(ctx, base);
	// 830E3DF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E3DF8: 48000214  b 0x830e400c
	pc = 0x830E400C; continue 'dispatch;
	// 830E3DFC: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 830E3E00: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830E3E04: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830E3E08: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 830E3E0C: 4BFF9D15  bl 0x830ddb20
	ctx.lr = 0x830E3E10;
	sub_830DDB20(ctx, base);
	// 830E3E10: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830E3E14: 40800010  bge 0x830e3e24
	if !ctx.cr[0].lt {
	pc = 0x830E3E24; continue 'dispatch;
	}
	// 830E3E18: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830E3E1C: 4BFF96BD  bl 0x830dd4d8
	ctx.lr = 0x830E3E20;
	sub_830DD4D8(ctx, base);
	// 830E3E20: 4BFFFFCC  b 0x830e3dec
	pc = 0x830E3DEC; continue 'dispatch;
	// 830E3E24: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830E3E28: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830E3E2C: 4BFE912D  bl 0x830ccf58
	ctx.lr = 0x830E3E30;
	sub_830CCF58(ctx, base);
	// 830E3E30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E3E34: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830E3E38: 4BFF96A1  bl 0x830dd4d8
	ctx.lr = 0x830E3E3C;
	sub_830DD4D8(ctx, base);
	// 830E3E3C: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830E3E40: 409A0020  bne cr6, 0x830e3e60
	if !ctx.cr[6].eq {
	pc = 0x830E3E60; continue 'dispatch;
	}
	// 830E3E44: 3FC08007  lis r30, -0x7ff9
	ctx.r[30].s64 = -2147024896;
	// 830E3E48: 83210060  lwz r25, 0x60(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830E3E4C: 63DE000E  ori r30, r30, 0xe
	ctx.r[30].u64 = ctx.r[30].u64 | 14;
	// 830E3E50: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 830E3E54: 4BFF9685  bl 0x830dd4d8
	ctx.lr = 0x830E3E58;
	sub_830DD4D8(ctx, base);
	// 830E3E58: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E3E5C: 480001B0  b 0x830e400c
	pc = 0x830E400C; continue 'dispatch;
	// 830E3E60: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 830E3E64: 7EE6BB78  mr r6, r23
	ctx.r[6].u64 = ctx.r[23].u64;
	// 830E3E68: 83210060  lwz r25, 0x60(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830E3E6C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830E3E70: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E3E74: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 830E3E78: 4BFF88E1  bl 0x830dc758
	ctx.lr = 0x830E3E7C;
	sub_830DC758(ctx, base);
	// 830E3E7C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E3E80: 4080000C  bge 0x830e3e8c
	if !ctx.cr[0].lt {
	pc = 0x830E3E8C; continue 'dispatch;
	}
	// 830E3E84: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830E3E88: 4BFFFFC8  b 0x830e3e50
	pc = 0x830E3E50; continue 'dispatch;
	// 830E3E8C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830E3E90: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E3E94: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 830E3E98: 4BFFB939  bl 0x830df7d0
	ctx.lr = 0x830E3E9C;
	sub_830DF7D0(ctx, base);
	// 830E3E9C: 83A10058  lwz r29, 0x58(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830E3EA0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 830E3EA4: 7FBBEB78  mr r27, r29
	ctx.r[27].u64 = ctx.r[29].u64;
	// 830E3EA8: 419A0088  beq cr6, 0x830e3f30
	if ctx.cr[6].eq {
	pc = 0x830E3F30; continue 'dispatch;
	}
	// 830E3EAC: 3F808339  lis r28, -0x7cc7
	ctx.r[28].s64 = -2093416448;
	// 830E3EB0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830E3EB4: 83FCC080  lwz r31, -0x3f80(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-16256 as u32) ) } as u64;
	// 830E3EB8: 4BFEAD59  bl 0x830cec10
	ctx.lr = 0x830E3EBC;
	sub_830CEC10(ctx, base);
	// 830E3EBC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E3EC0: 4BFEACB1  bl 0x830ceb70
	ctx.lr = 0x830E3EC4;
	sub_830CEB70(ctx, base);
	// 830E3EC4: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830E3EC8: 40820020  bne 0x830e3ee8
	if !ctx.cr[0].eq {
	pc = 0x830E3EE8; continue 'dispatch;
	}
	// 830E3ECC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830E3ED0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830E3ED4: 4BFFB9ED  bl 0x830df8c0
	ctx.lr = 0x830E3ED8;
	sub_830DF8C0(ctx, base);
	// 830E3ED8: 83A10058  lwz r29, 0x58(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830E3EDC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 830E3EE0: 409AFFD0  bne cr6, 0x830e3eb0
	if !ctx.cr[6].eq {
	pc = 0x830E3EB0; continue 'dispatch;
	}
	// 830E3EE4: 48000044  b 0x830e3f28
	pc = 0x830E3F28; continue 'dispatch;
	// 830E3EE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E3EEC: 4BFEAD25  bl 0x830cec10
	ctx.lr = 0x830E3EF0;
	sub_830CEC10(ctx, base);
	// 830E3EF0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E3EF4: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830E3EF8: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 830E3EFC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830E3F00: 4BFFB9C1  bl 0x830df8c0
	ctx.lr = 0x830E3F04;
	sub_830DF8C0(ctx, base);
	// 830E3F04: 7F1DD840  cmplw cr6, r29, r27
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[27].u32, &mut ctx.xer);
	// 830E3F08: 409A0010  bne cr6, 0x830e3f18
	if !ctx.cr[6].eq {
	pc = 0x830E3F18; continue 'dispatch;
	}
	// 830E3F0C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830E3F10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830E3F14: 419A0014  beq cr6, 0x830e3f28
	if ctx.cr[6].eq {
	pc = 0x830E3F28; continue 'dispatch;
	}
	// 830E3F18: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830E3F1C: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 830E3F20: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830E3F24: 4BFFBD5D  bl 0x830dfc80
	ctx.lr = 0x830E3F28;
	sub_830DFC80(ctx, base);
	// 830E3F28: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830E3F2C: 409A0018  bne cr6, 0x830e3f44
	if !ctx.cr[6].eq {
	pc = 0x830E3F44; continue 'dispatch;
	}
	// 830E3F30: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E3F34: 4BFF58F5  bl 0x830d9828
	ctx.lr = 0x830E3F38;
	sub_830D9828(ctx, base);
	// 830E3F38: 3FC08030  lis r30, -0x7fd0
	ctx.r[30].s64 = -2144337920;
	// 830E3F3C: 63DE000A  ori r30, r30, 0xa
	ctx.r[30].u64 = ctx.r[30].u64 | 10;
	// 830E3F40: 4BFFFF10  b 0x830e3e50
	pc = 0x830E3E50; continue 'dispatch;
	// 830E3F44: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 830E3F48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E3F4C: 4BFFCADD  bl 0x830e0a28
	ctx.lr = 0x830E3F50;
	sub_830E0A28(ctx, base);
	// 830E3F50: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830E3F54: 40800014  bge 0x830e3f68
	if !ctx.cr[0].lt {
	pc = 0x830E3F68; continue 'dispatch;
	}
	// 830E3F58: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E3F5C: 4BFF58CD  bl 0x830d9828
	ctx.lr = 0x830E3F60;
	sub_830D9828(ctx, base);
	// 830E3F60: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 830E3F64: 4BFFFEEC  b 0x830e3e50
	pc = 0x830E3E50; continue 'dispatch;
	// 830E3F68: 3FA08334  lis r29, -0x7ccc
	ctx.r[29].s64 = -2093744128;
	// 830E3F6C: 807D56F8  lwz r3, 0x56f8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(22264 as u32) ) } as u64;
	// 830E3F70: 4815ED3D  bl 0x83242cac
	ctx.lr = 0x830E3F74;
	// extern call 0x83242CAC → crate::xboxkrnl::KeTlsGetValue
	crate::xboxkrnl::KeTlsGetValue(ctx, base);
	// 830E3F74: 817D56F8  lwz r11, 0x56f8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(22264 as u32) ) } as u64;
	// 830E3F78: 38830001  addi r4, r3, 1
	ctx.r[4].s64 = ctx.r[3].s64 + 1;
	// 830E3F7C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 830E3F80: 4815ED3D  bl 0x83242cbc
	ctx.lr = 0x830E3F84;
	// extern call 0x83242CBC → crate::xboxkrnl::KeTlsSetValue
	crate::xboxkrnl::KeTlsSetValue(ctx, base);
	// 830E3F84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E3F88: 4BFFB789  bl 0x830df710
	ctx.lr = 0x830E3F8C;
	sub_830DF710(ctx, base);
	// 830E3F8C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E3F90: 4BFF5899  bl 0x830d9828
	ctx.lr = 0x830E3F94;
	sub_830D9828(ctx, base);
	// 830E3F94: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 830E3F98: 807D56F8  lwz r3, 0x56f8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(22264 as u32) ) } as u64;
	// 830E3F9C: 4815ED11  bl 0x83242cac
	ctx.lr = 0x830E3FA0;
	// extern call 0x83242CAC → crate::xboxkrnl::KeTlsGetValue
	crate::xboxkrnl::KeTlsGetValue(ctx, base);
	// 830E3FA0: 817D56F8  lwz r11, 0x56f8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(22264 as u32) ) } as u64;
	// 830E3FA4: 3883FFFF  addi r4, r3, -1
	ctx.r[4].s64 = ctx.r[3].s64 + -1;
	// 830E3FA8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 830E3FAC: 4815ED11  bl 0x83242cbc
	ctx.lr = 0x830E3FB0;
	// extern call 0x83242CBC → crate::xboxkrnl::KeTlsSetValue
	crate::xboxkrnl::KeTlsSetValue(ctx, base);
	// 830E3FB0: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 830E3FB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E3FB8: 4BFFDDA9  bl 0x830e1d60
	ctx.lr = 0x830E3FBC;
	sub_830E1D60(ctx, base);
	// 830E3FBC: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830E3FC0: 40800010  bge 0x830e3fd0
	if !ctx.cr[0].lt {
	pc = 0x830E3FD0; continue 'dispatch;
	}
	// 830E3FC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E3FC8: 4BFF5861  bl 0x830d9828
	ctx.lr = 0x830E3FCC;
	sub_830D9828(ctx, base);
	// 830E3FCC: 4BFFFE84  b 0x830e3e50
	pc = 0x830E3E50; continue 'dispatch;
	// 830E3FD0: 56EB07BD  rlwinm. r11, r23, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[23].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E3FD4: 4182001C  beq 0x830e3ff0
	if ctx.cr[0].eq {
	pc = 0x830E3FF0; continue 'dispatch;
	}
	// 830E3FD8: 38800029  li r4, 0x29
	ctx.r[4].s64 = 41;
	// 830E3FDC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830E3FE0: 4801E011  bl 0x83101ff0
	ctx.lr = 0x830E3FE4;
	sub_83101FF0(ctx, base);
	// 830E3FE4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830E3FE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E3FEC: 4BFF592D  bl 0x830d9918
	ctx.lr = 0x830E3FF0;
	sub_830D9918(ctx, base);
	// 830E3FF0: 93F80000  stw r31, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 830E3FF4: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 830E3FF8: 4BFF94E1  bl 0x830dd4d8
	ctx.lr = 0x830E3FFC;
	sub_830DD4D8(ctx, base);
	// 830E3FFC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E4000: 4800000C  b 0x830e400c
	pc = 0x830E400C; continue 'dispatch;
	// 830E4004: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 830E4008: 60630057  ori r3, r3, 0x57
	ctx.r[3].u64 = ctx.r[3].u64 | 87;
	// 830E400C: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 830E4010: 480C4194  b 0x831a81a4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E4018(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830E4018 size=8
    let mut pc: u32 = 0x830E4018;
    'dispatch: loop {
        match pc {
            0x830E4018 => {
    //   block [0x830E4018..0x830E4020)
	// 830E4018: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 830E401C: 4BFFFD44  b 0x830e3d60
	sub_830E3D60(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E4020(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830E4020 size=8
    let mut pc: u32 = 0x830E4020;
    'dispatch: loop {
        match pc {
            0x830E4020 => {
    //   block [0x830E4020..0x830E4028)
	// 830E4020: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 830E4024: 4BFFFB24  b 0x830e3b48
	sub_830E3B48(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E4028(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E4028 size=228
    let mut pc: u32 = 0x830E4028;
    'dispatch: loop {
        match pc {
            0x830E4028 => {
    //   block [0x830E4028..0x830E410C)
	// 830E4028: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E402C: 480C4139  bl 0x831a8164
	ctx.lr = 0x830E4030;
	sub_831A8130(ctx, base);
	// 830E4030: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E4034: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 830E4038: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830E403C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 830E4040: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 830E4044: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 830E4048: 915C0000  stw r10, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830E404C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830E4050: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 830E4054: 557D07FE  clrlwi r29, r11, 0x1f
	ctx.r[29].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 830E4058: 4BFFDEC9  bl 0x830e1f20
	ctx.lr = 0x830E405C;
	sub_830E1F20(ctx, base);
	// 830E405C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E4060: 418000A4  blt 0x830e4104
	if ctx.cr[0].lt {
	pc = 0x830E4104; continue 'dispatch;
	}
	// 830E4064: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E4068: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 830E406C: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E4070: 41820010  beq 0x830e4080
	if ctx.cr[0].eq {
	pc = 0x830E4080; continue 'dispatch;
	}
	// 830E4074: 3C608030  lis r3, -0x7fd0
	ctx.r[3].s64 = -2144337920;
	// 830E4078: 60630025  ori r3, r3, 0x25
	ctx.r[3].u64 = ctx.r[3].u64 | 37;
	// 830E407C: 48000088  b 0x830e4104
	pc = 0x830E4104; continue 'dispatch;
	// 830E4080: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830E4084: 3BCBD7E0  addi r30, r11, -0x2820
	ctx.r[30].s64 = ctx.r[11].s64 + -10272;
	// 830E4088: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E408C: 4815E8E1  bl 0x8324296c
	ctx.lr = 0x830E4090;
	// extern call 0x8324296C → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 830E4090: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 830E4094: 81010054  lwz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830E4098: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 830E409C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 830E40A0: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 830E40A4: 409A0008  bne cr6, 0x830e40ac
	if !ctx.cr[6].eq {
	pc = 0x830E40AC; continue 'dispatch;
	}
	// 830E40A8: 7FE8FB78  mr r8, r31
	ctx.r[8].u64 = ctx.r[31].u64;
	// 830E40AC: 7FAB0034  cntlzw r11, r29
	ctx.r[11].u64 = if ctx.r[29].u32 == 0 { 32 } else { ctx.r[29].u32.leading_zeros() as u64 };
	// 830E40B0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 830E40B4: 5566DFFE  rlwinm r6, r11, 0x1b, 0x1f, 0x1f
	ctx.r[6].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830E40B8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830E40BC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830E40C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E40C4: 4BFFFA85  bl 0x830e3b48
	ctx.lr = 0x830E40C8;
	sub_830E3B48(ctx, base);
	// 830E40C8: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 830E40CC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830E40D0: 556B003C  rlwinm r11, r11, 0, 0, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830E40D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E40D8: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 830E40DC: 4815E881  bl 0x8324295c
	ctx.lr = 0x830E40E0;
	// extern call 0x8324295C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 830E40E0: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830E40E4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E40E8: 419A0018  beq cr6, 0x830e4100
	if ctx.cr[6].eq {
	pc = 0x830E4100; continue 'dispatch;
	}
	// 830E40EC: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830E40F0: 41980010  blt cr6, 0x830e4100
	if ctx.cr[6].lt {
	pc = 0x830E4100; continue 'dispatch;
	}
	// 830E40F4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830E40F8: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E40FC: 4BFFC8D5  bl 0x830e09d0
	ctx.lr = 0x830E4100;
	sub_830E09D0(ctx, base);
	// 830E4100: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830E4104: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830E4108: 480C40AC  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E4110(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E4110 size=84
    let mut pc: u32 = 0x830E4110;
    'dispatch: loop {
        match pc {
            0x830E4110 => {
    //   block [0x830E4110..0x830E4164)
	// 830E4110: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E4114: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E4118: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E411C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E4120: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E4124: 4BFFAA2D  bl 0x830deb50
	ctx.lr = 0x830E4128;
	sub_830DEB50(ctx, base);
	// 830E4128: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830E412C: 40820010  bne 0x830e413c
	if !ctx.cr[0].eq {
	pc = 0x830E413C; continue 'dispatch;
	}
	// 830E4130: 3C608030  lis r3, -0x7fd0
	ctx.r[3].s64 = -2144337920;
	// 830E4134: 6063000A  ori r3, r3, 0xa
	ctx.r[3].u64 = ctx.r[3].u64 | 10;
	// 830E4138: 48000018  b 0x830e4150
	pc = 0x830E4150; continue 'dispatch;
	// 830E413C: 80830030  lwz r4, 0x30(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 830E4140: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 830E4144: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 830E4148: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E414C: 4BFFF59D  bl 0x830e36e8
	ctx.lr = 0x830E4150;
	sub_830E36E8(ctx, base);
	// 830E4150: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830E4154: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E4158: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E415C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E4160: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E4168(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E4168 size=84
    let mut pc: u32 = 0x830E4168;
    'dispatch: loop {
        match pc {
            0x830E4168 => {
    //   block [0x830E4168..0x830E41BC)
	// 830E4168: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E416C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E4170: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E4174: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E4178: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E417C: 4BFFA9D5  bl 0x830deb50
	ctx.lr = 0x830E4180;
	sub_830DEB50(ctx, base);
	// 830E4180: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830E4184: 40820010  bne 0x830e4194
	if !ctx.cr[0].eq {
	pc = 0x830E4194; continue 'dispatch;
	}
	// 830E4188: 3C608030  lis r3, -0x7fd0
	ctx.r[3].s64 = -2144337920;
	// 830E418C: 6063000A  ori r3, r3, 0xa
	ctx.r[3].u64 = ctx.r[3].u64 | 10;
	// 830E4190: 48000018  b 0x830e41a8
	pc = 0x830E41A8; continue 'dispatch;
	// 830E4194: 80830034  lwz r4, 0x34(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) } as u64;
	// 830E4198: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830E419C: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 830E41A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E41A4: 4BFFF545  bl 0x830e36e8
	ctx.lr = 0x830E41A8;
	sub_830E36E8(ctx, base);
	// 830E41A8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830E41AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E41B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E41B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E41B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E41C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E41C0 size=84
    let mut pc: u32 = 0x830E41C0;
    'dispatch: loop {
        match pc {
            0x830E41C0 => {
    //   block [0x830E41C0..0x830E4214)
	// 830E41C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E41C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E41C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E41CC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E41D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E41D4: 4BFFA97D  bl 0x830deb50
	ctx.lr = 0x830E41D8;
	sub_830DEB50(ctx, base);
	// 830E41D8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830E41DC: 40820010  bne 0x830e41ec
	if !ctx.cr[0].eq {
	pc = 0x830E41EC; continue 'dispatch;
	}
	// 830E41E0: 3C608030  lis r3, -0x7fd0
	ctx.r[3].s64 = -2144337920;
	// 830E41E4: 6063000A  ori r3, r3, 0xa
	ctx.r[3].u64 = ctx.r[3].u64 | 10;
	// 830E41E8: 48000018  b 0x830e4200
	pc = 0x830E4200; continue 'dispatch;
	// 830E41EC: 8083002C  lwz r4, 0x2c(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 830E41F0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830E41F4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830E41F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E41FC: 4BFFF4ED  bl 0x830e36e8
	ctx.lr = 0x830E4200;
	sub_830E36E8(ctx, base);
	// 830E4200: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830E4204: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E4208: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E420C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E4210: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E4218(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E4218 size=116
    let mut pc: u32 = 0x830E4218;
    'dispatch: loop {
        match pc {
            0x830E4218 => {
    //   block [0x830E4218..0x830E428C)
	// 830E4218: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E421C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E4220: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830E4224: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E4228: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E422C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E4230: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830E4234: 4BFFA91D  bl 0x830deb50
	ctx.lr = 0x830E4238;
	sub_830DEB50(ctx, base);
	// 830E4238: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830E423C: 40820010  bne 0x830e424c
	if !ctx.cr[0].eq {
	pc = 0x830E424C; continue 'dispatch;
	}
	// 830E4240: 3C608030  lis r3, -0x7fd0
	ctx.r[3].s64 = -2144337920;
	// 830E4244: 6063000A  ori r3, r3, 0xa
	ctx.r[3].u64 = ctx.r[3].u64 | 10;
	// 830E4248: 4800002C  b 0x830e4274
	pc = 0x830E4274; continue 'dispatch;
	// 830E424C: 2B1E0003  cmplwi cr6, r30, 3
	ctx.cr[6].compare_u32(ctx.r[30].u32, 3 as u32, &mut ctx.xer);
	// 830E4250: 41980010  blt cr6, 0x830e4260
	if ctx.cr[6].lt {
	pc = 0x830E4260; continue 'dispatch;
	}
	// 830E4254: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 830E4258: 60630057  ori r3, r3, 0x57
	ctx.r[3].u64 = ctx.r[3].u64 | 87;
	// 830E425C: 48000018  b 0x830e4274
	pc = 0x830E4274; continue 'dispatch;
	// 830E4260: 80830028  lwz r4, 0x28(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 830E4264: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 830E4268: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 830E426C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E4270: 4BFFF479  bl 0x830e36e8
	ctx.lr = 0x830E4274;
	sub_830E36E8(ctx, base);
	// 830E4274: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E4278: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E427C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E4280: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830E4284: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E4288: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E4290(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E4290 size=264
    let mut pc: u32 = 0x830E4290;
    'dispatch: loop {
        match pc {
            0x830E4290 => {
    //   block [0x830E4290..0x830E4398)
	// 830E4290: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E4294: 480C3ED9  bl 0x831a816c
	ctx.lr = 0x830E4298;
	sub_831A8130(ctx, base);
	// 830E4298: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E429C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830E42A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E42A4: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830E42A8: 419800E4  blt cr6, 0x830e438c
	if ctx.cr[6].lt {
	pc = 0x830E438C; continue 'dispatch;
	}
	// 830E42AC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E42B0: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830E42B4: 409800D8  bge cr6, 0x830e438c
	if !ctx.cr[6].lt {
	pc = 0x830E438C; continue 'dispatch;
	}
	// 830E42B8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E42BC: 1FBE000C  mulli r29, r30, 0xc
	ctx.r[29].s64 = ctx.r[30].s64 * 12;
	// 830E42C0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830E42C4: 7C7D5A14  add r3, r29, r11
	ctx.r[3].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 830E42C8: 4BFE8D29  bl 0x830ccff0
	ctx.lr = 0x830E42CC;
	sub_830CCFF0(ctx, base);
	// 830E42CC: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E42D0: 396AFFFF  addi r11, r10, -1
	ctx.r[11].s64 = ctx.r[10].s64 + -1;
	// 830E42D4: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830E42D8: 419A0044  beq cr6, 0x830e431c
	if ctx.cr[6].eq {
	pc = 0x830E431C; continue 'dispatch;
	}
	// 830E42DC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E42E0: 7D5E5050  subf r10, r30, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[30].s64;
	// 830E42E4: 7C7D5A14  add r3, r29, r11
	ctx.r[3].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 830E42E8: 1D6A000C  mulli r11, r10, 0xc
	ctx.r[11].s64 = ctx.r[10].s64 * 12;
	// 830E42EC: 3883000C  addi r4, r3, 0xc
	ctx.r[4].s64 = ctx.r[3].s64 + 12;
	// 830E42F0: 38ABFFF4  addi r5, r11, -0xc
	ctx.r[5].s64 = ctx.r[11].s64 + -12;
	// 830E42F4: 480C905D  bl 0x831ad350
	ctx.lr = 0x830E42F8;
	sub_831AD350(ctx, base);
	// 830E42F8: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E42FC: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830E4300: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830E4304: 38830004  addi r4, r3, 4
	ctx.r[4].s64 = ctx.r[3].s64 + 4;
	// 830E4308: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E430C: 7D7E5850  subf r11, r30, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 830E4310: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830E4314: 38ABFFFC  addi r5, r11, -4
	ctx.r[5].s64 = ctx.r[11].s64 + -4;
	// 830E4318: 480C9039  bl 0x831ad350
	ctx.lr = 0x830E431C;
	sub_831AD350(ctx, base);
	// 830E431C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E4320: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E4324: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830E4328: 1C8B000C  mulli r4, r11, 0xc
	ctx.r[4].s64 = ctx.r[11].s64 * 12;
	// 830E432C: 4BFF91C5  bl 0x830dd4f0
	ctx.lr = 0x830E4330;
	sub_830DD4F0(ctx, base);
	// 830E4330: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830E4334: 40820010  bne 0x830e4344
	if !ctx.cr[0].eq {
	pc = 0x830E4344; continue 'dispatch;
	}
	// 830E4338: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E433C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830E4340: 409A0008  bne cr6, 0x830e4348
	if !ctx.cr[6].eq {
	pc = 0x830E4348; continue 'dispatch;
	}
	// 830E4344: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 830E4348: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E434C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E4350: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830E4354: 5564103A  slwi r4, r11, 2
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 830E4358: 4BFF9199  bl 0x830dd4f0
	ctx.lr = 0x830E435C;
	sub_830DD4F0(ctx, base);
	// 830E435C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830E4360: 40820010  bne 0x830e4370
	if !ctx.cr[0].eq {
	pc = 0x830E4370; continue 'dispatch;
	}
	// 830E4364: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E4368: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830E436C: 409A0008  bne cr6, 0x830e4374
	if !ctx.cr[6].eq {
	pc = 0x830E4374; continue 'dispatch;
	}
	// 830E4370: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 830E4374: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E4378: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830E437C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830E4380: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830E4384: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 830E4388: 48000008  b 0x830e4390
	pc = 0x830E4390; continue 'dispatch;
	// 830E438C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E4390: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E4394: 480C3E28  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E4398(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E4398 size=264
    let mut pc: u32 = 0x830E4398;
    'dispatch: loop {
        match pc {
            0x830E4398 => {
    //   block [0x830E4398..0x830E44A0)
	// 830E4398: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E439C: 480C3DD1  bl 0x831a816c
	ctx.lr = 0x830E43A0;
	sub_831A8130(ctx, base);
	// 830E43A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E43A4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830E43A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E43AC: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830E43B0: 419800E4  blt cr6, 0x830e4494
	if ctx.cr[6].lt {
	pc = 0x830E4494; continue 'dispatch;
	}
	// 830E43B4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E43B8: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830E43BC: 409800D8  bge cr6, 0x830e4494
	if !ctx.cr[6].lt {
	pc = 0x830E4494; continue 'dispatch;
	}
	// 830E43C0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E43C4: 1FBE000C  mulli r29, r30, 0xc
	ctx.r[29].s64 = ctx.r[30].s64 * 12;
	// 830E43C8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830E43CC: 7C7D5A14  add r3, r29, r11
	ctx.r[3].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 830E43D0: 4BFE8C21  bl 0x830ccff0
	ctx.lr = 0x830E43D4;
	sub_830CCFF0(ctx, base);
	// 830E43D4: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E43D8: 396AFFFF  addi r11, r10, -1
	ctx.r[11].s64 = ctx.r[10].s64 + -1;
	// 830E43DC: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830E43E0: 419A0044  beq cr6, 0x830e4424
	if ctx.cr[6].eq {
	pc = 0x830E4424; continue 'dispatch;
	}
	// 830E43E4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E43E8: 7D5E5050  subf r10, r30, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[30].s64;
	// 830E43EC: 7C7D5A14  add r3, r29, r11
	ctx.r[3].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 830E43F0: 1D6A000C  mulli r11, r10, 0xc
	ctx.r[11].s64 = ctx.r[10].s64 * 12;
	// 830E43F4: 3883000C  addi r4, r3, 0xc
	ctx.r[4].s64 = ctx.r[3].s64 + 12;
	// 830E43F8: 38ABFFF4  addi r5, r11, -0xc
	ctx.r[5].s64 = ctx.r[11].s64 + -12;
	// 830E43FC: 480C8F55  bl 0x831ad350
	ctx.lr = 0x830E4400;
	sub_831AD350(ctx, base);
	// 830E4400: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E4404: 57CB1838  slwi r11, r30, 3
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830E4408: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830E440C: 38830008  addi r4, r3, 8
	ctx.r[4].s64 = ctx.r[3].s64 + 8;
	// 830E4410: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E4414: 7D7E5850  subf r11, r30, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 830E4418: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830E441C: 38ABFFF8  addi r5, r11, -8
	ctx.r[5].s64 = ctx.r[11].s64 + -8;
	// 830E4420: 480C8F31  bl 0x831ad350
	ctx.lr = 0x830E4424;
	sub_831AD350(ctx, base);
	// 830E4424: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E4428: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E442C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830E4430: 1C8B000C  mulli r4, r11, 0xc
	ctx.r[4].s64 = ctx.r[11].s64 * 12;
	// 830E4434: 4BFF90BD  bl 0x830dd4f0
	ctx.lr = 0x830E4438;
	sub_830DD4F0(ctx, base);
	// 830E4438: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830E443C: 40820010  bne 0x830e444c
	if !ctx.cr[0].eq {
	pc = 0x830E444C; continue 'dispatch;
	}
	// 830E4440: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E4444: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830E4448: 409A0008  bne cr6, 0x830e4450
	if !ctx.cr[6].eq {
	pc = 0x830E4450; continue 'dispatch;
	}
	// 830E444C: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 830E4450: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E4454: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E4458: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830E445C: 55641838  slwi r4, r11, 3
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 830E4460: 4BFF9091  bl 0x830dd4f0
	ctx.lr = 0x830E4464;
	sub_830DD4F0(ctx, base);
	// 830E4464: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830E4468: 40820010  bne 0x830e4478
	if !ctx.cr[0].eq {
	pc = 0x830E4478; continue 'dispatch;
	}
	// 830E446C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E4470: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830E4474: 409A0008  bne cr6, 0x830e447c
	if !ctx.cr[6].eq {
	pc = 0x830E447C; continue 'dispatch;
	}
	// 830E4478: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 830E447C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E4480: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830E4484: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830E4488: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830E448C: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 830E4490: 48000008  b 0x830e4498
	pc = 0x830E4498; continue 'dispatch;
	// 830E4494: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E4498: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E449C: 480C3D20  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E44A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E44A0 size=108
    let mut pc: u32 = 0x830E44A0;
    'dispatch: loop {
        match pc {
            0x830E44A0 => {
    //   block [0x830E44A0..0x830E450C)
	// 830E44A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E44A4: 480C3CC5  bl 0x831a8168
	ctx.lr = 0x830E44A8;
	sub_831A8130(ctx, base);
	// 830E44A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E44AC: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830E44B0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 830E44B4: 3BCBD818  addi r30, r11, -0x27e8
	ctx.r[30].s64 = ctx.r[11].s64 + -10216;
	// 830E44B8: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E44BC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E44C0: 4099003C  ble cr6, 0x830e44fc
	if !ctx.cr[6].gt {
	pc = 0x830E44FC; continue 'dispatch;
	}
	// 830E44C4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830E44C8: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E44CC: 7FFD502E  lwzx r31, r29, r10
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830E44D0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830E44D4: 419A0018  beq cr6, 0x830e44ec
	if ctx.cr[6].eq {
	pc = 0x830E44EC; continue 'dispatch;
	}
	// 830E44D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E44DC: 4BFFEE6D  bl 0x830e3348
	ctx.lr = 0x830E44E0;
	sub_830E3348(ctx, base);
	// 830E44E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E44E4: 4BFF8FF5  bl 0x830dd4d8
	ctx.lr = 0x830E44E8;
	sub_830DD4D8(ctx, base);
	// 830E44E8: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E44EC: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 830E44F0: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 830E44F4: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830E44F8: 4198FFD0  blt cr6, 0x830e44c8
	if ctx.cr[6].lt {
	pc = 0x830E44C8; continue 'dispatch;
	}
	// 830E44FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E4500: 4BFF9A99  bl 0x830ddf98
	ctx.lr = 0x830E4504;
	sub_830DDF98(ctx, base);
	// 830E4504: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830E4508: 480C3CB0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E4510(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E4510 size=492
    let mut pc: u32 = 0x830E4510;
    'dispatch: loop {
        match pc {
            0x830E4510 => {
    //   block [0x830E4510..0x830E46FC)
	// 830E4510: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E4514: 480C3C51  bl 0x831a8164
	ctx.lr = 0x830E4518;
	sub_831A8130(ctx, base);
	// 830E4518: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E451C: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 830E4520: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 830E4524: 579E063E  clrlwi r30, r28, 0x18
	ctx.r[30].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 830E4528: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 830E452C: 2B1E0004  cmplwi cr6, r30, 4
	ctx.cr[6].compare_u32(ctx.r[30].u32, 4 as u32, &mut ctx.xer);
	// 830E4530: 4198001C  blt cr6, 0x830e454c
	if ctx.cr[6].lt {
	pc = 0x830E454C; continue 'dispatch;
	}
	// 830E4534: 2B1E00FF  cmplwi cr6, r30, 0xff
	ctx.cr[6].compare_u32(ctx.r[30].u32, 255 as u32, &mut ctx.xer);
	// 830E4538: 419A0014  beq cr6, 0x830e454c
	if ctx.cr[6].eq {
	pc = 0x830E454C; continue 'dispatch;
	}
	// 830E453C: 2B1E00FE  cmplwi cr6, r30, 0xfe
	ctx.cr[6].compare_u32(ctx.r[30].u32, 254 as u32, &mut ctx.xer);
	// 830E4540: 419A000C  beq cr6, 0x830e454c
	if ctx.cr[6].eq {
	pc = 0x830E454C; continue 'dispatch;
	}
	// 830E4544: 2B1E00FD  cmplwi cr6, r30, 0xfd
	ctx.cr[6].compare_u32(ctx.r[30].u32, 253 as u32, &mut ctx.xer);
	// 830E4548: 409A01A4  bne cr6, 0x830e46ec
	if !ctx.cr[6].eq {
	pc = 0x830E46EC; continue 'dispatch;
	}
	// 830E454C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830E4550: 419A019C  beq cr6, 0x830e46ec
	if ctx.cr[6].eq {
	pc = 0x830E46EC; continue 'dispatch;
	}
	// 830E4554: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 830E4558: 419A0194  beq cr6, 0x830e46ec
	if ctx.cr[6].eq {
	pc = 0x830E46EC; continue 'dispatch;
	}
	// 830E455C: 4BFEA6B5  bl 0x830cec10
	ctx.lr = 0x830E4560;
	sub_830CEC10(ctx, base);
	// 830E4560: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E4564: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830E4568: 4BFEA6A9  bl 0x830cec10
	ctx.lr = 0x830E456C;
	sub_830CEC10(ctx, base);
	// 830E456C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830E4570: 2B1E00FD  cmplwi cr6, r30, 0xfd
	ctx.cr[6].compare_u32(ctx.r[30].u32, 253 as u32, &mut ctx.xer);
	// 830E4574: 409A0024  bne cr6, 0x830e4598
	if !ctx.cr[6].eq {
	pc = 0x830E4598; continue 'dispatch;
	}
	// 830E4578: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E457C: 3BC000FF  li r30, 0xff
	ctx.r[30].s64 = 255;
	// 830E4580: 4BFFCF31  bl 0x830e14b0
	ctx.lr = 0x830E4584;
	sub_830E14B0(ctx, base);
	// 830E4584: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830E4588: 4182000C  beq 0x830e4594
	if ctx.cr[0].eq {
	pc = 0x830E4594; continue 'dispatch;
	}
	// 830E458C: 4BFFA975  bl 0x830def00
	ctx.lr = 0x830E4590;
	sub_830DEF00(ctx, base);
	// 830E4590: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830E4594: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 830E4598: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830E459C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 830E45A0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830E45A4: 4BFFC245  bl 0x830e07e8
	ctx.lr = 0x830E45A8;
	sub_830E07E8(ctx, base);
	// 830E45A8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830E45AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E45B0: 4BFF1619  bl 0x830d5bc8
	ctx.lr = 0x830E45B4;
	sub_830D5BC8(ctx, base);
	// 830E45B4: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830E45B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830E45BC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830E45C0: 409A000C  bne cr6, 0x830e45cc
	if !ctx.cr[6].eq {
	pc = 0x830E45CC; continue 'dispatch;
	}
	// 830E45C4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830E45C8: 4800012C  b 0x830e46f4
	pc = 0x830E46F4; continue 'dispatch;
	// 830E45CC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E45D0: 4BFFC619  bl 0x830e0be8
	ctx.lr = 0x830E45D4;
	sub_830E0BE8(ctx, base);
	// 830E45D4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830E45D8: 41820010  beq 0x830e45e8
	if ctx.cr[0].eq {
	pc = 0x830E45E8; continue 'dispatch;
	}
	// 830E45DC: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 830E45E0: 6063FFFF  ori r3, r3, 0xffff
	ctx.r[3].u64 = ctx.r[3].u64 | 65535;
	// 830E45E4: 48000110  b 0x830e46f4
	pc = 0x830E46F4; continue 'dispatch;
	// 830E45E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E45EC: 4BFFD335  bl 0x830e1920
	ctx.lr = 0x830E45F0;
	sub_830E1920(ctx, base);
	// 830E45F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830E45F4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E45F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E45FC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830E4600: 4BFFB159  bl 0x830df758
	ctx.lr = 0x830E4604;
	sub_830DF758(ctx, base);
	// 830E4604: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E4608: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830E460C: 409A0050  bne cr6, 0x830e465c
	if !ctx.cr[6].eq {
	pc = 0x830E465C; continue 'dispatch;
	}
	// 830E4610: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E4614: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E4618: 4BFFB141  bl 0x830df758
	ctx.lr = 0x830E461C;
	sub_830DF758(ctx, base);
	// 830E461C: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E4620: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 830E4624: 409A0010  bne cr6, 0x830e4634
	if !ctx.cr[6].eq {
	pc = 0x830E4634; continue 'dispatch;
	}
	// 830E4628: 3C608030  lis r3, -0x7fd0
	ctx.r[3].s64 = -2144337920;
	// 830E462C: 6063000B  ori r3, r3, 0xb
	ctx.r[3].u64 = ctx.r[3].u64 | 11;
	// 830E4630: 480000C4  b 0x830e46f4
	pc = 0x830E46F4; continue 'dispatch;
	// 830E4634: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E4638: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E463C: 4BFFB285  bl 0x830df8c0
	ctx.lr = 0x830E4640;
	sub_830DF8C0(ctx, base);
	// 830E4640: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830E4644: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830E4648: 80C10050  lwz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E464C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830E4650: 4BFFB361  bl 0x830df9b0
	ctx.lr = 0x830E4654;
	sub_830DF9B0(ctx, base);
	// 830E4654: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E4658: 4180009C  blt 0x830e46f4
	if ctx.cr[0].lt {
	pc = 0x830E46F4; continue 'dispatch;
	}
	// 830E465C: 38800029  li r4, 0x29
	ctx.r[4].s64 = 41;
	// 830E4660: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830E4664: 4801D98D  bl 0x83101ff0
	ctx.lr = 0x830E4668;
	sub_83101FF0(ctx, base);
	// 830E4668: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830E466C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E4670: 4BFF52A9  bl 0x830d9918
	ctx.lr = 0x830E4674;
	sub_830D9918(ctx, base);
	// 830E4674: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 830E4678: 2B0B00FE  cmplwi cr6, r11, 0xfe
	ctx.cr[6].compare_u32(ctx.r[11].u32, 254 as u32, &mut ctx.xer);
	// 830E467C: 419A0014  beq cr6, 0x830e4690
	if ctx.cr[6].eq {
	pc = 0x830E4690; continue 'dispatch;
	}
	// 830E4680: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830E4684: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830E4688: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E468C: 4BFFF5D5  bl 0x830e3c60
	ctx.lr = 0x830E4690;
	sub_830E3C60(ctx, base);
	// 830E4690: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830E4694: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E4698: 4BFFAF89  bl 0x830df620
	ctx.lr = 0x830E469C;
	sub_830DF620(ctx, base);
	// 830E469C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830E46A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E46A4: 4BFFAF7D  bl 0x830df620
	ctx.lr = 0x830E46A8;
	sub_830DF620(ctx, base);
	// 830E46A8: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830E46AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E46B0: 808BC080  lwz r4, -0x3f80(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16256 as u32) ) } as u64;
	// 830E46B4: 4BFFA435  bl 0x830deae8
	ctx.lr = 0x830E46B8;
	sub_830DEAE8(ctx, base);
	// 830E46B8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830E46BC: 41820008  beq 0x830e46c4
	if ctx.cr[0].eq {
	pc = 0x830E46C4; continue 'dispatch;
	}
	// 830E46C0: 93C30024  stw r30, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[30].u32 ) };
	// 830E46C4: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 830E46C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E46CC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830E46D0: 409A0008  bne cr6, 0x830e46d8
	if !ctx.cr[6].eq {
	pc = 0x830E46D8; continue 'dispatch;
	}
	// 830E46D4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830E46D8: 4BFFFB41  bl 0x830e4218
	ctx.lr = 0x830E46DC;
	sub_830E4218(ctx, base);
	// 830E46DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E46E0: 4BFFFAE1  bl 0x830e41c0
	ctx.lr = 0x830E46E4;
	sub_830E41C0(ctx, base);
	// 830E46E4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E46E8: 4800000C  b 0x830e46f4
	pc = 0x830E46F4; continue 'dispatch;
	// 830E46EC: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 830E46F0: 60630057  ori r3, r3, 0x57
	ctx.r[3].u64 = ctx.r[3].u64 | 87;
	// 830E46F4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 830E46F8: 480C3ABC  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E4700(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E4700 size=552
    let mut pc: u32 = 0x830E4700;
    'dispatch: loop {
        match pc {
            0x830E4700 => {
    //   block [0x830E4700..0x830E4928)
	// 830E4700: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E4704: 480C3A61  bl 0x831a8164
	ctx.lr = 0x830E4708;
	sub_831A8130(ctx, base);
	// 830E4708: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E470C: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 830E4710: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830E4714: 577D063E  clrlwi r29, r27, 0x18
	ctx.r[29].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	// 830E4718: 2B1D0004  cmplwi cr6, r29, 4
	ctx.cr[6].compare_u32(ctx.r[29].u32, 4 as u32, &mut ctx.xer);
	// 830E471C: 4198001C  blt cr6, 0x830e4738
	if ctx.cr[6].lt {
	pc = 0x830E4738; continue 'dispatch;
	}
	// 830E4720: 2B1D00FF  cmplwi cr6, r29, 0xff
	ctx.cr[6].compare_u32(ctx.r[29].u32, 255 as u32, &mut ctx.xer);
	// 830E4724: 419A0014  beq cr6, 0x830e4738
	if ctx.cr[6].eq {
	pc = 0x830E4738; continue 'dispatch;
	}
	// 830E4728: 2B1D00FE  cmplwi cr6, r29, 0xfe
	ctx.cr[6].compare_u32(ctx.r[29].u32, 254 as u32, &mut ctx.xer);
	// 830E472C: 419A000C  beq cr6, 0x830e4738
	if ctx.cr[6].eq {
	pc = 0x830E4738; continue 'dispatch;
	}
	// 830E4730: 2B1D00FD  cmplwi cr6, r29, 0xfd
	ctx.cr[6].compare_u32(ctx.r[29].u32, 253 as u32, &mut ctx.xer);
	// 830E4734: 409A01E4  bne cr6, 0x830e4918
	if !ctx.cr[6].eq {
	pc = 0x830E4918; continue 'dispatch;
	}
	// 830E4738: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830E473C: 419A01DC  beq cr6, 0x830e4918
	if ctx.cr[6].eq {
	pc = 0x830E4918; continue 'dispatch;
	}
	// 830E4740: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830E4744: 419A01D4  beq cr6, 0x830e4918
	if ctx.cr[6].eq {
	pc = 0x830E4918; continue 'dispatch;
	}
	// 830E4748: 4BFEA4C9  bl 0x830cec10
	ctx.lr = 0x830E474C;
	sub_830CEC10(ctx, base);
	// 830E474C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830E4750: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E4754: 4BFEA4BD  bl 0x830cec10
	ctx.lr = 0x830E4758;
	sub_830CEC10(ctx, base);
	// 830E4758: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E475C: 2B1D00FD  cmplwi cr6, r29, 0xfd
	ctx.cr[6].compare_u32(ctx.r[29].u32, 253 as u32, &mut ctx.xer);
	// 830E4760: 409A0024  bne cr6, 0x830e4784
	if !ctx.cr[6].eq {
	pc = 0x830E4784; continue 'dispatch;
	}
	// 830E4764: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E4768: 3BA000FF  li r29, 0xff
	ctx.r[29].s64 = 255;
	// 830E476C: 4BFFCD45  bl 0x830e14b0
	ctx.lr = 0x830E4770;
	sub_830E14B0(ctx, base);
	// 830E4770: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830E4774: 4182000C  beq 0x830e4780
	if ctx.cr[0].eq {
	pc = 0x830E4780; continue 'dispatch;
	}
	// 830E4778: 4BFFA789  bl 0x830def00
	ctx.lr = 0x830E477C;
	sub_830DEF00(ctx, base);
	// 830E477C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830E4780: 7FBBEB78  mr r27, r29
	ctx.r[27].u64 = ctx.r[29].u64;
	// 830E4784: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E4788: 48003B79  bl 0x830e8300
	ctx.lr = 0x830E478C;
	sub_830E8300(ctx, base);
	// 830E478C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830E4790: 7F1DF840  cmplw cr6, r29, r31
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[31].u32, &mut ctx.xer);
	// 830E4794: 419A0018  beq cr6, 0x830e47ac
	if ctx.cr[6].eq {
	pc = 0x830E47AC; continue 'dispatch;
	}
	// 830E4798: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830E479C: 419A00A0  beq cr6, 0x830e483c
	if ctx.cr[6].eq {
	pc = 0x830E483C; continue 'dispatch;
	}
	// 830E47A0: 48003B61  bl 0x830e8300
	ctx.lr = 0x830E47A4;
	sub_830E8300(ctx, base);
	// 830E47A4: 7F03F840  cmplw cr6, r3, r31
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[31].u32, &mut ctx.xer);
	// 830E47A8: 409AFFF0  bne cr6, 0x830e4798
	if !ctx.cr[6].eq {
	pc = 0x830E4798; continue 'dispatch;
	}
	// 830E47AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E47B0: 4BFFD171  bl 0x830e1920
	ctx.lr = 0x830E47B4;
	sub_830E1920(ctx, base);
	// 830E47B4: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 830E47B8: 419A0040  beq cr6, 0x830e47f8
	if ctx.cr[6].eq {
	pc = 0x830E47F8; continue 'dispatch;
	}
	// 830E47BC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E47C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E47C4: 4BFFC425  bl 0x830e0be8
	ctx.lr = 0x830E47C8;
	sub_830E0BE8(ctx, base);
	// 830E47C8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830E47CC: 7F1DF840  cmplw cr6, r29, r31
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[31].u32, &mut ctx.xer);
	// 830E47D0: 419A0028  beq cr6, 0x830e47f8
	if ctx.cr[6].eq {
	pc = 0x830E47F8; continue 'dispatch;
	}
	// 830E47D4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830E47D8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830E47DC: 4BFFC40D  bl 0x830e0be8
	ctx.lr = 0x830E47E0;
	sub_830E0BE8(ctx, base);
	// 830E47E0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 830E47E4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830E47E8: 4BFF5041  bl 0x830d9828
	ctx.lr = 0x830E47EC;
	sub_830D9828(ctx, base);
	// 830E47EC: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 830E47F0: 7F1CF840  cmplw cr6, r28, r31
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[31].u32, &mut ctx.xer);
	// 830E47F4: 409AFFE0  bne cr6, 0x830e47d4
	if !ctx.cr[6].eq {
	pc = 0x830E47D4; continue 'dispatch;
	}
	// 830E47F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830E47FC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E4800: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E4804: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830E4808: 4BFFAF51  bl 0x830df758
	ctx.lr = 0x830E480C;
	sub_830DF758(ctx, base);
	// 830E480C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E4810: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830E4814: 409A0074  bne cr6, 0x830e4888
	if !ctx.cr[6].eq {
	pc = 0x830E4888; continue 'dispatch;
	}
	// 830E4818: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E481C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E4820: 4BFFAF39  bl 0x830df758
	ctx.lr = 0x830E4824;
	sub_830DF758(ctx, base);
	// 830E4824: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E4828: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 830E482C: 409A001C  bne cr6, 0x830e4848
	if !ctx.cr[6].eq {
	pc = 0x830E4848; continue 'dispatch;
	}
	// 830E4830: 3C608030  lis r3, -0x7fd0
	ctx.r[3].s64 = -2144337920;
	// 830E4834: 6063000B  ori r3, r3, 0xb
	ctx.r[3].u64 = ctx.r[3].u64 | 11;
	// 830E4838: 480000E8  b 0x830e4920
	pc = 0x830E4920; continue 'dispatch;
	// 830E483C: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 830E4840: 6063FFFF  ori r3, r3, 0xffff
	ctx.r[3].u64 = ctx.r[3].u64 | 65535;
	// 830E4844: 480000DC  b 0x830e4920
	pc = 0x830E4920; continue 'dispatch;
	// 830E4848: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E484C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E4850: 4BFFB0E9  bl 0x830df938
	ctx.lr = 0x830E4854;
	sub_830DF938(ctx, base);
	// 830E4854: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 830E4858: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E485C: 80A10050  lwz r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E4860: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830E4864: 4BFFB14D  bl 0x830df9b0
	ctx.lr = 0x830E4868;
	sub_830DF9B0(ctx, base);
	// 830E4868: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E486C: 418000B4  blt 0x830e4920
	if ctx.cr[0].lt {
	pc = 0x830E4920; continue 'dispatch;
	}
	// 830E4870: 38800029  li r4, 0x29
	ctx.r[4].s64 = 41;
	// 830E4874: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830E4878: 4801D779  bl 0x83101ff0
	ctx.lr = 0x830E487C;
	sub_83101FF0(ctx, base);
	// 830E487C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830E4880: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E4884: 4BFF5095  bl 0x830d9918
	ctx.lr = 0x830E4888;
	sub_830D9918(ctx, base);
	// 830E4888: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E488C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E4890: 4BFFCFF1  bl 0x830e1880
	ctx.lr = 0x830E4894;
	sub_830E1880(ctx, base);
	// 830E4894: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830E4898: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 830E489C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830E48A0: 4BFFBF99  bl 0x830e0838
	ctx.lr = 0x830E48A4;
	sub_830E0838(ctx, base);
	// 830E48A4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830E48A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E48AC: 4BFF131D  bl 0x830d5bc8
	ctx.lr = 0x830E48B0;
	sub_830D5BC8(ctx, base);
	// 830E48B0: 576B063E  clrlwi r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	// 830E48B4: 2B0B00FE  cmplwi cr6, r11, 0xfe
	ctx.cr[6].compare_u32(ctx.r[11].u32, 254 as u32, &mut ctx.xer);
	// 830E48B8: 419A0014  beq cr6, 0x830e48cc
	if ctx.cr[6].eq {
	pc = 0x830E48CC; continue 'dispatch;
	}
	// 830E48BC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830E48C0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830E48C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E48C8: 4BFFF399  bl 0x830e3c60
	ctx.lr = 0x830E48CC;
	sub_830E3C60(ctx, base);
	// 830E48CC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830E48D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E48D4: 4BFFAD4D  bl 0x830df620
	ctx.lr = 0x830E48D8;
	sub_830DF620(ctx, base);
	// 830E48D8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830E48DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E48E0: 4BFFAD41  bl 0x830df620
	ctx.lr = 0x830E48E4;
	sub_830DF620(ctx, base);
	// 830E48E4: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830E48E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E48EC: 808BC080  lwz r4, -0x3f80(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16256 as u32) ) } as u64;
	// 830E48F0: 4BFFA1F9  bl 0x830deae8
	ctx.lr = 0x830E48F4;
	sub_830DEAE8(ctx, base);
	// 830E48F4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830E48F8: 41820008  beq 0x830e4900
	if ctx.cr[0].eq {
	pc = 0x830E4900; continue 'dispatch;
	}
	// 830E48FC: 93C30024  stw r30, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[30].u32 ) };
	// 830E4900: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E4904: 4BFFF80D  bl 0x830e4110
	ctx.lr = 0x830E4908;
	sub_830E4110(ctx, base);
	// 830E4908: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E490C: 4BFFF85D  bl 0x830e4168
	ctx.lr = 0x830E4910;
	sub_830E4168(ctx, base);
	// 830E4910: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E4914: 4800000C  b 0x830e4920
	pc = 0x830E4920; continue 'dispatch;
	// 830E4918: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 830E491C: 60630057  ori r3, r3, 0x57
	ctx.r[3].u64 = ctx.r[3].u64 | 87;
	// 830E4920: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 830E4924: 480C3890  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E4928(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E4928 size=180
    let mut pc: u32 = 0x830E4928;
    'dispatch: loop {
        match pc {
            0x830E4928 => {
    //   block [0x830E4928..0x830E49DC)
	// 830E4928: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E492C: 480C3841  bl 0x831a816c
	ctx.lr = 0x830E4930;
	sub_831A8130(ctx, base);
	// 830E4930: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E4934: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E4938: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830E493C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E4940: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E4944: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830E4948: 409A0050  bne cr6, 0x830e4998
	if !ctx.cr[6].eq {
	pc = 0x830E4998; continue 'dispatch;
	}
	// 830E494C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E4950: 409A000C  bne cr6, 0x830e495c
	if !ctx.cr[6].eq {
	pc = 0x830E495C; continue 'dispatch;
	}
	// 830E4954: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 830E4958: 4800001C  b 0x830e4974
	pc = 0x830E4974; continue 'dispatch;
	// 830E495C: 557E083D  rlwinm. r30, r11, 1, 0, 0x1e
	ctx.r[30].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830E4960: 40810028  ble 0x830e4988
	if !ctx.cr[0].gt {
	pc = 0x830E4988; continue 'dispatch;
	}
	// 830E4964: 3D600AAA  lis r11, 0xaaa
	ctx.r[11].s64 = 178913280;
	// 830E4968: 616BAAAA  ori r11, r11, 0xaaaa
	ctx.r[11].u64 = ctx.r[11].u64 | 43690;
	// 830E496C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830E4970: 40980018  bge cr6, 0x830e4988
	if !ctx.cr[6].lt {
	pc = 0x830E4988; continue 'dispatch;
	}
	// 830E4974: 1C9E000C  mulli r4, r30, 0xc
	ctx.r[4].s64 = ctx.r[30].s64 * 12;
	// 830E4978: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E497C: 4BFF8B75  bl 0x830dd4f0
	ctx.lr = 0x830E4980;
	sub_830DD4F0(ctx, base);
	// 830E4980: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830E4984: 4082000C  bne 0x830e4990
	if !ctx.cr[0].eq {
	pc = 0x830E4990; continue 'dispatch;
	}
	// 830E4988: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E498C: 48000048  b 0x830e49d4
	pc = 0x830E49D4; continue 'dispatch;
	// 830E4990: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 830E4994: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 830E4998: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E499C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E49A0: 1D6B000C  mulli r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 * 12;
	// 830E49A4: 7D6B5215  add. r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E49A8: 4182001C  beq 0x830e49c4
	if ctx.cr[0].eq {
	pc = 0x830E49C4; continue 'dispatch;
	}
	// 830E49AC: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E49B0: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830E49B4: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E49B8: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 830E49BC: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E49C0: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830E49C4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E49C8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830E49CC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830E49D0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830E49D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E49D8: 480C37E4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E49E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E49E0 size=164
    let mut pc: u32 = 0x830E49E0;
    'dispatch: loop {
        match pc {
            0x830E49E0 => {
    //   block [0x830E49E0..0x830E4A84)
	// 830E49E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E49E4: 480C3785  bl 0x831a8168
	ctx.lr = 0x830E49E8;
	sub_831A8130(ctx, base);
	// 830E49E8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E49EC: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830E49F0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830E49F4: 3B8BD7A8  addi r28, r11, -0x2858
	ctx.r[28].s64 = ctx.r[11].s64 + -10328;
	// 830E49F8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830E49FC: 4815DF71  bl 0x8324296c
	ctx.lr = 0x830E4A00;
	// extern call 0x8324296C → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 830E4A00: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830E4A04: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830E4A08: 3BEBD828  addi r31, r11, -0x27d8
	ctx.r[31].s64 = ctx.r[11].s64 + -10200;
	// 830E4A0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E4A10: 4BFF9351  bl 0x830ddd60
	ctx.lr = 0x830E4A14;
	sub_830DDD60(ctx, base);
	// 830E4A14: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E4A18: 40800020  bge 0x830e4a38
	if !ctx.cr[0].lt {
	pc = 0x830E4A38; continue 'dispatch;
	}
	// 830E4A1C: 3FE08000  lis r31, -0x8000
	ctx.r[31].s64 = -2147483648;
	// 830E4A20: 63FF4005  ori r31, r31, 0x4005
	ctx.r[31].u64 = ctx.r[31].u64 | 16389;
	// 830E4A24: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830E4A28: 4815DF35  bl 0x8324295c
	ctx.lr = 0x830E4A2C;
	// extern call 0x8324295C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 830E4A2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E4A30: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830E4A34: 480C3784  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
	// 830E4A38: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E4A3C: 546A1838  slwi r10, r3, 3
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830E4A40: 7FCA5A14  add r30, r10, r11
	ctx.r[30].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 830E4A44: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830E4A48: 4801E539  bl 0x83102f80
	ctx.lr = 0x830E4A4C;
	sub_83102F80(ctx, base);
	// 830E4A4C: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E4A50: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830E4A54: 419A0008  beq cr6, 0x830e4a5c
	if ctx.cr[6].eq {
	pc = 0x830E4A5C; continue 'dispatch;
	}
	// 830E4A58: 4801E529  bl 0x83102f80
	ctx.lr = 0x830E4A5C;
	sub_83102F80(ctx, base);
	// 830E4A5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E4A60: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830E4A64: 4BFF92FD  bl 0x830ddd60
	ctx.lr = 0x830E4A68;
	sub_830DDD60(ctx, base);
	// 830E4A68: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830E4A6C: 2F04FFFF  cmpwi cr6, r4, -1
	ctx.cr[6].compare_i32(ctx.r[4].s32, -1, &mut ctx.xer);
	// 830E4A70: 419A000C  beq cr6, 0x830e4a7c
	if ctx.cr[6].eq {
	pc = 0x830E4A7C; continue 'dispatch;
	}
	// 830E4A74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E4A78: 4BFFF921  bl 0x830e4398
	ctx.lr = 0x830E4A7C;
	sub_830E4398(ctx, base);
	// 830E4A7C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 830E4A80: 4BFFFFA4  b 0x830e4a24
	pc = 0x830E4A24; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E4A88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E4A88 size=116
    let mut pc: u32 = 0x830E4A88;
    'dispatch: loop {
        match pc {
            0x830E4A88 => {
    //   block [0x830E4A88..0x830E4AFC)
	// 830E4A88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E4A8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E4A90: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E4A94: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E4A98: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830E4A9C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E4AA0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830E4AA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830E4AA8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 830E4AAC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 830E4AB0: 4BFE84A9  bl 0x830ccf58
	ctx.lr = 0x830E4AB4;
	sub_830CCF58(ctx, base);
	// 830E4AB4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E4AB8: 40820014  bne 0x830e4acc
	if !ctx.cr[0].eq {
	pc = 0x830E4ACC; continue 'dispatch;
	}
	// 830E4ABC: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E4AC0: 4BFF8A19  bl 0x830dd4d8
	ctx.lr = 0x830E4AC4;
	sub_830DD4D8(ctx, base);
	// 830E4AC4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E4AC8: 48000020  b 0x830e4ae8
	pc = 0x830E4AE8; continue 'dispatch;
	// 830E4ACC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E4AD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E4AD4: 4BFFFE55  bl 0x830e4928
	ctx.lr = 0x830E4AD8;
	sub_830E4928(ctx, base);
	// 830E4AD8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E4ADC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E4AE0: 4BFF89F9  bl 0x830dd4d8
	ctx.lr = 0x830E4AE4;
	sub_830DD4D8(ctx, base);
	// 830E4AE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E4AE8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E4AEC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E4AF0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E4AF4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E4AF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E4B00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E4B00 size=452
    let mut pc: u32 = 0x830E4B00;
    'dispatch: loop {
        match pc {
            0x830E4B00 => {
    //   block [0x830E4B00..0x830E4CC4)
	// 830E4B00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E4B04: 480C3659  bl 0x831a815c
	ctx.lr = 0x830E4B08;
	sub_831A8130(ctx, base);
	// 830E4B08: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E4B0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E4B10: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 830E4B14: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 830E4B18: 4BFFD381  bl 0x830e1e98
	ctx.lr = 0x830E4B1C;
	sub_830E1E98(ctx, base);
	// 830E4B1C: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830E4B20: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 830E4B24: 3B2BD7C4  addi r25, r11, -0x283c
	ctx.r[25].s64 = ctx.r[11].s64 + -10300;
	// 830E4B28: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 830E4B2C: 4815DE41  bl 0x8324296c
	ctx.lr = 0x830E4B30;
	// extern call 0x8324296C → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 830E4B30: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 830E4B34: 409A0044  bne cr6, 0x830e4b78
	if !ctx.cr[6].eq {
	pc = 0x830E4B78; continue 'dispatch;
	}
	// 830E4B38: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830E4B3C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E4B40: 3BEBD838  addi r31, r11, -0x27c8
	ctx.r[31].s64 = ctx.r[11].s64 + -10184;
	// 830E4B44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E4B48: 4BFE8411  bl 0x830ccf58
	ctx.lr = 0x830E4B4C;
	sub_830CCF58(ctx, base);
	// 830E4B4C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E4B50: 41820158  beq 0x830e4ca8
	if ctx.cr[0].eq {
	pc = 0x830E4CA8; continue 'dispatch;
	}
	// 830E4B54: 83DF000C  lwz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830E4B58: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830E4B5C: 419A0014  beq cr6, 0x830e4b70
	if ctx.cr[6].eq {
	pc = 0x830E4B70; continue 'dispatch;
	}
	// 830E4B60: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E4B64: 4801F1D5  bl 0x83103d38
	ctx.lr = 0x830E4B68;
	sub_83103D38(ctx, base);
	// 830E4B68: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E4B6C: 4BFF896D  bl 0x830dd4d8
	ctx.lr = 0x830E4B70;
	sub_830DD4D8(ctx, base);
	// 830E4B70: 935F000C  stw r26, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[26].u32 ) };
	// 830E4B74: 4800013C  b 0x830e4cb0
	pc = 0x830E4CB0; continue 'dispatch;
	// 830E4B78: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830E4B7C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830E4B80: 3BABD818  addi r29, r11, -0x27e8
	ctx.r[29].s64 = ctx.r[11].s64 + -10216;
	// 830E4B84: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830E4B88: 4BFF91D9  bl 0x830ddd60
	ctx.lr = 0x830E4B8C;
	sub_830DDD60(ctx, base);
	// 830E4B8C: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 830E4B90: 409A0090  bne cr6, 0x830e4c20
	if !ctx.cr[6].eq {
	pc = 0x830E4C20; continue 'dispatch;
	}
	// 830E4B94: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830E4B98: 419A0118  beq cr6, 0x830e4cb0
	if ctx.cr[6].eq {
	pc = 0x830E4CB0; continue 'dispatch;
	}
	// 830E4B9C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 830E4BA0: 4BFF8911  bl 0x830dd4b0
	ctx.lr = 0x830E4BA4;
	sub_830DD4B0(ctx, base);
	// 830E4BA4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830E4BA8: 4182001C  beq 0x830e4bc4
	if ctx.cr[0].eq {
	pc = 0x830E4BC4; continue 'dispatch;
	}
	// 830E4BAC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830E4BB0: 93830000  stw r28, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 830E4BB4: 93830004  stw r28, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 830E4BB8: 93830008  stw r28, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 830E4BBC: 9383000C  stw r28, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	// 830E4BC0: 48000008  b 0x830e4bc8
	pc = 0x830E4BC8; continue 'dispatch;
	// 830E4BC4: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 830E4BC8: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 830E4BCC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830E4BD0: 419A00D8  beq cr6, 0x830e4ca8
	if ctx.cr[6].eq {
	pc = 0x830E4CA8; continue 'dispatch;
	}
	// 830E4BD4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E4BD8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E4BDC: 4BFE837D  bl 0x830ccf58
	ctx.lr = 0x830E4BE0;
	sub_830CCF58(ctx, base);
	// 830E4BE0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E4BE4: 41820020  beq 0x830e4c04
	if ctx.cr[0].eq {
	pc = 0x830E4C04; continue 'dispatch;
	}
	// 830E4BE8: 935E000C  stw r26, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[26].u32 ) };
	// 830E4BEC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830E4BF0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830E4BF4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830E4BF8: 4BFE8651  bl 0x830cd248
	ctx.lr = 0x830E4BFC;
	sub_830CD248(ctx, base);
	// 830E4BFC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E4C00: 408200B0  bne 0x830e4cb0
	if !ctx.cr[0].eq {
	pc = 0x830E4CB0; continue 'dispatch;
	}
	// 830E4C04: 3F808007  lis r28, -0x7ff9
	ctx.r[28].s64 = -2147024896;
	// 830E4C08: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E4C0C: 639C000E  ori r28, r28, 0xe
	ctx.r[28].u64 = ctx.r[28].u64 | 14;
	// 830E4C10: 4BFFE739  bl 0x830e3348
	ctx.lr = 0x830E4C14;
	sub_830E3348(ctx, base);
	// 830E4C14: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E4C18: 4BFF88C1  bl 0x830dd4d8
	ctx.lr = 0x830E4C1C;
	sub_830DD4D8(ctx, base);
	// 830E4C1C: 48000094  b 0x830e4cb0
	pc = 0x830E4CB0; continue 'dispatch;
	// 830E4C20: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E4C24: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830E4C28: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830E4C2C: 7FCA582E  lwzx r30, r10, r11
	ctx.r[30].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830E4C30: 409A0040  bne cr6, 0x830e4c70
	if !ctx.cr[6].eq {
	pc = 0x830E4C70; continue 'dispatch;
	}
	// 830E4C34: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830E4C38: 419A0014  beq cr6, 0x830e4c4c
	if ctx.cr[6].eq {
	pc = 0x830E4C4C; continue 'dispatch;
	}
	// 830E4C3C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E4C40: 4BFFE709  bl 0x830e3348
	ctx.lr = 0x830E4C44;
	sub_830E3348(ctx, base);
	// 830E4C44: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E4C48: 4BFF8891  bl 0x830dd4d8
	ctx.lr = 0x830E4C4C;
	sub_830DD4D8(ctx, base);
	// 830E4C4C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830E4C50: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830E4C54: 4BFF910D  bl 0x830ddd60
	ctx.lr = 0x830E4C58;
	sub_830DDD60(ctx, base);
	// 830E4C58: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830E4C5C: 2F04FFFF  cmpwi cr6, r4, -1
	ctx.cr[6].compare_i32(ctx.r[4].s32, -1, &mut ctx.xer);
	// 830E4C60: 419A0050  beq cr6, 0x830e4cb0
	if ctx.cr[6].eq {
	pc = 0x830E4CB0; continue 'dispatch;
	}
	// 830E4C64: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830E4C68: 4BFFF629  bl 0x830e4290
	ctx.lr = 0x830E4C6C;
	sub_830E4290(ctx, base);
	// 830E4C6C: 48000044  b 0x830e4cb0
	pc = 0x830E4CB0; continue 'dispatch;
	// 830E4C70: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E4C74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E4C78: 4BFE82E1  bl 0x830ccf58
	ctx.lr = 0x830E4C7C;
	sub_830CCF58(ctx, base);
	// 830E4C7C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E4C80: 41820028  beq 0x830e4ca8
	if ctx.cr[0].eq {
	pc = 0x830E4CA8; continue 'dispatch;
	}
	// 830E4C84: 83FE000C  lwz r31, 0xc(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 830E4C88: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830E4C8C: 419A0014  beq cr6, 0x830e4ca0
	if ctx.cr[6].eq {
	pc = 0x830E4CA0; continue 'dispatch;
	}
	// 830E4C90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E4C94: 4801F0A5  bl 0x83103d38
	ctx.lr = 0x830E4C98;
	sub_83103D38(ctx, base);
	// 830E4C98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E4C9C: 4BFF883D  bl 0x830dd4d8
	ctx.lr = 0x830E4CA0;
	sub_830DD4D8(ctx, base);
	// 830E4CA0: 935E000C  stw r26, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[26].u32 ) };
	// 830E4CA4: 4800000C  b 0x830e4cb0
	pc = 0x830E4CB0; continue 'dispatch;
	// 830E4CA8: 3F808007  lis r28, -0x7ff9
	ctx.r[28].s64 = -2147024896;
	// 830E4CAC: 639C000E  ori r28, r28, 0xe
	ctx.r[28].u64 = ctx.r[28].u64 | 14;
	// 830E4CB0: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 830E4CB4: 4815DCA9  bl 0x8324295c
	ctx.lr = 0x830E4CB8;
	// extern call 0x8324295C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 830E4CB8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830E4CBC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830E4CC0: 480C34EC  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E4CC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E4CC8 size=332
    let mut pc: u32 = 0x830E4CC8;
    'dispatch: loop {
        match pc {
            0x830E4CC8 => {
    //   block [0x830E4CC8..0x830E4E14)
	// 830E4CC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E4CCC: 480C3491  bl 0x831a815c
	ctx.lr = 0x830E4CD0;
	sub_831A8130(ctx, base);
	// 830E4CD0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E4CD4: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830E4CD8: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 830E4CDC: 3B2BD7A8  addi r25, r11, -0x2858
	ctx.r[25].s64 = ctx.r[11].s64 + -10328;
	// 830E4CE0: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 830E4CE4: 4815DC89  bl 0x8324296c
	ctx.lr = 0x830E4CE8;
	// extern call 0x8324296C → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 830E4CE8: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 830E4CEC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 830E4CF0: 409A005C  bne cr6, 0x830e4d4c
	if !ctx.cr[6].eq {
	pc = 0x830E4D4C; continue 'dispatch;
	}
	// 830E4CF4: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830E4CF8: 3BCBD828  addi r30, r11, -0x27d8
	ctx.r[30].s64 = ctx.r[11].s64 + -10200;
	// 830E4CFC: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E4D00: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E4D04: 4099003C  ble cr6, 0x830e4d40
	if !ctx.cr[6].gt {
	pc = 0x830E4D40; continue 'dispatch;
	}
	// 830E4D08: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 830E4D0C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E4D10: 7FBF5A14  add r29, r31, r11
	ctx.r[29].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 830E4D14: 7C7F582E  lwzx r3, r31, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830E4D18: 4801E269  bl 0x83102f80
	ctx.lr = 0x830E4D1C;
	sub_83102F80(ctx, base);
	// 830E4D1C: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E4D20: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830E4D24: 419A0008  beq cr6, 0x830e4d2c
	if ctx.cr[6].eq {
	pc = 0x830E4D2C; continue 'dispatch;
	}
	// 830E4D28: 4801E259  bl 0x83102f80
	ctx.lr = 0x830E4D2C;
	sub_83102F80(ctx, base);
	// 830E4D2C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E4D30: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 830E4D34: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 830E4D38: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830E4D3C: 4198FFD0  blt cr6, 0x830e4d0c
	if ctx.cr[6].lt {
	pc = 0x830E4D0C; continue 'dispatch;
	}
	// 830E4D40: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E4D44: 4BFF9255  bl 0x830ddf98
	ctx.lr = 0x830E4D48;
	sub_830DDF98(ctx, base);
	// 830E4D48: 480000BC  b 0x830e4e04
	pc = 0x830E4E04; continue 'dispatch;
	// 830E4D4C: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 830E4D50: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 830E4D54: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830E4D58: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 830E4D5C: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 830E4D60: 480C4369  bl 0x831a90c8
	ctx.lr = 0x830E4D64;
	sub_831A90C8(ctx, base);
	// 830E4D64: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830E4D68: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 830E4D6C: 3BEBD828  addi r31, r11, -0x27d8
	ctx.r[31].s64 = ctx.r[11].s64 + -10200;
	// 830E4D70: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E4D74: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E4D78: 40990058  ble cr6, 0x830e4dd0
	if !ctx.cr[6].gt {
	pc = 0x830E4DD0; continue 'dispatch;
	}
	// 830E4D7C: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 830E4D80: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E4D84: 7FDD5A14  add r30, r29, r11
	ctx.r[30].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 830E4D88: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E4D8C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E4D90: 419A0028  beq cr6, 0x830e4db8
	if ctx.cr[6].eq {
	pc = 0x830E4DB8; continue 'dispatch;
	}
	// 830E4D94: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 830E4D98: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E4D9C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830E4DA0: 480CD609  bl 0x831b23a8
	ctx.lr = 0x830E4DA4;
	sub_831B23A8(ctx, base);
	// 830E4DA4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E4DA8: 40820010  bne 0x830e4db8
	if !ctx.cr[0].eq {
	pc = 0x830E4DB8; continue 'dispatch;
	}
	// 830E4DAC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830E4DB0: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E4DB4: 4BFFFCD5  bl 0x830e4a88
	ctx.lr = 0x830E4DB8;
	sub_830E4A88(ctx, base);
	// 830E4DB8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E4DBC: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 830E4DC0: 3BBD000C  addi r29, r29, 0xc
	ctx.r[29].s64 = ctx.r[29].s64 + 12;
	// 830E4DC4: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830E4DC8: 4198FFB8  blt cr6, 0x830e4d80
	if ctx.cr[6].lt {
	pc = 0x830E4D80; continue 'dispatch;
	}
	// 830E4DCC: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830E4DD0: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830E4DD4: 4099001C  ble cr6, 0x830e4df0
	if !ctx.cr[6].gt {
	pc = 0x830E4DF0; continue 'dispatch;
	}
	// 830E4DD8: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E4DDC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E4DE0: 4BFFFC01  bl 0x830e49e0
	ctx.lr = 0x830E4DE4;
	sub_830E49E0(ctx, base);
	// 830E4DE4: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830E4DE8: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 830E4DEC: 4082FFF0  bne 0x830e4ddc
	if !ctx.cr[0].eq {
	pc = 0x830E4DDC; continue 'dispatch;
	}
	// 830E4DF0: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 830E4DF4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E4DF8: 4BFFFD09  bl 0x830e4b00
	ctx.lr = 0x830E4DFC;
	sub_830E4B00(ctx, base);
	// 830E4DFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830E4E00: 4BFF67F9  bl 0x830db5f8
	ctx.lr = 0x830E4E04;
	sub_830DB5F8(ctx, base);
	// 830E4E04: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 830E4E08: 4815DB55  bl 0x8324295c
	ctx.lr = 0x830E4E0C;
	// extern call 0x8324295C → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 830E4E0C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830E4E10: 480C339C  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E4E18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E4E18 size=88
    let mut pc: u32 = 0x830E4E18;
    'dispatch: loop {
        match pc {
            0x830E4E18 => {
    //   block [0x830E4E18..0x830E4E70)
	// 830E4E18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E4E1C: 480C3351  bl 0x831a816c
	ctx.lr = 0x830E4E20;
	sub_831A8130(ctx, base);
	// 830E4E20: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E4E24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E4E28: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 830E4E2C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830E4E30: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 830E4E34: 4BFF867D  bl 0x830dd4b0
	ctx.lr = 0x830E4E38;
	sub_830DD4B0(ctx, base);
	// 830E4E38: 7C6B1B79  or. r11, r3, r3
	ctx.r[11].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E4E3C: 40820014  bne 0x830e4e50
	if !ctx.cr[0].eq {
	pc = 0x830E4E50; continue 'dispatch;
	}
	// 830E4E40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E4E44: 4BFE869D  bl 0x830cd4e0
	ctx.lr = 0x830E4E48;
	sub_830CD4E0(ctx, base);
	// 830E4E48: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E4E4C: 4800001C  b 0x830e4e68
	pc = 0x830E4E68; continue 'dispatch;
	// 830E4E50: B3CB0000  sth r30, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u16 ) };
	// 830E4E54: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830E4E58: B3AB0002  sth r29, 2(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(2 as u32), ctx.r[29].u16 ) };
	// 830E4E5C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E4E60: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 830E4E64: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830E4E68: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E4E6C: 480C3350  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E4E70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E4E70 size=272
    let mut pc: u32 = 0x830E4E70;
    'dispatch: loop {
        match pc {
            0x830E4E70 => {
    //   block [0x830E4E70..0x830E4F80)
	// 830E4E70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E4E74: 480C32F1  bl 0x831a8164
	ctx.lr = 0x830E4E78;
	sub_831A8130(ctx, base);
	// 830E4E78: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E4E7C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830E4E80: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830E4E84: 4BFE865D  bl 0x830cd4e0
	ctx.lr = 0x830E4E88;
	sub_830CD4E0(ctx, base);
	// 830E4E88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E4E8C: 480C423D  bl 0x831a90c8
	ctx.lr = 0x830E4E90;
	sub_831A90C8(ctx, base);
	// 830E4E90: 7C7C1B79  or. r28, r3, r3
	ctx.r[28].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 830E4E94: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830E4E98: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830E4E9C: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 830E4EA0: 41820098  beq 0x830e4f38
	if ctx.cr[0].eq {
	pc = 0x830E4F38; continue 'dispatch;
	}
	// 830E4EA4: A0BF0000  lhz r5, 0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E4EA8: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 830E4EAC: 2B0B002D  cmplwi cr6, r11, 0x2d
	ctx.cr[6].compare_u32(ctx.r[11].u32, 45 as u32, &mut ctx.xer);
	// 830E4EB0: 409A0028  bne cr6, 0x830e4ed8
	if !ctx.cr[6].eq {
	pc = 0x830E4ED8; continue 'dispatch;
	}
	// 830E4EB4: 397CFFFF  addi r11, r28, -1
	ctx.r[11].s64 = ctx.r[28].s64 + -1;
	// 830E4EB8: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830E4EBC: 419A004C  beq cr6, 0x830e4f08
	if ctx.cr[6].eq {
	pc = 0x830E4F08; continue 'dispatch;
	}
	// 830E4EC0: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830E4EC4: 409A00A8  bne cr6, 0x830e4f6c
	if !ctx.cr[6].eq {
	pc = 0x830E4F6C; continue 'dispatch;
	}
	// 830E4EC8: 548B043F  clrlwi. r11, r4, 0x10
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x0000FFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E4ECC: 418200A0  beq 0x830e4f6c
	if ctx.cr[0].eq {
	pc = 0x830E4F6C; continue 'dispatch;
	}
	// 830E4ED0: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 830E4ED4: 48000054  b 0x830e4f28
	pc = 0x830E4F28; continue 'dispatch;
	// 830E4ED8: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830E4EDC: 419A002C  beq cr6, 0x830e4f08
	if ctx.cr[6].eq {
	pc = 0x830E4F08; continue 'dispatch;
	}
	// 830E4EE0: 548A043E  clrlwi r10, r4, 0x10
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x0000FFFFu64;
	// 830E4EE4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E4EE8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830E4EEC: 41990084  bgt cr6, 0x830e4f70
	if ctx.cr[6].gt {
	pc = 0x830E4F70; continue 'dispatch;
	}
	// 830E4EF0: 4BFFFF29  bl 0x830e4e18
	ctx.lr = 0x830E4EF4;
	sub_830E4E18(ctx, base);
	// 830E4EF4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E4EF8: 41820068  beq 0x830e4f60
	if ctx.cr[0].eq {
	pc = 0x830E4F60; continue 'dispatch;
	}
	// 830E4EFC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830E4F00: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830E4F04: 48000024  b 0x830e4f28
	pc = 0x830E4F28; continue 'dispatch;
	// 830E4F08: 548B043F  clrlwi. r11, r4, 0x10
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x0000FFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E4F0C: 41820018  beq 0x830e4f24
	if ctx.cr[0].eq {
	pc = 0x830E4F24; continue 'dispatch;
	}
	// 830E4F10: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 830E4F14: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E4F18: 4BFFFF01  bl 0x830e4e18
	ctx.lr = 0x830E4F1C;
	sub_830E4E18(ctx, base);
	// 830E4F1C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E4F20: 41820040  beq 0x830e4f60
	if ctx.cr[0].eq {
	pc = 0x830E4F60; continue 'dispatch;
	}
	// 830E4F24: A09F0000  lhz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E4F28: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 830E4F2C: 3BFF0002  addi r31, r31, 2
	ctx.r[31].s64 = ctx.r[31].s64 + 2;
	// 830E4F30: 7F1BE040  cmplw cr6, r27, r28
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[28].u32, &mut ctx.xer);
	// 830E4F34: 4198FF70  blt cr6, 0x830e4ea4
	if ctx.cr[6].lt {
	pc = 0x830E4EA4; continue 'dispatch;
	}
	// 830E4F38: 548B043F  clrlwi. r11, r4, 0x10
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x0000FFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E4F3C: 41820018  beq 0x830e4f54
	if ctx.cr[0].eq {
	pc = 0x830E4F54; continue 'dispatch;
	}
	// 830E4F40: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 830E4F44: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E4F48: 4BFFFED1  bl 0x830e4e18
	ctx.lr = 0x830E4F4C;
	sub_830E4E18(ctx, base);
	// 830E4F4C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E4F50: 41820010  beq 0x830e4f60
	if ctx.cr[0].eq {
	pc = 0x830E4F60; continue 'dispatch;
	}
	// 830E4F54: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E4F58: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830E4F5C: 480C3258  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
	// 830E4F60: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 830E4F64: 6063000E  ori r3, r3, 0xe
	ctx.r[3].u64 = ctx.r[3].u64 | 14;
	// 830E4F68: 4BFFFFF0  b 0x830e4f58
	pc = 0x830E4F58; continue 'dispatch;
	// 830E4F6C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E4F70: 4BFE8571  bl 0x830cd4e0
	ctx.lr = 0x830E4F74;
	sub_830CD4E0(ctx, base);
	// 830E4F74: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 830E4F78: 60630057  ori r3, r3, 0x57
	ctx.r[3].u64 = ctx.r[3].u64 | 87;
	// 830E4F7C: 4BFFFFDC  b 0x830e4f58
	pc = 0x830E4F58; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E4F80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E4F80 size=76
    let mut pc: u32 = 0x830E4F80;
    'dispatch: loop {
        match pc {
            0x830E4F80 => {
    //   block [0x830E4F80..0x830E4FCC)
	// 830E4F80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E4F84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E4F88: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E4F8C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E4F90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E4F94: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E4F98: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830E4F9C: 419A001C  beq cr6, 0x830e4fb8
	if ctx.cr[6].eq {
	pc = 0x830E4FB8; continue 'dispatch;
	}
	// 830E4FA0: 4802B4C1  bl 0x83110460
	ctx.lr = 0x830E4FA4;
	sub_83110460(ctx, base);
	// 830E4FA4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830E4FA8: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830E4FAC: 817F0084  lwz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 830E4FB0: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 830E4FB4: 917F0084  stw r11, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 830E4FB8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830E4FBC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E4FC0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E4FC4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E4FC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E4FD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E4FD0 size=100
    let mut pc: u32 = 0x830E4FD0;
    'dispatch: loop {
        match pc {
            0x830E4FD0 => {
    //   block [0x830E4FD0..0x830E5034)
	// 830E4FD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E4FD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E4FD8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830E4FDC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E4FE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E4FE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E4FE8: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 830E4FEC: 817F00F4  lwz r11, 0xf4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 830E4FF0: 616B0002  ori r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u64 | 2;
	// 830E4FF4: 917F00F4  stw r11, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 830E4FF8: 4BFF9F09  bl 0x830def00
	ctx.lr = 0x830E4FFC;
	sub_830DEF00(ctx, base);
	// 830E4FFC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830E5000: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E5004: 4BFE9C0D  bl 0x830cec10
	ctx.lr = 0x830E5008;
	sub_830CEC10(ctx, base);
	// 830E5008: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830E500C: 4BFFDC15  bl 0x830e2c20
	ctx.lr = 0x830E5010;
	sub_830E2C20(ctx, base);
	// 830E5010: 817F00F4  lwz r11, 0xf4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 830E5014: 556B07FA  rlwinm r11, r11, 0, 0x1f, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830E5018: 917F00F4  stw r11, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 830E501C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E5020: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E5024: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E5028: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830E502C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E5030: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E5038(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E5038 size=108
    let mut pc: u32 = 0x830E5038;
    'dispatch: loop {
        match pc {
            0x830E5038 => {
    //   block [0x830E5038..0x830E50A4)
	// 830E5038: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E503C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E5040: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E5044: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 830E5048: 80AB0024  lwz r5, 0x24(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 830E504C: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 830E5050: 419A0040  beq cr6, 0x830e5090
	if ctx.cr[6].eq {
	pc = 0x830E5090; continue 'dispatch;
	}
	// 830E5054: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 830E5058: 554907BC  rlwinm r9, r10, 0, 0x1e, 0x1e
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 830E505C: 2B090002  cmplwi cr6, r9, 2
	ctx.cr[6].compare_u32(ctx.r[9].u32, 2 as u32, &mut ctx.xer);
	// 830E5060: 409A000C  bne cr6, 0x830e506c
	if !ctx.cr[6].eq {
	pc = 0x830E506C; continue 'dispatch;
	}
	// 830E5064: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830E5068: 4800002C  b 0x830e5094
	pc = 0x830E5094; continue 'dispatch;
	// 830E506C: 812B001C  lwz r9, 0x1c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 830E5070: 614A0002  ori r10, r10, 2
	ctx.r[10].u64 = ctx.r[10].u64 | 2;
	// 830E5074: 908B002C  stw r4, 0x2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[4].u32 ) };
	// 830E5078: 3C80AABB  lis r4, -0x5545
	ctx.r[4].s64 = -1430585344;
	// 830E507C: 914B0048  stw r10, 0x48(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(72 as u32), ctx.r[10].u32 ) };
	// 830E5080: 6084CCDD  ori r4, r4, 0xccdd
	ctx.r[4].u64 = ctx.r[4].u64 | 52445;
	// 830E5084: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E5088: 912B0028  stw r9, 0x28(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 830E508C: 4801AE6D  bl 0x830ffef8
	ctx.lr = 0x830E5090;
	sub_830FFEF8(ctx, base);
	// 830E5090: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E5094: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830E5098: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E509C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E50A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E50A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E50A8 size=80
    let mut pc: u32 = 0x830E50A8;
    'dispatch: loop {
        match pc {
            0x830E50A8 => {
    //   block [0x830E50A8..0x830E50F8)
	// 830E50A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E50AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E50B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E50B4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E50B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E50BC: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 830E50C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830E50C4: 419A0020  beq cr6, 0x830e50e4
	if ctx.cr[6].eq {
	pc = 0x830E50E4; continue 'dispatch;
	}
	// 830E50C8: 3C80AABB  lis r4, -0x5545
	ctx.r[4].s64 = -1430585344;
	// 830E50CC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E50D0: 6084CCDD  ori r4, r4, 0xccdd
	ctx.r[4].u64 = ctx.r[4].u64 | 52445;
	// 830E50D4: 4801AEE5  bl 0x830fffb8
	ctx.lr = 0x830E50D8;
	sub_830FFFB8(ctx, base);
	// 830E50D8: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 830E50DC: 556B07FA  rlwinm r11, r11, 0, 0x1f, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830E50E0: 917F0048  stw r11, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 830E50E4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830E50E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E50EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E50F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E50F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E50F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830E50F8 size=12
    let mut pc: u32 = 0x830E50F8;
    'dispatch: loop {
        match pc {
            0x830E50F8 => {
    //   block [0x830E50F8..0x830E5104)
	// 830E50F8: 3D608218  lis r11, -0x7de8
	ctx.r[11].s64 = -2112356352;
	// 830E50FC: 386B7B64  addi r3, r11, 0x7b64
	ctx.r[3].s64 = ctx.r[11].s64 + 31588;
	// 830E5100: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E5108(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E5108 size=112
    let mut pc: u32 = 0x830E5108;
    'dispatch: loop {
        match pc {
            0x830E5108 => {
    //   block [0x830E5108..0x830E5178)
	// 830E5108: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E510C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E5110: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830E5114: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E5118: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E511C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E5120: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830E5124: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E5128: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830E512C: 817F00F0  lwz r11, 0xf0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 830E5130: 556B0398  rlwinm r11, r11, 0, 0xe, 0xc
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830E5134: 917F00F0  stw r11, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 830E5138: 419A0028  beq cr6, 0x830e5160
	if ctx.cr[6].eq {
	pc = 0x830E5160; continue 'dispatch;
	}
	// 830E513C: 817F00F4  lwz r11, 0xf4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 830E5140: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830E5144: 419A001C  beq cr6, 0x830e5160
	if ctx.cr[6].eq {
	pc = 0x830E5160; continue 'dispatch;
	}
	// 830E5148: 389F00A4  addi r4, r31, 0xa4
	ctx.r[4].s64 = ctx.r[31].s64 + 164;
	// 830E514C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E5150: 4802B169  bl 0x831102b8
	ctx.lr = 0x830E5154;
	sub_831102B8(ctx, base);
	// 830E5154: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E5158: 809F00F4  lwz r4, 0xf4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 830E515C: 4803074D  bl 0x831158a8
	ctx.lr = 0x830E5160;
	sub_831158A8(ctx, base);
	// 830E5160: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E5164: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E5168: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E516C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830E5170: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E5174: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E5178(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E5178 size=192
    let mut pc: u32 = 0x830E5178;
    'dispatch: loop {
        match pc {
            0x830E5178 => {
    //   block [0x830E5178..0x830E5238)
	// 830E5178: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E517C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E5180: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830E5184: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E5188: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E518C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830E5190: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830E5194: 4BFF9955  bl 0x830deae8
	ctx.lr = 0x830E5198;
	sub_830DEAE8(ctx, base);
	// 830E5198: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830E519C: 816BC0E8  lwz r11, -0x3f18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16152 as u32) ) } as u64;
	// 830E51A0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830E51A4: 419A0074  beq cr6, 0x830e5218
	if ctx.cr[6].eq {
	pc = 0x830E5218; continue 'dispatch;
	}
	// 830E51A8: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830E51AC: 816BC0EC  lwz r11, -0x3f14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16148 as u32) ) } as u64;
	// 830E51B0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830E51B4: 419A0064  beq cr6, 0x830e5218
	if ctx.cr[6].eq {
	pc = 0x830E5218; continue 'dispatch;
	}
	// 830E51B8: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830E51BC: 816BC0F0  lwz r11, -0x3f10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16144 as u32) ) } as u64;
	// 830E51C0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830E51C4: 419A0054  beq cr6, 0x830e5218
	if ctx.cr[6].eq {
	pc = 0x830E5218; continue 'dispatch;
	}
	// 830E51C8: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830E51CC: 816BC0F4  lwz r11, -0x3f0c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16140 as u32) ) } as u64;
	// 830E51D0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830E51D4: 419A0044  beq cr6, 0x830e5218
	if ctx.cr[6].eq {
	pc = 0x830E5218; continue 'dispatch;
	}
	// 830E51D8: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830E51DC: 816BC0F8  lwz r11, -0x3f08(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16136 as u32) ) } as u64;
	// 830E51E0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830E51E4: 419A0034  beq cr6, 0x830e5218
	if ctx.cr[6].eq {
	pc = 0x830E5218; continue 'dispatch;
	}
	// 830E51E8: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830E51EC: 816BC0FC  lwz r11, -0x3f04(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16132 as u32) ) } as u64;
	// 830E51F0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830E51F4: 419A0024  beq cr6, 0x830e5218
	if ctx.cr[6].eq {
	pc = 0x830E5218; continue 'dispatch;
	}
	// 830E51F8: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830E51FC: 816BC100  lwz r11, -0x3f00(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16128 as u32) ) } as u64;
	// 830E5200: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830E5204: 419A0014  beq cr6, 0x830e5218
	if ctx.cr[6].eq {
	pc = 0x830E5218; continue 'dispatch;
	}
	// 830E5208: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830E520C: 816BC104  lwz r11, -0x3efc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16124 as u32) ) } as u64;
	// 830E5210: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830E5214: 409A0008  bne cr6, 0x830e521c
	if !ctx.cr[6].eq {
	pc = 0x830E521C; continue 'dispatch;
	}
	// 830E5218: 3BC30004  addi r30, r3, 4
	ctx.r[30].s64 = ctx.r[3].s64 + 4;
	// 830E521C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E5220: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E5224: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E5228: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E522C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830E5230: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E5234: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E5238(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E5238 size=148
    let mut pc: u32 = 0x830E5238;
    'dispatch: loop {
        match pc {
            0x830E5238 => {
    //   block [0x830E5238..0x830E52CC)
	// 830E5238: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E523C: 480C2F31  bl 0x831a816c
	ctx.lr = 0x830E5240;
	sub_831A8130(ctx, base);
	// 830E5240: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E5244: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830E5248: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E524C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E5250: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E5254: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830E5258: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E525C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830E5260: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E5264: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 830E5268: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E526C: 4802B28D  bl 0x831104f8
	ctx.lr = 0x830E5270;
	sub_831104F8(ctx, base);
	// 830E5270: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830E5274: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E5278: 4802B2A9  bl 0x83110520
	ctx.lr = 0x830E527C;
	sub_83110520(ctx, base);
	// 830E527C: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E5280: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E5284: 4802B24D  bl 0x831104d0
	ctx.lr = 0x830E5288;
	sub_831104D0(ctx, base);
	// 830E5288: 83BE000C  lwz r29, 0xc(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 830E528C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 830E5290: 419A0030  beq cr6, 0x830e52c0
	if ctx.cr[6].eq {
	pc = 0x830E52C0; continue 'dispatch;
	}
	// 830E5294: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E5298: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830E529C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E52A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830E52A4: 419A0008  beq cr6, 0x830e52ac
	if ctx.cr[6].eq {
	pc = 0x830E52AC; continue 'dispatch;
	}
	// 830E52A8: 389D0004  addi r4, r29, 4
	ctx.r[4].s64 = ctx.r[29].s64 + 4;
	// 830E52AC: 4802B725  bl 0x831109d0
	ctx.lr = 0x830E52B0;
	sub_831109D0(ctx, base);
	// 830E52B0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830E52B4: 4BFF8225  bl 0x830dd4d8
	ctx.lr = 0x830E52B8;
	sub_830DD4D8(ctx, base);
	// 830E52B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830E52BC: 917E000C  stw r11, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 830E52C0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E52C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E52C8: 480C2EF4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E52D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830E52D0 size=228
    let mut pc: u32 = 0x830E52D0;
    'dispatch: loop {
        match pc {
            0x830E52D0 => {
    //   block [0x830E52D0..0x830E53B4)
	// 830E52D0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 830E52D4: 812B00E8  lwz r9, 0xe8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(232 as u32) ) } as u64;
	// 830E52D8: 80CB00F0  lwz r6, 0xf0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(240 as u32) ) } as u64;
	// 830E52DC: 7127000A  andi. r7, r9, 0xa
	ctx.r[7].u64 = ctx.r[9].u64 & 10;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 830E52E0: 3907FFF6  addi r8, r7, -0xa
	ctx.r[8].s64 = ctx.r[7].s64 + -10;
	// 830E52E4: 54CAE7FF  rlwinm. r10, r6, 0x1c, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[6].u32 as u64 & 0x0000000Fu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830E52E8: 7D080034  cntlzw r8, r8
	ctx.r[8].u64 = if ctx.r[8].u32 == 0 { 32 } else { ctx.r[8].u32.leading_zeros() as u64 };
	// 830E52EC: 5508DFFE  rlwinm r8, r8, 0x1b, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x0000001Fu64;
	// 830E52F0: 40820018  bne 0x830e5308
	if !ctx.cr[0].eq {
	pc = 0x830E5308; continue 'dispatch;
	}
	// 830E52F4: 71250005  andi. r5, r9, 5
	ctx.r[5].u64 = ctx.r[9].u64 & 5;
	ctx.cr[0].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 830E52F8: 2B050005  cmplwi cr6, r5, 5
	ctx.cr[6].compare_u32(ctx.r[5].u32, 5 as u32, &mut ctx.xer);
	// 830E52FC: 409A000C  bne cr6, 0x830e5308
	if !ctx.cr[6].eq {
	pc = 0x830E5308; continue 'dispatch;
	}
	// 830E5300: 55250673  rlwinm. r5, r9, 0, 0x19, 0x19
	ctx.r[5].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 830E5304: 4082000C  bne 0x830e5310
	if !ctx.cr[0].eq {
	pc = 0x830E5310; continue 'dispatch;
	}
	// 830E5308: C0040000  lfs f0, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E530C: D00B003C  stfs f0, 0x3c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 830E5310: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830E5314: 409A0014  bne cr6, 0x830e5328
	if !ctx.cr[6].eq {
	pc = 0x830E5328; continue 'dispatch;
	}
	// 830E5318: 550A063F  clrlwi. r10, r8, 0x18
	ctx.r[10].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830E531C: 4182000C  beq 0x830e5328
	if ctx.cr[0].eq {
	pc = 0x830E5328; continue 'dispatch;
	}
	// 830E5320: 552A0631  rlwinm. r10, r9, 0, 0x18, 0x18
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830E5324: 4082000C  bne 0x830e5330
	if !ctx.cr[0].eq {
	pc = 0x830E5330; continue 'dispatch;
	}
	// 830E5328: C0040004  lfs f0, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E532C: D00B0040  stfs f0, 0x40(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 830E5330: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 830E5334: C0040008  lfs f0, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E5338: D00B0044  stfs f0, 0x44(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 830E533C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830E5340: 419A0064  beq cr6, 0x830e53a4
	if ctx.cr[6].eq {
	pc = 0x830E53A4; continue 'dispatch;
	}
	// 830E5344: 54C806F6  rlwinm r8, r6, 0, 0x1b, 0x1b
	ctx.r[8].u64 = ctx.r[6].u32 as u64 & 0xFFFFFFFFu64;
	// 830E5348: 2B080010  cmplwi cr6, r8, 0x10
	ctx.cr[6].compare_u32(ctx.r[8].u32, 16 as u32, &mut ctx.xer);
	// 830E534C: 419A0058  beq cr6, 0x830e53a4
	if ctx.cr[6].eq {
	pc = 0x830E53A4; continue 'dispatch;
	}
	// 830E5350: 810A00F0  lwz r8, 0xf0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(240 as u32) ) } as u64;
	// 830E5354: 550806B4  rlwinm r8, r8, 0, 0x1a, 0x1a
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	// 830E5358: 2B080020  cmplwi cr6, r8, 0x20
	ctx.cr[6].compare_u32(ctx.r[8].u32, 32 as u32, &mut ctx.xer);
	// 830E535C: 409A0048  bne cr6, 0x830e53a4
	if !ctx.cr[6].eq {
	pc = 0x830E53A4; continue 'dispatch;
	}
	// 830E5360: 71290005  andi. r9, r9, 5
	ctx.r[9].u64 = ctx.r[9].u64 & 5;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830E5364: 2B090005  cmplwi cr6, r9, 5
	ctx.cr[6].compare_u32(ctx.r[9].u32, 5 as u32, &mut ctx.xer);
	// 830E5368: 409A001C  bne cr6, 0x830e5384
	if !ctx.cr[6].eq {
	pc = 0x830E5384; continue 'dispatch;
	}
	// 830E536C: C1AA000C  lfs f13, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830E5370: C00A0104  lfs f0, 0x104(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(260 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E5374: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 830E5378: C1AB003C  lfs f13, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830E537C: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 830E5380: D00B003C  stfs f0, 0x3c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 830E5384: 2B07000A  cmplwi cr6, r7, 0xa
	ctx.cr[6].compare_u32(ctx.r[7].u32, 10 as u32, &mut ctx.xer);
	// 830E5388: 409A001C  bne cr6, 0x830e53a4
	if !ctx.cr[6].eq {
	pc = 0x830E53A4; continue 'dispatch;
	}
	// 830E538C: C1AA0010  lfs f13, 0x10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830E5390: C00A0108  lfs f0, 0x108(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(264 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E5394: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 830E5398: C1AB0040  lfs f13, 0x40(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830E539C: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 830E53A0: D00B0040  stfs f0, 0x40(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 830E53A4: 60CA0002  ori r10, r6, 2
	ctx.r[10].u64 = ctx.r[6].u64 | 2;
	// 830E53A8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E53AC: 914B00F0  stw r10, 0xf0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(240 as u32), ctx.r[10].u32 ) };
	// 830E53B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E53B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830E53B8 size=12
    let mut pc: u32 = 0x830E53B8;
    'dispatch: loop {
        match pc {
            0x830E53B8 => {
    //   block [0x830E53B8..0x830E53C4)
	// 830E53B8: 908300EC  stw r4, 0xec(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(236 as u32), ctx.r[4].u32 ) };
	// 830E53BC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E53C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E53C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830E53C8 size=24
    let mut pc: u32 = 0x830E53C8;
    'dispatch: loop {
        match pc {
            0x830E53C8 => {
    //   block [0x830E53C8..0x830E53E0)
	// 830E53C8: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 830E53CC: 8149002C  lwz r10, 0x2c(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(44 as u32) ) } as u64;
	// 830E53D0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830E53D4: 409A000C  bne cr6, 0x830e53e0
	if !ctx.cr[6].eq {
		sub_830E53E0(ctx, base);
		return;
	}
	// 830E53D8: 9089002C  stw r4, 0x2c(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(44 as u32), ctx.r[4].u32 ) };
	// 830E53DC: 4800002C  b 0x830e5408
	sub_830E53EC(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E53E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830E53E0 size=12
    let mut pc: u32 = 0x830E53E0;
    'dispatch: loop {
        match pc {
            0x830E53E0 => {
    //   block [0x830E53E0..0x830E53EC)
	// 830E53E0: 396A0020  addi r11, r10, 0x20
	ctx.r[11].s64 = ctx.r[10].s64 + 32;
	// 830E53E4: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E53E8: 48000010  b 0x830e53f8
	sub_830E53EC(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E53EC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830E53EC size=52
    let mut pc: u32 = 0x830E53EC;
    'dispatch: loop {
        match pc {
            0x830E53EC => {
    //   block [0x830E53EC..0x830E5420)
	// 830E53EC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E53F0: 396A0020  addi r11, r10, 0x20
	ctx.r[11].s64 = ctx.r[10].s64 + 32;
	// 830E53F4: 810A0020  lwz r8, 0x20(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 830E53F8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 830E53FC: 409AFFF0  bne cr6, 0x830e53ec
	if !ctx.cr[6].eq {
	pc = 0x830E53EC; continue 'dispatch;
	}
	// 830E5400: 908A0020  stw r4, 0x20(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), ctx.r[4].u32 ) };
	// 830E5404: 91440024  stw r10, 0x24(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(36 as u32), ctx.r[10].u32 ) };
	// 830E5408: 91240028  stw r9, 0x28(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 830E540C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E5410: 816900F0  lwz r11, 0xf0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(240 as u32) ) } as u64;
	// 830E5414: 616B8000  ori r11, r11, 0x8000
	ctx.r[11].u64 = ctx.r[11].u64 | 32768;
	// 830E5418: 916900F0  stw r11, 0xf0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 830E541C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E5420(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E5420 size=52
    let mut pc: u32 = 0x830E5420;
    'dispatch: loop {
        match pc {
            0x830E5420 => {
    //   block [0x830E5420..0x830E5454)
	// 830E5420: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E5424: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E5428: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E542C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E5430: 4BFE9041  bl 0x830ce470
	ctx.lr = 0x830E5434;
	sub_830CE470(ctx, base);
	// 830E5434: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E5438: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E543C: 41800008  blt 0x830e5444
	if ctx.cr[0].lt {
	pc = 0x830E5444; continue 'dispatch;
	}
	// 830E5440: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E5444: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830E5448: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E544C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E5450: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E5458(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830E5458 size=16
    let mut pc: u32 = 0x830E5458;
    'dispatch: loop {
        match pc {
            0x830E5458 => {
    //   block [0x830E5458..0x830E5468)
	// 830E5458: 816300E4  lwz r11, 0xe4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(228 as u32) ) } as u64;
	// 830E545C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E5460: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830E5464: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E5468(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E5468 size=148
    let mut pc: u32 = 0x830E5468;
    'dispatch: loop {
        match pc {
            0x830E5468 => {
    //   block [0x830E5468..0x830E54FC)
	// 830E5468: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E546C: 480C2CF9  bl 0x831a8164
	ctx.lr = 0x830E5470;
	sub_831A8130(ctx, base);
	// 830E5470: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E5474: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 830E5478: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830E547C: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 830E5480: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 830E5484: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830E5488: 817D00E4  lwz r11, 0xe4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(228 as u32) ) } as u64;
	// 830E548C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830E5490: 419A0060  beq cr6, 0x830e54f0
	if ctx.cr[6].eq {
	pc = 0x830E54F0; continue 'dispatch;
	}
	// 830E5494: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 830E5498: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 830E549C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830E54A0: 40990050  ble cr6, 0x830e54f0
	if !ctx.cr[6].gt {
	pc = 0x830E54F0; continue 'dispatch;
	}
	// 830E54A4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830E54A8: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 830E54AC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830E54B0: 7C8BF02E  lwzx r4, r11, r30
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 830E54B4: 480CC97D  bl 0x831b1e30
	ctx.lr = 0x830E54B8;
	sub_831B1E30(ctx, base);
	// 830E54B8: 817D00E4  lwz r11, 0xe4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(228 as u32) ) } as u64;
	// 830E54BC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E54C0: 4182001C  beq 0x830e54dc
	if ctx.cr[0].eq {
	pc = 0x830E54DC; continue 'dispatch;
	}
	// 830E54C4: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 830E54C8: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 830E54CC: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 830E54D0: 7F1F5000  cmpw cr6, r31, r10
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830E54D4: 4198FFD4  blt cr6, 0x830e54a8
	if ctx.cr[6].lt {
	pc = 0x830E54A8; continue 'dispatch;
	}
	// 830E54D8: 48000018  b 0x830e54f0
	pc = 0x830E54F0; continue 'dispatch;
	// 830E54DC: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 830E54E0: 57EA2036  slwi r10, r31, 4
	ctx.r[10].u32 = ctx.r[31].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830E54E4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830E54E8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E54EC: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830E54F0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E54F4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830E54F8: 480C2CBC  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E5500(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E5500 size=112
    let mut pc: u32 = 0x830E5500;
    'dispatch: loop {
        match pc {
            0x830E5500 => {
    //   block [0x830E5500..0x830E5570)
	// 830E5500: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E5504: 480C2C69  bl 0x831a816c
	ctx.lr = 0x830E5508;
	sub_831A8130(ctx, base);
	// 830E5508: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E550C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830E5510: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830E5514: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830E5518: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830E551C: 83E3002C  lwz r31, 0x2c(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 830E5520: 48000024  b 0x830e5544
	pc = 0x830E5544; continue 'dispatch;
	// 830E5524: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E5528: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830E552C: 419A0014  beq cr6, 0x830e5540
	if ctx.cr[6].eq {
	pc = 0x830E5540; continue 'dispatch;
	}
	// 830E5530: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830E5534: 480CC8FD  bl 0x831b1e30
	ctx.lr = 0x830E5538;
	sub_831B1E30(ctx, base);
	// 830E5538: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E553C: 41820020  beq 0x830e555c
	if ctx.cr[0].eq {
	pc = 0x830E555C; continue 'dispatch;
	}
	// 830E5540: 83FF0020  lwz r31, 0x20(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 830E5544: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830E5548: 409AFFDC  bne cr6, 0x830e5524
	if !ctx.cr[6].eq {
	pc = 0x830E5524; continue 'dispatch;
	}
	// 830E554C: 3C608030  lis r3, -0x7fd0
	ctx.r[3].s64 = -2144337920;
	// 830E5550: 60630017  ori r3, r3, 0x17
	ctx.r[3].u64 = ctx.r[3].u64 | 23;
	// 830E5554: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E5558: 480C2C64  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
	// 830E555C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E5560: 4BFE96B1  bl 0x830cec10
	ctx.lr = 0x830E5564;
	sub_830CEC10(ctx, base);
	// 830E5564: 907E0000  stw r3, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 830E5568: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E556C: 4BFFFFE8  b 0x830e5554
	pc = 0x830E5554; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E5570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E5570 size=112
    let mut pc: u32 = 0x830E5570;
    'dispatch: loop {
        match pc {
            0x830E5570 => {
    //   block [0x830E5570..0x830E55E0)
	// 830E5570: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E5574: 480C2BF9  bl 0x831a816c
	ctx.lr = 0x830E5578;
	sub_831A8130(ctx, base);
	// 830E5578: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E557C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830E5580: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830E5584: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830E5588: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830E558C: 83E30018  lwz r31, 0x18(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 830E5590: 48000024  b 0x830e55b4
	pc = 0x830E55B4; continue 'dispatch;
	// 830E5594: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E5598: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830E559C: 419A0014  beq cr6, 0x830e55b0
	if ctx.cr[6].eq {
	pc = 0x830E55B0; continue 'dispatch;
	}
	// 830E55A0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830E55A4: 480CC88D  bl 0x831b1e30
	ctx.lr = 0x830E55A8;
	sub_831B1E30(ctx, base);
	// 830E55A8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E55AC: 41820020  beq 0x830e55cc
	if ctx.cr[0].eq {
	pc = 0x830E55CC; continue 'dispatch;
	}
	// 830E55B0: 83FF0020  lwz r31, 0x20(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 830E55B4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830E55B8: 409AFFDC  bne cr6, 0x830e5594
	if !ctx.cr[6].eq {
	pc = 0x830E5594; continue 'dispatch;
	}
	// 830E55BC: 3C608030  lis r3, -0x7fd0
	ctx.r[3].s64 = -2144337920;
	// 830E55C0: 60630017  ori r3, r3, 0x17
	ctx.r[3].u64 = ctx.r[3].u64 | 23;
	// 830E55C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E55C8: 480C2BF4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
	// 830E55CC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E55D0: 4BFE9641  bl 0x830cec10
	ctx.lr = 0x830E55D4;
	sub_830CEC10(ctx, base);
	// 830E55D4: 907E0000  stw r3, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 830E55D8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E55DC: 4BFFFFE8  b 0x830e55c4
	pc = 0x830E55C4; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E55E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830E55E0 size=632
    let mut pc: u32 = 0x830E55E0;
    'dispatch: loop {
        match pc {
            0x830E55E0 => {
    //   block [0x830E55E0..0x830E5858)
	// 830E55E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E55E4: 480C2B89  bl 0x831a816c
	ctx.lr = 0x830E55E8;
	sub_831A8130(ctx, base);
	// 830E55E8: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 830E55EC: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 830E55F0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E55F4: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830E55F8: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 830E55FC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830E5600: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 830E5604: 7CFE3B78  mr r30, r7
	ctx.r[30].u64 = ctx.r[7].u64;
	// 830E5608: 808BC06C  lwz r4, -0x3f94(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16276 as u32) ) } as u64;
	// 830E560C: 4BFE9565  bl 0x830ceb70
	ctx.lr = 0x830E5610;
	sub_830CEB70(ctx, base);
	// 830E5610: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830E5614: 40820010  bne 0x830e5624
	if !ctx.cr[0].eq {
	pc = 0x830E5624; continue 'dispatch;
	}
	// 830E5618: 3C608030  lis r3, -0x7fd0
	ctx.r[3].s64 = -2144337920;
	// 830E561C: 6063000A  ori r3, r3, 0xa
	ctx.r[3].u64 = ctx.r[3].u64 | 10;
	// 830E5620: 48000228  b 0x830e5848
	pc = 0x830E5848; continue 'dispatch;
	// 830E5624: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E5628: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830E562C: 4BFE8E45  bl 0x830ce470
	ctx.lr = 0x830E5630;
	sub_830CE470(ctx, base);
	// 830E5630: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E5634: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830E5638: 419AFFE0  beq cr6, 0x830e5618
	if ctx.cr[6].eq {
	pc = 0x830E5618; continue 'dispatch;
	}
	// 830E563C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 830E5640: C1AB0110  lfs f13, 0x110(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(272 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830E5644: C00B010C  lfs f0, 0x10c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(268 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E5648: ED5E6828  fsubs f10, f30, f13
	ctx.f[10].f64 = (((ctx.f[30].f64 - ctx.f[13].f64) as f32) as f64);
	// 830E564C: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830E5650: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 830E5654: C1AA08A4  lfs f13, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830E5658: 419A000C  beq cr6, 0x830e5664
	if ctx.cr[6].eq {
	pc = 0x830E5664; continue 'dispatch;
	}
	// 830E565C: FD406890  fmr f10, f13
	ctx.f[10].f64 = ctx.f[13].f64;
	// 830E5660: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 830E5664: 814B00F8  lwz r10, 0xf8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(248 as u32) ) } as u64;
	// 830E5668: C3CB0104  lfs f30, 0x104(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(260 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 830E566C: 810B00FC  lwz r8, 0xfc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(252 as u32) ) } as u64;
	// 830E5670: C3EB0108  lfs f31, 0x108(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(264 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 830E5674: 80EB0100  lwz r7, 0x100(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(256 as u32) ) } as u64;
	// 830E5678: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 830E567C: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 830E5680: 73E60005  andi. r6, r31, 5
	ctx.r[6].u64 = ctx.r[31].u64 & 5;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 830E5684: C1699450  lfs f11, -0x6bb0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830E5688: 9101005C  stw r8, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[8].u32 ) };
	// 830E568C: 90E10060  stw r7, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[7].u32 ) };
	// 830E5690: 2B060005  cmplwi cr6, r6, 5
	ctx.cr[6].compare_u32(ctx.r[6].u32, 5 as u32, &mut ctx.xer);
	// 830E5694: 814B003C  lwz r10, 0x3c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 830E5698: 812B0040  lwz r9, 0x40(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 830E569C: 810B0044  lwz r8, 0x44(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 830E56A0: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 830E56A4: 9121006C  stw r9, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[9].u32 ) };
	// 830E56A8: 91010070  stw r8, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[8].u32 ) };
	// 830E56AC: 409A0074  bne cr6, 0x830e5720
	if !ctx.cr[6].eq {
	pc = 0x830E5720; continue 'dispatch;
	}
	// 830E56B0: 57EA0673  rlwinm. r10, r31, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830E56B4: 4182004C  beq 0x830e5700
	if ctx.cr[0].eq {
	pc = 0x830E5700; continue 'dispatch;
	}
	// 830E56B8: C18B0104  lfs f12, 0x104(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(260 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830E56BC: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 830E56C0: 409A000C  bne cr6, 0x830e56cc
	if !ctx.cr[6].eq {
	pc = 0x830E56CC; continue 'dispatch;
	}
	// 830E56C4: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 830E56C8: 48000018  b 0x830e56e0
	pc = 0x830E56E0; continue 'dispatch;
	// 830E56CC: C12B0114  lfs f9, 0x114(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(276 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 830E56D0: ED890332  fmuls f12, f9, f12
	ctx.f[12].f64 = (((ctx.f[9].f64 * ctx.f[12].f64) as f32) as f64);
	// 830E56D4: EC0C002A  fadds f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 830E56D8: EC006024  fdivs f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[12].f64) as f32) as f64;
	// 830E56DC: EC000272  fmuls f0, f0, f9
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[9].f64) as f32) as f64);
	// 830E56E0: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 830E56E4: C18B0058  lfs f12, 0x58(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830E56E8: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 830E56EC: 419A0064  beq cr6, 0x830e5750
	if ctx.cr[6].eq {
	pc = 0x830E5750; continue 'dispatch;
	}
	// 830E56F0: EC0C6038  fmsubs f0, f12, f0, f12
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 830E56F4: C1810058  lfs f12, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830E56F8: EC00602A  fadds f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 830E56FC: 48000050  b 0x830e574c
	pc = 0x830E574C; continue 'dispatch;
	// 830E5700: C18B003C  lfs f12, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830E5704: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 830E5708: 409A000C  bne cr6, 0x830e5714
	if !ctx.cr[6].eq {
	pc = 0x830E5714; continue 'dispatch;
	}
	// 830E570C: FFC06890  fmr f30, f13
	ctx.f[30].f64 = ctx.f[13].f64;
	// 830E5710: 48000040  b 0x830e5750
	pc = 0x830E5750; continue 'dispatch;
	// 830E5714: EC006024  fdivs f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[12].f64) as f32) as f64;
	// 830E5718: EFC0F02A  fadds f30, f0, f30
	ctx.f[30].f64 = ((ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64;
	// 830E571C: 48000034  b 0x830e5750
	pc = 0x830E5750; continue 'dispatch;
	// 830E5720: 57EA077A  rlwinm r10, r31, 0, 0x1d, 0x1d
	ctx.r[10].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	// 830E5724: 2B0A0004  cmplwi cr6, r10, 4
	ctx.cr[6].compare_u32(ctx.r[10].u32, 4 as u32, &mut ctx.xer);
	// 830E5728: 409A0010  bne cr6, 0x830e5738
	if !ctx.cr[6].eq {
	pc = 0x830E5738; continue 'dispatch;
	}
	// 830E572C: C1810058  lfs f12, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830E5730: EC0C002A  fadds f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 830E5734: 48000018  b 0x830e574c
	pc = 0x830E574C; continue 'dispatch;
	// 830E5738: 57EA06F6  rlwinm r10, r31, 0, 0x1b, 0x1b
	ctx.r[10].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	// 830E573C: 2B0A0010  cmplwi cr6, r10, 0x10
	ctx.cr[6].compare_u32(ctx.r[10].u32, 16 as u32, &mut ctx.xer);
	// 830E5740: 409A0010  bne cr6, 0x830e5750
	if !ctx.cr[6].eq {
	pc = 0x830E5750; continue 'dispatch;
	}
	// 830E5744: C1810058  lfs f12, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830E5748: EC0062FA  fmadds f0, f0, f11, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64 + ctx.f[12].f64) as f32) as f64);
	// 830E574C: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 830E5750: 73EA000A  andi. r10, r31, 0xa
	ctx.r[10].u64 = ctx.r[31].u64 & 10;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830E5754: 2B0A000A  cmplwi cr6, r10, 0xa
	ctx.cr[6].compare_u32(ctx.r[10].u32, 10 as u32, &mut ctx.xer);
	// 830E5758: 409A0078  bne cr6, 0x830e57d0
	if !ctx.cr[6].eq {
	pc = 0x830E57D0; continue 'dispatch;
	}
	// 830E575C: 57EA0631  rlwinm. r10, r31, 0, 0x18, 0x18
	ctx.r[10].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830E5760: 41820050  beq 0x830e57b0
	if ctx.cr[0].eq {
	pc = 0x830E57B0; continue 'dispatch;
	}
	// 830E5764: C00B0108  lfs f0, 0x108(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(264 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E5768: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830E576C: 409A000C  bne cr6, 0x830e5778
	if !ctx.cr[6].eq {
	pc = 0x830E5778; continue 'dispatch;
	}
	// 830E5770: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 830E5774: 48000018  b 0x830e578c
	pc = 0x830E578C; continue 'dispatch;
	// 830E5778: C18B0118  lfs f12, 0x118(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(280 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830E577C: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 830E5780: ED60502A  fadds f11, f0, f10
	ctx.f[11].f64 = ((ctx.f[0].f64 + ctx.f[10].f64) as f32) as f64;
	// 830E5784: EC0B0024  fdivs f0, f11, f0
	ctx.f[0].f64 = ((ctx.f[11].f64 / ctx.f[0].f64) as f32) as f64;
	// 830E5788: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 830E578C: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 830E5790: C18B005C  lfs f12, 0x5c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830E5794: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 830E5798: 419A0068  beq cr6, 0x830e5800
	if ctx.cr[6].eq {
	pc = 0x830E5800; continue 'dispatch;
	}
	// 830E579C: FDA06090  fmr f13, f12
	ctx.f[13].f64 = ctx.f[12].f64;
	// 830E57A0: EC0D6838  fmsubs f0, f13, f0, f13
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 830E57A4: C1A1005C  lfs f13, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830E57A8: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 830E57AC: 48000050  b 0x830e57fc
	pc = 0x830E57FC; continue 'dispatch;
	// 830E57B0: C00B0040  lfs f0, 0x40(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E57B4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830E57B8: 409A000C  bne cr6, 0x830e57c4
	if !ctx.cr[6].eq {
	pc = 0x830E57C4; continue 'dispatch;
	}
	// 830E57BC: FFE06890  fmr f31, f13
	ctx.f[31].f64 = ctx.f[13].f64;
	// 830E57C0: 48000040  b 0x830e5800
	pc = 0x830E5800; continue 'dispatch;
	// 830E57C4: EC0A0024  fdivs f0, f10, f0
	ctx.f[0].f64 = ((ctx.f[10].f64 / ctx.f[0].f64) as f32) as f64;
	// 830E57C8: EFE0F82A  fadds f31, f0, f31
	ctx.f[31].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 830E57CC: 48000034  b 0x830e5800
	pc = 0x830E5800; continue 'dispatch;
	// 830E57D0: 57EA0738  rlwinm r10, r31, 0, 0x1c, 0x1c
	ctx.r[10].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	// 830E57D4: 2B0A0008  cmplwi cr6, r10, 8
	ctx.cr[6].compare_u32(ctx.r[10].u32, 8 as u32, &mut ctx.xer);
	// 830E57D8: 409A0010  bne cr6, 0x830e57e8
	if !ctx.cr[6].eq {
	pc = 0x830E57E8; continue 'dispatch;
	}
	// 830E57DC: C001005C  lfs f0, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E57E0: EC00502A  fadds f0, f0, f10
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[10].f64) as f32) as f64;
	// 830E57E4: 48000018  b 0x830e57fc
	pc = 0x830E57FC; continue 'dispatch;
	// 830E57E8: 57EA06B4  rlwinm r10, r31, 0, 0x1a, 0x1a
	ctx.r[10].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	// 830E57EC: 2B0A0020  cmplwi cr6, r10, 0x20
	ctx.cr[6].compare_u32(ctx.r[10].u32, 32 as u32, &mut ctx.xer);
	// 830E57F0: 409A0010  bne cr6, 0x830e5800
	if !ctx.cr[6].eq {
	pc = 0x830E5800; continue 'dispatch;
	}
	// 830E57F4: C001005C  lfs f0, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E57F8: EC0A02FA  fmadds f0, f10, f11, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 830E57FC: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 830E5800: 814B00F0  lwz r10, 0xf0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(240 as u32) ) } as u64;
	// 830E5804: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830E5808: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830E580C: 614A0010  ori r10, r10, 0x10
	ctx.r[10].u64 = ctx.r[10].u64 | 16;
	// 830E5810: 914B00F0  stw r10, 0xf0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(240 as u32), ctx.r[10].u32 ) };
	// 830E5814: 4BFFA28D  bl 0x830dfaa0
	ctx.lr = 0x830E5818;
	sub_830DFAA0(ctx, base);
	// 830E5818: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830E581C: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 830E5820: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 830E5824: 4BFFC1E5  bl 0x830e1a08
	ctx.lr = 0x830E5828;
	sub_830E1A08(ctx, base);
	// 830E5828: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 830E582C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830E5830: 4BFFA311  bl 0x830dfb40
	ctx.lr = 0x830E5834;
	sub_830DFB40(ctx, base);
	// 830E5834: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E5838: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E583C: 814B00F0  lwz r10, 0xf0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(240 as u32) ) } as u64;
	// 830E5840: 554A0734  rlwinm r10, r10, 0, 0x1c, 0x1a
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 830E5844: 914B00F0  stw r10, 0xf0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(240 as u32), ctx.r[10].u32 ) };
	// 830E5848: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 830E584C: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 830E5850: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 830E5854: 480C2968  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E5858(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E5858 size=144
    let mut pc: u32 = 0x830E5858;
    'dispatch: loop {
        match pc {
            0x830E5858 => {
    //   block [0x830E5858..0x830E58E8)
	// 830E5858: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E585C: 480C2911  bl 0x831a816c
	ctx.lr = 0x830E5860;
	sub_831A8130(ctx, base);
	// 830E5860: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 830E5864: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 830E5868: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E586C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830E5870: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 830E5874: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 830E5878: 817E00F0  lwz r11, 0xf0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(240 as u32) ) } as u64;
	// 830E587C: 83FE0018  lwz r31, 0x18(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 830E5880: 616B0010  ori r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u64 | 16;
	// 830E5884: 917E00F0  stw r11, 0xf0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 830E5888: 557DDFFE  rlwinm r29, r11, 0x1b, 0x1f, 0x1f
	ctx.r[29].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830E588C: 48000034  b 0x830e58c0
	pc = 0x830E58C0; continue 'dispatch;
	// 830E5890: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E5894: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E5898: 4BFFA651  bl 0x830dfee8
	ctx.lr = 0x830E589C;
	sub_830DFEE8(ctx, base);
	// 830E589C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E58A0: 4180001C  blt 0x830e58bc
	if ctx.cr[0].lt {
	pc = 0x830E58BC; continue 'dispatch;
	}
	// 830E58A4: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 830E58A8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E58AC: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E58B0: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 830E58B4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 830E58B8: 4BFFFD29  bl 0x830e55e0
	ctx.lr = 0x830E58BC;
	sub_830E55E0(ctx, base);
	// 830E58BC: 83FF0020  lwz r31, 0x20(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 830E58C0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830E58C4: 409AFFCC  bne cr6, 0x830e5890
	if !ctx.cr[6].eq {
	pc = 0x830E5890; continue 'dispatch;
	}
	// 830E58C8: 817E00F0  lwz r11, 0xf0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(240 as u32) ) } as u64;
	// 830E58CC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E58D0: 556B0734  rlwinm r11, r11, 0, 0x1c, 0x1a
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830E58D4: 917E00F0  stw r11, 0xf0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 830E58D8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830E58DC: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 830E58E0: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 830E58E4: 480C28D8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E58E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830E58E8 size=16
    let mut pc: u32 = 0x830E58E8;
    'dispatch: loop {
        match pc {
            0x830E58E8 => {
    //   block [0x830E58E8..0x830E58F8)
	// 830E58E8: 816300F0  lwz r11, 0xf0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(240 as u32) ) } as u64;
	// 830E58EC: 508B452E  rlwimi r11, r4, 8, 0x14, 0x17
	ctx.r[11].u64 = (((ctx.r[4].u32).rotate_left(8) as u64) & 0x0000000000000F00) | (ctx.r[11].u64 & 0xFFFFFFFFFFFFF0FF);
	// 830E58F0: 916300F0  stw r11, 0xf0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 830E58F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E58F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830E58F8 size=12
    let mut pc: u32 = 0x830E58F8;
    'dispatch: loop {
        match pc {
            0x830E58F8 => {
    //   block [0x830E58F8..0x830E5904)
	// 830E58F8: 816300F0  lwz r11, 0xf0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(240 as u32) ) } as u64;
	// 830E58FC: 5563C73E  rlwinm r3, r11, 0x18, 0x1c, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 830E5900: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E5908(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E5908 size=132
    let mut pc: u32 = 0x830E5908;
    'dispatch: loop {
        match pc {
            0x830E5908 => {
    //   block [0x830E5908..0x830E598C)
	// 830E5908: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E590C: 480C285D  bl 0x831a8168
	ctx.lr = 0x830E5910;
	sub_831A8130(ctx, base);
	// 830E5910: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E5914: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 830E5918: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E591C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830E5920: 93BC0000  stw r29, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 830E5924: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830E5928: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 830E592C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830E5930: 419A0010  beq cr6, 0x830e5940
	if ctx.cr[6].eq {
	pc = 0x830E5940; continue 'dispatch;
	}
	// 830E5934: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830E5938: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830E593C: 48000044  b 0x830e5980
	pc = 0x830E5980; continue 'dispatch;
	// 830E5940: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830E5944: 3BDF0010  addi r30, r31, 0x10
	ctx.r[30].s64 = ctx.r[31].s64 + 16;
	// 830E5948: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830E594C: 419A000C  beq cr6, 0x830e5958
	if ctx.cr[6].eq {
	pc = 0x830E5958; continue 'dispatch;
	}
	// 830E5950: 4802AB11  bl 0x83110460
	ctx.lr = 0x830E5954;
	sub_83110460(ctx, base);
	// 830E5954: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 830E5958: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830E595C: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E5960: 4802C5F9  bl 0x83111f58
	ctx.lr = 0x830E5964;
	sub_83111F58(ctx, base);
	// 830E5964: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E5968: 4180001C  blt 0x830e5984
	if ctx.cr[0].lt {
	pc = 0x830E5984; continue 'dispatch;
	}
	// 830E596C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830E5970: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E5974: 556B003C  rlwinm r11, r11, 0, 0, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830E5978: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 830E597C: 915C0000  stw r10, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830E5980: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E5984: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830E5988: 480C2830  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E5990(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E5990 size=88
    let mut pc: u32 = 0x830E5990;
    'dispatch: loop {
        match pc {
            0x830E5990 => {
    //   block [0x830E5990..0x830E59E8)
	// 830E5990: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E5994: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E5998: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E599C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E59A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830E59A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E59A8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830E59AC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E59B0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E59B4: 4BFFBBA5  bl 0x830e1558
	ctx.lr = 0x830E59B8;
	sub_830E1558(ctx, base);
	// 830E59B8: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E59BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830E59C0: 419A0008  beq cr6, 0x830e59c8
	if ctx.cr[6].eq {
	pc = 0x830E59C8; continue 'dispatch;
	}
	// 830E59C4: 4BFF3E65  bl 0x830d9828
	ctx.lr = 0x830E59C8;
	sub_830D9828(ctx, base);
	// 830E59C8: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830E59CC: 556B07B8  rlwinm r11, r11, 0, 0x1e, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830E59D0: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 830E59D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E59D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E59DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E59E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E59E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E59E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E59E8 size=380
    let mut pc: u32 = 0x830E59E8;
    'dispatch: loop {
        match pc {
            0x830E59E8 => {
    //   block [0x830E59E8..0x830E5B64)
	// 830E59E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E59EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E59F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830E59F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E59F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E59FC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830E5A00: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E5A04: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830E5A08: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830E5A0C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E5A10: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E5A14: 4BFFBB45  bl 0x830e1558
	ctx.lr = 0x830E5A18;
	sub_830E1558(ctx, base);
	// 830E5A18: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E5A1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830E5A20: 419A012C  beq cr6, 0x830e5b4c
	if ctx.cr[6].eq {
	pc = 0x830E5B4C; continue 'dispatch;
	}
	// 830E5A24: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E5A28: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E5A2C: 419A000C  beq cr6, 0x830e5a38
	if ctx.cr[6].eq {
	pc = 0x830E5A38; continue 'dispatch;
	}
	// 830E5A30: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E5A34: 4800000C  b 0x830e5a40
	pc = 0x830E5A40; continue 'dispatch;
	// 830E5A38: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E5A3C: 4BFFB9CD  bl 0x830e1408
	ctx.lr = 0x830E5A40;
	sub_830E1408(ctx, base);
	// 830E5A40: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830E5A44: 419A00A4  beq cr6, 0x830e5ae8
	if ctx.cr[6].eq {
	pc = 0x830E5AE8; continue 'dispatch;
	}
	// 830E5A48: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E5A4C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E5A50: 419A0054  beq cr6, 0x830e5aa4
	if ctx.cr[6].eq {
	pc = 0x830E5AA4; continue 'dispatch;
	}
	// 830E5A54: 4BFF93B5  bl 0x830dee08
	ctx.lr = 0x830E5A58;
	sub_830DEE08(ctx, base);
	// 830E5A58: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E5A5C: 41820048  beq 0x830e5aa4
	if ctx.cr[0].eq {
	pc = 0x830E5AA4; continue 'dispatch;
	}
	// 830E5A60: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830E5A64: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 830E5A68: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E5A6C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830E5A70: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 830E5A74: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830E5A78: 409A0018  bne cr6, 0x830e5a90
	if !ctx.cr[6].eq {
	pc = 0x830E5A90; continue 'dispatch;
	}
	// 830E5A7C: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830E5A80: 3D408219  lis r10, -0x7de7
	ctx.r[10].s64 = -2112290816;
	// 830E5A84: 38AB8D00  addi r5, r11, -0x7300
	ctx.r[5].s64 = ctx.r[11].s64 + -29440;
	// 830E5A88: 388A8D1C  addi r4, r10, -0x72e4
	ctx.r[4].s64 = ctx.r[10].s64 + -29412;
	// 830E5A8C: 480000BC  b 0x830e5b48
	pc = 0x830E5B48; continue 'dispatch;
	// 830E5A90: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830E5A94: 3D408219  lis r10, -0x7de7
	ctx.r[10].s64 = -2112290816;
	// 830E5A98: 38AB8CB4  addi r5, r11, -0x734c
	ctx.r[5].s64 = ctx.r[11].s64 + -29516;
	// 830E5A9C: 388A8CDC  addi r4, r10, -0x7324
	ctx.r[4].s64 = ctx.r[10].s64 + -29476;
	// 830E5AA0: 480000A8  b 0x830e5b48
	pc = 0x830E5B48; continue 'dispatch;
	// 830E5AA4: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830E5AA8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 830E5AAC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E5AB0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830E5AB4: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 830E5AB8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830E5ABC: 409A0018  bne cr6, 0x830e5ad4
	if !ctx.cr[6].eq {
	pc = 0x830E5AD4; continue 'dispatch;
	}
	// 830E5AC0: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830E5AC4: 3D408219  lis r10, -0x7de7
	ctx.r[10].s64 = -2112290816;
	// 830E5AC8: 38AB90FC  addi r5, r11, -0x6f04
	ctx.r[5].s64 = ctx.r[11].s64 + -28420;
	// 830E5ACC: 388A9110  addi r4, r10, -0x6ef0
	ctx.r[4].s64 = ctx.r[10].s64 + -28400;
	// 830E5AD0: 48000078  b 0x830e5b48
	pc = 0x830E5B48; continue 'dispatch;
	// 830E5AD4: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830E5AD8: 3D408219  lis r10, -0x7de7
	ctx.r[10].s64 = -2112290816;
	// 830E5ADC: 38AB906C  addi r5, r11, -0x6f94
	ctx.r[5].s64 = ctx.r[11].s64 + -28564;
	// 830E5AE0: 388A908C  addi r4, r10, -0x6f74
	ctx.r[4].s64 = ctx.r[10].s64 + -28532;
	// 830E5AE4: 48000064  b 0x830e5b48
	pc = 0x830E5B48; continue 'dispatch;
	// 830E5AE8: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830E5AEC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 830E5AF0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E5AF4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830E5AF8: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 830E5AFC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830E5B00: 409A0038  bne cr6, 0x830e5b38
	if !ctx.cr[6].eq {
	pc = 0x830E5B38; continue 'dispatch;
	}
	// 830E5B04: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E5B08: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E5B0C: 419A0018  beq cr6, 0x830e5b24
	if ctx.cr[6].eq {
	pc = 0x830E5B24; continue 'dispatch;
	}
	// 830E5B10: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830E5B14: 3D408219  lis r10, -0x7de7
	ctx.r[10].s64 = -2112290816;
	// 830E5B18: 38AB8BB8  addi r5, r11, -0x7448
	ctx.r[5].s64 = ctx.r[11].s64 + -29768;
	// 830E5B1C: 388A90E8  addi r4, r10, -0x6f18
	ctx.r[4].s64 = ctx.r[10].s64 + -28440;
	// 830E5B20: 48000028  b 0x830e5b48
	pc = 0x830E5B48; continue 'dispatch;
	// 830E5B24: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830E5B28: 3D408219  lis r10, -0x7de7
	ctx.r[10].s64 = -2112290816;
	// 830E5B2C: 38AB911C  addi r5, r11, -0x6ee4
	ctx.r[5].s64 = ctx.r[11].s64 + -28388;
	// 830E5B30: 388A9130  addi r4, r10, -0x6ed0
	ctx.r[4].s64 = ctx.r[10].s64 + -28368;
	// 830E5B34: 48000014  b 0x830e5b48
	pc = 0x830E5B48; continue 'dispatch;
	// 830E5B38: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830E5B3C: 3D408219  lis r10, -0x7de7
	ctx.r[10].s64 = -2112290816;
	// 830E5B40: 38AB90A8  addi r5, r11, -0x6f58
	ctx.r[5].s64 = ctx.r[11].s64 + -28504;
	// 830E5B44: 388A90CC  addi r4, r10, -0x6f34
	ctx.r[4].s64 = ctx.r[10].s64 + -28468;
	// 830E5B48: 4BFFBC11  bl 0x830e1758
	ctx.lr = 0x830E5B4C;
	sub_830E1758(ctx, base);
	// 830E5B4C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E5B50: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E5B54: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E5B58: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830E5B5C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E5B60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E5B68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E5B68 size=92
    let mut pc: u32 = 0x830E5B68;
    'dispatch: loop {
        match pc {
            0x830E5B68 => {
    //   block [0x830E5B68..0x830E5BC4)
	// 830E5B68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E5B6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E5B70: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E5B74: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E5B78: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E5B7C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 830E5B80: 4BFF9C51  bl 0x830df7d0
	ctx.lr = 0x830E5B84;
	sub_830DF7D0(ctx, base);
	// 830E5B84: 4800001C  b 0x830e5ba0
	pc = 0x830E5BA0; continue 'dispatch;
	// 830E5B88: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E5B8C: 4BFF9595  bl 0x830df120
	ctx.lr = 0x830E5B90;
	sub_830DF120(ctx, base);
	// 830E5B90: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E5B94: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E5B98: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 830E5B9C: 4BFF9D25  bl 0x830df8c0
	ctx.lr = 0x830E5BA0;
	sub_830DF8C0(ctx, base);
	// 830E5BA0: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E5BA4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830E5BA8: 409AFFE0  bne cr6, 0x830e5b88
	if !ctx.cr[6].eq {
	pc = 0x830E5B88; continue 'dispatch;
	}
	// 830E5BAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E5BB0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E5BB4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E5BB8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E5BBC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E5BC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E5BC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E5BC8 size=112
    let mut pc: u32 = 0x830E5BC8;
    'dispatch: loop {
        match pc {
            0x830E5BC8 => {
    //   block [0x830E5BC8..0x830E5C38)
	// 830E5BC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E5BCC: 480C25A1  bl 0x831a816c
	ctx.lr = 0x830E5BD0;
	sub_831A8130(ctx, base);
	// 830E5BD0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E5BD4: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830E5BD8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830E5BDC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830E5BE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E5BE4: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 830E5BE8: 808BC06C  lwz r4, -0x3f94(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16276 as u32) ) } as u64;
	// 830E5BEC: 4BFF8EFD  bl 0x830deae8
	ctx.lr = 0x830E5BF0;
	sub_830DEAE8(ctx, base);
	// 830E5BF0: 81630020  lwz r11, 0x20(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 830E5BF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830E5BF8: 409A002C  bne cr6, 0x830e5c24
	if !ctx.cr[6].eq {
	pc = 0x830E5C24; continue 'dispatch;
	}
	// 830E5BFC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E5C00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E5C04: 4BFE886D  bl 0x830ce470
	ctx.lr = 0x830E5C08;
	sub_830CE470(ctx, base);
	// 830E5C08: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E5C0C: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E5C10: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 830E5C14: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E5C18: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830E5C1C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830E5C20: 48000010  b 0x830e5c30
	pc = 0x830E5C30; continue 'dispatch;
	// 830E5C24: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830E5C28: 4BFFFF41  bl 0x830e5b68
	ctx.lr = 0x830E5C2C;
	sub_830E5B68(ctx, base);
	// 830E5C2C: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 830E5C30: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830E5C34: 480C2588  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E5C38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E5C38 size=92
    let mut pc: u32 = 0x830E5C38;
    'dispatch: loop {
        match pc {
            0x830E5C38 => {
    //   block [0x830E5C38..0x830E5C94)
	// 830E5C38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E5C3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E5C40: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E5C44: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E5C48: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E5C4C: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E5C50: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830E5C54: 419A0028  beq cr6, 0x830e5c7c
	if ctx.cr[6].eq {
	pc = 0x830E5C7C; continue 'dispatch;
	}
	// 830E5C58: 4BFE89A1  bl 0x830ce5f8
	ctx.lr = 0x830E5C5C;
	sub_830CE5F8(ctx, base);
	// 830E5C5C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E5C60: 4182001C  beq 0x830e5c7c
	if ctx.cr[0].eq {
	pc = 0x830E5C7C; continue 'dispatch;
	}
	// 830E5C64: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E5C68: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E5C6C: 4BFFA205  bl 0x830dfe70
	ctx.lr = 0x830E5C70;
	sub_830DFE70(ctx, base);
	// 830E5C70: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E5C74: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830E5C78: 40820008  bne 0x830e5c80
	if !ctx.cr[0].eq {
	pc = 0x830E5C80; continue 'dispatch;
	}
	// 830E5C7C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E5C80: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830E5C84: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E5C88: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E5C8C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E5C90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E5C98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E5C98 size=116
    let mut pc: u32 = 0x830E5C98;
    'dispatch: loop {
        match pc {
            0x830E5C98 => {
    //   block [0x830E5C98..0x830E5D0C)
	// 830E5C98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E5C9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E5CA0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E5CA4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E5CA8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830E5CAC: 419A0040  beq cr6, 0x830e5cec
	if ctx.cr[6].eq {
	pc = 0x830E5CEC; continue 'dispatch;
	}
	// 830E5CB0: 3FE08339  lis r31, -0x7cc7
	ctx.r[31].s64 = -2093416448;
	// 830E5CB4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830E5CB8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E5CBC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830E5CC0: 4BFF9A99  bl 0x830df758
	ctx.lr = 0x830E5CC4;
	sub_830DF758(ctx, base);
	// 830E5CC4: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E5CC8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830E5CCC: 419A0020  beq cr6, 0x830e5cec
	if ctx.cr[6].eq {
	pc = 0x830E5CEC; continue 'dispatch;
	}
	// 830E5CD0: 809FC078  lwz r4, -0x3f88(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-16264 as u32) ) } as u64;
	// 830E5CD4: 4BFE8E9D  bl 0x830ceb70
	ctx.lr = 0x830E5CD8;
	sub_830CEB70(ctx, base);
	// 830E5CD8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830E5CDC: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E5CE0: 40820024  bne 0x830e5d04
	if !ctx.cr[0].eq {
	pc = 0x830E5D04; continue 'dispatch;
	}
	// 830E5CE4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830E5CE8: 409AFFCC  bne cr6, 0x830e5cb4
	if !ctx.cr[6].eq {
	pc = 0x830E5CB4; continue 'dispatch;
	}
	// 830E5CEC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E5CF0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E5CF4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E5CF8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E5CFC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E5D00: 4E800020  blr
	return;
	// 830E5D04: 4BFE8F0D  bl 0x830cec10
	ctx.lr = 0x830E5D08;
	sub_830CEC10(ctx, base);
	// 830E5D08: 4BFFFFE8  b 0x830e5cf0
	pc = 0x830E5CF0; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E5D10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E5D10 size=92
    let mut pc: u32 = 0x830E5D10;
    'dispatch: loop {
        match pc {
            0x830E5D10 => {
    //   block [0x830E5D10..0x830E5D6C)
	// 830E5D10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E5D14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E5D18: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E5D1C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E5D20: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E5D24: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E5D28: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830E5D2C: 419A0028  beq cr6, 0x830e5d54
	if ctx.cr[6].eq {
	pc = 0x830E5D54; continue 'dispatch;
	}
	// 830E5D30: 4BFE88C9  bl 0x830ce5f8
	ctx.lr = 0x830E5D34;
	sub_830CE5F8(ctx, base);
	// 830E5D34: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E5D38: 4182001C  beq 0x830e5d54
	if ctx.cr[0].eq {
	pc = 0x830E5D54; continue 'dispatch;
	}
	// 830E5D3C: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E5D40: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E5D44: 4BFFA12D  bl 0x830dfe70
	ctx.lr = 0x830E5D48;
	sub_830DFE70(ctx, base);
	// 830E5D48: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E5D4C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830E5D50: 40820008  bne 0x830e5d58
	if !ctx.cr[0].eq {
	pc = 0x830E5D58; continue 'dispatch;
	}
	// 830E5D54: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E5D58: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830E5D5C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E5D60: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E5D64: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E5D68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E5D70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830E5D70 size=8
    let mut pc: u32 = 0x830E5D70;
    'dispatch: loop {
        match pc {
            0x830E5D70 => {
    //   block [0x830E5D70..0x830E5D78)
	// 830E5D70: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830E5D74: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E5D78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830E5D78 size=8
    let mut pc: u32 = 0x830E5D78;
    'dispatch: loop {
        match pc {
            0x830E5D78 => {
    //   block [0x830E5D78..0x830E5D80)
	// 830E5D78: 2B040004  cmplwi cr6, r4, 4
	ctx.cr[6].compare_u32(ctx.r[4].u32, 4 as u32, &mut ctx.xer);
	// 830E5D7C: 4D990020  bgtlr cr6
	if ctx.cr[6].gt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E5D80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830E5D80 size=8
    let mut pc: u32 = 0x830E5D80;
    'dispatch: loop {
        match pc {
            0x830E5D80 => {
    //   block [0x830E5D80..0x830E5D88)
	// 830E5D80: 90830008  stw r4, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 830E5D84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E5D88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830E5D88 size=8
    let mut pc: u32 = 0x830E5D88;
    'dispatch: loop {
        match pc {
            0x830E5D88 => {
    //   block [0x830E5D88..0x830E5D90)
	// 830E5D88: 2B040003  cmplwi cr6, r4, 3
	ctx.cr[6].compare_u32(ctx.r[4].u32, 3 as u32, &mut ctx.xer);
	// 830E5D8C: 4C980020  bgelr cr6
	if !ctx.cr[6].lt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E5D90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830E5D90 size=8
    let mut pc: u32 = 0x830E5D90;
    'dispatch: loop {
        match pc {
            0x830E5D90 => {
    //   block [0x830E5D90..0x830E5D98)
	// 830E5D90: 90830004  stw r4, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 830E5D94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E5D98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E5D98 size=96
    let mut pc: u32 = 0x830E5D98;
    'dispatch: loop {
        match pc {
            0x830E5D98 => {
    //   block [0x830E5D98..0x830E5DF8)
	// 830E5D98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E5D9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E5DA0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E5DA4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E5DA8: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E5DAC: 3FE08339  lis r31, -0x7cc7
	ctx.r[31].s64 = -2093416448;
	// 830E5DB0: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 830E5DB4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E5DB8: 4BFF99A1  bl 0x830df758
	ctx.lr = 0x830E5DBC;
	sub_830DF758(ctx, base);
	// 830E5DBC: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E5DC0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830E5DC4: 419A0020  beq cr6, 0x830e5de4
	if ctx.cr[6].eq {
	pc = 0x830E5DE4; continue 'dispatch;
	}
	// 830E5DC8: 809FC0B8  lwz r4, -0x3f48(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-16200 as u32) ) } as u64;
	// 830E5DCC: 4BFE8DA5  bl 0x830ceb70
	ctx.lr = 0x830E5DD0;
	sub_830CEB70(ctx, base);
	// 830E5DD0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830E5DD4: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E5DD8: 4082000C  bne 0x830e5de4
	if !ctx.cr[0].eq {
	pc = 0x830E5DE4; continue 'dispatch;
	}
	// 830E5DDC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830E5DE0: 409AFFD4  bne cr6, 0x830e5db4
	if !ctx.cr[6].eq {
	pc = 0x830E5DB4; continue 'dispatch;
	}
	// 830E5DE4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E5DE8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E5DEC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E5DF0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E5DF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E5DF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E5DF8 size=104
    let mut pc: u32 = 0x830E5DF8;
    'dispatch: loop {
        match pc {
            0x830E5DF8 => {
    //   block [0x830E5DF8..0x830E5E60)
	// 830E5DF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E5DFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E5E00: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E5E04: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E5E08: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830E5E0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E5E10: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830E5E14: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E5E18: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E5E1C: 4BFFB73D  bl 0x830e1558
	ctx.lr = 0x830E5E20;
	sub_830E1558(ctx, base);
	// 830E5E20: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E5E24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830E5E28: 419A0024  beq cr6, 0x830e5e4c
	if ctx.cr[6].eq {
	pc = 0x830E5E4C; continue 'dispatch;
	}
	// 830E5E2C: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830E5E30: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E5E34: 3D408219  lis r10, -0x7de7
	ctx.r[10].s64 = -2112290816;
	// 830E5E38: 38AB911C  addi r5, r11, -0x6ee4
	ctx.r[5].s64 = ctx.r[11].s64 + -28388;
	// 830E5E3C: 388A9130  addi r4, r10, -0x6ed0
	ctx.r[4].s64 = ctx.r[10].s64 + -28368;
	// 830E5E40: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 830E5E44: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830E5E48: 4BFFB911  bl 0x830e1758
	ctx.lr = 0x830E5E4C;
	sub_830E1758(ctx, base);
	// 830E5E4C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E5E50: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E5E54: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E5E58: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E5E5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E5E60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830E5E60 size=48
    let mut pc: u32 = 0x830E5E60;
    'dispatch: loop {
        match pc {
            0x830E5E60 => {
    //   block [0x830E5E60..0x830E5E90)
	// 830E5E60: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830E5E64: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E5E68: D0060000  stfs f0, 0(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830E5E6C: D0060004  stfs f0, 4(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830E5E70: 816300A0  lwz r11, 0xa0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(160 as u32) ) } as u64;
	// 830E5E74: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E5E78: 419A0048  beq cr6, 0x830e5ec0
	if ctx.cr[6].eq {
		sub_830E5EC0(ctx, base);
		return;
	}
	// 830E5E7C: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 830E5E80: 419A0010  beq cr6, 0x830e5e90
	if ctx.cr[6].eq {
		sub_830E5E90(ctx, base);
		return;
	}
	// 830E5E84: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 830E5E88: 60634005  ori r3, r3, 0x4005
	ctx.r[3].u64 = ctx.r[3].u64 | 16389;
	// 830E5E8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E5E90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830E5E90 size=48
    let mut pc: u32 = 0x830E5E90;
    'dispatch: loop {
        match pc {
            0x830E5E90 => {
    //   block [0x830E5E90..0x830E5EC0)
	// 830E5E90: C1A3008C  lfs f13, 0x8c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830E5E94: C0030094  lfs f0, 0x94(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E5E98: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 830E5E9C: C1A3004C  lfs f13, 0x4c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830E5EA0: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 830E5EA4: D0060004  stfs f0, 4(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830E5EA8: C003003C  lfs f0, 0x3c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E5EAC: C1A30090  lfs f13, 0x90(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830E5EB0: C1830088  lfs f12, 0x88(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(136 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830E5EB4: EDAD602A  fadds f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 830E5EB8: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 830E5EBC: 4800006C  b 0x830e5f28
	sub_830E5EC0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E5EC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830E5EC0 size=116
    let mut pc: u32 = 0x830E5EC0;
    'dispatch: loop {
        match pc {
            0x830E5EC0 => {
    //   block [0x830E5EC0..0x830E5F34)
	// 830E5EC0: C0030094  lfs f0, 0x94(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E5EC4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830E5EC8: C1A3004C  lfs f13, 0x4c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830E5ECC: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 830E5ED0: D0060004  stfs f0, 4(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830E5ED4: 419A0030  beq cr6, 0x830e5f04
	if ctx.cr[6].eq {
	pc = 0x830E5F04; continue 'dispatch;
	}
	// 830E5ED8: 3964FFFF  addi r11, r4, -1
	ctx.r[11].s64 = ctx.r[4].s64 + -1;
	// 830E5EDC: C1830040  lfs f12, 0x40(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830E5EE0: C1A30054  lfs f13, 0x54(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830E5EE4: 796B0020  clrldi r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 830E5EE8: EDAD602A  fadds f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 830E5EEC: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 830E5EF0: C981FFF0  lfd f12, -0x10(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E5EF4: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 830E5EF8: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 830E5EFC: EC0D033A  fmadds f0, f13, f12, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 830E5F00: D0060004  stfs f0, 4(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830E5F04: C1A60004  lfs f13, 4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830E5F08: C003008C  lfs f0, 0x8c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E5F0C: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 830E5F10: D0060004  stfs f0, 4(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830E5F14: C0030090  lfs f0, 0x90(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E5F18: C1A30088  lfs f13, 0x88(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(136 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830E5F1C: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 830E5F20: C1A3003C  lfs f13, 0x3c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830E5F24: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 830E5F28: D0060000  stfs f0, 0(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830E5F2C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E5F30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E5F38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830E5F38 size=36
    let mut pc: u32 = 0x830E5F38;
    'dispatch: loop {
        match pc {
            0x830E5F38 => {
    //   block [0x830E5F38..0x830E5F5C)
	// 830E5F38: 816300A0  lwz r11, 0xa0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(160 as u32) ) } as u64;
	// 830E5F3C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830E5F40: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E5F44: 914300A4  stw r10, 0xa4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(164 as u32), ctx.r[10].u32 ) };
	// 830E5F48: 409A0014  bne cr6, 0x830e5f5c
	if !ctx.cr[6].eq {
		sub_830E5F5C(ctx, base);
		return;
	}
	// 830E5F4C: 8163009C  lwz r11, 0x9c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(156 as u32) ) } as u64;
	// 830E5F50: 556B07FA  rlwinm r11, r11, 0, 0x1f, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830E5F54: 556B0776  rlwinm r11, r11, 0, 0x1d, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830E5F58: 48000034  b 0x830e5f8c
	sub_830E5F84(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E5F5C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830E5F5C size=24
    let mut pc: u32 = 0x830E5F5C;
    'dispatch: loop {
        match pc {
            0x830E5F5C => {
    //   block [0x830E5F5C..0x830E5F74)
	// 830E5F5C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830E5F60: 409A0014  bne cr6, 0x830e5f74
	if !ctx.cr[6].eq {
		sub_830E5F74(ctx, base);
		return;
	}
	// 830E5F64: 8163009C  lwz r11, 0x9c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(156 as u32) ) } as u64;
	// 830E5F68: 556B003C  rlwinm r11, r11, 0, 0, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830E5F6C: 556B07B8  rlwinm r11, r11, 0, 0x1e, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830E5F70: 4800001C  b 0x830e5f8c
	sub_830E5F84(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E5F74(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830E5F74 size=16
    let mut pc: u32 = 0x830E5F74;
    'dispatch: loop {
        match pc {
            0x830E5F74 => {
    //   block [0x830E5F74..0x830E5F84)
	// 830E5F74: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 830E5F78: 419A000C  beq cr6, 0x830e5f84
	if ctx.cr[6].eq {
		sub_830E5F84(ctx, base);
		return;
	}
	// 830E5F7C: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 830E5F80: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E5F84(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830E5F84 size=24
    let mut pc: u32 = 0x830E5F84;
    'dispatch: loop {
        match pc {
            0x830E5F84 => {
    //   block [0x830E5F84..0x830E5F9C)
	// 830E5F84: 8163009C  lwz r11, 0x9c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(156 as u32) ) } as u64;
	// 830E5F88: 556B0036  rlwinm r11, r11, 0, 0, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830E5F8C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830E5F90: 9163009C  stw r11, 0x9c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	// 830E5F94: 914300A4  stw r10, 0xa4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(164 as u32), ctx.r[10].u32 ) };
	// 830E5F98: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E5FA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830E5FA0 size=80
    let mut pc: u32 = 0x830E5FA0;
    'dispatch: loop {
        match pc {
            0x830E5FA0 => {
    //   block [0x830E5FA0..0x830E5FF0)
	// 830E5FA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E5FA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E5FA8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E5FAC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E5FB0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E5FB4: C01F0068  lfs f0, 0x68(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E5FB8: 909F0074  stw r4, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[4].u32 ) };
	// 830E5FBC: D01F0078  stfs f0, 0x78(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 830E5FC0: 90BF007C  stw r5, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[5].u32 ) };
	// 830E5FC4: 480DF09D  bl 0x831c5060
	ctx.lr = 0x830E5FC8;
	sub_831C5060(ctx, base);
	// 830E5FC8: 907F0080  stw r3, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[3].u32 ) };
	// 830E5FCC: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 830E5FD0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E5FD4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830E5FD8: 48019F21  bl 0x830ffef8
	ctx.lr = 0x830E5FDC;
	sub_830FFEF8(ctx, base);
	// 830E5FDC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830E5FE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E5FE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E5FE8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E5FEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E5FF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E5FF0 size=136
    let mut pc: u32 = 0x830E5FF0;
    'dispatch: loop {
        match pc {
            0x830E5FF0 => {
    //   block [0x830E5FF0..0x830E6078)
	// 830E5FF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E5FF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E5FF8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E5FFC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E6000: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830E6004: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E6008: 808BC06C  lwz r4, -0x3f94(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16276 as u32) ) } as u64;
	// 830E600C: 4BFE8B65  bl 0x830ceb70
	ctx.lr = 0x830E6010;
	sub_830CEB70(ctx, base);
	// 830E6010: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830E6014: 41820050  beq 0x830e6064
	if ctx.cr[0].eq {
	pc = 0x830E6064; continue 'dispatch;
	}
	// 830E6018: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 830E601C: 4BFE8455  bl 0x830ce470
	ctx.lr = 0x830E6020;
	sub_830CE470(ctx, base);
	// 830E6020: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830E6024: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830E6028: 419A003C  beq cr6, 0x830e6064
	if ctx.cr[6].eq {
	pc = 0x830E6064; continue 'dispatch;
	}
	// 830E602C: 814B00F0  lwz r10, 0xf0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(240 as u32) ) } as u64;
	// 830E6030: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E6034: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E6038: 614A0020  ori r10, r10, 0x20
	ctx.r[10].u64 = ctx.r[10].u64 | 32;
	// 830E603C: 914B00F0  stw r10, 0xf0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(240 as u32), ctx.r[10].u32 ) };
	// 830E6040: 4BFF9791  bl 0x830df7d0
	ctx.lr = 0x830E6044;
	sub_830DF7D0(ctx, base);
	// 830E6044: 48000014  b 0x830e6058
	pc = 0x830E6058; continue 'dispatch;
	// 830E6048: 4BFFFFA9  bl 0x830e5ff0
	ctx.lr = 0x830E604C;
	sub_830E5FF0(ctx, base);
	// 830E604C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E6050: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E6054: 4BFF986D  bl 0x830df8c0
	ctx.lr = 0x830E6058;
	sub_830DF8C0(ctx, base);
	// 830E6058: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E605C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830E6060: 409AFFE8  bne cr6, 0x830e6048
	if !ctx.cr[6].eq {
	pc = 0x830E6048; continue 'dispatch;
	}
	// 830E6064: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E6068: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E606C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E6070: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E6074: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E6078(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E6078 size=292
    let mut pc: u32 = 0x830E6078;
    'dispatch: loop {
        match pc {
            0x830E6078 => {
    //   block [0x830E6078..0x830E619C)
	// 830E6078: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E607C: 480C20DD  bl 0x831a8158
	ctx.lr = 0x830E6080;
	sub_831A8130(ctx, base);
	// 830E6080: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E6084: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 830E6088: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 830E608C: 3D408219  lis r10, -0x7de7
	ctx.r[10].s64 = -2112290816;
	// 830E6090: 3D208219  lis r9, -0x7de7
	ctx.r[9].s64 = -2112290816;
	// 830E6094: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 830E6098: 3B2A9130  addi r25, r10, -0x6ed0
	ctx.r[25].s64 = ctx.r[10].s64 + -28368;
	// 830E609C: 3B09911C  addi r24, r9, -0x6ee4
	ctx.r[24].s64 = ctx.r[9].s64 + -28388;
	// 830E60A0: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830E60A4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830E60A8: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830E60AC: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 830E60B0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830E60B4: 7F1EC378  mr r30, r24
	ctx.r[30].u64 = ctx.r[24].u64;
	// 830E60B8: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 830E60BC: 419A0048  beq cr6, 0x830e6104
	if ctx.cr[6].eq {
	pc = 0x830E6104; continue 'dispatch;
	}
	// 830E60C0: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830E60C4: 3D408219  lis r10, -0x7de7
	ctx.r[10].s64 = -2112290816;
	// 830E60C8: 3BEB9110  addi r31, r11, -0x6ef0
	ctx.r[31].s64 = ctx.r[11].s64 + -28400;
	// 830E60CC: 3BCA90FC  addi r30, r10, -0x6f04
	ctx.r[30].s64 = ctx.r[10].s64 + -28420;
	// 830E60D0: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 830E60D4: 409A0068  bne cr6, 0x830e613c
	if !ctx.cr[6].eq {
	pc = 0x830E613C; continue 'dispatch;
	}
	// 830E60D8: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830E60DC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830E60E0: 3B4B908C  addi r26, r11, -0x6f74
	ctx.r[26].s64 = ctx.r[11].s64 + -28532;
	// 830E60E4: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 830E60E8: 4BFFA0D1  bl 0x830e01b8
	ctx.lr = 0x830E60EC;
	sub_830E01B8(ctx, base);
	// 830E60EC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E60F0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E60F4: 41980048  blt cr6, 0x830e613c
	if ctx.cr[6].lt {
	pc = 0x830E613C; continue 'dispatch;
	}
	// 830E60F8: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830E60FC: 3BCB906C  addi r30, r11, -0x6f94
	ctx.r[30].s64 = ctx.r[11].s64 + -28564;
	// 830E6100: 48000038  b 0x830e6138
	pc = 0x830E6138; continue 'dispatch;
	// 830E6104: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 830E6108: 409A0034  bne cr6, 0x830e613c
	if !ctx.cr[6].eq {
	pc = 0x830E613C; continue 'dispatch;
	}
	// 830E610C: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830E6110: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830E6114: 3B4B90CC  addi r26, r11, -0x6f34
	ctx.r[26].s64 = ctx.r[11].s64 + -28468;
	// 830E6118: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830E611C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 830E6120: 4BFFA099  bl 0x830e01b8
	ctx.lr = 0x830E6124;
	sub_830E01B8(ctx, base);
	// 830E6124: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E6128: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E612C: 41980010  blt cr6, 0x830e613c
	if ctx.cr[6].lt {
	pc = 0x830E613C; continue 'dispatch;
	}
	// 830E6130: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830E6134: 3BCB90A8  addi r30, r11, -0x6f58
	ctx.r[30].s64 = ctx.r[11].s64 + -28504;
	// 830E6138: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 830E613C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 830E6140: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E6144: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830E6148: 4BFFA071  bl 0x830e01b8
	ctx.lr = 0x830E614C;
	sub_830E01B8(ctx, base);
	// 830E614C: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 830E6150: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830E6154: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830E6158: 4BFFA061  bl 0x830e01b8
	ctx.lr = 0x830E615C;
	sub_830E01B8(ctx, base);
	// 830E615C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E6160: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E6164: 41980010  blt cr6, 0x830e6174
	if ctx.cr[6].lt {
	pc = 0x830E6174; continue 'dispatch;
	}
	// 830E6168: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E616C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E6170: 40980024  bge cr6, 0x830e6194
	if !ctx.cr[6].lt {
	pc = 0x830E6194; continue 'dispatch;
	}
	// 830E6174: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 830E6178: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 830E617C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830E6180: 4BFFA039  bl 0x830e01b8
	ctx.lr = 0x830E6184;
	sub_830E01B8(ctx, base);
	// 830E6184: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 830E6188: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 830E618C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830E6190: 4BFFA029  bl 0x830e01b8
	ctx.lr = 0x830E6194;
	sub_830E01B8(ctx, base);
	// 830E6194: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830E6198: 480C2010  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E61A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E61A0 size=112
    let mut pc: u32 = 0x830E61A0;
    'dispatch: loop {
        match pc {
            0x830E61A0 => {
    //   block [0x830E61A0..0x830E6210)
	// 830E61A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E61A4: 480C1FC5  bl 0x831a8168
	ctx.lr = 0x830E61A8;
	sub_831A8130(ctx, base);
	// 830E61A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E61AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830E61B0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830E61B4: 3BBE0064  addi r29, r30, 0x64
	ctx.r[29].s64 = ctx.r[30].s64 + 100;
	// 830E61B8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 830E61BC: 807E0064  lwz r3, 0x64(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 830E61C0: 4BFF7319  bl 0x830dd4d8
	ctx.lr = 0x830E61C4;
	sub_830DD4D8(ctx, base);
	// 830E61C4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830E61C8: 939E0064  stw r28, 0x64(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 830E61CC: 419A0038  beq cr6, 0x830e6204
	if ctx.cr[6].eq {
	pc = 0x830E6204; continue 'dispatch;
	}
	// 830E61D0: 3BDE0098  addi r30, r30, 0x98
	ctx.r[30].s64 = ctx.r[30].s64 + 152;
	// 830E61D4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E61D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E61DC: 4BFFEC95  bl 0x830e4e70
	ctx.lr = 0x830E61E0;
	sub_830E4E70(ctx, base);
	// 830E61E0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E61E4: 41800024  blt 0x830e6208
	if ctx.cr[0].lt {
	pc = 0x830E6208; continue 'dispatch;
	}
	// 830E61E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E61EC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830E61F0: 4BFE8A99  bl 0x830cec88
	ctx.lr = 0x830E61F4;
	sub_830CEC88(ctx, base);
	// 830E61F4: 7C7C1B79  or. r28, r3, r3
	ctx.r[28].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 830E61F8: 4080000C  bge 0x830e6204
	if !ctx.cr[0].lt {
	pc = 0x830E6204; continue 'dispatch;
	}
	// 830E61FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E6200: 4BFE72E1  bl 0x830cd4e0
	ctx.lr = 0x830E6204;
	sub_830CD4E0(ctx, base);
	// 830E6204: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830E6208: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830E620C: 480C1FAC  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E6210(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E6210 size=220
    let mut pc: u32 = 0x830E6210;
    'dispatch: loop {
        match pc {
            0x830E6210 => {
    //   block [0x830E6210..0x830E62EC)
	// 830E6210: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E6214: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E6218: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E621C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E6220: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E6224: 807F005C  lwz r3, 0x5c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 830E6228: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830E622C: 419A00A8  beq cr6, 0x830e62d4
	if ctx.cr[6].eq {
	pc = 0x830E62D4; continue 'dispatch;
	}
	// 830E6230: 480C2E99  bl 0x831a90c8
	ctx.lr = 0x830E6234;
	sub_831A90C8(ctx, base);
	// 830E6234: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 830E6238: 815F005C  lwz r10, 0x5c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 830E623C: 813F0068  lwz r9, 0x68(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 830E6240: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830E6244: 7CEB5214  add r7, r11, r10
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830E6248: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 830E624C: 419A0040  beq cr6, 0x830e628c
	if ctx.cr[6].eq {
	pc = 0x830E628C; continue 'dispatch;
	}
	// 830E6250: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 830E6254: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 830E6258: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 830E625C: 40980028  bge cr6, 0x830e6284
	if !ctx.cr[6].lt {
	pc = 0x830E6284; continue 'dispatch;
	}
	// 830E6260: 7D6B1850  subf r11, r11, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 830E6264: 7CEA3B78  mr r10, r7
	ctx.r[10].u64 = ctx.r[7].u64;
	// 830E6268: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 830E626C: 811F0068  lwz r8, 0x68(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 830E6270: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E6274: A1080000  lhz r8, 0(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E6278: B10A0000  sth r8, 0(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u16 ) };
	// 830E627C: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 830E6280: 4082FFEC  bne 0x830e626c
	if !ctx.cr[0].eq {
	pc = 0x830E626C; continue 'dispatch;
	}
	// 830E6284: 552B083C  slwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830E6288: 48000044  b 0x830e62cc
	pc = 0x830E62CC; continue 'dispatch;
	// 830E628C: 815F0074  lwz r10, 0x74(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 830E6290: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 830E6294: 7F0A1840  cmplw cr6, r10, r3
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[3].u32, &mut ctx.xer);
	// 830E6298: 40980030  bge cr6, 0x830e62c8
	if !ctx.cr[6].lt {
	pc = 0x830E62C8; continue 'dispatch;
	}
	// 830E629C: 7D6A1850  subf r11, r10, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[10].s64;
	// 830E62A0: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830E62A4: 7CE93B78  mr r9, r7
	ctx.r[9].u64 = ctx.r[7].u64;
	// 830E62A8: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 830E62AC: 80DF005C  lwz r6, 0x5c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 830E62B0: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E62B4: 7CCA322E  lhzx r6, r10, r6
	ctx.r[6].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 830E62B8: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 830E62BC: B0C90000  sth r6, 0(r9)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[6].u16 ) };
	// 830E62C0: 39290002  addi r9, r9, 2
	ctx.r[9].s64 = ctx.r[9].s64 + 2;
	// 830E62C4: 4082FFE8  bne 0x830e62ac
	if !ctx.cr[0].eq {
	pc = 0x830E62AC; continue 'dispatch;
	}
	// 830E62C8: 550B083C  slwi r11, r8, 1
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830E62CC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830E62D0: 7D4B3B2E  sthx r10, r11, r7
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[7].u32), ctx.r[10].u16) };
	// 830E62D4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E62D8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830E62DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E62E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E62E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E62E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E62F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E62F0 size=88
    let mut pc: u32 = 0x830E62F0;
    'dispatch: loop {
        match pc {
            0x830E62F0 => {
    //   block [0x830E62F0..0x830E6348)
	// 830E62F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E62F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E62F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E62FC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E6300: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E6304: 897F00BC  lbz r11, 0xbc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) } as u64;
	// 830E6308: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830E630C: 40820028  bne 0x830e6334
	if !ctx.cr[0].eq {
	pc = 0x830E6334; continue 'dispatch;
	}
	// 830E6310: 480DED51  bl 0x831c5060
	ctx.lr = 0x830E6314;
	sub_831C5060(ctx, base);
	// 830E6314: 907F00B8  stw r3, 0xb8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), ctx.r[3].u32 ) };
	// 830E6318: 3C80AABB  lis r4, -0x5545
	ctx.r[4].s64 = -1430585344;
	// 830E631C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E6320: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 830E6324: 6084CCDD  ori r4, r4, 0xccdd
	ctx.r[4].u64 = ctx.r[4].u64 | 52445;
	// 830E6328: 48019BD1  bl 0x830ffef8
	ctx.lr = 0x830E632C;
	sub_830FFEF8(ctx, base);
	// 830E632C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830E6330: 997F00BC  stb r11, 0xbc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), ctx.r[11].u8 ) };
	// 830E6334: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830E6338: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E633C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E6340: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E6344: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E6348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E6348 size=156
    let mut pc: u32 = 0x830E6348;
    'dispatch: loop {
        match pc {
            0x830E6348 => {
    //   block [0x830E6348..0x830E63E4)
	// 830E6348: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E634C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E6350: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830E6354: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E6358: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E635C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E6360: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830E6364: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 830E6368: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830E636C: 419A0034  beq cr6, 0x830e63a0
	if ctx.cr[6].eq {
	pc = 0x830E63A0; continue 'dispatch;
	}
	// 830E6370: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 830E6374: 409A004C  bne cr6, 0x830e63c0
	if !ctx.cr[6].eq {
	pc = 0x830E63C0; continue 'dispatch;
	}
	// 830E6378: 807F0084  lwz r3, 0x84(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 830E637C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830E6380: 419A0040  beq cr6, 0x830e63c0
	if ctx.cr[6].eq {
	pc = 0x830E63C0; continue 'dispatch;
	}
	// 830E6384: 4BFF938D  bl 0x830df710
	ctx.lr = 0x830E6388;
	sub_830DF710(ctx, base);
	// 830E6388: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830E638C: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 830E6390: 419A002C  beq cr6, 0x830e63bc
	if ctx.cr[6].eq {
	pc = 0x830E63BC; continue 'dispatch;
	}
	// 830E6394: 807F0084  lwz r3, 0x84(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 830E6398: 4BFF3491  bl 0x830d9828
	ctx.lr = 0x830E639C;
	sub_830D9828(ctx, base);
	// 830E639C: 48000020  b 0x830e63bc
	pc = 0x830E63BC; continue 'dispatch;
	// 830E63A0: 807F0084  lwz r3, 0x84(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 830E63A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830E63A8: 419A0018  beq cr6, 0x830e63c0
	if ctx.cr[6].eq {
	pc = 0x830E63C0; continue 'dispatch;
	}
	// 830E63AC: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830E63B0: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 830E63B4: 419A0008  beq cr6, 0x830e63bc
	if ctx.cr[6].eq {
	pc = 0x830E63BC; continue 'dispatch;
	}
	// 830E63B8: 4802A0A9  bl 0x83110460
	ctx.lr = 0x830E63BC;
	sub_83110460(ctx, base);
	// 830E63BC: 93DF0084  stw r30, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	// 830E63C0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830E63C4: 93DF0074  stw r30, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[30].u32 ) };
	// 830E63C8: 917F0078  stw r11, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 830E63CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E63D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E63D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E63D8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830E63DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E63E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E63E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E63E8 size=100
    let mut pc: u32 = 0x830E63E8;
    'dispatch: loop {
        match pc {
            0x830E63E8 => {
    //   block [0x830E63E8..0x830E644C)
	// 830E63E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E63EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E63F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830E63F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E63F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E63FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E6400: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830E6404: 389F0068  addi r4, r31, 0x68
	ctx.r[4].s64 = ctx.r[31].s64 + 104;
	// 830E6408: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 830E640C: 90BF0084  stw r5, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 830E6410: 4BFF9641  bl 0x830dfa50
	ctx.lr = 0x830E6414;
	sub_830DFA50(ctx, base);
	// 830E6414: 389F005C  addi r4, r31, 0x5c
	ctx.r[4].s64 = ctx.r[31].s64 + 92;
	// 830E6418: 807F0084  lwz r3, 0x84(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 830E641C: 4BFF96D5  bl 0x830dfaf0
	ctx.lr = 0x830E6420;
	sub_830DFAF0(ctx, base);
	// 830E6420: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E6424: 809F0084  lwz r4, 0x84(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 830E6428: 4BFF9299  bl 0x830df6c0
	ctx.lr = 0x830E642C;
	sub_830DF6C0(ctx, base);
	// 830E642C: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 830E6430: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 830E6434: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E6438: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E643C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E6440: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830E6444: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E6448: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E6450(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830E6450 size=12
    let mut pc: u32 = 0x830E6450;
    'dispatch: loop {
        match pc {
            0x830E6450 => {
    //   block [0x830E6450..0x830E645C)
	// 830E6450: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E6454: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830E6458: 4BFF9DE0  b 0x830e0238
	sub_830E0238(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E6460(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830E6460 size=12
    let mut pc: u32 = 0x830E6460;
    'dispatch: loop {
        match pc {
            0x830E6460 => {
    //   block [0x830E6460..0x830E646C)
	// 830E6460: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830E6464: 386B9308  addi r3, r11, -0x6cf8
	ctx.r[3].s64 = ctx.r[11].s64 + -27896;
	// 830E6468: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E6470(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830E6470 size=16
    let mut pc: u32 = 0x830E6470;
    'dispatch: loop {
        match pc {
            0x830E6470 => {
    //   block [0x830E6470..0x830E6480)
	// 830E6470: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E6474: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E6478: 2B0B000B  cmplwi cr6, r11, 0xb
	ctx.cr[6].compare_u32(ctx.r[11].u32, 11 as u32, &mut ctx.xer);
	// 830E647C: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E6480(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830E6480 size=24
    let mut pc: u32 = 0x830E6480;
    'dispatch: loop {
        match pc {
            0x830E6480 => {
    //   block [0x830E6480..0x830E6498)
	// 830E6480: 81640010  lwz r11, 0x10(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 830E6484: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830E6488: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 830E648C: 91440008  stw r10, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830E6490: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 830E6494: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E6498(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830E6498 size=120
    let mut pc: u32 = 0x830E6498;
    'dispatch: loop {
        match pc {
            0x830E6498 => {
    //   block [0x830E6498..0x830E6510)
	// 830E6498: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 830E649C: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 830E64A0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830E64A4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830E64A8: C1A908A4  lfs f13, 0x8a4(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830E64AC: C0040000  lfs f0, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E64B0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830E64B4: 4198005C  blt cr6, 0x830e6510
	if ctx.cr[6].lt {
		sub_830E6510(ctx, base);
		return;
	}
	// 830E64B8: 812A0020  lwz r9, 0x20(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 830E64BC: F921FFF0  std r9, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[9].u64 ) };
	// 830E64C0: C981FFF0  lfd f12, -0x10(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E64C4: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 830E64C8: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 830E64CC: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 830E64D0: 40980040  bge cr6, 0x830e6510
	if !ctx.cr[6].lt {
		sub_830E6510(ctx, base);
		return;
	}
	// 830E64D4: C0040004  lfs f0, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E64D8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830E64DC: 41980034  blt cr6, 0x830e6510
	if ctx.cr[6].lt {
		sub_830E6510(ctx, base);
		return;
	}
	// 830E64E0: 812A0024  lwz r9, 0x24(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(36 as u32) ) } as u64;
	// 830E64E4: F921FFF8  std r9, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[9].u64 ) };
	// 830E64E8: C981FFF8  lfd f12, -8(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 830E64EC: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 830E64F0: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 830E64F4: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 830E64F8: 40980018  bge cr6, 0x830e6510
	if !ctx.cr[6].lt {
		sub_830E6510(ctx, base);
		return;
	}
	// 830E64FC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830E6500: 3884000C  addi r4, r4, 0xc
	ctx.r[4].s64 = ctx.r[4].s64 + 12;
	// 830E6504: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 830E6508: 4198FFA4  blt cr6, 0x830e64ac
	if ctx.cr[6].lt {
	pc = 0x830E64AC; continue 'dispatch;
	}
	// 830E650C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E6510(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830E6510 size=8
    let mut pc: u32 = 0x830E6510;
    'dispatch: loop {
        match pc {
            0x830E6510 => {
    //   block [0x830E6510..0x830E6518)
	// 830E6510: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E6514: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E6518(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E6518 size=144
    let mut pc: u32 = 0x830E6518;
    'dispatch: loop {
        match pc {
            0x830E6518 => {
    //   block [0x830E6518..0x830E65A8)
	// 830E6518: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E651C: 480C1C51  bl 0x831a816c
	ctx.lr = 0x830E6520;
	sub_831A8130(ctx, base);
	// 830E6520: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 830E6524: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 830E6528: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E652C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E6530: FFE01890  fmr f31, f3
	ctx.f[31].f64 = ctx.f[3].f64;
	// 830E6534: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E6538: FFC02090  fmr f30, f4
	ctx.f[30].f64 = ctx.f[4].f64;
	// 830E653C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830E6540: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 830E6544: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 830E6548: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 830E654C: 83FE0000  lwz r31, 0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E6550: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830E6554: 419A0030  beq cr6, 0x830e6584
	if ctx.cr[6].eq {
	pc = 0x830E6584; continue 'dispatch;
	}
	// 830E6558: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E655C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E6560: 4BFF9989  bl 0x830dfee8
	ctx.lr = 0x830E6564;
	sub_830DFEE8(ctx, base);
	// 830E6564: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E6568: 41800030  blt 0x830e6598
	if ctx.cr[0].lt {
	pc = 0x830E6598; continue 'dispatch;
	}
	// 830E656C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 830E6570: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E6574: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E6578: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 830E657C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 830E6580: 4BFFF061  bl 0x830e55e0
	ctx.lr = 0x830E6584;
	sub_830E55E0(ctx, base);
	// 830E6584: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 830E6588: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 830E658C: 2B1D0002  cmplwi cr6, r29, 2
	ctx.cr[6].compare_u32(ctx.r[29].u32, 2 as u32, &mut ctx.xer);
	// 830E6590: 4198FFBC  blt cr6, 0x830e654c
	if ctx.cr[6].lt {
	pc = 0x830E654C; continue 'dispatch;
	}
	// 830E6594: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E6598: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830E659C: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 830E65A0: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 830E65A4: 480C1C18  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E65A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E65A8 size=112
    let mut pc: u32 = 0x830E65A8;
    'dispatch: loop {
        match pc {
            0x830E65A8 => {
    //   block [0x830E65A8..0x830E6618)
	// 830E65A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E65AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E65B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830E65B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E65B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E65BC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830E65C0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830E65C4: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830E65C8: 41980034  blt cr6, 0x830e65fc
	if ctx.cr[6].lt {
	pc = 0x830E65FC; continue 'dispatch;
	}
	// 830E65CC: 3D600492  lis r11, 0x492
	ctx.r[11].s64 = 76677120;
	// 830E65D0: 616B4924  ori r11, r11, 0x4924
	ctx.r[11].u64 = ctx.r[11].u64 | 18724;
	// 830E65D4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830E65D8: 40980024  bge cr6, 0x830e65fc
	if !ctx.cr[6].lt {
	pc = 0x830E65FC; continue 'dispatch;
	}
	// 830E65DC: 1C7F001C  mulli r3, r31, 0x1c
	ctx.r[3].s64 = ctx.r[31].s64 * 28;
	// 830E65E0: 4BFF6ED1  bl 0x830dd4b0
	ctx.lr = 0x830E65E4;
	sub_830DD4B0(ctx, base);
	// 830E65E4: 907E0000  stw r3, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 830E65E8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830E65EC: 41820010  beq 0x830e65fc
	if ctx.cr[0].eq {
	pc = 0x830E65FC; continue 'dispatch;
	}
	// 830E65F0: 93FE0008  stw r31, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 830E65F4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830E65F8: 48000008  b 0x830e6600
	pc = 0x830E6600; continue 'dispatch;
	// 830E65FC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E6600: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E6604: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E6608: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E660C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830E6610: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E6614: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E6618(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E6618 size=128
    let mut pc: u32 = 0x830E6618;
    'dispatch: loop {
        match pc {
            0x830E6618 => {
    //   block [0x830E6618..0x830E6698)
	// 830E6618: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E661C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E6620: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E6624: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E6628: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E662C: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 830E6630: 41980050  blt cr6, 0x830e6680
	if ctx.cr[6].lt {
	pc = 0x830E6680; continue 'dispatch;
	}
	// 830E6634: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E6638: 7F045800  cmpw cr6, r4, r11
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830E663C: 40980044  bge cr6, 0x830e6680
	if !ctx.cr[6].lt {
	pc = 0x830E6680; continue 'dispatch;
	}
	// 830E6640: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 830E6644: 7F045000  cmpw cr6, r4, r10
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830E6648: 419A0024  beq cr6, 0x830e666c
	if ctx.cr[6].eq {
	pc = 0x830E666C; continue 'dispatch;
	}
	// 830E664C: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E6650: 1D44001C  mulli r10, r4, 0x1c
	ctx.r[10].s64 = ctx.r[4].s64 * 28;
	// 830E6654: 7D645850  subf r11, r4, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[4].s64;
	// 830E6658: 7C6A4A14  add r3, r10, r9
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 830E665C: 1D6B001C  mulli r11, r11, 0x1c
	ctx.r[11].s64 = ctx.r[11].s64 * 28;
	// 830E6660: 3883001C  addi r4, r3, 0x1c
	ctx.r[4].s64 = ctx.r[3].s64 + 28;
	// 830E6664: 38ABFFE4  addi r5, r11, -0x1c
	ctx.r[5].s64 = ctx.r[11].s64 + -28;
	// 830E6668: 480C6CE9  bl 0x831ad350
	ctx.lr = 0x830E666C;
	sub_831AD350(ctx, base);
	// 830E666C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E6670: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830E6674: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830E6678: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830E667C: 48000008  b 0x830e6684
	pc = 0x830E6684; continue 'dispatch;
	// 830E6680: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E6684: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830E6688: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E668C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E6690: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E6694: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E6698(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830E6698 size=20
    let mut pc: u32 = 0x830E6698;
    'dispatch: loop {
        match pc {
            0x830E6698 => {
    //   block [0x830E6698..0x830E66AC)
	// 830E6698: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 830E669C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830E66A0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E66A4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830E66A8: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E66AC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830E66AC size=64
    let mut pc: u32 = 0x830E66AC;
    'dispatch: loop {
        match pc {
            0x830E66AC => {
    //   block [0x830E66AC..0x830E66EC)
	// 830E66AC: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830E66B0: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 830E66B4: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E66B8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E66BC: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 830E66C0: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830E66C4: 0CC80000  twi 6, r8, 0
	// 830E66C8: 7CE943D6  divw r7, r9, r8
	ctx.r[7].s32 = ctx.r[9].s32 / ctx.r[8].s32;
	// 830E66CC: 552A083E  rotlwi r10, r9, 1
	ctx.r[10].u64 = ((ctx.r[9].u32).rotate_left(1)) as u64;
	// 830E66D0: 7CE741D6  mullw r7, r7, r8
	ctx.r[7].s64 = (ctx.r[7].s32 as i64) * (ctx.r[8].s32 as i64);
	// 830E66D4: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 830E66D8: 7D274850  subf r9, r7, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[7].s64;
	// 830E66DC: 7D0A5078  andc r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 & !ctx.r[10].u64;
	// 830E66E0: 912B000C  stw r9, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 830E66E4: 0CAAFFFF  twi 5, r10, -1
	// 830E66E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E66F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E66F0 size=148
    let mut pc: u32 = 0x830E66F0;
    'dispatch: loop {
        match pc {
            0x830E66F0 => {
    //   block [0x830E66F0..0x830E6784)
	// 830E66F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E66F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E66F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830E66FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E6700: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E6704: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830E6708: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E670C: 7D44F214  add r10, r4, r30
	ctx.r[10].u64 = ctx.r[4].u64 + ctx.r[30].u64;
	// 830E6710: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 830E6714: 41980054  blt cr6, 0x830e6768
	if ctx.cr[6].lt {
	pc = 0x830E6768; continue 'dispatch;
	}
	// 830E6718: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830E671C: 4198004C  blt cr6, 0x830e6768
	if ctx.cr[6].lt {
	pc = 0x830E6768; continue 'dispatch;
	}
	// 830E6720: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830E6724: 41980044  blt cr6, 0x830e6768
	if ctx.cr[6].lt {
	pc = 0x830E6768; continue 'dispatch;
	}
	// 830E6728: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E672C: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 830E6730: 41990038  bgt cr6, 0x830e6768
	if ctx.cr[6].gt {
	pc = 0x830E6768; continue 'dispatch;
	}
	// 830E6734: 7D0A4850  subf r8, r10, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 830E6738: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E673C: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 830E6740: 548A103A  slwi r10, r4, 2
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830E6744: 5505103A  slwi r5, r8, 2
	ctx.r[5].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 830E6748: 7C895A14  add r4, r9, r11
	ctx.r[4].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 830E674C: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 830E6750: 480C6C01  bl 0x831ad350
	ctx.lr = 0x830E6754;
	sub_831AD350(ctx, base);
	// 830E6754: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E6758: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830E675C: 7D7E5850  subf r11, r30, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 830E6760: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830E6764: 48000008  b 0x830e676c
	pc = 0x830E676C; continue 'dispatch;
	// 830E6768: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E676C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E6770: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E6774: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E6778: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830E677C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E6780: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E6788(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E6788 size=128
    let mut pc: u32 = 0x830E6788;
    'dispatch: loop {
        match pc {
            0x830E6788 => {
    //   block [0x830E6788..0x830E6808)
	// 830E6788: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E678C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E6790: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E6794: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E6798: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E679C: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 830E67A0: 41980050  blt cr6, 0x830e67f0
	if ctx.cr[6].lt {
	pc = 0x830E67F0; continue 'dispatch;
	}
	// 830E67A4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E67A8: 7F045800  cmpw cr6, r4, r11
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830E67AC: 40980044  bge cr6, 0x830e67f0
	if !ctx.cr[6].lt {
	pc = 0x830E67F0; continue 'dispatch;
	}
	// 830E67B0: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 830E67B4: 7F045000  cmpw cr6, r4, r10
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830E67B8: 419A0024  beq cr6, 0x830e67dc
	if ctx.cr[6].eq {
	pc = 0x830E67DC; continue 'dispatch;
	}
	// 830E67BC: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E67C0: 1D4400A8  mulli r10, r4, 0xa8
	ctx.r[10].s64 = ctx.r[4].s64 * 168;
	// 830E67C4: 7D645850  subf r11, r4, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[4].s64;
	// 830E67C8: 7C6A4A14  add r3, r10, r9
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 830E67CC: 1D6B00A8  mulli r11, r11, 0xa8
	ctx.r[11].s64 = ctx.r[11].s64 * 168;
	// 830E67D0: 388300A8  addi r4, r3, 0xa8
	ctx.r[4].s64 = ctx.r[3].s64 + 168;
	// 830E67D4: 38ABFF58  addi r5, r11, -0xa8
	ctx.r[5].s64 = ctx.r[11].s64 + -168;
	// 830E67D8: 480C6B79  bl 0x831ad350
	ctx.lr = 0x830E67DC;
	sub_831AD350(ctx, base);
	// 830E67DC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E67E0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830E67E4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830E67E8: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830E67EC: 48000008  b 0x830e67f4
	pc = 0x830E67F4; continue 'dispatch;
	// 830E67F0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E67F4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830E67F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E67FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E6800: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E6804: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E6808(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E6808 size=128
    let mut pc: u32 = 0x830E6808;
    'dispatch: loop {
        match pc {
            0x830E6808 => {
    //   block [0x830E6808..0x830E6888)
	// 830E6808: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E680C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E6810: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E6814: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E6818: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E681C: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 830E6820: 41980050  blt cr6, 0x830e6870
	if ctx.cr[6].lt {
	pc = 0x830E6870; continue 'dispatch;
	}
	// 830E6824: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E6828: 7F045800  cmpw cr6, r4, r11
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830E682C: 40980044  bge cr6, 0x830e6870
	if !ctx.cr[6].lt {
	pc = 0x830E6870; continue 'dispatch;
	}
	// 830E6830: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 830E6834: 7F045000  cmpw cr6, r4, r10
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830E6838: 419A0024  beq cr6, 0x830e685c
	if ctx.cr[6].eq {
	pc = 0x830E685C; continue 'dispatch;
	}
	// 830E683C: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E6840: 548A103A  slwi r10, r4, 2
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830E6844: 7D645850  subf r11, r4, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[4].s64;
	// 830E6848: 7C6A4A14  add r3, r10, r9
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 830E684C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830E6850: 38830004  addi r4, r3, 4
	ctx.r[4].s64 = ctx.r[3].s64 + 4;
	// 830E6854: 38ABFFFC  addi r5, r11, -4
	ctx.r[5].s64 = ctx.r[11].s64 + -4;
	// 830E6858: 480C6AF9  bl 0x831ad350
	ctx.lr = 0x830E685C;
	sub_831AD350(ctx, base);
	// 830E685C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E6860: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830E6864: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830E6868: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830E686C: 48000008  b 0x830e6874
	pc = 0x830E6874; continue 'dispatch;
	// 830E6870: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E6874: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830E6878: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E687C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E6880: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E6884: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E6888(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E6888 size=132
    let mut pc: u32 = 0x830E6888;
    'dispatch: loop {
        match pc {
            0x830E6888 => {
    //   block [0x830E6888..0x830E690C)
	// 830E6888: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E688C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E6890: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830E6894: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E6898: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E689C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830E68A0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830E68A4: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830E68A8: 41980044  blt cr6, 0x830e68ec
	if ctx.cr[6].lt {
	pc = 0x830E68EC; continue 'dispatch;
	}
	// 830E68AC: 3D600666  lis r11, 0x666
	ctx.r[11].s64 = 107347968;
	// 830E68B0: 616B6666  ori r11, r11, 0x6666
	ctx.r[11].u64 = ctx.r[11].u64 | 26214;
	// 830E68B4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830E68B8: 41990034  bgt cr6, 0x830e68ec
	if ctx.cr[6].gt {
	pc = 0x830E68EC; continue 'dispatch;
	}
	// 830E68BC: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830E68C0: 40990024  ble cr6, 0x830e68e4
	if !ctx.cr[6].gt {
	pc = 0x830E68E4; continue 'dispatch;
	}
	// 830E68C4: 1C7F0014  mulli r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 * 20;
	// 830E68C8: 4BFF6BE9  bl 0x830dd4b0
	ctx.lr = 0x830E68CC;
	sub_830DD4B0(ctx, base);
	// 830E68CC: 907E0000  stw r3, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 830E68D0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830E68D4: 41820018  beq 0x830e68ec
	if ctx.cr[0].eq {
	pc = 0x830E68EC; continue 'dispatch;
	}
	// 830E68D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830E68DC: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 830E68E0: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830E68E4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E68E8: 4800000C  b 0x830e68f4
	pc = 0x830E68F4; continue 'dispatch;
	// 830E68EC: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 830E68F0: 6063000E  ori r3, r3, 0xe
	ctx.r[3].u64 = ctx.r[3].u64 | 14;
	// 830E68F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E68F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E68FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E6900: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830E6904: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E6908: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E6910(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E6910 size=80
    let mut pc: u32 = 0x830E6910;
    'dispatch: loop {
        match pc {
            0x830E6910 => {
    //   block [0x830E6910..0x830E6960)
	// 830E6910: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E6914: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E6918: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830E691C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E6920: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E6924: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E6928: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830E692C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E6930: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830E6934: 419A000C  beq cr6, 0x830e6940
	if ctx.cr[6].eq {
	pc = 0x830E6940; continue 'dispatch;
	}
	// 830E6938: 4BFF6BA1  bl 0x830dd4d8
	ctx.lr = 0x830E693C;
	sub_830DD4D8(ctx, base);
	// 830E693C: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 830E6940: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 830E6944: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 830E6948: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E694C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E6950: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E6954: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830E6958: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E695C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E6960(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E6960 size=80
    let mut pc: u32 = 0x830E6960;
    'dispatch: loop {
        match pc {
            0x830E6960 => {
    //   block [0x830E6960..0x830E69B0)
	// 830E6960: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E6964: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E6968: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830E696C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E6970: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E6974: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830E6978: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 830E697C: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 830E6980: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830E6984: 4801B66D  bl 0x83101ff0
	ctx.lr = 0x830E6988;
	sub_83101FF0(ctx, base);
	// 830E6988: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 830E698C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E6990: 4801D109  bl 0x83103a98
	ctx.lr = 0x830E6994;
	sub_83103A98(ctx, base);
	// 830E6994: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 830E6998: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E699C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E69A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E69A4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830E69A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E69AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E69B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E69B0 size=80
    let mut pc: u32 = 0x830E69B0;
    'dispatch: loop {
        match pc {
            0x830E69B0 => {
    //   block [0x830E69B0..0x830E6A00)
	// 830E69B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E69B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E69B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830E69BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E69C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E69C4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830E69C8: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 830E69CC: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 830E69D0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830E69D4: 4801B61D  bl 0x83101ff0
	ctx.lr = 0x830E69D8;
	sub_83101FF0(ctx, base);
	// 830E69D8: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 830E69DC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E69E0: 4801D0B9  bl 0x83103a98
	ctx.lr = 0x830E69E4;
	sub_83103A98(ctx, base);
	// 830E69E4: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 830E69E8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E69EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E69F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E69F4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830E69F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E69FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E6A00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E6A00 size=80
    let mut pc: u32 = 0x830E6A00;
    'dispatch: loop {
        match pc {
            0x830E6A00 => {
    //   block [0x830E6A00..0x830E6A50)
	// 830E6A00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E6A04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E6A08: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830E6A0C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E6A10: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E6A14: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830E6A18: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 830E6A1C: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 830E6A20: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830E6A24: 4801B5CD  bl 0x83101ff0
	ctx.lr = 0x830E6A28;
	sub_83101FF0(ctx, base);
	// 830E6A28: 38A0000C  li r5, 0xc
	ctx.r[5].s64 = 12;
	// 830E6A2C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E6A30: 4801D069  bl 0x83103a98
	ctx.lr = 0x830E6A34;
	sub_83103A98(ctx, base);
	// 830E6A34: FBDF0000  std r30, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u64 ) };
	// 830E6A38: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E6A3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E6A40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E6A44: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830E6A48: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E6A4C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E6A50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E6A50 size=84
    let mut pc: u32 = 0x830E6A50;
    'dispatch: loop {
        match pc {
            0x830E6A50 => {
    //   block [0x830E6A50..0x830E6AA4)
	// 830E6A50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E6A54: 480C1715  bl 0x831a8168
	ctx.lr = 0x830E6A58;
	sub_831A8130(ctx, base);
	// 830E6A58: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E6A5C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830E6A60: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830E6A64: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 830E6A68: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830E6A6C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 830E6A70: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 830E6A74: 4801B57D  bl 0x83101ff0
	ctx.lr = 0x830E6A78;
	sub_83101FF0(ctx, base);
	// 830E6A78: 38A00014  li r5, 0x14
	ctx.r[5].s64 = 20;
	// 830E6A7C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E6A80: 4801D019  bl 0x83103a98
	ctx.lr = 0x830E6A84;
	sub_83103A98(ctx, base);
	// 830E6A84: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830E6A88: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 830E6A8C: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 830E6A90: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 830E6A94: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 830E6A98: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 830E6A9C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830E6AA0: 480C1718  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E6AA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E6AA8 size=56
    let mut pc: u32 = 0x830E6AA8;
    'dispatch: loop {
        match pc {
            0x830E6AA8 => {
    //   block [0x830E6AA8..0x830E6AE0)
	// 830E6AA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E6AAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E6AB0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E6AB4: 7C882378  mr r8, r4
	ctx.r[8].u64 = ctx.r[4].u64;
	// 830E6AB8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830E6ABC: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 830E6AC0: 4801B531  bl 0x83101ff0
	ctx.lr = 0x830E6AC4;
	sub_83101FF0(ctx, base);
	// 830E6AC4: 39600014  li r11, 0x14
	ctx.r[11].s64 = 20;
	// 830E6AC8: 91090010  stw r8, 0x10(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), ctx.r[8].u32 ) };
	// 830E6ACC: 9169000C  stw r11, 0xc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 830E6AD0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830E6AD4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E6AD8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E6ADC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E6AE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E6AE0 size=56
    let mut pc: u32 = 0x830E6AE0;
    'dispatch: loop {
        match pc {
            0x830E6AE0 => {
    //   block [0x830E6AE0..0x830E6B18)
	// 830E6AE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E6AE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E6AE8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E6AEC: 7C882378  mr r8, r4
	ctx.r[8].u64 = ctx.r[4].u64;
	// 830E6AF0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830E6AF4: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 830E6AF8: 4801B4F9  bl 0x83101ff0
	ctx.lr = 0x830E6AFC;
	sub_83101FF0(ctx, base);
	// 830E6AFC: 39600014  li r11, 0x14
	ctx.r[11].s64 = 20;
	// 830E6B00: 91090010  stw r8, 0x10(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), ctx.r[8].u32 ) };
	// 830E6B04: 9169000C  stw r11, 0xc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 830E6B08: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830E6B0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E6B10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E6B14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E6B18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E6B18 size=80
    let mut pc: u32 = 0x830E6B18;
    'dispatch: loop {
        match pc {
            0x830E6B18 => {
    //   block [0x830E6B18..0x830E6B68)
	// 830E6B18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E6B1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E6B20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830E6B24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E6B28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E6B2C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830E6B30: 38800803  li r4, 0x803
	ctx.r[4].s64 = 2051;
	// 830E6B34: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 830E6B38: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830E6B3C: 4801B4B5  bl 0x83101ff0
	ctx.lr = 0x830E6B40;
	sub_83101FF0(ctx, base);
	// 830E6B40: 38A00014  li r5, 0x14
	ctx.r[5].s64 = 20;
	// 830E6B44: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E6B48: 4801CF51  bl 0x83103a98
	ctx.lr = 0x830E6B4C;
	sub_83103A98(ctx, base);
	// 830E6B4C: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 830E6B50: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E6B54: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E6B58: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E6B5C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830E6B60: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E6B64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E6B68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E6B68 size=88
    let mut pc: u32 = 0x830E6B68;
    'dispatch: loop {
        match pc {
            0x830E6B68 => {
    //   block [0x830E6B68..0x830E6BC0)
	// 830E6B68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E6B6C: 480C15F1  bl 0x831a815c
	ctx.lr = 0x830E6B70;
	sub_831A8130(ctx, base);
	// 830E6B70: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E6B74: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830E6B78: 38800804  li r4, 0x804
	ctx.r[4].s64 = 2052;
	// 830E6B7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E6B80: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 830E6B84: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 830E6B88: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 830E6B8C: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 830E6B90: 7D394B78  mr r25, r9
	ctx.r[25].u64 = ctx.r[9].u64;
	// 830E6B94: 4801B45D  bl 0x83101ff0
	ctx.lr = 0x830E6B98;
	sub_83101FF0(ctx, base);
	// 830E6B98: 38A00014  li r5, 0x14
	ctx.r[5].s64 = 20;
	// 830E6B9C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830E6BA0: 4801CEF9  bl 0x83103a98
	ctx.lr = 0x830E6BA4;
	sub_83103A98(ctx, base);
	// 830E6BA4: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 830E6BA8: 939E0004  stw r28, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 830E6BAC: 937E0008  stw r27, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 830E6BB0: 935E000C  stw r26, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[26].u32 ) };
	// 830E6BB4: 933E0010  stw r25, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[25].u32 ) };
	// 830E6BB8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830E6BBC: 480C15F0  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E6BC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E6BC0 size=56
    let mut pc: u32 = 0x830E6BC0;
    'dispatch: loop {
        match pc {
            0x830E6BC0 => {
    //   block [0x830E6BC0..0x830E6BF8)
	// 830E6BC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E6BC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E6BC8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E6BCC: 7C882378  mr r8, r4
	ctx.r[8].u64 = ctx.r[4].u64;
	// 830E6BD0: 3880001B  li r4, 0x1b
	ctx.r[4].s64 = 27;
	// 830E6BD4: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 830E6BD8: 4801B419  bl 0x83101ff0
	ctx.lr = 0x830E6BDC;
	sub_83101FF0(ctx, base);
	// 830E6BDC: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 830E6BE0: 7D044378  mr r4, r8
	ctx.r[4].u64 = ctx.r[8].u64;
	// 830E6BE4: 4801CEB5  bl 0x83103a98
	ctx.lr = 0x830E6BE8;
	sub_83103A98(ctx, base);
	// 830E6BE8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830E6BEC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E6BF0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E6BF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E6BF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E6BF8 size=64
    let mut pc: u32 = 0x830E6BF8;
    'dispatch: loop {
        match pc {
            0x830E6BF8 => {
    //   block [0x830E6BF8..0x830E6C38)
	// 830E6BF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E6BFC: 480C1571  bl 0x831a816c
	ctx.lr = 0x830E6C00;
	sub_831A8130(ctx, base);
	// 830E6C00: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E6C04: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830E6C08: 3880000E  li r4, 0xe
	ctx.r[4].s64 = 14;
	// 830E6C0C: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 830E6C10: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830E6C14: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 830E6C18: 4801B3D9  bl 0x83101ff0
	ctx.lr = 0x830E6C1C;
	sub_83101FF0(ctx, base);
	// 830E6C1C: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 830E6C20: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E6C24: 4801CE75  bl 0x83103a98
	ctx.lr = 0x830E6C28;
	sub_83103A98(ctx, base);
	// 830E6C28: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 830E6C2C: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 830E6C30: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E6C34: 480C1588  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E6C38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E6C38 size=76
    let mut pc: u32 = 0x830E6C38;
    'dispatch: loop {
        match pc {
            0x830E6C38 => {
    //   block [0x830E6C38..0x830E6C84)
	// 830E6C38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E6C3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E6C40: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830E6C44: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E6C48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E6C4C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E6C50: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 830E6C54: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830E6C58: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 830E6C5C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830E6C60: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 830E6C64: 480C157D  bl 0x831a81e0
	ctx.lr = 0x830E6C68;
	sub_831A81E0(ctx, base);
	// 830E6C68: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 830E6C6C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E6C70: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E6C74: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E6C78: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830E6C7C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E6C80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E6C88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E6C88 size=60
    let mut pc: u32 = 0x830E6C88;
    'dispatch: loop {
        match pc {
            0x830E6C88 => {
    //   block [0x830E6C88..0x830E6CC4)
	// 830E6C88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E6C8C: 480C14E1  bl 0x831a816c
	ctx.lr = 0x830E6C90;
	sub_831A8130(ctx, base);
	// 830E6C90: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E6C94: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830E6C98: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 830E6C9C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830E6CA0: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 830E6CA4: 4BFFFF55  bl 0x830e6bf8
	ctx.lr = 0x830E6CA8;
	sub_830E6BF8(ctx, base);
	// 830E6CA8: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 830E6CAC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830E6CB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E6CB4: 4BFFFF85  bl 0x830e6c38
	ctx.lr = 0x830E6CB8;
	sub_830E6C38(ctx, base);
	// 830E6CB8: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 830E6CBC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E6CC0: 480C14FC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E6CC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E6CC8 size=60
    let mut pc: u32 = 0x830E6CC8;
    'dispatch: loop {
        match pc {
            0x830E6CC8 => {
    //   block [0x830E6CC8..0x830E6D04)
	// 830E6CC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E6CCC: 480C14A1  bl 0x831a816c
	ctx.lr = 0x830E6CD0;
	sub_831A8130(ctx, base);
	// 830E6CD0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E6CD4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830E6CD8: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 830E6CDC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830E6CE0: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 830E6CE4: 4BFFFF15  bl 0x830e6bf8
	ctx.lr = 0x830E6CE8;
	sub_830E6BF8(ctx, base);
	// 830E6CE8: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 830E6CEC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830E6CF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E6CF4: 4BFFFF45  bl 0x830e6c38
	ctx.lr = 0x830E6CF8;
	sub_830E6C38(ctx, base);
	// 830E6CF8: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 830E6CFC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E6D00: 480C14BC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E6D08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E6D08 size=68
    let mut pc: u32 = 0x830E6D08;
    'dispatch: loop {
        match pc {
            0x830E6D08 => {
    //   block [0x830E6D08..0x830E6D4C)
	// 830E6D08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E6D0C: 480C145D  bl 0x831a8168
	ctx.lr = 0x830E6D10;
	sub_831A8130(ctx, base);
	// 830E6D10: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E6D14: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830E6D18: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 830E6D1C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830E6D20: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 830E6D24: 7D1C4378  mr r28, r8
	ctx.r[28].u64 = ctx.r[8].u64;
	// 830E6D28: 4BFFFED1  bl 0x830e6bf8
	ctx.lr = 0x830E6D2C;
	sub_830E6BF8(ctx, base);
	// 830E6D2C: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 830E6D30: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830E6D34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E6D38: 4BFFFF01  bl 0x830e6c38
	ctx.lr = 0x830E6D3C;
	sub_830E6C38(ctx, base);
	// 830E6D3C: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 830E6D40: 939E0004  stw r28, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 830E6D44: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830E6D48: 480C1470  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E6D50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E6D50 size=60
    let mut pc: u32 = 0x830E6D50;
    'dispatch: loop {
        match pc {
            0x830E6D50 => {
    //   block [0x830E6D50..0x830E6D8C)
	// 830E6D50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E6D54: 480C1419  bl 0x831a816c
	ctx.lr = 0x830E6D58;
	sub_831A8130(ctx, base);
	// 830E6D58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E6D5C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830E6D60: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830E6D64: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830E6D68: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 830E6D6C: 4BFFFE8D  bl 0x830e6bf8
	ctx.lr = 0x830E6D70;
	sub_830E6BF8(ctx, base);
	// 830E6D70: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830E6D74: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830E6D78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E6D7C: 4BFFFEBD  bl 0x830e6c38
	ctx.lr = 0x830E6D80;
	sub_830E6C38(ctx, base);
	// 830E6D80: 9BBE0000  stb r29, 0(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 830E6D84: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E6D88: 480C1434  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E6D90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E6D90 size=68
    let mut pc: u32 = 0x830E6D90;
    'dispatch: loop {
        match pc {
            0x830E6D90 => {
    //   block [0x830E6D90..0x830E6DD4)
	// 830E6D90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E6D94: 480C13D5  bl 0x831a8168
	ctx.lr = 0x830E6D98;
	sub_831A8130(ctx, base);
	// 830E6D98: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E6D9C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830E6DA0: 38A00007  li r5, 7
	ctx.r[5].s64 = 7;
	// 830E6DA4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830E6DA8: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 830E6DAC: 7D1C4378  mr r28, r8
	ctx.r[28].u64 = ctx.r[8].u64;
	// 830E6DB0: 4BFFFE49  bl 0x830e6bf8
	ctx.lr = 0x830E6DB4;
	sub_830E6BF8(ctx, base);
	// 830E6DB4: 38A0000C  li r5, 0xc
	ctx.r[5].s64 = 12;
	// 830E6DB8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830E6DBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E6DC0: 4BFFFE79  bl 0x830e6c38
	ctx.lr = 0x830E6DC4;
	sub_830E6C38(ctx, base);
	// 830E6DC4: 939E0000  stw r28, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 830E6DC8: 9BBE0008  stb r29, 8(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u8 ) };
	// 830E6DCC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830E6DD0: 480C13E8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E6DD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E6DD8 size=68
    let mut pc: u32 = 0x830E6DD8;
    'dispatch: loop {
        match pc {
            0x830E6DD8 => {
    //   block [0x830E6DD8..0x830E6E1C)
	// 830E6DD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E6DDC: 480C138D  bl 0x831a8168
	ctx.lr = 0x830E6DE0;
	sub_831A8130(ctx, base);
	// 830E6DE0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E6DE4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830E6DE8: 38A00006  li r5, 6
	ctx.r[5].s64 = 6;
	// 830E6DEC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830E6DF0: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 830E6DF4: 7D1C4378  mr r28, r8
	ctx.r[28].u64 = ctx.r[8].u64;
	// 830E6DF8: 4BFFFE01  bl 0x830e6bf8
	ctx.lr = 0x830E6DFC;
	sub_830E6BF8(ctx, base);
	// 830E6DFC: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 830E6E00: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830E6E04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E6E08: 4BFFFE31  bl 0x830e6c38
	ctx.lr = 0x830E6E0C;
	sub_830E6C38(ctx, base);
	// 830E6E0C: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 830E6E10: 939E0004  stw r28, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 830E6E14: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830E6E18: 480C13A0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E6E20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E6E20 size=56
    let mut pc: u32 = 0x830E6E20;
    'dispatch: loop {
        match pc {
            0x830E6E20 => {
    //   block [0x830E6E20..0x830E6E58)
	// 830E6E20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E6E24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E6E28: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E6E2C: 7C882378  mr r8, r4
	ctx.r[8].u64 = ctx.r[4].u64;
	// 830E6E30: 388007D0  li r4, 0x7d0
	ctx.r[4].s64 = 2000;
	// 830E6E34: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 830E6E38: 4801B1B9  bl 0x83101ff0
	ctx.lr = 0x830E6E3C;
	sub_83101FF0(ctx, base);
	// 830E6E3C: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 830E6E40: 7D044378  mr r4, r8
	ctx.r[4].u64 = ctx.r[8].u64;
	// 830E6E44: 4801CC55  bl 0x83103a98
	ctx.lr = 0x830E6E48;
	sub_83103A98(ctx, base);
	// 830E6E48: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830E6E4C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E6E50: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E6E54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E6E58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E6E58 size=80
    let mut pc: u32 = 0x830E6E58;
    'dispatch: loop {
        match pc {
            0x830E6E58 => {
    //   block [0x830E6E58..0x830E6EA8)
	// 830E6E58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E6E5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E6E60: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830E6E64: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E6E68: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E6E6C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830E6E70: 388007D1  li r4, 0x7d1
	ctx.r[4].s64 = 2001;
	// 830E6E74: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 830E6E78: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830E6E7C: 4801B175  bl 0x83101ff0
	ctx.lr = 0x830E6E80;
	sub_83101FF0(ctx, base);
	// 830E6E80: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 830E6E84: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E6E88: 4801CC11  bl 0x83103a98
	ctx.lr = 0x830E6E8C;
	sub_83103A98(ctx, base);
	// 830E6E8C: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 830E6E90: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E6E94: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E6E98: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E6E9C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830E6EA0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E6EA4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E6EA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E6EA8 size=80
    let mut pc: u32 = 0x830E6EA8;
    'dispatch: loop {
        match pc {
            0x830E6EA8 => {
    //   block [0x830E6EA8..0x830E6EF8)
	// 830E6EA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E6EAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E6EB0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830E6EB4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E6EB8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E6EBC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830E6EC0: 388007D3  li r4, 0x7d3
	ctx.r[4].s64 = 2003;
	// 830E6EC4: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 830E6EC8: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830E6ECC: 4801B125  bl 0x83101ff0
	ctx.lr = 0x830E6ED0;
	sub_83101FF0(ctx, base);
	// 830E6ED0: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 830E6ED4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E6ED8: 4801CBC1  bl 0x83103a98
	ctx.lr = 0x830E6EDC;
	sub_83103A98(ctx, base);
	// 830E6EDC: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 830E6EE0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E6EE4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E6EE8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E6EEC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830E6EF0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E6EF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E6EF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E6EF8 size=56
    let mut pc: u32 = 0x830E6EF8;
    'dispatch: loop {
        match pc {
            0x830E6EF8 => {
    //   block [0x830E6EF8..0x830E6F30)
	// 830E6EF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E6EFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E6F00: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E6F04: 7C882378  mr r8, r4
	ctx.r[8].u64 = ctx.r[4].u64;
	// 830E6F08: 388007F7  li r4, 0x7f7
	ctx.r[4].s64 = 2039;
	// 830E6F0C: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 830E6F10: 4801B0E1  bl 0x83101ff0
	ctx.lr = 0x830E6F14;
	sub_83101FF0(ctx, base);
	// 830E6F14: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 830E6F18: 7D044378  mr r4, r8
	ctx.r[4].u64 = ctx.r[8].u64;
	// 830E6F1C: 4801CB7D  bl 0x83103a98
	ctx.lr = 0x830E6F20;
	sub_83103A98(ctx, base);
	// 830E6F20: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830E6F24: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E6F28: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E6F2C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E6F30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E6F30 size=80
    let mut pc: u32 = 0x830E6F30;
    'dispatch: loop {
        match pc {
            0x830E6F30 => {
    //   block [0x830E6F30..0x830E6F80)
	// 830E6F30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E6F34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E6F38: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830E6F3C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E6F40: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E6F44: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830E6F48: 388007F8  li r4, 0x7f8
	ctx.r[4].s64 = 2040;
	// 830E6F4C: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 830E6F50: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830E6F54: 4801B09D  bl 0x83101ff0
	ctx.lr = 0x830E6F58;
	sub_83101FF0(ctx, base);
	// 830E6F58: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 830E6F5C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E6F60: 4801CB39  bl 0x83103a98
	ctx.lr = 0x830E6F64;
	sub_83103A98(ctx, base);
	// 830E6F64: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 830E6F68: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E6F6C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E6F70: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E6F74: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830E6F78: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E6F7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E6F80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E6F80 size=56
    let mut pc: u32 = 0x830E6F80;
    'dispatch: loop {
        match pc {
            0x830E6F80 => {
    //   block [0x830E6F80..0x830E6FB8)
	// 830E6F80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E6F84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E6F88: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E6F8C: 7C882378  mr r8, r4
	ctx.r[8].u64 = ctx.r[4].u64;
	// 830E6F90: 388007D6  li r4, 0x7d6
	ctx.r[4].s64 = 2006;
	// 830E6F94: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 830E6F98: 4801B059  bl 0x83101ff0
	ctx.lr = 0x830E6F9C;
	sub_83101FF0(ctx, base);
	// 830E6F9C: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 830E6FA0: 7D044378  mr r4, r8
	ctx.r[4].u64 = ctx.r[8].u64;
	// 830E6FA4: 4801CAF5  bl 0x83103a98
	ctx.lr = 0x830E6FA8;
	sub_83103A98(ctx, base);
	// 830E6FA8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830E6FAC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E6FB0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E6FB4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E6FB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E6FB8 size=88
    let mut pc: u32 = 0x830E6FB8;
    'dispatch: loop {
        match pc {
            0x830E6FB8 => {
    //   block [0x830E6FB8..0x830E7010)
	// 830E6FB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E6FBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E6FC0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830E6FC4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E6FC8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E6FCC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830E6FD0: 388007D6  li r4, 0x7d6
	ctx.r[4].s64 = 2006;
	// 830E6FD4: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 830E6FD8: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830E6FDC: 4801B015  bl 0x83101ff0
	ctx.lr = 0x830E6FE0;
	sub_83101FF0(ctx, base);
	// 830E6FE0: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 830E6FE4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E6FE8: 4801CAB1  bl 0x83103a98
	ctx.lr = 0x830E6FEC;
	sub_83103A98(ctx, base);
	// 830E6FEC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830E6FF0: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 830E6FF4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830E6FF8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E6FFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E7000: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E7004: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830E7008: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E700C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E7010(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E7010 size=56
    let mut pc: u32 = 0x830E7010;
    'dispatch: loop {
        match pc {
            0x830E7010 => {
    //   block [0x830E7010..0x830E7048)
	// 830E7010: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E7014: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E7018: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E701C: 7C882378  mr r8, r4
	ctx.r[8].u64 = ctx.r[4].u64;
	// 830E7020: 388007D7  li r4, 0x7d7
	ctx.r[4].s64 = 2007;
	// 830E7024: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 830E7028: 4801AFC9  bl 0x83101ff0
	ctx.lr = 0x830E702C;
	sub_83101FF0(ctx, base);
	// 830E702C: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 830E7030: 7D044378  mr r4, r8
	ctx.r[4].u64 = ctx.r[8].u64;
	// 830E7034: 4801CA65  bl 0x83103a98
	ctx.lr = 0x830E7038;
	sub_83103A98(ctx, base);
	// 830E7038: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830E703C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E7040: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E7044: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E7048(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E7048 size=80
    let mut pc: u32 = 0x830E7048;
    'dispatch: loop {
        match pc {
            0x830E7048 => {
    //   block [0x830E7048..0x830E7098)
	// 830E7048: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E704C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E7050: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830E7054: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E7058: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E705C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830E7060: 388007D8  li r4, 0x7d8
	ctx.r[4].s64 = 2008;
	// 830E7064: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 830E7068: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830E706C: 4801AF85  bl 0x83101ff0
	ctx.lr = 0x830E7070;
	sub_83101FF0(ctx, base);
	// 830E7070: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 830E7074: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E7078: 4801CA21  bl 0x83103a98
	ctx.lr = 0x830E707C;
	sub_83103A98(ctx, base);
	// 830E707C: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 830E7080: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E7084: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E7088: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E708C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830E7090: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E7094: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E7098(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E7098 size=80
    let mut pc: u32 = 0x830E7098;
    'dispatch: loop {
        match pc {
            0x830E7098 => {
    //   block [0x830E7098..0x830E70E8)
	// 830E7098: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E709C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E70A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830E70A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E70A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E70AC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830E70B0: 388007D9  li r4, 0x7d9
	ctx.r[4].s64 = 2009;
	// 830E70B4: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 830E70B8: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830E70BC: 4801AF35  bl 0x83101ff0
	ctx.lr = 0x830E70C0;
	sub_83101FF0(ctx, base);
	// 830E70C0: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 830E70C4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E70C8: 4801C9D1  bl 0x83103a98
	ctx.lr = 0x830E70CC;
	sub_83103A98(ctx, base);
	// 830E70CC: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 830E70D0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E70D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E70D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E70DC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830E70E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E70E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E70E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E70E8 size=80
    let mut pc: u32 = 0x830E70E8;
    'dispatch: loop {
        match pc {
            0x830E70E8 => {
    //   block [0x830E70E8..0x830E7138)
	// 830E70E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E70EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E70F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830E70F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E70F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E70FC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830E7100: 388007DC  li r4, 0x7dc
	ctx.r[4].s64 = 2012;
	// 830E7104: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 830E7108: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830E710C: 4801AEE5  bl 0x83101ff0
	ctx.lr = 0x830E7110;
	sub_83101FF0(ctx, base);
	// 830E7110: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 830E7114: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E7118: 4801C981  bl 0x83103a98
	ctx.lr = 0x830E711C;
	sub_83103A98(ctx, base);
	// 830E711C: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 830E7120: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E7124: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E7128: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E712C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830E7130: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E7134: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E7138(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E7138 size=56
    let mut pc: u32 = 0x830E7138;
    'dispatch: loop {
        match pc {
            0x830E7138 => {
    //   block [0x830E7138..0x830E7170)
	// 830E7138: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E713C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E7140: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E7144: 7C882378  mr r8, r4
	ctx.r[8].u64 = ctx.r[4].u64;
	// 830E7148: 388007DA  li r4, 0x7da
	ctx.r[4].s64 = 2010;
	// 830E714C: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 830E7150: 4801AEA1  bl 0x83101ff0
	ctx.lr = 0x830E7154;
	sub_83101FF0(ctx, base);
	// 830E7154: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 830E7158: 7D044378  mr r4, r8
	ctx.r[4].u64 = ctx.r[8].u64;
	// 830E715C: 4801C93D  bl 0x83103a98
	ctx.lr = 0x830E7160;
	sub_83103A98(ctx, base);
	// 830E7160: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830E7164: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E7168: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E716C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E7170(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E7170 size=80
    let mut pc: u32 = 0x830E7170;
    'dispatch: loop {
        match pc {
            0x830E7170 => {
    //   block [0x830E7170..0x830E71C0)
	// 830E7170: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E7174: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E7178: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830E717C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E7180: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E7184: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830E7188: 388007DB  li r4, 0x7db
	ctx.r[4].s64 = 2011;
	// 830E718C: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 830E7190: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830E7194: 4801AE5D  bl 0x83101ff0
	ctx.lr = 0x830E7198;
	sub_83101FF0(ctx, base);
	// 830E7198: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 830E719C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E71A0: 4801C8F9  bl 0x83103a98
	ctx.lr = 0x830E71A4;
	sub_83103A98(ctx, base);
	// 830E71A4: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 830E71A8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E71AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E71B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E71B4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830E71B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E71BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E71C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E71C0 size=64
    let mut pc: u32 = 0x830E71C0;
    'dispatch: loop {
        match pc {
            0x830E71C0 => {
    //   block [0x830E71C0..0x830E7200)
	// 830E71C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E71C4: 480C0FA9  bl 0x831a816c
	ctx.lr = 0x830E71C8;
	sub_831A8130(ctx, base);
	// 830E71C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E71CC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830E71D0: 388007DD  li r4, 0x7dd
	ctx.r[4].s64 = 2013;
	// 830E71D4: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 830E71D8: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830E71DC: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 830E71E0: 4801AE11  bl 0x83101ff0
	ctx.lr = 0x830E71E4;
	sub_83101FF0(ctx, base);
	// 830E71E4: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 830E71E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E71EC: 4801C8AD  bl 0x83103a98
	ctx.lr = 0x830E71F0;
	sub_83103A98(ctx, base);
	// 830E71F0: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 830E71F4: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 830E71F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E71FC: 480C0FC0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E7200(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E7200 size=64
    let mut pc: u32 = 0x830E7200;
    'dispatch: loop {
        match pc {
            0x830E7200 => {
    //   block [0x830E7200..0x830E7240)
	// 830E7200: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E7204: 480C0F69  bl 0x831a816c
	ctx.lr = 0x830E7208;
	sub_831A8130(ctx, base);
	// 830E7208: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E720C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830E7210: 388007DE  li r4, 0x7de
	ctx.r[4].s64 = 2014;
	// 830E7214: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 830E7218: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830E721C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 830E7220: 4801ADD1  bl 0x83101ff0
	ctx.lr = 0x830E7224;
	sub_83101FF0(ctx, base);
	// 830E7224: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 830E7228: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E722C: 4801C86D  bl 0x83103a98
	ctx.lr = 0x830E7230;
	sub_83103A98(ctx, base);
	// 830E7230: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 830E7234: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 830E7238: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E723C: 480C0F80  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E7240(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830E7240 size=132
    let mut pc: u32 = 0x830E7240;
    'dispatch: loop {
        match pc {
            0x830E7240 => {
    //   block [0x830E7240..0x830E72C4)
	// 830E7240: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E7244: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E7248: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830E724C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E7250: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 830E7254: 480C1825  bl 0x831a8a78
	ctx.lr = 0x830E7258;
	sub_831A8A40(ctx, base);
	// 830E7258: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E725C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830E7260: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 830E7264: 38A00011  li r5, 0x11
	ctx.r[5].s64 = 17;
	// 830E7268: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 830E726C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830E7270: FFA01890  fmr f29, f3
	ctx.f[29].f64 = ctx.f[3].f64;
	// 830E7274: FF802090  fmr f28, f4
	ctx.f[28].f64 = ctx.f[4].f64;
	// 830E7278: 4BFFF981  bl 0x830e6bf8
	ctx.lr = 0x830E727C;
	sub_830E6BF8(ctx, base);
	// 830E727C: 38A00014  li r5, 0x14
	ctx.r[5].s64 = 20;
	// 830E7280: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830E7284: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E7288: 4BFFF9B1  bl 0x830e6c38
	ctx.lr = 0x830E728C;
	sub_830E6C38(ctx, base);
	// 830E728C: 816100E4  lwz r11, 0xe4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(228 as u32) ) } as u64;
	// 830E7290: D3FE0000  stfs f31, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830E7294: D3DE0004  stfs f30, 4(r30)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830E7298: D3BE0008  stfs f29, 8(r30)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 830E729C: D39E000C  stfs f28, 0xc(r30)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830E72A0: 917E0010  stw r11, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 830E72A4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830E72A8: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 830E72AC: 480C1819  bl 0x831a8ac4
	ctx.lr = 0x830E72B0;
	sub_831A8A8C(ctx, base);
	// 830E72B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E72B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E72B8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830E72BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E72C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E72C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830E72C8 size=84
    let mut pc: u32 = 0x830E72C8;
    'dispatch: loop {
        match pc {
            0x830E72C8 => {
    //   block [0x830E72C8..0x830E731C)
	// 830E72C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E72CC: 480C0E9D  bl 0x831a8168
	ctx.lr = 0x830E72D0;
	sub_831A8130(ctx, base);
	// 830E72D0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E72D4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830E72D8: 388007DF  li r4, 0x7df
	ctx.r[4].s64 = 2015;
	// 830E72DC: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 830E72E0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830E72E4: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 830E72E8: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 830E72EC: 4801AD05  bl 0x83101ff0
	ctx.lr = 0x830E72F0;
	sub_83101FF0(ctx, base);
	// 830E72F0: 38A00028  li r5, 0x28
	ctx.r[5].s64 = 40;
	// 830E72F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E72F8: 4801C7A1  bl 0x83103a98
	ctx.lr = 0x830E72FC;
	sub_83103A98(ctx, base);
	// 830E72FC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 830E7300: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 830E7304: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 830E7308: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 830E730C: C00B9534  lfs f0, -0x6acc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E7310: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 830E7314: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830E7318: 480C0EA0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E7320(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E7320 size=72
    let mut pc: u32 = 0x830E7320;
    'dispatch: loop {
        match pc {
            0x830E7320 => {
    //   block [0x830E7320..0x830E7368)
	// 830E7320: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E7324: 480C0E45  bl 0x831a8168
	ctx.lr = 0x830E7328;
	sub_831A8130(ctx, base);
	// 830E7328: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E732C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830E7330: 388007E1  li r4, 0x7e1
	ctx.r[4].s64 = 2017;
	// 830E7334: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 830E7338: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830E733C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 830E7340: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 830E7344: 4801ACAD  bl 0x83101ff0
	ctx.lr = 0x830E7348;
	sub_83101FF0(ctx, base);
	// 830E7348: 38A0001C  li r5, 0x1c
	ctx.r[5].s64 = 28;
	// 830E734C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E7350: 4801C749  bl 0x83103a98
	ctx.lr = 0x830E7354;
	sub_83103A98(ctx, base);
	// 830E7354: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 830E7358: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 830E735C: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 830E7360: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830E7364: 480C0E54  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E7368(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E7368 size=80
    let mut pc: u32 = 0x830E7368;
    'dispatch: loop {
        match pc {
            0x830E7368 => {
    //   block [0x830E7368..0x830E73B8)
	// 830E7368: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E736C: 480C0DF9  bl 0x831a8164
	ctx.lr = 0x830E7370;
	sub_831A8130(ctx, base);
	// 830E7370: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E7374: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830E7378: 388007E0  li r4, 0x7e0
	ctx.r[4].s64 = 2016;
	// 830E737C: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 830E7380: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830E7384: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 830E7388: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 830E738C: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 830E7390: 4801AC61  bl 0x83101ff0
	ctx.lr = 0x830E7394;
	sub_83101FF0(ctx, base);
	// 830E7394: 38A00028  li r5, 0x28
	ctx.r[5].s64 = 40;
	// 830E7398: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E739C: 4801C6FD  bl 0x83103a98
	ctx.lr = 0x830E73A0;
	sub_83103A98(ctx, base);
	// 830E73A0: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 830E73A4: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 830E73A8: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 830E73AC: 937F000C  stw r27, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[27].u32 ) };
	// 830E73B0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830E73B4: 480C0E00  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E73B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E73B8 size=96
    let mut pc: u32 = 0x830E73B8;
    'dispatch: loop {
        match pc {
            0x830E73B8 => {
    //   block [0x830E73B8..0x830E7418)
	// 830E73B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E73BC: 480C0D9D  bl 0x831a8158
	ctx.lr = 0x830E73C0;
	sub_831A8130(ctx, base);
	// 830E73C0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E73C4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830E73C8: 388007E2  li r4, 0x7e2
	ctx.r[4].s64 = 2018;
	// 830E73CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E73D0: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 830E73D4: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 830E73D8: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 830E73DC: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 830E73E0: 7D394B78  mr r25, r9
	ctx.r[25].u64 = ctx.r[9].u64;
	// 830E73E4: 7D585378  mr r24, r10
	ctx.r[24].u64 = ctx.r[10].u64;
	// 830E73E8: 4801AC09  bl 0x83101ff0
	ctx.lr = 0x830E73EC;
	sub_83101FF0(ctx, base);
	// 830E73EC: 38A0001C  li r5, 0x1c
	ctx.r[5].s64 = 28;
	// 830E73F0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830E73F4: 4801C6A5  bl 0x83103a98
	ctx.lr = 0x830E73F8;
	sub_83103A98(ctx, base);
	// 830E73F8: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 830E73FC: 939E0004  stw r28, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 830E7400: 937E0008  stw r27, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 830E7404: 935E0010  stw r26, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[26].u32 ) };
	// 830E7408: 933E0014  stw r25, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[25].u32 ) };
	// 830E740C: 931E0018  stw r24, 0x18(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), ctx.r[24].u32 ) };
	// 830E7410: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830E7414: 480C0D94  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E7418(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E7418 size=80
    let mut pc: u32 = 0x830E7418;
    'dispatch: loop {
        match pc {
            0x830E7418 => {
    //   block [0x830E7418..0x830E7468)
	// 830E7418: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E741C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E7420: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830E7424: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E7428: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E742C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830E7430: 388007E3  li r4, 0x7e3
	ctx.r[4].s64 = 2019;
	// 830E7434: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 830E7438: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830E743C: 4801ABB5  bl 0x83101ff0
	ctx.lr = 0x830E7440;
	sub_83101FF0(ctx, base);
	// 830E7440: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 830E7444: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E7448: 4801C651  bl 0x83103a98
	ctx.lr = 0x830E744C;
	sub_83103A98(ctx, base);
	// 830E744C: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 830E7450: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E7454: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E7458: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E745C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830E7460: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E7464: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E7468(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E7468 size=64
    let mut pc: u32 = 0x830E7468;
    'dispatch: loop {
        match pc {
            0x830E7468 => {
    //   block [0x830E7468..0x830E74A8)
	// 830E7468: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E746C: 480C0D01  bl 0x831a816c
	ctx.lr = 0x830E7470;
	sub_831A8130(ctx, base);
	// 830E7470: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E7474: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830E7478: 388007E4  li r4, 0x7e4
	ctx.r[4].s64 = 2020;
	// 830E747C: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 830E7480: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830E7484: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 830E7488: 4801AB69  bl 0x83101ff0
	ctx.lr = 0x830E748C;
	sub_83101FF0(ctx, base);
	// 830E748C: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 830E7490: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E7494: 4801C605  bl 0x83103a98
	ctx.lr = 0x830E7498;
	sub_83103A98(ctx, base);
	// 830E7498: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 830E749C: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 830E74A0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E74A4: 480C0D18  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E74A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E74A8 size=80
    let mut pc: u32 = 0x830E74A8;
    'dispatch: loop {
        match pc {
            0x830E74A8 => {
    //   block [0x830E74A8..0x830E74F8)
	// 830E74A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E74AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E74B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830E74B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E74B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E74BC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830E74C0: 388007E8  li r4, 0x7e8
	ctx.r[4].s64 = 2024;
	// 830E74C4: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 830E74C8: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830E74CC: 4801AB25  bl 0x83101ff0
	ctx.lr = 0x830E74D0;
	sub_83101FF0(ctx, base);
	// 830E74D0: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 830E74D4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E74D8: 4801C5C1  bl 0x83103a98
	ctx.lr = 0x830E74DC;
	sub_83103A98(ctx, base);
	// 830E74DC: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 830E74E0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E74E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E74E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E74EC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830E74F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E74F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E74F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830E74F8 size=96
    let mut pc: u32 = 0x830E74F8;
    'dispatch: loop {
        match pc {
            0x830E74F8 => {
    //   block [0x830E74F8..0x830E7558)
	// 830E74F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E74FC: 480C0C71  bl 0x831a816c
	ctx.lr = 0x830E7500;
	sub_831A8130(ctx, base);
	// 830E7500: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 830E7504: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 830E7508: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E750C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830E7510: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 830E7514: 3880080B  li r4, 0x80b
	ctx.r[4].s64 = 2059;
	// 830E7518: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 830E751C: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 830E7520: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830E7524: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 830E7528: 4801AAC9  bl 0x83101ff0
	ctx.lr = 0x830E752C;
	sub_83101FF0(ctx, base);
	// 830E752C: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 830E7530: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E7534: 4801C565  bl 0x83103a98
	ctx.lr = 0x830E7538;
	sub_83103A98(ctx, base);
	// 830E7538: D3FF0008  stfs f31, 8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 830E753C: D3DF000C  stfs f30, 0xc(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830E7540: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 830E7544: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 830E7548: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830E754C: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 830E7550: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 830E7554: 480C0C68  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E7558(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E7558 size=80
    let mut pc: u32 = 0x830E7558;
    'dispatch: loop {
        match pc {
            0x830E7558 => {
    //   block [0x830E7558..0x830E75A8)
	// 830E7558: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E755C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E7560: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830E7564: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E7568: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E756C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830E7570: 388007E5  li r4, 0x7e5
	ctx.r[4].s64 = 2021;
	// 830E7574: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 830E7578: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830E757C: 4801AA75  bl 0x83101ff0
	ctx.lr = 0x830E7580;
	sub_83101FF0(ctx, base);
	// 830E7580: 38A0000C  li r5, 0xc
	ctx.r[5].s64 = 12;
	// 830E7584: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E7588: 4801C511  bl 0x83103a98
	ctx.lr = 0x830E758C;
	sub_83103A98(ctx, base);
	// 830E758C: 9BDF0004  stb r30, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u8 ) };
	// 830E7590: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E7594: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E7598: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E759C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830E75A0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E75A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E75A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E75A8 size=64
    let mut pc: u32 = 0x830E75A8;
    'dispatch: loop {
        match pc {
            0x830E75A8 => {
    //   block [0x830E75A8..0x830E75E8)
	// 830E75A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E75AC: 480C0BC1  bl 0x831a816c
	ctx.lr = 0x830E75B0;
	sub_831A8130(ctx, base);
	// 830E75B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E75B4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830E75B8: 388007E6  li r4, 0x7e6
	ctx.r[4].s64 = 2022;
	// 830E75BC: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 830E75C0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830E75C4: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 830E75C8: 4801AA29  bl 0x83101ff0
	ctx.lr = 0x830E75CC;
	sub_83101FF0(ctx, base);
	// 830E75CC: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 830E75D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E75D4: 4801C4C5  bl 0x83103a98
	ctx.lr = 0x830E75D8;
	sub_83103A98(ctx, base);
	// 830E75D8: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 830E75DC: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 830E75E0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E75E4: 480C0BD8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E75E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E75E8 size=80
    let mut pc: u32 = 0x830E75E8;
    'dispatch: loop {
        match pc {
            0x830E75E8 => {
    //   block [0x830E75E8..0x830E7638)
	// 830E75E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E75EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E75F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830E75F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E75F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E75FC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830E7600: 388007E7  li r4, 0x7e7
	ctx.r[4].s64 = 2023;
	// 830E7604: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 830E7608: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830E760C: 4801A9E5  bl 0x83101ff0
	ctx.lr = 0x830E7610;
	sub_83101FF0(ctx, base);
	// 830E7610: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 830E7614: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E7618: 4801C481  bl 0x83103a98
	ctx.lr = 0x830E761C;
	sub_83103A98(ctx, base);
	// 830E761C: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 830E7620: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E7624: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E7628: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E762C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830E7630: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E7634: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E7638(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E7638 size=72
    let mut pc: u32 = 0x830E7638;
    'dispatch: loop {
        match pc {
            0x830E7638 => {
    //   block [0x830E7638..0x830E7680)
	// 830E7638: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E763C: 480C0B2D  bl 0x831a8168
	ctx.lr = 0x830E7640;
	sub_831A8130(ctx, base);
	// 830E7640: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E7644: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830E7648: 38800808  li r4, 0x808
	ctx.r[4].s64 = 2056;
	// 830E764C: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 830E7650: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830E7654: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 830E7658: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 830E765C: 4801A995  bl 0x83101ff0
	ctx.lr = 0x830E7660;
	sub_83101FF0(ctx, base);
	// 830E7660: 38A0000C  li r5, 0xc
	ctx.r[5].s64 = 12;
	// 830E7664: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E7668: 4801C431  bl 0x83103a98
	ctx.lr = 0x830E766C;
	sub_83103A98(ctx, base);
	// 830E766C: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 830E7670: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 830E7674: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 830E7678: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830E767C: 480C0B3C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E7680(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E7680 size=80
    let mut pc: u32 = 0x830E7680;
    'dispatch: loop {
        match pc {
            0x830E7680 => {
    //   block [0x830E7680..0x830E76D0)
	// 830E7680: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E7684: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E7688: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830E768C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E7690: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E7694: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830E7698: 388007EC  li r4, 0x7ec
	ctx.r[4].s64 = 2028;
	// 830E769C: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 830E76A0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830E76A4: 4801A94D  bl 0x83101ff0
	ctx.lr = 0x830E76A8;
	sub_83101FF0(ctx, base);
	// 830E76A8: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 830E76AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E76B0: 4801C3E9  bl 0x83103a98
	ctx.lr = 0x830E76B4;
	sub_83103A98(ctx, base);
	// 830E76B4: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 830E76B8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E76BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E76C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E76C4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830E76C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E76CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E76D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E76D0 size=68
    let mut pc: u32 = 0x830E76D0;
    'dispatch: loop {
        match pc {
            0x830E76D0 => {
    //   block [0x830E76D0..0x830E7714)
	// 830E76D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E76D4: 480C0A95  bl 0x831a8168
	ctx.lr = 0x830E76D8;
	sub_831A8130(ctx, base);
	// 830E76D8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E76DC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830E76E0: 38A0000A  li r5, 0xa
	ctx.r[5].s64 = 10;
	// 830E76E4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830E76E8: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 830E76EC: 7D1C4378  mr r28, r8
	ctx.r[28].u64 = ctx.r[8].u64;
	// 830E76F0: 4BFFF509  bl 0x830e6bf8
	ctx.lr = 0x830E76F4;
	sub_830E6BF8(ctx, base);
	// 830E76F4: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 830E76F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830E76FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E7700: 4BFFF539  bl 0x830e6c38
	ctx.lr = 0x830E7704;
	sub_830E6C38(ctx, base);
	// 830E7704: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 830E7708: 939E0004  stw r28, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 830E770C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830E7710: 480C0AA8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E7718(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E7718 size=60
    let mut pc: u32 = 0x830E7718;
    'dispatch: loop {
        match pc {
            0x830E7718 => {
    //   block [0x830E7718..0x830E7754)
	// 830E7718: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E771C: 480C0A51  bl 0x831a816c
	ctx.lr = 0x830E7720;
	sub_831A8130(ctx, base);
	// 830E7720: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E7724: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830E7728: 38A0000B  li r5, 0xb
	ctx.r[5].s64 = 11;
	// 830E772C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830E7730: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 830E7734: 4BFFF4C5  bl 0x830e6bf8
	ctx.lr = 0x830E7738;
	sub_830E6BF8(ctx, base);
	// 830E7738: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 830E773C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830E7740: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E7744: 4BFFF4F5  bl 0x830e6c38
	ctx.lr = 0x830E7748;
	sub_830E6C38(ctx, base);
	// 830E7748: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 830E774C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E7750: 480C0A6C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E7758(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E7758 size=88
    let mut pc: u32 = 0x830E7758;
    'dispatch: loop {
        match pc {
            0x830E7758 => {
    //   block [0x830E7758..0x830E77B0)
	// 830E7758: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E775C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E7760: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E7764: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E7768: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E776C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E7770: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830E7774: 4BFF8FE5  bl 0x830e0758
	ctx.lr = 0x830E7778;
	sub_830E0758(ctx, base);
	// 830E7778: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E777C: 3BE10060  addi r31, r1, 0x60
	ctx.r[31].s64 = ctx.r[1].s64 + 96;
	// 830E7780: 4BFE7491  bl 0x830cec10
	ctx.lr = 0x830E7784;
	sub_830CEC10(ctx, base);
	// 830E7784: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E7788: 4BFEE5D1  bl 0x830d5d58
	ctx.lr = 0x830E778C;
	sub_830D5D58(ctx, base);
	// 830E778C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E7790: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E7794: 41800008  blt 0x830e779c
	if ctx.cr[0].lt {
	pc = 0x830E779C; continue 'dispatch;
	}
	// 830E7798: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E779C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830E77A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E77A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E77A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E77AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E77B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E77B0 size=88
    let mut pc: u32 = 0x830E77B0;
    'dispatch: loop {
        match pc {
            0x830E77B0 => {
    //   block [0x830E77B0..0x830E7808)
	// 830E77B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E77B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E77B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E77BC: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E77C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E77C4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E77C8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830E77CC: 4801C31D  bl 0x83103ae8
	ctx.lr = 0x830E77D0;
	sub_83103AE8(ctx, base);
	// 830E77D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E77D4: 3BE10060  addi r31, r1, 0x60
	ctx.r[31].s64 = ctx.r[1].s64 + 96;
	// 830E77D8: 4BFE7439  bl 0x830cec10
	ctx.lr = 0x830E77DC;
	sub_830CEC10(ctx, base);
	// 830E77DC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E77E0: 4BFEE579  bl 0x830d5d58
	ctx.lr = 0x830E77E4;
	sub_830D5D58(ctx, base);
	// 830E77E4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E77E8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E77EC: 41800008  blt 0x830e77f4
	if ctx.cr[0].lt {
	pc = 0x830E77F4; continue 'dispatch;
	}
	// 830E77F0: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E77F4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830E77F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E77FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E7800: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E7804: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E7808(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830E7808 size=108
    let mut pc: u32 = 0x830E7808;
    'dispatch: loop {
        match pc {
            0x830E7808 => {
    //   block [0x830E7808..0x830E7874)
	// 830E7808: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E780C: 480C0961  bl 0x831a816c
	ctx.lr = 0x830E7810;
	sub_831A8130(ctx, base);
	// 830E7810: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E7814: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830E7818: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830E781C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E7820: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830E7824: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830E7828: 4BFF8CE1  bl 0x830e0508
	ctx.lr = 0x830E782C;
	sub_830E0508(ctx, base);
	// 830E782C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830E7830: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830E7834: 4BFEE395  bl 0x830d5bc8
	ctx.lr = 0x830E7838;
	sub_830D5BC8(ctx, base);
	// 830E7838: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E783C: 41800030  blt 0x830e786c
	if ctx.cr[0].lt {
	pc = 0x830E786C; continue 'dispatch;
	}
	// 830E7840: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 830E7844: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E7848: 409A0010  bne cr6, 0x830e7858
	if !ctx.cr[6].eq {
	pc = 0x830E7858; continue 'dispatch;
	}
	// 830E784C: 3C608030  lis r3, -0x7fd0
	ctx.r[3].s64 = -2144337920;
	// 830E7850: 60630011  ori r3, r3, 0x11
	ctx.r[3].u64 = ctx.r[3].u64 | 17;
	// 830E7854: 48000018  b 0x830e786c
	pc = 0x830E786C; continue 'dispatch;
	// 830E7858: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E785C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E7860: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830E7864: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830E7868: D1BE0000  stfs f13, 0(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830E786C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830E7870: 480C094C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E7878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E7878 size=68
    let mut pc: u32 = 0x830E7878;
    'dispatch: loop {
        match pc {
            0x830E7878 => {
    //   block [0x830E7878..0x830E78BC)
	// 830E7878: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E787C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E7880: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E7884: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E7888: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E788C: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 830E7890: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E7894: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830E7898: 4BFE79D9  bl 0x830cf270
	ctx.lr = 0x830E789C;
	sub_830CF270(ctx, base);
	// 830E789C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830E78A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E78A4: 4BFEE325  bl 0x830d5bc8
	ctx.lr = 0x830E78A8;
	sub_830D5BC8(ctx, base);
	// 830E78A8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830E78AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E78B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E78B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E78B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E78C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E78C0 size=156
    let mut pc: u32 = 0x830E78C0;
    'dispatch: loop {
        match pc {
            0x830E78C0 => {
    //   block [0x830E78C0..0x830E795C)
	// 830E78C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E78C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E78C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E78CC: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E78D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E78D4: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 830E78D8: 93E100A4  stw r31, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[31].u32 ) };
	// 830E78DC: 409A0068  bne cr6, 0x830e7944
	if !ctx.cr[6].eq {
	pc = 0x830E7944; continue 'dispatch;
	}
	// 830E78E0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E78E4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830E78E8: 4BFF8DE9  bl 0x830e06d0
	ctx.lr = 0x830E78EC;
	sub_830E06D0(ctx, base);
	// 830E78EC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830E78F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E78F4: 4BFEE2D5  bl 0x830d5bc8
	ctx.lr = 0x830E78F8;
	sub_830D5BC8(ctx, base);
	// 830E78F8: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E78FC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830E7900: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E7904: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E7908: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E790C: 4E800020  blr
	return;
	// 830E7910: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E7914: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830E7918: 4BFF8DB9  bl 0x830e06d0
	ctx.lr = 0x830E791C;
	sub_830E06D0(ctx, base);
	// 830E791C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830E7920: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E7924: 4BFEE2A5  bl 0x830d5bc8
	ctx.lr = 0x830E7928;
	sub_830D5BC8(ctx, base);
	// 830E7928: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E792C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E7930: 409A0024  bne cr6, 0x830e7954
	if !ctx.cr[6].eq {
	pc = 0x830E7954; continue 'dispatch;
	}
	// 830E7934: 388100A4  addi r4, r1, 0xa4
	ctx.r[4].s64 = ctx.r[1].s64 + 164;
	// 830E7938: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 830E793C: 4BFF7E1D  bl 0x830df758
	ctx.lr = 0x830E7940;
	sub_830DF758(ctx, base);
	// 830E7940: 83E100A4  lwz r31, 0xa4(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 830E7944: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830E7948: 409AFFC8  bne cr6, 0x830e7910
	if !ctx.cr[6].eq {
	pc = 0x830E7910; continue 'dispatch;
	}
	// 830E794C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E7950: 4BFFFFAC  b 0x830e78fc
	pc = 0x830E78FC; continue 'dispatch;
	// 830E7954: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830E7958: 4BFFFFA4  b 0x830e78fc
	pc = 0x830E78FC; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E7960(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E7960 size=96
    let mut pc: u32 = 0x830E7960;
    'dispatch: loop {
        match pc {
            0x830E7960 => {
    //   block [0x830E7960..0x830E79C0)
	// 830E7960: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E7964: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E7968: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830E796C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E7970: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E7974: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830E7978: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830E797C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E7980: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830E7984: 4BFFF68D  bl 0x830e7010
	ctx.lr = 0x830E7988;
	sub_830E7010(ctx, base);
	// 830E7988: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830E798C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E7990: 4BFEE239  bl 0x830d5bc8
	ctx.lr = 0x830E7994;
	sub_830D5BC8(ctx, base);
	// 830E7994: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830E7998: 419A000C  beq cr6, 0x830e79a4
	if ctx.cr[6].eq {
	pc = 0x830E79A4; continue 'dispatch;
	}
	// 830E799C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830E79A0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830E79A4: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E79A8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830E79AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E79B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E79B4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830E79B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E79BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E79C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E79C0 size=68
    let mut pc: u32 = 0x830E79C0;
    'dispatch: loop {
        match pc {
            0x830E79C0 => {
    //   block [0x830E79C0..0x830E7A04)
	// 830E79C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E79C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E79C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E79CC: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E79D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E79D4: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 830E79D8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E79DC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830E79E0: 4BFFF669  bl 0x830e7048
	ctx.lr = 0x830E79E4;
	sub_830E7048(ctx, base);
	// 830E79E4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830E79E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E79EC: 4BFEE1DD  bl 0x830d5bc8
	ctx.lr = 0x830E79F0;
	sub_830D5BC8(ctx, base);
	// 830E79F0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830E79F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E79F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E79FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E7A00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E7A08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E7A08 size=80
    let mut pc: u32 = 0x830E7A08;
    'dispatch: loop {
        match pc {
            0x830E7A08 => {
    //   block [0x830E7A08..0x830E7A58)
	// 830E7A08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E7A0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E7A10: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E7A14: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E7A18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E7A1C: 7CA82B78  mr r8, r5
	ctx.r[8].u64 = ctx.r[5].u64;
	// 830E7A20: 7C872378  mr r7, r4
	ctx.r[7].u64 = ctx.r[4].u64;
	// 830E7A24: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 830E7A28: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830E7A2C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830E7A30: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830E7A34: 4BFFF2D5  bl 0x830e6d08
	ctx.lr = 0x830E7A38;
	sub_830E6D08(ctx, base);
	// 830E7A38: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 830E7A3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E7A40: 4BFEE319  bl 0x830d5d58
	ctx.lr = 0x830E7A44;
	sub_830D5D58(ctx, base);
	// 830E7A44: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830E7A48: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E7A4C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E7A50: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E7A54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E7A58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E7A58 size=72
    let mut pc: u32 = 0x830E7A58;
    'dispatch: loop {
        match pc {
            0x830E7A58 => {
    //   block [0x830E7A58..0x830E7AA0)
	// 830E7A58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E7A5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E7A60: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E7A64: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E7A68: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E7A6C: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 830E7A70: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E7A74: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830E7A78: 4BFFF621  bl 0x830e7098
	ctx.lr = 0x830E7A7C;
	sub_830E7098(ctx, base);
	// 830E7A7C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830E7A80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E7A84: 4BFEE145  bl 0x830d5bc8
	ctx.lr = 0x830E7A88;
	sub_830D5BC8(ctx, base);
	// 830E7A88: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830E7A8C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830E7A90: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E7A94: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E7A98: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E7A9C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E7AA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E7AA0 size=92
    let mut pc: u32 = 0x830E7AA0;
    'dispatch: loop {
        match pc {
            0x830E7AA0 => {
    //   block [0x830E7AA0..0x830E7AFC)
	// 830E7AA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E7AA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E7AA8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E7AAC: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E7AB0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E7AB4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830E7AB8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E7ABC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830E7AC0: 4BFFF629  bl 0x830e70e8
	ctx.lr = 0x830E7AC4;
	sub_830E70E8(ctx, base);
	// 830E7AC4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830E7AC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E7ACC: 4BFEE0FD  bl 0x830d5bc8
	ctx.lr = 0x830E7AD0;
	sub_830D5BC8(ctx, base);
	// 830E7AD0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E7AD4: 41800010  blt 0x830e7ae4
	if ctx.cr[0].lt {
	pc = 0x830E7AE4; continue 'dispatch;
	}
	// 830E7AD8: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830E7ADC: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830E7AE0: 40980008  bge cr6, 0x830e7ae8
	if !ctx.cr[6].lt {
	pc = 0x830E7AE8; continue 'dispatch;
	}
	// 830E7AE4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E7AE8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830E7AEC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E7AF0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E7AF4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E7AF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E7B00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E7B00 size=92
    let mut pc: u32 = 0x830E7B00;
    'dispatch: loop {
        match pc {
            0x830E7B00 => {
    //   block [0x830E7B00..0x830E7B5C)
	// 830E7B00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E7B04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E7B08: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E7B0C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E7B10: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E7B14: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830E7B18: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E7B1C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830E7B20: 4BFFF5C9  bl 0x830e70e8
	ctx.lr = 0x830E7B24;
	sub_830E70E8(ctx, base);
	// 830E7B24: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830E7B28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E7B2C: 4BFEE09D  bl 0x830d5bc8
	ctx.lr = 0x830E7B30;
	sub_830D5BC8(ctx, base);
	// 830E7B30: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E7B34: 41800010  blt 0x830e7b44
	if ctx.cr[0].lt {
	pc = 0x830E7B44; continue 'dispatch;
	}
	// 830E7B38: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830E7B3C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830E7B40: 40980008  bge cr6, 0x830e7b48
	if !ctx.cr[6].lt {
	pc = 0x830E7B48; continue 'dispatch;
	}
	// 830E7B44: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E7B48: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830E7B4C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E7B50: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E7B54: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E7B58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E7B60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E7B60 size=80
    let mut pc: u32 = 0x830E7B60;
    'dispatch: loop {
        match pc {
            0x830E7B60 => {
    //   block [0x830E7B60..0x830E7BB0)
	// 830E7B60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E7B64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E7B68: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E7B6C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E7B70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E7B74: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E7B78: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830E7B7C: 4BFFF5BD  bl 0x830e7138
	ctx.lr = 0x830E7B80;
	sub_830E7138(ctx, base);
	// 830E7B80: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830E7B84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E7B88: 4BFEE041  bl 0x830d5bc8
	ctx.lr = 0x830E7B8C;
	sub_830D5BC8(ctx, base);
	// 830E7B8C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E7B90: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 830E7B94: 41800008  blt 0x830e7b9c
	if ctx.cr[0].lt {
	pc = 0x830E7B9C; continue 'dispatch;
	}
	// 830E7B98: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E7B9C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830E7BA0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E7BA4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E7BA8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E7BAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E7BB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E7BB0 size=68
    let mut pc: u32 = 0x830E7BB0;
    'dispatch: loop {
        match pc {
            0x830E7BB0 => {
    //   block [0x830E7BB0..0x830E7BF4)
	// 830E7BB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E7BB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E7BB8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E7BBC: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E7BC0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E7BC4: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 830E7BC8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E7BCC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830E7BD0: 4BFFF5A1  bl 0x830e7170
	ctx.lr = 0x830E7BD4;
	sub_830E7170(ctx, base);
	// 830E7BD4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830E7BD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E7BDC: 4BFEDFED  bl 0x830d5bc8
	ctx.lr = 0x830E7BE0;
	sub_830D5BC8(ctx, base);
	// 830E7BE0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830E7BE4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E7BE8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E7BEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E7BF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E7BF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E7BF8 size=72
    let mut pc: u32 = 0x830E7BF8;
    'dispatch: loop {
        match pc {
            0x830E7BF8 => {
    //   block [0x830E7BF8..0x830E7C40)
	// 830E7BF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E7BFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E7C00: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E7C04: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E7C08: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 830E7C0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E7C10: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 830E7C14: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E7C18: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830E7C1C: 4BFFF84D  bl 0x830e7468
	ctx.lr = 0x830E7C20;
	sub_830E7468(ctx, base);
	// 830E7C20: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830E7C24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E7C28: 4BFEDFA1  bl 0x830d5bc8
	ctx.lr = 0x830E7C2C;
	sub_830D5BC8(ctx, base);
	// 830E7C2C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830E7C30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E7C34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E7C38: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E7C3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E7C40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E7C40 size=88
    let mut pc: u32 = 0x830E7C40;
    'dispatch: loop {
        match pc {
            0x830E7C40 => {
    //   block [0x830E7C40..0x830E7C98)
	// 830E7C40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E7C44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E7C48: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E7C4C: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E7C50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E7C54: 7C882378  mr r8, r4
	ctx.r[8].u64 = ctx.r[4].u64;
	// 830E7C58: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 830E7C5C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830E7C60: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830E7C64: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 830E7C68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830E7C6C: 4BFFF6FD  bl 0x830e7368
	ctx.lr = 0x830E7C70;
	sub_830E7368(ctx, base);
	// 830E7C70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E7C74: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 830E7C78: 4BFE6F99  bl 0x830cec10
	ctx.lr = 0x830E7C7C;
	sub_830CEC10(ctx, base);
	// 830E7C7C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E7C80: 4BFEDF49  bl 0x830d5bc8
	ctx.lr = 0x830E7C84;
	sub_830D5BC8(ctx, base);
	// 830E7C84: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 830E7C88: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E7C8C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E7C90: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E7C94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E7C98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E7C98 size=96
    let mut pc: u32 = 0x830E7C98;
    'dispatch: loop {
        match pc {
            0x830E7C98 => {
    //   block [0x830E7C98..0x830E7CF8)
	// 830E7C98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E7C9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E7CA0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E7CA4: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E7CA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E7CAC: 7C882378  mr r8, r4
	ctx.r[8].u64 = ctx.r[4].u64;
	// 830E7CB0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830E7CB4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 830E7CB8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 830E7CBC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830E7CC0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830E7CC4: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 830E7CC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830E7CCC: 4BFFF6ED  bl 0x830e73b8
	ctx.lr = 0x830E7CD0;
	sub_830E73B8(ctx, base);
	// 830E7CD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E7CD4: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 830E7CD8: 4BFE6F39  bl 0x830cec10
	ctx.lr = 0x830E7CDC;
	sub_830CEC10(ctx, base);
	// 830E7CDC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E7CE0: 4BFEDEE9  bl 0x830d5bc8
	ctx.lr = 0x830E7CE4;
	sub_830D5BC8(ctx, base);
	// 830E7CE4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830E7CE8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E7CEC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E7CF0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E7CF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E7CF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E7CF8 size=68
    let mut pc: u32 = 0x830E7CF8;
    'dispatch: loop {
        match pc {
            0x830E7CF8 => {
    //   block [0x830E7CF8..0x830E7D3C)
	// 830E7CF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E7CFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E7D00: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E7D04: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E7D08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E7D0C: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 830E7D10: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E7D14: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830E7D18: 4BFFF191  bl 0x830e6ea8
	ctx.lr = 0x830E7D1C;
	sub_830E6EA8(ctx, base);
	// 830E7D1C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830E7D20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E7D24: 4BFEDEA5  bl 0x830d5bc8
	ctx.lr = 0x830E7D28;
	sub_830D5BC8(ctx, base);
	// 830E7D28: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830E7D2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E7D30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E7D34: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E7D38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E7D40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E7D40 size=68
    let mut pc: u32 = 0x830E7D40;
    'dispatch: loop {
        match pc {
            0x830E7D40 => {
    //   block [0x830E7D40..0x830E7D84)
	// 830E7D40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E7D44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E7D48: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E7D4C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E7D50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E7D54: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E7D58: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830E7D5C: 4BFFF19D  bl 0x830e6ef8
	ctx.lr = 0x830E7D60;
	sub_830E6EF8(ctx, base);
	// 830E7D60: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830E7D64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E7D68: 4BFEDE61  bl 0x830d5bc8
	ctx.lr = 0x830E7D6C;
	sub_830D5BC8(ctx, base);
	// 830E7D6C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E7D70: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830E7D74: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E7D78: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E7D7C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E7D80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E7D88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E7D88 size=68
    let mut pc: u32 = 0x830E7D88;
    'dispatch: loop {
        match pc {
            0x830E7D88 => {
    //   block [0x830E7D88..0x830E7DCC)
	// 830E7D88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E7D8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E7D90: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E7D94: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E7D98: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E7D9C: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 830E7DA0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E7DA4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830E7DA8: 4BFFF189  bl 0x830e6f30
	ctx.lr = 0x830E7DAC;
	sub_830E6F30(ctx, base);
	// 830E7DAC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830E7DB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E7DB4: 4BFEDE15  bl 0x830d5bc8
	ctx.lr = 0x830E7DB8;
	sub_830D5BC8(ctx, base);
	// 830E7DB8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830E7DBC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E7DC0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E7DC4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E7DC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E7DD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E7DD0 size=64
    let mut pc: u32 = 0x830E7DD0;
    'dispatch: loop {
        match pc {
            0x830E7DD0 => {
    //   block [0x830E7DD0..0x830E7E10)
	// 830E7DD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E7DD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E7DD8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E7DDC: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E7DE0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E7DE4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E7DE8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830E7DEC: 4BFFF195  bl 0x830e6f80
	ctx.lr = 0x830E7DF0;
	sub_830E6F80(ctx, base);
	// 830E7DF0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830E7DF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E7DF8: 4BFEDDD1  bl 0x830d5bc8
	ctx.lr = 0x830E7DFC;
	sub_830D5BC8(ctx, base);
	// 830E7DFC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830E7E00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E7E04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E7E08: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E7E0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E7E10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E7E10 size=68
    let mut pc: u32 = 0x830E7E10;
    'dispatch: loop {
        match pc {
            0x830E7E10 => {
    //   block [0x830E7E10..0x830E7E54)
	// 830E7E10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E7E14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E7E18: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E7E1C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E7E20: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E7E24: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 830E7E28: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E7E2C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830E7E30: 4BFFF189  bl 0x830e6fb8
	ctx.lr = 0x830E7E34;
	sub_830E6FB8(ctx, base);
	// 830E7E34: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830E7E38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E7E3C: 4BFEDD8D  bl 0x830d5bc8
	ctx.lr = 0x830E7E40;
	sub_830D5BC8(ctx, base);
	// 830E7E40: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830E7E44: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E7E48: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E7E4C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E7E50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E7E58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E7E58 size=68
    let mut pc: u32 = 0x830E7E58;
    'dispatch: loop {
        match pc {
            0x830E7E58 => {
    //   block [0x830E7E58..0x830E7E9C)
	// 830E7E58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E7E5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E7E60: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E7E64: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E7E68: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E7E6C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E7E70: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830E7E74: 4BFFEFAD  bl 0x830e6e20
	ctx.lr = 0x830E7E78;
	sub_830E6E20(ctx, base);
	// 830E7E78: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830E7E7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E7E80: 4BFEDD49  bl 0x830d5bc8
	ctx.lr = 0x830E7E84;
	sub_830D5BC8(ctx, base);
	// 830E7E84: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E7E88: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830E7E8C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E7E90: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E7E94: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E7E98: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E7EA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E7EA0 size=68
    let mut pc: u32 = 0x830E7EA0;
    'dispatch: loop {
        match pc {
            0x830E7EA0 => {
    //   block [0x830E7EA0..0x830E7EE4)
	// 830E7EA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E7EA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E7EA8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E7EAC: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E7EB0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E7EB4: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 830E7EB8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E7EBC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830E7EC0: 4BFFEF99  bl 0x830e6e58
	ctx.lr = 0x830E7EC4;
	sub_830E6E58(ctx, base);
	// 830E7EC4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830E7EC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E7ECC: 4BFEDCFD  bl 0x830d5bc8
	ctx.lr = 0x830E7ED0;
	sub_830D5BC8(ctx, base);
	// 830E7ED0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830E7ED4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E7ED8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E7EDC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E7EE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E7EE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E7EE8 size=72
    let mut pc: u32 = 0x830E7EE8;
    'dispatch: loop {
        match pc {
            0x830E7EE8 => {
    //   block [0x830E7EE8..0x830E7F30)
	// 830E7EE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E7EEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E7EF0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E7EF4: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E7EF8: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 830E7EFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E7F00: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 830E7F04: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E7F08: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830E7F0C: 4BFFF2B5  bl 0x830e71c0
	ctx.lr = 0x830E7F10;
	sub_830E71C0(ctx, base);
	// 830E7F10: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830E7F14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E7F18: 4BFEDCB1  bl 0x830d5bc8
	ctx.lr = 0x830E7F1C;
	sub_830D5BC8(ctx, base);
	// 830E7F1C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830E7F20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E7F24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E7F28: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E7F2C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E7F30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E7F30 size=72
    let mut pc: u32 = 0x830E7F30;
    'dispatch: loop {
        match pc {
            0x830E7F30 => {
    //   block [0x830E7F30..0x830E7F78)
	// 830E7F30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E7F34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E7F38: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E7F3C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E7F40: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 830E7F44: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E7F48: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 830E7F4C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E7F50: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830E7F54: 4BFFF2AD  bl 0x830e7200
	ctx.lr = 0x830E7F58;
	sub_830E7200(ctx, base);
	// 830E7F58: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830E7F5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E7F60: 4BFEDC69  bl 0x830d5bc8
	ctx.lr = 0x830E7F64;
	sub_830D5BC8(ctx, base);
	// 830E7F64: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830E7F68: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E7F6C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E7F70: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E7F74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E7F78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E7F78 size=72
    let mut pc: u32 = 0x830E7F78;
    'dispatch: loop {
        match pc {
            0x830E7F78 => {
    //   block [0x830E7F78..0x830E7FC0)
	// 830E7F78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E7F7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E7F80: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E7F84: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E7F88: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E7F8C: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 830E7F90: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E7F94: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830E7F98: 4BFFF481  bl 0x830e7418
	ctx.lr = 0x830E7F9C;
	sub_830E7418(ctx, base);
	// 830E7F9C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830E7FA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E7FA4: 4BFEDC25  bl 0x830d5bc8
	ctx.lr = 0x830E7FA8;
	sub_830D5BC8(ctx, base);
	// 830E7FA8: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830E7FAC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830E7FB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E7FB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E7FB8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E7FBC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E7FC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E7FC0 size=72
    let mut pc: u32 = 0x830E7FC0;
    'dispatch: loop {
        match pc {
            0x830E7FC0 => {
    //   block [0x830E7FC0..0x830E8008)
	// 830E7FC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E7FC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E7FC8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E7FCC: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E7FD0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E7FD4: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 830E7FD8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E7FDC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830E7FE0: 4BFFF4C9  bl 0x830e74a8
	ctx.lr = 0x830E7FE4;
	sub_830E74A8(ctx, base);
	// 830E7FE4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830E7FE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E7FEC: 4BFEDBDD  bl 0x830d5bc8
	ctx.lr = 0x830E7FF0;
	sub_830D5BC8(ctx, base);
	// 830E7FF0: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830E7FF4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830E7FF8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E7FFC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E8000: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E8004: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E8008(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E8008 size=88
    let mut pc: u32 = 0x830E8008;
    'dispatch: loop {
        match pc {
            0x830E8008 => {
    //   block [0x830E8008..0x830E8060)
	// 830E8008: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E800C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E8010: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E8014: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E8018: 7CA82B78  mr r8, r5
	ctx.r[8].u64 = ctx.r[5].u64;
	// 830E801C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E8020: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 830E8024: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 830E8028: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830E802C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 830E8030: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830E8034: 4BFFF335  bl 0x830e7368
	ctx.lr = 0x830E8038;
	sub_830E7368(ctx, base);
	// 830E8038: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E803C: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 830E8040: 4BFE6BD1  bl 0x830cec10
	ctx.lr = 0x830E8044;
	sub_830CEC10(ctx, base);
	// 830E8044: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E8048: 4BFEDB81  bl 0x830d5bc8
	ctx.lr = 0x830E804C;
	sub_830D5BC8(ctx, base);
	// 830E804C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 830E8050: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E8054: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E8058: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E805C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E8060(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E8060 size=88
    let mut pc: u32 = 0x830E8060;
    'dispatch: loop {
        match pc {
            0x830E8060 => {
    //   block [0x830E8060..0x830E80B8)
	// 830E8060: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E8064: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E8068: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E806C: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E8070: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E8074: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 830E8078: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 830E807C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830E8080: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 830E8084: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830E8088: 4BFFF241  bl 0x830e72c8
	ctx.lr = 0x830E808C;
	sub_830E72C8(ctx, base);
	// 830E808C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E8090: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 830E8094: 4BFE6B7D  bl 0x830cec10
	ctx.lr = 0x830E8098;
	sub_830CEC10(ctx, base);
	// 830E8098: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E809C: 4BFEDB2D  bl 0x830d5bc8
	ctx.lr = 0x830E80A0;
	sub_830D5BC8(ctx, base);
	// 830E80A0: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 830E80A4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 830E80A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E80AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E80B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E80B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E80B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E80B8 size=96
    let mut pc: u32 = 0x830E80B8;
    'dispatch: loop {
        match pc {
            0x830E80B8 => {
    //   block [0x830E80B8..0x830E8118)
	// 830E80B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E80BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E80C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E80C4: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E80C8: 7CA82B78  mr r8, r5
	ctx.r[8].u64 = ctx.r[5].u64;
	// 830E80CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E80D0: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 830E80D4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830E80D8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 830E80DC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 830E80E0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830E80E4: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 830E80E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830E80EC: 4BFFF2CD  bl 0x830e73b8
	ctx.lr = 0x830E80F0;
	sub_830E73B8(ctx, base);
	// 830E80F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E80F4: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 830E80F8: 4BFE6B19  bl 0x830cec10
	ctx.lr = 0x830E80FC;
	sub_830CEC10(ctx, base);
	// 830E80FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E8100: 4BFEDAC9  bl 0x830d5bc8
	ctx.lr = 0x830E8104;
	sub_830D5BC8(ctx, base);
	// 830E8104: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830E8108: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E810C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E8110: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E8114: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E8118(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E8118 size=104
    let mut pc: u32 = 0x830E8118;
    'dispatch: loop {
        match pc {
            0x830E8118 => {
    //   block [0x830E8118..0x830E8180)
	// 830E8118: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E811C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E8120: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830E8124: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E8128: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E812C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830E8130: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E8134: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 830E8138: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 830E813C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830E8140: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 830E8144: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830E8148: 4BFFF1D9  bl 0x830e7320
	ctx.lr = 0x830E814C;
	sub_830E7320(ctx, base);
	// 830E814C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E8150: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 830E8154: 4BFE6ABD  bl 0x830cec10
	ctx.lr = 0x830E8158;
	sub_830CEC10(ctx, base);
	// 830E8158: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E815C: 4BFEDA6D  bl 0x830d5bc8
	ctx.lr = 0x830E8160;
	sub_830D5BC8(ctx, base);
	// 830E8160: 81610080  lwz r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 830E8164: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830E8168: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 830E816C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E8170: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E8174: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830E8178: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E817C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E8180(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E8180 size=96
    let mut pc: u32 = 0x830E8180;
    'dispatch: loop {
        match pc {
            0x830E8180 => {
    //   block [0x830E8180..0x830E81E0)
	// 830E8180: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E8184: 480BFFE9  bl 0x831a816c
	ctx.lr = 0x830E8188;
	sub_831A8130(ctx, base);
	// 830E8188: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E818C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830E8190: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830E8194: 4BFFF9CD  bl 0x830e7b60
	ctx.lr = 0x830E8198;
	sub_830E7B60(ctx, base);
	// 830E8198: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830E819C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830E81A0: 4BFFF961  bl 0x830e7b00
	ctx.lr = 0x830E81A4;
	sub_830E7B00(ctx, base);
	// 830E81A4: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830E81A8: 4198002C  blt cr6, 0x830e81d4
	if ctx.cr[6].lt {
	pc = 0x830E81D4; continue 'dispatch;
	}
	// 830E81AC: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830E81B0: 41980024  blt cr6, 0x830e81d4
	if ctx.cr[6].lt {
	pc = 0x830E81D4; continue 'dispatch;
	}
	// 830E81B4: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830E81B8: 4099001C  ble cr6, 0x830e81d4
	if !ctx.cr[6].gt {
	pc = 0x830E81D4; continue 'dispatch;
	}
	// 830E81BC: 7F1FF000  cmpw cr6, r31, r30
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[30].s32, &mut ctx.xer);
	// 830E81C0: 41980014  blt cr6, 0x830e81d4
	if ctx.cr[6].lt {
	pc = 0x830E81D4; continue 'dispatch;
	}
	// 830E81C4: 7D63F214  add r11, r3, r30
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[30].u64;
	// 830E81C8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830E81CC: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830E81D0: 41980008  blt cr6, 0x830e81d8
	if ctx.cr[6].lt {
	pc = 0x830E81D8; continue 'dispatch;
	}
	// 830E81D4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E81D8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E81DC: 480BFFE0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E81E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E81E0 size=80
    let mut pc: u32 = 0x830E81E0;
    'dispatch: loop {
        match pc {
            0x830E81E0 => {
    //   block [0x830E81E0..0x830E8230)
	// 830E81E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E81E4: 480BFF89  bl 0x831a816c
	ctx.lr = 0x830E81E8;
	sub_831A8130(ctx, base);
	// 830E81E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E81EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E81F0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830E81F4: 4BFFF7CD  bl 0x830e79c0
	ctx.lr = 0x830E81F8;
	sub_830E79C0(ctx, base);
	// 830E81F8: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830E81FC: 41800028  blt 0x830e8224
	if ctx.cr[0].lt {
	pc = 0x830E8224; continue 'dispatch;
	}
	// 830E8200: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830E8204: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E8208: 4BFFFF79  bl 0x830e8180
	ctx.lr = 0x830E820C;
	sub_830E8180(ctx, base);
	// 830E820C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E8210: 40820014  bne 0x830e8224
	if !ctx.cr[0].eq {
	pc = 0x830E8224; continue 'dispatch;
	}
	// 830E8214: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830E8218: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E821C: 4BFFF995  bl 0x830e7bb0
	ctx.lr = 0x830E8220;
	sub_830E7BB0(ctx, base);
	// 830E8220: 48000008  b 0x830e8228
	pc = 0x830E8228; continue 'dispatch;
	// 830E8224: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830E8228: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E822C: 480BFF90  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E8230(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E8230 size=108
    let mut pc: u32 = 0x830E8230;
    'dispatch: loop {
        match pc {
            0x830E8230 => {
    //   block [0x830E8230..0x830E829C)
	// 830E8230: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E8234: 480BFF31  bl 0x831a8164
	ctx.lr = 0x830E8238;
	sub_831A8130(ctx, base);
	// 830E8238: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E823C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830E8240: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E8244: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 830E8248: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E824C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830E8250: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 830E8254: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 830E8258: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 830E825C: 4BFFE8BD  bl 0x830e6b18
	ctx.lr = 0x830E8260;
	sub_830E6B18(ctx, base);
	// 830E8260: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E8264: 3BE10070  addi r31, r1, 0x70
	ctx.r[31].s64 = ctx.r[1].s64 + 112;
	// 830E8268: 4BFE69A9  bl 0x830cec10
	ctx.lr = 0x830E826C;
	sub_830CEC10(ctx, base);
	// 830E826C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E8270: 4BFED959  bl 0x830d5bc8
	ctx.lr = 0x830E8274;
	sub_830D5BC8(ctx, base);
	// 830E8274: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830E8278: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830E827C: 8121005C  lwz r9, 0x5c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 830E8280: 81010060  lwz r8, 0x60(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830E8284: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830E8288: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830E828C: 913C0000  stw r9, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 830E8290: 911B0000  stw r8, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 830E8294: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 830E8298: 480BFF1C  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E82A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E82A0 size=92
    let mut pc: u32 = 0x830E82A0;
    'dispatch: loop {
        match pc {
            0x830E82A0 => {
    //   block [0x830E82A0..0x830E82FC)
	// 830E82A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E82A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E82A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E82AC: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E82B0: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 830E82B4: 7CE83B78  mr r8, r7
	ctx.r[8].u64 = ctx.r[7].u64;
	// 830E82B8: 7CC73378  mr r7, r6
	ctx.r[7].u64 = ctx.r[6].u64;
	// 830E82BC: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 830E82C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E82C4: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 830E82C8: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 830E82CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830E82D0: 4BFFE899  bl 0x830e6b68
	ctx.lr = 0x830E82D4;
	sub_830E6B68(ctx, base);
	// 830E82D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E82D8: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 830E82DC: 4BFE6935  bl 0x830cec10
	ctx.lr = 0x830E82E0;
	sub_830CEC10(ctx, base);
	// 830E82E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E82E4: 4BFED8E5  bl 0x830d5bc8
	ctx.lr = 0x830E82E8;
	sub_830D5BC8(ctx, base);
	// 830E82E8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830E82EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E82F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E82F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E82F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E8300(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E8300 size=68
    let mut pc: u32 = 0x830E8300;
    'dispatch: loop {
        match pc {
            0x830E8300 => {
    //   block [0x830E8300..0x830E8344)
	// 830E8300: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E8304: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E8308: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E830C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E8310: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E8314: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E8318: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830E831C: 4BFFE8A5  bl 0x830e6bc0
	ctx.lr = 0x830E8320;
	sub_830E6BC0(ctx, base);
	// 830E8320: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830E8324: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E8328: 4BFED8A1  bl 0x830d5bc8
	ctx.lr = 0x830E832C;
	sub_830D5BC8(ctx, base);
	// 830E832C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E8330: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830E8334: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E8338: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E833C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E8340: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E8348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E8348 size=68
    let mut pc: u32 = 0x830E8348;
    'dispatch: loop {
        match pc {
            0x830E8348 => {
    //   block [0x830E8348..0x830E838C)
	// 830E8348: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E834C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E8350: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E8354: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E8358: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E835C: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 830E8360: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E8364: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830E8368: 4BFFF281  bl 0x830e75e8
	ctx.lr = 0x830E836C;
	sub_830E75E8(ctx, base);
	// 830E836C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830E8370: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E8374: 4BFED855  bl 0x830d5bc8
	ctx.lr = 0x830E8378;
	sub_830D5BC8(ctx, base);
	// 830E8378: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830E837C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E8380: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E8384: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E8388: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E8390(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E8390 size=76
    let mut pc: u32 = 0x830E8390;
    'dispatch: loop {
        match pc {
            0x830E8390 => {
    //   block [0x830E8390..0x830E83DC)
	// 830E8390: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E8394: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E8398: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E839C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E83A0: 7CC73378  mr r7, r6
	ctx.r[7].u64 = ctx.r[6].u64;
	// 830E83A4: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 830E83A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E83AC: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 830E83B0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E83B4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830E83B8: 4BFFF281  bl 0x830e7638
	ctx.lr = 0x830E83BC;
	sub_830E7638(ctx, base);
	// 830E83BC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830E83C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E83C4: 4BFED805  bl 0x830d5bc8
	ctx.lr = 0x830E83C8;
	sub_830D5BC8(ctx, base);
	// 830E83C8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830E83CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E83D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E83D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E83D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E83E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830E83E0 size=292
    let mut pc: u32 = 0x830E83E0;
    'dispatch: loop {
        match pc {
            0x830E83E0 => {
    //   block [0x830E83E0..0x830E8504)
	// 830E83E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E83E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E83E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E83EC: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 830E83F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E83F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E83F8: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 830E83FC: C1BF0000  lfs f13, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830E8400: C01F0018  lfs f0, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E8404: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 830E8408: C1BF001C  lfs f13, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830E840C: C19F0004  lfs f12, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830E8410: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 830E8414: EDAD6028  fsubs f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 830E8418: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 830E841C: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 830E8420: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 830E8424: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 830E8428: 4098000C  bge cr6, 0x830e8434
	if !ctx.cr[6].lt {
	pc = 0x830E8434; continue 'dispatch;
	}
	// 830E842C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830E8430: 480000BC  b 0x830e84ec
	pc = 0x830E84EC; continue 'dispatch;
	// 830E8434: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E8438: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830E843C: 4802FACD  bl 0x83117f08
	ctx.lr = 0x830E8440;
	sub_83117F08(ctx, base);
	// 830E8440: C15F0004  lfs f10, 4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 830E8444: C13F000C  lfs f9, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 830E8448: C17F0000  lfs f11, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830E844C: ECE95028  fsubs f7, f9, f10
	ctx.f[7].f64 = (((ctx.f[9].f64 - ctx.f[10].f64) as f32) as f64);
	// 830E8450: C11F0010  lfs f8, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 830E8454: ECC85828  fsubs f6, f8, f11
	ctx.f[6].f64 = (((ctx.f[8].f64 - ctx.f[11].f64) as f32) as f64);
	// 830E8458: C0010050  lfs f0, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E845C: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830E8460: ED800032  fmuls f12, f0, f0
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 830E8464: C0BF0008  lfs f5, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 830E8468: C09F0014  lfs f4, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 830E846C: EC655828  fsubs f3, f5, f11
	ctx.f[3].f64 = (((ctx.f[5].f64 - ctx.f[11].f64) as f32) as f64);
	// 830E8470: EC445028  fsubs f2, f4, f10
	ctx.f[2].f64 = (((ctx.f[4].f64 - ctx.f[10].f64) as f32) as f64);
	// 830E8474: ECE70372  fmuls f7, f7, f13
	ctx.f[7].f64 = (((ctx.f[7].f64 * ctx.f[13].f64) as f32) as f64);
	// 830E8478: ECC60032  fmuls f6, f6, f0
	ctx.f[6].f64 = (((ctx.f[6].f64 * ctx.f[0].f64) as f32) as f64);
	// 830E847C: ED8D637A  fmadds f12, f13, f13, f12
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 830E8480: ECE3383A  fmadds f7, f3, f0, f7
	ctx.f[7].f64 = (((ctx.f[3].f64 * ctx.f[0].f64 + ctx.f[7].f64) as f32) as f64);
	// 830E8484: ECC2337A  fmadds f6, f2, f13, f6
	ctx.f[6].f64 = (((ctx.f[2].f64 * ctx.f[13].f64 + ctx.f[6].f64) as f32) as f64);
	// 830E8488: ECE76024  fdivs f7, f7, f12
	ctx.f[7].f64 = ((ctx.f[7].f64 / ctx.f[12].f64) as f32) as f64;
	// 830E848C: ED866024  fdivs f12, f6, f12
	ctx.f[12].f64 = ((ctx.f[6].f64 / ctx.f[12].f64) as f32) as f64;
	// 830E8490: ECC70032  fmuls f6, f7, f0
	ctx.f[6].f64 = (((ctx.f[7].f64 * ctx.f[0].f64) as f32) as f64);
	// 830E8494: ECE70372  fmuls f7, f7, f13
	ctx.f[7].f64 = (((ctx.f[7].f64 * ctx.f[13].f64) as f32) as f64);
	// 830E8498: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 830E849C: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 830E84A0: ED8B302A  fadds f12, f11, f6
	ctx.f[12].f64 = ((ctx.f[11].f64 + ctx.f[6].f64) as f32) as f64;
	// 830E84A4: EC0B002A  fadds f0, f11, f0
	ctx.f[0].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 830E84A8: EDAA682A  fadds f13, f10, f13
	ctx.f[13].f64 = ((ctx.f[10].f64 + ctx.f[13].f64) as f32) as f64;
	// 830E84AC: ED6A382A  fadds f11, f10, f7
	ctx.f[11].f64 = ((ctx.f[10].f64 + ctx.f[7].f64) as f32) as f64;
	// 830E84B0: ED856028  fsubs f12, f5, f12
	ctx.f[12].f64 = (((ctx.f[5].f64 - ctx.f[12].f64) as f32) as f64);
	// 830E84B4: EC080028  fsubs f0, f8, f0
	ctx.f[0].f64 = (((ctx.f[8].f64 - ctx.f[0].f64) as f32) as f64);
	// 830E84B8: EDA46828  fsubs f13, f4, f13
	ctx.f[13].f64 = (((ctx.f[4].f64 - ctx.f[13].f64) as f32) as f64);
	// 830E84BC: ED695828  fsubs f11, f9, f11
	ctx.f[11].f64 = (((ctx.f[9].f64 - ctx.f[11].f64) as f32) as f64);
	// 830E84C0: ED8C0332  fmuls f12, f12, f12
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[12].f64) as f32) as f64);
	// 830E84C4: ED400032  fmuls f10, f0, f0
	ctx.f[10].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 830E84C8: EC0B62FA  fmadds f0, f11, f11, f12
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[12].f64) as f32) as f64);
	// 830E84CC: EDAD537A  fmadds f13, f13, f13, f10
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[10].f64) as f32) as f64);
	// 830E84D0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830E84D4: 41990008  bgt cr6, 0x830e84dc
	if ctx.cr[6].gt {
	pc = 0x830E84DC; continue 'dispatch;
	}
	// 830E84D8: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 830E84DC: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 830E84E0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830E84E4: 41980008  blt cr6, 0x830e84ec
	if ctx.cr[6].lt {
	pc = 0x830E84EC; continue 'dispatch;
	}
	// 830E84E8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E84EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E84F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E84F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E84F8: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830E84FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E8500: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E8508(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830E8508 size=984
    let mut pc: u32 = 0x830E8508;
    'dispatch: loop {
        match pc {
            0x830E8508 => {
    //   block [0x830E8508..0x830E88E0)
	// 830E8508: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E850C: 480BFC51  bl 0x831a815c
	ctx.lr = 0x830E8510;
	sub_831A8130(ctx, base);
	// 830E8510: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E8514: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 830E8518: D0040000  stfs f0, 0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E88E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830E88E0 size=184
    let mut pc: u32 = 0x830E88E0;
    'dispatch: loop {
        match pc {
            0x830E88E0 => {
    //   block [0x830E88E0..0x830E8998)
	// 830E88E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E88E4: 480BF889  bl 0x831a816c
	ctx.lr = 0x830E88E8;
	sub_831A8130(ctx, base);
	// 830E88E8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E88EC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 830E88F0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830E88F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830E88F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E88FC: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 830E8900: C02B9450  lfs f1, -0x6bb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830E8904: 4BFFFADD  bl 0x830e83e0
	ctx.lr = 0x830E8908;
	sub_830E83E0(ctx, base);
	// 830E8908: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E890C: 41820030  beq 0x830e893c
	if ctx.cr[0].eq {
	pc = 0x830E893C; continue 'dispatch;
	}
	// 830E8910: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E8914: C05F001C  lfs f2, 0x1c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 830E8918: C03F0018  lfs f1, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830E891C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E8920: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E8924: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830E8928: 4E800421  bctrl
	ctx.lr = 0x830E892C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830E892C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E8930: 41800060  blt 0x830e8990
	if ctx.cr[0].lt {
	pc = 0x830E8990; continue 'dispatch;
	}
	// 830E8934: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830E8938: 48000050  b 0x830e8988
	pc = 0x830E8988; continue 'dispatch;
	// 830E893C: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 830E8940: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830E8944: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E8948: 4BFFFBC1  bl 0x830e8508
	ctx.lr = 0x830E894C;
	sub_830E8508(ctx, base);
	// 830E894C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830E8950: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830E8954: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E8958: 4BFFFF89  bl 0x830e88e0
	ctx.lr = 0x830E895C;
	sub_830E88E0(ctx, base);
	// 830E895C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E8960: 41800030  blt 0x830e8990
	if ctx.cr[0].lt {
	pc = 0x830E8990; continue 'dispatch;
	}
	// 830E8964: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 830E8968: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 830E896C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E8970: 4BFFFF71  bl 0x830e88e0
	ctx.lr = 0x830E8974;
	sub_830E88E0(ctx, base);
	// 830E8974: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E8978: 41800018  blt 0x830e8990
	if ctx.cr[0].lt {
	pc = 0x830E8990; continue 'dispatch;
	}
	// 830E897C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E8980: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830E8984: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 830E8988: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830E898C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E8990: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 830E8994: 480BF828  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E8998(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830E8998 size=32
    let mut pc: u32 = 0x830E8998;
    'dispatch: loop {
        match pc {
            0x830E8998 => {
    //   block [0x830E8998..0x830E89B8)
	// 830E8998: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 830E899C: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 830E89A0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830E89A4: 409A0014  bne cr6, 0x830e89b8
	if !ctx.cr[6].eq {
		sub_830E89B8(ctx, base);
		return;
	}
	// 830E89A8: D02B000C  stfs f1, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830E89AC: D02B0004  stfs f1, 4(r11)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830E89B0: D04B0008  stfs f2, 8(r11)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 830E89B4: 48000040  b 0x830e89f4
	sub_830E89B8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E89B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830E89B8 size=80
    let mut pc: u32 = 0x830E89B8;
    'dispatch: loop {
        match pc {
            0x830E89B8 => {
    //   block [0x830E89B8..0x830E8A08)
	// 830E89B8: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E89BC: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 830E89C0: 40980008  bge cr6, 0x830e89c8
	if !ctx.cr[6].lt {
	pc = 0x830E89C8; continue 'dispatch;
	}
	// 830E89C4: D02B0004  stfs f1, 4(r11)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830E89C8: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E89CC: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 830E89D0: 40990008  ble cr6, 0x830e89d8
	if !ctx.cr[6].gt {
	pc = 0x830E89D8; continue 'dispatch;
	}
	// 830E89D4: D02B000C  stfs f1, 0xc(r11)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830E89D8: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E89DC: FF020000  fcmpu cr6, f2, f0
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 830E89E0: 40980008  bge cr6, 0x830e89e8
	if !ctx.cr[6].lt {
	pc = 0x830E89E8; continue 'dispatch;
	}
	// 830E89E4: D04B0008  stfs f2, 8(r11)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 830E89E8: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E89EC: FF020000  fcmpu cr6, f2, f0
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 830E89F0: 40990008  ble cr6, 0x830e89f8
	if !ctx.cr[6].gt {
	pc = 0x830E89F8; continue 'dispatch;
	}
	// 830E89F4: D04B0010  stfs f2, 0x10(r11)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 830E89F8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830E89FC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E8A00: 914B0014  stw r10, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 830E8A04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E8A08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E8A08 size=372
    let mut pc: u32 = 0x830E8A08;
    'dispatch: loop {
        match pc {
            0x830E8A08 => {
    //   block [0x830E8A08..0x830E8B7C)
	// 830E8A08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E8A0C: 480BF74D  bl 0x831a8158
	ctx.lr = 0x830E8A10;
	sub_831A8130(ctx, base);
	// 830E8A10: 9421FE90  stwu r1, -0x170(r1)
	ea = ctx.r[1].u32.wrapping_add(-368 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E8A14: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830E8A18: 81440010  lwz r10, 0x10(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 830E8A1C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830E8A20: 3B6BD8F4  addi r27, r11, -0x270c
	ctx.r[27].s64 = ctx.r[11].s64 + -9996;
	// 830E8A24: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 830E8A28: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 830E8A2C: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 830E8A30: 7FB8EB78  mr r24, r29
	ctx.r[24].u64 = ctx.r[29].u64;
	// 830E8A34: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 830E8A38: 83CA0000  lwz r30, 0(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E8A3C: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E8A40: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E8A44: 4081012C  ble 0x830e8b70
	if !ctx.cr[0].gt {
	pc = 0x830E8B70; continue 'dispatch;
	}
	// 830E8A48: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 830E8A4C: 7D795B78  mr r25, r11
	ctx.r[25].u64 = ctx.r[11].u64;
	// 830E8A50: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E8A54: 807A0000  lwz r3, 0(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E8A58: 7FFC5A14  add r31, r28, r11
	ctx.r[31].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 830E8A5C: 7C9C582E  lwzx r4, r28, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830E8A60: 4BFF7411  bl 0x830dfe70
	ctx.lr = 0x830E8A64;
	sub_830DFE70(ctx, base);
	// 830E8A64: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E8A68: 418200B8  beq 0x830e8b20
	if ctx.cr[0].eq {
	pc = 0x830E8B20; continue 'dispatch;
	}
	// 830E8A6C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E8A70: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E8A74: 419A00AC  beq cr6, 0x830e8b20
	if ctx.cr[6].eq {
	pc = 0x830E8B20; continue 'dispatch;
	}
	// 830E8A78: 2F180000  cmpwi cr6, r24, 0
	ctx.cr[6].compare_i32(ctx.r[24].s32, 0, &mut ctx.xer);
	// 830E8A7C: 409A0034  bne cr6, 0x830e8ab0
	if !ctx.cr[6].eq {
	pc = 0x830E8AB0; continue 'dispatch;
	}
	// 830E8A80: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 830E8A84: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830E8A88: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 830E8A8C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E8A90: 48027E79  bl 0x83110908
	ctx.lr = 0x830E8A94;
	sub_83110908(ctx, base);
	// 830E8A94: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 830E8A98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E8A9C: 48027475  bl 0x8310ff10
	ctx.lr = 0x830E8AA0;
	sub_8310FF10(ctx, base);
	// 830E8AA0: 388100E0  addi r4, r1, 0xe0
	ctx.r[4].s64 = ctx.r[1].s64 + 224;
	// 830E8AA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E8AA8: 48027861  bl 0x83110308
	ctx.lr = 0x830E8AAC;
	sub_83110308(ctx, base);
	// 830E8AAC: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	// 830E8AB0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E8AB4: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E8AB8: 48027A41  bl 0x831104f8
	ctx.lr = 0x830E8ABC;
	sub_831104F8(ctx, base);
	// 830E8ABC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E8AC0: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830E8AC4: 48027A0D  bl 0x831104d0
	ctx.lr = 0x830E8AC8;
	sub_831104D0(ctx, base);
	// 830E8AC8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E8ACC: 809F0010  lwz r4, 0x10(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830E8AD0: 48027A51  bl 0x83110520
	ctx.lr = 0x830E8AD4;
	sub_83110520(ctx, base);
	// 830E8AD4: 389F0014  addi r4, r31, 0x14
	ctx.r[4].s64 = ctx.r[31].s64 + 20;
	// 830E8AD8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E8ADC: 480277DD  bl 0x831102b8
	ctx.lr = 0x830E8AE0;
	sub_831102B8(ctx, base);
	// 830E8AE0: 389F0054  addi r4, r31, 0x54
	ctx.r[4].s64 = ctx.r[31].s64 + 84;
	// 830E8AE4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E8AE8: 480277F9  bl 0x831102e0
	ctx.lr = 0x830E8AEC;
	sub_831102E0(ctx, base);
	// 830E8AEC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830E8AF0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830E8AF4: 80FF009C  lwz r7, 0x9c(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) } as u64;
	// 830E8AF8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 830E8AFC: 80DF0098  lwz r6, 0x98(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 830E8B00: 4BFFDF51  bl 0x830e6a50
	ctx.lr = 0x830E8B04;
	sub_830E6A50(ctx, base);
	// 830E8B04: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 830E8B08: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 830E8B0C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E8B10: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 830E8B14: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 830E8B18: 4BFED0B1  bl 0x830d5bc8
	ctx.lr = 0x830E8B1C;
	sub_830D5BC8(ctx, base);
	// 830E8B1C: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 830E8B20: 3739FFFF  addic. r25, r25, -1
	ctx.xer.ca = (ctx.r[25].u32 > (!(-1 as u32)));
	ctx.r[25].s64 = ctx.r[25].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 830E8B24: 3B9C00A8  addi r28, r28, 0xa8
	ctx.r[28].s64 = ctx.r[28].s64 + 168;
	// 830E8B28: 4082FF28  bne 0x830e8a50
	if !ctx.cr[0].eq {
	pc = 0x830E8A50; continue 'dispatch;
	}
	// 830E8B2C: 2F180000  cmpwi cr6, r24, 0
	ctx.cr[6].compare_i32(ctx.r[24].s32, 0, &mut ctx.xer);
	// 830E8B30: 419A0040  beq cr6, 0x830e8b70
	if ctx.cr[6].eq {
	pc = 0x830E8B70; continue 'dispatch;
	}
	// 830E8B34: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E8B38: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830E8B3C: 480279BD  bl 0x831104f8
	ctx.lr = 0x830E8B40;
	sub_831104F8(ctx, base);
	// 830E8B40: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E8B44: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E8B48: 48027989  bl 0x831104d0
	ctx.lr = 0x830E8B4C;
	sub_831104D0(ctx, base);
	// 830E8B4C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E8B50: 80810058  lwz r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830E8B54: 480279CD  bl 0x83110520
	ctx.lr = 0x830E8B58;
	sub_83110520(ctx, base);
	// 830E8B58: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 830E8B5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E8B60: 48027759  bl 0x831102b8
	ctx.lr = 0x830E8B64;
	sub_831102B8(ctx, base);
	// 830E8B64: 388100E0  addi r4, r1, 0xe0
	ctx.r[4].s64 = ctx.r[1].s64 + 224;
	// 830E8B68: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E8B6C: 48027775  bl 0x831102e0
	ctx.lr = 0x830E8B70;
	sub_831102E0(ctx, base);
	// 830E8B70: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E8B74: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 830E8B78: 480BF630  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E8B80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E8B80 size=192
    let mut pc: u32 = 0x830E8B80;
    'dispatch: loop {
        match pc {
            0x830E8B80 => {
    //   block [0x830E8B80..0x830E8C40)
	// 830E8B80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E8B84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E8B88: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830E8B8C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E8B90: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E8B94: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830E8B98: 7CC73378  mr r7, r6
	ctx.r[7].u64 = ctx.r[6].u64;
	// 830E8B9C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E8BA0: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 830E8BA4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830E8BA8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830E8BAC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830E8BB0: 4BFF7911  bl 0x830e04c0
	ctx.lr = 0x830E8BB4;
	sub_830E04C0(ctx, base);
	// 830E8BB4: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 830E8BB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E8BBC: 4BFED00D  bl 0x830d5bc8
	ctx.lr = 0x830E8BC0;
	sub_830D5BC8(ctx, base);
	// 830E8BC0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E8BC4: 40800014  bge 0x830e8bd8
	if !ctx.cr[0].lt {
	pc = 0x830E8BD8; continue 'dispatch;
	}
	// 830E8BC8: 3D608030  lis r11, -0x7fd0
	ctx.r[11].s64 = -2144337920;
	// 830E8BCC: 616B0026  ori r11, r11, 0x26
	ctx.r[11].u64 = ctx.r[11].u64 | 38;
	// 830E8BD0: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830E8BD4: 409A0054  bne cr6, 0x830e8c28
	if !ctx.cr[6].eq {
	pc = 0x830E8C28; continue 'dispatch;
	}
	// 830E8BD8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830E8BDC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E8BE0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830E8BE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E8BE8: 4BFF6BE9  bl 0x830df7d0
	ctx.lr = 0x830E8BEC;
	sub_830DF7D0(ctx, base);
	// 830E8BEC: 48000030  b 0x830e8c1c
	pc = 0x830E8C1C; continue 'dispatch;
	// 830E8BF0: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 830E8BF4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830E8BF8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830E8BFC: 4BFFFF85  bl 0x830e8b80
	ctx.lr = 0x830E8C00;
	sub_830E8B80(ctx, base);
	// 830E8C00: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E8C04: 41800024  blt 0x830e8c28
	if ctx.cr[0].lt {
	pc = 0x830E8C28; continue 'dispatch;
	}
	// 830E8C08: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E8C0C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E8C10: 4BFF6CB1  bl 0x830df8c0
	ctx.lr = 0x830E8C14;
	sub_830DF8C0(ctx, base);
	// 830E8C14: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E8C18: 41800010  blt 0x830e8c28
	if ctx.cr[0].lt {
	pc = 0x830E8C28; continue 'dispatch;
	}
	// 830E8C1C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E8C20: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830E8C24: 409AFFCC  bne cr6, 0x830e8bf0
	if !ctx.cr[6].eq {
	pc = 0x830E8BF0; continue 'dispatch;
	}
	// 830E8C28: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830E8C2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E8C30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E8C34: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830E8C38: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E8C3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E8C40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830E8C40 size=448
    let mut pc: u32 = 0x830E8C40;
    'dispatch: loop {
        match pc {
            0x830E8C40 => {
    //   block [0x830E8C40..0x830E8E00)
	// 830E8C40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E8C44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E8C48: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830E8C4C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E8C50: 9421FE50  stwu r1, -0x1b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-432 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E8C54: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E8C58: 817F00F0  lwz r11, 0xf0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 830E8C5C: 556B07BC  rlwinm r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830E8C60: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 830E8C64: 409A0184  bne cr6, 0x830e8de8
	if !ctx.cr[6].eq {
	pc = 0x830E8DE8; continue 'dispatch;
	}
	// 830E8C68: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 830E8C6C: C07F0044  lfs f3, 0x44(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 830E8C70: C05F0040  lfs f2, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 830E8C74: C03F003C  lfs f1, 0x3c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830E8C78: 4802F061  bl 0x83117cd8
	ctx.lr = 0x830E8C7C;
	sub_83117CD8(ctx, base);
	// 830E8C7C: 389F0048  addi r4, r31, 0x48
	ctx.r[4].s64 = ctx.r[31].s64 + 72;
	// 830E8C80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830E8C84: 4802F2FD  bl 0x83117f80
	ctx.lr = 0x830E8C88;
	sub_83117F80(ctx, base);
	// 830E8C88: C01F0060  lfs f0, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E8C8C: FC600050  fneg f3, f0
	ctx.f[3].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 830E8C90: C1BF005C  lfs f13, 0x5c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830E8C94: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 830E8C98: FC406850  fneg f2, f13
	ctx.f[2].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 830E8C9C: C01F0058  lfs f0, 0x58(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E8CA0: FC200050  fneg f1, f0
	ctx.f[1].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 830E8CA4: 4802F0AD  bl 0x83117d50
	ctx.lr = 0x830E8CA8;
	sub_83117D50(ctx, base);
	// 830E8CA8: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 830E8CAC: C07F0060  lfs f3, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 830E8CB0: C05F005C  lfs f2, 0x5c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 830E8CB4: C03F0058  lfs f1, 0x58(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830E8CB8: 4802F099  bl 0x83117d50
	ctx.lr = 0x830E8CBC;
	sub_83117D50(ctx, base);
	// 830E8CBC: 38610150  addi r3, r1, 0x150
	ctx.r[3].s64 = ctx.r[1].s64 + 336;
	// 830E8CC0: C07F0038  lfs f3, 0x38(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 830E8CC4: C05F0034  lfs f2, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 830E8CC8: C03F0030  lfs f1, 0x30(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830E8CCC: 4802F085  bl 0x83117d50
	ctx.lr = 0x830E8CD0;
	sub_83117D50(ctx, base);
	// 830E8CD0: 3BDF0064  addi r30, r31, 0x64
	ctx.r[30].s64 = ctx.r[31].s64 + 100;
	// 830E8CD4: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 830E8CD8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E8CDC: 38810110  addi r4, r1, 0x110
	ctx.r[4].s64 = ctx.r[1].s64 + 272;
	// 830E8CE0: 4802F101  bl 0x83117de0
	ctx.lr = 0x830E8CE4;
	sub_83117DE0(ctx, base);
	// 830E8CE4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830E8CE8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E8CEC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830E8CF0: 4802F0F1  bl 0x83117de0
	ctx.lr = 0x830E8CF4;
	sub_83117DE0(ctx, base);
	// 830E8CF4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830E8CF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E8CFC: 38A100D0  addi r5, r1, 0xd0
	ctx.r[5].s64 = ctx.r[1].s64 + 208;
	// 830E8D00: 4802F0E1  bl 0x83117de0
	ctx.lr = 0x830E8D04;
	sub_83117DE0(ctx, base);
	// 830E8D04: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830E8D08: 38A10150  addi r5, r1, 0x150
	ctx.r[5].s64 = ctx.r[1].s64 + 336;
	// 830E8D0C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E8D10: 4802F0D1  bl 0x83117de0
	ctx.lr = 0x830E8D14;
	sub_83117DE0(ctx, base);
	// 830E8D14: 815F00F0  lwz r10, 0xf0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 830E8D18: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 830E8D1C: 554A07FA  rlwinm r10, r10, 0, 0x1f, 0x1d
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 830E8D20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830E8D24: 915F00F0  stw r10, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[10].u32 ) };
	// 830E8D28: 419A0018  beq cr6, 0x830e8d40
	if ctx.cr[6].eq {
	pc = 0x830E8D40; continue 'dispatch;
	}
	// 830E8D2C: 38AB00A4  addi r5, r11, 0xa4
	ctx.r[5].s64 = ctx.r[11].s64 + 164;
	// 830E8D30: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830E8D34: 387F00A4  addi r3, r31, 0xa4
	ctx.r[3].s64 = ctx.r[31].s64 + 164;
	// 830E8D38: 4802F0A9  bl 0x83117de0
	ctx.lr = 0x830E8D3C;
	sub_83117DE0(ctx, base);
	// 830E8D3C: 48000084  b 0x830e8dc0
	pc = 0x830E8DC0; continue 'dispatch;
	// 830E8D40: C01E0000  lfs f0, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E8D44: D01F00A4  stfs f0, 0xa4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 830E8D48: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E8D4C: D01F00A8  stfs f0, 0xa8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 830E8D50: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E8D54: D01F00AC  stfs f0, 0xac(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 830E8D58: C01E000C  lfs f0, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E8D5C: D01F00B0  stfs f0, 0xb0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 830E8D60: C01E0010  lfs f0, 0x10(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E8D64: D01F00B4  stfs f0, 0xb4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 830E8D68: C01E0014  lfs f0, 0x14(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E8D6C: D01F00B8  stfs f0, 0xb8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 830E8D70: C01E0018  lfs f0, 0x18(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E8D74: D01F00BC  stfs f0, 0xbc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 830E8D78: C01E001C  lfs f0, 0x1c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E8D7C: D01F00C0  stfs f0, 0xc0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 830E8D80: C01E0020  lfs f0, 0x20(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E8D84: D01F00C4  stfs f0, 0xc4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 830E8D88: C01E0024  lfs f0, 0x24(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E8D8C: D01F00C8  stfs f0, 0xc8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 830E8D90: C01E0028  lfs f0, 0x28(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E8D94: D01F00CC  stfs f0, 0xcc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 830E8D98: C01E002C  lfs f0, 0x2c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E8D9C: D01F00D0  stfs f0, 0xd0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 830E8DA0: C01E0030  lfs f0, 0x30(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E8DA4: D01F00D4  stfs f0, 0xd4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 830E8DA8: C01E0034  lfs f0, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E8DAC: D01F00D8  stfs f0, 0xd8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 830E8DB0: C01E0038  lfs f0, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E8DB4: D01F00DC  stfs f0, 0xdc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 830E8DB8: C01E003C  lfs f0, 0x3c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E8DBC: D01F00E0  stfs f0, 0xe0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 830E8DC0: 83FF0018  lwz r31, 0x18(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830E8DC4: 4800001C  b 0x830e8de0
	pc = 0x830E8DE0; continue 'dispatch;
	// 830E8DC8: 817F00F0  lwz r11, 0xf0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 830E8DCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E8DD0: 616B0002  ori r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u64 | 2;
	// 830E8DD4: 917F00F0  stw r11, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 830E8DD8: 4BFFFE69  bl 0x830e8c40
	ctx.lr = 0x830E8DDC;
	sub_830E8C40(ctx, base);
	// 830E8DDC: 83FF0020  lwz r31, 0x20(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 830E8DE0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830E8DE4: 409AFFE4  bne cr6, 0x830e8dc8
	if !ctx.cr[6].eq {
	pc = 0x830E8DC8; continue 'dispatch;
	}
	// 830E8DE8: 382101B0  addi r1, r1, 0x1b0
	ctx.r[1].s64 = ctx.r[1].s64 + 432;
	// 830E8DEC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E8DF0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E8DF4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830E8DF8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E8DFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E8E00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830E8E00 size=188
    let mut pc: u32 = 0x830E8E00;
    'dispatch: loop {
        match pc {
            0x830E8E00 => {
    //   block [0x830E8E00..0x830E8EBC)
	// 830E8E00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E8E04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E8E08: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830E8E0C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E8E10: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E8E14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E8E18: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830E8E1C: 4BFFFE25  bl 0x830e8c40
	ctx.lr = 0x830E8E20;
	sub_830E8C40(ctx, base);
	// 830E8E20: C01F0064  lfs f0, 0x64(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E8E24: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E8E28: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830E8E2C: C01F0068  lfs f0, 0x68(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E8E30: D01E0004  stfs f0, 4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830E8E34: C01F006C  lfs f0, 0x6c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E8E38: D01E0008  stfs f0, 8(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 830E8E3C: C01F0070  lfs f0, 0x70(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E8E40: D01E000C  stfs f0, 0xc(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830E8E44: C01F0074  lfs f0, 0x74(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E8E48: D01E0010  stfs f0, 0x10(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 830E8E4C: C01F0078  lfs f0, 0x78(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E8E50: D01E0014  stfs f0, 0x14(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 830E8E54: C01F007C  lfs f0, 0x7c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E8E58: D01E0018  stfs f0, 0x18(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 830E8E5C: C01F0080  lfs f0, 0x80(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E8E60: D01E001C  stfs f0, 0x1c(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 830E8E64: C01F0084  lfs f0, 0x84(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E8E68: D01E0020  stfs f0, 0x20(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 830E8E6C: C01F0088  lfs f0, 0x88(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E8E70: D01E0024  stfs f0, 0x24(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 830E8E74: C01F008C  lfs f0, 0x8c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E8E78: D01E0028  stfs f0, 0x28(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 830E8E7C: C01F0090  lfs f0, 0x90(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E8E80: D01E002C  stfs f0, 0x2c(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 830E8E84: C01F0094  lfs f0, 0x94(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E8E88: D01E0030  stfs f0, 0x30(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 830E8E8C: C01F0098  lfs f0, 0x98(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E8E90: D01E0034  stfs f0, 0x34(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 830E8E94: C01F009C  lfs f0, 0x9c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E8E98: D01E0038  stfs f0, 0x38(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 830E8E9C: C01F00A0  lfs f0, 0xa0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E8EA0: D01E003C  stfs f0, 0x3c(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 830E8EA4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E8EA8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E8EAC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E8EB0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830E8EB4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E8EB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E8EC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830E8EC0 size=188
    let mut pc: u32 = 0x830E8EC0;
    'dispatch: loop {
        match pc {
            0x830E8EC0 => {
    //   block [0x830E8EC0..0x830E8F7C)
	// 830E8EC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E8EC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E8EC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830E8ECC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E8ED0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E8ED4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E8ED8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830E8EDC: 4BFFFD65  bl 0x830e8c40
	ctx.lr = 0x830E8EE0;
	sub_830E8C40(ctx, base);
	// 830E8EE0: C01F00A4  lfs f0, 0xa4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E8EE4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E8EE8: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830E8EEC: C01F00A8  lfs f0, 0xa8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E8EF0: D01E0004  stfs f0, 4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830E8EF4: C01F00AC  lfs f0, 0xac(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E8EF8: D01E0008  stfs f0, 8(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 830E8EFC: C01F00B0  lfs f0, 0xb0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E8F00: D01E000C  stfs f0, 0xc(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830E8F04: C01F00B4  lfs f0, 0xb4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E8F08: D01E0010  stfs f0, 0x10(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 830E8F0C: C01F00B8  lfs f0, 0xb8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E8F10: D01E0014  stfs f0, 0x14(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 830E8F14: C01F00BC  lfs f0, 0xbc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E8F18: D01E0018  stfs f0, 0x18(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 830E8F1C: C01F00C0  lfs f0, 0xc0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E8F20: D01E001C  stfs f0, 0x1c(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 830E8F24: C01F00C4  lfs f0, 0xc4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E8F28: D01E0020  stfs f0, 0x20(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 830E8F2C: C01F00C8  lfs f0, 0xc8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E8F30: D01E0024  stfs f0, 0x24(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 830E8F34: C01F00CC  lfs f0, 0xcc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E8F38: D01E0028  stfs f0, 0x28(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 830E8F3C: C01F00D0  lfs f0, 0xd0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E8F40: D01E002C  stfs f0, 0x2c(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 830E8F44: C01F00D4  lfs f0, 0xd4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E8F48: D01E0030  stfs f0, 0x30(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 830E8F4C: C01F00D8  lfs f0, 0xd8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E8F50: D01E0034  stfs f0, 0x34(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 830E8F54: C01F00DC  lfs f0, 0xdc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E8F58: D01E0038  stfs f0, 0x38(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 830E8F5C: C01F00E0  lfs f0, 0xe0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E8F60: D01E003C  stfs f0, 0x3c(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 830E8F64: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E8F68: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E8F6C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E8F70: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830E8F74: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E8F78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E8F80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830E8F80 size=36
    let mut pc: u32 = 0x830E8F80;
    'dispatch: loop {
        match pc {
            0x830E8F80 => {
    //   block [0x830E8F80..0x830E8FA4)
	// 830E8F80: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 830E8F84: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E8F88: C00B0030  lfs f0, 0x30(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E8F8C: D0040000  stfs f0, 0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830E8F90: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E8F94: D0040004  stfs f0, 4(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830E8F98: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E8F9C: D0040008  stfs f0, 8(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 830E8FA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E8FA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830E8FA8 size=36
    let mut pc: u32 = 0x830E8FA8;
    'dispatch: loop {
        match pc {
            0x830E8FA8 => {
    //   block [0x830E8FA8..0x830E8FCC)
	// 830E8FA8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 830E8FAC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E8FB0: C00B003C  lfs f0, 0x3c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E8FB4: D0040000  stfs f0, 0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830E8FB8: C00B0040  lfs f0, 0x40(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E8FBC: D0040004  stfs f0, 4(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830E8FC0: C00B0044  lfs f0, 0x44(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E8FC4: D0040008  stfs f0, 8(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 830E8FC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E8FD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830E8FD0 size=56
    let mut pc: u32 = 0x830E8FD0;
    'dispatch: loop {
        match pc {
            0x830E8FD0 => {
    //   block [0x830E8FD0..0x830E9008)
	// 830E8FD0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 830E8FD4: C0040000  lfs f0, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E8FD8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E8FDC: D00B0048  stfs f0, 0x48(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 830E8FE0: C0040004  lfs f0, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E8FE4: D00B004C  stfs f0, 0x4c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 830E8FE8: C0040008  lfs f0, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E8FEC: D00B0050  stfs f0, 0x50(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 830E8FF0: C004000C  lfs f0, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E8FF4: D00B0054  stfs f0, 0x54(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 830E8FF8: 814B00F0  lwz r10, 0xf0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(240 as u32) ) } as u64;
	// 830E8FFC: 614A0002  ori r10, r10, 2
	ctx.r[10].u64 = ctx.r[10].u64 | 2;
	// 830E9000: 914B00F0  stw r10, 0xf0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(240 as u32), ctx.r[10].u32 ) };
	// 830E9004: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E9008(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830E9008 size=36
    let mut pc: u32 = 0x830E9008;
    'dispatch: loop {
        match pc {
            0x830E9008 => {
    //   block [0x830E9008..0x830E902C)
	// 830E9008: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 830E900C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E9010: C00B0058  lfs f0, 0x58(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E9014: D0040000  stfs f0, 0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830E9018: C00B005C  lfs f0, 0x5c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E901C: D0040004  stfs f0, 4(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830E9020: C00B0060  lfs f0, 0x60(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E9024: D0040008  stfs f0, 8(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 830E9028: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E9030(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830E9030 size=48
    let mut pc: u32 = 0x830E9030;
    'dispatch: loop {
        match pc {
            0x830E9030 => {
    //   block [0x830E9030..0x830E9060)
	// 830E9030: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 830E9034: C0040000  lfs f0, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E9038: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E903C: D00B0058  stfs f0, 0x58(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 830E9040: C0040004  lfs f0, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E9044: D00B005C  stfs f0, 0x5c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 830E9048: C0040008  lfs f0, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E904C: D00B0060  stfs f0, 0x60(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 830E9050: 814B00F0  lwz r10, 0xf0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(240 as u32) ) } as u64;
	// 830E9054: 614A0002  ori r10, r10, 2
	ctx.r[10].u64 = ctx.r[10].u64 | 2;
	// 830E9058: 914B00F0  stw r10, 0xf0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(240 as u32), ctx.r[10].u32 ) };
	// 830E905C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E9060(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E9060 size=568
    let mut pc: u32 = 0x830E9060;
    'dispatch: loop {
        match pc {
            0x830E9060 => {
    //   block [0x830E9060..0x830E9298)
	// 830E9060: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E9064: 480BF0FD  bl 0x831a8160
	ctx.lr = 0x830E9068;
	sub_831A8130(ctx, base);
	// 830E9068: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E906C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E9070: 81640010  lwz r11, 0x10(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 830E9074: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830E9078: 91440008  stw r10, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830E907C: 815F00F0  lwz r10, 0xf0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 830E9080: 554A07FE  clrlwi r10, r10, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 830E9084: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 830E9088: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 830E908C: 419A0010  beq cr6, 0x830e909c
	if ctx.cr[6].eq {
	pc = 0x830E909C; continue 'dispatch;
	}
	// 830E9090: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830E9094: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830E9098: 480001F4  b 0x830e928c
	pc = 0x830E928C; continue 'dispatch;
	// 830E909C: 38A10064  addi r5, r1, 0x64
	ctx.r[5].s64 = ctx.r[1].s64 + 100;
	// 830E90A0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E90A4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830E90A8: 4BFFE761  bl 0x830e7808
	ctx.lr = 0x830E90AC;
	sub_830E7808(ctx, base);
	// 830E90AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E90B0: 4BFFFB91  bl 0x830e8c40
	ctx.lr = 0x830E90B4;
	sub_830E8C40(ctx, base);
	// 830E90B4: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 830E90B8: 39400008  li r10, 8
	ctx.r[10].s64 = 8;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E9298(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E9298 size=116
    let mut pc: u32 = 0x830E9298;
    'dispatch: loop {
        match pc {
            0x830E9298 => {
    //   block [0x830E9298..0x830E930C)
	// 830E9298: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E929C: 480BEED1  bl 0x831a816c
	ctx.lr = 0x830E92A0;
	sub_831A8130(ctx, base);
	// 830E92A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E92A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E92A8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830E92AC: 807F00E4  lwz r3, 0xe4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 830E92B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830E92B4: 419A0008  beq cr6, 0x830e92bc
	if ctx.cr[6].eq {
	pc = 0x830E92BC; continue 'dispatch;
	}
	// 830E92B8: 48016529  bl 0x830ff7e0
	ctx.lr = 0x830E92BC;
	sub_830FF7E0(ctx, base);
	// 830E92BC: 83DF00E4  lwz r30, 0xe4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 830E92C0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830E92C4: 419A0014  beq cr6, 0x830e92d8
	if ctx.cr[6].eq {
	pc = 0x830E92D8; continue 'dispatch;
	}
	// 830E92C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E92CC: 48016B3D  bl 0x830ffe08
	ctx.lr = 0x830E92D0;
	sub_830FFE08(ctx, base);
	// 830E92D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E92D4: 4BFF4205  bl 0x830dd4d8
	ctx.lr = 0x830E92D8;
	sub_830DD4D8(ctx, base);
	// 830E92D8: 93BF00E4  stw r29, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[29].u32 ) };
	// 830E92DC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 830E92E0: 419A0020  beq cr6, 0x830e9300
	if ctx.cr[6].eq {
	pc = 0x830E9300; continue 'dispatch;
	}
	// 830E92E4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E92E8: 4BFE5929  bl 0x830cec10
	ctx.lr = 0x830E92EC;
	sub_830CEC10(ctx, base);
	// 830E92EC: 817F00E4  lwz r11, 0xe4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 830E92F0: 906B0000  stw r3, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 830E92F4: 807F00E4  lwz r3, 0xe4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 830E92F8: 48016981  bl 0x830ffc78
	ctx.lr = 0x830E92FC;
	sub_830FFC78(ctx, base);
	// 830E92FC: 48000008  b 0x830e9304
	pc = 0x830E9304; continue 'dispatch;
	// 830E9300: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E9304: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E9308: 480BEEB4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E9310(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E9310 size=184
    let mut pc: u32 = 0x830E9310;
    'dispatch: loop {
        match pc {
            0x830E9310 => {
    //   block [0x830E9310..0x830E93C8)
	// 830E9310: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E9314: 480BEE55  bl 0x831a8168
	ctx.lr = 0x830E9318;
	sub_831A8130(ctx, base);
	// 830E9318: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E931C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830E9320: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830E9324: 807D00E4  lwz r3, 0xe4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(228 as u32) ) } as u64;
	// 830E9328: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830E932C: 419A0008  beq cr6, 0x830e9334
	if ctx.cr[6].eq {
	pc = 0x830E9334; continue 'dispatch;
	}
	// 830E9330: 48015DB9  bl 0x830ff0e8
	ctx.lr = 0x830E9334;
	sub_830FF0E8(ctx, base);
	// 830E9334: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830E9338: 419A0084  beq cr6, 0x830e93bc
	if ctx.cr[6].eq {
	pc = 0x830E93BC; continue 'dispatch;
	}
	// 830E933C: 817D00F0  lwz r11, 0xf0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(240 as u32) ) } as u64;
	// 830E9340: 556A0738  rlwinm r10, r11, 0, 0x1c, 0x1c
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830E9344: 2B0A0008  cmplwi cr6, r10, 8
	ctx.cr[6].compare_u32(ctx.r[10].u32, 8 as u32, &mut ctx.xer);
	// 830E9348: 419A0074  beq cr6, 0x830e93bc
	if ctx.cr[6].eq {
	pc = 0x830E93BC; continue 'dispatch;
	}
	// 830E934C: 556B0630  rlwinm r11, r11, 0, 0x18, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830E9350: 2B0B0080  cmplwi cr6, r11, 0x80
	ctx.cr[6].compare_u32(ctx.r[11].u32, 128 as u32, &mut ctx.xer);
	// 830E9354: 419A0068  beq cr6, 0x830e93bc
	if ctx.cr[6].eq {
	pc = 0x830E93BC; continue 'dispatch;
	}
	// 830E9358: 83FD0018  lwz r31, 0x18(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 830E935C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830E9360: 419A003C  beq cr6, 0x830e939c
	if ctx.cr[6].eq {
	pc = 0x830E939C; continue 'dispatch;
	}
	// 830E9364: 3F808339  lis r28, -0x7cc7
	ctx.r[28].s64 = -2093416448;
	// 830E9368: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E936C: 83DCC07C  lwz r30, -0x3f84(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-16260 as u32) ) } as u64;
	// 830E9370: 4BFE58A1  bl 0x830cec10
	ctx.lr = 0x830E9374;
	sub_830CEC10(ctx, base);
	// 830E9374: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830E9378: 4BFE5779  bl 0x830ceaf0
	ctx.lr = 0x830E937C;
	sub_830CEAF0(ctx, base);
	// 830E937C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E9380: 40820010  bne 0x830e9390
	if !ctx.cr[0].eq {
	pc = 0x830E9390; continue 'dispatch;
	}
	// 830E9384: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830E9388: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E938C: 4BFFFF85  bl 0x830e9310
	ctx.lr = 0x830E9390;
	sub_830E9310(ctx, base);
	// 830E9390: 83FF0020  lwz r31, 0x20(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 830E9394: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830E9398: 409AFFD0  bne cr6, 0x830e9368
	if !ctx.cr[6].eq {
	pc = 0x830E9368; continue 'dispatch;
	}
	// 830E939C: 83FD002C  lwz r31, 0x2c(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(44 as u32) ) } as u64;
	// 830E93A0: 48000014  b 0x830e93b4
	pc = 0x830E93B4; continue 'dispatch;
	// 830E93A4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830E93A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E93AC: 4BFFFF65  bl 0x830e9310
	ctx.lr = 0x830E93B0;
	sub_830E9310(ctx, base);
	// 830E93B0: 83FF0020  lwz r31, 0x20(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 830E93B4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830E93B8: 409AFFEC  bne cr6, 0x830e93a4
	if !ctx.cr[6].eq {
	pc = 0x830E93A4; continue 'dispatch;
	}
	// 830E93BC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E93C0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830E93C4: 480BEDF4  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E93C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E93C8 size=252
    let mut pc: u32 = 0x830E93C8;
    'dispatch: loop {
        match pc {
            0x830E93C8 => {
    //   block [0x830E93C8..0x830E94C4)
	// 830E93C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E93CC: 480BED8D  bl 0x831a8158
	ctx.lr = 0x830E93D0;
	sub_831A8130(ctx, base);
	// 830E93D0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E93D4: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 830E93D8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830E93DC: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 830E93E0: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 830E93E4: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 830E93E8: 807900E4  lwz r3, 0xe4(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(228 as u32) ) } as u64;
	// 830E93EC: 7D1F4378  mr r31, r8
	ctx.r[31].u64 = ctx.r[8].u64;
	// 830E93F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830E93F4: 419A001C  beq cr6, 0x830e9410
	if ctx.cr[6].eq {
	pc = 0x830E9410; continue 'dispatch;
	}
	// 830E93F8: 817900F0  lwz r11, 0xf0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(240 as u32) ) } as u64;
	// 830E93FC: 556B04A4  rlwinm r11, r11, 0, 0x12, 0x12
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830E9400: 2B0B2000  cmplwi cr6, r11, 0x2000
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8192 as u32, &mut ctx.xer);
	// 830E9404: 419A000C  beq cr6, 0x830e9410
	if ctx.cr[6].eq {
	pc = 0x830E9410; continue 'dispatch;
	}
	// 830E9408: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 830E940C: 48015CED  bl 0x830ff0f8
	ctx.lr = 0x830E9410;
	sub_830FF0F8(ctx, base);
	// 830E9410: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830E9414: 419A00A4  beq cr6, 0x830e94b8
	if ctx.cr[6].eq {
	pc = 0x830E94B8; continue 'dispatch;
	}
	// 830E9418: 817900F0  lwz r11, 0xf0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(240 as u32) ) } as u64;
	// 830E941C: 556A0738  rlwinm r10, r11, 0, 0x1c, 0x1c
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830E9420: 2B0A0008  cmplwi cr6, r10, 8
	ctx.cr[6].compare_u32(ctx.r[10].u32, 8 as u32, &mut ctx.xer);
	// 830E9424: 419A0094  beq cr6, 0x830e94b8
	if ctx.cr[6].eq {
	pc = 0x830E94B8; continue 'dispatch;
	}
	// 830E9428: 556B0630  rlwinm r11, r11, 0, 0x18, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830E942C: 2B0B0080  cmplwi cr6, r11, 0x80
	ctx.cr[6].compare_u32(ctx.r[11].u32, 128 as u32, &mut ctx.xer);
	// 830E9430: 419A0088  beq cr6, 0x830e94b8
	if ctx.cr[6].eq {
	pc = 0x830E94B8; continue 'dispatch;
	}
	// 830E9434: 83F90018  lwz r31, 0x18(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(24 as u32) ) } as u64;
	// 830E9438: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830E943C: 419A004C  beq cr6, 0x830e9488
	if ctx.cr[6].eq {
	pc = 0x830E9488; continue 'dispatch;
	}
	// 830E9440: 3F008339  lis r24, -0x7cc7
	ctx.r[24].s64 = -2093416448;
	// 830E9444: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E9448: 8358C07C  lwz r26, -0x3f84(r24)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-16260 as u32) ) } as u64;
	// 830E944C: 4BFE57C5  bl 0x830cec10
	ctx.lr = 0x830E9450;
	sub_830CEC10(ctx, base);
	// 830E9450: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 830E9454: 4BFE569D  bl 0x830ceaf0
	ctx.lr = 0x830E9458;
	sub_830CEAF0(ctx, base);
	// 830E9458: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E945C: 40820020  bne 0x830e947c
	if !ctx.cr[0].eq {
	pc = 0x830E947C; continue 'dispatch;
	}
	// 830E9460: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 830E9464: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 830E9468: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 830E946C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830E9470: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830E9474: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E9478: 4BFFFF51  bl 0x830e93c8
	ctx.lr = 0x830E947C;
	sub_830E93C8(ctx, base);
	// 830E947C: 83FF0020  lwz r31, 0x20(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 830E9480: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830E9484: 409AFFC0  bne cr6, 0x830e9444
	if !ctx.cr[6].eq {
	pc = 0x830E9444; continue 'dispatch;
	}
	// 830E9488: 83F9002C  lwz r31, 0x2c(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(44 as u32) ) } as u64;
	// 830E948C: 48000024  b 0x830e94b0
	pc = 0x830E94B0; continue 'dispatch;
	// 830E9490: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 830E9494: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 830E9498: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 830E949C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830E94A0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830E94A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E94A8: 4BFFFF21  bl 0x830e93c8
	ctx.lr = 0x830E94AC;
	sub_830E93C8(ctx, base);
	// 830E94AC: 83FF0020  lwz r31, 0x20(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 830E94B0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830E94B4: 409AFFDC  bne cr6, 0x830e9490
	if !ctx.cr[6].eq {
	pc = 0x830E9490; continue 'dispatch;
	}
	// 830E94B8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E94BC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830E94C0: 480BECE8  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E94C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830E94C8 size=140
    let mut pc: u32 = 0x830E94C8;
    'dispatch: loop {
        match pc {
            0x830E94C8 => {
    //   block [0x830E94C8..0x830E9554)
	// 830E94C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E94CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E94D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E94D4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E94D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E94DC: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 830E94E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830E94E4: 419A0014  beq cr6, 0x830e94f8
	if ctx.cr[6].eq {
	pc = 0x830E94F8; continue 'dispatch;
	}
	// 830E94E8: 814B00F0  lwz r10, 0xf0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(240 as u32) ) } as u64;
	// 830E94EC: 554A06F6  rlwinm r10, r10, 0, 0x1b, 0x1b
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 830E94F0: 2B0A0010  cmplwi cr6, r10, 0x10
	ctx.cr[6].compare_u32(ctx.r[10].u32, 16 as u32, &mut ctx.xer);
	// 830E94F4: 419A004C  beq cr6, 0x830e9540
	if ctx.cr[6].eq {
	pc = 0x830E9540; continue 'dispatch;
	}
	// 830E94F8: D03F0104  stfs f1, 0x104(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 830E94FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830E9500: D05F0108  stfs f2, 0x108(r31)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 830E9504: 419A0014  beq cr6, 0x830e9518
	if ctx.cr[6].eq {
	pc = 0x830E9518; continue 'dispatch;
	}
	// 830E9508: 38BF0110  addi r5, r31, 0x110
	ctx.r[5].s64 = ctx.r[31].s64 + 272;
	// 830E950C: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E9510: 389F010C  addi r4, r31, 0x10c
	ctx.r[4].s64 = ctx.r[31].s64 + 268;
	// 830E9514: 4BFFE2F5  bl 0x830e7808
	ctx.lr = 0x830E9518;
	sub_830E7808(ctx, base);
	// 830E9518: C01F0030  lfs f0, 0x30(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E951C: D01F00F8  stfs f0, 0xf8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 830E9520: C01F0034  lfs f0, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E9524: D01F00FC  stfs f0, 0xfc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 830E9528: C01F0038  lfs f0, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E952C: D01F0100  stfs f0, 0x100(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 830E9530: C01F003C  lfs f0, 0x3c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E9534: C1BF0040  lfs f13, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830E9538: D01F0114  stfs f0, 0x114(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 830E953C: D1BF0118  stfs f13, 0x118(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), tmp.u32 ) };
	// 830E9540: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830E9544: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E9548: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E954C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E9550: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E9558(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830E9558 size=28
    let mut pc: u32 = 0x830E9558;
    'dispatch: loop {
        match pc {
            0x830E9558 => {
    //   block [0x830E9558..0x830E9574)
	// 830E9558: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 830E955C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E9560: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E9564: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E9568: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 830E956C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E9570: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E9574(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830E9574 size=148
    let mut pc: u32 = 0x830E9574;
    'dispatch: loop {
        match pc {
            0x830E9574 => {
    //   block [0x830E9574..0x830E9608)
	// 830E9574: 55471838  slwi r7, r10, 3
	ctx.r[7].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 830E9578: C0040004  lfs f0, 4(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E957C: 39480004  addi r10, r8, 4
	ctx.r[10].s64 = ctx.r[8].s64 + 4;
	// 830E9580: 20C8FFFC  subfic r6, r8, -4
	ctx.xer.ca = ctx.r[8].u32 <= -4 as u32;
	ctx.r[6].s64 = (-4 as i64) - ctx.r[8].s64;
	// 830E9584: C1AA0000  lfs f13, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830E9588: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 830E958C: 41990014  bgt cr6, 0x830e95a0
	if ctx.cr[6].gt {
	pc = 0x830E95A0; continue 'dispatch;
	}
	// 830E9590: 7D274214  add r9, r7, r8
	ctx.r[9].u64 = ctx.r[7].u64 + ctx.r[8].u64;
	// 830E9594: C1890004  lfs f12, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830E9598: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 830E959C: 4198001C  blt cr6, 0x830e95b8
	if ctx.cr[6].lt {
	pc = 0x830E95B8; continue 'dispatch;
	}
	// 830E95A0: 7D274214  add r9, r7, r8
	ctx.r[9].u64 = ctx.r[7].u64 + ctx.r[8].u64;
	// 830E95A4: C1890004  lfs f12, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830E95A8: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 830E95AC: 41990048  bgt cr6, 0x830e95f4
	if ctx.cr[6].gt {
	pc = 0x830E95F4; continue 'dispatch;
	}
	// 830E95B0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830E95B4: 40980040  bge cr6, 0x830e95f4
	if !ctx.cr[6].lt {
	pc = 0x830E95F4; continue 'dispatch;
	}
	// 830E95B8: C1AAFFFC  lfs f13, -4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830E95BC: C18A0000  lfs f12, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830E95C0: C1690000  lfs f11, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830E95C4: ED406028  fsubs f10, f0, f12
	ctx.f[10].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 830E95C8: ED6B6828  fsubs f11, f11, f13
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[13].f64) as f32) as f64);
	// 830E95CC: C1290004  lfs f9, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 830E95D0: ED896028  fsubs f12, f9, f12
	ctx.f[12].f64 = (((ctx.f[9].f64 - ctx.f[12].f64) as f32) as f64);
	// 830E95D4: C1240000  lfs f9, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 830E95D8: ED6A02F2  fmuls f11, f10, f11
	ctx.f[11].f64 = (((ctx.f[10].f64 * ctx.f[11].f64) as f32) as f64);
	// 830E95DC: ED8B6024  fdivs f12, f11, f12
	ctx.f[12].f64 = ((ctx.f[11].f64 / ctx.f[12].f64) as f32) as f64;
	// 830E95E0: EDAC682A  fadds f13, f12, f13
	ctx.f[13].f64 = ((ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64;
	// 830E95E4: FF096800  fcmpu cr6, f9, f13
	ctx.cr[6].compare_f64(ctx.f[9].f64, ctx.f[13].f64);
	// 830E95E8: 4098000C  bge cr6, 0x830e95f4
	if !ctx.cr[6].lt {
	pc = 0x830E95F4; continue 'dispatch;
	}
	// 830E95EC: 7C690034  cntlzw r9, r3
	ctx.r[9].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 830E95F0: 5523DFFE  rlwinm r3, r9, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 830E95F4: 7CE65214  add r7, r6, r10
	ctx.r[7].u64 = ctx.r[6].u64 + ctx.r[10].u64;
	// 830E95F8: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E95FC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 830E9600: 4082FF84  bne 0x830e9584
	if !ctx.cr[0].eq {
	pc = 0x830E9584; continue 'dispatch;
	}
	// 830E9604: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E9608(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830E9608 size=96
    let mut pc: u32 = 0x830E9608;
    'dispatch: loop {
        match pc {
            0x830E9608 => {
    //   block [0x830E9608..0x830E9668)
	// 830E9608: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 830E960C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E9610: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E9614: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830E9618: 40990060  ble cr6, 0x830e9678
	if !ctx.cr[6].gt {
		sub_830E9668(ctx, base);
		return;
	}
	// 830E961C: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 830E9620: C1440000  lfs f10, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 830E9624: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E9628: C009A1C4  lfs f0, -0x5e3c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E962C: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830E9630: ED2D0028  fsubs f9, f13, f0
	ctx.f[9].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 830E9634: C16B0004  lfs f11, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830E9638: ED8B0028  fsubs f12, f11, f0
	ctx.f[12].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 830E963C: EDAD002A  fadds f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 830E9640: ED6B002A  fadds f11, f11, f0
	ctx.f[11].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 830E9644: FF0A4800  fcmpu cr6, f10, f9
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[9].f64);
	// 830E9648: 41980020  blt cr6, 0x830e9668
	if ctx.cr[6].lt {
		sub_830E9668(ctx, base);
		return;
	}
	// 830E964C: FF0A6800  fcmpu cr6, f10, f13
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[13].f64);
	// 830E9650: 41990018  bgt cr6, 0x830e9668
	if ctx.cr[6].gt {
		sub_830E9668(ctx, base);
		return;
	}
	// 830E9654: C1A40004  lfs f13, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830E9658: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 830E965C: 4198000C  blt cr6, 0x830e9668
	if ctx.cr[6].lt {
		sub_830E9668(ctx, base);
		return;
	}
	// 830E9660: FF0D5800  fcmpu cr6, f13, f11
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[11].f64);
	// 830E9664: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E9668(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830E9668 size=24
    let mut pc: u32 = 0x830E9668;
    'dispatch: loop {
        match pc {
            0x830E9668 => {
    //   block [0x830E9668..0x830E9680)
	// 830E9668: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	// 830E966C: 396B001C  addi r11, r11, 0x1c
	ctx.r[11].s64 = ctx.r[11].s64 + 28;
	// 830E9670: 7F035000  cmpw cr6, r3, r10
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830E9674: 4198FFB8  blt cr6, 0x830e962c
	if ctx.cr[6].lt {
		sub_830E9608(ctx, base);
		return;
	}
	// 830E9678: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 830E967C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E9680(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830E9680 size=348
    let mut pc: u32 = 0x830E9680;
    'dispatch: loop {
        match pc {
            0x830E9680 => {
    //   block [0x830E9680..0x830E97DC)
	// 830E9680: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E9684: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E9688: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830E968C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E9690: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 830E9694: 480BF3E1  bl 0x831a8a74
	ctx.lr = 0x830E9698;
	sub_831A8A40(ctx, base);
	// 830E9698: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E969C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E96A0: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 830E96A4: FFA01090  fmr f29, f2
	ctx.f[29].f64 = ctx.f[2].f64;
	// 830E96A8: FF801890  fmr f28, f3
	ctx.f[28].f64 = ctx.f[3].f64;
	// 830E96AC: FF602090  fmr f27, f4
	ctx.f[27].f64 = ctx.f[4].f64;
	// 830E96B0: 817F0084  lwz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 830E96B4: 556B07BC  rlwinm r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830E96B8: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 830E96BC: 409A0100  bne cr6, 0x830e97bc
	if !ctx.cr[6].eq {
	pc = 0x830E97BC; continue 'dispatch;
	}
	// 830E96C0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 830E96C4: C1BF0040  lfs f13, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830E96C8: 3BDF0044  addi r30, r31, 0x44
	ctx.r[30].s64 = ctx.r[31].s64 + 68;
	// 830E96CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E96D0: C00BCEE4  lfs f0, -0x311c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12572 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E96D4: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 830E96D8: 4802EC69  bl 0x83118340
	ctx.lr = 0x830E96DC;
	sub_83118340(ctx, base);
	// 830E96DC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830E96E0: C01F0038  lfs f0, 0x38(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E96E4: C1BF0034  lfs f13, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830E96E8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 830E96EC: EC40D824  fdivs f2, f0, f27
	ctx.f[2].f64 = ((ctx.f[0].f64 / ctx.f[27].f64) as f32) as f64;
	// 830E96F0: EC2DE024  fdivs f1, f13, f28
	ctx.f[1].f64 = ((ctx.f[13].f64 / ctx.f[28].f64) as f32) as f64;
	// 830E96F4: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 830E96F8: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 830E96FC: 4802E5DD  bl 0x83117cd8
	ctx.lr = 0x830E9700;
	sub_83117CD8(ctx, base);
	// 830E9700: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830E9704: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E9708: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 830E970C: 4802E6D5  bl 0x83117de0
	ctx.lr = 0x830E9710;
	sub_83117DE0(ctx, base);
	// 830E9710: D3C10050  stfs f30, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 830E9714: D3E10054  stfs f31, 0x54(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 830E9718: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830E971C: D3C10058  stfs f30, 0x58(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 830E9720: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E9724: D3A1005C  stfs f29, 0x5c(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 830E9728: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830E972C: D3E10060  stfs f31, 0x60(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 830E9730: D3A10064  stfs f29, 0x64(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 830E9734: 4802E4F5  bl 0x83117c28
	ctx.lr = 0x830E9738;
	sub_83117C28(ctx, base);
	// 830E9738: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830E973C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830E9740: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 830E9744: 4802E4E5  bl 0x83117c28
	ctx.lr = 0x830E9748;
	sub_83117C28(ctx, base);
	// 830E9748: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830E974C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830E9750: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 830E9754: 4802E4D5  bl 0x83117c28
	ctx.lr = 0x830E9758;
	sub_83117C28(ctx, base);
	// 830E9758: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 830E975C: C1810068  lfs f12, 0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830E9760: C161006C  lfs f11, 0x6c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830E9764: C1BF0028  lfs f13, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830E9768: C1410070  lfs f10, 0x70(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 830E976C: C00B9450  lfs f0, -0x6bb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E9770: ED4A0372  fmuls f10, f10, f13
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 830E9774: ED8C003C  fnmsubs f12, f12, f0, f0
	ctx.f[12].f64 = -(((ctx.f[12].f64 * ctx.f[0].f64 - ctx.f[0].f64) as f32) as f64);
	// 830E9778: C1210078  lfs f9, 0x78(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 830E977C: EC0B003C  fnmsubs f0, f11, f0, f0
	ctx.f[0].f64 = -(((ctx.f[11].f64 * ctx.f[0].f64 - ctx.f[0].f64) as f32) as f64);
	// 830E9780: C101007C  lfs f8, 0x7c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 830E9784: ED8A602A  fadds f12, f10, f12
	ctx.f[12].f64 = ((ctx.f[10].f64 + ctx.f[12].f64) as f32) as f64;
	// 830E9788: C1610074  lfs f11, 0x74(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830E978C: 817F0084  lwz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 830E9790: EDAB0372  fmuls f13, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 830E9794: C17F002C  lfs f11, 0x2c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830E9798: ED2902F2  fmuls f9, f9, f11
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[11].f64) as f32) as f64);
	// 830E979C: 556B07FA  rlwinm r11, r11, 0, 0x1f, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830E97A0: ED6802F2  fmuls f11, f8, f11
	ctx.f[11].f64 = (((ctx.f[8].f64 * ctx.f[11].f64) as f32) as f64);
	// 830E97A4: 917F0084  stw r11, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 830E97A8: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 830E97AC: EDA9602A  fadds f13, f9, f12
	ctx.f[13].f64 = ((ctx.f[9].f64 + ctx.f[12].f64) as f32) as f64;
	// 830E97B0: D1BF0074  stfs f13, 0x74(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 830E97B4: EC0B002A  fadds f0, f11, f0
	ctx.f[0].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 830E97B8: D01F0078  stfs f0, 0x78(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 830E97BC: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 830E97C0: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 830E97C4: 480BF2FD  bl 0x831a8ac0
	ctx.lr = 0x830E97C8;
	sub_831A8A8C(ctx, base);
	// 830E97C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E97CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E97D0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830E97D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E97D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E97E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830E97E0 size=268
    let mut pc: u32 = 0x830E97E0;
    'dispatch: loop {
        match pc {
            0x830E97E0 => {
    //   block [0x830E97E0..0x830E98EC)
	// 830E97E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E97E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E97E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830E97EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E97F0: DBA1FFD0  stfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[29].u64 ) };
	// 830E97F4: DBC1FFD8  stfd f30, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 830E97F8: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 830E97FC: 9421FEC0  stwu r1, -0x140(r1)
	ea = ctx.r[1].u32.wrapping_add(-320 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E9800: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E9804: FFC00890  fmr f30, f1
	ctx.f[30].f64 = ctx.f[1].f64;
	// 830E9808: FFA01090  fmr f29, f2
	ctx.f[29].f64 = ctx.f[2].f64;
	// 830E980C: 817F0084  lwz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 830E9810: 556B07BC  rlwinm r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830E9814: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 830E9818: 409A00B0  bne cr6, 0x830e98c8
	if !ctx.cr[6].eq {
	pc = 0x830E98C8; continue 'dispatch;
	}
	// 830E981C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 830E9820: C1BF0040  lfs f13, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830E9824: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 830E9828: C00BCEE4  lfs f0, -0x311c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12572 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E982C: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 830E9830: 4802EB11  bl 0x83118340
	ctx.lr = 0x830E9834;
	sub_83118340(ctx, base);
	// 830E9834: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 830E9838: C07F003C  lfs f3, 0x3c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 830E983C: C05F0038  lfs f2, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 830E9840: C03F0034  lfs f1, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830E9844: 4802E495  bl 0x83117cd8
	ctx.lr = 0x830E9848;
	sub_83117CD8(ctx, base);
	// 830E9848: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830E984C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 830E9850: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830E9854: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 830E9858: C00A9530  lfs f0, -0x6ad0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27344 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E985C: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 830E9860: EC5D0032  fmuls f2, f29, f0
	ctx.f[2].f64 = (((ctx.f[29].f64 * ctx.f[0].f64) as f32) as f64);
	// 830E9864: EC3E0032  fmuls f1, f30, f0
	ctx.f[1].f64 = (((ctx.f[30].f64 * ctx.f[0].f64) as f32) as f64);
	// 830E9868: 4802E4E9  bl 0x83117d50
	ctx.lr = 0x830E986C;
	sub_83117D50(ctx, base);
	// 830E986C: 3BDF0044  addi r30, r31, 0x44
	ctx.r[30].s64 = ctx.r[31].s64 + 68;
	// 830E9870: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 830E9874: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E9878: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E987C: 4802E565  bl 0x83117de0
	ctx.lr = 0x830E9880;
	sub_83117DE0(ctx, base);
	// 830E9880: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830E9884: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E9888: 38A100D0  addi r5, r1, 0xd0
	ctx.r[5].s64 = ctx.r[1].s64 + 208;
	// 830E988C: 4802E555  bl 0x83117de0
	ctx.lr = 0x830E9890;
	sub_83117DE0(ctx, base);
	// 830E9890: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 830E9894: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830E9898: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 830E989C: C00B9450  lfs f0, -0x6bb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E98A0: EC5D0032  fmuls f2, f29, f0
	ctx.f[2].f64 = (((ctx.f[29].f64 * ctx.f[0].f64) as f32) as f64);
	// 830E98A4: EC3E0032  fmuls f1, f30, f0
	ctx.f[1].f64 = (((ctx.f[30].f64 * ctx.f[0].f64) as f32) as f64);
	// 830E98A8: 4802E4A9  bl 0x83117d50
	ctx.lr = 0x830E98AC;
	sub_83117D50(ctx, base);
	// 830E98AC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830E98B0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830E98B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E98B8: 4802E529  bl 0x83117de0
	ctx.lr = 0x830E98BC;
	sub_83117DE0(ctx, base);
	// 830E98BC: 817F0084  lwz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 830E98C0: 556B07FA  rlwinm r11, r11, 0, 0x1f, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830E98C4: 917F0084  stw r11, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 830E98C8: 38210140  addi r1, r1, 0x140
	ctx.r[1].s64 = ctx.r[1].s64 + 320;
	// 830E98CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E98D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E98D4: CBA1FFD0  lfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 830E98D8: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 830E98DC: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 830E98E0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830E98E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E98E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E98F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830E98F0 size=292
    let mut pc: u32 = 0x830E98F0;
    'dispatch: loop {
        match pc {
            0x830E98F0 => {
    //   block [0x830E98F0..0x830E9A14)
	// 830E98F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E98F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E98F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830E98FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E9900: DBC1FFD8  stfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 830E9904: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 830E9908: 9421FE80  stwu r1, -0x180(r1)
	ea = ctx.r[1].u32.wrapping_add(-384 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E990C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830E9910: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 830E9914: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 830E9918: 817E0084  lwz r11, 0x84(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(132 as u32) ) } as u64;
	// 830E991C: 556B07BC  rlwinm r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830E9920: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 830E9924: 409A00D0  bne cr6, 0x830e99f4
	if !ctx.cr[6].eq {
	pc = 0x830E99F4; continue 'dispatch;
	}
	// 830E9928: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 830E992C: C1BE0040  lfs f13, 0x40(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830E9930: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 830E9934: C00BCEE4  lfs f0, -0x311c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12572 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E9938: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 830E993C: 4802EA05  bl 0x83118340
	ctx.lr = 0x830E9940;
	sub_83118340(ctx, base);
	// 830E9940: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830E9944: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 830E9948: C06B08A8  lfs f3, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 830E994C: EC43F024  fdivs f2, f3, f30
	ctx.f[2].f64 = ((ctx.f[3].f64 / ctx.f[30].f64) as f32) as f64;
	// 830E9950: EC23F824  fdivs f1, f3, f31
	ctx.f[1].f64 = ((ctx.f[3].f64 / ctx.f[31].f64) as f32) as f64;
	// 830E9954: 4802E385  bl 0x83117cd8
	ctx.lr = 0x830E9958;
	sub_83117CD8(ctx, base);
	// 830E9958: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 830E995C: C07E003C  lfs f3, 0x3c(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 830E9960: C05E0038  lfs f2, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 830E9964: C03E0034  lfs f1, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830E9968: 4802E371  bl 0x83117cd8
	ctx.lr = 0x830E996C;
	sub_83117CD8(ctx, base);
	// 830E996C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 830E9970: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 830E9974: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830E9978: C04B9530  lfs f2, -0x6ad0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27344 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 830E997C: C3EA08A4  lfs f31, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 830E9980: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 830E9984: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 830E9988: 4802E3C9  bl 0x83117d50
	ctx.lr = 0x830E998C;
	sub_83117D50(ctx, base);
	// 830E998C: 3BFE0044  addi r31, r30, 0x44
	ctx.r[31].s64 = ctx.r[30].s64 + 68;
	// 830E9990: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830E9994: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E9998: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 830E999C: 4802E445  bl 0x83117de0
	ctx.lr = 0x830E99A0;
	sub_83117DE0(ctx, base);
	// 830E99A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E99A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E99A8: 38A100D0  addi r5, r1, 0xd0
	ctx.r[5].s64 = ctx.r[1].s64 + 208;
	// 830E99AC: 4802E435  bl 0x83117de0
	ctx.lr = 0x830E99B0;
	sub_83117DE0(ctx, base);
	// 830E99B0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E99B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E99B8: 38A10110  addi r5, r1, 0x110
	ctx.r[5].s64 = ctx.r[1].s64 + 272;
	// 830E99BC: 4802E425  bl 0x83117de0
	ctx.lr = 0x830E99C0;
	sub_83117DE0(ctx, base);
	// 830E99C0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 830E99C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830E99C8: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 830E99CC: C04B9450  lfs f2, -0x6bb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 830E99D0: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 830E99D4: 4802E37D  bl 0x83117d50
	ctx.lr = 0x830E99D8;
	sub_83117D50(ctx, base);
	// 830E99D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E99DC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830E99E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E99E4: 4802E3FD  bl 0x83117de0
	ctx.lr = 0x830E99E8;
	sub_83117DE0(ctx, base);
	// 830E99E8: 817E0084  lwz r11, 0x84(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(132 as u32) ) } as u64;
	// 830E99EC: 556B07FA  rlwinm r11, r11, 0, 0x1f, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830E99F0: 917E0084  stw r11, 0x84(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 830E99F4: 38210180  addi r1, r1, 0x180
	ctx.r[1].s64 = ctx.r[1].s64 + 384;
	// 830E99F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E99FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E9A00: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 830E9A04: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 830E9A08: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830E9A0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E9A10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E9A18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E9A18 size=128
    let mut pc: u32 = 0x830E9A18;
    'dispatch: loop {
        match pc {
            0x830E9A18 => {
    //   block [0x830E9A18..0x830E9A98)
	// 830E9A18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E9A1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E9A20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830E9A24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E9A28: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E9A2C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830E9A30: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830E9A34: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830E9A38: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E9A3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E9A40: 4BFF5D19  bl 0x830df758
	ctx.lr = 0x830E9A44;
	sub_830DF758(ctx, base);
	// 830E9A44: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E9A48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830E9A4C: 409A000C  bne cr6, 0x830e9a58
	if !ctx.cr[6].eq {
	pc = 0x830E9A58; continue 'dispatch;
	}
	// 830E9A50: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E9A54: 4800002C  b 0x830e9a80
	pc = 0x830E9A80; continue 'dispatch;
	// 830E9A58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E9A5C: 4BFE51B5  bl 0x830cec10
	ctx.lr = 0x830E9A60;
	sub_830CEC10(ctx, base);
	// 830E9A60: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 830E9A64: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830E9A68: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830E9A6C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830E9A70: 4BFFD189  bl 0x830e6bf8
	ctx.lr = 0x830E9A74;
	sub_830E6BF8(ctx, base);
	// 830E9A74: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 830E9A78: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E9A7C: 4BFEC2DD  bl 0x830d5d58
	ctx.lr = 0x830E9A80;
	sub_830D5D58(ctx, base);
	// 830E9A80: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830E9A84: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E9A88: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E9A8C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830E9A90: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E9A94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E9A98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E9A98 size=120
    let mut pc: u32 = 0x830E9A98;
    'dispatch: loop {
        match pc {
            0x830E9A98 => {
    //   block [0x830E9A98..0x830E9B10)
	// 830E9A98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E9A9C: 480BE6D1  bl 0x831a816c
	ctx.lr = 0x830E9AA0;
	sub_831A8130(ctx, base);
	// 830E9AA0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E9AA4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830E9AA8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830E9AAC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830E9AB0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E9AB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E9AB8: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 830E9ABC: 4BFF5C9D  bl 0x830df758
	ctx.lr = 0x830E9AC0;
	sub_830DF758(ctx, base);
	// 830E9AC0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E9AC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830E9AC8: 409A000C  bne cr6, 0x830e9ad4
	if !ctx.cr[6].eq {
	pc = 0x830E9AD4; continue 'dispatch;
	}
	// 830E9ACC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E9AD0: 48000038  b 0x830e9b08
	pc = 0x830E9B08; continue 'dispatch;
	// 830E9AD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E9AD8: 4BFE5139  bl 0x830cec10
	ctx.lr = 0x830E9ADC;
	sub_830CEC10(ctx, base);
	// 830E9ADC: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 830E9AE0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 830E9AE4: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 830E9AE8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 830E9AEC: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 830E9AF0: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 830E9AF4: 4BFFD29D  bl 0x830e6d90
	ctx.lr = 0x830E9AF8;
	sub_830E6D90(ctx, base);
	// 830E9AF8: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 830E9AFC: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E9B00: 4BFEC259  bl 0x830d5d58
	ctx.lr = 0x830E9B04;
	sub_830D5D58(ctx, base);
	// 830E9B04: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 830E9B08: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 830E9B0C: 480BE6B0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E9B10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E9B10 size=132
    let mut pc: u32 = 0x830E9B10;
    'dispatch: loop {
        match pc {
            0x830E9B10 => {
    //   block [0x830E9B10..0x830E9B94)
	// 830E9B10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E9B14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E9B18: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830E9B1C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E9B20: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E9B24: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830E9B28: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830E9B2C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 830E9B30: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 830E9B34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E9B38: 4BFF5C21  bl 0x830df758
	ctx.lr = 0x830E9B3C;
	sub_830DF758(ctx, base);
	// 830E9B3C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830E9B40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830E9B44: 409A000C  bne cr6, 0x830e9b50
	if !ctx.cr[6].eq {
	pc = 0x830E9B50; continue 'dispatch;
	}
	// 830E9B48: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E9B4C: 48000030  b 0x830e9b7c
	pc = 0x830E9B7C; continue 'dispatch;
	// 830E9B50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E9B54: 4BFE50BD  bl 0x830cec10
	ctx.lr = 0x830E9B58;
	sub_830CEC10(ctx, base);
	// 830E9B58: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 830E9B5C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830E9B60: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830E9B64: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830E9B68: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 830E9B6C: 4BFFD1E5  bl 0x830e6d50
	ctx.lr = 0x830E9B70;
	sub_830E6D50(ctx, base);
	// 830E9B70: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 830E9B74: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830E9B78: 4BFEC1E1  bl 0x830d5d58
	ctx.lr = 0x830E9B7C;
	sub_830D5D58(ctx, base);
	// 830E9B7C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830E9B80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E9B84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E9B88: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830E9B8C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E9B90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E9B98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E9B98 size=408
    let mut pc: u32 = 0x830E9B98;
    'dispatch: loop {
        match pc {
            0x830E9B98 => {
    //   block [0x830E9B98..0x830E9D30)
	// 830E9B98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E9B9C: 480BE5C9  bl 0x831a8164
	ctx.lr = 0x830E9BA0;
	sub_831A8130(ctx, base);
	// 830E9BA0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E9BA4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 830E9BA8: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 830E9BAC: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E9BB0: 4BFE5061  bl 0x830cec10
	ctx.lr = 0x830E9BB4;
	sub_830CEC10(ctx, base);
	// 830E9BB4: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 830E9BB8: 83DB0010  lwz r30, 0x10(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 830E9BBC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E9BC0: 93BB0008  stw r29, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 830E9BC4: 4BFF6FDD  bl 0x830e0ba0
	ctx.lr = 0x830E9BC8;
	sub_830E0BA0(ctx, base);
	// 830E9BC8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E9BCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E9BD0: 418200C4  beq 0x830e9c94
	if ctx.cr[0].eq {
	pc = 0x830E9C94; continue 'dispatch;
	}
	// 830E9BD4: 4BFFE16D  bl 0x830e7d40
	ctx.lr = 0x830E9BD8;
	sub_830E7D40(ctx, base);
	// 830E9BD8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E9BDC: 889E0004  lbz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E9BE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E9BE4: 41820010  beq 0x830e9bf4
	if ctx.cr[0].eq {
	pc = 0x830E9BF4; continue 'dispatch;
	}
	// 830E9BE8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830E9BEC: 4BFFFEAD  bl 0x830e9a98
	ctx.lr = 0x830E9BF0;
	sub_830E9A98(ctx, base);
	// 830E9BF0: 48000138  b 0x830e9d28
	pc = 0x830E9D28; continue 'dispatch;
	// 830E9BF4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830E9BF8: 4BFFFEA1  bl 0x830e9a98
	ctx.lr = 0x830E9BFC;
	sub_830E9A98(ctx, base);
	// 830E9BFC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E9C00: 40820128  bne 0x830e9d28
	if !ctx.cr[0].eq {
	pc = 0x830E9D28; continue 'dispatch;
	}
	// 830E9C04: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E9C08: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 830E9C0C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E9C10: 419A0014  beq cr6, 0x830e9c24
	if ctx.cr[6].eq {
	pc = 0x830E9C24; continue 'dispatch;
	}
	// 830E9C14: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830E9C18: 88BE0004  lbz r5, 4(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E9C1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E9C20: 4BFF4FB9  bl 0x830debd8
	ctx.lr = 0x830E9C24;
	sub_830DEBD8(ctx, base);
	// 830E9C24: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830E9C28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E9C2C: 4BFFE15D  bl 0x830e7d88
	ctx.lr = 0x830E9C30;
	sub_830E7D88(ctx, base);
	// 830E9C30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E9C34: 4BFFE225  bl 0x830e7e58
	ctx.lr = 0x830E9C38;
	sub_830E7E58(ctx, base);
	// 830E9C38: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 830E9C3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E9C40: 5564DFFE  rlwinm r4, r11, 0x1b, 0x1f, 0x1f
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830E9C44: 4BFFE25D  bl 0x830e7ea0
	ctx.lr = 0x830E9C48;
	sub_830E7EA0(ctx, base);
	// 830E9C48: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830E9C4C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E9C50: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830E9C54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E9C58: 4BFF7901  bl 0x830e1558
	ctx.lr = 0x830E9C5C;
	sub_830E1558(ctx, base);
	// 830E9C5C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E9C60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E9C64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830E9C68: 409A00B4  bne cr6, 0x830e9d1c
	if !ctx.cr[6].eq {
	pc = 0x830E9D1C; continue 'dispatch;
	}
	// 830E9C6C: 889E0004  lbz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E9C70: 4BFFFEA1  bl 0x830e9b10
	ctx.lr = 0x830E9C74;
	sub_830E9B10(ctx, base);
	// 830E9C74: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830E9C78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E9C7C: 4BFFE10D  bl 0x830e7d88
	ctx.lr = 0x830E9C80;
	sub_830E7D88(ctx, base);
	// 830E9C80: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830E9C84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E9C88: 88BE0004  lbz r5, 4(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E9C8C: 4BFF4F4D  bl 0x830debd8
	ctx.lr = 0x830E9C90;
	sub_830DEBD8(ctx, base);
	// 830E9C90: 48000098  b 0x830e9d28
	pc = 0x830E9D28; continue 'dispatch;
	// 830E9C94: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830E9C98: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E9C9C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830E9CA0: 4BFF78B9  bl 0x830e1558
	ctx.lr = 0x830E9CA4;
	sub_830E1558(ctx, base);
	// 830E9CA4: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E9CA8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830E9CAC: 419A007C  beq cr6, 0x830e9d28
	if ctx.cr[6].eq {
	pc = 0x830E9D28; continue 'dispatch;
	}
	// 830E9CB0: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830E9CB4: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 830E9CB8: 388B8BF4  addi r4, r11, -0x740c
	ctx.r[4].s64 = ctx.r[11].s64 + -29708;
	// 830E9CBC: 4BFF64FD  bl 0x830e01b8
	ctx.lr = 0x830E9CC0;
	sub_830E01B8(ctx, base);
	// 830E9CC0: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830E9CC4: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 830E9CC8: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E9CCC: 388B8BD4  addi r4, r11, -0x742c
	ctx.r[4].s64 = ctx.r[11].s64 + -29740;
	// 830E9CD0: 4BFF64E9  bl 0x830e01b8
	ctx.lr = 0x830E9CD4;
	sub_830E01B8(ctx, base);
	// 830E9CD4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830E9CD8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E9CDC: 4198004C  blt cr6, 0x830e9d28
	if ctx.cr[6].lt {
	pc = 0x830E9D28; continue 'dispatch;
	}
	// 830E9CE0: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830E9CE4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E9CE8: 41980040  blt cr6, 0x830e9d28
	if ctx.cr[6].lt {
	pc = 0x830E9D28; continue 'dispatch;
	}
	// 830E9CEC: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E9CF0: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 830E9CF4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E9CF8: 419A0014  beq cr6, 0x830e9d0c
	if ctx.cr[6].eq {
	pc = 0x830E9D0C; continue 'dispatch;
	}
	// 830E9CFC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830E9D00: 88BE0004  lbz r5, 4(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E9D04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E9D08: 4BFF4ED1  bl 0x830debd8
	ctx.lr = 0x830E9D0C;
	sub_830DEBD8(ctx, base);
	// 830E9D0C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830E9D10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E9D14: 4BFFE075  bl 0x830e7d88
	ctx.lr = 0x830E9D18;
	sub_830E7D88(ctx, base);
	// 830E9D18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E9D1C: 897E0004  lbz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E9D20: 997C0038  stb r11, 0x38(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(56 as u32), ctx.r[11].u8 ) };
	// 830E9D24: 4BFFE0AD  bl 0x830e7dd0
	ctx.lr = 0x830E9D28;
	sub_830E7DD0(ctx, base);
	// 830E9D28: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830E9D2C: 480BE488  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E9D30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E9D30 size=232
    let mut pc: u32 = 0x830E9D30;
    'dispatch: loop {
        match pc {
            0x830E9D30 => {
    //   block [0x830E9D30..0x830E9E18)
	// 830E9D30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E9D34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E9D38: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830E9D3C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E9D40: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E9D44: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830E9D48: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E9D4C: 4BFE4EC5  bl 0x830cec10
	ctx.lr = 0x830E9D50;
	sub_830CEC10(ctx, base);
	// 830E9D50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E9D54: 4BFFDFED  bl 0x830e7d40
	ctx.lr = 0x830E9D58;
	sub_830E7D40(ctx, base);
	// 830E9D58: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E9D5C: 418200A4  beq 0x830e9e00
	if ctx.cr[0].eq {
	pc = 0x830E9E00; continue 'dispatch;
	}
	// 830E9D60: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830E9D64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E9D68: 4BFFE021  bl 0x830e7d88
	ctx.lr = 0x830E9D6C;
	sub_830E7D88(ctx, base);
	// 830E9D6C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830E9D70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E9D74: 88BE0038  lbz r5, 0x38(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) } as u64;
	// 830E9D78: 4BFF4E61  bl 0x830debd8
	ctx.lr = 0x830E9D7C;
	sub_830DEBD8(ctx, base);
	// 830E9D7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E9D80: 4BFF6E21  bl 0x830e0ba0
	ctx.lr = 0x830E9D84;
	sub_830E0BA0(ctx, base);
	// 830E9D84: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E9D88: 41820010  beq 0x830e9d98
	if ctx.cr[0].eq {
	pc = 0x830E9D98; continue 'dispatch;
	}
	// 830E9D8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E9D90: 889E0038  lbz r4, 0x38(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) } as u64;
	// 830E9D94: 4BFFFD7D  bl 0x830e9b10
	ctx.lr = 0x830E9D98;
	sub_830E9B10(ctx, base);
	// 830E9D98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E9D9C: 4BFFE035  bl 0x830e7dd0
	ctx.lr = 0x830E9DA0;
	sub_830E7DD0(ctx, base);
	// 830E9DA0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830E9DA4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E9DA8: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 830E9DAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E9DB0: 4BFF77A9  bl 0x830e1558
	ctx.lr = 0x830E9DB4;
	sub_830E1558(ctx, base);
	// 830E9DB4: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E9DB8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830E9DBC: 419A0044  beq cr6, 0x830e9e00
	if ctx.cr[6].eq {
	pc = 0x830E9E00; continue 'dispatch;
	}
	// 830E9DC0: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 830E9DC4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 830E9DC8: 4BFF62E9  bl 0x830e00b0
	ctx.lr = 0x830E9DCC;
	sub_830E00B0(ctx, base);
	// 830E9DCC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830E9DD0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830E9DD4: 419A002C  beq cr6, 0x830e9e00
	if ctx.cr[6].eq {
	pc = 0x830E9E00; continue 'dispatch;
	}
	// 830E9DD8: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 830E9DDC: 80A3000C  lwz r5, 0xc(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 830E9DE0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830E9DE4: 80E30010  lwz r7, 0x10(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 830E9DE8: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 830E9DEC: 80830008  lwz r4, 8(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E9DF0: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 830E9DF4: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830E9DF8: 69680001  xori r8, r11, 1
	ctx.r[8].u64 = ctx.r[11].u64 ^ 1;
	// 830E9DFC: 480152FD  bl 0x830ff0f8
	ctx.lr = 0x830E9E00;
	sub_830FF0F8(ctx, base);
	// 830E9E00: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E9E04: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E9E08: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E9E0C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830E9E10: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E9E14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E9E18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830E9E18 size=2160
    let mut pc: u32 = 0x830E9E18;
    'dispatch: loop {
        match pc {
            0x830E9E18 => {
    //   block [0x830E9E18..0x830EA688)
	// 830E9E18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E9E1C: 480BE345  bl 0x831a8160
	ctx.lr = 0x830E9E20;
	sub_831A8130(ctx, base);
	// 830E9E20: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E9E24: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830E9E28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E9E2C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E9E30: 2B0B07D2  cmplwi cr6, r11, 0x7d2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2002 as u32, &mut ctx.xer);
	// 830E9E34: 419904B8  bgt cr6, 0x830ea2ec
	if ctx.cr[6].gt {
	pc = 0x830EA2EC; continue 'dispatch;
	}
	// 830E9E38: 419A0498  beq cr6, 0x830ea2d0
	if ctx.cr[6].eq {
	pc = 0x830EA2D0; continue 'dispatch;
	}
	// 830E9E3C: 2B0B000F  cmplwi cr6, r11, 0xf
	ctx.cr[6].compare_u32(ctx.r[11].u32, 15 as u32, &mut ctx.xer);
	// 830E9E40: 419901A8  bgt cr6, 0x830e9fe8
	if ctx.cr[6].gt {
	pc = 0x830E9FE8; continue 'dispatch;
	}
	// 830E9E44: 419A0194  beq cr6, 0x830e9fd8
	if ctx.cr[6].eq {
	pc = 0x830E9FD8; continue 'dispatch;
	}
	// 830E9E48: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 830E9E4C: 41980158  blt cr6, 0x830e9fa4
	if ctx.cr[6].lt {
	pc = 0x830E9FA4; continue 'dispatch;
	}
	// 830E9E50: 2B0B0009  cmplwi cr6, r11, 9
	ctx.cr[6].compare_u32(ctx.r[11].u32, 9 as u32, &mut ctx.xer);
	// 830E9E54: 419A0128  beq cr6, 0x830e9f7c
	if ctx.cr[6].eq {
	pc = 0x830E9F7C; continue 'dispatch;
	}
	// 830E9E58: 2B0B000A  cmplwi cr6, r11, 0xa
	ctx.cr[6].compare_u32(ctx.r[11].u32, 10 as u32, &mut ctx.xer);
	// 830E9E5C: 419A0114  beq cr6, 0x830e9f70
	if ctx.cr[6].eq {
	pc = 0x830E9F70; continue 'dispatch;
	}
	// 830E9E60: 2B0B000B  cmplwi cr6, r11, 0xb
	ctx.cr[6].compare_u32(ctx.r[11].u32, 11 as u32, &mut ctx.xer);
	// 830E9E64: 419A00C4  beq cr6, 0x830e9f28
	if ctx.cr[6].eq {
	pc = 0x830E9F28; continue 'dispatch;
	}
	// 830E9E68: 2B0B000C  cmplwi cr6, r11, 0xc
	ctx.cr[6].compare_u32(ctx.r[11].u32, 12 as u32, &mut ctx.xer);
	// 830E9E6C: 419A0054  beq cr6, 0x830e9ec0
	if ctx.cr[6].eq {
	pc = 0x830E9EC0; continue 'dispatch;
	}
	// 830E9E70: 2B0B000D  cmplwi cr6, r11, 0xd
	ctx.cr[6].compare_u32(ctx.r[11].u32, 13 as u32, &mut ctx.xer);
	// 830E9E74: 409A0808  bne cr6, 0x830ea67c
	if !ctx.cr[6].eq {
	pc = 0x830EA67C; continue 'dispatch;
	}
	// 830E9E78: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830E9E7C: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830E9E80: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E9E84: 4BFE4D8D  bl 0x830cec10
	ctx.lr = 0x830E9E88;
	sub_830CEC10(ctx, base);
	// 830E9E88: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830E9E8C: 4BFFDF85  bl 0x830e7e10
	ctx.lr = 0x830E9E90;
	sub_830E7E10(ctx, base);
	// 830E9E90: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830E9E94: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E9E98: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E9E9C: 4BFE4D75  bl 0x830cec10
	ctx.lr = 0x830E9EA0;
	sub_830CEC10(ctx, base);
	// 830E9EA0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830E9EA4: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 830E9EA8: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 830E9EAC: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 830E9EB0: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 830E9EB4: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 830E9EB8: 4BFFCE11  bl 0x830e6cc8
	ctx.lr = 0x830E9EBC;
	sub_830E6CC8(ctx, base);
	// 830E9EBC: 48000048  b 0x830e9f04
	pc = 0x830E9F04; continue 'dispatch;
	// 830E9EC0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830E9EC4: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830E9EC8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E9ECC: 4BFE4D45  bl 0x830cec10
	ctx.lr = 0x830E9ED0;
	sub_830CEC10(ctx, base);
	// 830E9ED0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830E9ED4: 4BFFDF3D  bl 0x830e7e10
	ctx.lr = 0x830E9ED8;
	sub_830E7E10(ctx, base);
	// 830E9ED8: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830E9EDC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E9EE0: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E9EE4: 4BFE4D2D  bl 0x830cec10
	ctx.lr = 0x830E9EE8;
	sub_830CEC10(ctx, base);
	// 830E9EE8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830E9EEC: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 830E9EF0: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 830E9EF4: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 830E9EF8: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 830E9EFC: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 830E9F00: 4BFFCD89  bl 0x830e6c88
	ctx.lr = 0x830E9F04;
	sub_830E6C88(ctx, base);
	// 830E9F04: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830E9F08: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E9F0C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830E9F10: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E9F14: 4BFF5845  bl 0x830df758
	ctx.lr = 0x830E9F18;
	sub_830DF758(ctx, base);
	// 830E9F18: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 830E9F1C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E9F20: 4BFEBE39  bl 0x830d5d58
	ctx.lr = 0x830E9F24;
	sub_830D5D58(ctx, base);
	// 830E9F24: 48000758  b 0x830ea67c
	pc = 0x830EA67C; continue 'dispatch;
	// 830E9F28: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 830E9F2C: 83BE0010  lwz r29, 0x10(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830E9F30: 935E0008  stw r26, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[26].u32 ) };
	// 830E9F34: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E9F38: 4BFE4CD9  bl 0x830cec10
	ctx.lr = 0x830E9F3C;
	sub_830CEC10(ctx, base);
	// 830E9F3C: 4BFF6B45  bl 0x830e0a80
	ctx.lr = 0x830E9F40;
	sub_830E0A80(ctx, base);
	// 830E9F40: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E9F44: 41820020  beq 0x830e9f64
	if ctx.cr[0].eq {
	pc = 0x830E9F64; continue 'dispatch;
	}
	// 830E9F48: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E9F4C: 4BFE4CC5  bl 0x830cec10
	ctx.lr = 0x830E9F50;
	sub_830CEC10(ctx, base);
	// 830E9F50: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830E9F54: 4BFFD96D  bl 0x830e78c0
	ctx.lr = 0x830E9F58;
	sub_830E78C0(ctx, base);
	// 830E9F58: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E9F5C: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 830E9F60: 41820008  beq 0x830e9f68
	if ctx.cr[0].eq {
	pc = 0x830E9F68; continue 'dispatch;
	}
	// 830E9F64: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830E9F68: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830E9F6C: 48000710  b 0x830ea67c
	pc = 0x830EA67C; continue 'dispatch;
	// 830E9F70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E9F74: 4BFFBA1D  bl 0x830e5990
	ctx.lr = 0x830E9F78;
	sub_830E5990(ctx, base);
	// 830E9F78: 48000704  b 0x830ea67c
	pc = 0x830EA67C; continue 'dispatch;
	// 830E9F7C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830E9F80: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830E9F84: 4BFF5665  bl 0x830df5e8
	ctx.lr = 0x830E9F88;
	sub_830DF5E8(ctx, base);
	// 830E9F88: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E9F8C: 408206F0  bne 0x830ea67c
	if !ctx.cr[0].eq {
	pc = 0x830EA67C; continue 'dispatch;
	}
	// 830E9F90: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E9F94: 4BFF5035  bl 0x830defc8
	ctx.lr = 0x830E9F98;
	sub_830DEFC8(ctx, base);
	// 830E9F98: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830E9F9C: 418006E4  blt 0x830ea680
	if ctx.cr[0].lt {
	pc = 0x830EA680; continue 'dispatch;
	}
	// 830E9FA0: 48000544  b 0x830ea4e4
	pc = 0x830EA4E4; continue 'dispatch;
	// 830E9FA4: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830E9FA8: 556B077A  rlwinm r11, r11, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830E9FAC: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 830E9FB0: 419A06CC  beq cr6, 0x830ea67c
	if ctx.cr[6].eq {
	pc = 0x830EA67C; continue 'dispatch;
	}
	// 830E9FB4: 38800009  li r4, 9
	ctx.r[4].s64 = 9;
	// 830E9FB8: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 830E9FBC: 48018035  bl 0x83101ff0
	ctx.lr = 0x830E9FC0;
	sub_83101FF0(ctx, base);
	// 830E9FC0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E9FC4: 3BE100A0  addi r31, r1, 0xa0
	ctx.r[31].s64 = ctx.r[1].s64 + 160;
	// 830E9FC8: 4BFE4C49  bl 0x830cec10
	ctx.lr = 0x830E9FCC;
	sub_830CEC10(ctx, base);
	// 830E9FCC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E9FD0: 4BFEBBF9  bl 0x830d5bc8
	ctx.lr = 0x830E9FD4;
	sub_830D5BC8(ctx, base);
	// 830E9FD4: 480006A8  b 0x830ea67c
	pc = 0x830EA67C; continue 'dispatch;
	// 830E9FD8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830E9FDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E9FE0: 4BFFFD51  bl 0x830e9d30
	ctx.lr = 0x830E9FE4;
	sub_830E9D30(ctx, base);
	// 830E9FE4: 48000698  b 0x830ea67c
	pc = 0x830EA67C; continue 'dispatch;
	// 830E9FE8: 2B0B0012  cmplwi cr6, r11, 0x12
	ctx.cr[6].compare_u32(ctx.r[11].u32, 18 as u32, &mut ctx.xer);
	// 830E9FEC: 419A027C  beq cr6, 0x830ea268
	if ctx.cr[6].eq {
	pc = 0x830EA268; continue 'dispatch;
	}
	// 830E9FF0: 2B0B0021  cmplwi cr6, r11, 0x21
	ctx.cr[6].compare_u32(ctx.r[11].u32, 33 as u32, &mut ctx.xer);
	// 830E9FF4: 419A0218  beq cr6, 0x830ea20c
	if ctx.cr[6].eq {
	pc = 0x830EA20C; continue 'dispatch;
	}
	// 830E9FF8: 2B0B0024  cmplwi cr6, r11, 0x24
	ctx.cr[6].compare_u32(ctx.r[11].u32, 36 as u32, &mut ctx.xer);
	// 830E9FFC: 419A0094  beq cr6, 0x830ea090
	if ctx.cr[6].eq {
	pc = 0x830EA090; continue 'dispatch;
	}
	// 830EA000: 2B0B0028  cmplwi cr6, r11, 0x28
	ctx.cr[6].compare_u32(ctx.r[11].u32, 40 as u32, &mut ctx.xer);
	// 830EA004: 419A0040  beq cr6, 0x830ea044
	if ctx.cr[6].eq {
	pc = 0x830EA044; continue 'dispatch;
	}
	// 830EA008: 2B0B0029  cmplwi cr6, r11, 0x29
	ctx.cr[6].compare_u32(ctx.r[11].u32, 41 as u32, &mut ctx.xer);
	// 830EA00C: 409A0670  bne cr6, 0x830ea67c
	if !ctx.cr[6].eq {
	pc = 0x830EA67C; continue 'dispatch;
	}
	// 830EA010: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EA014: 556B077A  rlwinm r11, r11, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830EA018: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 830EA01C: 419A0660  beq cr6, 0x830ea67c
	if ctx.cr[6].eq {
	pc = 0x830EA67C; continue 'dispatch;
	}
	// 830EA020: 38800009  li r4, 9
	ctx.r[4].s64 = 9;
	// 830EA024: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 830EA028: 48017FC9  bl 0x83101ff0
	ctx.lr = 0x830EA02C;
	sub_83101FF0(ctx, base);
	// 830EA02C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA030: 3BE100A0  addi r31, r1, 0xa0
	ctx.r[31].s64 = ctx.r[1].s64 + 160;
	// 830EA034: 4BFE4BDD  bl 0x830cec10
	ctx.lr = 0x830EA038;
	sub_830CEC10(ctx, base);
	// 830EA038: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830EA03C: 4BFEBB8D  bl 0x830d5bc8
	ctx.lr = 0x830EA040;
	sub_830D5BC8(ctx, base);
	// 830EA040: 48000640  b 0x830ea680
	pc = 0x830EA680; continue 'dispatch;
	// 830EA044: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EA048: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA04C: 556B06F6  rlwinm r11, r11, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830EA050: 2B0B0010  cmplwi cr6, r11, 0x10
	ctx.cr[6].compare_u32(ctx.r[11].u32, 16 as u32, &mut ctx.xer);
	// 830EA054: 409A0628  bne cr6, 0x830ea67c
	if !ctx.cr[6].eq {
	pc = 0x830EA67C; continue 'dispatch;
	}
	// 830EA058: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA05C: 4BFE4BB5  bl 0x830cec10
	ctx.lr = 0x830EA060;
	sub_830CEC10(ctx, base);
	// 830EA060: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830EA064: 4BFFDCDD  bl 0x830e7d40
	ctx.lr = 0x830EA068;
	sub_830E7D40(ctx, base);
	// 830EA068: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830EA06C: 41820018  beq 0x830ea084
	if ctx.cr[0].eq {
	pc = 0x830EA084; continue 'dispatch;
	}
	// 830EA070: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830EA074: 4BFF4BFD  bl 0x830dec70
	ctx.lr = 0x830EA078;
	sub_830DEC70(ctx, base);
	// 830EA078: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830EA07C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830EA080: 4BFFDD09  bl 0x830e7d88
	ctx.lr = 0x830EA084;
	sub_830E7D88(ctx, base);
	// 830EA084: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA088: 4BFF4EF9  bl 0x830def80
	ctx.lr = 0x830EA08C;
	sub_830DEF80(ctx, base);
	// 830EA08C: 480005F0  b 0x830ea67c
	pc = 0x830EA67C; continue 'dispatch;
	// 830EA090: 837E0010  lwz r27, 0x10(r30)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EA094: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA098: 4BFF7371  bl 0x830e1408
	ctx.lr = 0x830EA09C;
	sub_830E1408(ctx, base);
	// 830EA09C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830EA0A0: 418205DC  beq 0x830ea67c
	if ctx.cr[0].eq {
	pc = 0x830EA67C; continue 'dispatch;
	}
	// 830EA0A4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830EA0A8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830EA0AC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 830EA0B0: 4BFF4C31  bl 0x830dece0
	ctx.lr = 0x830EA0B4;
	sub_830DECE0(ctx, base);
	// 830EA0B4: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 830EA0B8: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 830EA0BC: 419A0050  beq cr6, 0x830ea10c
	if ctx.cr[6].eq {
	pc = 0x830EA10C; continue 'dispatch;
	}
	// 830EA0C0: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 830EA0C4: 419A0040  beq cr6, 0x830ea104
	if ctx.cr[6].eq {
	pc = 0x830EA104; continue 'dispatch;
	}
	// 830EA0C8: 2F030003  cmpwi cr6, r3, 3
	ctx.cr[6].compare_i32(ctx.r[3].s32, 3, &mut ctx.xer);
	// 830EA0CC: 419A0030  beq cr6, 0x830ea0fc
	if ctx.cr[6].eq {
	pc = 0x830EA0FC; continue 'dispatch;
	}
	// 830EA0D0: 2F030004  cmpwi cr6, r3, 4
	ctx.cr[6].compare_i32(ctx.r[3].s32, 4, &mut ctx.xer);
	// 830EA0D4: 419A0020  beq cr6, 0x830ea0f4
	if ctx.cr[6].eq {
	pc = 0x830EA0F4; continue 'dispatch;
	}
	// 830EA0D8: 2F030007  cmpwi cr6, r3, 7
	ctx.cr[6].compare_i32(ctx.r[3].s32, 7, &mut ctx.xer);
	// 830EA0DC: 409A05A0  bne cr6, 0x830ea67c
	if !ctx.cr[6].eq {
	pc = 0x830EA67C; continue 'dispatch;
	}
	// 830EA0E0: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EA0E4: 7F5CD378  mr r28, r26
	ctx.r[28].u64 = ctx.r[26].u64;
	// 830EA0E8: 556BFFFE  rlwinm r11, r11, 0x1f, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 830EA0EC: 617D0004  ori r29, r11, 4
	ctx.r[29].u64 = ctx.r[11].u64 | 4;
	// 830EA0F0: 48000020  b 0x830ea110
	pc = 0x830EA110; continue 'dispatch;
	// 830EA0F4: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 830EA0F8: 48000018  b 0x830ea110
	pc = 0x830EA110; continue 'dispatch;
	// 830EA0FC: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 830EA100: 48000010  b 0x830ea110
	pc = 0x830EA110; continue 'dispatch;
	// 830EA104: 3BA00003  li r29, 3
	ctx.r[29].s64 = 3;
	// 830EA108: 48000008  b 0x830ea110
	pc = 0x830EA110; continue 'dispatch;
	// 830EA10C: 3BA00002  li r29, 2
	ctx.r[29].s64 = 2;
	// 830EA110: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA114: 4BFE4AFD  bl 0x830cec10
	ctx.lr = 0x830EA118;
	sub_830CEC10(ctx, base);
	// 830EA118: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 830EA11C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830EA120: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830EA124: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 830EA128: 4BFFD481  bl 0x830e75a8
	ctx.lr = 0x830EA12C;
	sub_830E75A8(ctx, base);
	// 830EA12C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA130: 3BA10080  addi r29, r1, 0x80
	ctx.r[29].s64 = ctx.r[1].s64 + 128;
	// 830EA134: 4BFE4ADD  bl 0x830cec10
	ctx.lr = 0x830EA138;
	sub_830CEC10(ctx, base);
	// 830EA138: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830EA13C: 4BFEBA8D  bl 0x830d5bc8
	ctx.lr = 0x830EA140;
	sub_830D5BC8(ctx, base);
	// 830EA140: 81610088  lwz r11, 0x88(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 830EA144: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EA148: 419A003C  beq cr6, 0x830ea184
	if ctx.cr[6].eq {
	pc = 0x830EA184; continue 'dispatch;
	}
	// 830EA14C: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 830EA150: 935E0008  stw r26, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[26].u32 ) };
	// 830EA154: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EA158: 409A0524  bne cr6, 0x830ea67c
	if !ctx.cr[6].eq {
	pc = 0x830EA67C; continue 'dispatch;
	}
	// 830EA15C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA160: 4BFF7351  bl 0x830e14b0
	ctx.lr = 0x830EA164;
	sub_830E14B0(ctx, base);
	// 830EA164: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EA168: 41820010  beq 0x830ea178
	if ctx.cr[0].eq {
	pc = 0x830EA178; continue 'dispatch;
	}
	// 830EA16C: 4BFF4D95  bl 0x830def00
	ctx.lr = 0x830EA170;
	sub_830DEF00(ctx, base);
	// 830EA170: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830EA174: 48000008  b 0x830ea17c
	pc = 0x830EA17C; continue 'dispatch;
	// 830EA178: 388000FF  li r4, 0xff
	ctx.r[4].s64 = 255;
	// 830EA17C: 80610068  lwz r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 830EA180: 48000084  b 0x830ea204
	pc = 0x830EA204; continue 'dispatch;
	// 830EA184: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 830EA188: 419A04F4  beq cr6, 0x830ea67c
	if ctx.cr[6].eq {
	pc = 0x830EA67C; continue 'dispatch;
	}
	// 830EA18C: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EA190: 935E0008  stw r26, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[26].u32 ) };
	// 830EA194: 557EFFFE  rlwinm r30, r11, 0x1f, 0x1f, 0x1f
	ctx.r[30].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 830EA198: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA19C: 4BFE4A75  bl 0x830cec10
	ctx.lr = 0x830EA1A0;
	sub_830CEC10(ctx, base);
	// 830EA1A0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 830EA1A4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830EA1A8: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 830EA1AC: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 830EA1B0: 4BFF6761  bl 0x830e0910
	ctx.lr = 0x830EA1B4;
	sub_830E0910(ctx, base);
	// 830EA1B4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA1B8: 3BC100A0  addi r30, r1, 0xa0
	ctx.r[30].s64 = ctx.r[1].s64 + 160;
	// 830EA1BC: 4BFE4A55  bl 0x830cec10
	ctx.lr = 0x830EA1C0;
	sub_830CEC10(ctx, base);
	// 830EA1C0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830EA1C4: 4BFEBA05  bl 0x830d5bc8
	ctx.lr = 0x830EA1C8;
	sub_830D5BC8(ctx, base);
	// 830EA1C8: 816100A8  lwz r11, 0xa8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) } as u64;
	// 830EA1CC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EA1D0: 419A04AC  beq cr6, 0x830ea67c
	if ctx.cr[6].eq {
	pc = 0x830EA67C; continue 'dispatch;
	}
	// 830EA1D4: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 830EA1D8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EA1DC: 409A04A0  bne cr6, 0x830ea67c
	if !ctx.cr[6].eq {
	pc = 0x830EA67C; continue 'dispatch;
	}
	// 830EA1E0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA1E4: 4BFF72CD  bl 0x830e14b0
	ctx.lr = 0x830EA1E8;
	sub_830E14B0(ctx, base);
	// 830EA1E8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EA1EC: 41820010  beq 0x830ea1fc
	if ctx.cr[0].eq {
	pc = 0x830EA1FC; continue 'dispatch;
	}
	// 830EA1F0: 4BFF4D11  bl 0x830def00
	ctx.lr = 0x830EA1F4;
	sub_830DEF00(ctx, base);
	// 830EA1F4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830EA1F8: 48000008  b 0x830ea200
	pc = 0x830EA200; continue 'dispatch;
	// 830EA1FC: 388000FF  li r4, 0xff
	ctx.r[4].s64 = 255;
	// 830EA200: 80610078  lwz r3, 0x78(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 830EA204: 4BFF8A1D  bl 0x830e2c20
	ctx.lr = 0x830EA208;
	sub_830E2C20(ctx, base);
	// 830EA208: 48000474  b 0x830ea67c
	pc = 0x830EA67C; continue 'dispatch;
	// 830EA20C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830EA210: 83BE0010  lwz r29, 0x10(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EA214: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830EA218: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830EA21C: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA220: 4BFF5539  bl 0x830df758
	ctx.lr = 0x830EA224;
	sub_830DF758(ctx, base);
	// 830EA224: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA228: 4BFE49E9  bl 0x830cec10
	ctx.lr = 0x830EA22C;
	sub_830CEC10(ctx, base);
	// 830EA22C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EA230: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 830EA234: 409A0448  bne cr6, 0x830ea67c
	if !ctx.cr[6].eq {
	pc = 0x830EA67C; continue 'dispatch;
	}
	// 830EA238: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830EA23C: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA240: 83EBC07C  lwz r31, -0x3f84(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16260 as u32) ) } as u64;
	// 830EA244: 4BFE49CD  bl 0x830cec10
	ctx.lr = 0x830EA248;
	sub_830CEC10(ctx, base);
	// 830EA248: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830EA24C: 4BFE4925  bl 0x830ceb70
	ctx.lr = 0x830EA250;
	sub_830CEB70(ctx, base);
	// 830EA250: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EA254: 41820428  beq 0x830ea67c
	if ctx.cr[0].eq {
	pc = 0x830EA67C; continue 'dispatch;
	}
	// 830EA258: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 830EA25C: 935E0008  stw r26, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[26].u32 ) };
	// 830EA260: 935D0004  stw r26, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 830EA264: 48000418  b 0x830ea67c
	pc = 0x830EA67C; continue 'dispatch;
	// 830EA268: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 830EA26C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA270: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830EA274: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 830EA278: 4BFE42A1  bl 0x830ce518
	ctx.lr = 0x830EA27C;
	sub_830CE518(ctx, base);
	// 830EA27C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830EA280: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EA284: 4BFEB945  bl 0x830d5bc8
	ctx.lr = 0x830EA288;
	sub_830D5BC8(ctx, base);
	// 830EA288: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA28C: 4BFE4985  bl 0x830cec10
	ctx.lr = 0x830EA290;
	sub_830CEC10(ctx, base);
	// 830EA290: 4BFF67F1  bl 0x830e0a80
	ctx.lr = 0x830EA294;
	sub_830E0A80(ctx, base);
	// 830EA294: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830EA298: 408203E4  bne 0x830ea67c
	if !ctx.cr[0].eq {
	pc = 0x830EA67C; continue 'dispatch;
	}
	// 830EA29C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA2A0: 4BFF4BE9  bl 0x830dee88
	ctx.lr = 0x830EA2A4;
	sub_830DEE88(ctx, base);
	// 830EA2A4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830EA2A8: 418203D4  beq 0x830ea67c
	if ctx.cr[0].eq {
	pc = 0x830EA67C; continue 'dispatch;
	}
	// 830EA2AC: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 830EA2B0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 830EA2B4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA2B8: 4BFF54A1  bl 0x830df758
	ctx.lr = 0x830EA2BC;
	sub_830DF758(ctx, base);
	// 830EA2BC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA2C0: 4BFF4C41  bl 0x830def00
	ctx.lr = 0x830EA2C4;
	sub_830DEF00(ctx, base);
	// 830EA2C4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830EA2C8: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830EA2CC: 4BFFFF38  b 0x830ea204
	pc = 0x830EA204; continue 'dispatch;
	// 830EA2D0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830EA2D4: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830EA2D8: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EA2DC: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 830EA2E0: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EA2E4: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830EA2E8: 48000394  b 0x830ea67c
	pc = 0x830EA67C; continue 'dispatch;
	// 830EA2EC: 2B0B07E2  cmplwi cr6, r11, 0x7e2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2018 as u32, &mut ctx.xer);
	// 830EA2F0: 41990240  bgt cr6, 0x830ea530
	if ctx.cr[6].gt {
	pc = 0x830EA530; continue 'dispatch;
	}
	// 830EA2F4: 419A0200  beq cr6, 0x830ea4f4
	if ctx.cr[6].eq {
	pc = 0x830EA4F4; continue 'dispatch;
	}
	// 830EA2F8: 2B0B07D3  cmplwi cr6, r11, 0x7d3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2003 as u32, &mut ctx.xer);
	// 830EA2FC: 419A01B0  beq cr6, 0x830ea4ac
	if ctx.cr[6].eq {
	pc = 0x830EA4AC; continue 'dispatch;
	}
	// 830EA300: 2B0B07D6  cmplwi cr6, r11, 0x7d6
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2006 as u32, &mut ctx.xer);
	// 830EA304: 419A0190  beq cr6, 0x830ea494
	if ctx.cr[6].eq {
	pc = 0x830EA494; continue 'dispatch;
	}
	// 830EA308: 2B0B07D9  cmplwi cr6, r11, 0x7d9
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2009 as u32, &mut ctx.xer);
	// 830EA30C: 419A0128  beq cr6, 0x830ea434
	if ctx.cr[6].eq {
	pc = 0x830EA434; continue 'dispatch;
	}
	// 830EA310: 2B0B07DF  cmplwi cr6, r11, 0x7df
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2015 as u32, &mut ctx.xer);
	// 830EA314: 419A00D0  beq cr6, 0x830ea3e4
	if ctx.cr[6].eq {
	pc = 0x830EA3E4; continue 'dispatch;
	}
	// 830EA318: 2B0B07E0  cmplwi cr6, r11, 0x7e0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2016 as u32, &mut ctx.xer);
	// 830EA31C: 419A003C  beq cr6, 0x830ea358
	if ctx.cr[6].eq {
	pc = 0x830EA358; continue 'dispatch;
	}
	// 830EA320: 2B0B07E1  cmplwi cr6, r11, 0x7e1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2017 as u32, &mut ctx.xer);
	// 830EA324: 409A0358  bne cr6, 0x830ea67c
	if !ctx.cr[6].eq {
	pc = 0x830EA67C; continue 'dispatch;
	}
	// 830EA328: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EA32C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA330: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830EA334: 409A00C0  bne cr6, 0x830ea3f4
	if !ctx.cr[6].eq {
	pc = 0x830EA3F4; continue 'dispatch;
	}
	// 830EA338: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EA33C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830EA340: 409A00CC  bne cr6, 0x830ea40c
	if !ctx.cr[6].eq {
	pc = 0x830EA40C; continue 'dispatch;
	}
	// 830EA344: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830EA348: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830EA34C: 815F0034  lwz r10, 0x34(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 830EA350: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 830EA354: 48000328  b 0x830ea67c
	pc = 0x830EA67C; continue 'dispatch;
	// 830EA358: 839E0010  lwz r28, 0x10(r30)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EA35C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA360: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EA364: 409A0090  bne cr6, 0x830ea3f4
	if !ctx.cr[6].eq {
	pc = 0x830EA3F4; continue 'dispatch;
	}
	// 830EA368: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EA36C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EA370: 409A009C  bne cr6, 0x830ea40c
	if !ctx.cr[6].eq {
	pc = 0x830EA40C; continue 'dispatch;
	}
	// 830EA374: 807F002C  lwz r3, 0x2c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 830EA378: 3BBF002C  addi r29, r31, 0x2c
	ctx.r[29].s64 = ctx.r[31].s64 + 44;
	// 830EA37C: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 830EA380: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830EA384: 409A0018  bne cr6, 0x830ea39c
	if !ctx.cr[6].eq {
	pc = 0x830EA39C; continue 'dispatch;
	}
	// 830EA388: 817C000C  lwz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EA38C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EA390: 419A004C  beq cr6, 0x830ea3dc
	if ctx.cr[6].eq {
	pc = 0x830EA3DC; continue 'dispatch;
	}
	// 830EA394: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830EA398: 419A001C  beq cr6, 0x830ea3b4
	if ctx.cr[6].eq {
	pc = 0x830EA3B4; continue 'dispatch;
	}
	// 830EA39C: 809C000C  lwz r4, 0xc(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EA3A0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830EA3A4: 419A0010  beq cr6, 0x830ea3b4
	if ctx.cr[6].eq {
	pc = 0x830EA3B4; continue 'dispatch;
	}
	// 830EA3A8: 480C7A89  bl 0x831b1e30
	ctx.lr = 0x830EA3AC;
	sub_831B1E30(ctx, base);
	// 830EA3AC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830EA3B0: 4182002C  beq 0x830ea3dc
	if ctx.cr[0].eq {
	pc = 0x830EA3DC; continue 'dispatch;
	}
	// 830EA3B4: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 830EA3B8: 356B0001  addic. r11, r11, 1
	ctx.xer.ca = (ctx.r[11].u32 > (!(1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EA3BC: 917F003C  stw r11, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 830EA3C0: 40820008  bne 0x830ea3c8
	if !ctx.cr[0].eq {
	pc = 0x830EA3C8; continue 'dispatch;
	}
	// 830EA3C4: 935F003C  stw r26, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[26].u32 ) };
	// 830EA3C8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830EA3CC: 809C000C  lwz r4, 0xc(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EA3D0: 4BFE48B9  bl 0x830cec88
	ctx.lr = 0x830EA3D4;
	sub_830CEC88(ctx, base);
	// 830EA3D4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830EA3D8: 418002A8  blt 0x830ea680
	if ctx.cr[0].lt {
	pc = 0x830EA680; continue 'dispatch;
	}
	// 830EA3DC: 935E0008  stw r26, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[26].u32 ) };
	// 830EA3E0: 4800029C  b 0x830ea67c
	pc = 0x830EA67C; continue 'dispatch;
	// 830EA3E4: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EA3E8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA3EC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830EA3F0: 419A0010  beq cr6, 0x830ea400
	if ctx.cr[6].eq {
	pc = 0x830EA400; continue 'dispatch;
	}
	// 830EA3F4: 3C608030  lis r3, -0x7fd0
	ctx.r[3].s64 = -2144337920;
	// 830EA3F8: 60630021  ori r3, r3, 0x21
	ctx.r[3].u64 = ctx.r[3].u64 | 33;
	// 830EA3FC: 48000284  b 0x830ea680
	pc = 0x830EA680; continue 'dispatch;
	// 830EA400: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EA404: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830EA408: 419A0010  beq cr6, 0x830ea418
	if ctx.cr[6].eq {
	pc = 0x830EA418; continue 'dispatch;
	}
	// 830EA40C: 3C608030  lis r3, -0x7fd0
	ctx.r[3].s64 = -2144337920;
	// 830EA410: 60630022  ori r3, r3, 0x22
	ctx.r[3].u64 = ctx.r[3].u64 | 34;
	// 830EA414: 4800026C  b 0x830ea680
	pc = 0x830EA680; continue 'dispatch;
	// 830EA418: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830EA41C: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830EA420: 815F002C  lwz r10, 0x2c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 830EA424: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 830EA428: C01F0030  lfs f0, 0x30(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EA42C: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 830EA430: 4800024C  b 0x830ea67c
	pc = 0x830EA67C; continue 'dispatch;
	// 830EA434: 83BE0010  lwz r29, 0x10(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EA438: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830EA43C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 830EA440: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830EA444: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830EA448: 939D0004  stw r28, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 830EA44C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 830EA450: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA454: 4BFF537D  bl 0x830df7d0
	ctx.lr = 0x830EA458;
	sub_830DF7D0(ctx, base);
	// 830EA458: 48000020  b 0x830ea478
	pc = 0x830EA478; continue 'dispatch;
	// 830EA45C: 4BFF4C85  bl 0x830df0e0
	ctx.lr = 0x830EA460;
	sub_830DF0E0(ctx, base);
	// 830EA460: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA464: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830EA468: 419A0020  beq cr6, 0x830ea488
	if ctx.cr[6].eq {
	pc = 0x830EA488; continue 'dispatch;
	}
	// 830EA46C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830EA470: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EA474: 4BFF544D  bl 0x830df8c0
	ctx.lr = 0x830EA478;
	sub_830DF8C0(ctx, base);
	// 830EA478: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EA47C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830EA480: 409AFFDC  bne cr6, 0x830ea45c
	if !ctx.cr[6].eq {
	pc = 0x830EA45C; continue 'dispatch;
	}
	// 830EA484: 480001F8  b 0x830ea67c
	pc = 0x830EA67C; continue 'dispatch;
	// 830EA488: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EA48C: 917D0004  stw r11, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830EA490: 480001EC  b 0x830ea67c
	pc = 0x830EA67C; continue 'dispatch;
	// 830EA494: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830EA498: 809E0010  lwz r4, 0x10(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EA49C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EA4A0: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830EA4A4: 4BFFB545  bl 0x830e59e8
	ctx.lr = 0x830EA4A8;
	sub_830E59E8(ctx, base);
	// 830EA4A8: 480001D4  b 0x830ea67c
	pc = 0x830EA67C; continue 'dispatch;
	// 830EA4AC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830EA4B0: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EA4B4: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830EA4B8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA4BC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EA4C0: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EA4C4: 419A000C  beq cr6, 0x830ea4d0
	if ctx.cr[6].eq {
	pc = 0x830EA4D0; continue 'dispatch;
	}
	// 830EA4C8: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 830EA4CC: 48000008  b 0x830ea4d4
	pc = 0x830EA4D4; continue 'dispatch;
	// 830EA4D0: 556B003C  rlwinm r11, r11, 0, 0, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830EA4D4: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 830EA4D8: 4BFF5111  bl 0x830df5e8
	ctx.lr = 0x830EA4DC;
	sub_830DF5E8(ctx, base);
	// 830EA4DC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830EA4E0: 4082019C  bne 0x830ea67c
	if !ctx.cr[0].eq {
	pc = 0x830EA67C; continue 'dispatch;
	}
	// 830EA4E4: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 830EA4E8: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 830EA4EC: 4BFFCA95  bl 0x830e6f80
	ctx.lr = 0x830EA4F0;
	sub_830E6F80(ctx, base);
	// 830EA4F0: 4BFFFAD0  b 0x830e9fc0
	pc = 0x830E9FC0; continue 'dispatch;
	// 830EA4F4: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EA4F8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA4FC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830EA500: 409AFEF4  bne cr6, 0x830ea3f4
	if !ctx.cr[6].eq {
	pc = 0x830EA3F4; continue 'dispatch;
	}
	// 830EA504: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EA508: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830EA50C: 409AFF00  bne cr6, 0x830ea40c
	if !ctx.cr[6].eq {
	pc = 0x830EA40C; continue 'dispatch;
	}
	// 830EA510: 387F0034  addi r3, r31, 0x34
	ctx.r[3].s64 = ctx.r[31].s64 + 52;
	// 830EA514: 808B0010  lwz r4, 0x10(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EA518: 4BFE4771  bl 0x830cec88
	ctx.lr = 0x830EA51C;
	sub_830CEC88(ctx, base);
	// 830EA51C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830EA520: 41800160  blt 0x830ea680
	if ctx.cr[0].lt {
	pc = 0x830EA680; continue 'dispatch;
	}
	// 830EA524: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830EA528: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830EA52C: 48000150  b 0x830ea67c
	pc = 0x830EA67C; continue 'dispatch;
	// 830EA530: 2B0B07E5  cmplwi cr6, r11, 0x7e5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2021 as u32, &mut ctx.xer);
	// 830EA534: 419A013C  beq cr6, 0x830ea670
	if ctx.cr[6].eq {
	pc = 0x830EA670; continue 'dispatch;
	}
	// 830EA538: 2B0B07E6  cmplwi cr6, r11, 0x7e6
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2022 as u32, &mut ctx.xer);
	// 830EA53C: 419A0094  beq cr6, 0x830ea5d0
	if ctx.cr[6].eq {
	pc = 0x830EA5D0; continue 'dispatch;
	}
	// 830EA540: 2B0B07F7  cmplwi cr6, r11, 0x7f7
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2039 as u32, &mut ctx.xer);
	// 830EA544: 419A0078  beq cr6, 0x830ea5bc
	if ctx.cr[6].eq {
	pc = 0x830EA5BC; continue 'dispatch;
	}
	// 830EA548: 2B0B07F8  cmplwi cr6, r11, 0x7f8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2040 as u32, &mut ctx.xer);
	// 830EA54C: 419A0040  beq cr6, 0x830ea58c
	if ctx.cr[6].eq {
	pc = 0x830EA58C; continue 'dispatch;
	}
	// 830EA550: 2B0B07FB  cmplwi cr6, r11, 0x7fb
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2043 as u32, &mut ctx.xer);
	// 830EA554: 409A0128  bne cr6, 0x830ea67c
	if !ctx.cr[6].eq {
	pc = 0x830EA67C; continue 'dispatch;
	}
	// 830EA558: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EA55C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EA560: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830EA564: 409AFE90  bne cr6, 0x830ea3f4
	if !ctx.cr[6].eq {
	pc = 0x830EA3F4; continue 'dispatch;
	}
	// 830EA568: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EA56C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830EA570: 409AFE9C  bne cr6, 0x830ea40c
	if !ctx.cr[6].eq {
	pc = 0x830EA40C; continue 'dispatch;
	}
	// 830EA574: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830EA578: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830EA57C: 815F003C  lwz r10, 0x3c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 830EA580: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830EA584: 815F002C  lwz r10, 0x2c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 830EA588: 4BFFFDC8  b 0x830ea350
	pc = 0x830EA350; continue 'dispatch;
	// 830EA58C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830EA590: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EA594: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830EA598: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA59C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EA5A0: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EA5A4: 419A000C  beq cr6, 0x830ea5b0
	if ctx.cr[6].eq {
	pc = 0x830EA5B0; continue 'dispatch;
	}
	// 830EA5A8: 616B0008  ori r11, r11, 8
	ctx.r[11].u64 = ctx.r[11].u64 | 8;
	// 830EA5AC: 48000008  b 0x830ea5b4
	pc = 0x830EA5B4; continue 'dispatch;
	// 830EA5B0: 556B0776  rlwinm r11, r11, 0, 0x1d, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830EA5B4: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 830EA5B8: 480000C4  b 0x830ea67c
	pc = 0x830EA67C; continue 'dispatch;
	// 830EA5BC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830EA5C0: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830EA5C4: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EA5C8: 556BEFFE  rlwinm r11, r11, 0x1d, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000007u64;
	// 830EA5CC: 4BFFFD14  b 0x830ea2e0
	pc = 0x830EA2E0; continue 'dispatch;
	// 830EA5D0: 83BE0010  lwz r29, 0x10(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EA5D4: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830EA5D8: 839F0000  lwz r28, 0(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA5DC: 808BC078  lwz r4, -0x3f88(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16264 as u32) ) } as u64;
	// 830EA5E0: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EA5E4: 4BFE458D  bl 0x830ceb70
	ctx.lr = 0x830EA5E8;
	sub_830CEB70(ctx, base);
	// 830EA5E8: 7F03E040  cmplw cr6, r3, r28
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[28].u32, &mut ctx.xer);
	// 830EA5EC: 409A0090  bne cr6, 0x830ea67c
	if !ctx.cr[6].eq {
	pc = 0x830EA67C; continue 'dispatch;
	}
	// 830EA5F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830EA5F4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 830EA5F8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 830EA5FC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830EA600: 4BFF5159  bl 0x830df758
	ctx.lr = 0x830EA604;
	sub_830DF758(ctx, base);
	// 830EA604: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830EA608: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830EA60C: 419A0014  beq cr6, 0x830ea620
	if ctx.cr[6].eq {
	pc = 0x830EA620; continue 'dispatch;
	}
	// 830EA610: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830EA614: 4BFEB5B5  bl 0x830d5bc8
	ctx.lr = 0x830EA618;
	sub_830D5BC8(ctx, base);
	// 830EA618: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830EA61C: 41800064  blt 0x830ea680
	if ctx.cr[0].lt {
	pc = 0x830EA680; continue 'dispatch;
	}
	// 830EA620: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EA624: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EA628: 409A0054  bne cr6, 0x830ea67c
	if !ctx.cr[6].eq {
	pc = 0x830EA67C; continue 'dispatch;
	}
	// 830EA62C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 830EA630: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA634: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830EA638: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA63C: 4BFF7225  bl 0x830e1860
	ctx.lr = 0x830EA640;
	sub_830E1860(ctx, base);
	// 830EA640: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EA644: 907D0008  stw r3, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 830EA648: 41820034  beq 0x830ea67c
	if ctx.cr[0].eq {
	pc = 0x830EA67C; continue 'dispatch;
	}
	// 830EA64C: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 830EA650: 935E0008  stw r26, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[26].u32 ) };
	// 830EA654: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EA658: 4BFE45B9  bl 0x830cec10
	ctx.lr = 0x830EA65C;
	sub_830CEC10(ctx, base);
	// 830EA65C: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EA660: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 830EA664: 409A0018  bne cr6, 0x830ea67c
	if !ctx.cr[6].eq {
	pc = 0x830EA67C; continue 'dispatch;
	}
	// 830EA668: 935D000C  stw r26, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[26].u32 ) };
	// 830EA66C: 48000010  b 0x830ea67c
	pc = 0x830EA67C; continue 'dispatch;
	// 830EA670: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830EA674: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EA678: 4BFFF521  bl 0x830e9b98
	ctx.lr = 0x830EA67C;
	sub_830E9B98(ctx, base);
	// 830EA67C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830EA680: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 830EA684: 480BDB2C  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EA688(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EA688 size=416
    let mut pc: u32 = 0x830EA688;
    'dispatch: loop {
        match pc {
            0x830EA688 => {
    //   block [0x830EA688..0x830EA828)
	// 830EA688: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EA68C: 480BDAD9  bl 0x831a8164
	ctx.lr = 0x830EA690;
	sub_831A8130(ctx, base);
	// 830EA690: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EA694: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830EA698: 4BFFB2F9  bl 0x830e5990
	ctx.lr = 0x830EA69C;
	sub_830E5990(ctx, base);
	// 830EA69C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA6A0: 4BFFD0B9  bl 0x830e7758
	ctx.lr = 0x830EA6A4;
	sub_830E7758(ctx, base);
	// 830EA6A4: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 830EA6A8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830EA6AC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA6B0: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 830EA6B4: 4BFF5BED  bl 0x830e02a0
	ctx.lr = 0x830EA6B8;
	sub_830E02A0(ctx, base);
	// 830EA6B8: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 830EA6BC: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EA6C0: 3D408030  lis r10, -0x7fd0
	ctx.r[10].s64 = -2144337920;
	// 830EA6C4: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830EA6C8: 615E0025  ori r30, r10, 0x25
	ctx.r[30].u64 = ctx.r[10].u64 | 37;
	// 830EA6CC: 697C0001  xori r28, r11, 1
	ctx.r[28].u64 = ctx.r[11].u64 ^ 1;
	// 830EA6D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830EA6D4: 419A0030  beq cr6, 0x830ea704
	if ctx.cr[6].eq {
	pc = 0x830EA704; continue 'dispatch;
	}
	// 830EA6D8: A1630000  lhz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA6DC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EA6E0: 41820024  beq 0x830ea704
	if ctx.cr[0].eq {
	pc = 0x830EA704; continue 'dispatch;
	}
	// 830EA6E4: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 830EA6E8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830EA6EC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830EA6F0: 4BFF9939  bl 0x830e4028
	ctx.lr = 0x830EA6F4;
	sub_830E4028(ctx, base);
	// 830EA6F4: 7F03F000  cmpw cr6, r3, r30
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[30].s32, &mut ctx.xer);
	// 830EA6F8: 409A000C  bne cr6, 0x830ea704
	if !ctx.cr[6].eq {
	pc = 0x830EA704; continue 'dispatch;
	}
	// 830EA6FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830EA700: 48000120  b 0x830ea820
	pc = 0x830EA820; continue 'dispatch;
	// 830EA704: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EA708: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EA70C: 409A00BC  bne cr6, 0x830ea7c8
	if !ctx.cr[6].eq {
	pc = 0x830EA7C8; continue 'dispatch;
	}
	// 830EA710: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EA714: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EA718: 419A0020  beq cr6, 0x830ea738
	if ctx.cr[6].eq {
	pc = 0x830EA738; continue 'dispatch;
	}
	// 830EA71C: A16B0000  lhz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA720: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EA724: 41820014  beq 0x830ea738
	if ctx.cr[0].eq {
	pc = 0x830EA738; continue 'dispatch;
	}
	// 830EA728: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 830EA72C: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 830EA730: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA734: 4BFF554D  bl 0x830dfc80
	ctx.lr = 0x830EA738;
	sub_830DFC80(ctx, base);
	// 830EA738: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA73C: 4BFE44D5  bl 0x830cec10
	ctx.lr = 0x830EA740;
	sub_830CEC10(ctx, base);
	// 830EA740: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 830EA744: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EA748: 41820058  beq 0x830ea7a0
	if ctx.cr[0].eq {
	pc = 0x830EA7A0; continue 'dispatch;
	}
	// 830EA74C: 4BFE3E75  bl 0x830ce5c0
	ctx.lr = 0x830EA750;
	sub_830CE5C0(ctx, base);
	// 830EA750: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830EA754: 4BFE3C8D  bl 0x830ce3e0
	ctx.lr = 0x830EA758;
	sub_830CE3E0(ctx, base);
	// 830EA758: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830EA75C: 418000C4  blt 0x830ea820
	if ctx.cr[0].lt {
	pc = 0x830EA820; continue 'dispatch;
	}
	// 830EA760: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 830EA764: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 830EA768: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830EA76C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830EA770: 4BFF98B9  bl 0x830e4028
	ctx.lr = 0x830EA774;
	sub_830E4028(ctx, base);
	// 830EA774: 7F03F000  cmpw cr6, r3, r30
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[30].s32, &mut ctx.xer);
	// 830EA778: 419AFF84  beq cr6, 0x830ea6fc
	if ctx.cr[6].eq {
	pc = 0x830EA6FC; continue 'dispatch;
	}
	// 830EA77C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EA780: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EA784: 409A0044  bne cr6, 0x830ea7c8
	if !ctx.cr[6].eq {
	pc = 0x830EA7C8; continue 'dispatch;
	}
	// 830EA788: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 830EA78C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830EA790: 4BFE3D89  bl 0x830ce518
	ctx.lr = 0x830EA794;
	sub_830CE518(ctx, base);
	// 830EA794: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830EA798: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830EA79C: 409AFFB0  bne cr6, 0x830ea74c
	if !ctx.cr[6].eq {
	pc = 0x830EA74C; continue 'dispatch;
	}
	// 830EA7A0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EA7A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EA7A8: 409A0020  bne cr6, 0x830ea7c8
	if !ctx.cr[6].eq {
	pc = 0x830EA7C8; continue 'dispatch;
	}
	// 830EA7AC: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 830EA7B0: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 830EA7B4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA7B8: 4BFF54C9  bl 0x830dfc80
	ctx.lr = 0x830EA7BC;
	sub_830DFC80(ctx, base);
	// 830EA7BC: 3C608030  lis r3, -0x7fd0
	ctx.r[3].s64 = -2144337920;
	// 830EA7C0: 60630026  ori r3, r3, 0x26
	ctx.r[3].u64 = ctx.r[3].u64 | 38;
	// 830EA7C4: 4800005C  b 0x830ea820
	pc = 0x830EA820; continue 'dispatch;
	// 830EA7C8: 93610058  stw r27, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[27].u32 ) };
	// 830EA7CC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830EA7D0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA7D4: 4BFF4FFD  bl 0x830df7d0
	ctx.lr = 0x830EA7D8;
	sub_830DF7D0(ctx, base);
	// 830EA7D8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830EA7DC: 4BFF4DB5  bl 0x830df590
	ctx.lr = 0x830EA7E0;
	sub_830DF590(ctx, base);
	// 830EA7E0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830EA7E4: 80C10058  lwz r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830EA7E8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA7EC: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EA7F0: 4BFF51C1  bl 0x830df9b0
	ctx.lr = 0x830EA7F4;
	sub_830DF9B0(ctx, base);
	// 830EA7F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830EA7F8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830EA7FC: 4BFF4D95  bl 0x830df590
	ctx.lr = 0x830EA800;
	sub_830DF590(ctx, base);
	// 830EA800: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830EA804: 4198FEF8  blt cr6, 0x830ea6fc
	if ctx.cr[6].lt {
	pc = 0x830EA6FC; continue 'dispatch;
	}
	// 830EA808: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EA80C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830EA810: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EA814: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 830EA818: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 830EA81C: 4BFF7545  bl 0x830e1d60
	ctx.lr = 0x830EA820;
	sub_830E1D60(ctx, base);
	// 830EA820: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 830EA824: 480BD990  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EA828(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EA828 size=240
    let mut pc: u32 = 0x830EA828;
    'dispatch: loop {
        match pc {
            0x830EA828 => {
    //   block [0x830EA828..0x830EA918)
	// 830EA828: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EA82C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830EA830: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830EA834: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830EA838: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EA83C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830EA840: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830EA844: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830EA848: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830EA84C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830EA850: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 830EA854: 4BFE3C1D  bl 0x830ce470
	ctx.lr = 0x830EA858;
	sub_830CE470(ctx, base);
	// 830EA858: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EA85C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EA860: 409A0010  bne cr6, 0x830ea870
	if !ctx.cr[6].eq {
	pc = 0x830EA870; continue 'dispatch;
	}
	// 830EA864: 3C608030  lis r3, -0x7fd0
	ctx.r[3].s64 = -2144337920;
	// 830EA868: 6063000A  ori r3, r3, 0xa
	ctx.r[3].u64 = ctx.r[3].u64 | 10;
	// 830EA86C: 48000094  b 0x830ea900
	pc = 0x830EA900; continue 'dispatch;
	// 830EA870: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA874: 2F0A0005  cmpwi cr6, r10, 5
	ctx.cr[6].compare_i32(ctx.r[10].s32, 5, &mut ctx.xer);
	// 830EA878: 419A0010  beq cr6, 0x830ea888
	if ctx.cr[6].eq {
	pc = 0x830EA888; continue 'dispatch;
	}
	// 830EA87C: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 830EA880: 60630057  ori r3, r3, 0x57
	ctx.r[3].u64 = ctx.r[3].u64 | 87;
	// 830EA884: 4800007C  b 0x830ea900
	pc = 0x830EA900; continue 'dispatch;
	// 830EA888: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EA88C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830EA890: 409A0018  bne cr6, 0x830ea8a8
	if !ctx.cr[6].eq {
	pc = 0x830EA8A8; continue 'dispatch;
	}
	// 830EA894: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EA898: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 830EA89C: 419A0060  beq cr6, 0x830ea8fc
	if ctx.cr[6].eq {
	pc = 0x830EA8FC; continue 'dispatch;
	}
	// 830EA8A0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830EA8A4: 419A0024  beq cr6, 0x830ea8c8
	if ctx.cr[6].eq {
	pc = 0x830EA8C8; continue 'dispatch;
	}
	// 830EA8A8: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EA8AC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830EA8B0: 419A0018  beq cr6, 0x830ea8c8
	if ctx.cr[6].eq {
	pc = 0x830EA8C8; continue 'dispatch;
	}
	// 830EA8B4: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EA8B8: 480C7579  bl 0x831b1e30
	ctx.lr = 0x830EA8BC;
	sub_831B1E30(ctx, base);
	// 830EA8BC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830EA8C0: 4182003C  beq 0x830ea8fc
	if ctx.cr[0].eq {
	pc = 0x830EA8FC; continue 'dispatch;
	}
	// 830EA8C4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EA8C8: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 830EA8CC: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EA8D0: 4BFE43B9  bl 0x830cec88
	ctx.lr = 0x830EA8D4;
	sub_830CEC88(ctx, base);
	// 830EA8D4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830EA8D8: 41800028  blt 0x830ea900
	if ctx.cr[0].lt {
	pc = 0x830EA900; continue 'dispatch;
	}
	// 830EA8DC: 38800009  li r4, 9
	ctx.r[4].s64 = 9;
	// 830EA8E0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830EA8E4: 4801770D  bl 0x83101ff0
	ctx.lr = 0x830EA8E8;
	sub_83101FF0(ctx, base);
	// 830EA8E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830EA8EC: 3BE10060  addi r31, r1, 0x60
	ctx.r[31].s64 = ctx.r[1].s64 + 96;
	// 830EA8F0: 4BFE4321  bl 0x830cec10
	ctx.lr = 0x830EA8F4;
	sub_830CEC10(ctx, base);
	// 830EA8F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830EA8F8: 4BFEB2D1  bl 0x830d5bc8
	ctx.lr = 0x830EA8FC;
	sub_830D5BC8(ctx, base);
	// 830EA8FC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830EA900: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830EA904: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830EA908: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830EA90C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830EA910: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830EA914: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EA918(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EA918 size=84
    let mut pc: u32 = 0x830EA918;
    'dispatch: loop {
        match pc {
            0x830EA918 => {
    //   block [0x830EA918..0x830EA96C)
	// 830EA918: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EA91C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830EA920: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830EA924: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EA928: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA92C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830EA930: 419A0010  beq cr6, 0x830ea940
	if ctx.cr[6].eq {
	pc = 0x830EA940; continue 'dispatch;
	}
	// 830EA934: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 830EA938: 60630057  ori r3, r3, 0x57
	ctx.r[3].u64 = ctx.r[3].u64 | 87;
	// 830EA93C: 4800001C  b 0x830ea958
	pc = 0x830EA958; continue 'dispatch;
	// 830EA940: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 830EA944: 83E50004  lwz r31, 4(r5)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EA948: 4BFE42C9  bl 0x830cec10
	ctx.lr = 0x830EA94C;
	sub_830CEC10(ctx, base);
	// 830EA94C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830EA950: 4BFFD3A9  bl 0x830e7cf8
	ctx.lr = 0x830EA954;
	sub_830E7CF8(ctx, base);
	// 830EA954: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830EA958: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830EA95C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830EA960: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830EA964: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830EA968: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EA970(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EA970 size=92
    let mut pc: u32 = 0x830EA970;
    'dispatch: loop {
        match pc {
            0x830EA970 => {
    //   block [0x830EA970..0x830EA9CC)
	// 830EA970: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EA974: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830EA978: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830EA97C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EA980: 4BFE4291  bl 0x830cec10
	ctx.lr = 0x830EA984;
	sub_830CEC10(ctx, base);
	// 830EA984: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830EA988: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830EA98C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830EA990: 48019159  bl 0x83103ae8
	ctx.lr = 0x830EA994;
	sub_83103AE8(ctx, base);
	// 830EA994: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830EA998: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EA99C: 4BFEB22D  bl 0x830d5bc8
	ctx.lr = 0x830EA9A0;
	sub_830D5BC8(ctx, base);
	// 830EA9A0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EA9A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EA9A8: 419A0010  beq cr6, 0x830ea9b8
	if ctx.cr[6].eq {
	pc = 0x830EA9B8; continue 'dispatch;
	}
	// 830EA9AC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830EA9B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EA9B4: 4BFF1D9D  bl 0x830dc750
	ctx.lr = 0x830EA9B8;
	sub_830DC750(ctx, base);
	// 830EA9B8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830EA9BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830EA9C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830EA9C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830EA9C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EA9D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EA9D0 size=88
    let mut pc: u32 = 0x830EA9D0;
    'dispatch: loop {
        match pc {
            0x830EA9D0 => {
    //   block [0x830EA9D0..0x830EAA28)
	// 830EA9D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EA9D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830EA9D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830EA9DC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EA9E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830EA9E4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830EA9E8: 419A002C  beq cr6, 0x830eaa14
	if ctx.cr[6].eq {
	pc = 0x830EAA14; continue 'dispatch;
	}
	// 830EA9EC: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EA9F0: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 830EA9F4: 4098000C  bge cr6, 0x830eaa00
	if !ctx.cr[6].lt {
	pc = 0x830EAA00; continue 'dispatch;
	}
	// 830EA9F8: 4B3717B1  bl 0x8245c1a8
	ctx.lr = 0x830EA9FC;
	sub_8245C1A8(ctx, base);
	// 830EA9FC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830EAA00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EAA04: 48015175  bl 0x830ffb78
	ctx.lr = 0x830EAA08;
	sub_830FFB78(ctx, base);
	// 830EAA08: 3880000F  li r4, 0xf
	ctx.r[4].s64 = 15;
	// 830EAA0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EAA10: 48014D81  bl 0x830ff790
	ctx.lr = 0x830EAA14;
	sub_830FF790(ctx, base);
	// 830EAA14: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830EAA18: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830EAA1C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830EAA20: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830EAA24: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EAA28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EAA28 size=176
    let mut pc: u32 = 0x830EAA28;
    'dispatch: loop {
        match pc {
            0x830EAA28 => {
    //   block [0x830EAA28..0x830EAAD8)
	// 830EAA28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EAA2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830EAA30: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830EAA34: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EAA38: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830EAA3C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830EAA40: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 830EAA44: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 830EAA48: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 830EAA4C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830EAA50: 409A0018  bne cr6, 0x830eaa68
	if !ctx.cr[6].eq {
	pc = 0x830EAA68; continue 'dispatch;
	}
	// 830EAA54: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830EAA58: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EAA5C: 4BFF5655  bl 0x830e00b0
	ctx.lr = 0x830EAA60;
	sub_830E00B0(ctx, base);
	// 830EAA60: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EAA64: 4BFFFF6D  bl 0x830ea9d0
	ctx.lr = 0x830EAA68;
	sub_830EA9D0(ctx, base);
	// 830EAA68: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 830EAA6C: 556B07BC  rlwinm r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830EAA70: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 830EAA74: 409A0050  bne cr6, 0x830eaac4
	if !ctx.cr[6].eq {
	pc = 0x830EAAC4; continue 'dispatch;
	}
	// 830EAA78: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 830EAA7C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EAA80: 4BFF4CD9  bl 0x830df758
	ctx.lr = 0x830EAA84;
	sub_830DF758(ctx, base);
	// 830EAA84: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830EAA88: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830EAA8C: 419A0038  beq cr6, 0x830eaac4
	if ctx.cr[6].eq {
	pc = 0x830EAAC4; continue 'dispatch;
	}
	// 830EAA90: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830EAA94: 808BC0A8  lwz r4, -0x3f58(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16216 as u32) ) } as u64;
	// 830EAA98: 4BFE40D9  bl 0x830ceb70
	ctx.lr = 0x830EAA9C;
	sub_830CEB70(ctx, base);
	// 830EAA9C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EAAA0: 41820024  beq 0x830eaac4
	if ctx.cr[0].eq {
	pc = 0x830EAAC4; continue 'dispatch;
	}
	// 830EAAA4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830EAAA8: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830EAAAC: 4BFF5605  bl 0x830e00b0
	ctx.lr = 0x830EAAB0;
	sub_830E00B0(ctx, base);
	// 830EAAB0: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EAAB4: 4BFFFF1D  bl 0x830ea9d0
	ctx.lr = 0x830EAAB8;
	sub_830EA9D0(ctx, base);
	// 830EAAB8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830EAABC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EAAC0: 4BFF5649  bl 0x830e0108
	ctx.lr = 0x830EAAC4;
	sub_830E0108(ctx, base);
	// 830EAAC4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830EAAC8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830EAACC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830EAAD0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830EAAD4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EAAD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EAAD8 size=252
    let mut pc: u32 = 0x830EAAD8;
    'dispatch: loop {
        match pc {
            0x830EAAD8 => {
    //   block [0x830EAAD8..0x830EABD4)
	// 830EAAD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EAADC: 480BD689  bl 0x831a8164
	ctx.lr = 0x830EAAE0;
	sub_831A8130(ctx, base);
	// 830EAAE0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EAAE4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830EAAE8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 830EAAEC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 830EAAF0: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 830EAAF4: 2B055840  cmplwi cr6, r5, 0x5840
	ctx.cr[6].compare_u32(ctx.r[5].u32, 22592 as u32, &mut ctx.xer);
	// 830EAAF8: 83DD0010  lwz r30, 0x10(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EAAFC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EAB00: 419A0030  beq cr6, 0x830eab30
	if ctx.cr[6].eq {
	pc = 0x830EAB30; continue 'dispatch;
	}
	// 830EAB04: 2B055841  cmplwi cr6, r5, 0x5841
	ctx.cr[6].compare_u32(ctx.r[5].u32, 22593 as u32, &mut ctx.xer);
	// 830EAB08: 419A0010  beq cr6, 0x830eab18
	if ctx.cr[6].eq {
	pc = 0x830EAB18; continue 'dispatch;
	}
	// 830EAB0C: 7F0B2840  cmplw cr6, r11, r5
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[5].u32, &mut ctx.xer);
	// 830EAB10: 409A0054  bne cr6, 0x830eab64
	if !ctx.cr[6].eq {
	pc = 0x830EAB64; continue 'dispatch;
	}
	// 830EAB14: 4800004C  b 0x830eab60
	pc = 0x830EAB60; continue 'dispatch;
	// 830EAB18: 2B0B5801  cmplwi cr6, r11, 0x5801
	ctx.cr[6].compare_u32(ctx.r[11].u32, 22529 as u32, &mut ctx.xer);
	// 830EAB1C: 419A0044  beq cr6, 0x830eab60
	if ctx.cr[6].eq {
	pc = 0x830EAB60; continue 'dispatch;
	}
	// 830EAB20: 2B0B5815  cmplwi cr6, r11, 0x5815
	ctx.cr[6].compare_u32(ctx.r[11].u32, 22549 as u32, &mut ctx.xer);
	// 830EAB24: 419A003C  beq cr6, 0x830eab60
	if ctx.cr[6].eq {
	pc = 0x830EAB60; continue 'dispatch;
	}
	// 830EAB28: 2B0B001B  cmplwi cr6, r11, 0x1b
	ctx.cr[6].compare_u32(ctx.r[11].u32, 27 as u32, &mut ctx.xer);
	// 830EAB2C: 48000020  b 0x830eab4c
	pc = 0x830EAB4C; continue 'dispatch;
	// 830EAB30: 2B0B5800  cmplwi cr6, r11, 0x5800
	ctx.cr[6].compare_u32(ctx.r[11].u32, 22528 as u32, &mut ctx.xer);
	// 830EAB34: 419A002C  beq cr6, 0x830eab60
	if ctx.cr[6].eq {
	pc = 0x830EAB60; continue 'dispatch;
	}
	// 830EAB38: 2B0B5814  cmplwi cr6, r11, 0x5814
	ctx.cr[6].compare_u32(ctx.r[11].u32, 22548 as u32, &mut ctx.xer);
	// 830EAB3C: 419A0024  beq cr6, 0x830eab60
	if ctx.cr[6].eq {
	pc = 0x830EAB60; continue 'dispatch;
	}
	// 830EAB40: 2B0B000D  cmplwi cr6, r11, 0xd
	ctx.cr[6].compare_u32(ctx.r[11].u32, 13 as u32, &mut ctx.xer);
	// 830EAB44: 419A000C  beq cr6, 0x830eab50
	if ctx.cr[6].eq {
	pc = 0x830EAB50; continue 'dispatch;
	}
	// 830EAB48: 2B0B0020  cmplwi cr6, r11, 0x20
	ctx.cr[6].compare_u32(ctx.r[11].u32, 32 as u32, &mut ctx.xer);
	// 830EAB4C: 409A0018  bne cr6, 0x830eab64
	if !ctx.cr[6].eq {
	pc = 0x830EAB64; continue 'dispatch;
	}
	// 830EAB50: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830EAB54: 816BC180  lwz r11, -0x3e80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16000 as u32) ) } as u64;
	// 830EAB58: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EAB5C: 40820008  bne 0x830eab64
	if !ctx.cr[0].eq {
	pc = 0x830EAB64; continue 'dispatch;
	}
	// 830EAB60: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 830EAB64: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830EAB68: 4BFFD1D9  bl 0x830e7d40
	ctx.lr = 0x830EAB6C;
	sub_830E7D40(ctx, base);
	// 830EAB6C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830EAB70: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830EAB74: 41820020  beq 0x830eab94
	if ctx.cr[0].eq {
	pc = 0x830EAB94; continue 'dispatch;
	}
	// 830EAB78: 939D0008  stw r28, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 830EAB7C: 419A0050  beq cr6, 0x830eabcc
	if ctx.cr[6].eq {
	pc = 0x830EABCC; continue 'dispatch;
	}
	// 830EAB80: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830EAB84: 889E000C  lbz r4, 0xc(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EAB88: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830EAB8C: 4BFFEF0D  bl 0x830e9a98
	ctx.lr = 0x830EAB90;
	sub_830E9A98(ctx, base);
	// 830EAB90: 4800003C  b 0x830eabcc
	pc = 0x830EABCC; continue 'dispatch;
	// 830EAB94: 419A0038  beq cr6, 0x830eabcc
	if ctx.cr[6].eq {
	pc = 0x830EABCC; continue 'dispatch;
	}
	// 830EAB98: 939D0008  stw r28, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 830EAB9C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EABA0: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 830EABA4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830EABA8: 419A0024  beq cr6, 0x830eabcc
	if ctx.cr[6].eq {
	pc = 0x830EABCC; continue 'dispatch;
	}
	// 830EABAC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830EABB0: 88BE000C  lbz r5, 0xc(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EABB4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830EABB8: 4BFFC9A1  bl 0x830e7558
	ctx.lr = 0x830EABBC;
	sub_830E7558(ctx, base);
	// 830EABBC: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 830EABC0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830EABC4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830EABC8: 4BFEB001  bl 0x830d5bc8
	ctx.lr = 0x830EABCC;
	sub_830D5BC8(ctx, base);
	// 830EABCC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 830EABD0: 480BD5E4  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EABD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EABD8 size=228
    let mut pc: u32 = 0x830EABD8;
    'dispatch: loop {
        match pc {
            0x830EABD8 => {
    //   block [0x830EABD8..0x830EACBC)
	// 830EABD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EABDC: 480BD58D  bl 0x831a8168
	ctx.lr = 0x830EABE0;
	sub_831A8130(ctx, base);
	// 830EABE0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EABE4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830EABE8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830EABEC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830EABF0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830EABF4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830EABF8: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 830EABFC: 4BFF695D  bl 0x830e1558
	ctx.lr = 0x830EAC00;
	sub_830E1558(ctx, base);
	// 830EAC00: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EAC04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EAC08: 419A00AC  beq cr6, 0x830eacb4
	if ctx.cr[6].eq {
	pc = 0x830EACB4; continue 'dispatch;
	}
	// 830EAC0C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EAC10: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EAC14: 419A000C  beq cr6, 0x830eac20
	if ctx.cr[6].eq {
	pc = 0x830EAC20; continue 'dispatch;
	}
	// 830EAC18: 83BE0004  lwz r29, 4(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EAC1C: 48000010  b 0x830eac2c
	pc = 0x830EAC2C; continue 'dispatch;
	// 830EAC20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EAC24: 4BFF67E5  bl 0x830e1408
	ctx.lr = 0x830EAC28;
	sub_830E1408(ctx, base);
	// 830EAC28: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830EAC2C: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 830EAC30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EAC34: 419A0064  beq cr6, 0x830eac98
	if ctx.cr[6].eq {
	pc = 0x830EAC98; continue 'dispatch;
	}
	// 830EAC38: 4BFF5F69  bl 0x830e0ba0
	ctx.lr = 0x830EAC3C;
	sub_830E0BA0(ctx, base);
	// 830EAC3C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830EAC40: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 830EAC44: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830EAC48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EAC4C: 40820018  bne 0x830eac64
	if !ctx.cr[0].eq {
	pc = 0x830EAC64; continue 'dispatch;
	}
	// 830EAC50: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830EAC54: 3D408219  lis r10, -0x7de7
	ctx.r[10].s64 = -2112290816;
	// 830EAC58: 38AB8BD4  addi r5, r11, -0x742c
	ctx.r[5].s64 = ctx.r[11].s64 + -29740;
	// 830EAC5C: 388A8BF4  addi r4, r10, -0x740c
	ctx.r[4].s64 = ctx.r[10].s64 + -29708;
	// 830EAC60: 48000030  b 0x830eac90
	pc = 0x830EAC90; continue 'dispatch;
	// 830EAC64: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830EAC68: 419A0018  beq cr6, 0x830eac80
	if ctx.cr[6].eq {
	pc = 0x830EAC80; continue 'dispatch;
	}
	// 830EAC6C: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830EAC70: 3D408219  lis r10, -0x7de7
	ctx.r[10].s64 = -2112290816;
	// 830EAC74: 38AB904C  addi r5, r11, -0x6fb4
	ctx.r[5].s64 = ctx.r[11].s64 + -28596;
	// 830EAC78: 388A9060  addi r4, r10, -0x6fa0
	ctx.r[4].s64 = ctx.r[10].s64 + -28576;
	// 830EAC7C: 48000014  b 0x830eac90
	pc = 0x830EAC90; continue 'dispatch;
	// 830EAC80: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830EAC84: 3D408219  lis r10, -0x7de7
	ctx.r[10].s64 = -2112290816;
	// 830EAC88: 38AB9014  addi r5, r11, -0x6fec
	ctx.r[5].s64 = ctx.r[11].s64 + -28652;
	// 830EAC8C: 388A9034  addi r4, r10, -0x6fcc
	ctx.r[4].s64 = ctx.r[10].s64 + -28620;
	// 830EAC90: 4BFF6AC9  bl 0x830e1758
	ctx.lr = 0x830EAC94;
	sub_830E1758(ctx, base);
	// 830EAC94: 48000020  b 0x830eacb4
	pc = 0x830EACB4; continue 'dispatch;
	// 830EAC98: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EAC9C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EACA0: 419A0010  beq cr6, 0x830eacb0
	if ctx.cr[6].eq {
	pc = 0x830EACB0; continue 'dispatch;
	}
	// 830EACA4: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EACA8: 4BFF43C1  bl 0x830df068
	ctx.lr = 0x830EACAC;
	sub_830DF068(ctx, base);
	// 830EACAC: 48000008  b 0x830eacb4
	pc = 0x830EACB4; continue 'dispatch;
	// 830EACB0: 4BFF4359  bl 0x830df008
	ctx.lr = 0x830EACB4;
	sub_830DF008(ctx, base);
	// 830EACB4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830EACB8: 480BD500  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EACC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EACC0 size=156
    let mut pc: u32 = 0x830EACC0;
    'dispatch: loop {
        match pc {
            0x830EACC0 => {
    //   block [0x830EACC0..0x830EAD5C)
	// 830EACC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EACC4: 480BD4A9  bl 0x831a816c
	ctx.lr = 0x830EACC8;
	sub_831A8130(ctx, base);
	// 830EACC8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EACCC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830EACD0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830EACD4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EACD8: 2B0B0024  cmplwi cr6, r11, 0x24
	ctx.cr[6].compare_u32(ctx.r[11].u32, 36 as u32, &mut ctx.xer);
	// 830EACDC: 419A0038  beq cr6, 0x830ead14
	if ctx.cr[6].eq {
	pc = 0x830EAD14; continue 'dispatch;
	}
	// 830EACE0: 2B0B07D6  cmplwi cr6, r11, 0x7d6
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2006 as u32, &mut ctx.xer);
	// 830EACE4: 409A006C  bne cr6, 0x830ead50
	if !ctx.cr[6].eq {
	pc = 0x830EAD50; continue 'dispatch;
	}
	// 830EACE8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830EACEC: 83BF0010  lwz r29, 0x10(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EACF0: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830EACF4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EACF8: 4BFE3F19  bl 0x830cec10
	ctx.lr = 0x830EACFC;
	sub_830CEC10(ctx, base);
	// 830EACFC: 4BFFD045  bl 0x830e7d40
	ctx.lr = 0x830EAD00;
	sub_830E7D40(ctx, base);
	// 830EAD00: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 830EAD04: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830EAD08: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EAD0C: 4BFFFECD  bl 0x830eabd8
	ctx.lr = 0x830EAD10;
	sub_830EABD8(ctx, base);
	// 830EAD10: 48000040  b 0x830ead50
	pc = 0x830EAD50; continue 'dispatch;
	// 830EAD14: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EAD18: 886B000C  lbz r3, 0xc(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EAD1C: 4BFF3E7D  bl 0x830deb98
	ctx.lr = 0x830EAD20;
	sub_830DEB98(ctx, base);
	// 830EAD20: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EAD24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EAD28: 419A0010  beq cr6, 0x830ead38
	if ctx.cr[6].eq {
	pc = 0x830EAD38; continue 'dispatch;
	}
	// 830EAD2C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830EAD30: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830EAD34: 4800001C  b 0x830ead50
	pc = 0x830EAD50; continue 'dispatch;
	// 830EAD38: 83BE0004  lwz r29, 4(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EAD3C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EAD40: 4BFE3ED1  bl 0x830cec10
	ctx.lr = 0x830EAD44;
	sub_830CEC10(ctx, base);
	// 830EAD44: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830EAD48: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830EAD4C: 4BFFFD8D  bl 0x830eaad8
	ctx.lr = 0x830EAD50;
	sub_830EAAD8(ctx, base);
	// 830EAD50: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830EAD54: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830EAD58: 480BD464  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EAD60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EAD60 size=376
    let mut pc: u32 = 0x830EAD60;
    'dispatch: loop {
        match pc {
            0x830EAD60 => {
    //   block [0x830EAD60..0x830EAED8)
	// 830EAD60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EAD64: 480BD405  bl 0x831a8168
	ctx.lr = 0x830EAD68;
	sub_831A8130(ctx, base);
	// 830EAD68: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EAD6C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830EAD70: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830EAD74: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830EAD78: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830EAD7C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830EAD80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EAD84: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 830EAD88: 4BFF67D1  bl 0x830e1558
	ctx.lr = 0x830EAD8C;
	sub_830E1558(ctx, base);
	// 830EAD8C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EAD90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EAD94: 419A013C  beq cr6, 0x830eaed0
	if ctx.cr[6].eq {
	pc = 0x830EAED0; continue 'dispatch;
	}
	// 830EAD98: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EAD9C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EADA0: 419A000C  beq cr6, 0x830eadac
	if ctx.cr[6].eq {
	pc = 0x830EADAC; continue 'dispatch;
	}
	// 830EADA4: 839D0004  lwz r28, 4(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EADA8: 48000010  b 0x830eadb8
	pc = 0x830EADB8; continue 'dispatch;
	// 830EADAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EADB0: 4BFF6659  bl 0x830e1408
	ctx.lr = 0x830EADB4;
	sub_830E1408(ctx, base);
	// 830EADB4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 830EADB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EADBC: 4BFE3E55  bl 0x830cec10
	ctx.lr = 0x830EADC0;
	sub_830CEC10(ctx, base);
	// 830EADC0: 4BFF5DE1  bl 0x830e0ba0
	ctx.lr = 0x830EADC4;
	sub_830E0BA0(ctx, base);
	// 830EADC4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EADC8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830EADCC: 556B07BC  rlwinm r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830EADD0: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 830EADD4: 409A00DC  bne cr6, 0x830eaeb0
	if !ctx.cr[6].eq {
	pc = 0x830EAEB0; continue 'dispatch;
	}
	// 830EADD8: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 830EADDC: 419A0094  beq cr6, 0x830eae70
	if ctx.cr[6].eq {
	pc = 0x830EAE70; continue 'dispatch;
	}
	// 830EADE0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EADE4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EADE8: 419A004C  beq cr6, 0x830eae34
	if ctx.cr[6].eq {
	pc = 0x830EAE34; continue 'dispatch;
	}
	// 830EADEC: 4BFF401D  bl 0x830dee08
	ctx.lr = 0x830EADF0;
	sub_830DEE08(ctx, base);
	// 830EADF0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830EADF4: 41820040  beq 0x830eae34
	if ctx.cr[0].eq {
	pc = 0x830EAE34; continue 'dispatch;
	}
	// 830EADF8: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830EADFC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 830EAE00: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830EAE04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EAE08: 419A0018  beq cr6, 0x830eae20
	if ctx.cr[6].eq {
	pc = 0x830EAE20; continue 'dispatch;
	}
	// 830EAE0C: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830EAE10: 3D408219  lis r10, -0x7de7
	ctx.r[10].s64 = -2112290816;
	// 830EAE14: 38AB8C70  addi r5, r11, -0x7390
	ctx.r[5].s64 = ctx.r[11].s64 + -29584;
	// 830EAE18: 388A8C94  addi r4, r10, -0x736c
	ctx.r[4].s64 = ctx.r[10].s64 + -29548;
	// 830EAE1C: 4800008C  b 0x830eaea8
	pc = 0x830EAEA8; continue 'dispatch;
	// 830EAE20: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830EAE24: 3D408219  lis r10, -0x7de7
	ctx.r[10].s64 = -2112290816;
	// 830EAE28: 38AB8C10  addi r5, r11, -0x73f0
	ctx.r[5].s64 = ctx.r[11].s64 + -29680;
	// 830EAE2C: 388A8C44  addi r4, r10, -0x73bc
	ctx.r[4].s64 = ctx.r[10].s64 + -29628;
	// 830EAE30: 48000078  b 0x830eaea8
	pc = 0x830EAEA8; continue 'dispatch;
	// 830EAE34: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830EAE38: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 830EAE3C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830EAE40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EAE44: 419A0018  beq cr6, 0x830eae5c
	if ctx.cr[6].eq {
	pc = 0x830EAE5C; continue 'dispatch;
	}
	// 830EAE48: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830EAE4C: 3D408219  lis r10, -0x7de7
	ctx.r[10].s64 = -2112290816;
	// 830EAE50: 38AB8FA8  addi r5, r11, -0x7058
	ctx.r[5].s64 = ctx.r[11].s64 + -28760;
	// 830EAE54: 388A8FC4  addi r4, r10, -0x703c
	ctx.r[4].s64 = ctx.r[10].s64 + -28732;
	// 830EAE58: 48000050  b 0x830eaea8
	pc = 0x830EAEA8; continue 'dispatch;
	// 830EAE5C: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830EAE60: 3D408219  lis r10, -0x7de7
	ctx.r[10].s64 = -2112290816;
	// 830EAE64: 38AB8F04  addi r5, r11, -0x70fc
	ctx.r[5].s64 = ctx.r[11].s64 + -28924;
	// 830EAE68: 388A8F30  addi r4, r10, -0x70d0
	ctx.r[4].s64 = ctx.r[10].s64 + -28880;
	// 830EAE6C: 4800003C  b 0x830eaea8
	pc = 0x830EAEA8; continue 'dispatch;
	// 830EAE70: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830EAE74: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 830EAE78: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830EAE7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EAE80: 419A0018  beq cr6, 0x830eae98
	if ctx.cr[6].eq {
	pc = 0x830EAE98; continue 'dispatch;
	}
	// 830EAE84: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830EAE88: 3D408219  lis r10, -0x7de7
	ctx.r[10].s64 = -2112290816;
	// 830EAE8C: 38AB8FDC  addi r5, r11, -0x7024
	ctx.r[5].s64 = ctx.r[11].s64 + -28708;
	// 830EAE90: 388A8FFC  addi r4, r10, -0x7004
	ctx.r[4].s64 = ctx.r[10].s64 + -28676;
	// 830EAE94: 48000014  b 0x830eaea8
	pc = 0x830EAEA8; continue 'dispatch;
	// 830EAE98: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 830EAE9C: 3D408219  lis r10, -0x7de7
	ctx.r[10].s64 = -2112290816;
	// 830EAEA0: 38AB8F54  addi r5, r11, -0x70ac
	ctx.r[5].s64 = ctx.r[11].s64 + -28844;
	// 830EAEA4: 388A8F80  addi r4, r10, -0x7080
	ctx.r[4].s64 = ctx.r[10].s64 + -28800;
	// 830EAEA8: 4BFF68B1  bl 0x830e1758
	ctx.lr = 0x830EAEAC;
	sub_830E1758(ctx, base);
	// 830EAEAC: 48000024  b 0x830eaed0
	pc = 0x830EAED0; continue 'dispatch;
	// 830EAEB0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EAEB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EAEB8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EAEBC: 419A0010  beq cr6, 0x830eaecc
	if ctx.cr[6].eq {
	pc = 0x830EAECC; continue 'dispatch;
	}
	// 830EAEC0: 809D0004  lwz r4, 4(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EAEC4: 4BFF41A5  bl 0x830df068
	ctx.lr = 0x830EAEC8;
	sub_830DF068(ctx, base);
	// 830EAEC8: 48000008  b 0x830eaed0
	pc = 0x830EAED0; continue 'dispatch;
	// 830EAECC: 4BFF413D  bl 0x830df008
	ctx.lr = 0x830EAED0;
	sub_830DF008(ctx, base);
	// 830EAED0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830EAED4: 480BD2E4  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EAED8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EAED8 size=176
    let mut pc: u32 = 0x830EAED8;
    'dispatch: loop {
        match pc {
            0x830EAED8 => {
    //   block [0x830EAED8..0x830EAF88)
	// 830EAED8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EAEDC: 480BD291  bl 0x831a816c
	ctx.lr = 0x830EAEE0;
	sub_831A8130(ctx, base);
	// 830EAEE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EAEE4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830EAEE8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830EAEEC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830EAEF0: 419A002C  beq cr6, 0x830eaf1c
	if ctx.cr[6].eq {
	pc = 0x830EAF1C; continue 'dispatch;
	}
	// 830EAEF4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830EAEF8: 4BFE3D19  bl 0x830cec10
	ctx.lr = 0x830EAEFC;
	sub_830CEC10(ctx, base);
	// 830EAEFC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830EAF00: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EAF04: 4BFF4F6D  bl 0x830dfe70
	ctx.lr = 0x830EAF08;
	sub_830DFE70(ctx, base);
	// 830EAF08: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830EAF0C: 40820010  bne 0x830eaf1c
	if !ctx.cr[0].eq {
	pc = 0x830EAF1C; continue 'dispatch;
	}
	// 830EAF10: 3C608030  lis r3, -0x7fd0
	ctx.r[3].s64 = -2144337920;
	// 830EAF14: 60630017  ori r3, r3, 0x17
	ctx.r[3].u64 = ctx.r[3].u64 | 23;
	// 830EAF18: 48000068  b 0x830eaf80
	pc = 0x830EAF80; continue 'dispatch;
	// 830EAF1C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EAF20: 7F1E1840  cmplw cr6, r30, r3
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[3].u32, &mut ctx.xer);
	// 830EAF24: 419A0058  beq cr6, 0x830eaf7c
	if ctx.cr[6].eq {
	pc = 0x830EAF7C; continue 'dispatch;
	}
	// 830EAF28: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830EAF2C: 419A000C  beq cr6, 0x830eaf38
	if ctx.cr[6].eq {
	pc = 0x830EAF38; continue 'dispatch;
	}
	// 830EAF30: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830EAF34: 4BFFCF6D  bl 0x830e7ea0
	ctx.lr = 0x830EAF38;
	sub_830E7EA0(ctx, base);
	// 830EAF38: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830EAF3C: 419A0010  beq cr6, 0x830eaf4c
	if ctx.cr[6].eq {
	pc = 0x830EAF4C; continue 'dispatch;
	}
	// 830EAF40: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830EAF44: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830EAF48: 4BFFCF59  bl 0x830e7ea0
	ctx.lr = 0x830EAF4C;
	sub_830E7EA0(ctx, base);
	// 830EAF4C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EAF50: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 830EAF54: 4BFF418D  bl 0x830df0e0
	ctx.lr = 0x830EAF58;
	sub_830DF0E0(ctx, base);
	// 830EAF58: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830EAF5C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EAF60: 4BFF4181  bl 0x830df0e0
	ctx.lr = 0x830EAF64;
	sub_830DF0E0(ctx, base);
	// 830EAF64: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830EAF68: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EAF6C: 4BFE3CA5  bl 0x830cec10
	ctx.lr = 0x830EAF70;
	sub_830CEC10(ctx, base);
	// 830EAF70: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830EAF74: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830EAF78: 4BFFCA91  bl 0x830e7a08
	ctx.lr = 0x830EAF7C;
	sub_830E7A08(ctx, base);
	// 830EAF7C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830EAF80: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830EAF84: 480BD238  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EAF88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EAF88 size=808
    let mut pc: u32 = 0x830EAF88;
    'dispatch: loop {
        match pc {
            0x830EAF88 => {
    //   block [0x830EAF88..0x830EB2B0)
	// 830EAF88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EAF8C: 480BD1D9  bl 0x831a8164
	ctx.lr = 0x830EAF90;
	sub_831A8130(ctx, base);
	// 830EAF90: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EAF94: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830EAF98: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830EAF9C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EAFA0: 2B0B07D4  cmplwi cr6, r11, 0x7d4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2004 as u32, &mut ctx.xer);
	// 830EAFA4: 4199027C  bgt cr6, 0x830eb220
	if ctx.cr[6].gt {
	pc = 0x830EB220; continue 'dispatch;
	}
	// 830EAFA8: 419A0260  beq cr6, 0x830eb208
	if ctx.cr[6].eq {
	pc = 0x830EB208; continue 'dispatch;
	}
	// 830EAFAC: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 830EAFB0: 419A01FC  beq cr6, 0x830eb1ac
	if ctx.cr[6].eq {
	pc = 0x830EB1AC; continue 'dispatch;
	}
	// 830EAFB4: 2B0B000C  cmplwi cr6, r11, 0xc
	ctx.cr[6].compare_u32(ctx.r[11].u32, 12 as u32, &mut ctx.xer);
	// 830EAFB8: 419A0138  beq cr6, 0x830eb0f0
	if ctx.cr[6].eq {
	pc = 0x830EB0F0; continue 'dispatch;
	}
	// 830EAFBC: 2B0B000E  cmplwi cr6, r11, 0xe
	ctx.cr[6].compare_u32(ctx.r[11].u32, 14 as u32, &mut ctx.xer);
	// 830EAFC0: 419A0064  beq cr6, 0x830eb024
	if ctx.cr[6].eq {
	pc = 0x830EB024; continue 'dispatch;
	}
	// 830EAFC4: 2B0B0020  cmplwi cr6, r11, 0x20
	ctx.cr[6].compare_u32(ctx.r[11].u32, 32 as u32, &mut ctx.xer);
	// 830EAFC8: 409A02C0  bne cr6, 0x830eb288
	if !ctx.cr[6].eq {
	pc = 0x830EB288; continue 'dispatch;
	}
	// 830EAFCC: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EAFD0: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830EAFD4: 808BC090  lwz r4, -0x3f70(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16240 as u32) ) } as u64;
	// 830EAFD8: 806A0000  lwz r3, 0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EAFDC: 4BFE3B95  bl 0x830ceb70
	ctx.lr = 0x830EAFE0;
	sub_830CEB70(ctx, base);
	// 830EAFE0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EAFE4: 40820020  bne 0x830eb004
	if !ctx.cr[0].eq {
	pc = 0x830EB004; continue 'dispatch;
	}
	// 830EAFE8: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EAFEC: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830EAFF0: 808BC094  lwz r4, -0x3f6c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16236 as u32) ) } as u64;
	// 830EAFF4: 806A0000  lwz r3, 0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EAFF8: 4BFE3B79  bl 0x830ceb70
	ctx.lr = 0x830EAFFC;
	sub_830CEB70(ctx, base);
	// 830EAFFC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EB000: 41820288  beq 0x830eb288
	if ctx.cr[0].eq {
	pc = 0x830EB288; continue 'dispatch;
	}
	// 830EB004: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EB008: 4BFFAB61  bl 0x830e5b68
	ctx.lr = 0x830EB00C;
	sub_830E5B68(ctx, base);
	// 830EB00C: 907E0008  stw r3, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 830EB010: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 830EB014: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EB018: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EB01C: 4BFF4105  bl 0x830df120
	ctx.lr = 0x830EB020;
	sub_830DF120(ctx, base);
	// 830EB020: 48000268  b 0x830eb288
	pc = 0x830EB288; continue 'dispatch;
	// 830EB024: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EB028: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EB02C: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 830EB030: 419A007C  beq cr6, 0x830eb0ac
	if ctx.cr[6].eq {
	pc = 0x830EB0AC; continue 'dispatch;
	}
	// 830EB034: 2B0A0002  cmplwi cr6, r10, 2
	ctx.cr[6].compare_u32(ctx.r[10].u32, 2 as u32, &mut ctx.xer);
	// 830EB038: 419A002C  beq cr6, 0x830eb064
	if ctx.cr[6].eq {
	pc = 0x830EB064; continue 'dispatch;
	}
	// 830EB03C: 2B0A0003  cmplwi cr6, r10, 3
	ctx.cr[6].compare_u32(ctx.r[10].u32, 3 as u32, &mut ctx.xer);
	// 830EB040: 409A0248  bne cr6, 0x830eb288
	if !ctx.cr[6].eq {
	pc = 0x830EB288; continue 'dispatch;
	}
	// 830EB044: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EB048: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EB04C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EB050: 4BFF4E21  bl 0x830dfe70
	ctx.lr = 0x830EB054;
	sub_830DFE70(ctx, base);
	// 830EB054: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830EB058: 40820230  bne 0x830eb288
	if !ctx.cr[0].eq {
	pc = 0x830EB288; continue 'dispatch;
	}
	// 830EB05C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830EB060: 48000040  b 0x830eb0a0
	pc = 0x830EB0A0; continue 'dispatch;
	// 830EB064: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EB068: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EB06C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EB070: 83EA0000  lwz r31, 0(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EB074: 4BFF4DFD  bl 0x830dfe70
	ctx.lr = 0x830EB078;
	sub_830DFE70(ctx, base);
	// 830EB078: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830EB07C: 4182020C  beq 0x830eb288
	if ctx.cr[0].eq {
	pc = 0x830EB288; continue 'dispatch;
	}
	// 830EB080: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830EB084: 419A0018  beq cr6, 0x830eb09c
	if ctx.cr[6].eq {
	pc = 0x830EB09C; continue 'dispatch;
	}
	// 830EB088: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830EB08C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EB090: 4BFF4DE1  bl 0x830dfe70
	ctx.lr = 0x830EB094;
	sub_830DFE70(ctx, base);
	// 830EB094: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830EB098: 408201F0  bne 0x830eb288
	if !ctx.cr[0].eq {
	pc = 0x830EB288; continue 'dispatch;
	}
	// 830EB09C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830EB0A0: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EB0A4: 4BFF3FC5  bl 0x830df068
	ctx.lr = 0x830EB0A8;
	sub_830DF068(ctx, base);
	// 830EB0A8: 480001E0  b 0x830eb288
	pc = 0x830EB288; continue 'dispatch;
	// 830EB0AC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830EB0B0: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830EB0B4: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EB0B8: 83EB000C  lwz r31, 0xc(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EB0BC: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EB0C0: 7F045040  cmplw cr6, r4, r10
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830EB0C4: 409A000C  bne cr6, 0x830eb0d0
	if !ctx.cr[6].eq {
	pc = 0x830EB0D0; continue 'dispatch;
	}
	// 830EB0C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830EB0CC: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830EB0D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830EB0D4: 4BFFFE05  bl 0x830eaed8
	ctx.lr = 0x830EB0D8;
	sub_830EAED8(ctx, base);
	// 830EB0D8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830EB0DC: 418001CC  blt 0x830eb2a8
	if ctx.cr[0].lt {
	pc = 0x830EB2A8; continue 'dispatch;
	}
	// 830EB0E0: 889F0000  lbz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EB0E4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EB0E8: 4BFFEA29  bl 0x830e9b10
	ctx.lr = 0x830EB0EC;
	sub_830E9B10(ctx, base);
	// 830EB0EC: 4800019C  b 0x830eb288
	pc = 0x830EB288; continue 'dispatch;
	// 830EB0F0: 83BF0010  lwz r29, 0x10(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EB0F4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EB0F8: 839D0000  lwz r28, 0(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EB0FC: 4BFE3B15  bl 0x830cec10
	ctx.lr = 0x830EB100;
	sub_830CEC10(ctx, base);
	// 830EB100: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 830EB104: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 830EB108: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 830EB10C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 830EB110: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830EB114: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830EB118: 4BFFBB71  bl 0x830e6c88
	ctx.lr = 0x830EB11C;
	sub_830E6C88(ctx, base);
	// 830EB11C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830EB120: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830EB124: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830EB128: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830EB12C: 4BFF462D  bl 0x830df758
	ctx.lr = 0x830EB130;
	sub_830DF758(ctx, base);
	// 830EB130: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 830EB134: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EB138: 4BFEAC21  bl 0x830d5d58
	ctx.lr = 0x830EB13C;
	sub_830D5D58(ctx, base);
	// 830EB13C: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EB140: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830EB144: 419A0020  beq cr6, 0x830eb164
	if ctx.cr[6].eq {
	pc = 0x830EB164; continue 'dispatch;
	}
	// 830EB148: 889D0004  lbz r4, 4(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EB14C: 4BFF7AD5  bl 0x830e2c20
	ctx.lr = 0x830EB150;
	sub_830E2C20(ctx, base);
	// 830EB150: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830EB154: 41800134  blt 0x830eb288
	if ctx.cr[0].lt {
	pc = 0x830EB288; continue 'dispatch;
	}
	// 830EB158: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830EB15C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830EB160: 48000128  b 0x830eb288
	pc = 0x830EB288; continue 'dispatch;
	// 830EB164: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830EB168: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EB16C: 4BFF4665  bl 0x830df7d0
	ctx.lr = 0x830EB170;
	sub_830DF7D0(ctx, base);
	// 830EB170: 4800002C  b 0x830eb19c
	pc = 0x830EB19C; continue 'dispatch;
	// 830EB174: 4BFF3C95  bl 0x830dee08
	ctx.lr = 0x830EB178;
	sub_830DEE08(ctx, base);
	// 830EB178: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 830EB17C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EB180: 889D0004  lbz r4, 4(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EB184: 4BFF8ADD  bl 0x830e3c60
	ctx.lr = 0x830EB188;
	sub_830E3C60(ctx, base);
	// 830EB188: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830EB18C: 4182FFCC  beq 0x830eb158
	if ctx.cr[0].eq {
	pc = 0x830EB158; continue 'dispatch;
	}
	// 830EB190: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830EB194: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EB198: 4BFF4729  bl 0x830df8c0
	ctx.lr = 0x830EB19C;
	sub_830DF8C0(ctx, base);
	// 830EB19C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EB1A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EB1A4: 409AFFD0  bne cr6, 0x830eb174
	if !ctx.cr[6].eq {
	pc = 0x830EB174; continue 'dispatch;
	}
	// 830EB1A8: 480000E0  b 0x830eb288
	pc = 0x830EB288; continue 'dispatch;
	// 830EB1AC: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EB1B0: 3D408339  lis r10, -0x7cc7
	ctx.r[10].s64 = -2093416448;
	// 830EB1B4: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EB1B8: 808AC090  lwz r4, -0x3f70(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16240 as u32) ) } as u64;
	// 830EB1BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EB1C0: 4BFE39B1  bl 0x830ceb70
	ctx.lr = 0x830EB1C4;
	sub_830CEB70(ctx, base);
	// 830EB1C4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EB1C8: 4082001C  bne 0x830eb1e4
	if !ctx.cr[0].eq {
	pc = 0x830EB1E4; continue 'dispatch;
	}
	// 830EB1CC: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830EB1D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EB1D4: 808BC094  lwz r4, -0x3f6c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16236 as u32) ) } as u64;
	// 830EB1D8: 4BFE3999  bl 0x830ceb70
	ctx.lr = 0x830EB1DC;
	sub_830CEB70(ctx, base);
	// 830EB1DC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EB1E0: 418200A8  beq 0x830eb288
	if ctx.cr[0].eq {
	pc = 0x830EB288; continue 'dispatch;
	}
	// 830EB1E4: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830EB1E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EB1EC: 808BC078  lwz r4, -0x3f88(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16264 as u32) ) } as u64;
	// 830EB1F0: 4BFE3981  bl 0x830ceb70
	ctx.lr = 0x830EB1F4;
	sub_830CEB70(ctx, base);
	// 830EB1F4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830EB1F8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EB1FC: 38BE0008  addi r5, r30, 8
	ctx.r[5].s64 = ctx.r[30].s64 + 8;
	// 830EB200: 4BFFA9C9  bl 0x830e5bc8
	ctx.lr = 0x830EB204;
	sub_830E5BC8(ctx, base);
	// 830EB204: 48000084  b 0x830eb288
	pc = 0x830EB288; continue 'dispatch;
	// 830EB208: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EB20C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830EB210: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830EB214: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EB218: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830EB21C: 4800006C  b 0x830eb288
	pc = 0x830EB288; continue 'dispatch;
	// 830EB220: 2B0B07D5  cmplwi cr6, r11, 0x7d5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2005 as u32, &mut ctx.xer);
	// 830EB224: 419A006C  beq cr6, 0x830eb290
	if ctx.cr[6].eq {
	pc = 0x830EB290; continue 'dispatch;
	}
	// 830EB228: 2B0B07D7  cmplwi cr6, r11, 0x7d7
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2007 as u32, &mut ctx.xer);
	// 830EB22C: 419A0038  beq cr6, 0x830eb264
	if ctx.cr[6].eq {
	pc = 0x830EB264; continue 'dispatch;
	}
	// 830EB230: 2B0B07D8  cmplwi cr6, r11, 0x7d8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2008 as u32, &mut ctx.xer);
	// 830EB234: 409A0054  bne cr6, 0x830eb288
	if !ctx.cr[6].eq {
	pc = 0x830EB288; continue 'dispatch;
	}
	// 830EB238: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830EB23C: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EB240: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830EB244: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EB248: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EB24C: 4BFFC80D  bl 0x830e7a58
	ctx.lr = 0x830EB250;
	sub_830E7A58(ctx, base);
	// 830EB250: 7C641B79  or. r4, r3, r3
	ctx.r[4].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 830EB254: 4082004C  bne 0x830eb2a0
	if !ctx.cr[0].eq {
	pc = 0x830EB2A0; continue 'dispatch;
	}
	// 830EB258: 3C608030  lis r3, -0x7fd0
	ctx.r[3].s64 = -2144337920;
	// 830EB25C: 6063000A  ori r3, r3, 0xa
	ctx.r[3].u64 = ctx.r[3].u64 | 10;
	// 830EB260: 48000048  b 0x830eb2a8
	pc = 0x830EB2A8; continue 'dispatch;
	// 830EB264: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830EB268: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830EB26C: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EB270: 4BFF3E71  bl 0x830df0e0
	ctx.lr = 0x830EB274;
	sub_830DF0E0(ctx, base);
	// 830EB274: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EB278: 906B0000  stw r3, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 830EB27C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EB280: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EB284: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 830EB288: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830EB28C: 4800001C  b 0x830eb2a8
	pc = 0x830EB2A8; continue 'dispatch;
	// 830EB290: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830EB294: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EB298: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830EB29C: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EB2A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830EB2A4: 4BFFFC35  bl 0x830eaed8
	ctx.lr = 0x830EB2A8;
	sub_830EAED8(ctx, base);
	// 830EB2A8: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 830EB2AC: 480BCF08  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EB2B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830EB2B0 size=196
    let mut pc: u32 = 0x830EB2B0;
    'dispatch: loop {
        match pc {
            0x830EB2B0 => {
    //   block [0x830EB2B0..0x830EB374)
	// 830EB2B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EB2B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830EB2B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830EB2BC: DBC1FFE0  stfd f30, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[30].u64 ) };
	// 830EB2C0: DBE1FFE8  stfd f31, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 830EB2C4: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EB2C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830EB2CC: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 830EB2D0: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 830EB2D4: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 830EB2D8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830EB2DC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EB2E0: 4BFFC529  bl 0x830e7808
	ctx.lr = 0x830EB2E4;
	sub_830E7808(ctx, base);
	// 830EB2E4: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EB2E8: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 830EB2EC: 409A0010  bne cr6, 0x830eb2fc
	if !ctx.cr[6].eq {
	pc = 0x830EB2FC; continue 'dispatch;
	}
	// 830EB2F0: C0010054  lfs f0, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EB2F4: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 830EB2F8: 419A005C  beq cr6, 0x830eb354
	if ctx.cr[6].eq {
	pc = 0x830EB354; continue 'dispatch;
	}
	// 830EB2FC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EB300: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 830EB304: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 830EB308: 4BFF6701  bl 0x830e1a08
	ctx.lr = 0x830EB30C;
	sub_830E1A08(ctx, base);
	// 830EB30C: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830EB310: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EB314: 808BC06C  lwz r4, -0x3f94(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16276 as u32) ) } as u64;
	// 830EB318: 4BFE3859  bl 0x830ceb70
	ctx.lr = 0x830EB31C;
	sub_830CEB70(ctx, base);
	// 830EB31C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EB320: 41820034  beq 0x830eb354
	if ctx.cr[0].eq {
	pc = 0x830EB354; continue 'dispatch;
	}
	// 830EB324: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830EB328: 4BFE3149  bl 0x830ce470
	ctx.lr = 0x830EB32C;
	sub_830CE470(ctx, base);
	// 830EB32C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EB330: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830EB334: 419A0020  beq cr6, 0x830eb354
	if ctx.cr[6].eq {
	pc = 0x830EB354; continue 'dispatch;
	}
	// 830EB338: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 830EB33C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 830EB340: 4BFFA519  bl 0x830e5858
	ctx.lr = 0x830EB344;
	sub_830E5858(ctx, base);
	// 830EB344: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EB348: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 830EB34C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 830EB350: 4BFFE179  bl 0x830e94c8
	ctx.lr = 0x830EB354;
	sub_830E94C8(ctx, base);
	// 830EB354: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830EB358: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830EB35C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830EB360: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830EB364: CBC1FFE0  lfd f30, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 830EB368: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830EB36C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830EB370: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EB378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830EB378 size=280
    let mut pc: u32 = 0x830EB378;
    'dispatch: loop {
        match pc {
            0x830EB378 => {
    //   block [0x830EB378..0x830EB490)
	// 830EB378: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EB37C: 480BCDF1  bl 0x831a816c
	ctx.lr = 0x830EB380;
	sub_831A8130(ctx, base);
	// 830EB380: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EB384: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830EB388: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830EB38C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EB390: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 830EB394: 419A0098  beq cr6, 0x830eb42c
	if ctx.cr[6].eq {
	pc = 0x830EB42C; continue 'dispatch;
	}
	// 830EB398: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 830EB39C: 419A0080  beq cr6, 0x830eb41c
	if ctx.cr[6].eq {
	pc = 0x830EB41C; continue 'dispatch;
	}
	// 830EB3A0: 2B0B0018  cmplwi cr6, r11, 0x18
	ctx.cr[6].compare_u32(ctx.r[11].u32, 24 as u32, &mut ctx.xer);
	// 830EB3A4: 419A0058  beq cr6, 0x830eb3fc
	if ctx.cr[6].eq {
	pc = 0x830EB3FC; continue 'dispatch;
	}
	// 830EB3A8: 2B0B0022  cmplwi cr6, r11, 0x22
	ctx.cr[6].compare_u32(ctx.r[11].u32, 34 as u32, &mut ctx.xer);
	// 830EB3AC: 419A0040  beq cr6, 0x830eb3ec
	if ctx.cr[6].eq {
	pc = 0x830EB3EC; continue 'dispatch;
	}
	// 830EB3B0: 2B0B0023  cmplwi cr6, r11, 0x23
	ctx.cr[6].compare_u32(ctx.r[11].u32, 35 as u32, &mut ctx.xer);
	// 830EB3B4: 419A001C  beq cr6, 0x830eb3d0
	if ctx.cr[6].eq {
	pc = 0x830EB3D0; continue 'dispatch;
	}
	// 830EB3B8: 2B0B0800  cmplwi cr6, r11, 0x800
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2048 as u32, &mut ctx.xer);
	// 830EB3BC: 409A00C8  bne cr6, 0x830eb484
	if !ctx.cr[6].eq {
	pc = 0x830EB484; continue 'dispatch;
	}
	// 830EB3C0: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EB3C4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830EB3C8: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 830EB3CC: 480000B4  b 0x830eb480
	pc = 0x830EB480; continue 'dispatch;
	// 830EB3D0: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EB3D4: 387D0004  addi r3, r29, 4
	ctx.r[3].s64 = ctx.r[29].s64 + 4;
	// 830EB3D8: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EB3DC: 4BFE38AD  bl 0x830cec88
	ctx.lr = 0x830EB3E0;
	sub_830CEC88(ctx, base);
	// 830EB3E0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830EB3E4: 418000A4  blt 0x830eb488
	if ctx.cr[0].lt {
	pc = 0x830EB488; continue 'dispatch;
	}
	// 830EB3E8: 48000094  b 0x830eb47c
	pc = 0x830EB47C; continue 'dispatch;
	// 830EB3EC: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EB3F0: 813F0010  lwz r9, 0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EB3F4: 91690000  stw r11, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830EB3F8: 48000018  b 0x830eb410
	pc = 0x830EB410; continue 'dispatch;
	// 830EB3FC: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EB400: 4BFFC359  bl 0x830e7758
	ctx.lr = 0x830EB404;
	sub_830E7758(ctx, base);
	// 830EB404: 4BFF7B35  bl 0x830e2f38
	ctx.lr = 0x830EB408;
	sub_830E2F38(ctx, base);
	// 830EB408: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EB40C: 906B0000  stw r3, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 830EB410: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830EB414: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830EB418: 4800006C  b 0x830eb484
	pc = 0x830EB484; continue 'dispatch;
	// 830EB41C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EB420: C04B000C  lfs f2, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 830EB424: C02B0008  lfs f1, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830EB428: 4800004C  b 0x830eb474
	pc = 0x830EB474; continue 'dispatch;
	// 830EB42C: 83DF0010  lwz r30, 0x10(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EB430: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EB434: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EB438: 419A0044  beq cr6, 0x830eb47c
	if ctx.cr[6].eq {
	pc = 0x830EB47C; continue 'dispatch;
	}
	// 830EB43C: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EB440: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830EB444: 419A0038  beq cr6, 0x830eb47c
	if ctx.cr[6].eq {
	pc = 0x830EB47C; continue 'dispatch;
	}
	// 830EB448: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830EB44C: 808BC078  lwz r4, -0x3f88(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16264 as u32) ) } as u64;
	// 830EB450: 4BFE3721  bl 0x830ceb70
	ctx.lr = 0x830EB454;
	sub_830CEB70(ctx, base);
	// 830EB454: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EB458: 41820024  beq 0x830eb47c
	if ctx.cr[0].eq {
	pc = 0x830EB47C; continue 'dispatch;
	}
	// 830EB45C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830EB460: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EB464: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 830EB468: 4BFFC3A1  bl 0x830e7808
	ctx.lr = 0x830EB46C;
	sub_830E7808(ctx, base);
	// 830EB46C: C0410050  lfs f2, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 830EB470: C0210054  lfs f1, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830EB474: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830EB478: 4BFFFE39  bl 0x830eb2b0
	ctx.lr = 0x830EB47C;
	sub_830EB2B0(ctx, base);
	// 830EB47C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830EB480: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830EB484: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830EB488: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830EB48C: 480BCD30  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


