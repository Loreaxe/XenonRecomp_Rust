pub fn sub_8242B4F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8242B4F8 size=872
    let mut pc: u32 = 0x8242B4F8;
    'dispatch: loop {
        match pc {
            0x8242B4F8 => {
    //   block [0x8242B4F8..0x8242B860)
	// 8242B4F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8242B4FC: 48D7CC59  bl 0x831a8154
	ctx.lr = 0x8242B500;
	sub_831A8130(ctx, base);
	// 8242B500: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8242B504: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8242B508: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 8242B50C: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 8242B510: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8242B514: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 8242B518: 485C7071  bl 0x829f2588
	ctx.lr = 0x8242B51C;
	sub_829F2588(ctx, base);
	// 8242B51C: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242B520: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8242B524: 409A000C  bne cr6, 0x8242b530
	if !ctx.cr[6].eq {
	pc = 0x8242B530; continue 'dispatch;
	}
	// 8242B528: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8242B52C: 48000010  b 0x8242b53c
	pc = 0x8242B53C; continue 'dispatch;
	// 8242B530: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8242B534: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8242B538: 7D682670  srawi r8, r11, 4
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[11].s32 >> 4) as i64;
	// 8242B53C: 2B170000  cmplwi cr6, r23, 0
	ctx.cr[6].compare_u32(ctx.r[23].u32, 0 as u32, &mut ctx.xer);
	// 8242B540: 419A0310  beq cr6, 0x8242b850
	if ctx.cr[6].eq {
	pc = 0x8242B850; continue 'dispatch;
	}
	// 8242B544: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8242B548: 409A000C  bne cr6, 0x8242b554
	if !ctx.cr[6].eq {
	pc = 0x8242B554; continue 'dispatch;
	}
	// 8242B54C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8242B550: 48000010  b 0x8242b560
	pc = 0x8242B560; continue 'dispatch;
	// 8242B554: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8242B558: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8242B55C: 7D6B2670  srawi r11, r11, 4
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 4) as i64;
	// 8242B560: 3D400FFF  lis r10, 0xfff
	ctx.r[10].s64 = 268369920;
	// 8242B564: 614AFFFF  ori r10, r10, 0xffff
	ctx.r[10].u64 = ctx.r[10].u64 | 65535;
	// 8242B568: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 8242B56C: 7F0BB840  cmplw cr6, r11, r23
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[23].u32, &mut ctx.xer);
	// 8242B570: 4098000C  bge cr6, 0x8242b57c
	if !ctx.cr[6].lt {
	pc = 0x8242B57C; continue 'dispatch;
	}
	// 8242B574: 4878C7AD  bl 0x82bb7d20
	ctx.lr = 0x8242B578;
	sub_82BB7D20(ctx, base);
	// 8242B578: 480002D8  b 0x8242b850
	pc = 0x8242B850; continue 'dispatch;
	// 8242B57C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8242B580: 409A000C  bne cr6, 0x8242b58c
	if !ctx.cr[6].eq {
	pc = 0x8242B58C; continue 'dispatch;
	}
	// 8242B584: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8242B588: 48000010  b 0x8242b598
	pc = 0x8242B598; continue 'dispatch;
	// 8242B58C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8242B590: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8242B594: 7D6B2670  srawi r11, r11, 4
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 4) as i64;
	// 8242B598: 7D6BBA14  add r11, r11, r23
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[23].u64;
	// 8242B59C: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8242B5A0: 40980180  bge cr6, 0x8242b720
	if !ctx.cr[6].lt {
	pc = 0x8242B720; continue 'dispatch;
	}
	// 8242B5A4: 550BF87E  srwi r11, r8, 1
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8242B5A8: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 8242B5AC: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 8242B5B0: 4098000C  bge cr6, 0x8242b5bc
	if !ctx.cr[6].lt {
	pc = 0x8242B5BC; continue 'dispatch;
	}
	// 8242B5B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8242B5B8: 48000008  b 0x8242b5c0
	pc = 0x8242B5C0; continue 'dispatch;
	// 8242B5BC: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 8242B5C0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8242B5C4: 409A000C  bne cr6, 0x8242b5d0
	if !ctx.cr[6].eq {
	pc = 0x8242B5D0; continue 'dispatch;
	}
	// 8242B5C8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8242B5CC: 48000010  b 0x8242b5dc
	pc = 0x8242B5DC; continue 'dispatch;
	// 8242B5D0: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8242B5D4: 7D495050  subf r10, r9, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 8242B5D8: 7D4A2670  srawi r10, r10, 4
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 4) as i64;
	// 8242B5DC: 7D4ABA14  add r10, r10, r23
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[23].u64;
	// 8242B5E0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8242B5E4: 40980024  bge cr6, 0x8242b608
	if !ctx.cr[6].lt {
	pc = 0x8242B608; continue 'dispatch;
	}
	// 8242B5E8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8242B5EC: 409A000C  bne cr6, 0x8242b5f8
	if !ctx.cr[6].eq {
	pc = 0x8242B5F8; continue 'dispatch;
	}
	// 8242B5F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8242B5F4: 48000010  b 0x8242b604
	pc = 0x8242B604; continue 'dispatch;
	// 8242B5F8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8242B5FC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8242B600: 7D6B2670  srawi r11, r11, 4
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 4) as i64;
	// 8242B604: 7D6BBA14  add r11, r11, r23
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[23].u64;
	// 8242B608: 55782036  slwi r24, r11, 4
	ctx.r[24].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[24].u64 = ctx.r[24].u32 as u64;
	// 8242B60C: 3F208335  lis r25, -0x7ccb
	ctx.r[25].s64 = -2093678592;
	// 8242B610: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8242B614: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 8242B618: 388B08B0  addi r4, r11, 0x8b0
	ctx.r[4].s64 = ctx.r[11].s64 + 2224;
	// 8242B61C: 38A0002D  li r5, 0x2d
	ctx.r[5].s64 = 45;
	// 8242B620: 8079110C  lwz r3, 0x110c(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4364 as u32) ) } as u64;
	// 8242B624: 489C6AA5  bl 0x82df20c8
	ctx.lr = 0x8242B628;
	sub_82DF20C8(ctx, base);
	// 8242B628: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8242B62C: 83DF0004  lwz r30, 4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242B630: 7F7DDB78  mr r29, r27
	ctx.r[29].u64 = ctx.r[27].u64;
	// 8242B634: 48000020  b 0x8242b654
	pc = 0x8242B654; continue 'dispatch;
	// 8242B638: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8242B63C: 419A0010  beq cr6, 0x8242b64c
	if ctx.cr[6].eq {
	pc = 0x8242B64C; continue 'dispatch;
	}
	// 8242B640: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8242B644: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8242B648: 485C6F41  bl 0x829f2588
	ctx.lr = 0x8242B64C;
	sub_829F2588(ctx, base);
	// 8242B64C: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 8242B650: 3BBD0010  addi r29, r29, 0x10
	ctx.r[29].s64 = ctx.r[29].s64 + 16;
	// 8242B654: 7F1ED040  cmplw cr6, r30, r26
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[26].u32, &mut ctx.xer);
	// 8242B658: 409AFFE0  bne cr6, 0x8242b638
	if !ctx.cr[6].eq {
	pc = 0x8242B638; continue 'dispatch;
	}
	// 8242B65C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 8242B660: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 8242B664: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8242B668: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8242B66C: 4BFFFE35  bl 0x8242b4a0
	ctx.lr = 0x8242B670;
	sub_8242B4A0(ctx, base);
	// 8242B670: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8242B674: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8242B678: 7F1AE840  cmplw cr6, r26, r29
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[29].u32, &mut ctx.xer);
	// 8242B67C: 419A002C  beq cr6, 0x8242b6a8
	if ctx.cr[6].eq {
	pc = 0x8242B6A8; continue 'dispatch;
	}
	// 8242B680: 7F9ED050  subf r28, r30, r26
	ctx.r[28].s64 = ctx.r[26].s64 - ctx.r[30].s64;
	// 8242B684: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8242B688: 419A0010  beq cr6, 0x8242b698
	if ctx.cr[6].eq {
	pc = 0x8242B698; continue 'dispatch;
	}
	// 8242B68C: 7C9CF214  add r4, r28, r30
	ctx.r[4].u64 = ctx.r[28].u64 + ctx.r[30].u64;
	// 8242B690: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8242B694: 485C6EF5  bl 0x829f2588
	ctx.lr = 0x8242B698;
	sub_829F2588(ctx, base);
	// 8242B698: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 8242B69C: 7D7CF214  add r11, r28, r30
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[30].u64;
	// 8242B6A0: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 8242B6A4: 409AFFE0  bne cr6, 0x8242b684
	if !ctx.cr[6].eq {
	pc = 0x8242B684; continue 'dispatch;
	}
	// 8242B6A8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242B6AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8242B6B0: 409A000C  bne cr6, 0x8242b6bc
	if !ctx.cr[6].eq {
	pc = 0x8242B6BC; continue 'dispatch;
	}
	// 8242B6B4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8242B6B8: 48000010  b 0x8242b6c8
	pc = 0x8242B6C8; continue 'dispatch;
	// 8242B6BC: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8242B6C0: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 8242B6C4: 7D4A2670  srawi r10, r10, 4
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 4) as i64;
	// 8242B6C8: 7F8ABA14  add r28, r10, r23
	ctx.r[28].u64 = ctx.r[10].u64 + ctx.r[23].u64;
	// 8242B6CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8242B6D0: 419A0034  beq cr6, 0x8242b704
	if ctx.cr[6].eq {
	pc = 0x8242B704; continue 'dispatch;
	}
	// 8242B6D4: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8242B6D8: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 8242B6DC: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 8242B6E0: 419A0018  beq cr6, 0x8242b6f8
	if ctx.cr[6].eq {
	pc = 0x8242B6F8; continue 'dispatch;
	}
	// 8242B6E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8242B6E8: 48085BB9  bl 0x824b12a0
	ctx.lr = 0x8242B6EC;
	sub_824B12A0(ctx, base);
	// 8242B6EC: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 8242B6F0: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 8242B6F4: 409AFFF0  bne cr6, 0x8242b6e4
	if !ctx.cr[6].eq {
	pc = 0x8242B6E4; continue 'dispatch;
	}
	// 8242B6F8: 8079110C  lwz r3, 0x110c(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4364 as u32) ) } as u64;
	// 8242B6FC: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242B700: 489C6A89  bl 0x82df2188
	ctx.lr = 0x8242B704;
	sub_82DF2188(ctx, base);
	// 8242B704: 578B2036  slwi r11, r28, 4
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8242B708: 937F0004  stw r27, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 8242B70C: 7D58DA14  add r10, r24, r27
	ctx.r[10].u64 = ctx.r[24].u64 + ctx.r[27].u64;
	// 8242B710: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 8242B714: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 8242B718: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8242B71C: 48000134  b 0x8242b850
	pc = 0x8242B850; continue 'dispatch;
	// 8242B720: 83DF0008  lwz r30, 8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8242B724: 7D7AF050  subf r11, r26, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[26].s64;
	// 8242B728: 7D6B2670  srawi r11, r11, 4
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 4) as i64;
	// 8242B72C: 7F0BB840  cmplw cr6, r11, r23
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[23].u32, &mut ctx.xer);
	// 8242B730: 40980090  bge cr6, 0x8242b7c0
	if !ctx.cr[6].lt {
	pc = 0x8242B7C0; continue 'dispatch;
	}
	// 8242B734: 56FD2036  slwi r29, r23, 4
	ctx.r[29].u32 = ctx.r[23].u32.wrapping_shl(4);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 8242B738: 7F1AF040  cmplw cr6, r26, r30
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[30].u32, &mut ctx.xer);
	// 8242B73C: 7F9DD214  add r28, r29, r26
	ctx.r[28].u64 = ctx.r[29].u64 + ctx.r[26].u64;
	// 8242B740: 419A002C  beq cr6, 0x8242b76c
	if ctx.cr[6].eq {
	pc = 0x8242B76C; continue 'dispatch;
	}
	// 8242B744: 7F7DE050  subf r27, r29, r28
	ctx.r[27].s64 = ctx.r[28].s64 - ctx.r[29].s64;
	// 8242B748: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 8242B74C: 419A0010  beq cr6, 0x8242b75c
	if ctx.cr[6].eq {
	pc = 0x8242B75C; continue 'dispatch;
	}
	// 8242B750: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8242B754: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8242B758: 485C6E31  bl 0x829f2588
	ctx.lr = 0x8242B75C;
	sub_829F2588(ctx, base);
	// 8242B75C: 3B7B0010  addi r27, r27, 0x10
	ctx.r[27].s64 = ctx.r[27].s64 + 16;
	// 8242B760: 3B9C0010  addi r28, r28, 0x10
	ctx.r[28].s64 = ctx.r[28].s64 + 16;
	// 8242B764: 7F1BF040  cmplw cr6, r27, r30
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[30].u32, &mut ctx.xer);
	// 8242B768: 409AFFE0  bne cr6, 0x8242b748
	if !ctx.cr[6].eq {
	pc = 0x8242B748; continue 'dispatch;
	}
	// 8242B76C: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8242B770: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 8242B774: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8242B778: 7D7A2050  subf r11, r26, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[26].s64;
	// 8242B77C: 7D6B2670  srawi r11, r11, 4
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 4) as i64;
	// 8242B780: 7CABB850  subf r5, r11, r23
	ctx.r[5].s64 = ctx.r[23].s64 - ctx.r[11].s64;
	// 8242B784: 4BFFFD1D  bl 0x8242b4a0
	ctx.lr = 0x8242B788;
	sub_8242B4A0(ctx, base);
	// 8242B788: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8242B78C: 7F5CD378  mr r28, r26
	ctx.r[28].u64 = ctx.r[26].u64;
	// 8242B790: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 8242B794: 7FDD5850  subf r30, r29, r11
	ctx.r[30].s64 = ctx.r[11].s64 - ctx.r[29].s64;
	// 8242B798: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8242B79C: 7F1AF040  cmplw cr6, r26, r30
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[30].u32, &mut ctx.xer);
	// 8242B7A0: 419A00B0  beq cr6, 0x8242b850
	if ctx.cr[6].eq {
	pc = 0x8242B850; continue 'dispatch;
	}
	// 8242B7A4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8242B7A8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8242B7AC: 4BE9B90D  bl 0x822c70b8
	ctx.lr = 0x8242B7B0;
	sub_822C70B8(ctx, base);
	// 8242B7B0: 3B9C0010  addi r28, r28, 0x10
	ctx.r[28].s64 = ctx.r[28].s64 + 16;
	// 8242B7B4: 7F1CF040  cmplw cr6, r28, r30
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[30].u32, &mut ctx.xer);
	// 8242B7B8: 409AFFEC  bne cr6, 0x8242b7a4
	if !ctx.cr[6].eq {
	pc = 0x8242B7A4; continue 'dispatch;
	}
	// 8242B7BC: 48000094  b 0x8242b850
	pc = 0x8242B850; continue 'dispatch;
	// 8242B7C0: 56F92036  slwi r25, r23, 4
	ctx.r[25].u32 = ctx.r[23].u32.wrapping_shl(4);
	ctx.r[25].u64 = ctx.r[25].u32 as u64;
	// 8242B7C4: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 8242B7C8: 7FB9F050  subf r29, r25, r30
	ctx.r[29].s64 = ctx.r[30].s64 - ctx.r[25].s64;
	// 8242B7CC: 7FBBEB78  mr r27, r29
	ctx.r[27].u64 = ctx.r[29].u64;
	// 8242B7D0: 7F1DF040  cmplw cr6, r29, r30
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[30].u32, &mut ctx.xer);
	// 8242B7D4: 419A0028  beq cr6, 0x8242b7fc
	if ctx.cr[6].eq {
	pc = 0x8242B7FC; continue 'dispatch;
	}
	// 8242B7D8: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 8242B7DC: 419A0010  beq cr6, 0x8242b7ec
	if ctx.cr[6].eq {
	pc = 0x8242B7EC; continue 'dispatch;
	}
	// 8242B7E0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8242B7E4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8242B7E8: 485C6DA1  bl 0x829f2588
	ctx.lr = 0x8242B7EC;
	sub_829F2588(ctx, base);
	// 8242B7EC: 3B7B0010  addi r27, r27, 0x10
	ctx.r[27].s64 = ctx.r[27].s64 + 16;
	// 8242B7F0: 3B9C0010  addi r28, r28, 0x10
	ctx.r[28].s64 = ctx.r[28].s64 + 16;
	// 8242B7F4: 7F1BF040  cmplw cr6, r27, r30
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[30].u32, &mut ctx.xer);
	// 8242B7F8: 409AFFE0  bne cr6, 0x8242b7d8
	if !ctx.cr[6].eq {
	pc = 0x8242B7D8; continue 'dispatch;
	}
	// 8242B7FC: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 8242B800: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 8242B804: 7F1AE840  cmplw cr6, r26, r29
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[29].u32, &mut ctx.xer);
	// 8242B808: 419A0020  beq cr6, 0x8242b828
	if ctx.cr[6].eq {
	pc = 0x8242B828; continue 'dispatch;
	}
	// 8242B80C: 7FDDF050  subf r30, r29, r30
	ctx.r[30].s64 = ctx.r[30].s64 - ctx.r[29].s64;
	// 8242B810: 3BFFFFF0  addi r31, r31, -0x10
	ctx.r[31].s64 = ctx.r[31].s64 + -16;
	// 8242B814: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8242B818: 7C7EFA14  add r3, r30, r31
	ctx.r[3].u64 = ctx.r[30].u64 + ctx.r[31].u64;
	// 8242B81C: 4BE9B89D  bl 0x822c70b8
	ctx.lr = 0x8242B820;
	sub_822C70B8(ctx, base);
	// 8242B820: 7F1FD040  cmplw cr6, r31, r26
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[26].u32, &mut ctx.xer);
	// 8242B824: 409AFFEC  bne cr6, 0x8242b810
	if !ctx.cr[6].eq {
	pc = 0x8242B810; continue 'dispatch;
	}
	// 8242B828: 7FD9D214  add r30, r25, r26
	ctx.r[30].u64 = ctx.r[25].u64 + ctx.r[26].u64;
	// 8242B82C: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 8242B830: 7F1AF040  cmplw cr6, r26, r30
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[30].u32, &mut ctx.xer);
	// 8242B834: 419A001C  beq cr6, 0x8242b850
	if ctx.cr[6].eq {
	pc = 0x8242B850; continue 'dispatch;
	}
	// 8242B838: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8242B83C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8242B840: 4BE9B879  bl 0x822c70b8
	ctx.lr = 0x8242B844;
	sub_822C70B8(ctx, base);
	// 8242B844: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 8242B848: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 8242B84C: 409AFFEC  bne cr6, 0x8242b838
	if !ctx.cr[6].eq {
	pc = 0x8242B838; continue 'dispatch;
	}
	// 8242B850: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8242B854: 48085A4D  bl 0x824b12a0
	ctx.lr = 0x8242B858;
	sub_824B12A0(ctx, base);
	// 8242B858: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 8242B85C: 48D7C948  b 0x831a81a4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242B860(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8242B860 size=108
    let mut pc: u32 = 0x8242B860;
    'dispatch: loop {
        match pc {
            0x8242B860 => {
    //   block [0x8242B860..0x8242B8CC)
	// 8242B860: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8242B864: 48D7C909  bl 0x831a816c
	ctx.lr = 0x8242B868;
	sub_831A8130(ctx, base);
	// 8242B868: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8242B86C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8242B870: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8242B874: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 8242B878: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242B87C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8242B880: 419A0014  beq cr6, 0x8242b894
	if ctx.cr[6].eq {
	pc = 0x8242B894; continue 'dispatch;
	}
	// 8242B884: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8242B888: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 8242B88C: 7D4A2671  srawi. r10, r10, 4
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 4) as i64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8242B890: 4082000C  bne 0x8242b89c
	if !ctx.cr[0].eq {
	pc = 0x8242B89C; continue 'dispatch;
	}
	// 8242B894: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 8242B898: 4800000C  b 0x8242b8a4
	pc = 0x8242B8A4; continue 'dispatch;
	// 8242B89C: 7D6B2050  subf r11, r11, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[11].s64;
	// 8242B8A0: 7D7D2670  srawi r29, r11, 4
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[29].s64 = (ctx.r[11].s32 >> 4) as i64;
	// 8242B8A4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8242B8A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8242B8AC: 4BFFFC4D  bl 0x8242b4f8
	ctx.lr = 0x8242B8B0;
	sub_8242B4F8(ctx, base);
	// 8242B8B0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242B8B4: 57AB2036  slwi r11, r29, 4
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8242B8B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8242B8BC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8242B8C0: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8242B8C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8242B8C8: 48D7C8F4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242B8D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8242B8D0 size=92
    let mut pc: u32 = 0x8242B8D0;
    'dispatch: loop {
        match pc {
            0x8242B8D0 => {
    //   block [0x8242B8D0..0x8242B92C)
	// 8242B8D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8242B8D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8242B8D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8242B8DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8242B8E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8242B8E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8242B8E8: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8242B8EC: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 8242B8F0: 396B5464  addi r11, r11, 0x5464
	ctx.r[11].s64 = ctx.r[11].s64 + 21604;
	// 8242B8F4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8242B8F8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8242B8FC: 485C7C6D  bl 0x829f3568
	ctx.lr = 0x8242B900;
	sub_829F3568(ctx, base);
	// 8242B900: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8242B904: 4182000C  beq 0x8242b910
	if ctx.cr[0].eq {
	pc = 0x8242B910; continue 'dispatch;
	}
	// 8242B908: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8242B90C: 4BE9495D  bl 0x822c0268
	ctx.lr = 0x8242B910;
	sub_822C0268(ctx, base);
	// 8242B910: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8242B914: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8242B918: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8242B91C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8242B920: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8242B924: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8242B928: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242B930(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8242B930 size=160
    let mut pc: u32 = 0x8242B930;
    'dispatch: loop {
        match pc {
            0x8242B930 => {
    //   block [0x8242B930..0x8242B9D0)
	// 8242B930: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8242B934: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8242B938: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8242B93C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8242B940: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8242B944: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8242B948: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242B94C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8242B950: 409A000C  bne cr6, 0x8242b95c
	if !ctx.cr[6].eq {
	pc = 0x8242B95C; continue 'dispatch;
	}
	// 8242B954: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8242B958: 48000010  b 0x8242b968
	pc = 0x8242B968; continue 'dispatch;
	// 8242B95C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8242B960: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 8242B964: 7D4A2670  srawi r10, r10, 4
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 4) as i64;
	// 8242B968: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8242B96C: 419A0038  beq cr6, 0x8242b9a4
	if ctx.cr[6].eq {
	pc = 0x8242B9A4; continue 'dispatch;
	}
	// 8242B970: 813F000C  lwz r9, 0xc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8242B974: 7D6B4850  subf r11, r11, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 8242B978: 7D6B2670  srawi r11, r11, 4
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 4) as i64;
	// 8242B97C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8242B980: 40980024  bge cr6, 0x8242b9a4
	if !ctx.cr[6].lt {
	pc = 0x8242B9A4; continue 'dispatch;
	}
	// 8242B984: 83DF0008  lwz r30, 8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8242B988: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8242B98C: 419A000C  beq cr6, 0x8242b998
	if ctx.cr[6].eq {
	pc = 0x8242B998; continue 'dispatch;
	}
	// 8242B990: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8242B994: 485C6BF5  bl 0x829f2588
	ctx.lr = 0x8242B998;
	sub_829F2588(ctx, base);
	// 8242B998: 397E0010  addi r11, r30, 0x10
	ctx.r[11].s64 = ctx.r[30].s64 + 16;
	// 8242B99C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8242B9A0: 48000018  b 0x8242b9b8
	pc = 0x8242B9B8; continue 'dispatch;
	// 8242B9A4: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 8242B9A8: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8242B9AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8242B9B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8242B9B4: 4BFFFEAD  bl 0x8242b860
	ctx.lr = 0x8242B9B8;
	sub_8242B860(ctx, base);
	// 8242B9B8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8242B9BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8242B9C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8242B9C4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8242B9C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8242B9CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242B9D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8242B9D0 size=1072
    let mut pc: u32 = 0x8242B9D0;
    'dispatch: loop {
        match pc {
            0x8242B9D0 => {
    //   block [0x8242B9D0..0x8242BE00)
	// 8242B9D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8242B9D4: 48D7C76D  bl 0x831a8140
	ctx.lr = 0x8242B9D8;
	sub_831A8130(ctx, base);
	// 8242B9D8: 3981FF88  addi r12, r1, -0x78
	ctx.r[12].s64 = ctx.r[1].s64 + -120;
	// 8242B9DC: 48D7D095  bl 0x831a8a70
	ctx.lr = 0x8242B9E0;
	sub_831A8A40(ctx, base);
	// 8242B9E0: 3980FF20  li r12, -0xe0
	ctx.r[12].s64 = -224;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242BE00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8242BE00 size=52
    let mut pc: u32 = 0x8242BE00;
    'dispatch: loop {
        match pc {
            0x8242BE00 => {
    //   block [0x8242BE00..0x8242BE34)
	// 8242BE00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8242BE04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8242BE08: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8242BE0C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8242BE10: 80840048  lwz r4, 0x48(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 8242BE14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8242BE18: 4BEC1159  bl 0x822ecf70
	ctx.lr = 0x8242BE1C;
	sub_822ECF70(ctx, base);
	// 8242BE1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8242BE20: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8242BE24: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8242BE28: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8242BE2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8242BE30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242BE38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8242BE38 size=152
    let mut pc: u32 = 0x8242BE38;
    'dispatch: loop {
        match pc {
            0x8242BE38 => {
    //   block [0x8242BE38..0x8242BED0)
	// 8242BE38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8242BE3C: 48D7C331  bl 0x831a816c
	ctx.lr = 0x8242BE40;
	sub_831A8130(ctx, base);
	// 8242BE40: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8242BE44: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8242BE48: C0040058  lfs f0, 0x58(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8242BE4C: 83C40048  lwz r30, 0x48(r4)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 8242BE50: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 8242BE54: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8242BE58: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8242BE5C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8242BE60: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8242BE64: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8242BE68: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8242BE6C: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8242BE70: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 8242BE74: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242BE78: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8242BE7C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8242BE80: 4E800421  bctrl
	ctx.lr = 0x8242BE84;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8242BE84: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8242BE88: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8242BE8C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8242BE90: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 8242BE94: 4BEC10DD  bl 0x822ecf70
	ctx.lr = 0x8242BE98;
	sub_822ECF70(ctx, base);
	// 8242BE98: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8242BE9C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 8242BEA0: 48A4FFF9  bl 0x82e7be98
	ctx.lr = 0x8242BEA4;
	sub_82E7BE98(ctx, base);
	// 8242BEA4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8242BEA8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8242BEAC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8242BEB0: 48A4FE99  bl 0x82e7bd48
	ctx.lr = 0x8242BEB4;
	sub_82E7BD48(ctx, base);
	// 8242BEB4: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8242BEB8: 13C0E8C7  vcmpequd (lvx128) v30, v0, v29
	tmp.u32 = ctx.r[29].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8242BEBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242BED0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8242BED0 size=16
    let mut pc: u32 = 0x8242BED0;
    'dispatch: loop {
        match pc {
            0x8242BED0 => {
    //   block [0x8242BED0..0x8242BEE0)
	// 8242BED0: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8242BED4: 396B5514  addi r11, r11, 0x5514
	ctx.r[11].s64 = ctx.r[11].s64 + 21780;
	// 8242BED8: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8242BEDC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242BEE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8242BEE0 size=68
    let mut pc: u32 = 0x8242BEE0;
    'dispatch: loop {
        match pc {
            0x8242BEE0 => {
    //   block [0x8242BEE0..0x8242BF24)
	// 8242BEE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8242BEE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8242BEE8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8242BEEC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8242BEF0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8242BEF4: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8242BEF8: 548A07FF  clrlwi. r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8242BEFC: 396B5514  addi r11, r11, 0x5514
	ctx.r[11].s64 = ctx.r[11].s64 + 21780;
	// 8242BF00: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8242BF04: 41820008  beq 0x8242bf0c
	if ctx.cr[0].eq {
	pc = 0x8242BF0C; continue 'dispatch;
	}
	// 8242BF08: 4BE94361  bl 0x822c0268
	ctx.lr = 0x8242BF0C;
	sub_822C0268(ctx, base);
	// 8242BF0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8242BF10: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8242BF14: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8242BF18: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8242BF1C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8242BF20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242BF28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8242BF28 size=208
    let mut pc: u32 = 0x8242BF28;
    'dispatch: loop {
        match pc {
            0x8242BF28 => {
    //   block [0x8242BF28..0x8242BFF8)
	// 8242BF28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8242BF2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8242BF30: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8242BF34: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8242BF38: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8242BF3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8242BF40: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8242BF44: 489E6D9D  bl 0x82e12ce0
	ctx.lr = 0x8242BF48;
	sub_82E12CE0(ctx, base);
	// 8242BF48: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 8242BF4C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 8242BF50: 38AA5544  addi r5, r10, 0x5544
	ctx.r[5].s64 = ctx.r[10].s64 + 21828;
	// 8242BF54: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8242BF58: 38CB6880  addi r6, r11, 0x6880
	ctx.r[6].s64 = ctx.r[11].s64 + 26752;
	// 8242BF5C: 90BF0000  stw r5, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 8242BF60: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 8242BF64: 989F0060  stb r4, 0x60(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[4].u8 ) };
	// 8242BF68: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 8242BF6C: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 8242BF70: 397F0070  addi r11, r31, 0x70
	ctx.r[11].s64 = ctx.r[31].s64 + 112;
	// 8242BF74: 395F00B0  addi r10, r31, 0xb0
	ctx.r[10].s64 = ctx.r[31].s64 + 176;
	// 8242BF78: 13803407  vcmpneb. (lvlx128) v28, v0, v6
	tmp.u32 = ctx.r[6].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8242BF7C: 3CA08200  lis r5, -0x7e00
	ctx.r[5].s64 = -2113929216;
	// 8242BF80: 13E73407  vcmpneb. (lvlx128) v31, v7, v6
	tmp.u32 = ctx.r[7].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8242BF84: 3C808200  lis r4, -0x7e00
	ctx.r[4].s64 = -2113929216;
	// 8242BF88: 13C83407  vcmpneb. (lvlx128) v30, v8, v6
	tmp.u32 = ctx.r[8].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8242BF8C: 13A93407  vcmpneb. (lvlx128) v29, v9, v6
	tmp.u32 = ctx.r[9].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8242BF90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242BFF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8242BFF8 size=640
    let mut pc: u32 = 0x8242BFF8;
    'dispatch: loop {
        match pc {
            0x8242BFF8 => {
    //   block [0x8242BFF8..0x8242C278)
	// 8242BFF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8242BFFC: 48D7C161  bl 0x831a815c
	ctx.lr = 0x8242C000;
	sub_831A8130(ctx, base);
	// 8242C000: 9421FE40  stwu r1, -0x1c0(r1)
	ea = ctx.r[1].u32.wrapping_add(-448 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8242C004: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 8242C008: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 8242C00C: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242C010: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8242C014: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8242C018: 4E800421  bctrl
	ctx.lr = 0x8242C01C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8242C01C: 3B600030  li r27, 0x30
	ctx.r[27].s64 = 48;
	// 8242C020: 3B800010  li r28, 0x10
	ctx.r[28].s64 = 16;
	// 8242C024: 13E01C07  vcmpneb. (lvlx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8242C028: 3BA00020  li r29, 0x20
	ctx.r[29].s64 = 32;
	// 8242C02C: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 8242C030: 394100A0  addi r10, r1, 0xa0
	ctx.r[10].s64 = ctx.r[1].s64 + 160;
	// 8242C034: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 8242C038: 13DB1C07  vcmpneb. (lvlx128) v30, v27, v3
	tmp.u32 = ctx.r[27].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8242C03C: 39010090  addi r8, r1, 0x90
	ctx.r[8].s64 = ctx.r[1].s64 + 144;
	// 8242C040: 13BC1C07  vcmpneb. (lvlx128) v29, v28, v3
	tmp.u32 = ctx.r[28].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8242C044: 139D1C07  vcmpneb. (lvlx128) v28, v29, v3
	tmp.u32 = ctx.r[29].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8242C048: 3CE08203  lis r7, -0x7dfd
	ctx.r[7].s64 = -2113732608;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242C278(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8242C278 size=196
    let mut pc: u32 = 0x8242C278;
    'dispatch: loop {
        match pc {
            0x8242C278 => {
    //   block [0x8242C278..0x8242C33C)
	// 8242C278: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8242C27C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8242C280: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8242C284: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8242C288: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8242C28C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8242C290: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8242C294: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8242C298: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8242C29C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8242C2A0: 4BE94699  bl 0x822c0938
	ctx.lr = 0x8242C2A4;
	sub_822C0938(ctx, base);
	// 8242C2A4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8242C2A8: 41820028  beq 0x8242c2d0
	if ctx.cr[0].eq {
	pc = 0x8242C2D0; continue 'dispatch;
	}
	// 8242C2AC: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8242C2B0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8242C2B4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8242C2B8: 392B551C  addi r9, r11, 0x551c
	ctx.r[9].s64 = ctx.r[11].s64 + 21788;
	// 8242C2BC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8242C2C0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8242C2C4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8242C2C8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8242C2CC: 48000008  b 0x8242c2d4
	pc = 0x8242C2D4; continue 'dispatch;
	// 8242C2D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8242C2D4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8242C2D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8242C2DC: 409A0044  bne cr6, 0x8242c320
	if !ctx.cr[6].eq {
	pc = 0x8242C320; continue 'dispatch;
	}
	// 8242C2E0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8242C2E4: 419A001C  beq cr6, 0x8242c300
	if ctx.cr[6].eq {
	pc = 0x8242C300; continue 'dispatch;
	}
	// 8242C2E8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242C2EC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8242C2F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8242C2F4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242C2F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8242C2FC: 4E800421  bctrl
	ctx.lr = 0x8242C300;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8242C300: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 8242C304: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8242C308: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8242C30C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8242C310: 816B199C  lwz r11, 0x199c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6556 as u32) ) } as u64;
	// 8242C314: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8242C318: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8242C31C: 4BE93CE5  bl 0x822c0000
	ctx.lr = 0x8242C320;
	sub_822C0000(ctx, base);
	// 8242C320: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8242C324: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8242C328: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8242C32C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8242C330: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8242C334: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8242C338: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242C340(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8242C340 size=196
    let mut pc: u32 = 0x8242C340;
    'dispatch: loop {
        match pc {
            0x8242C340 => {
    //   block [0x8242C340..0x8242C404)
	// 8242C340: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8242C344: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8242C348: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8242C34C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8242C350: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8242C354: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8242C358: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8242C35C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8242C360: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8242C364: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8242C368: 4BE945D1  bl 0x822c0938
	ctx.lr = 0x8242C36C;
	sub_822C0938(ctx, base);
	// 8242C36C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8242C370: 41820028  beq 0x8242c398
	if ctx.cr[0].eq {
	pc = 0x8242C398; continue 'dispatch;
	}
	// 8242C374: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8242C378: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8242C37C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8242C380: 392B5530  addi r9, r11, 0x5530
	ctx.r[9].s64 = ctx.r[11].s64 + 21808;
	// 8242C384: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8242C388: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8242C38C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8242C390: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8242C394: 48000008  b 0x8242c39c
	pc = 0x8242C39C; continue 'dispatch;
	// 8242C398: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8242C39C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8242C3A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8242C3A4: 409A0044  bne cr6, 0x8242c3e8
	if !ctx.cr[6].eq {
	pc = 0x8242C3E8; continue 'dispatch;
	}
	// 8242C3A8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8242C3AC: 419A001C  beq cr6, 0x8242c3c8
	if ctx.cr[6].eq {
	pc = 0x8242C3C8; continue 'dispatch;
	}
	// 8242C3B0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242C3B4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8242C3B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8242C3BC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242C3C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8242C3C4: 4E800421  bctrl
	ctx.lr = 0x8242C3C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8242C3C8: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 8242C3CC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8242C3D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8242C3D4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8242C3D8: 816B199C  lwz r11, 0x199c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6556 as u32) ) } as u64;
	// 8242C3DC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8242C3E0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8242C3E4: 4BE93C1D  bl 0x822c0000
	ctx.lr = 0x8242C3E8;
	sub_822C0000(ctx, base);
	// 8242C3E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8242C3EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8242C3F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8242C3F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8242C3F8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8242C3FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8242C400: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242C408(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8242C408 size=200
    let mut pc: u32 = 0x8242C408;
    'dispatch: loop {
        match pc {
            0x8242C408 => {
    //   block [0x8242C408..0x8242C4D0)
	// 8242C408: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8242C40C: 48D7BD55  bl 0x831a8160
	ctx.lr = 0x8242C410;
	sub_831A8130(ctx, base);
	// 8242C410: DBC1FFB8  stfd f30, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[30].u64 ) };
	// 8242C414: DBE1FFC0  stfd f31, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 8242C418: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8242C41C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8242C420: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8242C424: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 8242C428: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 8242C42C: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 8242C430: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 8242C434: 4BFFFA9D  bl 0x8242bed0
	ctx.lr = 0x8242C438;
	sub_8242BED0(ctx, base);
	// 8242C438: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8242C43C: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 8242C440: 396B55C0  addi r11, r11, 0x55c0
	ctx.r[11].s64 = ctx.r[11].s64 + 21952;
	// 8242C444: 388A5560  addi r4, r10, 0x5560
	ctx.r[4].s64 = ctx.r[10].s64 + 21856;
	// 8242C448: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8242C44C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8242C450: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 8242C454: 38600110  li r3, 0x110
	ctx.r[3].s64 = 272;
	// 8242C458: 489C5F91  bl 0x82df23e8
	ctx.lr = 0x8242C45C;
	sub_82DF23E8(ctx, base);
	// 8242C45C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8242C460: 41820014  beq 0x8242c474
	if ctx.cr[0].eq {
	pc = 0x8242C474; continue 'dispatch;
	}
	// 8242C464: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8242C468: 4BFFFAC1  bl 0x8242bf28
	ctx.lr = 0x8242C46C;
	sub_8242BF28(ctx, base);
	// 8242C46C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8242C470: 48000008  b 0x8242c478
	pc = 0x8242C478; continue 'dispatch;
	// 8242C474: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8242C478: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 8242C47C: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 8242C480: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8242C484: 3BAB0004  addi r29, r11, 4
	ctx.r[29].s64 = ctx.r[11].s64 + 4;
	// 8242C488: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8242C48C: 4BFFFDED  bl 0x8242c278
	ctx.lr = 0x8242C490;
	sub_8242C278(ctx, base);
	// 8242C490: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8242C494: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8242C498: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8242C49C: 4BE93B65  bl 0x822c0000
	ctx.lr = 0x8242C4A0;
	sub_822C0000(ctx, base);
	// 8242C4A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8242C4A4: D3FF0018  stfs f31, 0x18(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 8242C4A8: 939F0010  stw r28, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[28].u32 ) };
	// 8242C4AC: D3DF001C  stfs f30, 0x1c(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 8242C4B0: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 8242C4B4: 9B5F0014  stb r26, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[26].u8 ) };
	// 8242C4B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8242C4BC: 9B7F0015  stb r27, 0x15(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(21 as u32), ctx.r[27].u8 ) };
	// 8242C4C0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8242C4C4: CBC1FFB8  lfd f30, -0x48(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 8242C4C8: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 8242C4CC: 48D7BCE4  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242C4D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8242C4D0 size=76
    let mut pc: u32 = 0x8242C4D0;
    'dispatch: loop {
        match pc {
            0x8242C4D0 => {
    //   block [0x8242C4D0..0x8242C51C)
	// 8242C4D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8242C4D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8242C4D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8242C4DC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8242C4E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8242C4E4: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8242C4E8: 396B55C0  addi r11, r11, 0x55c0
	ctx.r[11].s64 = ctx.r[11].s64 + 21952;
	// 8242C4EC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8242C4F0: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8242C4F4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8242C4F8: 419A0008  beq cr6, 0x8242c500
	if ctx.cr[6].eq {
	pc = 0x8242C500; continue 'dispatch;
	}
	// 8242C4FC: 4BE94395  bl 0x822c0890
	ctx.lr = 0x8242C500;
	sub_822C0890(ctx, base);
	// 8242C500: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8242C504: 4BFFF9CD  bl 0x8242bed0
	ctx.lr = 0x8242C508;
	sub_8242BED0(ctx, base);
	// 8242C508: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8242C50C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8242C510: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8242C514: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8242C518: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242C520(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8242C520 size=76
    let mut pc: u32 = 0x8242C520;
    'dispatch: loop {
        match pc {
            0x8242C520 => {
    //   block [0x8242C520..0x8242C56C)
	// 8242C520: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8242C524: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8242C528: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8242C52C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8242C530: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8242C534: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8242C538: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8242C53C: 4BFFFF95  bl 0x8242c4d0
	ctx.lr = 0x8242C540;
	sub_8242C4D0(ctx, base);
	// 8242C540: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8242C544: 4182000C  beq 0x8242c550
	if ctx.cr[0].eq {
	pc = 0x8242C550; continue 'dispatch;
	}
	// 8242C548: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8242C54C: 4BE93D1D  bl 0x822c0268
	ctx.lr = 0x8242C550;
	sub_822C0268(ctx, base);
	// 8242C550: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8242C554: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8242C558: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8242C55C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8242C560: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8242C564: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8242C568: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242C570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8242C570 size=136
    let mut pc: u32 = 0x8242C570;
    'dispatch: loop {
        match pc {
            0x8242C570 => {
    //   block [0x8242C570..0x8242C5F8)
	// 8242C570: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8242C574: 48D7BBF9  bl 0x831a816c
	ctx.lr = 0x8242C578;
	sub_831A8130(ctx, base);
	// 8242C578: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8242C57C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8242C580: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8242C584: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8242C588: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 8242C58C: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 8242C590: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 8242C594: 489C5E55  bl 0x82df23e8
	ctx.lr = 0x8242C598;
	sub_82DF23E8(ctx, base);
	// 8242C598: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8242C59C: 41820028  beq 0x8242c5c4
	if ctx.cr[0].eq {
	pc = 0x8242C5C4; continue 'dispatch;
	}
	// 8242C5A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8242C5A4: 48A2D0FD  bl 0x82e596a0
	ctx.lr = 0x8242C5A8;
	sub_82E596A0(ctx, base);
	// 8242C5A8: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 8242C5AC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8242C5B0: 394A5558  addi r10, r10, 0x5558
	ctx.r[10].s64 = ctx.r[10].s64 + 21848;
	// 8242C5B4: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8242C5B8: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 8242C5BC: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 8242C5C0: 48000008  b 0x8242c5c8
	pc = 0x8242C5C8; continue 'dispatch;
	// 8242C5C4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8242C5C8: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8242C5CC: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8242C5D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8242C5D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8242C5D8: 4BFFFD69  bl 0x8242c340
	ctx.lr = 0x8242C5DC;
	sub_8242C340(ctx, base);
	// 8242C5DC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8242C5E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8242C5E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8242C5E8: 4BE93A19  bl 0x822c0000
	ctx.lr = 0x8242C5EC;
	sub_822C0000(ctx, base);
	// 8242C5EC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8242C5F0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8242C5F4: 48D7BBC8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242C5F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8242C5F8 size=1028
    let mut pc: u32 = 0x8242C5F8;
    'dispatch: loop {
        match pc {
            0x8242C5F8 => {
    //   block [0x8242C5F8..0x8242C9FC)
	// 8242C5F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8242C5FC: 48D7BB61  bl 0x831a815c
	ctx.lr = 0x8242C600;
	sub_831A8130(ctx, base);
	// 8242C600: DBC1FFB0  stfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 8242C604: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 8242C608: 9421FDC0  stwu r1, -0x240(r1)
	ea = ctx.r[1].u32.wrapping_add(-576 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8242C60C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8242C610: 897F000C  lbz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8242C614: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8242C618: 408203D4  bne 0x8242c9ec
	if !ctx.cr[0].eq {
	pc = 0x8242C9EC; continue 'dispatch;
	}
	// 8242C61C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8242C620: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8242C624: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 8242C628: 4BFFFF49  bl 0x8242c570
	ctx.lr = 0x8242C62C;
	sub_8242C570(ctx, base);
	// 8242C62C: 83210054  lwz r25, 0x54(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8242C630: 83410050  lwz r26, 0x50(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8242C634: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 8242C638: 93210064  stw r25, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[25].u32 ) };
	// 8242C63C: 93410060  stw r26, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[26].u32 ) };
	// 8242C640: 419A0024  beq cr6, 0x8242c664
	if ctx.cr[6].eq {
	pc = 0x8242C664; continue 'dispatch;
	}
	// 8242C644: 39790004  addi r11, r25, 4
	ctx.r[11].s64 = ctx.r[25].s64 + 4;
	// 8242C648: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8242C64C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8242C650: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8242C654: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8242C658: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8242C65C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8242C660: 4082FFE8  bne 0x8242c648
	if !ctx.cr[0].eq {
	pc = 0x8242C648; continue 'dispatch;
	}
	// 8242C664: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 8242C668: 809F0010  lwz r4, 0x10(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 8242C66C: 480E2E5D  bl 0x8250f4c8
	ctx.lr = 0x8242C670;
	sub_8250F4C8(ctx, base);
	// 8242C670: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242C674: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8242C678: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 8242C67C: 409A0008  bne cr6, 0x8242c684
	if !ctx.cr[6].eq {
	pc = 0x8242C684; continue 'dispatch;
	}
	// 8242C680: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8242C684: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8242C688: 3BC10060  addi r30, r1, 0x60
	ctx.r[30].s64 = ctx.r[1].s64 + 96;
	// 8242C68C: 480DC38D  bl 0x82508a18
	ctx.lr = 0x8242C690;
	sub_82508A18(ctx, base);
	// 8242C690: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 8242C694: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 8242C698: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 8242C69C: 388A5560  addi r4, r10, 0x5560
	ctx.r[4].s64 = ctx.r[10].s64 + 21856;
	// 8242C6A0: 38A00080  li r5, 0x80
	ctx.r[5].s64 = 128;
	// 8242C6A4: 386B0028  addi r3, r11, 0x28
	ctx.r[3].s64 = ctx.r[11].s64 + 40;
	// 8242C6A8: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 8242C6AC: 48A2A93D  bl 0x82e56fe8
	ctx.lr = 0x8242C6B0;
	sub_82E56FE8(ctx, base);
	// 8242C6B0: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 8242C6B4: 489C55DD  bl 0x82df1c90
	ctx.lr = 0x8242C6B8;
	sub_82DF1C90(ctx, base);
	// 8242C6B8: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8242C6BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8242C6C0: 419A0008  beq cr6, 0x8242c6c8
	if ctx.cr[6].eq {
	pc = 0x8242C6C8; continue 'dispatch;
	}
	// 8242C6C4: 4BE941CD  bl 0x822c0890
	ctx.lr = 0x8242C6C8;
	sub_822C0890(ctx, base);
	// 8242C6C8: 807A0018  lwz r3, 0x18(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(24 as u32) ) } as u64;
	// 8242C6CC: 489E6045  bl 0x82e12710
	ctx.lr = 0x8242C6D0;
	sub_82E12710(ctx, base);
	// 8242C6D0: 807A0018  lwz r3, 0x18(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(24 as u32) ) } as u64;
	// 8242C6D4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242C6D8: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8242C6DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8242C6E0: 4E800421  bctrl
	ctx.lr = 0x8242C6E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8242C6E4: 3B600010  li r27, 0x10
	ctx.r[27].s64 = 16;
	// 8242C6E8: 3B800020  li r28, 0x20
	ctx.r[28].s64 = 32;
	// 8242C6EC: 13E01C07  vcmpneb. (lvlx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8242C6F0: 3BA00030  li r29, 0x30
	ctx.r[29].s64 = 48;
	// 8242C6F4: 809F0010  lwz r4, 0x10(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 8242C6F8: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 8242C6FC: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 8242C700: 39210090  addi r9, r1, 0x90
	ctx.r[9].s64 = ctx.r[1].s64 + 144;
	// 8242C704: 13DB1C07  vcmpneb. (lvlx128) v30, v27, v3
	tmp.u32 = ctx.r[27].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8242C708: 390100A0  addi r8, r1, 0xa0
	ctx.r[8].s64 = ctx.r[1].s64 + 160;
	// 8242C70C: 13BC1C07  vcmpneb. (lvlx128) v29, v28, v3
	tmp.u32 = ctx.r[28].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8242C710: 139D1C07  vcmpneb. (lvlx128) v28, v29, v3
	tmp.u32 = ctx.r[29].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8242C714: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242CA00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8242CA00 size=272
    let mut pc: u32 = 0x8242CA00;
    'dispatch: loop {
        match pc {
            0x8242CA00 => {
    //   block [0x8242CA00..0x8242CB10)
	// 8242CA00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8242CA04: 48D7B765  bl 0x831a8168
	ctx.lr = 0x8242CA08;
	sub_831A8130(ctx, base);
	// 8242CA08: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8242CA0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8242CA10: 897F000C  lbz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8242CA14: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8242CA18: 418200F0  beq 0x8242cb08
	if ctx.cr[0].eq {
	pc = 0x8242CB08; continue 'dispatch;
	}
	// 8242CA1C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8242CA20: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8242CA24: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 8242CA28: 4BFFFB49  bl 0x8242c570
	ctx.lr = 0x8242CA2C;
	sub_8242C570(ctx, base);
	// 8242CA2C: 83C1005C  lwz r30, 0x5c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8242CA30: 83A10058  lwz r29, 0x58(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8242CA34: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8242CA38: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 8242CA3C: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 8242CA40: 419A0024  beq cr6, 0x8242ca64
	if ctx.cr[6].eq {
	pc = 0x8242CA64; continue 'dispatch;
	}
	// 8242CA44: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 8242CA48: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8242CA4C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8242CA50: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8242CA54: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8242CA58: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8242CA5C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8242CA60: 4082FFE8  bne 0x8242ca48
	if !ctx.cr[0].eq {
	pc = 0x8242CA48; continue 'dispatch;
	}
	// 8242CA64: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8242CA68: 809F0010  lwz r4, 0x10(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 8242CA6C: 480E2A5D  bl 0x8250f4c8
	ctx.lr = 0x8242CA70;
	sub_8250F4C8(ctx, base);
	// 8242CA70: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242CA74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8242CA78: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 8242CA7C: 409A0008  bne cr6, 0x8242ca84
	if !ctx.cr[6].eq {
	pc = 0x8242CA84; continue 'dispatch;
	}
	// 8242CA80: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8242CA84: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8242CA88: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 8242CA8C: 480DBF8D  bl 0x82508a18
	ctx.lr = 0x8242CA90;
	sub_82508A18(ctx, base);
	// 8242CA90: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 8242CA94: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 8242CA98: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 8242CA9C: 388A5560  addi r4, r10, 0x5560
	ctx.r[4].s64 = ctx.r[10].s64 + 21856;
	// 8242CAA0: 38A000C0  li r5, 0xc0
	ctx.r[5].s64 = 192;
	// 8242CAA4: 386B0028  addi r3, r11, 0x28
	ctx.r[3].s64 = ctx.r[11].s64 + 40;
	// 8242CAA8: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 8242CAAC: 48A2A53D  bl 0x82e56fe8
	ctx.lr = 0x8242CAB0;
	sub_82E56FE8(ctx, base);
	// 8242CAB0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8242CAB4: 489C51DD  bl 0x82df1c90
	ctx.lr = 0x8242CAB8;
	sub_82DF1C90(ctx, base);
	// 8242CAB8: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8242CABC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8242CAC0: 419A0008  beq cr6, 0x8242cac8
	if ctx.cr[6].eq {
	pc = 0x8242CAC8; continue 'dispatch;
	}
	// 8242CAC4: 4BE93DCD  bl 0x822c0890
	ctx.lr = 0x8242CAC8;
	sub_822C0890(ctx, base);
	// 8242CAC8: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242CACC: 807D0018  lwz r3, 0x18(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 8242CAD0: 489E5F29  bl 0x82e129f8
	ctx.lr = 0x8242CAD4;
	sub_82E129F8(ctx, base);
	// 8242CAD4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8242CAD8: 809F0010  lwz r4, 0x10(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 8242CADC: 48389AFD  bl 0x827b65d8
	ctx.lr = 0x8242CAE0;
	sub_827B65D8(ctx, base);
	// 8242CAE0: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242CAE4: 4BEC15CD  bl 0x822ee0b0
	ctx.lr = 0x8242CAE8;
	sub_822EE0B0(ctx, base);
	// 8242CAE8: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 8242CAEC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8242CAF0: 419A0008  beq cr6, 0x8242caf8
	if ctx.cr[6].eq {
	pc = 0x8242CAF8; continue 'dispatch;
	}
	// 8242CAF4: 4BE93D9D  bl 0x822c0890
	ctx.lr = 0x8242CAF8;
	sub_822C0890(ctx, base);
	// 8242CAF8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8242CAFC: 419A000C  beq cr6, 0x8242cb08
	if ctx.cr[6].eq {
	pc = 0x8242CB08; continue 'dispatch;
	}
	// 8242CB00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8242CB04: 4BE93D8D  bl 0x822c0890
	ctx.lr = 0x8242CB08;
	sub_822C0890(ctx, base);
	// 8242CB08: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8242CB0C: 48D7B6AC  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242CB10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8242CB10 size=20
    let mut pc: u32 = 0x8242CB10;
    'dispatch: loop {
        match pc {
            0x8242CB10 => {
    //   block [0x8242CB10..0x8242CB24)
	// 8242CB10: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8242CB14: 90830004  stw r4, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 8242CB18: 396B55C8  addi r11, r11, 0x55c8
	ctx.r[11].s64 = ctx.r[11].s64 + 21960;
	// 8242CB1C: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8242CB20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242CB28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8242CB28 size=172
    let mut pc: u32 = 0x8242CB28;
    'dispatch: loop {
        match pc {
            0x8242CB28 => {
    //   block [0x8242CB28..0x8242CBD4)
	// 8242CB28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8242CB2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8242CB30: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8242CB34: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8242CB38: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8242CB3C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8242CB40: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8242CB44: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8242CB48: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8242CB4C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8242CB50: 4BE93DE9  bl 0x822c0938
	ctx.lr = 0x8242CB54;
	sub_822C0938(ctx, base);
	// 8242CB54: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8242CB58: 41820028  beq 0x8242cb80
	if ctx.cr[0].eq {
	pc = 0x8242CB80; continue 'dispatch;
	}
	// 8242CB5C: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8242CB60: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8242CB64: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8242CB68: 392B55D8  addi r9, r11, 0x55d8
	ctx.r[9].s64 = ctx.r[11].s64 + 21976;
	// 8242CB6C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8242CB70: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8242CB74: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8242CB78: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8242CB7C: 48000008  b 0x8242cb84
	pc = 0x8242CB84; continue 'dispatch;
	// 8242CB80: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8242CB84: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8242CB88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8242CB8C: 409A002C  bne cr6, 0x8242cbb8
	if !ctx.cr[6].eq {
	pc = 0x8242CBB8; continue 'dispatch;
	}
	// 8242CB90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8242CB94: 4BE936D5  bl 0x822c0268
	ctx.lr = 0x8242CB98;
	sub_822C0268(ctx, base);
	// 8242CB98: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 8242CB9C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8242CBA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8242CBA4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8242CBA8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8242CBAC: 816B1A9C  lwz r11, 0x1a9c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6812 as u32) ) } as u64;
	// 8242CBB0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8242CBB4: 4BE9344D  bl 0x822c0000
	ctx.lr = 0x8242CBB8;
	sub_822C0000(ctx, base);
	// 8242CBB8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8242CBBC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8242CBC0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8242CBC4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8242CBC8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8242CBCC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8242CBD0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242CBD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8242CBD8 size=1168
    let mut pc: u32 = 0x8242CBD8;
    'dispatch: loop {
        match pc {
            0x8242CBD8 => {
    //   block [0x8242CBD8..0x8242D068)
	// 8242CBD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8242CBDC: 48D7B58D  bl 0x831a8168
	ctx.lr = 0x8242CBE0;
	sub_831A8130(ctx, base);
	// 8242CBE0: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 8242CBE4: 48D7BE91  bl 0x831a8a74
	ctx.lr = 0x8242CBE8;
	sub_831A8A40(ctx, base);
	// 8242CBE8: 3980FF90  li r12, -0x70
	ctx.r[12].s64 = -112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242D068(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8242D068 size=112
    let mut pc: u32 = 0x8242D068;
    'dispatch: loop {
        match pc {
            0x8242D068 => {
    //   block [0x8242D068..0x8242D0D8)
	// 8242D068: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8242D06C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8242D070: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8242D074: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8242D078: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8242D07C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8242D080: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8242D084: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 8242D088: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8242D08C: 4BE97455  bl 0x822c44e0
	ctx.lr = 0x8242D090;
	sub_822C44E0(ctx, base);
	// 8242D090: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8242D094: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8242D098: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8242D09C: 4BE92F65  bl 0x822c0000
	ctx.lr = 0x8242D0A0;
	sub_822C0000(ctx, base);
	// 8242D0A0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8242D0A4: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8242D0A8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8242D0AC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242D0B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8242D0B4: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8242D0B8: 419A0008  beq cr6, 0x8242d0c0
	if ctx.cr[6].eq {
	pc = 0x8242D0C0; continue 'dispatch;
	}
	// 8242D0BC: 4BE937D5  bl 0x822c0890
	ctx.lr = 0x8242D0C0;
	sub_822C0890(ctx, base);
	// 8242D0C0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8242D0C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8242D0C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8242D0CC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8242D0D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8242D0D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242D0D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8242D0D8 size=112
    let mut pc: u32 = 0x8242D0D8;
    'dispatch: loop {
        match pc {
            0x8242D0D8 => {
    //   block [0x8242D0D8..0x8242D148)
	// 8242D0D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8242D0DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8242D0E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8242D0E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8242D0E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8242D0EC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8242D0F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8242D0F4: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 8242D0F8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8242D0FC: 4BFFFA2D  bl 0x8242cb28
	ctx.lr = 0x8242D100;
	sub_8242CB28(ctx, base);
	// 8242D100: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8242D104: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8242D108: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8242D10C: 4BE92EF5  bl 0x822c0000
	ctx.lr = 0x8242D110;
	sub_822C0000(ctx, base);
	// 8242D110: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8242D114: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8242D118: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8242D11C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242D120: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8242D124: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8242D128: 419A0008  beq cr6, 0x8242d130
	if ctx.cr[6].eq {
	pc = 0x8242D130; continue 'dispatch;
	}
	// 8242D12C: 4BE93765  bl 0x822c0890
	ctx.lr = 0x8242D130;
	sub_822C0890(ctx, base);
	// 8242D130: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8242D134: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8242D138: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8242D13C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8242D140: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8242D144: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242D148(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8242D148 size=844
    let mut pc: u32 = 0x8242D148;
    'dispatch: loop {
        match pc {
            0x8242D148 => {
    //   block [0x8242D148..0x8242D494)
	// 8242D148: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8242D14C: 48D7B021  bl 0x831a816c
	ctx.lr = 0x8242D150;
	sub_831A8130(ctx, base);
	// 8242D150: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 8242D154: 48D7B919  bl 0x831a8a6c
	ctx.lr = 0x8242D158;
	sub_831A8A40(ctx, base);
	// 8242D158: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8242D15C: 38600080  li r3, 0x80
	ctx.r[3].s64 = 128;
	// 8242D160: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8242D164: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8242D168: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 8242D16C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 8242D170: FFA01890  fmr f29, f3
	ctx.f[29].f64 = ctx.f[3].f64;
	// 8242D174: FF802090  fmr f28, f4
	ctx.f[28].f64 = ctx.f[4].f64;
	// 8242D178: FF602890  fmr f27, f5
	ctx.f[27].f64 = ctx.f[5].f64;
	// 8242D17C: FF403090  fmr f26, f6
	ctx.f[26].f64 = ctx.f[6].f64;
	// 8242D180: FF203890  fmr f25, f7
	ctx.f[25].f64 = ctx.f[7].f64;
	// 8242D184: 489C523D  bl 0x82df23c0
	ctx.lr = 0x8242D188;
	sub_82DF23C0(ctx, base);
	// 8242D188: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8242D18C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8242D190: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 8242D194: 4BFFFED5  bl 0x8242d068
	ctx.lr = 0x8242D198;
	sub_8242D068(ctx, base);
	// 8242D198: 38600090  li r3, 0x90
	ctx.r[3].s64 = 144;
	// 8242D19C: 489C33E5  bl 0x82df0580
	ctx.lr = 0x8242D1A0;
	sub_82DF0580(ctx, base);
	// 8242D1A0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8242D1A4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8242D1A8: 4BFFFF31  bl 0x8242d0d8
	ctx.lr = 0x8242D1AC;
	sub_8242D0D8(ctx, base);
	// 8242D1AC: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 8242D1B0: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 8242D1B4: 81610114  lwz r11, 0x114(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(276 as u32) ) } as u64;
	// 8242D1B8: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 8242D1BC: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 8242D1C0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8242D1C4: C18A9530  lfs f12, -0x6ad0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27344 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8242D1C8: 38C00003  li r6, 3
	ctx.r[6].s64 = 3;
	// 8242D1CC: ED7D0332  fmuls f11, f29, f12
	ctx.f[11].f64 = (((ctx.f[29].f64 * ctx.f[12].f64) as f32) as f64);
	// 8242D1D0: C1A908A4  lfs f13, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8242D1D4: ED5A0332  fmuls f10, f26, f12
	ctx.f[10].f64 = (((ctx.f[26].f64 * ctx.f[12].f64) as f32) as f64);
	// 8242D1D8: C00808A8  lfs f0, 0x8a8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8242D1DC: C1879450  lfs f12, -0x6bb0(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8242D1E0: 38E00002  li r7, 2
	ctx.r[7].s64 = 2;
	// 8242D1E4: ED3D0332  fmuls f9, f29, f12
	ctx.f[9].f64 = (((ctx.f[29].f64 * ctx.f[12].f64) as f32) as f64);
	// 8242D1E8: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 8242D1EC: ED9A0332  fmuls f12, f26, f12
	ctx.f[12].f64 = (((ctx.f[26].f64 * ctx.f[12].f64) as f32) as f64);
	// 8242D1F0: 39000004  li r8, 4
	ctx.r[8].s64 = 4;
	// 8242D1F4: 39200005  li r9, 5
	ctx.r[9].s64 = 5;
	// 8242D1F8: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242D1FC: D16A0000  stfs f11, 0(r10)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 8242D200: D3CA0004  stfs f30, 4(r10)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 8242D204: D1AA0008  stfs f13, 8(r10)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 8242D208: D00A000C  stfs f0, 0xc(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 8242D20C: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242D210: D12A0010  stfs f9, 0x10(r10)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 8242D214: D3CA0014  stfs f30, 0x14(r10)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8242D218: D1AA0018  stfs f13, 0x18(r10)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 8242D21C: D00A001C  stfs f0, 0x1c(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 8242D220: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242D224: D12A0020  stfs f9, 0x20(r10)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 8242D228: D3EA0024  stfs f31, 0x24(r10)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 8242D22C: D1AA0028  stfs f13, 0x28(r10)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 8242D230: D00A002C  stfs f0, 0x2c(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 8242D234: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242D238: D16A0030  stfs f11, 0x30(r10)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8242D23C: D3EA0034  stfs f31, 0x34(r10)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 8242D240: D1AA0038  stfs f13, 0x38(r10)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 8242D244: D00A003C  stfs f0, 0x3c(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 8242D248: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242D24C: D14A0040  stfs f10, 0x40(r10)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 8242D250: D36A0044  stfs f27, 0x44(r10)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 8242D254: D32A0048  stfs f25, 0x48(r10)
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 8242D258: D00A004C  stfs f0, 0x4c(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 8242D25C: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242D260: D18A0050  stfs f12, 0x50(r10)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8242D264: D36A0054  stfs f27, 0x54(r10)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8242D268: D32A0058  stfs f25, 0x58(r10)
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8242D26C: D00A005C  stfs f0, 0x5c(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 8242D270: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242D274: D18A0060  stfs f12, 0x60(r10)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8242D278: D38A0064  stfs f28, 0x64(r10)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 8242D27C: D32A0068  stfs f25, 0x68(r10)
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 8242D280: D00A006C  stfs f0, 0x6c(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 8242D284: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242D288: D14A0070  stfs f10, 0x70(r10)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8242D28C: D38A0074  stfs f28, 0x74(r10)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 8242D290: D32A0078  stfs f25, 0x78(r10)
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8242D294: D00A007C  stfs f0, 0x7c(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 8242D298: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242D29C: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8242D2A0: 13C050C7  vcmpequd (lvx128) v30, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8242D2A4: 38600007  li r3, 7
	ctx.r[3].s64 = 7;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242D498(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8242D498 size=20
    let mut pc: u32 = 0x8242D498;
    'dispatch: loop {
        match pc {
            0x8242D498 => {
    //   block [0x8242D498..0x8242D4AC)
	// 8242D498: D023014C  stfs f1, 0x14c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(332 as u32), tmp.u32 ) };
	// 8242D49C: 90E30158  stw r7, 0x158(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(344 as u32), ctx.r[7].u32 ) };
	// 8242D4A0: D0430150  stfs f2, 0x150(r3)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(336 as u32), tmp.u32 ) };
	// 8242D4A4: D0630154  stfs f3, 0x154(r3)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(340 as u32), tmp.u32 ) };
	// 8242D4A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242D4B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8242D4B0 size=12
    let mut pc: u32 = 0x8242D4B0;
    'dispatch: loop {
        match pc {
            0x8242D4B0 => {
    //   block [0x8242D4B0..0x8242D4BC)
	// 8242D4B0: D0230174  stfs f1, 0x174(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(372 as u32), tmp.u32 ) };
	// 8242D4B4: D0230178  stfs f1, 0x178(r3)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(376 as u32), tmp.u32 ) };
	// 8242D4B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242D4C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8242D4C0 size=64
    let mut pc: u32 = 0x8242D4C0;
    'dispatch: loop {
        match pc {
            0x8242D4C0 => {
    //   block [0x8242D4C0..0x8242D500)
	// 8242D4C0: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242D4C4: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8242D4C8: 91440000  stw r10, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8242D4CC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8242D4D0: 892A0041  lbz r9, 0x41(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(65 as u32) ) } as u64;
	// 8242D4D4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8242D4D8: 409A0008  bne cr6, 0x8242d4e0
	if !ctx.cr[6].eq {
	pc = 0x8242D4E0; continue 'dispatch;
	}
	// 8242D4DC: 908A0004  stw r4, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 8242D4E0: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242D4E4: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8242D4E8: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242D4EC: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242D4F0: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8242D4F4: 409A000C  bne cr6, 0x8242d500
	if !ctx.cr[6].eq {
		sub_8242D500(ctx, base);
		return;
	}
	// 8242D4F8: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8242D4FC: 48000020  b 0x8242d51c
	sub_8242D518(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242D500(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8242D500 size=24
    let mut pc: u32 = 0x8242D500;
    'dispatch: loop {
        match pc {
            0x8242D500 => {
    //   block [0x8242D500..0x8242D518)
	// 8242D500: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242D504: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 8242D508: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8242D50C: 409A000C  bne cr6, 0x8242d518
	if !ctx.cr[6].eq {
		sub_8242D518(ctx, base);
		return;
	}
	// 8242D510: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8242D514: 48000008  b 0x8242d51c
	sub_8242D518(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242D518(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8242D518 size=16
    let mut pc: u32 = 0x8242D518;
    'dispatch: loop {
        match pc {
            0x8242D518 => {
    //   block [0x8242D518..0x8242D528)
	// 8242D518: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8242D51C: 908B0008  stw r4, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 8242D520: 91640004  stw r11, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8242D524: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242D528(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8242D528 size=16
    let mut pc: u32 = 0x8242D528;
    'dispatch: loop {
        match pc {
            0x8242D528 => {
    //   block [0x8242D528..0x8242D538)
	// 8242D528: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242D52C: 894B0041  lbz r10, 0x41(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(65 as u32) ) } as u64;
	// 8242D530: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8242D534: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242D538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8242D538 size=24
    let mut pc: u32 = 0x8242D538;
    'dispatch: loop {
        match pc {
            0x8242D538 => {
    //   block [0x8242D538..0x8242D550)
	// 8242D538: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8242D53C: 892A0041  lbz r9, 0x41(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(65 as u32) ) } as u64;
	// 8242D540: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8242D544: 409A0040  bne cr6, 0x8242d584
	if !ctx.cr[6].eq {
		sub_8242D56C(ctx, base);
		return;
	}
	// 8242D548: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242D54C: 4800000C  b 0x8242d558
	sub_8242D550(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242D550(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8242D550 size=28
    let mut pc: u32 = 0x8242D550;
    'dispatch: loop {
        match pc {
            0x8242D550 => {
    //   block [0x8242D550..0x8242D56C)
	// 8242D550: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 8242D554: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242D558: 892B0041  lbz r9, 0x41(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(65 as u32) ) } as u64;
	// 8242D55C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8242D560: 419AFFF0  beq cr6, 0x8242d550
	if ctx.cr[6].eq {
	pc = 0x8242D550; continue 'dispatch;
	}
	// 8242D564: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8242D568: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242D56C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8242D56C size=48
    let mut pc: u32 = 0x8242D56C;
    'dispatch: loop {
        match pc {
            0x8242D56C => {
    //   block [0x8242D56C..0x8242D59C)
	// 8242D56C: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242D570: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8242D574: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8242D578: 409A001C  bne cr6, 0x8242d594
	if !ctx.cr[6].eq {
	pc = 0x8242D594; continue 'dispatch;
	}
	// 8242D57C: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8242D580: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8242D584: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242D588: 894B0041  lbz r10, 0x41(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(65 as u32) ) } as u64;
	// 8242D58C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8242D590: 419AFFDC  beq cr6, 0x8242d56c
	if ctx.cr[6].eq {
	pc = 0x8242D56C; continue 'dispatch;
	}
	// 8242D594: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8242D598: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242D5A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8242D5A0 size=24
    let mut pc: u32 = 0x8242D5A0;
    'dispatch: loop {
        match pc {
            0x8242D5A0 => {
    //   block [0x8242D5A0..0x8242D5B8)
	// 8242D5A0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242D5A4: 894B0041  lbz r10, 0x41(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(65 as u32) ) } as u64;
	// 8242D5A8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8242D5AC: 419A000C  beq cr6, 0x8242d5b8
	if ctx.cr[6].eq {
		sub_8242D5B8(ctx, base);
		return;
	}
	// 8242D5B0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8242D5B4: 48000070  b 0x8242d624
	sub_8242D624(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242D5B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8242D5B8 size=24
    let mut pc: u32 = 0x8242D5B8;
    'dispatch: loop {
        match pc {
            0x8242D5B8 => {
    //   block [0x8242D5B8..0x8242D5D0)
	// 8242D5B8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242D5BC: 892A0041  lbz r9, 0x41(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(65 as u32) ) } as u64;
	// 8242D5C0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8242D5C4: 409A0040  bne cr6, 0x8242d604
	if !ctx.cr[6].eq {
		sub_8242D5EC(ctx, base);
		return;
	}
	// 8242D5C8: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 8242D5CC: 4800000C  b 0x8242d5d8
	sub_8242D5D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242D5D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8242D5D0 size=28
    let mut pc: u32 = 0x8242D5D0;
    'dispatch: loop {
        match pc {
            0x8242D5D0 => {
    //   block [0x8242D5D0..0x8242D5EC)
	// 8242D5D0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 8242D5D4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8242D5D8: 892B0041  lbz r9, 0x41(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(65 as u32) ) } as u64;
	// 8242D5DC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8242D5E0: 419AFFF0  beq cr6, 0x8242d5d0
	if ctx.cr[6].eq {
	pc = 0x8242D5D0; continue 'dispatch;
	}
	// 8242D5E4: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8242D5E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242D5EC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8242D5EC size=56
    let mut pc: u32 = 0x8242D5EC;
    'dispatch: loop {
        match pc {
            0x8242D5EC => {
    //   block [0x8242D5EC..0x8242D624)
	// 8242D5EC: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242D5F0: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242D5F4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8242D5F8: 409A001C  bne cr6, 0x8242d614
	if !ctx.cr[6].eq {
	pc = 0x8242D614; continue 'dispatch;
	}
	// 8242D5FC: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8242D600: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8242D604: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242D608: 894B0041  lbz r10, 0x41(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(65 as u32) ) } as u64;
	// 8242D60C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8242D610: 419AFFDC  beq cr6, 0x8242d5ec
	if ctx.cr[6].eq {
	pc = 0x8242D5EC; continue 'dispatch;
	}
	// 8242D614: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242D618: 894A0041  lbz r10, 0x41(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(65 as u32) ) } as u64;
	// 8242D61C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8242D620: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242D624(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8242D624 size=8
    let mut pc: u32 = 0x8242D624;
    'dispatch: loop {
        match pc {
            0x8242D624 => {
    //   block [0x8242D624..0x8242D62C)
	// 8242D624: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8242D628: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242D630(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8242D630 size=80
    let mut pc: u32 = 0x8242D630;
    'dispatch: loop {
        match pc {
            0x8242D630 => {
    //   block [0x8242D630..0x8242D680)
	// 8242D630: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8242D634: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8242D638: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8242D63C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8242D640: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8242D644: 48A2C05D  bl 0x82e596a0
	ctx.lr = 0x8242D648;
	sub_82E596A0(ctx, base);
	// 8242D648: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 8242D64C: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 8242D650: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 8242D654: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 8242D658: 394A5674  addi r10, r10, 0x5674
	ctx.r[10].s64 = ctx.r[10].s64 + 22132;
	// 8242D65C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8242D660: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8242D664: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242D680(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8242D680 size=108
    let mut pc: u32 = 0x8242D680;
    'dispatch: loop {
        match pc {
            0x8242D680 => {
    //   block [0x8242D680..0x8242D6EC)
	// 8242D680: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8242D684: 48D7AAE9  bl 0x831a816c
	ctx.lr = 0x8242D688;
	sub_831A8130(ctx, base);
	// 8242D688: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8242D68C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8242D690: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8242D694: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 8242D698: 48A2C009  bl 0x82e596a0
	ctx.lr = 0x8242D69C;
	sub_82E596A0(ctx, base);
	// 8242D69C: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8242D6A0: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 8242D6A4: 3D208338  lis r9, -0x7cc8
	ctx.r[9].s64 = -2093481984;
	// 8242D6A8: 396B567C  addi r11, r11, 0x567c
	ctx.r[11].s64 = ctx.r[11].s64 + 22140;
	// 8242D6AC: 39000030  li r8, 0x30
	ctx.r[8].s64 = 48;
	// 8242D6B0: 39296910  addi r9, r9, 0x6910
	ctx.r[9].s64 = ctx.r[9].s64 + 26896;
	// 8242D6B4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8242D6B8: 38E00040  li r7, 0x40
	ctx.r[7].s64 = 64;
	// 8242D6BC: 13E0F0C7  vcmpequd (lvx128) v31, v0, v30
	tmp.u32 = ctx.r[30].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242D6F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8242D6F0 size=112
    let mut pc: u32 = 0x8242D6F0;
    'dispatch: loop {
        match pc {
            0x8242D6F0 => {
    //   block [0x8242D6F0..0x8242D760)
	// 8242D6F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8242D6F4: 48D7AA79  bl 0x831a816c
	ctx.lr = 0x8242D6F8;
	sub_831A8130(ctx, base);
	// 8242D6F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8242D6FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8242D700: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8242D704: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 8242D708: 48A2BF99  bl 0x82e596a0
	ctx.lr = 0x8242D70C;
	sub_82E596A0(ctx, base);
	// 8242D70C: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8242D710: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 8242D714: 3D208338  lis r9, -0x7cc8
	ctx.r[9].s64 = -2093481984;
	// 8242D718: 396B5684  addi r11, r11, 0x5684
	ctx.r[11].s64 = ctx.r[11].s64 + 22148;
	// 8242D71C: 39000030  li r8, 0x30
	ctx.r[8].s64 = 48;
	// 8242D720: 39296910  addi r9, r9, 0x6910
	ctx.r[9].s64 = ctx.r[9].s64 + 26896;
	// 8242D724: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8242D728: 38E00040  li r7, 0x40
	ctx.r[7].s64 = 64;
	// 8242D72C: 13E0F0C7  vcmpequd (lvx128) v31, v0, v30
	tmp.u32 = ctx.r[30].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242D760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8242D760 size=348
    let mut pc: u32 = 0x8242D760;
    'dispatch: loop {
        match pc {
            0x8242D760 => {
    //   block [0x8242D760..0x8242D8BC)
	// 8242D760: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8242D764: 48D7AA01  bl 0x831a8164
	ctx.lr = 0x8242D768;
	sub_831A8130(ctx, base);
	// 8242D768: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242D8C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8242D8C0 size=40
    let mut pc: u32 = 0x8242D8C0;
    'dispatch: loop {
        match pc {
            0x8242D8C0 => {
    //   block [0x8242D8C0..0x8242D8E8)
	// 8242D8C0: 3D208338  lis r9, -0x7cc8
	ctx.r[9].s64 = -2093481984;
	// 8242D8C4: 394300B0  addi r10, r3, 0xb0
	ctx.r[10].s64 = ctx.r[3].s64 + 176;
	// 8242D8C8: 39600008  li r11, 8
	ctx.r[11].s64 = 8;
	// 8242D8CC: 39296910  addi r9, r9, 0x6910
	ctx.r[9].s64 = ctx.r[9].s64 + 26896;
	// 8242D8D0: 13E048C7  vcmpequd (lvx128) v31, v0, v9
	tmp.u32 = ctx.r[9].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8242D8D4: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242D8E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8242D8E8 size=92
    let mut pc: u32 = 0x8242D8E8;
    'dispatch: loop {
        match pc {
            0x8242D8E8 => {
    //   block [0x8242D8E8..0x8242D944)
	// 8242D8E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8242D8EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8242D8F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8242D8F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8242D8F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8242D8FC: 83E40000  lwz r31, 0(r4)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242D900: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8242D904: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8242D908: 419A000C  beq cr6, 0x8242d914
	if ctx.cr[6].eq {
	pc = 0x8242D914; continue 'dispatch;
	}
	// 8242D90C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8242D910: 48166279  bl 0x82593b88
	ctx.lr = 0x8242D914;
	sub_82593B88(ctx, base);
	// 8242D914: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242D918: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8242D91C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8242D920: 419A0008  beq cr6, 0x8242d928
	if ctx.cr[6].eq {
	pc = 0x8242D928; continue 'dispatch;
	}
	// 8242D924: 4816626D  bl 0x82593b90
	ctx.lr = 0x8242D928;
	sub_82593B90(ctx, base);
	// 8242D928: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8242D92C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8242D930: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8242D934: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8242D938: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8242D93C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8242D940: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242D948(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8242D948 size=64
    let mut pc: u32 = 0x8242D948;
    'dispatch: loop {
        match pc {
            0x8242D948 => {
    //   block [0x8242D948..0x8242D988)
	// 8242D948: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 8242D94C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242D950: 91440008  stw r10, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8242D954: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242D958: 892A0041  lbz r9, 0x41(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(65 as u32) ) } as u64;
	// 8242D95C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8242D960: 409A0008  bne cr6, 0x8242d968
	if !ctx.cr[6].eq {
	pc = 0x8242D968; continue 'dispatch;
	}
	// 8242D964: 908A0004  stw r4, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 8242D968: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242D96C: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8242D970: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242D974: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242D978: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8242D97C: 409A000C  bne cr6, 0x8242d988
	if !ctx.cr[6].eq {
		sub_8242D988(ctx, base);
		return;
	}
	// 8242D980: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8242D984: 48000020  b 0x8242d9a4
	sub_8242D9A0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242D988(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8242D988 size=24
    let mut pc: u32 = 0x8242D988;
    'dispatch: loop {
        match pc {
            0x8242D988 => {
    //   block [0x8242D988..0x8242D9A0)
	// 8242D988: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242D98C: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242D990: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8242D994: 409A000C  bne cr6, 0x8242d9a0
	if !ctx.cr[6].eq {
		sub_8242D9A0(ctx, base);
		return;
	}
	// 8242D998: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8242D99C: 48000008  b 0x8242d9a4
	sub_8242D9A0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242D9A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8242D9A0 size=16
    let mut pc: u32 = 0x8242D9A0;
    'dispatch: loop {
        match pc {
            0x8242D9A0 => {
    //   block [0x8242D9A0..0x8242D9B0)
	// 8242D9A0: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8242D9A4: 908B0000  stw r4, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 8242D9A8: 91640004  stw r11, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8242D9AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242D9B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8242D9B0 size=84
    let mut pc: u32 = 0x8242D9B0;
    'dispatch: loop {
        match pc {
            0x8242D9B0 => {
    //   block [0x8242D9B0..0x8242DA04)
	// 8242D9B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8242D9B4: 48D7A7B9  bl 0x831a816c
	ctx.lr = 0x8242D9B8;
	sub_831A8130(ctx, base);
	// 8242D9B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8242D9BC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8242D9C0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8242D9C4: 897F0041  lbz r11, 0x41(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(65 as u32) ) } as u64;
	// 8242D9C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8242D9CC: 409A0030  bne cr6, 0x8242d9fc
	if !ctx.cr[6].eq {
	pc = 0x8242D9FC; continue 'dispatch;
	}
	// 8242D9D0: 3FA08335  lis r29, -0x7ccb
	ctx.r[29].s64 = -2093678592;
	// 8242D9D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8242D9D8: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8242D9DC: 4BFFFFD5  bl 0x8242d9b0
	ctx.lr = 0x8242D9E0;
	sub_8242D9B0(ctx, base);
	// 8242D9E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8242D9E4: 807D110C  lwz r3, 0x110c(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4364 as u32) ) } as u64;
	// 8242D9E8: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242D9EC: 489C479D  bl 0x82df2188
	ctx.lr = 0x8242D9F0;
	sub_82DF2188(ctx, base);
	// 8242D9F0: 897F0041  lbz r11, 0x41(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(65 as u32) ) } as u64;
	// 8242D9F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8242D9F8: 419AFFDC  beq cr6, 0x8242d9d4
	if ctx.cr[6].eq {
	pc = 0x8242D9D4; continue 'dispatch;
	}
	// 8242D9FC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8242DA00: 48D7A7BC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242DA08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8242DA08 size=196
    let mut pc: u32 = 0x8242DA08;
    'dispatch: loop {
        match pc {
            0x8242DA08 => {
    //   block [0x8242DA08..0x8242DACC)
	// 8242DA08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8242DA0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8242DA10: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8242DA14: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8242DA18: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8242DA1C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8242DA20: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8242DA24: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8242DA28: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8242DA2C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8242DA30: 4BE92F09  bl 0x822c0938
	ctx.lr = 0x8242DA34;
	sub_822C0938(ctx, base);
	// 8242DA34: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8242DA38: 41820028  beq 0x8242da60
	if ctx.cr[0].eq {
	pc = 0x8242DA60; continue 'dispatch;
	}
	// 8242DA3C: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8242DA40: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8242DA44: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8242DA48: 392B55FC  addi r9, r11, 0x55fc
	ctx.r[9].s64 = ctx.r[11].s64 + 22012;
	// 8242DA4C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8242DA50: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8242DA54: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8242DA58: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8242DA5C: 48000008  b 0x8242da64
	pc = 0x8242DA64; continue 'dispatch;
	// 8242DA60: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8242DA64: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8242DA68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8242DA6C: 409A0044  bne cr6, 0x8242dab0
	if !ctx.cr[6].eq {
	pc = 0x8242DAB0; continue 'dispatch;
	}
	// 8242DA70: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8242DA74: 419A001C  beq cr6, 0x8242da90
	if ctx.cr[6].eq {
	pc = 0x8242DA90; continue 'dispatch;
	}
	// 8242DA78: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242DA7C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8242DA80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8242DA84: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242DA88: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8242DA8C: 4E800421  bctrl
	ctx.lr = 0x8242DA90;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8242DA90: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 8242DA94: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8242DA98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8242DA9C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8242DAA0: 816B1AFC  lwz r11, 0x1afc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6908 as u32) ) } as u64;
	// 8242DAA4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8242DAA8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8242DAAC: 4BE92555  bl 0x822c0000
	ctx.lr = 0x8242DAB0;
	sub_822C0000(ctx, base);
	// 8242DAB0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8242DAB4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8242DAB8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8242DABC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8242DAC0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8242DAC4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8242DAC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242DAD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8242DAD0 size=196
    let mut pc: u32 = 0x8242DAD0;
    'dispatch: loop {
        match pc {
            0x8242DAD0 => {
    //   block [0x8242DAD0..0x8242DB94)
	// 8242DAD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8242DAD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8242DAD8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8242DADC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8242DAE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8242DAE4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8242DAE8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8242DAEC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8242DAF0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8242DAF4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8242DAF8: 4BE92E41  bl 0x822c0938
	ctx.lr = 0x8242DAFC;
	sub_822C0938(ctx, base);
	// 8242DAFC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8242DB00: 41820028  beq 0x8242db28
	if ctx.cr[0].eq {
	pc = 0x8242DB28; continue 'dispatch;
	}
	// 8242DB04: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8242DB08: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8242DB0C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8242DB10: 392B5610  addi r9, r11, 0x5610
	ctx.r[9].s64 = ctx.r[11].s64 + 22032;
	// 8242DB14: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8242DB18: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8242DB1C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8242DB20: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8242DB24: 48000008  b 0x8242db2c
	pc = 0x8242DB2C; continue 'dispatch;
	// 8242DB28: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8242DB2C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8242DB30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8242DB34: 409A0044  bne cr6, 0x8242db78
	if !ctx.cr[6].eq {
	pc = 0x8242DB78; continue 'dispatch;
	}
	// 8242DB38: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8242DB3C: 419A001C  beq cr6, 0x8242db58
	if ctx.cr[6].eq {
	pc = 0x8242DB58; continue 'dispatch;
	}
	// 8242DB40: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242DB44: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8242DB48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8242DB4C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242DB50: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8242DB54: 4E800421  bctrl
	ctx.lr = 0x8242DB58;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8242DB58: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 8242DB5C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8242DB60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8242DB64: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8242DB68: 816B1AFC  lwz r11, 0x1afc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6908 as u32) ) } as u64;
	// 8242DB6C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8242DB70: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8242DB74: 4BE9248D  bl 0x822c0000
	ctx.lr = 0x8242DB78;
	sub_822C0000(ctx, base);
	// 8242DB78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8242DB7C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8242DB80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8242DB84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8242DB88: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8242DB8C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8242DB90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242DB98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8242DB98 size=196
    let mut pc: u32 = 0x8242DB98;
    'dispatch: loop {
        match pc {
            0x8242DB98 => {
    //   block [0x8242DB98..0x8242DC5C)
	// 8242DB98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8242DB9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8242DBA0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8242DBA4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8242DBA8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8242DBAC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8242DBB0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8242DBB4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8242DBB8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8242DBBC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8242DBC0: 4BE92D79  bl 0x822c0938
	ctx.lr = 0x8242DBC4;
	sub_822C0938(ctx, base);
	// 8242DBC4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8242DBC8: 41820028  beq 0x8242dbf0
	if ctx.cr[0].eq {
	pc = 0x8242DBF0; continue 'dispatch;
	}
	// 8242DBCC: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8242DBD0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8242DBD4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8242DBD8: 392B5624  addi r9, r11, 0x5624
	ctx.r[9].s64 = ctx.r[11].s64 + 22052;
	// 8242DBDC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8242DBE0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8242DBE4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8242DBE8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8242DBEC: 48000008  b 0x8242dbf4
	pc = 0x8242DBF4; continue 'dispatch;
	// 8242DBF0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8242DBF4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8242DBF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8242DBFC: 409A0044  bne cr6, 0x8242dc40
	if !ctx.cr[6].eq {
	pc = 0x8242DC40; continue 'dispatch;
	}
	// 8242DC00: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8242DC04: 419A001C  beq cr6, 0x8242dc20
	if ctx.cr[6].eq {
	pc = 0x8242DC20; continue 'dispatch;
	}
	// 8242DC08: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242DC0C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8242DC10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8242DC14: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242DC18: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8242DC1C: 4E800421  bctrl
	ctx.lr = 0x8242DC20;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8242DC20: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 8242DC24: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8242DC28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8242DC2C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8242DC30: 816B1AFC  lwz r11, 0x1afc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6908 as u32) ) } as u64;
	// 8242DC34: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8242DC38: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8242DC3C: 4BE923C5  bl 0x822c0000
	ctx.lr = 0x8242DC40;
	sub_822C0000(ctx, base);
	// 8242DC40: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8242DC44: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8242DC48: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8242DC4C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8242DC50: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8242DC54: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8242DC58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242DC60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8242DC60 size=196
    let mut pc: u32 = 0x8242DC60;
    'dispatch: loop {
        match pc {
            0x8242DC60 => {
    //   block [0x8242DC60..0x8242DD24)
	// 8242DC60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8242DC64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8242DC68: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8242DC6C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8242DC70: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8242DC74: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8242DC78: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8242DC7C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8242DC80: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8242DC84: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8242DC88: 4BE92CB1  bl 0x822c0938
	ctx.lr = 0x8242DC8C;
	sub_822C0938(ctx, base);
	// 8242DC8C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8242DC90: 41820028  beq 0x8242dcb8
	if ctx.cr[0].eq {
	pc = 0x8242DCB8; continue 'dispatch;
	}
	// 8242DC94: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8242DC98: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8242DC9C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8242DCA0: 392B5638  addi r9, r11, 0x5638
	ctx.r[9].s64 = ctx.r[11].s64 + 22072;
	// 8242DCA4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8242DCA8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8242DCAC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8242DCB0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8242DCB4: 48000008  b 0x8242dcbc
	pc = 0x8242DCBC; continue 'dispatch;
	// 8242DCB8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8242DCBC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8242DCC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8242DCC4: 409A0044  bne cr6, 0x8242dd08
	if !ctx.cr[6].eq {
	pc = 0x8242DD08; continue 'dispatch;
	}
	// 8242DCC8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8242DCCC: 419A001C  beq cr6, 0x8242dce8
	if ctx.cr[6].eq {
	pc = 0x8242DCE8; continue 'dispatch;
	}
	// 8242DCD0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242DCD4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8242DCD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8242DCDC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242DCE0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8242DCE4: 4E800421  bctrl
	ctx.lr = 0x8242DCE8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8242DCE8: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 8242DCEC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8242DCF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8242DCF4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8242DCF8: 816B1AFC  lwz r11, 0x1afc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6908 as u32) ) } as u64;
	// 8242DCFC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8242DD00: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8242DD04: 4BE922FD  bl 0x822c0000
	ctx.lr = 0x8242DD08;
	sub_822C0000(ctx, base);
	// 8242DD08: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8242DD0C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8242DD10: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8242DD14: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8242DD18: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8242DD1C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8242DD20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242DD28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8242DD28 size=196
    let mut pc: u32 = 0x8242DD28;
    'dispatch: loop {
        match pc {
            0x8242DD28 => {
    //   block [0x8242DD28..0x8242DDEC)
	// 8242DD28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8242DD2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8242DD30: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8242DD34: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8242DD38: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8242DD3C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8242DD40: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8242DD44: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8242DD48: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8242DD4C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8242DD50: 4BE92BE9  bl 0x822c0938
	ctx.lr = 0x8242DD54;
	sub_822C0938(ctx, base);
	// 8242DD54: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8242DD58: 41820028  beq 0x8242dd80
	if ctx.cr[0].eq {
	pc = 0x8242DD80; continue 'dispatch;
	}
	// 8242DD5C: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8242DD60: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8242DD64: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8242DD68: 392B564C  addi r9, r11, 0x564c
	ctx.r[9].s64 = ctx.r[11].s64 + 22092;
	// 8242DD6C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8242DD70: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8242DD74: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8242DD78: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8242DD7C: 48000008  b 0x8242dd84
	pc = 0x8242DD84; continue 'dispatch;
	// 8242DD80: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8242DD84: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8242DD88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8242DD8C: 409A0044  bne cr6, 0x8242ddd0
	if !ctx.cr[6].eq {
	pc = 0x8242DDD0; continue 'dispatch;
	}
	// 8242DD90: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8242DD94: 419A001C  beq cr6, 0x8242ddb0
	if ctx.cr[6].eq {
	pc = 0x8242DDB0; continue 'dispatch;
	}
	// 8242DD98: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242DD9C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8242DDA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8242DDA4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242DDA8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8242DDAC: 4E800421  bctrl
	ctx.lr = 0x8242DDB0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8242DDB0: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 8242DDB4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8242DDB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8242DDBC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8242DDC0: 816B1AFC  lwz r11, 0x1afc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6908 as u32) ) } as u64;
	// 8242DDC4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8242DDC8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8242DDCC: 4BE92235  bl 0x822c0000
	ctx.lr = 0x8242DDD0;
	sub_822C0000(ctx, base);
	// 8242DDD0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8242DDD4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8242DDD8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8242DDDC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8242DDE0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8242DDE4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8242DDE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242DDF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8242DDF0 size=196
    let mut pc: u32 = 0x8242DDF0;
    'dispatch: loop {
        match pc {
            0x8242DDF0 => {
    //   block [0x8242DDF0..0x8242DEB4)
	// 8242DDF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8242DDF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8242DDF8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8242DDFC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8242DE00: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8242DE04: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8242DE08: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8242DE0C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8242DE10: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8242DE14: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8242DE18: 4BE92B21  bl 0x822c0938
	ctx.lr = 0x8242DE1C;
	sub_822C0938(ctx, base);
	// 8242DE1C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8242DE20: 41820028  beq 0x8242de48
	if ctx.cr[0].eq {
	pc = 0x8242DE48; continue 'dispatch;
	}
	// 8242DE24: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8242DE28: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8242DE2C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8242DE30: 392B5660  addi r9, r11, 0x5660
	ctx.r[9].s64 = ctx.r[11].s64 + 22112;
	// 8242DE34: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8242DE38: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8242DE3C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8242DE40: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8242DE44: 48000008  b 0x8242de4c
	pc = 0x8242DE4C; continue 'dispatch;
	// 8242DE48: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8242DE4C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8242DE50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8242DE54: 409A0044  bne cr6, 0x8242de98
	if !ctx.cr[6].eq {
	pc = 0x8242DE98; continue 'dispatch;
	}
	// 8242DE58: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8242DE5C: 419A001C  beq cr6, 0x8242de78
	if ctx.cr[6].eq {
	pc = 0x8242DE78; continue 'dispatch;
	}
	// 8242DE60: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242DE64: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8242DE68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8242DE6C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242DE70: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8242DE74: 4E800421  bctrl
	ctx.lr = 0x8242DE78;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8242DE78: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 8242DE7C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8242DE80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8242DE84: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8242DE88: 816B1AFC  lwz r11, 0x1afc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6908 as u32) ) } as u64;
	// 8242DE8C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8242DE90: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8242DE94: 4BE9216D  bl 0x822c0000
	ctx.lr = 0x8242DE98;
	sub_822C0000(ctx, base);
	// 8242DE98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8242DE9C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8242DEA0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8242DEA4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8242DEA8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8242DEAC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8242DEB0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242DEB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8242DEB8 size=356
    let mut pc: u32 = 0x8242DEB8;
    'dispatch: loop {
        match pc {
            0x8242DEB8 => {
    //   block [0x8242DEB8..0x8242E01C)
	// 8242DEB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8242DEBC: 48D7A2AD  bl 0x831a8168
	ctx.lr = 0x8242DEC0;
	sub_831A8130(ctx, base);
	// 8242DEC0: DBC1FFC8  stfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 8242DEC4: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 8242DEC8: 3980FF90  li r12, -0x70
	ctx.r[12].s64 = -112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242E020(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8242E020 size=84
    let mut pc: u32 = 0x8242E020;
    'dispatch: loop {
        match pc {
            0x8242E020 => {
    //   block [0x8242E020..0x8242E074)
	// 8242E020: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8242E024: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8242E028: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8242E02C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8242E030: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8242E034: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242E038: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242E03C: 4BFFF975  bl 0x8242d9b0
	ctx.lr = 0x8242E040;
	sub_8242D9B0(ctx, base);
	// 8242E040: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242E044: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8242E048: 914A0004  stw r10, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8242E04C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8242E050: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242E054: 914A0000  stw r10, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8242E058: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242E05C: 916B0008  stw r11, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8242E060: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8242E064: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8242E068: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8242E06C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8242E070: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242E078(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8242E078 size=108
    let mut pc: u32 = 0x8242E078;
    'dispatch: loop {
        match pc {
            0x8242E078 => {
    //   block [0x8242E078..0x8242E0E4)
	// 8242E078: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8242E07C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8242E080: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8242E084: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 8242E088: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8242E08C: 38C00050  li r6, 0x50
	ctx.r[6].s64 = 80;
	// 8242E090: 388A08B0  addi r4, r10, 0x8b0
	ctx.r[4].s64 = ctx.r[10].s64 + 2224;
	// 8242E094: 38A0002D  li r5, 0x2d
	ctx.r[5].s64 = 45;
	// 8242E098: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 8242E09C: 489C402D  bl 0x82df20c8
	ctx.lr = 0x8242E0A0;
	sub_82DF20C8(ctx, base);
	// 8242E0A0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8242E0A4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8242E0A8: 41820008  beq 0x8242e0b0
	if ctx.cr[0].eq {
	pc = 0x8242E0B0; continue 'dispatch;
	}
	// 8242E0AC: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8242E0B0: 35630004  addic. r11, r3, 4
	ctx.xer.ca = (ctx.r[3].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8242E0B4: 41820008  beq 0x8242e0bc
	if ctx.cr[0].eq {
	pc = 0x8242E0BC; continue 'dispatch;
	}
	// 8242E0B8: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8242E0BC: 35630008  addic. r11, r3, 8
	ctx.xer.ca = (ctx.r[3].u32 > (!(8 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 8;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8242E0C0: 41820008  beq 0x8242e0c8
	if ctx.cr[0].eq {
	pc = 0x8242E0C8; continue 'dispatch;
	}
	// 8242E0C4: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8242E0C8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8242E0CC: 99430041  stb r10, 0x41(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(65 as u32), ctx.r[10].u8 ) };
	// 8242E0D0: 99630040  stb r11, 0x40(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[11].u8 ) };
	// 8242E0D4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8242E0D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8242E0DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8242E0E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242E0E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8242E0E8 size=96
    let mut pc: u32 = 0x8242E0E8;
    'dispatch: loop {
        match pc {
            0x8242E0E8 => {
    //   block [0x8242E0E8..0x8242E148)
	// 8242E0E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8242E0EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8242E0F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8242E0F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8242E0F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8242E0FC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8242E100: 90610084  stw r3, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 8242E104: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 8242E108: 7F03F840  cmplw cr6, r3, r31
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[31].u32, &mut ctx.xer);
	// 8242E10C: 419A0024  beq cr6, 0x8242e130
	if ctx.cr[6].eq {
	pc = 0x8242E130; continue 'dispatch;
	}
	// 8242E110: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242E114: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 8242E118: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8242E11C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8242E120: 4BFFF409  bl 0x8242d528
	ctx.lr = 0x8242E124;
	sub_8242D528(ctx, base);
	// 8242E124: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 8242E128: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 8242E12C: 409AFFE4  bne cr6, 0x8242e110
	if !ctx.cr[6].eq {
	pc = 0x8242E110; continue 'dispatch;
	}
	// 8242E130: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8242E134: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8242E138: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8242E13C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8242E140: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8242E144: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242E148(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8242E148 size=44
    let mut pc: u32 = 0x8242E148;
    'dispatch: loop {
        match pc {
            0x8242E148 => {
    //   block [0x8242E148..0x8242E174)
	// 8242E148: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242E14C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242E150: 892B0041  lbz r9, 0x41(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(65 as u32) ) } as u64;
	// 8242E154: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8242E158: 409A0030  bne cr6, 0x8242e188
	if !ctx.cr[6].eq {
		sub_8242E174(ctx, base);
		return;
	}
	// 8242E15C: 81250000  lwz r9, 0(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242E160: 810B0010  lwz r8, 0x10(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8242E164: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8242E168: 4098000C  bge cr6, 0x8242e174
	if !ctx.cr[6].lt {
		sub_8242E174(ctx, base);
		return;
	}
	// 8242E16C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8242E170: 4800000C  b 0x8242e17c
	sub_8242E174(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242E174(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8242E174 size=60
    let mut pc: u32 = 0x8242E174;
    'dispatch: loop {
        match pc {
            0x8242E174 => {
    //   block [0x8242E174..0x8242E1B0)
	// 8242E174: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 8242E178: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242E17C: 890B0041  lbz r8, 0x41(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(65 as u32) ) } as u64;
	// 8242E180: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 8242E184: 419AFFDC  beq cr6, 0x8242e160
	if ctx.cr[6].eq {
		sub_8242E148(ctx, base);
		return;
	}
	// 8242E188: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242E18C: 9141FFF0  stw r10, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[10].u32 ) };
	// 8242E190: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8242E194: 419A001C  beq cr6, 0x8242e1b0
	if ctx.cr[6].eq {
		sub_8242E1B0(ctx, base);
		return;
	}
	// 8242E198: 81250000  lwz r9, 0(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242E19C: 814A0010  lwz r10, 0x10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 8242E1A0: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8242E1A4: 4198000C  blt cr6, 0x8242e1b0
	if ctx.cr[6].lt {
		sub_8242E1B0(ctx, base);
		return;
	}
	// 8242E1A8: 3961FFF0  addi r11, r1, -0x10
	ctx.r[11].s64 = ctx.r[1].s64 + -16;
	// 8242E1AC: 4800000C  b 0x8242e1b8
	sub_8242E1B0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242E1B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8242E1B0 size=20
    let mut pc: u32 = 0x8242E1B0;
    'dispatch: loop {
        match pc {
            0x8242E1B0 => {
    //   block [0x8242E1B0..0x8242E1C4)
	// 8242E1B0: 9161FFF4  stw r11, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[11].u32 ) };
	// 8242E1B4: 3961FFF4  addi r11, r1, -0xc
	ctx.r[11].s64 = ctx.r[1].s64 + -12;
	// 8242E1B8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242E1BC: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8242E1C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242E1C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8242E1C8 size=48
    let mut pc: u32 = 0x8242E1C8;
    'dispatch: loop {
        match pc {
            0x8242E1C8 => {
    //   block [0x8242E1C8..0x8242E1F8)
	// 8242E1C8: 81040004  lwz r8, 4(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242E1CC: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242E1D0: 894B0041  lbz r10, 0x41(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(65 as u32) ) } as u64;
	// 8242E1D4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8242E1D8: 409A0030  bne cr6, 0x8242e208
	if !ctx.cr[6].eq {
		sub_8242E1F8(ctx, base);
		return;
	}
	// 8242E1DC: 81450000  lwz r10, 0(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242E1E0: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8242E1E4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8242E1E8: 40980010  bge cr6, 0x8242e1f8
	if !ctx.cr[6].lt {
		sub_8242E1F8(ctx, base);
		return;
	}
	// 8242E1EC: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 8242E1F0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242E1F4: 48000008  b 0x8242e1fc
	sub_8242E1F8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242E1F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8242E1F8 size=60
    let mut pc: u32 = 0x8242E1F8;
    'dispatch: loop {
        match pc {
            0x8242E1F8 => {
    //   block [0x8242E1F8..0x8242E234)
	// 8242E1F8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8242E1FC: 892B0041  lbz r9, 0x41(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(65 as u32) ) } as u64;
	// 8242E200: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8242E204: 419AFFDC  beq cr6, 0x8242e1e0
	if ctx.cr[6].eq {
		sub_8242E1C8(ctx, base);
		return;
	}
	// 8242E208: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242E20C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242E210: 892B0041  lbz r9, 0x41(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(65 as u32) ) } as u64;
	// 8242E214: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8242E218: 409A0030  bne cr6, 0x8242e248
	if !ctx.cr[6].eq {
		sub_8242E234(ctx, base);
		return;
	}
	// 8242E21C: 81250000  lwz r9, 0(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242E220: 80EB0010  lwz r7, 0x10(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8242E224: 7F074840  cmplw cr6, r7, r9
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8242E228: 4098000C  bge cr6, 0x8242e234
	if !ctx.cr[6].lt {
		sub_8242E234(ctx, base);
		return;
	}
	// 8242E22C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8242E230: 4800000C  b 0x8242e23c
	sub_8242E234(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242E234(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8242E234 size=32
    let mut pc: u32 = 0x8242E234;
    'dispatch: loop {
        match pc {
            0x8242E234 => {
    //   block [0x8242E234..0x8242E254)
	// 8242E234: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 8242E238: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242E23C: 88EB0041  lbz r7, 0x41(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(65 as u32) ) } as u64;
	// 8242E240: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8242E244: 419AFFDC  beq cr6, 0x8242e220
	if ctx.cr[6].eq {
		sub_8242E1F8(ctx, base);
		return;
	}
	// 8242E248: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8242E24C: 91030004  stw r8, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 8242E250: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242E258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8242E258 size=132
    let mut pc: u32 = 0x8242E258;
    'dispatch: loop {
        match pc {
            0x8242E258 => {
    //   block [0x8242E258..0x8242E2DC)
	// 8242E258: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8242E25C: 48D79F09  bl 0x831a8164
	ctx.lr = 0x8242E260;
	sub_831A8130(ctx, base);
	// 8242E260: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8242E264: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 8242E268: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8242E26C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8242E270: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 8242E274: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 8242E278: 38C00050  li r6, 0x50
	ctx.r[6].s64 = 80;
	// 8242E27C: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 8242E280: 388A08B0  addi r4, r10, 0x8b0
	ctx.r[4].s64 = ctx.r[10].s64 + 2224;
	// 8242E284: 38A0002D  li r5, 0x2d
	ctx.r[5].s64 = 45;
	// 8242E288: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 8242E28C: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 8242E290: 489C3E39  bl 0x82df20c8
	ctx.lr = 0x8242E294;
	sub_82DF20C8(ctx, base);
	// 8242E294: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8242E298: 4182003C  beq 0x8242e2d4
	if ctx.cr[0].eq {
	pc = 0x8242E2D4; continue 'dispatch;
	}
	// 8242E29C: 93C30000  stw r30, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 8242E2A0: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 8242E2A4: 93A30004  stw r29, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 8242E2A8: 39630010  addi r11, r3, 0x10
	ctx.r[11].s64 = ctx.r[3].s64 + 16;
	// 8242E2AC: 93830008  stw r28, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 8242E2B0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8242E2B4: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242E2B8: 91030010  stw r8, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[8].u32 ) };
	// 8242E2BC: 13FF50C7  vcmpequd (lvx128) v31, v31, v10
	tmp.u32 = ctx.r[31].u32 + ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242E2E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8242E2E0 size=88
    let mut pc: u32 = 0x8242E2E0;
    'dispatch: loop {
        match pc {
            0x8242E2E0 => {
    //   block [0x8242E2E0..0x8242E338)
	// 8242E2E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8242E2E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8242E2E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8242E2EC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8242E2F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8242E2F4: 4BFFFD85  bl 0x8242e078
	ctx.lr = 0x8242E2F8;
	sub_8242E078(ctx, base);
	// 8242E2F8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8242E2FC: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 8242E300: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8242E304: 99630041  stb r11, 0x41(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(65 as u32), ctx.r[11].u8 ) };
	// 8242E308: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242E30C: 916B0004  stw r11, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8242E310: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242E314: 916B0000  stw r11, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8242E318: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242E31C: 916B0008  stw r11, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8242E320: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8242E324: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8242E328: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8242E32C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8242E330: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8242E334: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242E338(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8242E338 size=112
    let mut pc: u32 = 0x8242E338;
    'dispatch: loop {
        match pc {
            0x8242E338 => {
    //   block [0x8242E338..0x8242E3A8)
	// 8242E338: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8242E33C: 48D79E31  bl 0x831a816c
	ctx.lr = 0x8242E340;
	sub_831A8130(ctx, base);
	// 8242E340: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8242E344: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8242E348: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8242E34C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8242E350: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 8242E354: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 8242E358: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 8242E35C: 489C408D  bl 0x82df23e8
	ctx.lr = 0x8242E360;
	sub_82DF23E8(ctx, base);
	// 8242E360: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8242E364: 41820010  beq 0x8242e374
	if ctx.cr[0].eq {
	pc = 0x8242E374; continue 'dispatch;
	}
	// 8242E368: 4BFFF2C9  bl 0x8242d630
	ctx.lr = 0x8242E36C;
	sub_8242D630(ctx, base);
	// 8242E36C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8242E370: 48000008  b 0x8242e378
	pc = 0x8242E378; continue 'dispatch;
	// 8242E374: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8242E378: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8242E37C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8242E380: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8242E384: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8242E388: 4BFFF681  bl 0x8242da08
	ctx.lr = 0x8242E38C;
	sub_8242DA08(ctx, base);
	// 8242E38C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8242E390: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8242E394: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8242E398: 4BE91C69  bl 0x822c0000
	ctx.lr = 0x8242E39C;
	sub_822C0000(ctx, base);
	// 8242E39C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8242E3A0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8242E3A4: 48D79E18  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242E3A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8242E3A8 size=128
    let mut pc: u32 = 0x8242E3A8;
    'dispatch: loop {
        match pc {
            0x8242E3A8 => {
    //   block [0x8242E3A8..0x8242E428)
	// 8242E3A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8242E3AC: 48D79DC1  bl 0x831a816c
	ctx.lr = 0x8242E3B0;
	sub_831A8130(ctx, base);
	// 8242E3B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8242E3B4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8242E3B8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8242E3BC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8242E3C0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 8242E3C4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8242E3C8: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 8242E3CC: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 8242E3D0: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 8242E3D4: 489C4015  bl 0x82df23e8
	ctx.lr = 0x8242E3D8;
	sub_82DF23E8(ctx, base);
	// 8242E3D8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8242E3DC: 41820018  beq 0x8242e3f4
	if ctx.cr[0].eq {
	pc = 0x8242E3F4; continue 'dispatch;
	}
	// 8242E3E0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8242E3E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8242E3E8: 4BFFF309  bl 0x8242d6f0
	ctx.lr = 0x8242E3EC;
	sub_8242D6F0(ctx, base);
	// 8242E3EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8242E3F0: 48000008  b 0x8242e3f8
	pc = 0x8242E3F8; continue 'dispatch;
	// 8242E3F4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8242E3F8: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8242E3FC: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8242E400: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8242E404: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8242E408: 4BFFF6C9  bl 0x8242dad0
	ctx.lr = 0x8242E40C;
	sub_8242DAD0(ctx, base);
	// 8242E40C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8242E410: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8242E414: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8242E418: 4BE91BE9  bl 0x822c0000
	ctx.lr = 0x8242E41C;
	sub_822C0000(ctx, base);
	// 8242E41C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8242E420: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8242E424: 48D79D98  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242E428(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8242E428 size=128
    let mut pc: u32 = 0x8242E428;
    'dispatch: loop {
        match pc {
            0x8242E428 => {
    //   block [0x8242E428..0x8242E4A8)
	// 8242E428: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8242E42C: 48D79D41  bl 0x831a816c
	ctx.lr = 0x8242E430;
	sub_831A8130(ctx, base);
	// 8242E430: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8242E434: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8242E438: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8242E43C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8242E440: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 8242E444: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8242E448: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 8242E44C: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 8242E450: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 8242E454: 489C3F95  bl 0x82df23e8
	ctx.lr = 0x8242E458;
	sub_82DF23E8(ctx, base);
	// 8242E458: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8242E45C: 41820018  beq 0x8242e474
	if ctx.cr[0].eq {
	pc = 0x8242E474; continue 'dispatch;
	}
	// 8242E460: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8242E464: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8242E468: 4BFFF219  bl 0x8242d680
	ctx.lr = 0x8242E46C;
	sub_8242D680(ctx, base);
	// 8242E46C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8242E470: 48000008  b 0x8242e478
	pc = 0x8242E478; continue 'dispatch;
	// 8242E474: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8242E478: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8242E47C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8242E480: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8242E484: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8242E488: 4BFFF711  bl 0x8242db98
	ctx.lr = 0x8242E48C;
	sub_8242DB98(ctx, base);
	// 8242E48C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8242E490: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8242E494: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8242E498: 4BE91B69  bl 0x822c0000
	ctx.lr = 0x8242E49C;
	sub_822C0000(ctx, base);
	// 8242E49C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8242E4A0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8242E4A4: 48D79D18  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242E4A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8242E4A8 size=124
    let mut pc: u32 = 0x8242E4A8;
    'dispatch: loop {
        match pc {
            0x8242E4A8 => {
    //   block [0x8242E4A8..0x8242E524)
	// 8242E4A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8242E4AC: 48D79CC1  bl 0x831a816c
	ctx.lr = 0x8242E4B0;
	sub_831A8130(ctx, base);
	// 8242E4B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8242E4B4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8242E4B8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8242E4BC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8242E4C0: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 8242E4C4: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 8242E4C8: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 8242E4CC: 489C3F1D  bl 0x82df23e8
	ctx.lr = 0x8242E4D0;
	sub_82DF23E8(ctx, base);
	// 8242E4D0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8242E4D4: 4182001C  beq 0x8242e4f0
	if ctx.cr[0].eq {
	pc = 0x8242E4F0; continue 'dispatch;
	}
	// 8242E4D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8242E4DC: 48A2B1A5  bl 0x82e59680
	ctx.lr = 0x8242E4E0;
	sub_82E59680(ctx, base);
	// 8242E4E0: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8242E4E4: 396B55F4  addi r11, r11, 0x55f4
	ctx.r[11].s64 = ctx.r[11].s64 + 22004;
	// 8242E4E8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8242E4EC: 48000008  b 0x8242e4f4
	pc = 0x8242E4F4; continue 'dispatch;
	// 8242E4F0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8242E4F4: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8242E4F8: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8242E4FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8242E500: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8242E504: 4BFFF75D  bl 0x8242dc60
	ctx.lr = 0x8242E508;
	sub_8242DC60(ctx, base);
	// 8242E508: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8242E50C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8242E510: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8242E514: 4BE91AED  bl 0x822c0000
	ctx.lr = 0x8242E518;
	sub_822C0000(ctx, base);
	// 8242E518: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8242E51C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8242E520: 48D79C9C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242E528(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8242E528 size=136
    let mut pc: u32 = 0x8242E528;
    'dispatch: loop {
        match pc {
            0x8242E528 => {
    //   block [0x8242E528..0x8242E5B0)
	// 8242E528: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8242E52C: 48D79C41  bl 0x831a816c
	ctx.lr = 0x8242E530;
	sub_831A8130(ctx, base);
	// 8242E530: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8242E534: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8242E538: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8242E53C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8242E540: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 8242E544: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 8242E548: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 8242E54C: 489C3E9D  bl 0x82df23e8
	ctx.lr = 0x8242E550;
	sub_82DF23E8(ctx, base);
	// 8242E550: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8242E554: 41820028  beq 0x8242e57c
	if ctx.cr[0].eq {
	pc = 0x8242E57C; continue 'dispatch;
	}
	// 8242E558: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8242E55C: 48A2B145  bl 0x82e596a0
	ctx.lr = 0x8242E560;
	sub_82E596A0(ctx, base);
	// 8242E560: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8242E564: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 8242E568: 394A55EC  addi r10, r10, 0x55ec
	ctx.r[10].s64 = ctx.r[10].s64 + 21996;
	// 8242E56C: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8242E570: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8242E574: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 8242E578: 48000008  b 0x8242e580
	pc = 0x8242E580; continue 'dispatch;
	// 8242E57C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8242E580: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8242E584: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8242E588: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8242E58C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8242E590: 4BFFF799  bl 0x8242dd28
	ctx.lr = 0x8242E594;
	sub_8242DD28(ctx, base);
	// 8242E594: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8242E598: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8242E59C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8242E5A0: 4BE91A61  bl 0x822c0000
	ctx.lr = 0x8242E5A4;
	sub_822C0000(ctx, base);
	// 8242E5A4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8242E5A8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8242E5AC: 48D79C10  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242E5B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8242E5B0 size=120
    let mut pc: u32 = 0x8242E5B0;
    'dispatch: loop {
        match pc {
            0x8242E5B0 => {
    //   block [0x8242E5B0..0x8242E628)
	// 8242E5B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8242E5B4: 48D79BB9  bl 0x831a816c
	ctx.lr = 0x8242E5B8;
	sub_831A8130(ctx, base);
	// 8242E5B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8242E5BC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8242E5C0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8242E5C4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8242E5C8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8242E5CC: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 8242E5D0: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 8242E5D4: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 8242E5D8: 489C3E11  bl 0x82df23e8
	ctx.lr = 0x8242E5DC;
	sub_82DF23E8(ctx, base);
	// 8242E5DC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8242E5E0: 41820014  beq 0x8242e5f4
	if ctx.cr[0].eq {
	pc = 0x8242E5F4; continue 'dispatch;
	}
	// 8242E5E4: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242E5E8: 48725DE1  bl 0x82b543c8
	ctx.lr = 0x8242E5EC;
	sub_82B543C8(ctx, base);
	// 8242E5EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8242E5F0: 48000008  b 0x8242e5f8
	pc = 0x8242E5F8; continue 'dispatch;
	// 8242E5F4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8242E5F8: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8242E5FC: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8242E600: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8242E604: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8242E608: 4BFFF7E9  bl 0x8242ddf0
	ctx.lr = 0x8242E60C;
	sub_8242DDF0(ctx, base);
	// 8242E60C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8242E610: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8242E614: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8242E618: 4BE919E9  bl 0x822c0000
	ctx.lr = 0x8242E61C;
	sub_822C0000(ctx, base);
	// 8242E61C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8242E620: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8242E624: 48D79B98  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242E628(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8242E628 size=168
    let mut pc: u32 = 0x8242E628;
    'dispatch: loop {
        match pc {
            0x8242E628 => {
    //   block [0x8242E628..0x8242E6D0)
	// 8242E628: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8242E62C: 48D79B2D  bl 0x831a8158
	ctx.lr = 0x8242E630;
	sub_831A8130(ctx, base);
	// 8242E630: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8242E634: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8242E638: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 8242E63C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8242E640: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 8242E644: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 8242E648: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8242E64C: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 8242E650: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 8242E654: 38600070  li r3, 0x70
	ctx.r[3].s64 = 112;
	// 8242E658: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 8242E65C: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 8242E660: 7D3A4B78  mr r26, r9
	ctx.r[26].u64 = ctx.r[9].u64;
	// 8242E664: 7D595378  mr r25, r10
	ctx.r[25].u64 = ctx.r[10].u64;
	// 8242E668: 489C3D81  bl 0x82df23e8
	ctx.lr = 0x8242E66C;
	sub_82DF23E8(ctx, base);
	// 8242E66C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8242E670: 4182002C  beq 0x8242e69c
	if ctx.cr[0].eq {
	pc = 0x8242E69C; continue 'dispatch;
	}
	// 8242E674: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	// 8242E678: 81590000  lwz r10, 0(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242E67C: 7F68DB78  mr r8, r27
	ctx.r[8].u64 = ctx.r[27].u64;
	// 8242E680: 80DD0000  lwz r6, 0(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242E684: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 8242E688: 80BE0000  lwz r5, 0(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242E68C: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242E690: 48723E19  bl 0x82b524a8
	ctx.lr = 0x8242E694;
	sub_82B524A8(ctx, base);
	// 8242E694: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8242E698: 48000008  b 0x8242e6a0
	pc = 0x8242E6A0; continue 'dispatch;
	// 8242E69C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8242E6A0: 93F80000  stw r31, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8242E6A4: 3BD80004  addi r30, r24, 4
	ctx.r[30].s64 = ctx.r[24].s64 + 4;
	// 8242E6A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8242E6AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8242E6B0: 4BF2ADF1  bl 0x823594a0
	ctx.lr = 0x8242E6B4;
	sub_823594A0(ctx, base);
	// 8242E6B4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8242E6B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8242E6BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8242E6C0: 4BE91941  bl 0x822c0000
	ctx.lr = 0x8242E6C4;
	sub_822C0000(ctx, base);
	// 8242E6C4: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 8242E6C8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8242E6CC: 48D79ADC  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242E6D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8242E6D0 size=712
    let mut pc: u32 = 0x8242E6D0;
    'dispatch: loop {
        match pc {
            0x8242E6D0 => {
    //   block [0x8242E6D0..0x8242E998)
	// 8242E6D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8242E6D4: 48D79A91  bl 0x831a8164
	ctx.lr = 0x8242E6D8;
	sub_831A8130(ctx, base);
	// 8242E6D8: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8242E6DC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8242E6E0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8242E6E4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 8242E6E8: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 8242E6EC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242E6F0: 4BED6CF9  bl 0x823053e8
	ctx.lr = 0x8242E6F4;
	sub_823053E8(ctx, base);
	// 8242E6F4: 486B519D  bl 0x82ae3890
	ctx.lr = 0x8242E6F8;
	sub_82AE3890(ctx, base);
	// 8242E6F8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8242E6FC: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 8242E700: 409A0014  bne cr6, 0x8242e714
	if !ctx.cr[6].eq {
	pc = 0x8242E714; continue 'dispatch;
	}
	// 8242E704: 397C0008  addi r11, r28, 8
	ctx.r[11].s64 = ctx.r[28].s64 + 8;
	// 8242E708: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8242E70C: 7C8BFA2E  lhzx r4, r11, r31
	ctx.r[4].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 8242E710: 48000020  b 0x8242e730
	pc = 0x8242E730; continue 'dispatch;
	// 8242E714: 2F1D0001  cmpwi cr6, r29, 1
	ctx.cr[6].compare_i32(ctx.r[29].s32, 1, &mut ctx.xer);
	// 8242E718: 409A000C  bne cr6, 0x8242e724
	if !ctx.cr[6].eq {
	pc = 0x8242E724; continue 'dispatch;
	}
	// 8242E71C: 397C000C  addi r11, r28, 0xc
	ctx.r[11].s64 = ctx.r[28].s64 + 12;
	// 8242E720: 4BFFFFE8  b 0x8242e708
	pc = 0x8242E708; continue 'dispatch;
	// 8242E724: 2F1D0002  cmpwi cr6, r29, 2
	ctx.cr[6].compare_i32(ctx.r[29].s32, 2, &mut ctx.xer);
	// 8242E728: 409A00A8  bne cr6, 0x8242e7d0
	if !ctx.cr[6].eq {
	pc = 0x8242E7D0; continue 'dispatch;
	}
	// 8242E72C: A09F0020  lhz r4, 0x20(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8242E730: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8242E734: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8242E738: 48B80F51  bl 0x82faf688
	ctx.lr = 0x8242E73C;
	sub_82FAF688(ctx, base);
	// 8242E73C: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 8242E740: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 8242E744: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8242E748: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 8242E74C: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 8242E750: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242E998(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8242E998 size=220
    let mut pc: u32 = 0x8242E998;
    'dispatch: loop {
        match pc {
            0x8242E998 => {
    //   block [0x8242E998..0x8242EA74)
	// 8242E998: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8242E99C: 48D797D1  bl 0x831a816c
	ctx.lr = 0x8242E9A0;
	sub_831A8130(ctx, base);
	// 8242E9A0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8242E9A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8242E9A8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8242E9AC: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242E9B0: 4BED9311  bl 0x82307cc0
	ctx.lr = 0x8242E9B4;
	sub_82307CC0(ctx, base);
	// 8242E9B4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8242E9B8: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242E9BC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8242E9C0: 4BED70B1  bl 0x82305a70
	ctx.lr = 0x8242E9C4;
	sub_82305A70(ctx, base);
	// 8242E9C4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8242E9C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8242E9CC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8242E9D0: 4BFFF9D9  bl 0x8242e3a8
	ctx.lr = 0x8242E9D4;
	sub_8242E3A8(ctx, base);
	// 8242E9D4: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8242E9D8: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8242E9DC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8242E9E0: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 8242E9E4: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 8242E9E8: 419A0024  beq cr6, 0x8242ea0c
	if ctx.cr[6].eq {
	pc = 0x8242EA0C; continue 'dispatch;
	}
	// 8242E9EC: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 8242E9F0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8242E9F4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8242E9F8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8242E9FC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8242EA00: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8242EA04: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8242EA08: 4082FFE8  bne 0x8242e9f0
	if !ctx.cr[0].eq {
	pc = 0x8242E9F0; continue 'dispatch;
	}
	// 8242EA0C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242EA10: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8242EA14: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 8242EA18: 388B5688  addi r4, r11, 0x5688
	ctx.r[4].s64 = ctx.r[11].s64 + 22152;
	// 8242EA1C: 38A00131  li r5, 0x131
	ctx.r[5].s64 = 305;
	// 8242EA20: 80C30828  lwz r6, 0x828(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(2088 as u32) ) } as u64;
	// 8242EA24: 4BED9415  bl 0x82307e38
	ctx.lr = 0x8242EA28;
	sub_82307E38(ctx, base);
	// 8242EA28: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8242EA2C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8242EA30: 4182002C  beq 0x8242ea5c
	if ctx.cr[0].eq {
	pc = 0x8242EA5C; continue 'dispatch;
	}
	// 8242EA34: 817D0050  lwz r11, 0x50(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(80 as u32) ) } as u64;
	// 8242EA38: 917F0130  stw r11, 0x130(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), ctx.r[11].u32 ) };
	// 8242EA3C: 897D0055  lbz r11, 0x55(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(85 as u32) ) } as u64;
	// 8242EA40: 997F0134  stb r11, 0x134(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(308 as u32), ctx.r[11].u8 ) };
	// 8242EA44: 8BFD0054  lbz r31, 0x54(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(84 as u32) ) } as u64;
	// 8242EA48: 419A000C  beq cr6, 0x8242ea54
	if ctx.cr[6].eq {
	pc = 0x8242EA54; continue 'dispatch;
	}
	// 8242EA4C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8242EA50: 4BE91E41  bl 0x822c0890
	ctx.lr = 0x8242EA54;
	sub_822C0890(ctx, base);
	// 8242EA54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8242EA58: 48000014  b 0x8242ea6c
	pc = 0x8242EA6C; continue 'dispatch;
	// 8242EA5C: 419A000C  beq cr6, 0x8242ea68
	if ctx.cr[6].eq {
	pc = 0x8242EA68; continue 'dispatch;
	}
	// 8242EA60: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8242EA64: 4BE91E2D  bl 0x822c0890
	ctx.lr = 0x8242EA68;
	sub_822C0890(ctx, base);
	// 8242EA68: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8242EA6C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8242EA70: 48D7974C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242EA78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8242EA78 size=272
    let mut pc: u32 = 0x8242EA78;
    'dispatch: loop {
        match pc {
            0x8242EA78 => {
    //   block [0x8242EA78..0x8242EB88)
	// 8242EA78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8242EA7C: 48D796ED  bl 0x831a8168
	ctx.lr = 0x8242EA80;
	sub_831A8130(ctx, base);
	// 8242EA80: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8242EA84: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8242EA88: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8242EA8C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 8242EA90: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 8242EA94: 809D0004  lwz r4, 4(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242EA98: 4BED9229  bl 0x82307cc0
	ctx.lr = 0x8242EA9C;
	sub_82307CC0(ctx, base);
	// 8242EA9C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8242EAA0: 809D0004  lwz r4, 4(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242EAA4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8242EAA8: 4BED6FC9  bl 0x82305a70
	ctx.lr = 0x8242EAAC;
	sub_82305A70(ctx, base);
	// 8242EAAC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8242EAB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8242EAB4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8242EAB8: 4BFFF971  bl 0x8242e428
	ctx.lr = 0x8242EABC;
	sub_8242E428(ctx, base);
	// 8242EABC: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8242EAC0: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8242EAC4: 4182002C  beq 0x8242eaf0
	if ctx.cr[0].eq {
	pc = 0x8242EAF0; continue 'dispatch;
	}
	// 8242EAC8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242EACC: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 8242EAD0: C1AB05D0  lfs f13, 0x5d0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1488 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8242EAD4: C00A964C  lfs f0, -0x69b4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8242EAD8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 8242EADC: 40990014  ble cr6, 0x8242eaf0
	if !ctx.cr[6].gt {
	pc = 0x8242EAF0; continue 'dispatch;
	}
	// 8242EAE0: 394005C0  li r10, 0x5c0
	ctx.r[10].s64 = 1472;
	// 8242EAE4: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 8242EAE8: 13EB50C7  vcmpequd (lvx128) v31, v11, v10
	tmp.u32 = ctx.r[11].u32 + ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242EB88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8242EB88 size=196
    let mut pc: u32 = 0x8242EB88;
    'dispatch: loop {
        match pc {
            0x8242EB88 => {
    //   block [0x8242EB88..0x8242EC4C)
	// 8242EB88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8242EB8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8242EB90: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8242EB94: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8242EB98: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8242EB9C: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 8242EBA0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8242EBA4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8242EBA8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8242EBAC: 4BEEE625  bl 0x8231d1d0
	ctx.lr = 0x8242EBB0;
	sub_8231D1D0(ctx, base);
	// 8242EBB0: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8242EBB4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8242EBB8: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8242EBBC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8242EBC0: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 8242EBC4: 419A0024  beq cr6, 0x8242ebe8
	if ctx.cr[6].eq {
	pc = 0x8242EBE8; continue 'dispatch;
	}
	// 8242EBC8: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 8242EBCC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8242EBD0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8242EBD4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8242EBD8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8242EBDC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8242EBE0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8242EBE4: 4082FFE8  bne 0x8242ebcc
	if !ctx.cr[0].eq {
	pc = 0x8242EBCC; continue 'dispatch;
	}
	// 8242EBE8: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242EBEC: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8242EBF0: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 8242EBF4: 388B5688  addi r4, r11, 0x5688
	ctx.r[4].s64 = ctx.r[11].s64 + 22152;
	// 8242EBF8: 38A0014C  li r5, 0x14c
	ctx.r[5].s64 = 332;
	// 8242EBFC: 80C3082C  lwz r6, 0x82c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(2092 as u32) ) } as u64;
	// 8242EC00: 4BED9239  bl 0x82307e38
	ctx.lr = 0x8242EC04;
	sub_82307E38(ctx, base);
	// 8242EC04: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8242EC08: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8242EC0C: 41820018  beq 0x8242ec24
	if ctx.cr[0].eq {
	pc = 0x8242EC24; continue 'dispatch;
	}
	// 8242EC10: 419A000C  beq cr6, 0x8242ec1c
	if ctx.cr[6].eq {
	pc = 0x8242EC1C; continue 'dispatch;
	}
	// 8242EC14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8242EC18: 4BE91C79  bl 0x822c0890
	ctx.lr = 0x8242EC1C;
	sub_822C0890(ctx, base);
	// 8242EC1C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 8242EC20: 48000014  b 0x8242ec34
	pc = 0x8242EC34; continue 'dispatch;
	// 8242EC24: 419A000C  beq cr6, 0x8242ec30
	if ctx.cr[6].eq {
	pc = 0x8242EC30; continue 'dispatch;
	}
	// 8242EC28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8242EC2C: 4BE91C65  bl 0x822c0890
	ctx.lr = 0x8242EC30;
	sub_822C0890(ctx, base);
	// 8242EC30: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8242EC34: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8242EC38: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8242EC3C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8242EC40: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8242EC44: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8242EC48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242EC50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8242EC50 size=148
    let mut pc: u32 = 0x8242EC50;
    'dispatch: loop {
        match pc {
            0x8242EC50 => {
    //   block [0x8242EC50..0x8242ECE4)
	// 8242EC50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8242EC54: 48D79519  bl 0x831a816c
	ctx.lr = 0x8242EC58;
	sub_831A8130(ctx, base);
	// 8242EC58: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8242EC5C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8242EC60: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8242EC64: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 8242EC68: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8242EC6C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8242EC70: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 8242EC74: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8242EC78: 4BFFFA59  bl 0x8242e6d0
	ctx.lr = 0x8242EC7C;
	sub_8242E6D0(ctx, base);
	// 8242EC7C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8242EC80: 807E0314  lwz r3, 0x314(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(788 as u32) ) } as u64;
	// 8242EC84: 480632F5  bl 0x82491f78
	ctx.lr = 0x8242EC88;
	sub_82491F78(ctx, base);
	// 8242EC88: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8242EC8C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8242EC90: 807E0314  lwz r3, 0x314(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(788 as u32) ) } as u64;
	// 8242EC94: 480632DD  bl 0x82491f70
	ctx.lr = 0x8242EC98;
	sub_82491F70(ctx, base);
	// 8242EC98: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8242EC9C: 4182003C  beq 0x8242ecd8
	if ctx.cr[0].eq {
	pc = 0x8242ECD8; continue 'dispatch;
	}
	// 8242ECA0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8242ECA4: C001006C  lfs f0, 0x6c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8242ECA8: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 8242ECAC: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8242ECB0: C1A10070  lfs f13, 0x70(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8242ECB4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 8242ECB8: C1810074  lfs f12, 0x74(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8242ECBC: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8242ECC0: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8242ECC4: D1810058  stfs f12, 0x58(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8242ECC8: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 8242ECCC: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242ECE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8242ECE8 size=1016
    let mut pc: u32 = 0x8242ECE8;
    'dispatch: loop {
        match pc {
            0x8242ECE8 => {
    //   block [0x8242ECE8..0x8242F0E0)
	// 8242ECE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8242ECEC: 48D7946D  bl 0x831a8158
	ctx.lr = 0x8242ECF0;
	sub_831A8130(ctx, base);
	// 8242ECF0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8242ECF4: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 8242ECF8: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 8242ECFC: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 8242ED00: 93E10104  stw r31, 0x104(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(260 as u32), ctx.r[31].u32 ) };
	// 8242ED04: 897F0041  lbz r11, 0x41(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(65 as u32) ) } as u64;
	// 8242ED08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8242ED0C: 419A0048  beq cr6, 0x8242ed54
	if ctx.cr[6].eq {
	pc = 0x8242ED54; continue 'dispatch;
	}
	// 8242ED10: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8242ED14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8242ED18: 388B9620  addi r4, r11, -0x69e0
	ctx.r[4].s64 = ctx.r[11].s64 + -27104;
	// 8242ED1C: 4BE96BAD  bl 0x822c58c8
	ctx.lr = 0x8242ED20;
	sub_822C58C8(ctx, base);
	// 8242ED20: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8242ED24: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8242ED28: 4BE9B189  bl 0x822c9eb0
	ctx.lr = 0x8242ED2C;
	sub_822C9EB0(ctx, base);
	// 8242ED2C: 4BE95585  bl 0x822c42b0
	ctx.lr = 0x8242ED30;
	sub_822C42B0(ctx, base);
	// 8242ED30: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8242ED34: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8242ED38: 396B9600  addi r11, r11, -0x6a00
	ctx.r[11].s64 = ctx.r[11].s64 + -27136;
	// 8242ED3C: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 8242ED40: 4BE96731  bl 0x822c5470
	ctx.lr = 0x8242ED44;
	sub_822C5470(ctx, base);
	// 8242ED44: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8242ED48: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8242ED4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8242ED50: 4BE95F91  bl 0x822c4ce0
	ctx.lr = 0x8242ED54;
	sub_822C4CE0(ctx, base);
	// 8242ED54: 38610104  addi r3, r1, 0x104
	ctx.r[3].s64 = ctx.r[1].s64 + 260;
	// 8242ED58: 7FFAFB78  mr r26, r31
	ctx.r[26].u64 = ctx.r[31].u64;
	// 8242ED5C: 4BFFE7CD  bl 0x8242d528
	ctx.lr = 0x8242ED60;
	sub_8242D528(ctx, base);
	// 8242ED60: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242ED64: 894B0041  lbz r10, 0x41(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(65 as u32) ) } as u64;
	// 8242ED68: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8242ED6C: 83210104  lwz r25, 0x104(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 8242ED70: 419A000C  beq cr6, 0x8242ed7c
	if ctx.cr[6].eq {
	pc = 0x8242ED7C; continue 'dispatch;
	}
	// 8242ED74: 839A0008  lwz r28, 8(r26)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 8242ED78: 48000028  b 0x8242eda0
	pc = 0x8242EDA0; continue 'dispatch;
	// 8242ED7C: 815A0008  lwz r10, 8(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 8242ED80: 894A0041  lbz r10, 0x41(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(65 as u32) ) } as u64;
	// 8242ED84: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8242ED88: 419A000C  beq cr6, 0x8242ed94
	if ctx.cr[6].eq {
	pc = 0x8242ED94; continue 'dispatch;
	}
	// 8242ED8C: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 8242ED90: 48000010  b 0x8242eda0
	pc = 0x8242EDA0; continue 'dispatch;
	// 8242ED94: 83990008  lwz r28, 8(r25)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 8242ED98: 7F19D040  cmplw cr6, r25, r26
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[26].u32, &mut ctx.xer);
	// 8242ED9C: 409A00DC  bne cr6, 0x8242ee78
	if !ctx.cr[6].eq {
	pc = 0x8242EE78; continue 'dispatch;
	}
	// 8242EDA0: 897C0041  lbz r11, 0x41(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(65 as u32) ) } as u64;
	// 8242EDA4: 83FA0004  lwz r31, 4(r26)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242EDA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8242EDAC: 409A0008  bne cr6, 0x8242edb4
	if !ctx.cr[6].eq {
	pc = 0x8242EDB4; continue 'dispatch;
	}
	// 8242EDB0: 93FC0004  stw r31, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 8242EDB4: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242EDB8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242EDBC: 7F0AD040  cmplw cr6, r10, r26
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[26].u32, &mut ctx.xer);
	// 8242EDC0: 409A000C  bne cr6, 0x8242edcc
	if !ctx.cr[6].eq {
	pc = 0x8242EDCC; continue 'dispatch;
	}
	// 8242EDC4: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 8242EDC8: 4800001C  b 0x8242ede4
	pc = 0x8242EDE4; continue 'dispatch;
	// 8242EDCC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242EDD0: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 8242EDD4: 409A000C  bne cr6, 0x8242ede0
	if !ctx.cr[6].eq {
	pc = 0x8242EDE0; continue 'dispatch;
	}
	// 8242EDD8: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 8242EDDC: 48000008  b 0x8242ede4
	pc = 0x8242EDE4; continue 'dispatch;
	// 8242EDE0: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 8242EDE4: 813B0004  lwz r9, 4(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242EDE8: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242EDEC: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 8242EDF0: 409A003C  bne cr6, 0x8242ee2c
	if !ctx.cr[6].eq {
	pc = 0x8242EE2C; continue 'dispatch;
	}
	// 8242EDF4: 897C0041  lbz r11, 0x41(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(65 as u32) ) } as u64;
	// 8242EDF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8242EDFC: 419A000C  beq cr6, 0x8242ee08
	if ctx.cr[6].eq {
	pc = 0x8242EE08; continue 'dispatch;
	}
	// 8242EE00: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 8242EE04: 48000024  b 0x8242ee28
	pc = 0x8242EE28; continue 'dispatch;
	// 8242EE08: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242EE0C: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 8242EE10: 4800000C  b 0x8242ee1c
	pc = 0x8242EE1C; continue 'dispatch;
	// 8242EE14: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 8242EE18: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242EE1C: 890B0041  lbz r8, 0x41(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(65 as u32) ) } as u64;
	// 8242EE20: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 8242EE24: 419AFFF0  beq cr6, 0x8242ee14
	if ctx.cr[6].eq {
	pc = 0x8242EE14; continue 'dispatch;
	}
	// 8242EE28: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8242EE2C: 813B0004  lwz r9, 4(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242EE30: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 8242EE34: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 8242EE38: 409A00D4  bne cr6, 0x8242ef0c
	if !ctx.cr[6].eq {
	pc = 0x8242EF0C; continue 'dispatch;
	}
	// 8242EE3C: 897C0041  lbz r11, 0x41(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(65 as u32) ) } as u64;
	// 8242EE40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8242EE44: 419A000C  beq cr6, 0x8242ee50
	if ctx.cr[6].eq {
	pc = 0x8242EE50; continue 'dispatch;
	}
	// 8242EE48: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 8242EE4C: 48000024  b 0x8242ee70
	pc = 0x8242EE70; continue 'dispatch;
	// 8242EE50: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 8242EE54: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 8242EE58: 4800000C  b 0x8242ee64
	pc = 0x8242EE64; continue 'dispatch;
	// 8242EE5C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 8242EE60: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8242EE64: 890B0041  lbz r8, 0x41(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(65 as u32) ) } as u64;
	// 8242EE68: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 8242EE6C: 419AFFF0  beq cr6, 0x8242ee5c
	if ctx.cr[6].eq {
	pc = 0x8242EE5C; continue 'dispatch;
	}
	// 8242EE70: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8242EE74: 48000098  b 0x8242ef0c
	pc = 0x8242EF0C; continue 'dispatch;
	// 8242EE78: 932B0004  stw r25, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 8242EE7C: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242EE80: 91790000  stw r11, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8242EE84: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 8242EE88: 7F195840  cmplw cr6, r25, r11
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8242EE8C: 409A000C  bne cr6, 0x8242ee98
	if !ctx.cr[6].eq {
	pc = 0x8242EE98; continue 'dispatch;
	}
	// 8242EE90: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 8242EE94: 4800002C  b 0x8242eec0
	pc = 0x8242EEC0; continue 'dispatch;
	// 8242EE98: 897C0041  lbz r11, 0x41(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(65 as u32) ) } as u64;
	// 8242EE9C: 83F90004  lwz r31, 4(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242EEA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8242EEA4: 409A0008  bne cr6, 0x8242eeac
	if !ctx.cr[6].eq {
	pc = 0x8242EEAC; continue 'dispatch;
	}
	// 8242EEA8: 93FC0004  stw r31, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 8242EEAC: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 8242EEB0: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 8242EEB4: 91790008  stw r11, 8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8242EEB8: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 8242EEBC: 932B0004  stw r25, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 8242EEC0: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242EEC4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242EEC8: 7F0AD040  cmplw cr6, r10, r26
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[26].u32, &mut ctx.xer);
	// 8242EECC: 409A000C  bne cr6, 0x8242eed8
	if !ctx.cr[6].eq {
	pc = 0x8242EED8; continue 'dispatch;
	}
	// 8242EED0: 932B0004  stw r25, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 8242EED4: 48000020  b 0x8242eef4
	pc = 0x8242EEF4; continue 'dispatch;
	// 8242EED8: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242EEDC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242EEE0: 7F0AD040  cmplw cr6, r10, r26
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[26].u32, &mut ctx.xer);
	// 8242EEE4: 409A000C  bne cr6, 0x8242eef0
	if !ctx.cr[6].eq {
	pc = 0x8242EEF0; continue 'dispatch;
	}
	// 8242EEE8: 932B0000  stw r25, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 8242EEEC: 48000008  b 0x8242eef4
	pc = 0x8242EEF4; continue 'dispatch;
	// 8242EEF0: 932B0008  stw r25, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[25].u32 ) };
	// 8242EEF4: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242EEF8: 91790004  stw r11, 4(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8242EEFC: 897A0040  lbz r11, 0x40(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(64 as u32) ) } as u64;
	// 8242EF00: 89590040  lbz r10, 0x40(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(64 as u32) ) } as u64;
	// 8242EF04: 99790040  stb r11, 0x40(r25)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[25].u32.wrapping_add(64 as u32), ctx.r[11].u8 ) };
	// 8242EF08: 995A0040  stb r10, 0x40(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(64 as u32), ctx.r[10].u8 ) };
	// 8242EF0C: 897A0040  lbz r11, 0x40(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(64 as u32) ) } as u64;
	// 8242EF10: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 8242EF14: 409A0198  bne cr6, 0x8242f0ac
	if !ctx.cr[6].eq {
	pc = 0x8242F0AC; continue 'dispatch;
	}
	// 8242EF18: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242EF1C: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 8242EF20: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242EF24: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8242EF28: 419A0180  beq cr6, 0x8242f0a8
	if ctx.cr[6].eq {
	pc = 0x8242F0A8; continue 'dispatch;
	}
	// 8242EF2C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 8242EF30: 897C0040  lbz r11, 0x40(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(64 as u32) ) } as u64;
	// 8242EF34: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 8242EF38: 409A0170  bne cr6, 0x8242f0a8
	if !ctx.cr[6].eq {
	pc = 0x8242F0A8; continue 'dispatch;
	}
	// 8242EF3C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242EF40: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8242EF44: 409A00A8  bne cr6, 0x8242efec
	if !ctx.cr[6].eq {
	pc = 0x8242EFEC; continue 'dispatch;
	}
	// 8242EF48: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8242EF4C: 894B0040  lbz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 8242EF50: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8242EF54: 409A001C  bne cr6, 0x8242ef70
	if !ctx.cr[6].eq {
	pc = 0x8242EF70; continue 'dispatch;
	}
	// 8242EF58: 9BCB0040  stb r30, 0x40(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), ctx.r[30].u8 ) };
	// 8242EF5C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8242EF60: 9BBF0040  stb r29, 0x40(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[29].u8 ) };
	// 8242EF64: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8242EF68: 4BFFE9E1  bl 0x8242d948
	ctx.lr = 0x8242EF6C;
	sub_8242D948(ctx, base);
	// 8242EF6C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8242EF70: 894B0041  lbz r10, 0x41(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(65 as u32) ) } as u64;
	// 8242EF74: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8242EF78: 409A00C8  bne cr6, 0x8242f040
	if !ctx.cr[6].eq {
	pc = 0x8242F040; continue 'dispatch;
	}
	// 8242EF7C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242EF80: 894A0040  lbz r10, 0x40(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 8242EF84: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 8242EF88: 409A0014  bne cr6, 0x8242ef9c
	if !ctx.cr[6].eq {
	pc = 0x8242EF9C; continue 'dispatch;
	}
	// 8242EF8C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8242EF90: 894A0040  lbz r10, 0x40(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 8242EF94: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 8242EF98: 419A00A4  beq cr6, 0x8242f03c
	if ctx.cr[6].eq {
	pc = 0x8242F03C; continue 'dispatch;
	}
	// 8242EF9C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8242EFA0: 894A0040  lbz r10, 0x40(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 8242EFA4: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 8242EFA8: 409A0020  bne cr6, 0x8242efc8
	if !ctx.cr[6].eq {
	pc = 0x8242EFC8; continue 'dispatch;
	}
	// 8242EFAC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242EFB0: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 8242EFB4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8242EFB8: 9BCA0040  stb r30, 0x40(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(64 as u32), ctx.r[30].u8 ) };
	// 8242EFBC: 9BAB0040  stb r29, 0x40(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), ctx.r[29].u8 ) };
	// 8242EFC0: 4BFFE501  bl 0x8242d4c0
	ctx.lr = 0x8242EFC4;
	sub_8242D4C0(ctx, base);
	// 8242EFC4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8242EFC8: 895F0040  lbz r10, 0x40(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 8242EFCC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8242EFD0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8242EFD4: 994B0040  stb r10, 0x40(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), ctx.r[10].u8 ) };
	// 8242EFD8: 9BDF0040  stb r30, 0x40(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[30].u8 ) };
	// 8242EFDC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8242EFE0: 9BCB0040  stb r30, 0x40(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), ctx.r[30].u8 ) };
	// 8242EFE4: 4BFFE965  bl 0x8242d948
	ctx.lr = 0x8242EFE8;
	sub_8242D948(ctx, base);
	// 8242EFE8: 480000C0  b 0x8242f0a8
	pc = 0x8242F0A8; continue 'dispatch;
	// 8242EFEC: 894B0040  lbz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 8242EFF0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8242EFF4: 409A001C  bne cr6, 0x8242f010
	if !ctx.cr[6].eq {
	pc = 0x8242F010; continue 'dispatch;
	}
	// 8242EFF8: 9BCB0040  stb r30, 0x40(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), ctx.r[30].u8 ) };
	// 8242EFFC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8242F000: 9BBF0040  stb r29, 0x40(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[29].u8 ) };
	// 8242F004: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8242F008: 4BFFE4B9  bl 0x8242d4c0
	ctx.lr = 0x8242F00C;
	sub_8242D4C0(ctx, base);
	// 8242F00C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242F010: 894B0041  lbz r10, 0x41(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(65 as u32) ) } as u64;
	// 8242F014: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8242F018: 409A0028  bne cr6, 0x8242f040
	if !ctx.cr[6].eq {
	pc = 0x8242F040; continue 'dispatch;
	}
	// 8242F01C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8242F020: 894A0040  lbz r10, 0x40(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 8242F024: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 8242F028: 409A0034  bne cr6, 0x8242f05c
	if !ctx.cr[6].eq {
	pc = 0x8242F05C; continue 'dispatch;
	}
	// 8242F02C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242F030: 894A0040  lbz r10, 0x40(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 8242F034: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 8242F038: 409A0024  bne cr6, 0x8242f05c
	if !ctx.cr[6].eq {
	pc = 0x8242F05C; continue 'dispatch;
	}
	// 8242F03C: 9BAB0040  stb r29, 0x40(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), ctx.r[29].u8 ) };
	// 8242F040: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242F044: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 8242F048: 83FF0004  lwz r31, 4(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242F04C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242F050: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8242F054: 409AFEDC  bne cr6, 0x8242ef30
	if !ctx.cr[6].eq {
	pc = 0x8242EF30; continue 'dispatch;
	}
	// 8242F058: 48000050  b 0x8242f0a8
	pc = 0x8242F0A8; continue 'dispatch;
	// 8242F05C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242F060: 894A0040  lbz r10, 0x40(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 8242F064: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 8242F068: 409A0020  bne cr6, 0x8242f088
	if !ctx.cr[6].eq {
	pc = 0x8242F088; continue 'dispatch;
	}
	// 8242F06C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8242F070: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 8242F074: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8242F078: 9BCA0040  stb r30, 0x40(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(64 as u32), ctx.r[30].u8 ) };
	// 8242F07C: 9BAB0040  stb r29, 0x40(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), ctx.r[29].u8 ) };
	// 8242F080: 4BFFE8C9  bl 0x8242d948
	ctx.lr = 0x8242F084;
	sub_8242D948(ctx, base);
	// 8242F084: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242F088: 895F0040  lbz r10, 0x40(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 8242F08C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8242F090: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8242F094: 994B0040  stb r10, 0x40(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), ctx.r[10].u8 ) };
	// 8242F098: 9BDF0040  stb r30, 0x40(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[30].u8 ) };
	// 8242F09C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242F0A0: 9BCB0040  stb r30, 0x40(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), ctx.r[30].u8 ) };
	// 8242F0A4: 4BFFE41D  bl 0x8242d4c0
	ctx.lr = 0x8242F0A8;
	sub_8242D4C0(ctx, base);
	// 8242F0A8: 9BDC0040  stb r30, 0x40(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(64 as u32), ctx.r[30].u8 ) };
	// 8242F0AC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 8242F0B0: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 8242F0B4: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 8242F0B8: 489C30D1  bl 0x82df2188
	ctx.lr = 0x8242F0BC;
	sub_82DF2188(ctx, base);
	// 8242F0BC: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 8242F0C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8242F0C4: 419A000C  beq cr6, 0x8242f0d0
	if ctx.cr[6].eq {
	pc = 0x8242F0D0; continue 'dispatch;
	}
	// 8242F0C8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8242F0CC: 917B0008  stw r11, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8242F0D0: 93380000  stw r25, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 8242F0D4: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 8242F0D8: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 8242F0DC: 48D790CC  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242F0E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8242F0E0 size=132
    let mut pc: u32 = 0x8242F0E0;
    'dispatch: loop {
        match pc {
            0x8242F0E0 => {
    //   block [0x8242F0E0..0x8242F164)
	// 8242F0E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8242F0E4: 48D79085  bl 0x831a8168
	ctx.lr = 0x8242F0E8;
	sub_831A8130(ctx, base);
	// 8242F0E8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8242F0EC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8242F0F0: 90A100A4  stw r5, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[5].u32 ) };
	// 8242F0F4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8242F0F8: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 8242F0FC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242F100: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242F104: 7F055040  cmplw cr6, r5, r10
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8242F108: 409A0044  bne cr6, 0x8242f14c
	if !ctx.cr[6].eq {
	pc = 0x8242F14C; continue 'dispatch;
	}
	// 8242F10C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8242F110: 409A003C  bne cr6, 0x8242f14c
	if !ctx.cr[6].eq {
	pc = 0x8242F14C; continue 'dispatch;
	}
	// 8242F114: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8242F118: 4BFFEF09  bl 0x8242e020
	ctx.lr = 0x8242F11C;
	sub_8242E020(ctx, base);
	// 8242F11C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242F120: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242F124: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8242F128: 48000030  b 0x8242f158
	pc = 0x8242F158; continue 'dispatch;
	// 8242F12C: 386100A4  addi r3, r1, 0xa4
	ctx.r[3].s64 = ctx.r[1].s64 + 164;
	// 8242F130: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 8242F134: 4BFFE3F5  bl 0x8242d528
	ctx.lr = 0x8242F138;
	sub_8242D528(ctx, base);
	// 8242F138: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 8242F13C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8242F140: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8242F144: 4BFFFBA5  bl 0x8242ece8
	ctx.lr = 0x8242F148;
	sub_8242ECE8(ctx, base);
	// 8242F148: 80A100A4  lwz r5, 0xa4(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 8242F14C: 7F05F040  cmplw cr6, r5, r30
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[30].u32, &mut ctx.xer);
	// 8242F150: 409AFFDC  bne cr6, 0x8242f12c
	if !ctx.cr[6].eq {
	pc = 0x8242F12C; continue 'dispatch;
	}
	// 8242F154: 90BD0000  stw r5, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 8242F158: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8242F15C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8242F160: 48D79058  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242F168(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8242F168 size=548
    let mut pc: u32 = 0x8242F168;
    'dispatch: loop {
        match pc {
            0x8242F168 => {
    //   block [0x8242F168..0x8242F38C)
	// 8242F168: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8242F16C: 48D78FF5  bl 0x831a8160
	ctx.lr = 0x8242F170;
	sub_831A8130(ctx, base);
	// 8242F170: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8242F174: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8242F178: 3D600555  lis r11, 0x555
	ctx.r[11].s64 = 89456640;
	// 8242F17C: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 8242F180: 616B5554  ori r11, r11, 0x5554
	ctx.r[11].u64 = ctx.r[11].u64 | 21844;
	// 8242F184: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 8242F188: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8242F18C: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 8242F190: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 8242F194: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8242F198: 41980048  blt cr6, 0x8242f1e0
	if ctx.cr[6].lt {
	pc = 0x8242F1E0; continue 'dispatch;
	}
	// 8242F19C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8242F1A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8242F1A4: 388B9BCC  addi r4, r11, -0x6434
	ctx.r[4].s64 = ctx.r[11].s64 + -25652;
	// 8242F1A8: 4BE96721  bl 0x822c58c8
	ctx.lr = 0x8242F1AC;
	sub_822C58C8(ctx, base);
	// 8242F1AC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8242F1B0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8242F1B4: 4BE96665  bl 0x822c5818
	ctx.lr = 0x8242F1B8;
	sub_822C5818(ctx, base);
	// 8242F1B8: 4BE950F9  bl 0x822c42b0
	ctx.lr = 0x8242F1BC;
	sub_822C42B0(ctx, base);
	// 8242F1BC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8242F1C0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8242F1C4: 396B94A0  addi r11, r11, -0x6b60
	ctx.r[11].s64 = ctx.r[11].s64 + -27488;
	// 8242F1C8: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 8242F1CC: 4BE962A5  bl 0x822c5470
	ctx.lr = 0x8242F1D0;
	sub_822C5470(ctx, base);
	// 8242F1D0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8242F1D4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8242F1D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8242F1DC: 4BE95B05  bl 0x822c4ce0
	ctx.lr = 0x8242F1E0;
	sub_822C4CE0(ctx, base);
	// 8242F1E0: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242F1E4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8242F1E8: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 8242F1EC: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 8242F1F0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8242F1F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8242F1F8: 4BFFF061  bl 0x8242e258
	ctx.lr = 0x8242F1FC;
	sub_8242E258(ctx, base);
	// 8242F1FC: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8242F200: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242F204: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8242F208: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8242F20C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8242F210: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8242F214: 409A0018  bne cr6, 0x8242f22c
	if !ctx.cr[6].eq {
	pc = 0x8242F22C; continue 'dispatch;
	}
	// 8242F218: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 8242F21C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242F220: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 8242F224: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242F228: 4800003C  b 0x8242f264
	pc = 0x8242F264; continue 'dispatch;
	// 8242F22C: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8242F230: 41820020  beq 0x8242f250
	if ctx.cr[0].eq {
	pc = 0x8242F250; continue 'dispatch;
	}
	// 8242F234: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 8242F238: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242F23C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242F240: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8242F244: 409A0024  bne cr6, 0x8242f268
	if !ctx.cr[6].eq {
	pc = 0x8242F268; continue 'dispatch;
	}
	// 8242F248: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 8242F24C: 4800001C  b 0x8242f268
	pc = 0x8242F268; continue 'dispatch;
	// 8242F250: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 8242F254: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242F258: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8242F25C: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8242F260: 409A0008  bne cr6, 0x8242f268
	if !ctx.cr[6].eq {
	pc = 0x8242F268; continue 'dispatch;
	}
	// 8242F264: 938B0008  stw r28, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 8242F268: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242F26C: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 8242F270: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 8242F274: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 8242F278: 894A0040  lbz r10, 0x40(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 8242F27C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8242F280: 409A00F0  bne cr6, 0x8242f370
	if !ctx.cr[6].eq {
	pc = 0x8242F370; continue 'dispatch;
	}
	// 8242F284: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 8242F288: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242F28C: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242F290: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242F294: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8242F298: 409A0054  bne cr6, 0x8242f2ec
	if !ctx.cr[6].eq {
	pc = 0x8242F2EC; continue 'dispatch;
	}
	// 8242F29C: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 8242F2A0: 892A0040  lbz r9, 0x40(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 8242F2A4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8242F2A8: 419A0054  beq cr6, 0x8242f2fc
	if ctx.cr[6].eq {
	pc = 0x8242F2FC; continue 'dispatch;
	}
	// 8242F2AC: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 8242F2B0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8242F2B4: 409A0010  bne cr6, 0x8242f2c4
	if !ctx.cr[6].eq {
	pc = 0x8242F2C4; continue 'dispatch;
	}
	// 8242F2B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8242F2BC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8242F2C0: 4BFFE689  bl 0x8242d948
	ctx.lr = 0x8242F2C4;
	sub_8242D948(ctx, base);
	// 8242F2C4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242F2C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8242F2CC: 9BAB0040  stb r29, 0x40(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), ctx.r[29].u8 ) };
	// 8242F2D0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242F2D4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242F2D8: 9B6B0040  stb r27, 0x40(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), ctx.r[27].u8 ) };
	// 8242F2DC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242F2E0: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242F2E4: 4BFFE1DD  bl 0x8242d4c0
	ctx.lr = 0x8242F2E8;
	sub_8242D4C0(ctx, base);
	// 8242F2E8: 48000074  b 0x8242f35c
	pc = 0x8242F35C; continue 'dispatch;
	// 8242F2EC: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242F2F0: 892A0040  lbz r9, 0x40(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 8242F2F4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8242F2F8: 409A0028  bne cr6, 0x8242f320
	if !ctx.cr[6].eq {
	pc = 0x8242F320; continue 'dispatch;
	}
	// 8242F2FC: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242F300: 9BA90040  stb r29, 0x40(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(64 as u32), ctx.r[29].u8 ) };
	// 8242F304: 9BAA0040  stb r29, 0x40(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(64 as u32), ctx.r[29].u8 ) };
	// 8242F308: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242F30C: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242F310: 9B6A0040  stb r27, 0x40(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(64 as u32), ctx.r[27].u8 ) };
	// 8242F314: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242F318: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242F31C: 48000040  b 0x8242f35c
	pc = 0x8242F35C; continue 'dispatch;
	// 8242F320: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242F324: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8242F328: 409A0010  bne cr6, 0x8242f338
	if !ctx.cr[6].eq {
	pc = 0x8242F338; continue 'dispatch;
	}
	// 8242F32C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8242F330: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8242F334: 4BFFE18D  bl 0x8242d4c0
	ctx.lr = 0x8242F338;
	sub_8242D4C0(ctx, base);
	// 8242F338: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242F33C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8242F340: 9BAB0040  stb r29, 0x40(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), ctx.r[29].u8 ) };
	// 8242F344: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242F348: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242F34C: 9B6B0040  stb r27, 0x40(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), ctx.r[27].u8 ) };
	// 8242F350: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242F354: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242F358: 4BFFE5F1  bl 0x8242d948
	ctx.lr = 0x8242F35C;
	sub_8242D948(ctx, base);
	// 8242F35C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242F360: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 8242F364: 894A0040  lbz r10, 0x40(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 8242F368: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8242F36C: 419AFF1C  beq cr6, 0x8242f288
	if ctx.cr[6].eq {
	pc = 0x8242F288; continue 'dispatch;
	}
	// 8242F370: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242F374: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8242F378: 939A0000  stw r28, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 8242F37C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242F380: 9BAB0040  stb r29, 0x40(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), ctx.r[29].u8 ) };
	// 8242F384: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 8242F388: 48D78E28  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242F390(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8242F390 size=88
    let mut pc: u32 = 0x8242F390;
    'dispatch: loop {
        match pc {
            0x8242F390 => {
    //   block [0x8242F390..0x8242F3E8)
	// 8242F390: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8242F394: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8242F398: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8242F39C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8242F3A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8242F3A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8242F3A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8242F3AC: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242F3B0: 80A60000  lwz r5, 0(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242F3B4: 4BFFFD2D  bl 0x8242f0e0
	ctx.lr = 0x8242F3B8;
	sub_8242F0E0(ctx, base);
	// 8242F3B8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 8242F3BC: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242F3C0: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 8242F3C4: 489C2DC5  bl 0x82df2188
	ctx.lr = 0x8242F3C8;
	sub_82DF2188(ctx, base);
	// 8242F3C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8242F3CC: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8242F3D0: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8242F3D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8242F3D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8242F3DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8242F3E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8242F3E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242F3E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8242F3E8 size=236
    let mut pc: u32 = 0x8242F3E8;
    'dispatch: loop {
        match pc {
            0x8242F3E8 => {
    //   block [0x8242F3E8..0x8242F4D4)
	// 8242F3E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8242F3EC: 48D78D75  bl 0x831a8160
	ctx.lr = 0x8242F3F0;
	sub_831A8130(ctx, base);
	// 8242F3F0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8242F3F4: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 8242F3F8: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 8242F3FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8242F400: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 8242F404: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 8242F408: 83DC0004  lwz r30, 4(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242F40C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242F410: 894B0041  lbz r10, 0x41(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(65 as u32) ) } as u64;
	// 8242F414: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8242F418: 409A0038  bne cr6, 0x8242f450
	if !ctx.cr[6].eq {
	pc = 0x8242F450; continue 'dispatch;
	}
	// 8242F41C: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242F420: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8242F424: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 8242F428: 7D295010  subfc r9, r9, r10
	ctx.xer.ca = ctx.r[10].u32 >= ctx.r[9].u32;
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 8242F42C: 7D294910  subfe r9, r9, r9
	let x = (!ctx.r[9].u32);
	let y = ctx.r[9].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[9].u32 = res;
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 8242F430: 553D07FF  clrlwi. r29, r9, 0x1f
	ctx.r[29].u64 = ctx.r[9].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 8242F434: 4182000C  beq 0x8242f440
	if ctx.cr[0].eq {
	pc = 0x8242F440; continue 'dispatch;
	}
	// 8242F438: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242F43C: 48000008  b 0x8242f444
	pc = 0x8242F444; continue 'dispatch;
	// 8242F440: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8242F444: 892B0041  lbz r9, 0x41(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(65 as u32) ) } as u64;
	// 8242F448: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8242F44C: 419AFFD4  beq cr6, 0x8242f420
	if ctx.cr[6].eq {
	pc = 0x8242F420; continue 'dispatch;
	}
	// 8242F450: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 8242F454: 57AA063F  clrlwi. r10, r29, 0x18
	ctx.r[10].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8242F458: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8242F45C: 41820044  beq 0x8242f4a0
	if ctx.cr[0].eq {
	pc = 0x8242F4A0; continue 'dispatch;
	}
	// 8242F460: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242F464: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8242F468: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242F46C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8242F470: 409A0028  bne cr6, 0x8242f498
	if !ctx.cr[6].eq {
	pc = 0x8242F498; continue 'dispatch;
	}
	// 8242F474: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8242F478: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8242F47C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 8242F480: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 8242F484: 4BFFFCE5  bl 0x8242f168
	ctx.lr = 0x8242F488;
	sub_8242F168(ctx, base);
	// 8242F488: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8242F48C: 9B5F0004  stb r26, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[26].u8 ) };
	// 8242F490: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242F494: 48000030  b 0x8242f4c4
	pc = 0x8242F4C4; continue 'dispatch;
	// 8242F498: 4BFFE109  bl 0x8242d5a0
	ctx.lr = 0x8242F49C;
	sub_8242D5A0(ctx, base);
	// 8242F49C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8242F4A0: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8242F4A4: 813B0000  lwz r9, 0(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242F4A8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8242F4AC: 40980010  bge cr6, 0x8242f4bc
	if !ctx.cr[6].lt {
	pc = 0x8242F4BC; continue 'dispatch;
	}
	// 8242F4B0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8242F4B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8242F4B8: 4BFFFFC0  b 0x8242f478
	pc = 0x8242F478; continue 'dispatch;
	// 8242F4BC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8242F4C0: 995F0004  stb r10, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u8 ) };
	// 8242F4C4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8242F4C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8242F4CC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8242F4D0: 48D78CE0  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242F4D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8242F4D8 size=100
    let mut pc: u32 = 0x8242F4D8;
    'dispatch: loop {
        match pc {
            0x8242F4D8 => {
    //   block [0x8242F4D8..0x8242F53C)
	// 8242F4D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8242F4DC: 48D78C91  bl 0x831a816c
	ctx.lr = 0x8242F4E0;
	sub_831A8130(ctx, base);
	// 8242F4E0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8242F4E4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8242F4E8: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 8242F4EC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8242F4F0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8242F4F4: 4BFFECD5  bl 0x8242e1c8
	ctx.lr = 0x8242F4F8;
	sub_8242E1C8(ctx, base);
	// 8242F4F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8242F4FC: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 8242F500: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8242F504: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8242F508: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8242F50C: 83C10058  lwz r30, 0x58(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8242F510: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8242F514: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8242F518: 4BFFEBD1  bl 0x8242e0e8
	ctx.lr = 0x8242F51C;
	sub_8242E0E8(ctx, base);
	// 8242F51C: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 8242F520: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8242F524: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8242F528: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8242F52C: 4BFFFBB5  bl 0x8242f0e0
	ctx.lr = 0x8242F530;
	sub_8242F0E0(ctx, base);
	// 8242F530: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8242F534: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8242F538: 48D78C84  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242F540(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8242F540 size=268
    let mut pc: u32 = 0x8242F540;
    'dispatch: loop {
        match pc {
            0x8242F540 => {
    //   block [0x8242F540..0x8242F64C)
	// 8242F540: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8242F544: 48D78C15  bl 0x831a8158
	ctx.lr = 0x8242F548;
	sub_831A8130(ctx, base);
	// 8242F548: DBE1FFB0  stfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 8242F54C: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8242F550: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8242F554: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8242F558: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8242F55C: 3BBC0354  addi r29, r28, 0x354
	ctx.r[29].s64 = ctx.r[28].s64 + 852;
	// 8242F560: 3B00000A  li r24, 0xa
	ctx.r[24].s64 = 10;
	// 8242F564: C3EA08A4  lfs f31, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8242F568: 3B2B5688  addi r25, r11, 0x5688
	ctx.r[25].s64 = ctx.r[11].s64 + 22152;
	// 8242F56C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242F570: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242F574: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8242F578: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 8242F57C: 419A00B0  beq cr6, 0x8242f62c
	if ctx.cr[6].eq {
	pc = 0x8242F62C; continue 'dispatch;
	}
	// 8242F580: 3B7C03C8  addi r27, r28, 0x3c8
	ctx.r[27].s64 = ctx.r[28].s64 + 968;
	// 8242F584: 3B5DFFFC  addi r26, r29, -4
	ctx.r[26].s64 = ctx.r[29].s64 + -4;
	// 8242F588: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8242F58C: 4BFFEF1D  bl 0x8242e4a8
	ctx.lr = 0x8242F590;
	sub_8242E4A8(ctx, base);
	// 8242F590: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242F594: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8242F598: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242F59C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8242F5A0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 8242F5A4: 419A0024  beq cr6, 0x8242f5c8
	if ctx.cr[6].eq {
	pc = 0x8242F5C8; continue 'dispatch;
	}
	// 8242F5A8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8242F5AC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8242F5B0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8242F5B4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8242F5B8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8242F5BC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8242F5C0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8242F5C4: 4082FFE8  bne 0x8242f5ac
	if !ctx.cr[0].eq {
	pc = 0x8242F5AC; continue 'dispatch;
	}
	// 8242F5C8: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 8242F5CC: 807C0004  lwz r3, 4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242F5D0: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 8242F5D4: 80DE0010  lwz r6, 0x10(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 8242F5D8: 38A0019E  li r5, 0x19e
	ctx.r[5].s64 = 414;
	// 8242F5DC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8242F5E0: 3BFE0010  addi r31, r30, 0x10
	ctx.r[31].s64 = ctx.r[30].s64 + 16;
	// 8242F5E4: 4BED88A5  bl 0x82307e88
	ctx.lr = 0x8242F5E8;
	sub_82307E88(ctx, base);
	// 8242F5E8: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8242F5EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8242F5F0: 419A0008  beq cr6, 0x8242f5f8
	if ctx.cr[6].eq {
	pc = 0x8242F5F8; continue 'dispatch;
	}
	// 8242F5F4: 4BE9129D  bl 0x822c0890
	ctx.lr = 0x8242F5F8;
	sub_822C0890(ctx, base);
	// 8242F5F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8242F5FC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8242F600: 4BFFFED9  bl 0x8242f4d8
	ctx.lr = 0x8242F604;
	sub_8242F4D8(ctx, base);
	// 8242F604: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8242F608: 4BFFDF21  bl 0x8242d528
	ctx.lr = 0x8242F60C;
	sub_8242D528(ctx, base);
	// 8242F60C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8242F610: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 8242F614: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8242F618: 4BFFF6D1  bl 0x8242ece8
	ctx.lr = 0x8242F61C;
	sub_8242ECE8(ctx, base);
	// 8242F61C: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8242F620: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242F624: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8242F628: 409AFF60  bne cr6, 0x8242f588
	if !ctx.cr[6].eq {
	pc = 0x8242F588; continue 'dispatch;
	}
	// 8242F62C: 3718FFFF  addic. r24, r24, -1
	ctx.xer.ca = (ctx.r[24].u32 > (!(-1 as u32)));
	ctx.r[24].s64 = ctx.r[24].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[24].s32, 0, &mut ctx.xer);
	// 8242F630: 3BBD000C  addi r29, r29, 0xc
	ctx.r[29].s64 = ctx.r[29].s64 + 12;
	// 8242F634: 4082FF38  bne 0x8242f56c
	if !ctx.cr[0].eq {
	pc = 0x8242F56C; continue 'dispatch;
	}
	// 8242F638: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8242F63C: 917C0138  stw r11, 0x138(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(312 as u32), ctx.r[11].u32 ) };
	// 8242F640: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 8242F644: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 8242F648: 48D78B60  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242F650(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8242F650 size=540
    let mut pc: u32 = 0x8242F650;
    'dispatch: loop {
        match pc {
            0x8242F650 => {
    //   block [0x8242F650..0x8242F86C)
	// 8242F650: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8242F654: 48D78B19  bl 0x831a816c
	ctx.lr = 0x8242F658;
	sub_831A8130(ctx, base);
	// 8242F658: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 8242F65C: 48D7941D  bl 0x831a8a78
	ctx.lr = 0x8242F660;
	sub_831A8A40(ctx, base);
	// 8242F660: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8242F664: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 8242F668: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8242F66C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8242F670: 896B3EF9  lbz r11, 0x3ef9(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16121 as u32) ) } as u64;
	// 8242F674: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8242F678: 41820070  beq 0x8242f6e8
	if ctx.cr[0].eq {
	pc = 0x8242F6E8; continue 'dispatch;
	}
	// 8242F67C: 3BC000FF  li r30, 0xff
	ctx.r[30].s64 = 255;
	// 8242F680: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 8242F684: 9BC10050  stb r30, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u8 ) };
	// 8242F688: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 8242F68C: 9BC10051  stb r30, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[30].u8 ) };
	// 8242F690: 3D408326  lis r10, -0x7cda
	ctx.r[10].s64 = -2094661632;
	// 8242F694: 9BA10052  stb r29, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[29].u8 ) };
	// 8242F698: 3D208326  lis r9, -0x7cda
	ctx.r[9].s64 = -2094661632;
	// 8242F69C: 9BA10053  stb r29, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[29].u8 ) };
	// 8242F6A0: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 8242F6A4: C06B3F00  lfs f3, 0x3f00(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16128 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 8242F6A8: C04A64E8  lfs f2, 0x64e8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25832 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8242F6AC: C02964E4  lfs f1, 0x64e4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(25828 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8242F6B0: 4BFFD529  bl 0x8242cbd8
	ctx.lr = 0x8242F6B4;
	sub_8242CBD8(ctx, base);
	// 8242F6B4: 9BC10054  stb r30, 0x54(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u8 ) };
	// 8242F6B8: 9BC10055  stb r30, 0x55(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(85 as u32), ctx.r[30].u8 ) };
	// 8242F6BC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 8242F6C0: 9BC10056  stb r30, 0x56(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(86 as u32), ctx.r[30].u8 ) };
	// 8242F6C4: 3D408326  lis r10, -0x7cda
	ctx.r[10].s64 = -2094661632;
	// 8242F6C8: 9BA10057  stb r29, 0x57(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(87 as u32), ctx.r[29].u8 ) };
	// 8242F6CC: 3D208326  lis r9, -0x7cda
	ctx.r[9].s64 = -2094661632;
	// 8242F6D0: 38E10054  addi r7, r1, 0x54
	ctx.r[7].s64 = ctx.r[1].s64 + 84;
	// 8242F6D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8242F6D8: C06B3EFC  lfs f3, 0x3efc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16124 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 8242F6DC: C04A64E0  lfs f2, 0x64e0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25824 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8242F6E0: C02964DC  lfs f1, 0x64dc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(25820 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8242F6E4: 4BFFD4F5  bl 0x8242cbd8
	ctx.lr = 0x8242F6E8;
	sub_8242CBD8(ctx, base);
	// 8242F6E8: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 8242F6EC: 896B63E6  lbz r11, 0x63e6(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25574 as u32) ) } as u64;
	// 8242F6F0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8242F6F4: 41820144  beq 0x8242f838
	if ctx.cr[0].eq {
	pc = 0x8242F838; continue 'dispatch;
	}
	// 8242F6F8: C01F0174  lfs f0, 0x174(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(372 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8242F6FC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8242F700: EC00F828  fsubs f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 8242F704: 807F0170  lwz r3, 0x170(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 8242F708: D01F0174  stfs f0, 0x174(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(372 as u32), tmp.u32 ) };
	// 8242F70C: C3AB08A4  lfs f29, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 8242F710: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 8242F714: 41990020  bgt cr6, 0x8242f734
	if ctx.cr[6].gt {
	pc = 0x8242F734; continue 'dispatch;
	}
	// 8242F718: 481642D9  bl 0x825939f0
	ctx.lr = 0x8242F71C;
	sub_825939F0(ctx, base);
	// 8242F71C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8242F720: 41820118  beq 0x8242f838
	if ctx.cr[0].eq {
	pc = 0x8242F838; continue 'dispatch;
	}
	// 8242F724: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8242F728: 807F0170  lwz r3, 0x170(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 8242F72C: 48164265  bl 0x82593990
	ctx.lr = 0x8242F730;
	sub_82593990(ctx, base);
	// 8242F730: 48000108  b 0x8242f838
	pc = 0x8242F838; continue 'dispatch;
	// 8242F734: 481642BD  bl 0x825939f0
	ctx.lr = 0x8242F738;
	sub_825939F0(ctx, base);
	// 8242F738: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8242F73C: 40820010  bne 0x8242f74c
	if !ctx.cr[0].eq {
	pc = 0x8242F74C; continue 'dispatch;
	}
	// 8242F740: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8242F744: 807F0170  lwz r3, 0x170(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 8242F748: 48164249  bl 0x82593990
	ctx.lr = 0x8242F74C;
	sub_82593990(ctx, base);
	// 8242F74C: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 8242F750: C1BF0178  lfs f13, 0x178(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(376 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8242F754: C19F0174  lfs f12, 0x174(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(372 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8242F758: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 8242F75C: 3D208326  lis r9, -0x7cda
	ctx.r[9].s64 = -2094661632;
	// 8242F760: 3D008326  lis r8, -0x7cda
	ctx.r[8].s64 = -2094661632;
	// 8242F764: 3CE08326  lis r7, -0x7cda
	ctx.r[7].s64 = -2094661632;
	// 8242F768: C00BDFAC  lfs f0, -0x2054(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8242F76C: EDA06824  fdivs f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 8242F770: C00A9450  lfs f0, -0x6bb0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8242F774: C3C964C8  lfs f30, 0x64c8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(25800 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8242F778: C38864CC  lfs f28, 0x64cc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(25804 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 8242F77C: C3E764C4  lfs f31, 0x64c4(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(25796 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8242F780: EDAD0332  fmuls f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 8242F784: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8242F788: 48D79641  bl 0x831a8dc8
	ctx.lr = 0x8242F78C;
	sub_831A8DC8(ctx, base);
	// 8242F78C: FD800818  frsp f12, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = (ctx.f[1].f64 as f32) as f64;
	// 8242F790: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8242F794: C1AB08A8  lfs f13, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8242F798: EC0C07F2  fmuls f0, f12, f31
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[31].f64) as f32) as f64);
	// 8242F79C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8242F7A0: 40990040  ble cr6, 0x8242f7e0
	if !ctx.cr[6].gt {
	pc = 0x8242F7E0; continue 'dispatch;
	}
	// 8242F7A4: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 8242F7A8: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	// 8242F7AC: EC0C07B2  fmuls f0, f12, f30
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[30].f64) as f32) as f64);
	// 8242F7B0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8242F7B4: 4099003C  ble cr6, 0x8242f7f0
	if !ctx.cr[6].gt {
	pc = 0x8242F7F0; continue 'dispatch;
	}
	// 8242F7B8: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 8242F7BC: FC400090  fmr f2, f0
	ctx.f[2].f64 = ctx.f[0].f64;
	// 8242F7C0: EC0C0732  fmuls f0, f12, f28
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[28].f64) as f32) as f64);
	// 8242F7C4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8242F7C8: 41990038  bgt cr6, 0x8242f800
	if ctx.cr[6].gt {
	pc = 0x8242F800; continue 'dispatch;
	}
	// 8242F7CC: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 8242F7D0: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 8242F7D4: 4098002C  bge cr6, 0x8242f800
	if !ctx.cr[6].lt {
	pc = 0x8242F800; continue 'dispatch;
	}
	// 8242F7D8: FC60E890  fmr f3, f29
	ctx.f[3].f64 = ctx.f[29].f64;
	// 8242F7DC: 48000028  b 0x8242f804
	pc = 0x8242F804; continue 'dispatch;
	// 8242F7E0: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 8242F7E4: 4098FFC4  bge cr6, 0x8242f7a8
	if !ctx.cr[6].lt {
	pc = 0x8242F7A8; continue 'dispatch;
	}
	// 8242F7E8: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 8242F7EC: 4BFFFFC0  b 0x8242f7ac
	pc = 0x8242F7AC; continue 'dispatch;
	// 8242F7F0: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 8242F7F4: 4098FFC8  bge cr6, 0x8242f7bc
	if !ctx.cr[6].lt {
	pc = 0x8242F7BC; continue 'dispatch;
	}
	// 8242F7F8: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 8242F7FC: 4BFFFFC4  b 0x8242f7c0
	pc = 0x8242F7C0; continue 'dispatch;
	// 8242F800: FC606890  fmr f3, f13
	ctx.f[3].f64 = ctx.f[13].f64;
	// 8242F804: 807F0170  lwz r3, 0x170(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 8242F808: 48163ED9  bl 0x825936e0
	ctx.lr = 0x8242F80C;
	sub_825936E0(ctx, base);
	// 8242F80C: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 8242F810: 807F0170  lwz r3, 0x170(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 8242F814: C02B64D4  lfs f1, 0x64d4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(25812 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8242F818: 48163F49  bl 0x82593760
	ctx.lr = 0x8242F81C;
	sub_82593760(ctx, base);
	// 8242F81C: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 8242F820: 807F0170  lwz r3, 0x170(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 8242F824: C02B64D8  lfs f1, 0x64d8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(25816 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8242F828: 48163F99  bl 0x825937c0
	ctx.lr = 0x8242F82C;
	sub_825937C0(ctx, base);
	// 8242F82C: 389F0160  addi r4, r31, 0x160
	ctx.r[4].s64 = ctx.r[31].s64 + 352;
	// 8242F830: 807F0170  lwz r3, 0x170(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 8242F834: 48163DED  bl 0x82593620
	ctx.lr = 0x8242F838;
	sub_82593620(ctx, base);
	// 8242F838: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8242F83C: 4BFFE67D  bl 0x8242deb8
	ctx.lr = 0x8242F840;
	sub_8242DEB8(ctx, base);
	// 8242F840: 897F03D4  lbz r11, 0x3d4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(980 as u32) ) } as u64;
	// 8242F844: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8242F848: 4182000C  beq 0x8242f854
	if ctx.cr[0].eq {
	pc = 0x8242F854; continue 'dispatch;
	}
	// 8242F84C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8242F850: 4BFFFCF1  bl 0x8242f540
	ctx.lr = 0x8242F854;
	sub_8242F540(ctx, base);
	// 8242F854: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8242F858: 997F03D4  stb r11, 0x3d4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(980 as u32), ctx.r[11].u8 ) };
	// 8242F85C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8242F860: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 8242F864: 48D79261  bl 0x831a8ac4
	ctx.lr = 0x8242F868;
	sub_831A8A8C(ctx, base);
	// 8242F868: 48D78954  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242F870(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8242F870 size=244
    let mut pc: u32 = 0x8242F870;
    'dispatch: loop {
        match pc {
            0x8242F870 => {
    //   block [0x8242F870..0x8242F964)
	// 8242F870: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8242F874: 48D788F9  bl 0x831a816c
	ctx.lr = 0x8242F878;
	sub_831A8130(ctx, base);
	// 8242F878: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8242F87C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8242F880: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8242F884: 387F03C8  addi r3, r31, 0x3c8
	ctx.r[3].s64 = ctx.r[31].s64 + 968;
	// 8242F888: 396B56F0  addi r11, r11, 0x56f0
	ctx.r[11].s64 = ctx.r[11].s64 + 22256;
	// 8242F88C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8242F890: 4BFFFB01  bl 0x8242f390
	ctx.lr = 0x8242F894;
	sub_8242F390(ctx, base);
	// 8242F894: 3BDF03C8  addi r30, r31, 0x3c8
	ctx.r[30].s64 = ctx.r[31].s64 + 968;
	// 8242F898: 3BA00009  li r29, 9
	ctx.r[29].s64 = 9;
	// 8242F89C: 3BDEFFF4  addi r30, r30, -0xc
	ctx.r[30].s64 = ctx.r[30].s64 + -12;
	// 8242F8A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8242F8A4: 4BFFFAED  bl 0x8242f390
	ctx.lr = 0x8242F8A8;
	sub_8242F390(ctx, base);
	// 8242F8A8: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 8242F8AC: 4080FFF0  bge 0x8242f89c
	if !ctx.cr[0].lt {
	pc = 0x8242F89C; continue 'dispatch;
	}
	// 8242F8B0: 807F034C  lwz r3, 0x34c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(844 as u32) ) } as u64;
	// 8242F8B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8242F8B8: 419A0008  beq cr6, 0x8242f8c0
	if ctx.cr[6].eq {
	pc = 0x8242F8C0; continue 'dispatch;
	}
	// 8242F8BC: 4BE90FD5  bl 0x822c0890
	ctx.lr = 0x8242F8C0;
	sub_822C0890(ctx, base);
	// 8242F8C0: 807F0344  lwz r3, 0x344(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(836 as u32) ) } as u64;
	// 8242F8C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8242F8C8: 419A0008  beq cr6, 0x8242f8d0
	if ctx.cr[6].eq {
	pc = 0x8242F8D0; continue 'dispatch;
	}
	// 8242F8CC: 4BE90FC5  bl 0x822c0890
	ctx.lr = 0x8242F8D0;
	sub_822C0890(ctx, base);
	// 8242F8D0: 807F033C  lwz r3, 0x33c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(828 as u32) ) } as u64;
	// 8242F8D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8242F8D8: 419A0008  beq cr6, 0x8242f8e0
	if ctx.cr[6].eq {
	pc = 0x8242F8E0; continue 'dispatch;
	}
	// 8242F8DC: 4BE90FB5  bl 0x822c0890
	ctx.lr = 0x8242F8E0;
	sub_822C0890(ctx, base);
	// 8242F8E0: 807F0334  lwz r3, 0x334(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(820 as u32) ) } as u64;
	// 8242F8E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8242F8E8: 419A0008  beq cr6, 0x8242f8f0
	if ctx.cr[6].eq {
	pc = 0x8242F8F0; continue 'dispatch;
	}
	// 8242F8EC: 4BE90FA5  bl 0x822c0890
	ctx.lr = 0x8242F8F0;
	sub_822C0890(ctx, base);
	// 8242F8F0: 807F0318  lwz r3, 0x318(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(792 as u32) ) } as u64;
	// 8242F8F4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8242F8F8: 419A0008  beq cr6, 0x8242f900
	if ctx.cr[6].eq {
	pc = 0x8242F900; continue 'dispatch;
	}
	// 8242F8FC: 4BE90F95  bl 0x822c0890
	ctx.lr = 0x8242F900;
	sub_822C0890(ctx, base);
	// 8242F900: 807F0310  lwz r3, 0x310(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(784 as u32) ) } as u64;
	// 8242F904: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8242F908: 419A0008  beq cr6, 0x8242f910
	if ctx.cr[6].eq {
	pc = 0x8242F910; continue 'dispatch;
	}
	// 8242F90C: 4BE90F85  bl 0x822c0890
	ctx.lr = 0x8242F910;
	sub_822C0890(ctx, base);
	// 8242F910: 397F030C  addi r11, r31, 0x30c
	ctx.r[11].s64 = ctx.r[31].s64 + 780;
	// 8242F914: 3BA00031  li r29, 0x31
	ctx.r[29].s64 = 49;
	// 8242F918: 3BCB0004  addi r30, r11, 4
	ctx.r[30].s64 = ctx.r[11].s64 + 4;
	// 8242F91C: 3BDEFFF8  addi r30, r30, -8
	ctx.r[30].s64 = ctx.r[30].s64 + -8;
	// 8242F920: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242F924: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8242F928: 419A0008  beq cr6, 0x8242f930
	if ctx.cr[6].eq {
	pc = 0x8242F930; continue 'dispatch;
	}
	// 8242F92C: 4BE90F65  bl 0x822c0890
	ctx.lr = 0x8242F930;
	sub_822C0890(ctx, base);
	// 8242F930: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 8242F934: 4080FFE8  bge 0x8242f91c
	if !ctx.cr[0].lt {
	pc = 0x8242F91C; continue 'dispatch;
	}
	// 8242F938: 807F0170  lwz r3, 0x170(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 8242F93C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8242F940: 419A0008  beq cr6, 0x8242f948
	if ctx.cr[6].eq {
	pc = 0x8242F948; continue 'dispatch;
	}
	// 8242F944: 4816424D  bl 0x82593b90
	ctx.lr = 0x8242F948;
	sub_82593B90(ctx, base);
	// 8242F948: 387F0148  addi r3, r31, 0x148
	ctx.r[3].s64 = ctx.r[31].s64 + 328;
	// 8242F94C: 489C3ADD  bl 0x82df3428
	ctx.lr = 0x8242F950;
	sub_82DF3428(ctx, base);
	// 8242F950: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8242F954: 396B55C8  addi r11, r11, 0x55c8
	ctx.r[11].s64 = ctx.r[11].s64 + 21960;
	// 8242F958: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8242F95C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8242F960: 48D7885C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242F968(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8242F968 size=304
    let mut pc: u32 = 0x8242F968;
    'dispatch: loop {
        match pc {
            0x8242F968 => {
    //   block [0x8242F968..0x8242FA98)
	// 8242F968: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8242F96C: 48D787FD  bl 0x831a8168
	ctx.lr = 0x8242F970;
	sub_831A8130(ctx, base);
	// 8242F970: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8242F974: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8242F978: 4BFFD199  bl 0x8242cb10
	ctx.lr = 0x8242F97C;
	sub_8242CB10(ctx, base);
	// 8242F97C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8242F980: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 8242F984: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8242F988: 394A56F0  addi r10, r10, 0x56f0
	ctx.r[10].s64 = ctx.r[10].s64 + 22256;
	// 8242F98C: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 8242F990: 387F0148  addi r3, r31, 0x148
	ctx.r[3].s64 = ctx.r[31].s64 + 328;
	// 8242F994: C00BC664  lfs f0, -0x399c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-14748 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8242F998: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8242F99C: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 8242F9A0: 93DF0130  stw r30, 0x130(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), ctx.r[30].u32 ) };
	// 8242F9A4: 93DF0138  stw r30, 0x138(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(312 as u32), ctx.r[30].u32 ) };
	// 8242F9A8: 9BDF013C  stb r30, 0x13c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(316 as u32), ctx.r[30].u8 ) };
	// 8242F9AC: 489C3745  bl 0x82df30f0
	ctx.lr = 0x8242F9B0;
	sub_82DF30F0(ctx, base);
	// 8242F9B0: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 8242F9B4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8242F9B8: 3B8B6910  addi r28, r11, 0x6910
	ctx.r[28].s64 = ctx.r[11].s64 + 26896;
	// 8242F9BC: 39200160  li r9, 0x160
	ctx.r[9].s64 = 352;
	// 8242F9C0: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 8242F9C4: 397F017C  addi r11, r31, 0x17c
	ctx.r[11].s64 = ctx.r[31].s64 + 380;
	// 8242F9C8: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8242F9CC: 911F0158  stw r8, 0x158(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(344 as u32), ctx.r[8].u32 ) };
	// 8242F9D0: D01F014C  stfs f0, 0x14c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(332 as u32), tmp.u32 ) };
	// 8242F9D4: 39400031  li r10, 0x31
	ctx.r[10].s64 = 49;
	// 8242F9D8: D01F0150  stfs f0, 0x150(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), tmp.u32 ) };
	// 8242F9DC: D01F0154  stfs f0, 0x154(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(340 as u32), tmp.u32 ) };
	// 8242F9E0: 13E0E0C7  vcmpequd (lvx128) v31, v0, v28
	tmp.u32 = ctx.r[28].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242FA98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8242FA98 size=76
    let mut pc: u32 = 0x8242FA98;
    'dispatch: loop {
        match pc {
            0x8242FA98 => {
    //   block [0x8242FA98..0x8242FAE4)
	// 8242FA98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8242FA9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8242FAA0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8242FAA4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8242FAA8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8242FAAC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8242FAB0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8242FAB4: 4BFFFDBD  bl 0x8242f870
	ctx.lr = 0x8242FAB8;
	sub_8242F870(ctx, base);
	// 8242FAB8: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8242FABC: 4182000C  beq 0x8242fac8
	if ctx.cr[0].eq {
	pc = 0x8242FAC8; continue 'dispatch;
	}
	// 8242FAC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8242FAC4: 489C2915  bl 0x82df23d8
	ctx.lr = 0x8242FAC8;
	sub_82DF23D8(ctx, base);
	// 8242FAC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8242FACC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8242FAD0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8242FAD4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8242FAD8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8242FADC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8242FAE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8242FAE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8242FAE8 size=1780
    let mut pc: u32 = 0x8242FAE8;
    'dispatch: loop {
        match pc {
            0x8242FAE8 => {
    //   block [0x8242FAE8..0x824301DC)
	// 8242FAE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8242FAEC: 48D78651  bl 0x831a813c
	ctx.lr = 0x8242FAF0;
	sub_831A8130(ctx, base);
	// 8242FAF0: DBC1FF70  stfd f30, -0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.f[30].u64 ) };
	// 8242FAF4: DBE1FF78  stfd f31, -0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.f[31].u64 ) };
	// 8242FAF8: 9421FE80  stwu r1, -0x180(r1)
	ea = ctx.r[1].u32.wrapping_add(-384 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8242FAFC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 8242FB00: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 8242FB04: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 8242FB08: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 8242FB0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8242FB10: 808B6774  lwz r4, 0x6774(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26484 as u32) ) } as u64;
	// 8242FB14: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8242FB18: 93C1008C  stw r30, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[30].u32 ) };
	// 8242FB1C: 7CB12B78  mr r17, r5
	ctx.r[17].u64 = ctx.r[5].u64;
	// 8242FB20: 4BEB5411  bl 0x822e4f30
	ctx.lr = 0x8242FB24;
	sub_822E4F30(ctx, base);
	// 8242FB24: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8242FB28: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 8242FB2C: 4BEB5395  bl 0x822e4ec0
	ctx.lr = 0x8242FB30;
	sub_822E4EC0(ctx, base);
	// 8242FB30: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8242FB34: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8242FB38: E89D0000  ld r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	// 8242FB3C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8242FB40: E8630000  ld r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 8242FB44: 4805C745  bl 0x8248c288
	ctx.lr = 0x8242FB48;
	sub_8248C288(ctx, base);
	// 8242FB48: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8242FB4C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8242FB50: 3A8B5688  addi r20, r11, 0x5688
	ctx.r[20].s64 = ctx.r[11].s64 + 22152;
	// 8242FB54: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8242FB58: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 8242FB5C: 38A0005F  li r5, 0x5f
	ctx.r[5].s64 = 95;
	// 8242FB60: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 8242FB64: 4BE90875  bl 0x822c03d8
	ctx.lr = 0x8242FB68;
	sub_822C03D8(ctx, base);
	// 8242FB68: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 8242FB6C: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 8242FB70: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 8242FB74: 3AA00020  li r21, 0x20
	ctx.r[21].s64 = 32;
	// 8242FB78: 3AEB6910  addi r23, r11, 0x6910
	ctx.r[23].s64 = ctx.r[11].s64 + 26896;
	// 8242FB7C: 3ACABA80  addi r22, r10, -0x4580
	ctx.r[22].s64 = ctx.r[10].s64 + -17792;
	// 8242FB80: 41820058  beq 0x8242fbd8
	if ctx.cr[0].eq {
	pc = 0x8242FBD8; continue 'dispatch;
	}
	// 8242FB84: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242FB88: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 8242FB8C: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 8242FB90: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 8242FB94: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8242FB98: 48A70B99  bl 0x82ea0730
	ctx.lr = 0x8242FB9C;
	sub_82EA0730(ctx, base);
	// 8242FB9C: B2A30004  sth r21, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[21].u16 ) };
	// 8242FBA0: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 8242FBA4: C02B7BC4  lfs f1, 0x7bc4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31684 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8242FBA8: 48AEA649  bl 0x82f1a1f0
	ctx.lr = 0x8242FBAC;
	sub_82F1A1F0(ctx, base);
	// 8242FBAC: 90610070  stw r3, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[3].u32 ) };
	// 8242FBB0: 7EC7B378  mr r7, r22
	ctx.r[7].u64 = ctx.r[22].u64;
	// 8242FBB4: 7EE6BB78  mr r6, r23
	ctx.r[6].u64 = ctx.r[23].u64;
	// 8242FBB8: 7F68DB78  mr r8, r27
	ctx.r[8].u64 = ctx.r[27].u64;
	// 8242FBBC: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 8242FBC0: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 8242FBC4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8242FBC8: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 8242FBCC: 480625D5  bl 0x824921a0
	ctx.lr = 0x8242FBD0;
	sub_824921A0(ctx, base);
	// 8242FBD0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8242FBD4: 48000008  b 0x8242fbdc
	pc = 0x8242FBDC; continue 'dispatch;
	// 8242FBD8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8242FBDC: 387F030C  addi r3, r31, 0x30c
	ctx.r[3].s64 = ctx.r[31].s64 + 780;
	// 8242FBE0: 4BEB5209  bl 0x822e4de8
	ctx.lr = 0x8242FBE4;
	sub_822E4DE8(ctx, base);
	// 8242FBE4: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8242FBE8: 41820018  beq 0x8242fc00
	if ctx.cr[0].eq {
	pc = 0x8242FC00; continue 'dispatch;
	}
	// 8242FBEC: 80610070  lwz r3, 0x70(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 8242FBF0: 57DE003C  rlwinm r30, r30, 0, 0, 0x1e
	ctx.r[30].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 8242FBF4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8242FBF8: 419A0008  beq cr6, 0x8242fc00
	if ctx.cr[6].eq {
	pc = 0x8242FC00; continue 'dispatch;
	}
	// 8242FBFC: 4BEB866D  bl 0x822e8268
	ctx.lr = 0x8242FC00;
	sub_822E8268(ctx, base);
	// 8242FC00: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 8242FC04: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 8242FC08: 3D208335  lis r9, -0x7ccb
	ctx.r[9].s64 = -2093678592;
	// 8242FC0C: 3E608335  lis r19, -0x7ccb
	ctx.r[19].s64 = -2093678592;
	// 8242FC10: 3E408335  lis r18, -0x7ccb
	ctx.r[18].s64 = -2093678592;
	// 8242FC14: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 8242FC18: 810B6888  lwz r8, 0x6888(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26760 as u32) ) } as u64;
	// 8242FC1C: 80EA67C4  lwz r7, 0x67c4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(26564 as u32) ) } as u64;
	// 8242FC20: 80C9683C  lwz r6, 0x683c(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(26684 as u32) ) } as u64;
	// 8242FC24: 80B36838  lwz r5, 0x6838(r19)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(26680 as u32) ) } as u64;
	// 8242FC28: 809267D4  lwz r4, 0x67d4(r18)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(26580 as u32) ) } as u64;
	// 8242FC2C: 4BF803E5  bl 0x823b0010
	ctx.lr = 0x8242FC30;
	sub_823B0010(ctx, base);
	// 8242FC30: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8242FC34: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8242FC38: 4BEB5289  bl 0x822e4ec0
	ctx.lr = 0x8242FC3C;
	sub_822E4EC0(ctx, base);
	// 8242FC3C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8242FC40: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8242FC44: E89D0000  ld r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	// 8242FC48: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8242FC4C: E8630000  ld r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 8242FC50: 4805C639  bl 0x8248c288
	ctx.lr = 0x8242FC54;
	sub_8248C288(ctx, base);
	// 8242FC54: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8242FC58: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 8242FC5C: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 8242FC60: 3B3F017C  addi r25, r31, 0x17c
	ctx.r[25].s64 = ctx.r[31].s64 + 380;
	// 8242FC64: C3EB964C  lfs f31, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8242FC68: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 8242FC6C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8242FC70: 38A00069  li r5, 0x69
	ctx.r[5].s64 = 105;
	// 8242FC74: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 8242FC78: 4BE90761  bl 0x822c03d8
	ctx.lr = 0x8242FC7C;
	sub_822C03D8(ctx, base);
	// 8242FC7C: 7C7B1B79  or. r27, r3, r3
	ctx.r[27].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 8242FC80: 4182006C  beq 0x8242fcec
	if ctx.cr[0].eq {
	pc = 0x8242FCEC; continue 'dispatch;
	}
	// 8242FC84: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242FC88: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 8242FC8C: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 8242FC90: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 8242FC94: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8242FC98: 48A70A99  bl 0x82ea0730
	ctx.lr = 0x8242FC9C;
	sub_82EA0730(ctx, base);
	// 8242FC9C: 397D0001  addi r11, r29, 1
	ctx.r[11].s64 = ctx.r[29].s64 + 1;
	// 8242FCA0: B2A30004  sth r21, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[21].u16 ) };
	// 8242FCA4: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 8242FCA8: F9610080  std r11, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u64 ) };
	// 8242FCAC: C8010080  lfd f0, 0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 8242FCB0: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 8242FCB4: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8242FCB8: EC2007F2  fmuls f1, f0, f31
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 8242FCBC: 48AEA535  bl 0x82f1a1f0
	ctx.lr = 0x8242FCC0;
	sub_82F1A1F0(ctx, base);
	// 8242FCC0: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 8242FCC4: 7EC7B378  mr r7, r22
	ctx.r[7].u64 = ctx.r[22].u64;
	// 8242FCC8: 7EE6BB78  mr r6, r23
	ctx.r[6].u64 = ctx.r[23].u64;
	// 8242FCCC: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 8242FCD0: 38A10074  addi r5, r1, 0x74
	ctx.r[5].s64 = ctx.r[1].s64 + 116;
	// 8242FCD4: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 8242FCD8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8242FCDC: 63DE0002  ori r30, r30, 2
	ctx.r[30].u64 = ctx.r[30].u64 | 2;
	// 8242FCE0: 480624C1  bl 0x824921a0
	ctx.lr = 0x8242FCE4;
	sub_824921A0(ctx, base);
	// 8242FCE4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8242FCE8: 48000008  b 0x8242fcf0
	pc = 0x8242FCF0; continue 'dispatch;
	// 8242FCEC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8242FCF0: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 8242FCF4: 4BEB50F5  bl 0x822e4de8
	ctx.lr = 0x8242FCF8;
	sub_822E4DE8(ctx, base);
	// 8242FCF8: 57CB07BD  rlwinm. r11, r30, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8242FCFC: 41820018  beq 0x8242fd14
	if ctx.cr[0].eq {
	pc = 0x8242FD14; continue 'dispatch;
	}
	// 8242FD00: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 8242FD04: 57DE07FA  rlwinm r30, r30, 0, 0x1f, 0x1d
	ctx.r[30].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 8242FD08: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8242FD0C: 419A0008  beq cr6, 0x8242fd14
	if ctx.cr[6].eq {
	pc = 0x8242FD14; continue 'dispatch;
	}
	// 8242FD10: 4BEB8559  bl 0x822e8268
	ctx.lr = 0x8242FD14;
	sub_822E8268(ctx, base);
	// 8242FD14: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 8242FD18: 3B390008  addi r25, r25, 8
	ctx.r[25].s64 = ctx.r[25].s64 + 8;
	// 8242FD1C: 2F1D0032  cmpwi cr6, r29, 0x32
	ctx.cr[6].compare_i32(ctx.r[29].s32, 50, &mut ctx.xer);
	// 8242FD20: 4198FF48  blt cr6, 0x8242fc68
	if ctx.cr[6].lt {
	pc = 0x8242FC68; continue 'dispatch;
	}
	// 8242FD24: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 8242FD28: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8242FD2C: 38A0006C  li r5, 0x6c
	ctx.r[5].s64 = 108;
	// 8242FD30: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 8242FD34: 4BE906A5  bl 0x822c03d8
	ctx.lr = 0x8242FD38;
	sub_822C03D8(ctx, base);
	// 8242FD38: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 8242FD3C: 4182005C  beq 0x8242fd98
	if ctx.cr[0].eq {
	pc = 0x8242FD98; continue 'dispatch;
	}
	// 8242FD40: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242FD44: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 8242FD48: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 8242FD4C: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 8242FD50: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8242FD54: 48A709DD  bl 0x82ea0730
	ctx.lr = 0x8242FD58;
	sub_82EA0730(ctx, base);
	// 8242FD58: B2A30004  sth r21, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[21].u16 ) };
	// 8242FD5C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8242FD60: C02B0A90  lfs f1, 0xa90(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2704 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8242FD64: 48AEA48D  bl 0x82f1a1f0
	ctx.lr = 0x8242FD68;
	sub_82F1A1F0(ctx, base);
	// 8242FD68: 90610078  stw r3, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[3].u32 ) };
	// 8242FD6C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 8242FD70: 7EC7B378  mr r7, r22
	ctx.r[7].u64 = ctx.r[22].u64;
	// 8242FD74: 7EE6BB78  mr r6, r23
	ctx.r[6].u64 = ctx.r[23].u64;
	// 8242FD78: 38A10078  addi r5, r1, 0x78
	ctx.r[5].s64 = ctx.r[1].s64 + 120;
	// 8242FD7C: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 8242FD80: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8242FD84: 810B671C  lwz r8, 0x671c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26396 as u32) ) } as u64;
	// 8242FD88: 63DE0004  ori r30, r30, 4
	ctx.r[30].u64 = ctx.r[30].u64 | 4;
	// 8242FD8C: 48062415  bl 0x824921a0
	ctx.lr = 0x8242FD90;
	sub_824921A0(ctx, base);
	// 8242FD90: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8242FD94: 48000008  b 0x8242fd9c
	pc = 0x8242FD9C; continue 'dispatch;
	// 8242FD98: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8242FD9C: 387F0314  addi r3, r31, 0x314
	ctx.r[3].s64 = ctx.r[31].s64 + 788;
	// 8242FDA0: 4BEB5049  bl 0x822e4de8
	ctx.lr = 0x8242FDA4;
	sub_822E4DE8(ctx, base);
	// 8242FDA4: 57CB077B  rlwinm. r11, r30, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8242FDA8: 41820018  beq 0x8242fdc0
	if ctx.cr[0].eq {
	pc = 0x8242FDC0; continue 'dispatch;
	}
	// 8242FDAC: 80610078  lwz r3, 0x78(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 8242FDB0: 57DE07B8  rlwinm r30, r30, 0, 0x1e, 0x1c
	ctx.r[30].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 8242FDB4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8242FDB8: 419A0008  beq cr6, 0x8242fdc0
	if ctx.cr[6].eq {
	pc = 0x8242FDC0; continue 'dispatch;
	}
	// 8242FDBC: 4BEB84AD  bl 0x822e8268
	ctx.lr = 0x8242FDC0;
	sub_822E8268(ctx, base);
	// 8242FDC0: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8242FDC4: 4BED5625  bl 0x823053e8
	ctx.lr = 0x8242FDC8;
	sub_823053E8(ctx, base);
	// 8242FDC8: 4877CA41  bl 0x82bac808
	ctx.lr = 0x8242FDCC;
	sub_82BAC808(ctx, base);
	// 8242FDCC: 483BA49D  bl 0x827ea268
	ctx.lr = 0x8242FDD0;
	sub_827EA268(ctx, base);
	// 8242FDD0: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8242FDD4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8242FDD8: 388BF818  addi r4, r11, -0x7e8
	ctx.r[4].s64 = ctx.r[11].s64 + -2024;
	// 8242FDDC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8242FDE0: 48B7CF31  bl 0x82facd10
	ctx.lr = 0x8242FDE4;
	sub_82FACD10(ctx, base);
	// 8242FDE4: B07F0010  sth r3, 0x10(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[3].u16 ) };
	// 8242FDE8: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8242FDEC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8242FDF0: 388BF820  addi r4, r11, -0x7e0
	ctx.r[4].s64 = ctx.r[11].s64 + -2016;
	// 8242FDF4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8242FDF8: 48B7CF19  bl 0x82facd10
	ctx.lr = 0x8242FDFC;
	sub_82FACD10(ctx, base);
	// 8242FDFC: B07F0018  sth r3, 0x18(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[3].u16 ) };
	// 8242FE00: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8242FE04: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8242FE08: 388B5734  addi r4, r11, 0x5734
	ctx.r[4].s64 = ctx.r[11].s64 + 22324;
	// 8242FE0C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8242FE10: 48B7CF01  bl 0x82facd10
	ctx.lr = 0x8242FE14;
	sub_82FACD10(ctx, base);
	// 8242FE14: B07F0012  sth r3, 0x12(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(18 as u32), ctx.r[3].u16 ) };
	// 8242FE18: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8242FE1C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8242FE20: 388B572C  addi r4, r11, 0x572c
	ctx.r[4].s64 = ctx.r[11].s64 + 22316;
	// 8242FE24: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8242FE28: 48B7CEE9  bl 0x82facd10
	ctx.lr = 0x8242FE2C;
	sub_82FACD10(ctx, base);
	// 8242FE2C: B07F001A  sth r3, 0x1a(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(26 as u32), ctx.r[3].u16 ) };
	// 8242FE30: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8242FE34: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8242FE38: 388B5724  addi r4, r11, 0x5724
	ctx.r[4].s64 = ctx.r[11].s64 + 22308;
	// 8242FE3C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8242FE40: 48B7CED1  bl 0x82facd10
	ctx.lr = 0x8242FE44;
	sub_82FACD10(ctx, base);
	// 8242FE44: B07F0014  sth r3, 0x14(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[3].u16 ) };
	// 8242FE48: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8242FE4C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8242FE50: 388B571C  addi r4, r11, 0x571c
	ctx.r[4].s64 = ctx.r[11].s64 + 22300;
	// 8242FE54: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8242FE58: 48B7CEB9  bl 0x82facd10
	ctx.lr = 0x8242FE5C;
	sub_82FACD10(ctx, base);
	// 8242FE5C: B07F001C  sth r3, 0x1c(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[3].u16 ) };
	// 8242FE60: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8242FE64: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8242FE68: 388B5714  addi r4, r11, 0x5714
	ctx.r[4].s64 = ctx.r[11].s64 + 22292;
	// 8242FE6C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8242FE70: 48B7CEA1  bl 0x82facd10
	ctx.lr = 0x8242FE74;
	sub_82FACD10(ctx, base);
	// 8242FE74: B07F0016  sth r3, 0x16(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(22 as u32), ctx.r[3].u16 ) };
	// 8242FE78: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8242FE7C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8242FE80: 388B570C  addi r4, r11, 0x570c
	ctx.r[4].s64 = ctx.r[11].s64 + 22284;
	// 8242FE84: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8242FE88: 48B7CE89  bl 0x82facd10
	ctx.lr = 0x8242FE8C;
	sub_82FACD10(ctx, base);
	// 8242FE8C: B07F001E  sth r3, 0x1e(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(30 as u32), ctx.r[3].u16 ) };
	// 8242FE90: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8242FE94: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8242FE98: 388B5D34  addi r4, r11, 0x5d34
	ctx.r[4].s64 = ctx.r[11].s64 + 23860;
	// 8242FE9C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8242FEA0: 48B7CE71  bl 0x82facd10
	ctx.lr = 0x8242FEA4;
	sub_82FACD10(ctx, base);
	// 8242FEA4: B07F0020  sth r3, 0x20(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[3].u16 ) };
	// 8242FEA8: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8242FEAC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8242FEB0: 388B5704  addi r4, r11, 0x5704
	ctx.r[4].s64 = ctx.r[11].s64 + 22276;
	// 8242FEB4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8242FEB8: 48B7CE59  bl 0x82facd10
	ctx.lr = 0x8242FEBC;
	sub_82FACD10(ctx, base);
	// 8242FEBC: B07F0022  sth r3, 0x22(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(34 as u32), ctx.r[3].u16 ) };
	// 8242FEC0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8242FEC4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8242FEC8: 388BC604  addi r4, r11, -0x39fc
	ctx.r[4].s64 = ctx.r[11].s64 + -14844;
	// 8242FECC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8242FED0: 48B7CE41  bl 0x82facd10
	ctx.lr = 0x8242FED4;
	sub_82FACD10(ctx, base);
	// 8242FED4: B07F0024  sth r3, 0x24(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[3].u16 ) };
	// 8242FED8: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8242FEDC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8242FEE0: 388B56FC  addi r4, r11, 0x56fc
	ctx.r[4].s64 = ctx.r[11].s64 + 22268;
	// 8242FEE4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8242FEE8: 48B7CE29  bl 0x82facd10
	ctx.lr = 0x8242FEEC;
	sub_82FACD10(ctx, base);
	// 8242FEEC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8242FEF0: B07F0026  sth r3, 0x26(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(38 as u32), ctx.r[3].u16 ) };
	// 8242FEF4: 397F0320  addi r11, r31, 0x320
	ctx.r[11].s64 = ctx.r[31].s64 + 800;
	// 8242FEF8: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 8242FEFC: C08A08A8  lfs f4, 0x8a8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 8242FF00: D09F032C  stfs f4, 0x32c(r31)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(812 as u32), tmp.u32 ) };
	// 8242FF04: C0A96150  lfs f5, 0x6150(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(24912 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 8242FF08: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 8242FF0C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 8242FF10: FC202090  fmr f1, f4
	ctx.f[1].f64 = ctx.f[4].f64;
	// 8242FF14: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 8242FF18: FC402890  fmr f2, f5
	ctx.f[2].f64 = ctx.f[5].f64;
	// 8242FF1C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8242FF20: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 8242FF24: 389F0340  addi r4, r31, 0x340
	ctx.r[4].s64 = ctx.r[31].s64 + 832;
	// 8242FF28: 38BF0348  addi r5, r31, 0x348
	ctx.r[5].s64 = ctx.r[31].s64 + 840;
	// 8242FF2C: C3E908A4  lfs f31, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8242FF30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8242FF34: C0EAA2EC  lfs f7, -0x5d14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-23828 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 8242FF38: C0CB0944  lfs f6, 0x944(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2372 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 8242FF3C: C068A1C4  lfs f3, -0x5e3c(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 8242FF40: D3FF0320  stfs f31, 0x320(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(800 as u32), tmp.u32 ) };
	// 8242FF44: D3FF0324  stfs f31, 0x324(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(804 as u32), tmp.u32 ) };
	// 8242FF48: D3FF0328  stfs f31, 0x328(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(808 as u32), tmp.u32 ) };
	// 8242FF4C: 4BFFD1FD  bl 0x8242d148
	ctx.lr = 0x8242FF50;
	sub_8242D148(ctx, base);
	// 8242FF50: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 8242FF54: 938100B0  stw r28, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[28].u32 ) };
	// 8242FF58: 39400008  li r10, 8
	ctx.r[10].s64 = 8;
	// 8242FF5C: 938100B4  stw r28, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[28].u32 ) };
	// 8242FF60: 916100B8  stw r11, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[11].u32 ) };
	// 8242FF64: 3BA00010  li r29, 0x10
	ctx.r[29].s64 = 16;
	// 8242FF68: 916100D8  stw r11, 0xd8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[11].u32 ) };
	// 8242FF6C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 8242FF70: 916100E4  stw r11, 0xe4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 8242FF74: 38A100B0  addi r5, r1, 0xb0
	ctx.r[5].s64 = ctx.r[1].s64 + 176;
	// 8242FF78: 938100D0  stw r28, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[28].u32 ) };
	// 8242FF7C: 388100D0  addi r4, r1, 0xd0
	ctx.r[4].s64 = ctx.r[1].s64 + 208;
	// 8242FF80: 938100D4  stw r28, 0xd4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), ctx.r[28].u32 ) };
	// 8242FF84: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 8242FF88: 938100DC  stw r28, 0xdc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), ctx.r[28].u32 ) };
	// 8242FF8C: 938100E0  stw r28, 0xe0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[28].u32 ) };
	// 8242FF90: 914100A4  stw r10, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[10].u32 ) };
	// 8242FF94: 93A100A8  stw r29, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[29].u32 ) };
	// 8242FF98: 93810080  stw r28, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[28].u32 ) };
	// 8242FF9C: 817F0340  lwz r11, 0x340(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(832 as u32) ) } as u64;
	// 8242FFA0: 916100A0  stw r11, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 8242FFA4: 48B2FC75  bl 0x82f5fc18
	ctx.lr = 0x8242FFA8;
	sub_82F5FC18(ctx, base);
	// 8242FFA8: 816100D4  lwz r11, 0xd4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 8242FFAC: 814100D0  lwz r10, 0xd0(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(208 as u32) ) } as u64;
	// 8242FFB0: 3B400014  li r26, 0x14
	ctx.r[26].s64 = 20;
	// 8242FFB4: 93A100A8  stw r29, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[29].u32 ) };
	// 8242FFB8: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 8242FFBC: 836D0000  lwz r27, 0(r13)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 8242FFC0: 38800060  li r4, 0x60
	ctx.r[4].s64 = 96;
	// 8242FFC4: 916100A4  stw r11, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 8242FFC8: 914100A0  stw r10, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[10].u32 ) };
	// 8242FFCC: 7C7AD82E  lwzx r3, r26, r27
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 8242FFD0: 48A70761  bl 0x82ea0730
	ctx.lr = 0x8242FFD4;
	sub_82EA0730(ctx, base);
	// 8242FFD4: 39600060  li r11, 0x60
	ctx.r[11].s64 = 96;
	// 8242FFD8: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 8242FFDC: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 8242FFE0: 38A100B0  addi r5, r1, 0xb0
	ctx.r[5].s64 = ctx.r[1].s64 + 176;
	// 8242FFE4: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 8242FFE8: C02AF614  lfs f1, -0x9ec(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-2540 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8242FFEC: 48AEB895  bl 0x82f1b880
	ctx.lr = 0x8242FFF0;
	sub_82F1B880(ctx, base);
	// 8242FFF0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8242FFF4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8242FFF8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8242FFFC: 4BF764BD  bl 0x823a64b8
	ctx.lr = 0x82430000;
	sub_823A64B8(ctx, base);
	// 82430000: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 82430004: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82430008: 38A000A1  li r5, 0xa1
	ctx.r[5].s64 = 161;
	// 8243000C: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 82430010: 4BE903C9  bl 0x822c03d8
	ctx.lr = 0x82430014;
	sub_822C03D8(ctx, base);
	// 82430014: 83210080  lwz r25, 0x80(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82430018: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 8243001C: 41820074  beq 0x82430090
	if ctx.cr[0].eq {
	pc = 0x82430090; continue 'dispatch;
	}
	// 82430020: 93210088  stw r25, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[25].u32 ) };
	// 82430024: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 82430028: 419A000C  beq cr6, 0x82430034
	if ctx.cr[6].eq {
	pc = 0x82430034; continue 'dispatch;
	}
	// 8243002C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82430030: 4BEB8219  bl 0x822e8248
	ctx.lr = 0x82430034;
	sub_822E8248(ctx, base);
	// 82430034: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82430038: 80B36838  lwz r5, 0x6838(r19)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(26680 as u32) ) } as u64;
	// 8243003C: 809267D4  lwz r4, 0x67d4(r18)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(26580 as u32) ) } as u64;
	// 82430040: 63DE0008  ori r30, r30, 8
	ctx.r[30].u64 = ctx.r[30].u64 | 8;
	// 82430044: 4BEC775D  bl 0x822f77a0
	ctx.lr = 0x82430048;
	sub_822F77A0(ctx, base);
	// 82430048: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8243004C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82430050: 4BEB4E71  bl 0x822e4ec0
	ctx.lr = 0x82430054;
	sub_822E4EC0(ctx, base);
	// 82430054: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82430058: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8243005C: E89C0000  ld r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	// 82430060: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82430064: E8630000  ld r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 82430068: 4805C221  bl 0x8248c288
	ctx.lr = 0x8243006C;
	sub_8248C288(ctx, base);
	// 8243006C: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 82430070: 7EC7B378  mr r7, r22
	ctx.r[7].u64 = ctx.r[22].u64;
	// 82430074: 7EE6BB78  mr r6, r23
	ctx.r[6].u64 = ctx.r[23].u64;
	// 82430078: 38A10088  addi r5, r1, 0x88
	ctx.r[5].s64 = ctx.r[1].s64 + 136;
	// 8243007C: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82430080: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82430084: 4806211D  bl 0x824921a0
	ctx.lr = 0x82430088;
	sub_824921A0(ctx, base);
	// 82430088: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8243008C: 48000008  b 0x82430094
	pc = 0x82430094; continue 'dispatch;
	// 82430090: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82430094: 387F0330  addi r3, r31, 0x330
	ctx.r[3].s64 = ctx.r[31].s64 + 816;
	// 82430098: 4BEB4D51  bl 0x822e4de8
	ctx.lr = 0x8243009C;
	sub_822E4DE8(ctx, base);
	// 8243009C: 57CB0739  rlwinm. r11, r30, 0, 0x1c, 0x1c
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824300A0: 41820014  beq 0x824300b4
	if ctx.cr[0].eq {
	pc = 0x824300B4; continue 'dispatch;
	}
	// 824300A4: 80610088  lwz r3, 0x88(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 824300A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 824300AC: 419A0008  beq cr6, 0x824300b4
	if ctx.cr[6].eq {
	pc = 0x824300B4; continue 'dispatch;
	}
	// 824300B0: 4BEB81B9  bl 0x822e8268
	ctx.lr = 0x824300B4;
	sub_822E8268(ctx, base);
	// 824300B4: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 824300B8: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 824300BC: 808B6750  lwz r4, 0x6750(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26448 as u32) ) } as u64;
	// 824300C0: 4BEB4E71  bl 0x822e4f30
	ctx.lr = 0x824300C4;
	sub_822E4F30(ctx, base);
	// 824300C4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 824300C8: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 824300CC: 4BEB4DF5  bl 0x822e4ec0
	ctx.lr = 0x824300D0;
	sub_822E4EC0(ctx, base);
	// 824300D0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 824300D4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 824300D8: E89E0000  ld r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 824300DC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 824300E0: E8630000  ld r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 824300E4: 4805C1A5  bl 0x8248c288
	ctx.lr = 0x824300E8;
	sub_8248C288(ctx, base);
	// 824300E8: 907F015C  stw r3, 0x15c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(348 as u32), ctx.r[3].u32 ) };
	// 824300EC: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 824300F0: 4BEB65B1  bl 0x822e66a0
	ctx.lr = 0x824300F4;
	sub_822E66A0(ctx, base);
	// 824300F4: 816100B8  lwz r11, 0xb8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) } as u64;
	// 824300F8: 556A0001  rlwinm. r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824300FC: 40820018  bne 0x82430114
	if !ctx.cr[0].eq {
	pc = 0x82430114; continue 'dispatch;
	}
	// 82430100: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 82430104: 7C7AD82E  lwzx r3, r26, r27
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 82430108: 55652036  slwi r5, r11, 4
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 8243010C: 808100B0  lwz r4, 0xb0(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 82430110: 48A706A1  bl 0x82ea07b0
	ctx.lr = 0x82430114;
	sub_82EA07B0(ctx, base);
	// 82430114: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 82430118: 419A000C  beq cr6, 0x82430124
	if ctx.cr[6].eq {
	pc = 0x82430124; continue 'dispatch;
	}
	// 8243011C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82430120: 4BEB8149  bl 0x822e8268
	ctx.lr = 0x82430124;
	sub_822E8268(ctx, base);
	// 82430124: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82430128: D3E100CC  stfs f31, 0xcc(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 8243012C: 3D408326  lis r10, -0x7cda
	ctx.r[10].s64 = -2094661632;
	// 82430130: 3D208326  lis r9, -0x7cda
	ctx.r[9].s64 = -2094661632;
	// 82430134: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 82430138: C00B64C4  lfs f0, 0x64c4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(25796 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8243013C: C1AA64C8  lfs f13, 0x64c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25800 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82430140: C18964CC  lfs f12, 0x64cc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(25804 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82430144: D00100C0  stfs f0, 0xc0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 82430148: D1A100C4  stfs f13, 0xc4(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 8243014C: D18100C8  stfs f12, 0xc8(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82430150: 480D83E9  bl 0x82508538
	ctx.lr = 0x82430154;
	sub_82508538(ctx, base);
	// 82430154: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82430158: 3D408326  lis r10, -0x7cda
	ctx.r[10].s64 = -2094661632;
	// 8243015C: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82430160: 3D208326  lis r9, -0x7cda
	ctx.r[9].s64 = -2094661632;
	// 82430164: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82430168: 3BFF0170  addi r31, r31, 0x170
	ctx.r[31].s64 = ctx.r[31].s64 + 368;
	// 8243016C: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82430170: 3BA100C0  addi r29, r1, 0xc0
	ctx.r[29].s64 = ctx.r[1].s64 + 192;
	// 82430174: C3EA64D8  lfs f31, 0x64d8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25816 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82430178: C3C964D4  lfs f30, 0x64d4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(25812 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8243017C: 4BED58F5  bl 0x82305a70
	ctx.lr = 0x82430180;
	sub_82305A70(ctx, base);
	// 82430180: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82430184: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82430188: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8243018C: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82430190: 3861008C  addi r3, r1, 0x8c
	ctx.r[3].s64 = ctx.r[1].s64 + 140;
	// 82430194: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82430198: 48162F71  bl 0x82593108
	ctx.lr = 0x8243019C;
	sub_82593108(ctx, base);
	// 8243019C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 824301A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824301A4: 4BFFD745  bl 0x8242d8e8
	ctx.lr = 0x824301A8;
	sub_8242D8E8(ctx, base);
	// 824301A8: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 824301AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 824301B0: 419A0008  beq cr6, 0x824301b8
	if ctx.cr[6].eq {
	pc = 0x824301B8; continue 'dispatch;
	}
	// 824301B4: 481639DD  bl 0x82593b90
	ctx.lr = 0x824301B8;
	sub_82593B90(ctx, base);
	// 824301B8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824301BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 824301C0: 419A000C  beq cr6, 0x824301cc
	if ctx.cr[6].eq {
	pc = 0x824301CC; continue 'dispatch;
	}
	// 824301C4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 824301C8: 481637C9  bl 0x82593990
	ctx.lr = 0x824301CC;
	sub_82593990(ctx, base);
	// 824301CC: 38210180  addi r1, r1, 0x180
	ctx.r[1].s64 = ctx.r[1].s64 + 384;
	// 824301D0: CBC1FF70  lfd f30, -0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-144 as u32) ) };
	// 824301D4: CBE1FF78  lfd f31, -0x88(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-136 as u32) ) };
	// 824301D8: 48D77FB4  b 0x831a818c
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824301E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824301E0 size=2996
    let mut pc: u32 = 0x824301E0;
    'dispatch: loop {
        match pc {
            0x824301E0 => {
    //   block [0x824301E0..0x82430D94)
	// 824301E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824301E4: 48D77F4D  bl 0x831a8130
	ctx.lr = 0x824301E8;
	sub_831A8130(ctx, base);
	// 824301E8: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 824301EC: 48D78889  bl 0x831a8a74
	ctx.lr = 0x824301F0;
	sub_831A8A40(ctx, base);
	// 824301F0: 3980FF20  li r12, -0xe0
	ctx.r[12].s64 = -224;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82430D98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82430D98 size=80
    let mut pc: u32 = 0x82430D98;
    'dispatch: loop {
        match pc {
            0x82430D98 => {
    //   block [0x82430D98..0x82430DE8)
	// 82430D98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82430D9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82430DA0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82430DA4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82430DA8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82430DAC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82430DB0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82430DB4: 48A288CD  bl 0x82e59680
	ctx.lr = 0x82430DB8;
	sub_82E59680(ctx, base);
	// 82430DB8: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82430DBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82430DC0: 396B5754  addi r11, r11, 0x5754
	ctx.r[11].s64 = ctx.r[11].s64 + 22356;
	// 82430DC4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82430DC8: C01E0000  lfs f0, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82430DCC: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82430DD0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82430DD4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82430DD8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82430DDC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82430DE0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82430DE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82430DE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82430DE8 size=60
    let mut pc: u32 = 0x82430DE8;
    'dispatch: loop {
        match pc {
            0x82430DE8 => {
    //   block [0x82430DE8..0x82430E24)
	// 82430DE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82430DEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82430DF0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82430DF4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82430DF8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82430DFC: 4BFFBD15  bl 0x8242cb10
	ctx.lr = 0x82430E00;
	sub_8242CB10(ctx, base);
	// 82430E00: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82430E04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82430E08: 396B575C  addi r11, r11, 0x575c
	ctx.r[11].s64 = ctx.r[11].s64 + 22364;
	// 82430E0C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82430E10: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82430E14: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82430E18: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82430E1C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82430E20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82430E28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82430E28 size=68
    let mut pc: u32 = 0x82430E28;
    'dispatch: loop {
        match pc {
            0x82430E28 => {
    //   block [0x82430E28..0x82430E6C)
	// 82430E28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82430E2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82430E30: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82430E34: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82430E38: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82430E3C: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82430E40: 548A07FF  clrlwi. r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82430E44: 396B55C8  addi r11, r11, 0x55c8
	ctx.r[11].s64 = ctx.r[11].s64 + 21960;
	// 82430E48: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82430E4C: 41820008  beq 0x82430e54
	if ctx.cr[0].eq {
	pc = 0x82430E54; continue 'dispatch;
	}
	// 82430E50: 489C1589  bl 0x82df23d8
	ctx.lr = 0x82430E54;
	sub_82DF23D8(ctx, base);
	// 82430E54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82430E58: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82430E5C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82430E60: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82430E64: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82430E68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82430E70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82430E70 size=196
    let mut pc: u32 = 0x82430E70;
    'dispatch: loop {
        match pc {
            0x82430E70 => {
    //   block [0x82430E70..0x82430F34)
	// 82430E70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82430E74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82430E78: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82430E7C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82430E80: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82430E84: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82430E88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82430E8C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82430E90: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82430E94: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82430E98: 4BE8FAA1  bl 0x822c0938
	ctx.lr = 0x82430E9C;
	sub_822C0938(ctx, base);
	// 82430E9C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82430EA0: 41820028  beq 0x82430ec8
	if ctx.cr[0].eq {
	pc = 0x82430EC8; continue 'dispatch;
	}
	// 82430EA4: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82430EA8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82430EAC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82430EB0: 392B576C  addi r9, r11, 0x576c
	ctx.r[9].s64 = ctx.r[11].s64 + 22380;
	// 82430EB4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82430EB8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82430EBC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82430EC0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82430EC4: 48000008  b 0x82430ecc
	pc = 0x82430ECC; continue 'dispatch;
	// 82430EC8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82430ECC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82430ED0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82430ED4: 409A0044  bne cr6, 0x82430f18
	if !ctx.cr[6].eq {
	pc = 0x82430F18; continue 'dispatch;
	}
	// 82430ED8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82430EDC: 419A001C  beq cr6, 0x82430ef8
	if ctx.cr[6].eq {
	pc = 0x82430EF8; continue 'dispatch;
	}
	// 82430EE0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82430EE4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82430EE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82430EEC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82430EF0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82430EF4: 4E800421  bctrl
	ctx.lr = 0x82430EF8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82430EF8: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 82430EFC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82430F00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82430F04: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82430F08: 816B1E28  lwz r11, 0x1e28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(7720 as u32) ) } as u64;
	// 82430F0C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82430F10: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82430F14: 4BE8F0ED  bl 0x822c0000
	ctx.lr = 0x82430F18;
	sub_822C0000(ctx, base);
	// 82430F18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82430F1C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82430F20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82430F24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82430F28: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82430F2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82430F30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82430F38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82430F38 size=196
    let mut pc: u32 = 0x82430F38;
    'dispatch: loop {
        match pc {
            0x82430F38 => {
    //   block [0x82430F38..0x82430FFC)
	// 82430F38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82430F3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82430F40: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82430F44: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82430F48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82430F4C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82430F50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82430F54: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82430F58: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82430F5C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82430F60: 4BE8F9D9  bl 0x822c0938
	ctx.lr = 0x82430F64;
	sub_822C0938(ctx, base);
	// 82430F64: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82430F68: 41820028  beq 0x82430f90
	if ctx.cr[0].eq {
	pc = 0x82430F90; continue 'dispatch;
	}
	// 82430F6C: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82430F70: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82430F74: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82430F78: 392B5780  addi r9, r11, 0x5780
	ctx.r[9].s64 = ctx.r[11].s64 + 22400;
	// 82430F7C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82430F80: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82430F84: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82430F88: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82430F8C: 48000008  b 0x82430f94
	pc = 0x82430F94; continue 'dispatch;
	// 82430F90: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82430F94: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82430F98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82430F9C: 409A0044  bne cr6, 0x82430fe0
	if !ctx.cr[6].eq {
	pc = 0x82430FE0; continue 'dispatch;
	}
	// 82430FA0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82430FA4: 419A001C  beq cr6, 0x82430fc0
	if ctx.cr[6].eq {
	pc = 0x82430FC0; continue 'dispatch;
	}
	// 82430FA8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82430FAC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82430FB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82430FB4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82430FB8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82430FBC: 4E800421  bctrl
	ctx.lr = 0x82430FC0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82430FC0: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 82430FC4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82430FC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82430FCC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82430FD0: 816B1E28  lwz r11, 0x1e28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(7720 as u32) ) } as u64;
	// 82430FD4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82430FD8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82430FDC: 4BE8F025  bl 0x822c0000
	ctx.lr = 0x82430FE0;
	sub_822C0000(ctx, base);
	// 82430FE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82430FE4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82430FE8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82430FEC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82430FF0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82430FF4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82430FF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82431000(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82431000 size=124
    let mut pc: u32 = 0x82431000;
    'dispatch: loop {
        match pc {
            0x82431000 => {
    //   block [0x82431000..0x8243107C)
	// 82431000: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82431004: 48D77169  bl 0x831a816c
	ctx.lr = 0x82431008;
	sub_831A8130(ctx, base);
	// 82431008: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8243100C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82431010: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82431014: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82431018: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 8243101C: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 82431020: 38600040  li r3, 0x40
	ctx.r[3].s64 = 64;
	// 82431024: 489C13C5  bl 0x82df23e8
	ctx.lr = 0x82431028;
	sub_82DF23E8(ctx, base);
	// 82431028: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8243102C: 4182001C  beq 0x82431048
	if ctx.cr[0].eq {
	pc = 0x82431048; continue 'dispatch;
	}
	// 82431030: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82431034: 48A2866D  bl 0x82e596a0
	ctx.lr = 0x82431038;
	sub_82E596A0(ctx, base);
	// 82431038: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8243103C: 396B5794  addi r11, r11, 0x5794
	ctx.r[11].s64 = ctx.r[11].s64 + 22420;
	// 82431040: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82431044: 48000008  b 0x8243104c
	pc = 0x8243104C; continue 'dispatch;
	// 82431048: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8243104C: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82431050: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82431054: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82431058: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8243105C: 4BFFFE15  bl 0x82430e70
	ctx.lr = 0x82431060;
	sub_82430E70(ctx, base);
	// 82431060: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82431064: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82431068: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8243106C: 4BE8EF95  bl 0x822c0000
	ctx.lr = 0x82431070;
	sub_822C0000(ctx, base);
	// 82431070: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82431074: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82431078: 48D77144  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82431080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82431080 size=120
    let mut pc: u32 = 0x82431080;
    'dispatch: loop {
        match pc {
            0x82431080 => {
    //   block [0x82431080..0x824310F8)
	// 82431080: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82431084: 48D770E9  bl 0x831a816c
	ctx.lr = 0x82431088;
	sub_831A8130(ctx, base);
	// 82431088: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8243108C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82431090: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82431094: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82431098: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8243109C: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 824310A0: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 824310A4: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 824310A8: 489C1341  bl 0x82df23e8
	ctx.lr = 0x824310AC;
	sub_82DF23E8(ctx, base);
	// 824310AC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 824310B0: 41820014  beq 0x824310c4
	if ctx.cr[0].eq {
	pc = 0x824310C4; continue 'dispatch;
	}
	// 824310B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 824310B8: 4BFFFCE1  bl 0x82430d98
	ctx.lr = 0x824310BC;
	sub_82430D98(ctx, base);
	// 824310BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824310C0: 48000008  b 0x824310c8
	pc = 0x824310C8; continue 'dispatch;
	// 824310C4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 824310C8: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 824310CC: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 824310D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 824310D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824310D8: 4BFFFE61  bl 0x82430f38
	ctx.lr = 0x824310DC;
	sub_82430F38(ctx, base);
	// 824310DC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 824310E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 824310E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824310E8: 4BE8EF19  bl 0x822c0000
	ctx.lr = 0x824310EC;
	sub_822C0000(ctx, base);
	// 824310EC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 824310F0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824310F4: 48D770C8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824310F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824310F8 size=432
    let mut pc: u32 = 0x824310F8;
    'dispatch: loop {
        match pc {
            0x824310F8 => {
    //   block [0x824310F8..0x824312A8)
	// 824310F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824310FC: 48D77065  bl 0x831a8160
	ctx.lr = 0x82431100;
	sub_831A8130(ctx, base);
	// 82431100: DBC1FFB8  stfd f30, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[30].u64 ) };
	// 82431104: DBE1FFC0  stfd f31, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 82431108: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8243110C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82431110: FFC00890  fmr f30, f1
	ctx.f[30].f64 = ctx.f[1].f64;
	// 82431114: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82431118: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 8243111C: 4BFFFEE5  bl 0x82431000
	ctx.lr = 0x82431120;
	sub_82431000(ctx, base);
	// 82431120: 83610054  lwz r27, 0x54(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82431124: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82431128: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 8243112C: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 82431130: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82431134: 419A0024  beq cr6, 0x82431158
	if ctx.cr[6].eq {
	pc = 0x82431158; continue 'dispatch;
	}
	// 82431138: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 8243113C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82431140: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82431144: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82431148: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8243114C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82431150: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82431154: 4082FFE8  bne 0x8243113c
	if !ctx.cr[0].eq {
	pc = 0x8243113C; continue 'dispatch;
	}
	// 82431158: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8243115C: 3B410050  addi r26, r1, 0x50
	ctx.r[26].s64 = ctx.r[1].s64 + 80;
	// 82431160: 4BED4AD1  bl 0x82305c30
	ctx.lr = 0x82431164;
	sub_82305C30(ctx, base);
	// 82431164: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82431168: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 8243116C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82431170: 3BAB5798  addi r29, r11, 0x5798
	ctx.r[29].s64 = ctx.r[11].s64 + 22424;
	// 82431174: 38A0003E  li r5, 0x3e
	ctx.r[5].s64 = 62;
	// 82431178: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8243117C: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 82431180: 4BED6CB9  bl 0x82307e38
	ctx.lr = 0x82431184;
	sub_82307E38(ctx, base);
	// 82431184: 39600030  li r11, 0x30
	ctx.r[11].s64 = 48;
	// 82431188: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 8243118C: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 82431190: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82431194: 13FE58C7  vcmpequd (lvx128) v31, v30, v11
	tmp.u32 = ctx.r[30].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82431198: 13DE50C7  vcmpequd (lvx128) v30, v30, v10
	tmp.u32 = ctx.r[30].u32 + ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824312A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824312A8 size=108
    let mut pc: u32 = 0x824312A8;
    'dispatch: loop {
        match pc {
            0x824312A8 => {
    //   block [0x824312A8..0x82431314)
	// 824312A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824312AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824312B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824312B4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824312B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824312BC: 4BFFB855  bl 0x8242cb10
	ctx.lr = 0x824312C0;
	sub_8242CB10(ctx, base);
	// 824312C0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 824312C4: 3D208202  lis r9, -0x7dfe
	ctx.r[9].s64 = -2113798144;
	// 824312C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824312CC: 39295800  addi r9, r9, 0x5800
	ctx.r[9].s64 = ctx.r[9].s64 + 22528;
	// 824312D0: 917F0048  stw r11, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 824312D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824312D8: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824312DC: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824312E0: D01F0040  stfs f0, 0x40(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 824312E4: D01F0044  stfs f0, 0x44(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 824312E8: D01F004C  stfs f0, 0x4c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 824312EC: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 824312F0: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 824312F4: 917F0078  stw r11, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 824312F8: 917F007C  stw r11, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 824312FC: 917F00A8  stw r11, 0xa8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), ctx.r[11].u32 ) };
	// 82431300: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82431304: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82431308: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8243130C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82431310: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82431318(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82431318 size=84
    let mut pc: u32 = 0x82431318;
    'dispatch: loop {
        match pc {
            0x82431318 => {
    //   block [0x82431318..0x8243136C)
	// 82431318: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8243131C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82431320: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82431324: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82431328: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8243132C: 807F007C  lwz r3, 0x7c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82431330: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82431334: 419A0008  beq cr6, 0x8243133c
	if ctx.cr[6].eq {
	pc = 0x8243133C; continue 'dispatch;
	}
	// 82431338: 4BE8F559  bl 0x822c0890
	ctx.lr = 0x8243133C;
	sub_822C0890(ctx, base);
	// 8243133C: 807F0074  lwz r3, 0x74(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82431340: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82431344: 419A0008  beq cr6, 0x8243134c
	if ctx.cr[6].eq {
	pc = 0x8243134C; continue 'dispatch;
	}
	// 82431348: 4BE8F549  bl 0x822c0890
	ctx.lr = 0x8243134C;
	sub_822C0890(ctx, base);
	// 8243134C: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82431350: 396B55C8  addi r11, r11, 0x55c8
	ctx.r[11].s64 = ctx.r[11].s64 + 21960;
	// 82431354: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82431358: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8243135C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82431360: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82431364: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82431368: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82431370(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82431370 size=76
    let mut pc: u32 = 0x82431370;
    'dispatch: loop {
        match pc {
            0x82431370 => {
    //   block [0x82431370..0x824313BC)
	// 82431370: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82431374: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82431378: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8243137C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82431380: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82431384: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82431388: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8243138C: 4BFFFF8D  bl 0x82431318
	ctx.lr = 0x82431390;
	sub_82431318(ctx, base);
	// 82431390: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82431394: 4182000C  beq 0x824313a0
	if ctx.cr[0].eq {
	pc = 0x824313A0; continue 'dispatch;
	}
	// 82431398: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8243139C: 489C103D  bl 0x82df23d8
	ctx.lr = 0x824313A0;
	sub_82DF23D8(ctx, base);
	// 824313A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824313A4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824313A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824313AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824313B0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 824313B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824313B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824313C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824313C0 size=1568
    let mut pc: u32 = 0x824313C0;
    'dispatch: loop {
        match pc {
            0x824313C0 => {
    //   block [0x824313C0..0x824319E0)
	// 824313C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824313C4: 48D76D99  bl 0x831a815c
	ctx.lr = 0x824313C8;
	sub_831A8130(ctx, base);
	// 824313C8: 3981FFC0  addi r12, r1, -0x40
	ctx.r[12].s64 = ctx.r[1].s64 + -64;
	// 824313CC: 48D776A5  bl 0x831a8a70
	ctx.lr = 0x824313D0;
	sub_831A8A40(ctx, base);
	// 824313D0: 3980FF70  li r12, -0x90
	ctx.r[12].s64 = -144;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824319E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824319E0 size=196
    let mut pc: u32 = 0x824319E0;
    'dispatch: loop {
        match pc {
            0x824319E0 => {
    //   block [0x824319E0..0x82431AA4)
	// 824319E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824319E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824319E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824319EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824319F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824319F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 824319F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824319FC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82431A00: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82431A04: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82431A08: 4BE8EF31  bl 0x822c0938
	ctx.lr = 0x82431A0C;
	sub_822C0938(ctx, base);
	// 82431A0C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82431A10: 41820028  beq 0x82431a38
	if ctx.cr[0].eq {
	pc = 0x82431A38; continue 'dispatch;
	}
	// 82431A14: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82431A18: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82431A1C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82431A20: 392B5878  addi r9, r11, 0x5878
	ctx.r[9].s64 = ctx.r[11].s64 + 22648;
	// 82431A24: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82431A28: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82431A2C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82431A30: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82431A34: 48000008  b 0x82431a3c
	pc = 0x82431A3C; continue 'dispatch;
	// 82431A38: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82431A3C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82431A40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82431A44: 409A0044  bne cr6, 0x82431a88
	if !ctx.cr[6].eq {
	pc = 0x82431A88; continue 'dispatch;
	}
	// 82431A48: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82431A4C: 419A001C  beq cr6, 0x82431a68
	if ctx.cr[6].eq {
	pc = 0x82431A68; continue 'dispatch;
	}
	// 82431A50: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82431A54: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82431A58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82431A5C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82431A60: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82431A64: 4E800421  bctrl
	ctx.lr = 0x82431A68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82431A68: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 82431A6C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82431A70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82431A74: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82431A78: 816B1FA0  lwz r11, 0x1fa0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8096 as u32) ) } as u64;
	// 82431A7C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82431A80: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82431A84: 4BE8E57D  bl 0x822c0000
	ctx.lr = 0x82431A88;
	sub_822C0000(ctx, base);
	// 82431A88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82431A8C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82431A90: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82431A94: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82431A98: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82431A9C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82431AA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82431AA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82431AA8 size=440
    let mut pc: u32 = 0x82431AA8;
    'dispatch: loop {
        match pc {
            0x82431AA8 => {
    //   block [0x82431AA8..0x82431C60)
	// 82431AA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82431AAC: 48D766BD  bl 0x831a8168
	ctx.lr = 0x82431AB0;
	sub_831A8130(ctx, base);
	// 82431AB0: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82431AB4: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82431C60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82431C60 size=348
    let mut pc: u32 = 0x82431C60;
    'dispatch: loop {
        match pc {
            0x82431C60 => {
    //   block [0x82431C60..0x82431DBC)
	// 82431C60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82431C64: 48D76505  bl 0x831a8168
	ctx.lr = 0x82431C68;
	sub_831A8130(ctx, base);
	// 82431C68: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82431C6C: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82431DC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82431DC0 size=164
    let mut pc: u32 = 0x82431DC0;
    'dispatch: loop {
        match pc {
            0x82431DC0 => {
    //   block [0x82431DC0..0x82431E64)
	// 82431DC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82431DC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82431DC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82431DCC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82431DD0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82431DD4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82431DD8: 4BFFAD39  bl 0x8242cb10
	ctx.lr = 0x82431DDC;
	sub_8242CB10(ctx, base);
	// 82431DDC: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82431DE0: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 82431DE4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82431DE8: 394A588C  addi r10, r10, 0x588c
	ctx.r[10].s64 = ctx.r[10].s64 + 22668;
	// 82431DEC: 93DF0028  stw r30, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[30].u32 ) };
	// 82431DF0: 387F0030  addi r3, r31, 0x30
	ctx.r[3].s64 = ctx.r[31].s64 + 48;
	// 82431DF4: C00B5898  lfs f0, 0x5898(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(22680 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82431DF8: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82431DFC: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82431E00: 487215D1  bl 0x82b533d0
	ctx.lr = 0x82431E04;
	sub_82B533D0(ctx, base);
	// 82431E04: 93DF0060  stw r30, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 82431E08: 93DF0064  stw r30, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 82431E0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82431E10: 93DF0068  stw r30, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[30].u32 ) };
	// 82431E14: 93DF006C  stw r30, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[30].u32 ) };
	// 82431E18: 93DF0080  stw r30, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[30].u32 ) };
	// 82431E1C: 93DF0084  stw r30, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	// 82431E20: 93DF0088  stw r30, 0x88(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[30].u32 ) };
	// 82431E24: 93DF008C  stw r30, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[30].u32 ) };
	// 82431E28: 93DF0090  stw r30, 0x90(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[30].u32 ) };
	// 82431E2C: 93DF0094  stw r30, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[30].u32 ) };
	// 82431E30: 93DF0098  stw r30, 0x98(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[30].u32 ) };
	// 82431E34: 93DF009C  stw r30, 0x9c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), ctx.r[30].u32 ) };
	// 82431E38: 93DF00A0  stw r30, 0xa0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), ctx.r[30].u32 ) };
	// 82431E3C: 93DF00C4  stw r30, 0xc4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), ctx.r[30].u32 ) };
	// 82431E40: 93DF00C8  stw r30, 0xc8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), ctx.r[30].u32 ) };
	// 82431E44: 93DF00CC  stw r30, 0xcc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), ctx.r[30].u32 ) };
	// 82431E48: 93DF00D0  stw r30, 0xd0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[30].u32 ) };
	// 82431E4C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82431E50: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82431E54: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82431E58: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82431E5C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82431E60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82431E68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82431E68 size=132
    let mut pc: u32 = 0x82431E68;
    'dispatch: loop {
        match pc {
            0x82431E68 => {
    //   block [0x82431E68..0x82431EEC)
	// 82431E68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82431E6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82431E70: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82431E74: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82431E78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82431E7C: 807F009C  lwz r3, 0x9c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) } as u64;
	// 82431E80: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82431E84: 419A0008  beq cr6, 0x82431e8c
	if ctx.cr[6].eq {
	pc = 0x82431E8C; continue 'dispatch;
	}
	// 82431E88: 4BE8EA09  bl 0x822c0890
	ctx.lr = 0x82431E8C;
	sub_822C0890(ctx, base);
	// 82431E8C: 807F0094  lwz r3, 0x94(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 82431E90: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82431E94: 419A0008  beq cr6, 0x82431e9c
	if ctx.cr[6].eq {
	pc = 0x82431E9C; continue 'dispatch;
	}
	// 82431E98: 4BE8E9F9  bl 0x822c0890
	ctx.lr = 0x82431E9C;
	sub_822C0890(ctx, base);
	// 82431E9C: 807F008C  lwz r3, 0x8c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82431EA0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82431EA4: 419A0008  beq cr6, 0x82431eac
	if ctx.cr[6].eq {
	pc = 0x82431EAC; continue 'dispatch;
	}
	// 82431EA8: 4BE8E9E9  bl 0x822c0890
	ctx.lr = 0x82431EAC;
	sub_822C0890(ctx, base);
	// 82431EAC: 807F0084  lwz r3, 0x84(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 82431EB0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82431EB4: 419A0008  beq cr6, 0x82431ebc
	if ctx.cr[6].eq {
	pc = 0x82431EBC; continue 'dispatch;
	}
	// 82431EB8: 4BE8E9D9  bl 0x822c0890
	ctx.lr = 0x82431EBC;
	sub_822C0890(ctx, base);
	// 82431EBC: 807F006C  lwz r3, 0x6c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82431EC0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82431EC4: 419A0008  beq cr6, 0x82431ecc
	if ctx.cr[6].eq {
	pc = 0x82431ECC; continue 'dispatch;
	}
	// 82431EC8: 4BE8E9C9  bl 0x822c0890
	ctx.lr = 0x82431ECC;
	sub_822C0890(ctx, base);
	// 82431ECC: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82431ED0: 396B55C8  addi r11, r11, 0x55c8
	ctx.r[11].s64 = ctx.r[11].s64 + 21960;
	// 82431ED4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82431ED8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82431EDC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82431EE0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82431EE4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82431EE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82431EF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82431EF0 size=76
    let mut pc: u32 = 0x82431EF0;
    'dispatch: loop {
        match pc {
            0x82431EF0 => {
    //   block [0x82431EF0..0x82431F3C)
	// 82431EF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82431EF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82431EF8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82431EFC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82431F00: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82431F04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82431F08: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82431F0C: 4BFFFF5D  bl 0x82431e68
	ctx.lr = 0x82431F10;
	sub_82431E68(ctx, base);
	// 82431F10: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82431F14: 4182000C  beq 0x82431f20
	if ctx.cr[0].eq {
	pc = 0x82431F20; continue 'dispatch;
	}
	// 82431F18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82431F1C: 489C04BD  bl 0x82df23d8
	ctx.lr = 0x82431F20;
	sub_82DF23D8(ctx, base);
	// 82431F20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82431F24: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82431F28: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82431F2C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82431F30: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82431F34: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82431F38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82431F40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82431F40 size=132
    let mut pc: u32 = 0x82431F40;
    'dispatch: loop {
        match pc {
            0x82431F40 => {
    //   block [0x82431F40..0x82431FC4)
	// 82431F40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82431F44: 48D76229  bl 0x831a816c
	ctx.lr = 0x82431F48;
	sub_831A8130(ctx, base);
	// 82431F48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82431F4C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82431F50: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82431F54: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82431F58: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82431F5C: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 82431F60: 38600050  li r3, 0x50
	ctx.r[3].s64 = 80;
	// 82431F64: 489C0485  bl 0x82df23e8
	ctx.lr = 0x82431F68;
	sub_82DF23E8(ctx, base);
	// 82431F68: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82431F6C: 41820024  beq 0x82431f90
	if ctx.cr[0].eq {
	pc = 0x82431F90; continue 'dispatch;
	}
	// 82431F70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82431F74: 48A2772D  bl 0x82e596a0
	ctx.lr = 0x82431F78;
	sub_82E596A0(ctx, base);
	// 82431F78: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82431F7C: 387F0020  addi r3, r31, 0x20
	ctx.r[3].s64 = ctx.r[31].s64 + 32;
	// 82431F80: 396B5870  addi r11, r11, 0x5870
	ctx.r[11].s64 = ctx.r[11].s64 + 22640;
	// 82431F84: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82431F88: 48721449  bl 0x82b533d0
	ctx.lr = 0x82431F8C;
	sub_82B533D0(ctx, base);
	// 82431F8C: 48000008  b 0x82431f94
	pc = 0x82431F94; continue 'dispatch;
	// 82431F90: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82431F94: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82431F98: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82431F9C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82431FA0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82431FA4: 4BFFFA3D  bl 0x824319e0
	ctx.lr = 0x82431FA8;
	sub_824319E0(ctx, base);
	// 82431FA8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82431FAC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82431FB0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82431FB4: 4BE8E04D  bl 0x822c0000
	ctx.lr = 0x82431FB8;
	sub_822C0000(ctx, base);
	// 82431FB8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82431FBC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82431FC0: 48D761FC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82431FC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82431FC8 size=388
    let mut pc: u32 = 0x82431FC8;
    'dispatch: loop {
        match pc {
            0x82431FC8 => {
    //   block [0x82431FC8..0x8243214C)
	// 82431FC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82431FCC: 48D761A1  bl 0x831a816c
	ctx.lr = 0x82431FD0;
	sub_831A8130(ctx, base);
	// 82431FD0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82431FD4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82431FD8: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82431FDC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82431FE0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82431FE4: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82431FE8: 4BED3A89  bl 0x82305a70
	ctx.lr = 0x82431FEC;
	sub_82305A70(ctx, base);
	// 82431FEC: 39610090  addi r11, r1, 0x90
	ctx.r[11].s64 = ctx.r[1].s64 + 144;
	// 82431FF0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82431FF4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82431FF8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82431FFC: 4BEEB1D5  bl 0x8231d1d0
	ctx.lr = 0x82432000;
	sub_8231D1D0(ctx, base);
	// 82432000: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82432004: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82432008: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8243200C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82432010: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82432014: 419A0024  beq cr6, 0x82432038
	if ctx.cr[6].eq {
	pc = 0x82432038; continue 'dispatch;
	}
	// 82432018: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8243201C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82432020: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82432024: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82432028: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8243202C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82432030: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82432034: 4082FFE8  bne 0x8243201c
	if !ctx.cr[0].eq {
	pc = 0x8243201C; continue 'dispatch;
	}
	// 82432038: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8243203C: 80DF00A0  lwz r6, 0xa0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 82432040: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 82432044: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82432048: 388B58A0  addi r4, r11, 0x58a0
	ctx.r[4].s64 = ctx.r[11].s64 + 22688;
	// 8243204C: 38A000BD  li r5, 0xbd
	ctx.r[5].s64 = 189;
	// 82432050: 4BED5DE9  bl 0x82307e38
	ctx.lr = 0x82432054;
	sub_82307E38(ctx, base);
	// 82432054: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82432058: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8243205C: 419A0008  beq cr6, 0x82432064
	if ctx.cr[6].eq {
	pc = 0x82432064; continue 'dispatch;
	}
	// 82432060: 4BE8E831  bl 0x822c0890
	ctx.lr = 0x82432064;
	sub_822C0890(ctx, base);
	// 82432064: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82432068: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8243206C: 4BED3A05  bl 0x82305a70
	ctx.lr = 0x82432070;
	sub_82305A70(ctx, base);
	// 82432070: 39610090  addi r11, r1, 0x90
	ctx.r[11].s64 = ctx.r[1].s64 + 144;
	// 82432074: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82432078: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 8243207C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82432150(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82432150 size=500
    let mut pc: u32 = 0x82432150;
    'dispatch: loop {
        match pc {
            0x82432150 => {
    //   block [0x82432150..0x82432344)
	// 82432150: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82432154: 48D76015  bl 0x831a8168
	ctx.lr = 0x82432158;
	sub_831A8130(ctx, base);
	// 82432158: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8243215C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82432160: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82432164: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82432168: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 8243216C: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82432170: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82432174: 4BED38FD  bl 0x82305a70
	ctx.lr = 0x82432178;
	sub_82305A70(ctx, base);
	// 82432178: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 8243217C: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82432180: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82432184: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82432188: 419A0068  beq cr6, 0x824321f0
	if ctx.cr[6].eq {
	pc = 0x824321F0; continue 'dispatch;
	}
	// 8243218C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82432190: 4BEEB041  bl 0x8231d1d0
	ctx.lr = 0x82432194;
	sub_8231D1D0(ctx, base);
	// 82432194: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82432198: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8243219C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 824321A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824321A4: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 824321A8: 419A0024  beq cr6, 0x824321cc
	if ctx.cr[6].eq {
	pc = 0x824321CC; continue 'dispatch;
	}
	// 824321AC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 824321B0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 824321B4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 824321B8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 824321BC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 824321C0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 824321C4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 824321C8: 4082FFE8  bne 0x824321b0
	if !ctx.cr[0].eq {
	pc = 0x824321B0; continue 'dispatch;
	}
	// 824321CC: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 824321D0: 80DF0060  lwz r6, 0x60(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 824321D4: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 824321D8: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824321DC: 388B58A0  addi r4, r11, 0x58a0
	ctx.r[4].s64 = ctx.r[11].s64 + 22688;
	// 824321E0: 38A000CC  li r5, 0xcc
	ctx.r[5].s64 = 204;
	// 824321E4: 4BED5C55  bl 0x82307e38
	ctx.lr = 0x824321E8;
	sub_82307E38(ctx, base);
	// 824321E8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 824321EC: 48000064  b 0x82432250
	pc = 0x82432250; continue 'dispatch;
	// 824321F0: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 824321F4: 4BEEAFDD  bl 0x8231d1d0
	ctx.lr = 0x824321F8;
	sub_8231D1D0(ctx, base);
	// 824321F8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824321FC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82432200: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82432204: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82432208: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 8243220C: 419A0024  beq cr6, 0x82432230
	if ctx.cr[6].eq {
	pc = 0x82432230; continue 'dispatch;
	}
	// 82432210: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82432214: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82432218: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8243221C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82432220: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82432224: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82432228: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8243222C: 4082FFE8  bne 0x82432214
	if !ctx.cr[0].eq {
	pc = 0x82432214; continue 'dispatch;
	}
	// 82432230: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82432234: 80DF0064  lwz r6, 0x64(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82432238: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 8243223C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82432240: 388B58A0  addi r4, r11, 0x58a0
	ctx.r[4].s64 = ctx.r[11].s64 + 22688;
	// 82432244: 38A000CE  li r5, 0xce
	ctx.r[5].s64 = 206;
	// 82432248: 4BED5BF1  bl 0x82307e38
	ctx.lr = 0x8243224C;
	sub_82307E38(ctx, base);
	// 8243224C: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82432250: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82432254: 419A0008  beq cr6, 0x8243225c
	if ctx.cr[6].eq {
	pc = 0x8243225C; continue 'dispatch;
	}
	// 82432258: 4BE8E639  bl 0x822c0890
	ctx.lr = 0x8243225C;
	sub_822C0890(ctx, base);
	// 8243225C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82432260: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82432264: 4BED380D  bl 0x82305a70
	ctx.lr = 0x82432268;
	sub_82305A70(ctx, base);
	// 82432268: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 8243226C: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82432270: 39410090  addi r10, r1, 0x90
	ctx.r[10].s64 = ctx.r[1].s64 + 144;
	// 82432274: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82432348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82432348 size=496
    let mut pc: u32 = 0x82432348;
    'dispatch: loop {
        match pc {
            0x82432348 => {
    //   block [0x82432348..0x82432538)
	// 82432348: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8243234C: 48D75E19  bl 0x831a8164
	ctx.lr = 0x82432350;
	sub_831A8130(ctx, base);
	// 82432350: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82432354: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82432358: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8243235C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82432360: 4BFFFBE1  bl 0x82431f40
	ctx.lr = 0x82432364;
	sub_82431F40(ctx, base);
	// 82432364: 39610090  addi r11, r1, 0x90
	ctx.r[11].s64 = ctx.r[1].s64 + 144;
	// 82432368: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8243236C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82432370: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82432374: 4BEEAE5D  bl 0x8231d1d0
	ctx.lr = 0x82432378;
	sub_8231D1D0(ctx, base);
	// 82432378: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8243237C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82432380: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82432384: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82432388: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 8243238C: 419A0024  beq cr6, 0x824323b0
	if ctx.cr[6].eq {
	pc = 0x824323B0; continue 'dispatch;
	}
	// 82432390: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82432394: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82432398: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8243239C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 824323A0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 824323A4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 824323A8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 824323AC: 4082FFE8  bne 0x82432394
	if !ctx.cr[0].eq {
	pc = 0x82432394; continue 'dispatch;
	}
	// 824323B0: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 824323B4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824323B8: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 824323BC: 3BAB58A0  addi r29, r11, 0x58a0
	ctx.r[29].s64 = ctx.r[11].s64 + 22688;
	// 824323C0: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 824323C4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 824323C8: 38A000DE  li r5, 0xde
	ctx.r[5].s64 = 222;
	// 824323CC: 4BED5A6D  bl 0x82307e38
	ctx.lr = 0x824323D0;
	sub_82307E38(ctx, base);
	// 824323D0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 824323D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 824323D8: 419A0008  beq cr6, 0x824323e0
	if ctx.cr[6].eq {
	pc = 0x824323E0; continue 'dispatch;
	}
	// 824323DC: 4BE8E4B5  bl 0x822c0890
	ctx.lr = 0x824323E0;
	sub_822C0890(ctx, base);
	// 824323E0: 83610064  lwz r27, 0x64(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 824323E4: 83C10060  lwz r30, 0x60(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 824323E8: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 824323EC: 93610064  stw r27, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[27].u32 ) };
	// 824323F0: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 824323F4: 419A0024  beq cr6, 0x82432418
	if ctx.cr[6].eq {
	pc = 0x82432418; continue 'dispatch;
	}
	// 824323F8: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 824323FC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82432400: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82432404: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82432408: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8243240C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82432410: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82432414: 4082FFE8  bne 0x824323fc
	if !ctx.cr[0].eq {
	pc = 0x824323FC; continue 'dispatch;
	}
	// 82432418: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8243241C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82432420: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 82432424: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82432428: 38A000DF  li r5, 0xdf
	ctx.r[5].s64 = 223;
	// 8243242C: 4BED5A0D  bl 0x82307e38
	ctx.lr = 0x82432430;
	sub_82307E38(ctx, base);
	// 82432430: 813E0020  lwz r9, 0x20(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 82432434: 397E0020  addi r11, r30, 0x20
	ctx.r[11].s64 = ctx.r[30].s64 + 32;
	// 82432438: 3BA00010  li r29, 0x10
	ctx.r[29].s64 = 16;
	// 8243243C: 395F0030  addi r10, r31, 0x30
	ctx.r[10].s64 = ctx.r[31].s64 + 48;
	// 82432440: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82432444: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82432448: 813E0020  lwz r9, 0x20(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 8243244C: 913F0030  stw r9, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[9].u32 ) };
	// 82432450: 813E0024  lwz r9, 0x24(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 82432454: 913F0034  stw r9, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[9].u32 ) };
	// 82432458: 13EBE8C7  vcmpequd (lvx128) v31, v11, v29
	tmp.u32 = ctx.r[11].u32 + ctx.r[29].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82432538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82432538 size=768
    let mut pc: u32 = 0x82432538;
    'dispatch: loop {
        match pc {
            0x82432538 => {
    //   block [0x82432538..0x82432838)
	// 82432538: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8243253C: 48D75C19  bl 0x831a8154
	ctx.lr = 0x82432540;
	sub_831A8130(ctx, base);
	// 82432540: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82432544: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82432548: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8243254C: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82432550: 3D008202  lis r8, -0x7dfe
	ctx.r[8].s64 = -2113798144;
	// 82432554: 3CE08209  lis r7, -0x7df7
	ctx.r[7].s64 = -2113339392;
	// 82432558: C08AD7BC  lfs f4, -0x2844(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 8243255C: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 82432560: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82432564: C0AB6150  lfs f5, 0x6150(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82432568: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8243256C: C0E9A2EC  lfs f7, -0x5d14(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-23828 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82432570: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82432574: C0C85918  lfs f6, 0x5918(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(22808 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82432578: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 8243257C: C067ACFC  lfs f3, -0x5304(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-21252 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82432580: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82432584: C00608A4  lfs f0, 0x8a4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82432588: 397F0070  addi r11, r31, 0x70
	ctx.r[11].s64 = ctx.r[31].s64 + 112;
	// 8243258C: C1AA08A8  lfs f13, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82432590: 389F0090  addi r4, r31, 0x90
	ctx.r[4].s64 = ctx.r[31].s64 + 144;
	// 82432594: 93810070  stw r28, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[28].u32 ) };
	// 82432598: 38BF0098  addi r5, r31, 0x98
	ctx.r[5].s64 = ctx.r[31].s64 + 152;
	// 8243259C: D01F0070  stfs f0, 0x70(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 824325A0: D01F0074  stfs f0, 0x74(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 824325A4: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 824325A8: D01F0078  stfs f0, 0x78(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 824325AC: FC402890  fmr f2, f5
	ctx.f[2].f64 = ctx.f[5].f64;
	// 824325B0: D1BF007C  stfs f13, 0x7c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 824325B4: FC202090  fmr f1, f4
	ctx.f[1].f64 = ctx.f[4].f64;
	// 824325B8: 4BFFAB91  bl 0x8242d148
	ctx.lr = 0x824325BC;
	sub_8242D148(ctx, base);
	// 824325BC: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 824325C0: 39400008  li r10, 8
	ctx.r[10].s64 = 8;
	// 824325C4: 93C10098  stw r30, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[30].u32 ) };
	// 824325C8: 916100A0  stw r11, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 824325CC: 3BA00010  li r29, 0x10
	ctx.r[29].s64 = 16;
	// 824325D0: 916100B8  stw r11, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[11].u32 ) };
	// 824325D4: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 824325D8: 916100C4  stw r11, 0xc4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 824325DC: 38A10098  addi r5, r1, 0x98
	ctx.r[5].s64 = ctx.r[1].s64 + 152;
	// 824325E0: 93C1009C  stw r30, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[30].u32 ) };
	// 824325E4: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 824325E8: 93C100B0  stw r30, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[30].u32 ) };
	// 824325EC: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 824325F0: 93C100B4  stw r30, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[30].u32 ) };
	// 824325F4: 93C100BC  stw r30, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[30].u32 ) };
	// 824325F8: 93C100C0  stw r30, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[30].u32 ) };
	// 824325FC: 9141008C  stw r10, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[10].u32 ) };
	// 82432600: 93A10090  stw r29, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[29].u32 ) };
	// 82432604: 817F0090  lwz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 82432608: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 8243260C: 48B2D60D  bl 0x82f5fc18
	ctx.lr = 0x82432610;
	sub_82F5FC18(ctx, base);
	// 82432610: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82432614: 814100B0  lwz r10, 0xb0(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 82432618: 3B000014  li r24, 0x14
	ctx.r[24].s64 = 20;
	// 8243261C: 93A10090  stw r29, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[29].u32 ) };
	// 82432620: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 82432624: 832D0000  lwz r25, 0(r13)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82432628: 38800060  li r4, 0x60
	ctx.r[4].s64 = 96;
	// 8243262C: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 82432630: 91410088  stw r10, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[10].u32 ) };
	// 82432634: 7C78C82E  lwzx r3, r24, r25
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[24].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 82432638: 48A6E0F9  bl 0x82ea0730
	ctx.lr = 0x8243263C;
	sub_82EA0730(ctx, base);
	// 8243263C: 39600060  li r11, 0x60
	ctx.r[11].s64 = 96;
	// 82432640: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 82432644: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 82432648: 38A10098  addi r5, r1, 0x98
	ctx.r[5].s64 = ctx.r[1].s64 + 152;
	// 8243264C: 38810088  addi r4, r1, 0x88
	ctx.r[4].s64 = ctx.r[1].s64 + 136;
	// 82432650: C02AF614  lfs f1, -0x9ec(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-2540 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82432654: 48AE922D  bl 0x82f1b880
	ctx.lr = 0x82432658;
	sub_82F1B880(ctx, base);
	// 82432658: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8243265C: 3AEB58A0  addi r23, r11, 0x58a0
	ctx.r[23].s64 = ctx.r[11].s64 + 22688;
	// 82432660: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82432664: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82432668: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 8243266C: 38A0005B  li r5, 0x5b
	ctx.r[5].s64 = 91;
	// 82432670: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 82432674: 4BE8DD65  bl 0x822c03d8
	ctx.lr = 0x82432678;
	sub_822C03D8(ctx, base);
	// 82432678: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 8243267C: 4182006C  beq 0x824326e8
	if ctx.cr[0].eq {
	pc = 0x824326E8; continue 'dispatch;
	}
	// 82432680: 93410070  stw r26, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[26].u32 ) };
	// 82432684: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82432688: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8243268C: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 82432690: 808B6838  lwz r4, 0x6838(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26680 as u32) ) } as u64;
	// 82432694: 4BEB289D  bl 0x822e4f30
	ctx.lr = 0x82432698;
	sub_822E4F30(ctx, base);
	// 82432698: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 8243269C: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 824326A0: 4BEB2821  bl 0x822e4ec0
	ctx.lr = 0x824326A4;
	sub_822E4EC0(ctx, base);
	// 824326A4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 824326A8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 824326AC: E89A0000  ld r4, 0(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) };
	// 824326B0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 824326B4: E8630000  ld r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 824326B8: 48059BD1  bl 0x8248c288
	ctx.lr = 0x824326BC;
	sub_8248C288(ctx, base);
	// 824326BC: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 824326C0: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 824326C4: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 824326C8: 38EBBA80  addi r7, r11, -0x4580
	ctx.r[7].s64 = ctx.r[11].s64 + -17792;
	// 824326CC: 38CA6910  addi r6, r10, 0x6910
	ctx.r[6].s64 = ctx.r[10].s64 + 26896;
	// 824326D0: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 824326D4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 824326D8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 824326DC: 4805FAC5  bl 0x824921a0
	ctx.lr = 0x824326E0;
	sub_824921A0(ctx, base);
	// 824326E0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 824326E4: 48000008  b 0x824326ec
	pc = 0x824326EC; continue 'dispatch;
	// 824326E8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 824326EC: 387F0080  addi r3, r31, 0x80
	ctx.r[3].s64 = ctx.r[31].s64 + 128;
	// 824326F0: 4BEB26F9  bl 0x822e4de8
	ctx.lr = 0x824326F4;
	sub_822E4DE8(ctx, base);
	// 824326F4: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824326F8: 41820018  beq 0x82432710
	if ctx.cr[0].eq {
	pc = 0x82432710; continue 'dispatch;
	}
	// 824326FC: 80610070  lwz r3, 0x70(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82432700: 579C003C  rlwinm r28, r28, 0, 0, 0x1e
	ctx.r[28].u64 = ctx.r[28].u32 as u64 & 0xFFFFFFFFu64;
	// 82432704: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82432708: 419A0008  beq cr6, 0x82432710
	if ctx.cr[6].eq {
	pc = 0x82432710; continue 'dispatch;
	}
	// 8243270C: 4BEB5B5D  bl 0x822e8268
	ctx.lr = 0x82432710;
	sub_822E8268(ctx, base);
	// 82432710: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82432714: 4BEB3F8D  bl 0x822e66a0
	ctx.lr = 0x82432718;
	sub_822E66A0(ctx, base);
	// 82432718: 816100A0  lwz r11, 0xa0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) } as u64;
	// 8243271C: 556A0001  rlwinm. r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82432720: 40820018  bne 0x82432738
	if !ctx.cr[0].eq {
	pc = 0x82432738; continue 'dispatch;
	}
	// 82432724: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 82432728: 7C78C82E  lwzx r3, r24, r25
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[24].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 8243272C: 55652036  slwi r5, r11, 4
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82432730: 80810098  lwz r4, 0x98(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 82432734: 48A6E07D  bl 0x82ea07b0
	ctx.lr = 0x82432738;
	sub_82EA07B0(ctx, base);
	// 82432738: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 8243273C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82432740: 38A0005D  li r5, 0x5d
	ctx.r[5].s64 = 93;
	// 82432744: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 82432748: 4BE8DC91  bl 0x822c03d8
	ctx.lr = 0x8243274C;
	sub_822C03D8(ctx, base);
	// 8243274C: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82432750: 41820028  beq 0x82432778
	if ctx.cr[0].eq {
	pc = 0x82432778; continue 'dispatch;
	}
	// 82432754: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82432758: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8243275C: 639C0002  ori r28, r28, 2
	ctx.r[28].u64 = ctx.r[28].u64 | 2;
	// 82432760: 4BF6EB69  bl 0x823a12c8
	ctx.lr = 0x82432764;
	sub_823A12C8(ctx, base);
	// 82432764: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82432768: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8243276C: 4805E985  bl 0x824910f0
	ctx.lr = 0x82432770;
	sub_824910F0(ctx, base);
	// 82432770: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82432774: 48000008  b 0x8243277c
	pc = 0x8243277C; continue 'dispatch;
	// 82432778: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8243277C: 387F0068  addi r3, r31, 0x68
	ctx.r[3].s64 = ctx.r[31].s64 + 104;
	// 82432780: 4BED7F61  bl 0x8230a6e0
	ctx.lr = 0x82432784;
	sub_8230A6E0(ctx, base);
	// 82432784: 578B07BD  rlwinm. r11, r28, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82432788: 4182000C  beq 0x82432794
	if ctx.cr[0].eq {
	pc = 0x82432794; continue 'dispatch;
	}
	// 8243278C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82432790: 489BF501  bl 0x82df1c90
	ctx.lr = 0x82432794;
	sub_82DF1C90(ctx, base);
	// 82432794: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82432798: 4BED2C51  bl 0x823053e8
	ctx.lr = 0x8243279C;
	sub_823053E8(ctx, base);
	// 8243279C: 4877A06D  bl 0x82bac808
	ctx.lr = 0x824327A0;
	sub_82BAC808(ctx, base);
	// 824327A0: 483B7AC9  bl 0x827ea268
	ctx.lr = 0x824327A4;
	sub_827EA268(ctx, base);
	// 824327A4: 907F00C0  stw r3, 0xc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[3].u32 ) };
	// 824327A8: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 824327AC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 824327B0: 388BF818  addi r4, r11, -0x7e8
	ctx.r[4].s64 = ctx.r[11].s64 + -2024;
	// 824327B4: 48B7A55D  bl 0x82facd10
	ctx.lr = 0x824327B8;
	sub_82FACD10(ctx, base);
	// 824327B8: 7C6B0734  extsh r11, r3
	ctx.r[11].s64 = ctx.r[3].s16 as i64;
	// 824327BC: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 824327C0: 807F00C0  lwz r3, 0xc0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 824327C4: 917F00C8  stw r11, 0xc8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), ctx.r[11].u32 ) };
	// 824327C8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 824327CC: 388AF820  addi r4, r10, -0x7e0
	ctx.r[4].s64 = ctx.r[10].s64 + -2016;
	// 824327D0: 48B7A541  bl 0x82facd10
	ctx.lr = 0x824327D4;
	sub_82FACD10(ctx, base);
	// 824327D4: 7C6B0734  extsh r11, r3
	ctx.r[11].s64 = ctx.r[3].s16 as i64;
	// 824327D8: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 824327DC: 807F00C0  lwz r3, 0xc0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 824327E0: 917F00C4  stw r11, 0xc4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 824327E4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 824327E8: 388A590C  addi r4, r10, 0x590c
	ctx.r[4].s64 = ctx.r[10].s64 + 22796;
	// 824327EC: 48B7A525  bl 0x82facd10
	ctx.lr = 0x824327F0;
	sub_82FACD10(ctx, base);
	// 824327F0: 7C6B0734  extsh r11, r3
	ctx.r[11].s64 = ctx.r[3].s16 as i64;
	// 824327F4: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 824327F8: 807F00C0  lwz r3, 0xc0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 824327FC: 917F00D0  stw r11, 0xd0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[11].u32 ) };
	// 82432800: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82432804: 388A5900  addi r4, r10, 0x5900
	ctx.r[4].s64 = ctx.r[10].s64 + 22784;
	// 82432808: 48B7A509  bl 0x82facd10
	ctx.lr = 0x8243280C;
	sub_82FACD10(ctx, base);
	// 8243280C: 7C6B0734  extsh r11, r3
	ctx.r[11].s64 = ctx.r[3].s16 as i64;
	// 82432810: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 82432814: 807F00C0  lwz r3, 0xc0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 82432818: 917F00CC  stw r11, 0xcc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), ctx.r[11].u32 ) };
	// 8243281C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82432820: 388AF828  addi r4, r10, -0x7d8
	ctx.r[4].s64 = ctx.r[10].s64 + -2008;
	// 82432824: 48B7A4ED  bl 0x82facd10
	ctx.lr = 0x82432828;
	sub_82FACD10(ctx, base);
	// 82432828: 7C6B0734  extsh r11, r3
	ctx.r[11].s64 = ctx.r[3].s16 as i64;
	// 8243282C: 917F00D4  stw r11, 0xd4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), ctx.r[11].u32 ) };
	// 82432830: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 82432834: 48D75970  b 0x831a81a4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82432838(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82432838 size=360
    let mut pc: u32 = 0x82432838;
    'dispatch: loop {
        match pc {
            0x82432838 => {
    //   block [0x82432838..0x824329A0)
	// 82432838: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8243283C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82432840: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82432844: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82432848: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8243284C: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82432850: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82432854: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82432858: 388BF820  addi r4, r11, -0x7e0
	ctx.r[4].s64 = ctx.r[11].s64 + -2016;
	// 8243285C: 489C11AD  bl 0x82df3a08
	ctx.lr = 0x82432860;
	sub_82DF3A08(ctx, base);
	// 82432860: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82432864: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 82432868: 4BED2B81  bl 0x823053e8
	ctx.lr = 0x8243286C;
	sub_823053E8(ctx, base);
	// 8243286C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82432870: 4877B3F1  bl 0x82badc60
	ctx.lr = 0x82432874;
	sub_82BADC60(ctx, base);
	// 82432874: 7C6B0734  extsh r11, r3
	ctx.r[11].s64 = ctx.r[3].s16 as i64;
	// 82432878: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8243287C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82432880: 489C0BA9  bl 0x82df3428
	ctx.lr = 0x82432884;
	sub_82DF3428(ctx, base);
	// 82432884: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82432888: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8243288C: 388BF818  addi r4, r11, -0x7e8
	ctx.r[4].s64 = ctx.r[11].s64 + -2024;
	// 82432890: 489C1179  bl 0x82df3a08
	ctx.lr = 0x82432894;
	sub_82DF3A08(ctx, base);
	// 82432894: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82432898: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 8243289C: 4BED2B4D  bl 0x823053e8
	ctx.lr = 0x824328A0;
	sub_823053E8(ctx, base);
	// 824328A0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 824328A4: 4877B3BD  bl 0x82badc60
	ctx.lr = 0x824328A8;
	sub_82BADC60(ctx, base);
	// 824328A8: 7C6B0734  extsh r11, r3
	ctx.r[11].s64 = ctx.r[3].s16 as i64;
	// 824328AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 824328B0: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 824328B4: 489C0B75  bl 0x82df3428
	ctx.lr = 0x824328B8;
	sub_82DF3428(ctx, base);
	// 824328B8: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 824328BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 824328C0: 388B3EF8  addi r4, r11, 0x3ef8
	ctx.r[4].s64 = ctx.r[11].s64 + 16120;
	// 824328C4: 489C1145  bl 0x82df3a08
	ctx.lr = 0x824328C8;
	sub_82DF3A08(ctx, base);
	// 824328C8: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824328CC: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 824328D0: 4BED2B19  bl 0x823053e8
	ctx.lr = 0x824328D4;
	sub_823053E8(ctx, base);
	// 824328D4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 824328D8: 4877B389  bl 0x82badc60
	ctx.lr = 0x824328DC;
	sub_82BADC60(ctx, base);
	// 824328DC: 7C6B0734  extsh r11, r3
	ctx.r[11].s64 = ctx.r[3].s16 as i64;
	// 824328E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 824328E4: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 824328E8: 489C0B41  bl 0x82df3428
	ctx.lr = 0x824328EC;
	sub_82DF3428(ctx, base);
	// 824328EC: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 824328F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 824328F4: 388B3EE8  addi r4, r11, 0x3ee8
	ctx.r[4].s64 = ctx.r[11].s64 + 16104;
	// 824328F8: 489C1111  bl 0x82df3a08
	ctx.lr = 0x824328FC;
	sub_82DF3A08(ctx, base);
	// 824328FC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82432900: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 82432904: 4BED2AE5  bl 0x823053e8
	ctx.lr = 0x82432908;
	sub_823053E8(ctx, base);
	// 82432908: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8243290C: 4877B355  bl 0x82badc60
	ctx.lr = 0x82432910;
	sub_82BADC60(ctx, base);
	// 82432910: 7C6B0734  extsh r11, r3
	ctx.r[11].s64 = ctx.r[3].s16 as i64;
	// 82432914: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82432918: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 8243291C: 489C0B0D  bl 0x82df3428
	ctx.lr = 0x82432920;
	sub_82DF3428(ctx, base);
	// 82432920: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82432924: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82432928: 388B570C  addi r4, r11, 0x570c
	ctx.r[4].s64 = ctx.r[11].s64 + 22284;
	// 8243292C: 489C10DD  bl 0x82df3a08
	ctx.lr = 0x82432930;
	sub_82DF3A08(ctx, base);
	// 82432930: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82432934: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 82432938: 4BED2AB1  bl 0x823053e8
	ctx.lr = 0x8243293C;
	sub_823053E8(ctx, base);
	// 8243293C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82432940: 4877B321  bl 0x82badc60
	ctx.lr = 0x82432944;
	sub_82BADC60(ctx, base);
	// 82432944: 7C6B0734  extsh r11, r3
	ctx.r[11].s64 = ctx.r[3].s16 as i64;
	// 82432948: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8243294C: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82432950: 489C0AD9  bl 0x82df3428
	ctx.lr = 0x82432954;
	sub_82DF3428(ctx, base);
	// 82432954: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82432958: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8243295C: 388B5714  addi r4, r11, 0x5714
	ctx.r[4].s64 = ctx.r[11].s64 + 22292;
	// 82432960: 489C10A9  bl 0x82df3a08
	ctx.lr = 0x82432964;
	sub_82DF3A08(ctx, base);
	// 82432964: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82432968: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 8243296C: 4BED2A7D  bl 0x823053e8
	ctx.lr = 0x82432970;
	sub_823053E8(ctx, base);
	// 82432970: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82432974: 4877B2ED  bl 0x82badc60
	ctx.lr = 0x82432978;
	sub_82BADC60(ctx, base);
	// 82432978: 7C6B0734  extsh r11, r3
	ctx.r[11].s64 = ctx.r[3].s16 as i64;
	// 8243297C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82432980: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82432984: 489C0AA5  bl 0x82df3428
	ctx.lr = 0x82432988;
	sub_82DF3428(ctx, base);
	// 82432988: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8243298C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82432990: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82432994: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82432998: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8243299C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824329A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824329A0 size=120
    let mut pc: u32 = 0x824329A0;
    'dispatch: loop {
        match pc {
            0x824329A0 => {
    //   block [0x824329A0..0x82432A18)
	// 824329A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824329A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824329A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824329AC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824329B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824329B4: 4BFFA15D  bl 0x8242cb10
	ctx.lr = 0x824329B8;
	sub_8242CB10(ctx, base);
	// 824329B8: 3D408203  lis r10, -0x7dfd
	ctx.r[10].s64 = -2113732608;
	// 824329BC: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 824329C0: 3D008202  lis r8, -0x7dfe
	ctx.r[8].s64 = -2113798144;
	// 824329C4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824329C8: 39085920  addi r8, r8, 0x5920
	ctx.r[8].s64 = ctx.r[8].s64 + 22816;
	// 824329CC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 824329D0: C1AA7BC4  lfs f13, 0x7bc4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(31684 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824329D4: C00908A4  lfs f0, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824329D8: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 824329DC: D1BF0018  stfs f13, 0x18(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 824329E0: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 824329E4: D01F0028  stfs f0, 0x28(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 824329E8: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 824329EC: D01F0044  stfs f0, 0x44(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 824329F0: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 824329F4: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 824329F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824329FC: 98FF0024  stb r7, 0x24(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[7].u8 ) };
	// 82432A00: 997F0040  stb r11, 0x40(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[11].u8 ) };
	// 82432A04: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82432A08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82432A0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82432A10: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82432A14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82432A18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82432A18 size=8892
    let mut pc: u32 = 0x82432A18;
    'dispatch: loop {
        match pc {
            0x82432A18 => {
    //   block [0x82432A18..0x82434CD4)
	// 82432A18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82432A1C: 48D75715  bl 0x831a8130
	ctx.lr = 0x82432A20;
	sub_831A8130(ctx, base);
	// 82432A20: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 82432A24: 48D76041  bl 0x831a8a64
	ctx.lr = 0x82432A28;
	sub_831A8A40(ctx, base);
	// 82432A28: 3981FF20  addi r12, r1, -0xe0
	ctx.r[12].s64 = ctx.r[1].s64 + -224;
	// 82432A2C: 48D781A9  bl 0x831aabd4
	ctx.lr = 0x82432A30;
	sub_831AA9A0(ctx, base);
	// 82432A30: 9421FB80  stwu r1, -0x480(r1)
	ea = ctx.r[1].u32.wrapping_add(-1152 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82432A34: 7C741B78  mr r20, r3
	ctx.r[20].u64 = ctx.r[3].u64;
	// 82432A38: 80740004  lwz r3, 4(r20)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(4 as u32) ) } as u64;
	// 82432A3C: 4BF74785  bl 0x823a71c0
	ctx.lr = 0x82432A40;
	sub_823A71C0(ctx, base);
	// 82432A40: 80740004  lwz r3, 4(r20)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(4 as u32) ) } as u64;
	// 82432A44: 4BED29A5  bl 0x823053e8
	ctx.lr = 0x82432A48;
	sub_823053E8(ctx, base);
	// 82432A48: 486B0E49  bl 0x82ae3890
	ctx.lr = 0x82432A4C;
	sub_82AE3890(ctx, base);
	// 82432A4C: 81740004  lwz r11, 4(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(4 as u32) ) } as u64;
	// 82432A50: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 82432A54: 3CA08200  lis r5, -0x7e00
	ctx.r[5].s64 = -2113929216;
	// 82432A58: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82432A5C: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82432A60: 808B07C4  lwz r4, 0x7c4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1988 as u32) ) } as u64;
	// 82432A64: 3D408212  lis r10, -0x7dee
	ctx.r[10].s64 = -2112749568;
	// 82432A68: 3CE08212  lis r7, -0x7dee
	ctx.r[7].s64 = -2112749568;
	// 82432A6C: C3E608A4  lfs f31, 0x8a4(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82432A70: 3BA9C5A0  addi r29, r9, -0x3a60
	ctx.r[29].s64 = ctx.r[9].s64 + -14944;
	// 82432A74: C38508A8  lfs f28, 0x8a8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(2216 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82432A78: 3B28C5B0  addi r25, r8, -0x3a50
	ctx.r[25].s64 = ctx.r[8].s64 + -14928;
	// 82432A7C: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 82432A80: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82432A84: 3A000010  li r16, 0x10
	ctx.r[16].s64 = 16;
	// 82432A88: 93210058  stw r25, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[25].u32 ) };
	// 82432A8C: 3AE00020  li r23, 0x20
	ctx.r[23].s64 = 32;
	// 82432A90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82432A94: 2F040023  cmpwi cr6, r4, 0x23
	ctx.cr[6].compare_i32(ctx.r[4].s32, 35, &mut ctx.xer);
	// 82432A98: 39CAFFA0  addi r14, r10, -0x60
	ctx.r[14].s64 = ctx.r[10].s64 + -96;
	// 82432A9C: 3A470010  addi r18, r7, 0x10
	ctx.r[18].s64 = ctx.r[7].s64 + 16;
	// 82432AA0: 409A0F50  bne cr6, 0x824339f0
	if !ctx.cr[6].eq {
	pc = 0x824339F0; continue 'dispatch;
	}
	// 82432AA4: 89540024  lbz r10, 0x24(r20)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[20].u32.wrapping_add(36 as u32) ) } as u64;
	// 82432AA8: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82432AAC: 41820F44  beq 0x824339f0
	if ctx.cr[0].eq {
	pc = 0x824339F0; continue 'dispatch;
	}
	// 82432AB0: B3610050  sth r27, 0x50(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u16 ) };
	// 82432AB4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82432AB8: 386B03B0  addi r3, r11, 0x3b0
	ctx.r[3].s64 = ctx.r[11].s64 + 944;
	// 82432ABC: FF40E090  fmr f26, f28
	ctx.f[26].f64 = ctx.f[28].f64;
	// 82432AC0: FF20E090  fmr f25, f28
	ctx.f[25].f64 = ctx.f[28].f64;
	// 82432AC4: FF00E090  fmr f24, f28
	ctx.f[24].f64 = ctx.f[28].f64;
	// 82432AC8: FEE0E090  fmr f23, f28
	ctx.f[23].f64 = ctx.f[28].f64;
	// 82432ACC: 4877FC75  bl 0x82bb2740
	ctx.lr = 0x82432AD0;
	sub_82BB2740(ctx, base);
	// 82432AD0: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82432AD4: 480033FD  bl 0x82435ed0
	ctx.lr = 0x82432AD8;
	sub_82435ED0(ctx, base);
	// 82432AD8: 8094000C  lwz r4, 0xc(r20)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(12 as u32) ) } as u64;
	// 82432ADC: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82432AE0: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 82432AE4: 548A103A  slwi r10, r4, 2
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82432AE8: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82432AEC: 556B07BD  rlwinm. r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82432AF0: 40820014  bne 0x82432b04
	if !ctx.cr[0].eq {
	pc = 0x82432B04; continue 'dispatch;
	}
	// 82432AF4: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82432AF8: 1D440030  mulli r10, r4, 0x30
	ctx.r[10].s64 = ctx.r[4].s64 * 48;
	// 82432AFC: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82432B00: 4800000C  b 0x82432b0c
	pc = 0x82432B0C; continue 'dispatch;
	// 82432B04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82432B08: 48B7BC71  bl 0x82fae778
	ctx.lr = 0x82432B0C;
	sub_82FAE778(ctx, base);
	// 82432B0C: 396100B0  addi r11, r1, 0xb0
	ctx.r[11].s64 = ctx.r[1].s64 + 176;
	// 82432B10: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82432B14: 80940008  lwz r4, 8(r20)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(8 as u32) ) } as u64;
	// 82432B18: 548A103A  slwi r10, r4, 2
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82434CD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82434CD8 size=64
    let mut pc: u32 = 0x82434CD8;
    'dispatch: loop {
        match pc {
            0x82434CD8 => {
    //   block [0x82434CD8..0x82434D18)
	// 82434CD8: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82434CDC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82434CE0: 91440008  stw r10, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82434CE4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82434CE8: 892A0011  lbz r9, 0x11(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(17 as u32) ) } as u64;
	// 82434CEC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82434CF0: 409A0008  bne cr6, 0x82434cf8
	if !ctx.cr[6].eq {
	pc = 0x82434CF8; continue 'dispatch;
	}
	// 82434CF4: 908A0004  stw r4, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 82434CF8: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82434CFC: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82434D00: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82434D04: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82434D08: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82434D0C: 409A000C  bne cr6, 0x82434d18
	if !ctx.cr[6].eq {
		sub_82434D18(ctx, base);
		return;
	}
	// 82434D10: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82434D14: 48000020  b 0x82434d34
	sub_82434D30(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82434D18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82434D18 size=24
    let mut pc: u32 = 0x82434D18;
    'dispatch: loop {
        match pc {
            0x82434D18 => {
    //   block [0x82434D18..0x82434D30)
	// 82434D18: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82434D1C: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82434D20: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82434D24: 409A000C  bne cr6, 0x82434d30
	if !ctx.cr[6].eq {
		sub_82434D30(ctx, base);
		return;
	}
	// 82434D28: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82434D2C: 48000008  b 0x82434d34
	sub_82434D30(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82434D30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82434D30 size=16
    let mut pc: u32 = 0x82434D30;
    'dispatch: loop {
        match pc {
            0x82434D30 => {
    //   block [0x82434D30..0x82434D40)
	// 82434D30: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82434D34: 908B0000  stw r4, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 82434D38: 91640004  stw r11, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82434D3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82434D40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82434D40 size=24
    let mut pc: u32 = 0x82434D40;
    'dispatch: loop {
        match pc {
            0x82434D40 => {
    //   block [0x82434D40..0x82434D58)
	// 82434D40: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82434D44: 894B0011  lbz r10, 0x11(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(17 as u32) ) } as u64;
	// 82434D48: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82434D4C: 419A000C  beq cr6, 0x82434d58
	if ctx.cr[6].eq {
		sub_82434D58(ctx, base);
		return;
	}
	// 82434D50: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82434D54: 48000070  b 0x82434dc4
	sub_82434DC4(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82434D58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82434D58 size=24
    let mut pc: u32 = 0x82434D58;
    'dispatch: loop {
        match pc {
            0x82434D58 => {
    //   block [0x82434D58..0x82434D70)
	// 82434D58: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82434D5C: 892A0011  lbz r9, 0x11(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(17 as u32) ) } as u64;
	// 82434D60: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82434D64: 409A0040  bne cr6, 0x82434da4
	if !ctx.cr[6].eq {
		sub_82434D8C(ctx, base);
		return;
	}
	// 82434D68: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82434D6C: 4800000C  b 0x82434d78
	sub_82434D70(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82434D70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82434D70 size=28
    let mut pc: u32 = 0x82434D70;
    'dispatch: loop {
        match pc {
            0x82434D70 => {
    //   block [0x82434D70..0x82434D8C)
	// 82434D70: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82434D74: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82434D78: 892B0011  lbz r9, 0x11(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(17 as u32) ) } as u64;
	// 82434D7C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82434D80: 419AFFF0  beq cr6, 0x82434d70
	if ctx.cr[6].eq {
	pc = 0x82434D70; continue 'dispatch;
	}
	// 82434D84: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82434D88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82434D8C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82434D8C size=56
    let mut pc: u32 = 0x82434D8C;
    'dispatch: loop {
        match pc {
            0x82434D8C => {
    //   block [0x82434D8C..0x82434DC4)
	// 82434D8C: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82434D90: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82434D94: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82434D98: 409A001C  bne cr6, 0x82434db4
	if !ctx.cr[6].eq {
	pc = 0x82434DB4; continue 'dispatch;
	}
	// 82434D9C: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82434DA0: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82434DA4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82434DA8: 894B0011  lbz r10, 0x11(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(17 as u32) ) } as u64;
	// 82434DAC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82434DB0: 419AFFDC  beq cr6, 0x82434d8c
	if ctx.cr[6].eq {
	pc = 0x82434D8C; continue 'dispatch;
	}
	// 82434DB4: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82434DB8: 894A0011  lbz r10, 0x11(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(17 as u32) ) } as u64;
	// 82434DBC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82434DC0: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82434DC4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82434DC4 size=8
    let mut pc: u32 = 0x82434DC4;
    'dispatch: loop {
        match pc {
            0x82434DC4 => {
    //   block [0x82434DC4..0x82434DCC)
	// 82434DC4: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82434DC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82434DD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82434DD0 size=100
    let mut pc: u32 = 0x82434DD0;
    'dispatch: loop {
        match pc {
            0x82434DD0 => {
    //   block [0x82434DD0..0x82434E34)
	// 82434DD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82434DD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82434DD8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82434DDC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82434DE0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82434DE4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82434DE8: 4BED0601  bl 0x823053e8
	ctx.lr = 0x82434DEC;
	sub_823053E8(ctx, base);
	// 82434DEC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82434DF0: 41820030  beq 0x82434e20
	if ctx.cr[0].eq {
	pc = 0x82434E20; continue 'dispatch;
	}
	// 82434DF4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82434DF8: 4BED05F1  bl 0x823053e8
	ctx.lr = 0x82434DFC;
	sub_823053E8(ctx, base);
	// 82434DFC: 48777A0D  bl 0x82bac808
	ctx.lr = 0x82434E00;
	sub_82BAC808(ctx, base);
	// 82434E00: 483B5469  bl 0x827ea268
	ctx.lr = 0x82434E04;
	sub_827EA268(ctx, base);
	// 82434E04: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82434E08: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82434E0C: 388B5944  addi r4, r11, 0x5944
	ctx.r[4].s64 = ctx.r[11].s64 + 22852;
	// 82434E10: 48B77F01  bl 0x82facd10
	ctx.lr = 0x82434E14;
	sub_82FACD10(ctx, base);
	// 82434E14: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82434E18: 4BED05D1  bl 0x823053e8
	ctx.lr = 0x82434E1C;
	sub_823053E8(ctx, base);
	// 82434E1C: 486AEA75  bl 0x82ae3890
	ctx.lr = 0x82434E20;
	sub_82AE3890(ctx, base);
	// 82434E20: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82434E24: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82434E28: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82434E2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82434E30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82434E38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82434E38 size=108
    let mut pc: u32 = 0x82434E38;
    'dispatch: loop {
        match pc {
            0x82434E38 => {
    //   block [0x82434E38..0x82434EA4)
	// 82434E38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82434E3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82434E40: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82434E44: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82434E48: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82434E4C: 38C00014  li r6, 0x14
	ctx.r[6].s64 = 20;
	// 82434E50: 388A08B0  addi r4, r10, 0x8b0
	ctx.r[4].s64 = ctx.r[10].s64 + 2224;
	// 82434E54: 38A0002D  li r5, 0x2d
	ctx.r[5].s64 = 45;
	// 82434E58: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 82434E5C: 489BD26D  bl 0x82df20c8
	ctx.lr = 0x82434E60;
	sub_82DF20C8(ctx, base);
	// 82434E60: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82434E64: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82434E68: 41820008  beq 0x82434e70
	if ctx.cr[0].eq {
	pc = 0x82434E70; continue 'dispatch;
	}
	// 82434E6C: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82434E70: 35630004  addic. r11, r3, 4
	ctx.xer.ca = (ctx.r[3].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82434E74: 41820008  beq 0x82434e7c
	if ctx.cr[0].eq {
	pc = 0x82434E7C; continue 'dispatch;
	}
	// 82434E78: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82434E7C: 35630008  addic. r11, r3, 8
	ctx.xer.ca = (ctx.r[3].u32 > (!(8 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 8;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82434E80: 41820008  beq 0x82434e88
	if ctx.cr[0].eq {
	pc = 0x82434E88; continue 'dispatch;
	}
	// 82434E84: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82434E88: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82434E8C: 99430011  stb r10, 0x11(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(17 as u32), ctx.r[10].u8 ) };
	// 82434E90: 99630010  stb r11, 0x10(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u8 ) };
	// 82434E94: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82434E98: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82434E9C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82434EA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82434EA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82434EA8 size=124
    let mut pc: u32 = 0x82434EA8;
    'dispatch: loop {
        match pc {
            0x82434EA8 => {
    //   block [0x82434EA8..0x82434F24)
	// 82434EA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82434EAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82434EB0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82434EB4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82434EB8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82434EBC: 4BFF7C55  bl 0x8242cb10
	ctx.lr = 0x82434EC0;
	sub_8242CB10(ctx, base);
	// 82434EC0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82434EC4: 3D208202  lis r9, -0x7dfe
	ctx.r[9].s64 = -2113798144;
	// 82434EC8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82434ECC: 39295950  addi r9, r9, 0x5950
	ctx.r[9].s64 = ctx.r[9].s64 + 22864;
	// 82434ED0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82434ED4: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82434ED8: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82434EDC: D01F0030  stfs f0, 0x30(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82434EE0: 917F003C  stw r11, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 82434EE4: 917F0040  stw r11, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 82434EE8: 917F0044  stw r11, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[11].u32 ) };
	// 82434EEC: 917F0048  stw r11, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 82434EF0: 917F0060  stw r11, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82434EF4: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82434EF8: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82434EFC: 917F006C  stw r11, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82434F00: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82434F04: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82434F08: 917F0078  stw r11, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82434F0C: 917F007C  stw r11, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82434F10: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82434F14: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82434F18: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82434F1C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82434F20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82434F28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82434F28 size=148
    let mut pc: u32 = 0x82434F28;
    'dispatch: loop {
        match pc {
            0x82434F28 => {
    //   block [0x82434F28..0x82434FBC)
	// 82434F28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82434F2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82434F30: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82434F34: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82434F38: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82434F3C: 807F007C  lwz r3, 0x7c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82434F40: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82434F44: 419A0008  beq cr6, 0x82434f4c
	if ctx.cr[6].eq {
	pc = 0x82434F4C; continue 'dispatch;
	}
	// 82434F48: 4BE8B949  bl 0x822c0890
	ctx.lr = 0x82434F4C;
	sub_822C0890(ctx, base);
	// 82434F4C: 807F0074  lwz r3, 0x74(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82434F50: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82434F54: 419A0008  beq cr6, 0x82434f5c
	if ctx.cr[6].eq {
	pc = 0x82434F5C; continue 'dispatch;
	}
	// 82434F58: 4BE8B939  bl 0x822c0890
	ctx.lr = 0x82434F5C;
	sub_822C0890(ctx, base);
	// 82434F5C: 807F006C  lwz r3, 0x6c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82434F60: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82434F64: 419A0008  beq cr6, 0x82434f6c
	if ctx.cr[6].eq {
	pc = 0x82434F6C; continue 'dispatch;
	}
	// 82434F68: 4BE8B929  bl 0x822c0890
	ctx.lr = 0x82434F6C;
	sub_822C0890(ctx, base);
	// 82434F6C: 807F0064  lwz r3, 0x64(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82434F70: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82434F74: 419A0008  beq cr6, 0x82434f7c
	if ctx.cr[6].eq {
	pc = 0x82434F7C; continue 'dispatch;
	}
	// 82434F78: 4BE8B919  bl 0x822c0890
	ctx.lr = 0x82434F7C;
	sub_822C0890(ctx, base);
	// 82434F7C: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82434F80: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82434F84: 419A0008  beq cr6, 0x82434f8c
	if ctx.cr[6].eq {
	pc = 0x82434F8C; continue 'dispatch;
	}
	// 82434F88: 4BE8B909  bl 0x822c0890
	ctx.lr = 0x82434F8C;
	sub_822C0890(ctx, base);
	// 82434F8C: 807F0040  lwz r3, 0x40(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82434F90: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82434F94: 419A0008  beq cr6, 0x82434f9c
	if ctx.cr[6].eq {
	pc = 0x82434F9C; continue 'dispatch;
	}
	// 82434F98: 4BE8B8F9  bl 0x822c0890
	ctx.lr = 0x82434F9C;
	sub_822C0890(ctx, base);
	// 82434F9C: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82434FA0: 396B55C8  addi r11, r11, 0x55c8
	ctx.r[11].s64 = ctx.r[11].s64 + 21960;
	// 82434FA4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82434FA8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82434FAC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82434FB0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82434FB4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82434FB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82434FC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82434FC0 size=76
    let mut pc: u32 = 0x82434FC0;
    'dispatch: loop {
        match pc {
            0x82434FC0 => {
    //   block [0x82434FC0..0x8243500C)
	// 82434FC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82434FC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82434FC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82434FCC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82434FD0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82434FD4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82434FD8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82434FDC: 4BFFFF4D  bl 0x82434f28
	ctx.lr = 0x82434FE0;
	sub_82434F28(ctx, base);
	// 82434FE0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82434FE4: 4182000C  beq 0x82434ff0
	if ctx.cr[0].eq {
	pc = 0x82434FF0; continue 'dispatch;
	}
	// 82434FE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82434FEC: 489BD3ED  bl 0x82df23d8
	ctx.lr = 0x82434FF0;
	sub_82DF23D8(ctx, base);
	// 82434FF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82434FF4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82434FF8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82434FFC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82435000: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82435004: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82435008: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82435010(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82435010 size=88
    let mut pc: u32 = 0x82435010;
    'dispatch: loop {
        match pc {
            0x82435010 => {
    //   block [0x82435010..0x82435068)
	// 82435010: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82435014: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82435018: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8243501C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82435020: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82435024: 4BFFFE15  bl 0x82434e38
	ctx.lr = 0x82435028;
	sub_82434E38(ctx, base);
	// 82435028: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8243502C: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82435030: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82435034: 99630011  stb r11, 0x11(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(17 as u32), ctx.r[11].u8 ) };
	// 82435038: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8243503C: 916B0004  stw r11, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82435040: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82435044: 916B0000  stw r11, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82435048: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8243504C: 916B0008  stw r11, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82435050: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82435054: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82435058: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8243505C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82435060: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82435064: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82435068(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82435068 size=888
    let mut pc: u32 = 0x82435068;
    'dispatch: loop {
        match pc {
            0x82435068 => {
    //   block [0x82435068..0x824353E0)
	// 82435068: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8243506C: 48D730DD  bl 0x831a8148
	ctx.lr = 0x82435070;
	sub_831A8130(ctx, base);
	// 82435070: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82435074: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82435078: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8243507C: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82435080: 3D008202  lis r8, -0x7dfe
	ctx.r[8].s64 = -2113798144;
	// 82435084: 3CE08209  lis r7, -0x7df7
	ctx.r[7].s64 = -2113339392;
	// 82435088: C08AD7BC  lfs f4, -0x2844(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 8243508C: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 82435090: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82435094: C0AB6150  lfs f5, 0x6150(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82435098: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8243509C: C0E9A2EC  lfs f7, -0x5d14(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-23828 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 824350A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824350A4: C0C85918  lfs f6, 0x5918(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(22808 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 824350A8: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 824350AC: C067ACFC  lfs f3, -0x5304(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-21252 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 824350B0: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 824350B4: C00608A4  lfs f0, 0x8a4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824350B8: 397F0050  addi r11, r31, 0x50
	ctx.r[11].s64 = ctx.r[31].s64 + 80;
	// 824350BC: C1AA08A8  lfs f13, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824350C0: 389F0070  addi r4, r31, 0x70
	ctx.r[4].s64 = ctx.r[31].s64 + 112;
	// 824350C4: 93A10074  stw r29, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[29].u32 ) };
	// 824350C8: 38BF0078  addi r5, r31, 0x78
	ctx.r[5].s64 = ctx.r[31].s64 + 120;
	// 824350CC: D01F0050  stfs f0, 0x50(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 824350D0: D01F0054  stfs f0, 0x54(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 824350D4: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 824350D8: D01F0058  stfs f0, 0x58(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 824350DC: FC402890  fmr f2, f5
	ctx.f[2].f64 = ctx.f[5].f64;
	// 824350E0: D1BF005C  stfs f13, 0x5c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 824350E4: FC202090  fmr f1, f4
	ctx.f[1].f64 = ctx.f[4].f64;
	// 824350E8: 4BFF8061  bl 0x8242d148
	ctx.lr = 0x824350EC;
	sub_8242D148(ctx, base);
	// 824350EC: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 824350F0: 39400008  li r10, 8
	ctx.r[10].s64 = 8;
	// 824350F4: 93C10098  stw r30, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[30].u32 ) };
	// 824350F8: 916100A0  stw r11, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 824350FC: 3B800010  li r28, 0x10
	ctx.r[28].s64 = 16;
	// 82435100: 916100B8  stw r11, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[11].u32 ) };
	// 82435104: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82435108: 916100C4  stw r11, 0xc4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 8243510C: 38A10098  addi r5, r1, 0x98
	ctx.r[5].s64 = ctx.r[1].s64 + 152;
	// 82435110: 93C1009C  stw r30, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[30].u32 ) };
	// 82435114: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 82435118: 93C100B0  stw r30, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[30].u32 ) };
	// 8243511C: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82435120: 93C100B4  stw r30, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[30].u32 ) };
	// 82435124: 93C100BC  stw r30, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[30].u32 ) };
	// 82435128: 93C100C0  stw r30, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[30].u32 ) };
	// 8243512C: 9141008C  stw r10, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[10].u32 ) };
	// 82435130: 93810090  stw r28, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[28].u32 ) };
	// 82435134: 817F0070  lwz r11, 0x70(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82435138: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 8243513C: 48B2AADD  bl 0x82f5fc18
	ctx.lr = 0x82435140;
	sub_82F5FC18(ctx, base);
	// 82435140: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82435144: 814100B0  lwz r10, 0xb0(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 82435148: 3B400014  li r26, 0x14
	ctx.r[26].s64 = 20;
	// 8243514C: 93810090  stw r28, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[28].u32 ) };
	// 82435150: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 82435154: 836D0000  lwz r27, 0(r13)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82435158: 38800060  li r4, 0x60
	ctx.r[4].s64 = 96;
	// 8243515C: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 82435160: 91410088  stw r10, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[10].u32 ) };
	// 82435164: 7C7AD82E  lwzx r3, r26, r27
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 82435168: 48A6B5C9  bl 0x82ea0730
	ctx.lr = 0x8243516C;
	sub_82EA0730(ctx, base);
	// 8243516C: 39600060  li r11, 0x60
	ctx.r[11].s64 = 96;
	// 82435170: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 82435174: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 82435178: 38A10098  addi r5, r1, 0x98
	ctx.r[5].s64 = ctx.r[1].s64 + 152;
	// 8243517C: 38810088  addi r4, r1, 0x88
	ctx.r[4].s64 = ctx.r[1].s64 + 136;
	// 82435180: C02AF614  lfs f1, -0x9ec(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-2540 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82435184: 48AE66FD  bl 0x82f1b880
	ctx.lr = 0x82435188;
	sub_82F1B880(ctx, base);
	// 82435188: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8243518C: 3A8B5960  addi r20, r11, 0x5960
	ctx.r[20].s64 = ctx.r[11].s64 + 22880;
	// 82435190: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82435194: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82435198: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 8243519C: 38A0005A  li r5, 0x5a
	ctx.r[5].s64 = 90;
	// 824351A0: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 824351A4: 4BE8B235  bl 0x822c03d8
	ctx.lr = 0x824351A8;
	sub_822C03D8(ctx, base);
	// 824351A8: 7C7C1B79  or. r28, r3, r3
	ctx.r[28].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 824351AC: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 824351B0: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 824351B4: 3EA08335  lis r21, -0x7ccb
	ctx.r[21].s64 = -2093678592;
	// 824351B8: 3AEB6910  addi r23, r11, 0x6910
	ctx.r[23].s64 = ctx.r[11].s64 + 26896;
	// 824351BC: 3ACABA80  addi r22, r10, -0x4580
	ctx.r[22].s64 = ctx.r[10].s64 + -17792;
	// 824351C0: 41820060  beq 0x82435220
	if ctx.cr[0].eq {
	pc = 0x82435220; continue 'dispatch;
	}
	// 824351C4: 93210070  stw r25, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[25].u32 ) };
	// 824351C8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 824351CC: 809567D4  lwz r4, 0x67d4(r21)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(26580 as u32) ) } as u64;
	// 824351D0: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 824351D4: 4BEAFD5D  bl 0x822e4f30
	ctx.lr = 0x824351D8;
	sub_822E4F30(ctx, base);
	// 824351D8: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 824351DC: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 824351E0: 4BEAFCE1  bl 0x822e4ec0
	ctx.lr = 0x824351E4;
	sub_822E4EC0(ctx, base);
	// 824351E4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 824351E8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 824351EC: E8990000  ld r4, 0(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) };
	// 824351F0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 824351F4: E8630000  ld r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 824351F8: 48057091  bl 0x8248c288
	ctx.lr = 0x824351FC;
	sub_8248C288(ctx, base);
	// 824351FC: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 82435200: 7EC7B378  mr r7, r22
	ctx.r[7].u64 = ctx.r[22].u64;
	// 82435204: 7EE6BB78  mr r6, r23
	ctx.r[6].u64 = ctx.r[23].u64;
	// 82435208: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 8243520C: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82435210: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82435214: 4805CF8D  bl 0x824921a0
	ctx.lr = 0x82435218;
	sub_824921A0(ctx, base);
	// 82435218: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8243521C: 48000008  b 0x82435224
	pc = 0x82435224; continue 'dispatch;
	// 82435220: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82435224: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 82435228: 4BEAFBC1  bl 0x822e4de8
	ctx.lr = 0x8243522C;
	sub_822E4DE8(ctx, base);
	// 8243522C: 57AB07FF  clrlwi. r11, r29, 0x1f
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82435230: 41820018  beq 0x82435248
	if ctx.cr[0].eq {
	pc = 0x82435248; continue 'dispatch;
	}
	// 82435234: 80610070  lwz r3, 0x70(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82435238: 57BD003C  rlwinm r29, r29, 0, 0, 0x1e
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 8243523C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82435240: 419A0008  beq cr6, 0x82435248
	if ctx.cr[6].eq {
	pc = 0x82435248; continue 'dispatch;
	}
	// 82435244: 4BEB3025  bl 0x822e8268
	ctx.lr = 0x82435248;
	sub_822E8268(ctx, base);
	// 82435248: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 8243524C: 4BEB1455  bl 0x822e66a0
	ctx.lr = 0x82435250;
	sub_822E66A0(ctx, base);
	// 82435250: 816100A0  lwz r11, 0xa0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) } as u64;
	// 82435254: 556A0001  rlwinm. r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82435258: 40820018  bne 0x82435270
	if !ctx.cr[0].eq {
	pc = 0x82435270; continue 'dispatch;
	}
	// 8243525C: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 82435260: 7C7AD82E  lwzx r3, r26, r27
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 82435264: 55652036  slwi r5, r11, 4
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82435268: 80810098  lwz r4, 0x98(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 8243526C: 48A6B545  bl 0x82ea07b0
	ctx.lr = 0x82435270;
	sub_82EA07B0(ctx, base);
	// 82435270: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 82435274: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82435278: 38A0005D  li r5, 0x5d
	ctx.r[5].s64 = 93;
	// 8243527C: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 82435280: 4BE8B159  bl 0x822c03d8
	ctx.lr = 0x82435284;
	sub_822C03D8(ctx, base);
	// 82435284: 7C7C1B79  or. r28, r3, r3
	ctx.r[28].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82435288: 4182008C  beq 0x82435314
	if ctx.cr[0].eq {
	pc = 0x82435314; continue 'dispatch;
	}
	// 8243528C: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 82435290: 7C7AD82E  lwzx r3, r26, r27
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 82435294: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 82435298: 48A6B499  bl 0x82ea0730
	ctx.lr = 0x8243529C;
	sub_82EA0730(ctx, base);
	// 8243529C: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 824352A0: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 824352A4: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 824352A8: C02AD1B8  lfs f1, -0x2e48(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-11848 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 824352AC: 48AE4F45  bl 0x82f1a1f0
	ctx.lr = 0x824352B0;
	sub_82F1A1F0(ctx, base);
	// 824352B0: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 824352B4: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 824352B8: 809567D4  lwz r4, 0x67d4(r21)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(26580 as u32) ) } as u64;
	// 824352BC: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 824352C0: 63BD0002  ori r29, r29, 2
	ctx.r[29].u64 = ctx.r[29].u64 | 2;
	// 824352C4: 80AB6838  lwz r5, 0x6838(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26680 as u32) ) } as u64;
	// 824352C8: 4BEC24D9  bl 0x822f77a0
	ctx.lr = 0x824352CC;
	sub_822F77A0(ctx, base);
	// 824352CC: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 824352D0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 824352D4: 4BEAFBED  bl 0x822e4ec0
	ctx.lr = 0x824352D8;
	sub_822E4EC0(ctx, base);
	// 824352D8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 824352DC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 824352E0: E89B0000  ld r4, 0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	// 824352E4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 824352E8: E8630000  ld r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 824352EC: 48056F9D  bl 0x8248c288
	ctx.lr = 0x824352F0;
	sub_8248C288(ctx, base);
	// 824352F0: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 824352F4: 7EC7B378  mr r7, r22
	ctx.r[7].u64 = ctx.r[22].u64;
	// 824352F8: 7EE6BB78  mr r6, r23
	ctx.r[6].u64 = ctx.r[23].u64;
	// 824352FC: 38A10074  addi r5, r1, 0x74
	ctx.r[5].s64 = ctx.r[1].s64 + 116;
	// 82435300: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82435304: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82435308: 4805CE99  bl 0x824921a0
	ctx.lr = 0x8243530C;
	sub_824921A0(ctx, base);
	// 8243530C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82435310: 48000008  b 0x82435318
	pc = 0x82435318; continue 'dispatch;
	// 82435314: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82435318: 387F0044  addi r3, r31, 0x44
	ctx.r[3].s64 = ctx.r[31].s64 + 68;
	// 8243531C: 4BEAFACD  bl 0x822e4de8
	ctx.lr = 0x82435320;
	sub_822E4DE8(ctx, base);
	// 82435320: 57AB07BD  rlwinm. r11, r29, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82435324: 41820018  beq 0x8243533c
	if ctx.cr[0].eq {
	pc = 0x8243533C; continue 'dispatch;
	}
	// 82435328: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 8243532C: 57BD07FA  rlwinm r29, r29, 0, 0x1f, 0x1d
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 82435330: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82435334: 419A0008  beq cr6, 0x8243533c
	if ctx.cr[6].eq {
	pc = 0x8243533C; continue 'dispatch;
	}
	// 82435338: 4BEB2F31  bl 0x822e8268
	ctx.lr = 0x8243533C;
	sub_822E8268(ctx, base);
	// 8243533C: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 82435340: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82435344: 38A0005F  li r5, 0x5f
	ctx.r[5].s64 = 95;
	// 82435348: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 8243534C: 4BE8B08D  bl 0x822c03d8
	ctx.lr = 0x82435350;
	sub_822C03D8(ctx, base);
	// 82435350: 7C7C1B79  or. r28, r3, r3
	ctx.r[28].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82435354: 41820028  beq 0x8243537c
	if ctx.cr[0].eq {
	pc = 0x8243537C; continue 'dispatch;
	}
	// 82435358: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 8243535C: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82435360: 63BD0004  ori r29, r29, 4
	ctx.r[29].u64 = ctx.r[29].u64 | 4;
	// 82435364: 4BF6BF65  bl 0x823a12c8
	ctx.lr = 0x82435368;
	sub_823A12C8(ctx, base);
	// 82435368: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8243536C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82435370: 4805BD81  bl 0x824910f0
	ctx.lr = 0x82435374;
	sub_824910F0(ctx, base);
	// 82435374: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82435378: 48000008  b 0x82435380
	pc = 0x82435380; continue 'dispatch;
	// 8243537C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82435380: 387F003C  addi r3, r31, 0x3c
	ctx.r[3].s64 = ctx.r[31].s64 + 60;
	// 82435384: 4BED535D  bl 0x8230a6e0
	ctx.lr = 0x82435388;
	sub_8230A6E0(ctx, base);
	// 82435388: 57AB077B  rlwinm. r11, r29, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8243538C: 4182000C  beq 0x82435398
	if ctx.cr[0].eq {
	pc = 0x82435398; continue 'dispatch;
	}
	// 82435390: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82435394: 489BC8FD  bl 0x82df1c90
	ctx.lr = 0x82435398;
	sub_82DF1C90(ctx, base);
	// 82435398: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8243539C: 4BED004D  bl 0x823053e8
	ctx.lr = 0x824353A0;
	sub_823053E8(ctx, base);
	// 824353A0: 48777469  bl 0x82bac808
	ctx.lr = 0x824353A4;
	sub_82BAC808(ctx, base);
	// 824353A4: 483B4EC5  bl 0x827ea268
	ctx.lr = 0x824353A8;
	sub_827EA268(ctx, base);
	// 824353A8: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 824353AC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 824353B0: 388B5734  addi r4, r11, 0x5734
	ctx.r[4].s64 = ctx.r[11].s64 + 22324;
	// 824353B4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 824353B8: 48B77959  bl 0x82facd10
	ctx.lr = 0x824353BC;
	sub_82FACD10(ctx, base);
	// 824353BC: B07F0080  sth r3, 0x80(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[3].u16 ) };
	// 824353C0: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 824353C4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 824353C8: 388B5724  addi r4, r11, 0x5724
	ctx.r[4].s64 = ctx.r[11].s64 + 22308;
	// 824353CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824353D0: 48B77941  bl 0x82facd10
	ctx.lr = 0x824353D4;
	sub_82FACD10(ctx, base);
	// 824353D4: B07F0082  sth r3, 0x82(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(130 as u32), ctx.r[3].u16 ) };
	// 824353D8: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 824353DC: 48D72DBC  b 0x831a8198
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824353E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824353E0 size=196
    let mut pc: u32 = 0x824353E0;
    'dispatch: loop {
        match pc {
            0x824353E0 => {
    //   block [0x824353E0..0x824354A4)
	// 824353E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824353E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824353E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824353EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824353F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824353F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 824353F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824353FC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82435400: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82435404: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82435408: 4BE8B531  bl 0x822c0938
	ctx.lr = 0x8243540C;
	sub_822C0938(ctx, base);
	// 8243540C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82435410: 41820028  beq 0x82435438
	if ctx.cr[0].eq {
	pc = 0x82435438; continue 'dispatch;
	}
	// 82435414: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82435418: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8243541C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82435420: 392B59D0  addi r9, r11, 0x59d0
	ctx.r[9].s64 = ctx.r[11].s64 + 22992;
	// 82435424: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82435428: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8243542C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82435430: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82435434: 48000008  b 0x8243543c
	pc = 0x8243543C; continue 'dispatch;
	// 82435438: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8243543C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82435440: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82435444: 409A0044  bne cr6, 0x82435488
	if !ctx.cr[6].eq {
	pc = 0x82435488; continue 'dispatch;
	}
	// 82435448: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8243544C: 419A001C  beq cr6, 0x82435468
	if ctx.cr[6].eq {
	pc = 0x82435468; continue 'dispatch;
	}
	// 82435450: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82435454: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82435458: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8243545C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82435460: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82435464: 4E800421  bctrl
	ctx.lr = 0x82435468;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82435468: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 8243546C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82435470: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82435474: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82435478: 816B20D4  lwz r11, 0x20d4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8404 as u32) ) } as u64;
	// 8243547C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82435480: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82435484: 4BE8AB7D  bl 0x822c0000
	ctx.lr = 0x82435488;
	sub_822C0000(ctx, base);
	// 82435488: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8243548C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82435490: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82435494: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82435498: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8243549C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824354A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824354A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824354A8 size=72
    let mut pc: u32 = 0x824354A8;
    'dispatch: loop {
        match pc {
            0x824354A8 => {
    //   block [0x824354A8..0x824354F0)
	// 824354A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824354AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824354B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824354B4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824354B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824354BC: 4BFF7655  bl 0x8242cb10
	ctx.lr = 0x824354C0;
	sub_8242CB10(ctx, base);
	// 824354C0: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 824354C4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824354C8: 394A59E4  addi r10, r10, 0x59e4
	ctx.r[10].s64 = ctx.r[10].s64 + 23012;
	// 824354CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824354D0: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 824354D4: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 824354D8: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 824354DC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 824354E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824354E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824354E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824354EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824354F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824354F0 size=100
    let mut pc: u32 = 0x824354F0;
    'dispatch: loop {
        match pc {
            0x824354F0 => {
    //   block [0x824354F0..0x82435554)
	// 824354F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824354F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824354F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824354FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82435500: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82435504: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82435508: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8243550C: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82435510: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82435514: 419A0008  beq cr6, 0x8243551c
	if ctx.cr[6].eq {
	pc = 0x8243551C; continue 'dispatch;
	}
	// 82435518: 4BE8B379  bl 0x822c0890
	ctx.lr = 0x8243551C;
	sub_822C0890(ctx, base);
	// 8243551C: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82435520: 57CA07FF  clrlwi. r10, r30, 0x1f
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82435524: 396B55C8  addi r11, r11, 0x55c8
	ctx.r[11].s64 = ctx.r[11].s64 + 21960;
	// 82435528: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8243552C: 4182000C  beq 0x82435538
	if ctx.cr[0].eq {
	pc = 0x82435538; continue 'dispatch;
	}
	// 82435530: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82435534: 489BCEA5  bl 0x82df23d8
	ctx.lr = 0x82435538;
	sub_82DF23D8(ctx, base);
	// 82435538: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8243553C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82435540: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82435544: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82435548: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8243554C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82435550: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82435558(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82435558 size=112
    let mut pc: u32 = 0x82435558;
    'dispatch: loop {
        match pc {
            0x82435558 => {
    //   block [0x82435558..0x824355C8)
	// 82435558: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8243555C: 48D72C11  bl 0x831a816c
	ctx.lr = 0x82435560;
	sub_831A8130(ctx, base);
	// 82435560: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82435564: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82435568: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8243556C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82435570: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82435574: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 82435578: 38600050  li r3, 0x50
	ctx.r[3].s64 = 80;
	// 8243557C: 489BCE6D  bl 0x82df23e8
	ctx.lr = 0x82435580;
	sub_82DF23E8(ctx, base);
	// 82435580: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82435584: 41820010  beq 0x82435594
	if ctx.cr[0].eq {
	pc = 0x82435594; continue 'dispatch;
	}
	// 82435588: 4871E4F1  bl 0x82b53a78
	ctx.lr = 0x8243558C;
	sub_82B53A78(ctx, base);
	// 8243558C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82435590: 48000008  b 0x82435598
	pc = 0x82435598; continue 'dispatch;
	// 82435594: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82435598: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8243559C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 824355A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 824355A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824355A8: 4BFFFE39  bl 0x824353e0
	ctx.lr = 0x824355AC;
	sub_824353E0(ctx, base);
	// 824355AC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 824355B0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 824355B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824355B8: 4BE8AA49  bl 0x822c0000
	ctx.lr = 0x824355BC;
	sub_822C0000(ctx, base);
	// 824355BC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 824355C0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824355C4: 48D72BF8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824355C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824355C8 size=1056
    let mut pc: u32 = 0x824355C8;
    'dispatch: loop {
        match pc {
            0x824355C8 => {
    //   block [0x824355C8..0x824359E8)
	// 824355C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824355CC: 48D72B99  bl 0x831a8164
	ctx.lr = 0x824355D0;
	sub_831A8130(ctx, base);
	// 824355D0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824355D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824355D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 824355DC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 824355E0: 4BFFFF79  bl 0x82435558
	ctx.lr = 0x824355E4;
	sub_82435558(ctx, base);
	// 824355E4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 824355E8: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824355EC: 4BED0485  bl 0x82305a70
	ctx.lr = 0x824355F0;
	sub_82305A70(ctx, base);
	// 824355F0: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 824355F4: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 824355F8: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 824355FC: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82435600: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82435604: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82435608: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824359E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824359E8 size=4
    let mut pc: u32 = 0x824359E8;
    'dispatch: loop {
        match pc {
            0x824359E8 => {
    //   block [0x824359E8..0x824359EC)
	// 824359E8: 4BFFFBE0  b 0x824355c8
	sub_824355C8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824359F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824359F0 size=596
    let mut pc: u32 = 0x824359F0;
    'dispatch: loop {
        match pc {
            0x824359F0 => {
    //   block [0x824359F0..0x82435C44)
	// 824359F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824359F4: 48D7275D  bl 0x831a8150
	ctx.lr = 0x824359F8;
	sub_831A8130(ctx, base);
	// 824359F8: 3980FF90  li r12, -0x70
	ctx.r[12].s64 = -112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82435C48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82435C48 size=364
    let mut pc: u32 = 0x82435C48;
    'dispatch: loop {
        match pc {
            0x82435C48 => {
    //   block [0x82435C48..0x82435DB4)
	// 82435C48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82435C4C: 48D72519  bl 0x831a8164
	ctx.lr = 0x82435C50;
	sub_831A8130(ctx, base);
	// 82435C50: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82435C54: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82435C58: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82435C5C: 810D0000  lwz r8, 0(r13)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82435C60: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 82435C64: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82435C68: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 82435C6C: 3BE10090  addi r31, r1, 0x90
	ctx.r[31].s64 = ctx.r[1].s64 + 144;
	// 82435C70: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82435C74: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82435C78: C00A5A50  lfs f0, 0x5a50(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(23120 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82435C7C: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 82435C80: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82435C84: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82435C88: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 82435C8C: C3EB027C  lfs f31, 0x27c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(636 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82435C90: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 82435C94: EDA0F828  fsubs f13, f0, f31
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 82435C98: C00908A4  lfs f0, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82435C9C: 7C6A402E  lwzx r3, r10, r8
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 82435CA0: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82435CA4: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82435CA8: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82435CAC: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82435CB0: 38800040  li r4, 0x40
	ctx.r[4].s64 = 64;
	// 82435CB4: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82435CB8: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82435CBC: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82435CC0: D1A10074  stfs f13, 0x74(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82435CC4: 13E038C7  vcmpequd (lvx128) v31, v0, v7
	tmp.u32 = ctx.r[7].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82435DB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82435DB8 size=104
    let mut pc: u32 = 0x82435DB8;
    'dispatch: loop {
        match pc {
            0x82435DB8 => {
    //   block [0x82435DB8..0x82435E20)
	// 82435DB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82435DBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82435DC0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82435DC4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82435DC8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82435DCC: 4BFF6D45  bl 0x8242cb10
	ctx.lr = 0x82435DD0;
	sub_8242CB10(ctx, base);
	// 82435DD0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82435DD4: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 82435DD8: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 82435DDC: 394A5A58  addi r10, r10, 0x5a58
	ctx.r[10].s64 = ctx.r[10].s64 + 23128;
	// 82435DE0: C00B08A8  lfs f0, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82435DE4: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82435DE8: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82435DEC: 489BD305  bl 0x82df30f0
	ctx.lr = 0x82435DF0;
	sub_82DF30F0(ctx, base);
	// 82435DF0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82435DF4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82435DF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82435DFC: 997F0010  stb r11, 0x10(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u8 ) };
	// 82435E00: 997F0011  stb r11, 0x11(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(17 as u32), ctx.r[11].u8 ) };
	// 82435E04: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82435E08: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82435E0C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82435E10: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82435E14: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82435E18: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82435E1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82435E20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82435E20 size=72
    let mut pc: u32 = 0x82435E20;
    'dispatch: loop {
        match pc {
            0x82435E20 => {
    //   block [0x82435E20..0x82435E68)
	// 82435E20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82435E24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82435E28: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82435E2C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82435E30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82435E34: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82435E38: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 82435E3C: 396B5A58  addi r11, r11, 0x5a58
	ctx.r[11].s64 = ctx.r[11].s64 + 23128;
	// 82435E40: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82435E44: 489BD5E5  bl 0x82df3428
	ctx.lr = 0x82435E48;
	sub_82DF3428(ctx, base);
	// 82435E48: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82435E4C: 396B55C8  addi r11, r11, 0x55c8
	ctx.r[11].s64 = ctx.r[11].s64 + 21960;
	// 82435E50: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82435E54: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82435E58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82435E5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82435E60: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82435E64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82435E68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82435E68 size=76
    let mut pc: u32 = 0x82435E68;
    'dispatch: loop {
        match pc {
            0x82435E68 => {
    //   block [0x82435E68..0x82435EB4)
	// 82435E68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82435E6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82435E70: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82435E74: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82435E78: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82435E7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82435E80: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82435E84: 4BFFFF9D  bl 0x82435e20
	ctx.lr = 0x82435E88;
	sub_82435E20(ctx, base);
	// 82435E88: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82435E8C: 4182000C  beq 0x82435e98
	if ctx.cr[0].eq {
	pc = 0x82435E98; continue 'dispatch;
	}
	// 82435E90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82435E94: 489BC545  bl 0x82df23d8
	ctx.lr = 0x82435E98;
	sub_82DF23D8(ctx, base);
	// 82435E98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82435E9C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82435EA0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82435EA4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82435EA8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82435EAC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82435EB0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82435EB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82435EB8 size=12
    let mut pc: u32 = 0x82435EB8;
    'dispatch: loop {
        match pc {
            0x82435EB8 => {
    //   block [0x82435EB8..0x82435EC4)
	// 82435EB8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82435EBC: 99630050  stb r11, 0x50(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 82435EC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82435EC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82435EC8 size=8
    let mut pc: u32 = 0x82435EC8;
    'dispatch: loop {
        match pc {
            0x82435EC8 => {
    //   block [0x82435EC8..0x82435ED0)
	// 82435EC8: D02300B4  stfs f1, 0xb4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82435ECC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82435ED0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82435ED0 size=8
    let mut pc: u32 = 0x82435ED0;
    'dispatch: loop {
        match pc {
            0x82435ED0 => {
    //   block [0x82435ED0..0x82435ED8)
	// 82435ED0: C02300B4  lfs f1, 0xb4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(180 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82435ED4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82435ED8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82435ED8 size=16
    let mut pc: u32 = 0x82435ED8;
    'dispatch: loop {
        match pc {
            0x82435ED8 => {
    //   block [0x82435ED8..0x82435EE8)
	// 82435ED8: 396000A0  li r11, 0xa0
	ctx.r[11].s64 = 160;
	// 82435EDC: 13E358C7  vcmpequd (lvx128) v31, v3, v11
	tmp.u32 = ctx.r[3].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82435EE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82435EE8 size=1124
    let mut pc: u32 = 0x82435EE8;
    'dispatch: loop {
        match pc {
            0x82435EE8 => {
    //   block [0x82435EE8..0x8243634C)
	// 82435EE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82435EEC: 48D72275  bl 0x831a8160
	ctx.lr = 0x82435EF0;
	sub_831A8130(ctx, base);
	// 82435EF0: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 82435EF4: 3980FF90  li r12, -0x70
	ctx.r[12].s64 = -112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82436350(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82436350 size=264
    let mut pc: u32 = 0x82436350;
    'dispatch: loop {
        match pc {
            0x82436350 => {
    //   block [0x82436350..0x82436458)
	// 82436350: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82436354: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82436358: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8243635C: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82436458(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82436458 size=1092
    let mut pc: u32 = 0x82436458;
    'dispatch: loop {
        match pc {
            0x82436458 => {
    //   block [0x82436458..0x8243689C)
	// 82436458: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8243645C: 48D71CF9  bl 0x831a8154
	ctx.lr = 0x82436460;
	sub_831A8130(ctx, base);
	// 82436460: 3981FFB0  addi r12, r1, -0x50
	ctx.r[12].s64 = ctx.r[1].s64 + -80;
	// 82436464: 48D72611  bl 0x831a8a74
	ctx.lr = 0x82436468;
	sub_831A8A40(ctx, base);
	// 82436468: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8243646C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82436470: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 82436474: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82436478: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8243647C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82436480: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 82436484: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82436488: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 8243648C: D3E10058  stfs f31, 0x58(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82436490: 7CF83B78  mr r24, r7
	ctx.r[24].u64 = ctx.r[7].u64;
	// 82436494: 7D174378  mr r23, r8
	ctx.r[23].u64 = ctx.r[8].u64;
	// 82436498: 4BF9FB11  bl 0x823d5fa8
	ctx.lr = 0x8243649C;
	sub_823D5FA8(ctx, base);
	// 8243649C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824364A0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 824364A4: D3E100A0  stfs f31, 0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 824364A8: D3E100A8  stfs f31, 0xa8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 824364AC: D3E100AC  stfs f31, 0xac(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 824364B0: C3ABD5B8  lfs f29, -0x2a48(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10824 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 824364B4: EF7EE82A  fadds f27, f30, f29
	ctx.f[27].f64 = ((ctx.f[30].f64 + ctx.f[29].f64) as f32) as f64;
	// 824364B8: C00A08A8  lfs f0, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824364BC: D00100A4  stfs f0, 0xa4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 824364C0: 83C10060  lwz r30, 0x60(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 824364C4: C01F00B8  lfs f0, 0xb8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824364C8: 83410064  lwz r26, 0x64(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 824364CC: FF1B0000  fcmpu cr6, f27, f0
	ctx.cr[6].compare_f64(ctx.f[27].f64, ctx.f[0].f64);
	// 824364D0: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 824364D4: 93410064  stw r26, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[26].u32 ) };
	// 824364D8: 40990038  ble cr6, 0x82436510
	if !ctx.cr[6].gt {
	pc = 0x82436510; continue 'dispatch;
	}
	// 824364DC: D01E0018  stfs f0, 0x18(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 824364E0: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 824364E4: 419A0024  beq cr6, 0x82436508
	if ctx.cr[6].eq {
	pc = 0x82436508; continue 'dispatch;
	}
	// 824364E8: 397A0004  addi r11, r26, 4
	ctx.r[11].s64 = ctx.r[26].s64 + 4;
	// 824364EC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 824364F0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 824364F4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 824364F8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 824364FC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82436500: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82436504: 4082FFE8  bne 0x824364ec
	if !ctx.cr[0].eq {
	pc = 0x824364EC; continue 'dispatch;
	}
	// 82436508: 38A0010F  li r5, 0x10f
	ctx.r[5].s64 = 271;
	// 8243650C: 48000034  b 0x82436540
	pc = 0x82436540; continue 'dispatch;
	// 82436510: D37E0018  stfs f27, 0x18(r30)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82436514: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82436518: 419A0024  beq cr6, 0x8243653c
	if ctx.cr[6].eq {
	pc = 0x8243653C; continue 'dispatch;
	}
	// 8243651C: 397A0004  addi r11, r26, 4
	ctx.r[11].s64 = ctx.r[26].s64 + 4;
	// 82436520: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82436524: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82436528: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8243652C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82436530: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82436534: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82436538: 4082FFE8  bne 0x82436520
	if !ctx.cr[0].eq {
	pc = 0x82436520; continue 'dispatch;
	}
	// 8243653C: 38A00115  li r5, 0x115
	ctx.r[5].s64 = 277;
	// 82436540: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82436544: 80DF00F0  lwz r6, 0xf0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 82436548: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 8243654C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82436550: 3BAB5A80  addi r29, r11, 0x5a80
	ctx.r[29].s64 = ctx.r[11].s64 + 23168;
	// 82436554: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82436558: 4BED18E1  bl 0x82307e38
	ctx.lr = 0x8243655C;
	sub_82307E38(ctx, base);
	// 8243655C: EF9EE828  fsubs f28, f30, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[28].f64 = (((ctx.f[30].f64 - ctx.f[29].f64) as f32) as f64);
	// 82436560: 3B9E0020  addi r28, r30, 0x20
	ctx.r[28].s64 = ctx.r[30].s64 + 32;
	// 82436564: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 82436568: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 8243656C: 93410064  stw r26, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[26].u32 ) };
	// 82436570: 13E0E0C7  vcmpequd (lvx128) v31, v0, v28
	tmp.u32 = ctx.r[28].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824368A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824368A0 size=492
    let mut pc: u32 = 0x824368A0;
    'dispatch: loop {
        match pc {
            0x824368A0 => {
    //   block [0x824368A0..0x82436A8C)
	// 824368A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824368A4: 48D718B9  bl 0x831a815c
	ctx.lr = 0x824368A8;
	sub_831A8130(ctx, base);
	// 824368A8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824368AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824368B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824368B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 824368B8: 997F0051  stb r11, 0x51(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(81 as u32), ctx.r[11].u8 ) };
	// 824368BC: 4BF9F66D  bl 0x823d5f28
	ctx.lr = 0x824368C0;
	sub_823D5F28(ctx, base);
	// 824368C0: 83210054  lwz r25, 0x54(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 824368C4: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 824368C8: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 824368CC: 93210054  stw r25, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[25].u32 ) };
	// 824368D0: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 824368D4: 419A0024  beq cr6, 0x824368f8
	if ctx.cr[6].eq {
	pc = 0x824368F8; continue 'dispatch;
	}
	// 824368D8: 39790004  addi r11, r25, 4
	ctx.r[11].s64 = ctx.r[25].s64 + 4;
	// 824368DC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 824368E0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 824368E4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 824368E8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 824368EC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 824368F0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 824368F4: 4082FFE8  bne 0x824368dc
	if !ctx.cr[0].eq {
	pc = 0x824368DC; continue 'dispatch;
	}
	// 824368F8: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 824368FC: 80DF00F0  lwz r6, 0xf0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 82436900: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82436904: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82436908: 3BCB5A80  addi r30, r11, 0x5a80
	ctx.r[30].s64 = ctx.r[11].s64 + 23168;
	// 8243690C: 38A00174  li r5, 0x174
	ctx.r[5].s64 = 372;
	// 82436910: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82436914: 4BED1525  bl 0x82307e38
	ctx.lr = 0x82436918;
	sub_82307E38(ctx, base);
	// 82436918: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8243691C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82436920: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82436924: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82436928: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8243692C: 4BF9F67D  bl 0x823d5fa8
	ctx.lr = 0x82436930;
	sub_823D5FA8(ctx, base);
	// 82436930: 389D0018  addi r4, r29, 0x18
	ctx.r[4].s64 = ctx.r[29].s64 + 24;
	// 82436934: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82436938: 4BF9F671  bl 0x823d5fa8
	ctx.lr = 0x8243693C;
	sub_823D5FA8(ctx, base);
	// 8243693C: 83610064  lwz r27, 0x64(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82436940: 83410060  lwz r26, 0x60(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82436944: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82436948: 93610064  stw r27, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[27].u32 ) };
	// 8243694C: 93410060  stw r26, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[26].u32 ) };
	// 82436950: 419A0024  beq cr6, 0x82436974
	if ctx.cr[6].eq {
	pc = 0x82436974; continue 'dispatch;
	}
	// 82436954: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 82436958: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8243695C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82436960: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82436964: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82436968: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8243696C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82436970: 4082FFE8  bne 0x82436958
	if !ctx.cr[0].eq {
	pc = 0x82436958; continue 'dispatch;
	}
	// 82436974: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82436978: 80DF00F0  lwz r6, 0xf0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 8243697C: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 82436980: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82436984: 38A0017A  li r5, 0x17a
	ctx.r[5].s64 = 378;
	// 82436988: 4BED14B1  bl 0x82307e38
	ctx.lr = 0x8243698C;
	sub_82307E38(ctx, base);
	// 8243698C: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82436990: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82436994: 418200C0  beq 0x82436a54
	if ctx.cr[0].eq {
	pc = 0x82436A54; continue 'dispatch;
	}
	// 82436998: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8243699C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 824369A0: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 824369A4: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 824369A8: 419A0024  beq cr6, 0x824369cc
	if ctx.cr[6].eq {
	pc = 0x824369CC; continue 'dispatch;
	}
	// 824369AC: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 824369B0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 824369B4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 824369B8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 824369BC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 824369C0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 824369C4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 824369C8: 4082FFE8  bne 0x824369b0
	if !ctx.cr[0].eq {
	pc = 0x824369B0; continue 'dispatch;
	}
	// 824369CC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 824369D0: 80DF00F0  lwz r6, 0xf0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 824369D4: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 824369D8: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824369DC: 38A0017A  li r5, 0x17a
	ctx.r[5].s64 = 378;
	// 824369E0: 4BED1459  bl 0x82307e38
	ctx.lr = 0x824369E4;
	sub_82307E38(ctx, base);
	// 824369E4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824369E8: 4182006C  beq 0x82436a54
	if ctx.cr[0].eq {
	pc = 0x82436A54; continue 'dispatch;
	}
	// 824369EC: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82436A90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82436A90 size=800
    let mut pc: u32 = 0x82436A90;
    'dispatch: loop {
        match pc {
            0x82436A90 => {
    //   block [0x82436A90..0x82436DB0)
	// 82436A90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82436A94: 48D716C5  bl 0x831a8158
	ctx.lr = 0x82436A98;
	sub_831A8130(ctx, base);
	// 82436A98: DBE1FFB0  stfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 82436A9C: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82436AA0: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82436AA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82436AA8: 548B063F  clrlwi. r11, r4, 0x18
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82436AAC: C3EAA9F0  lfs f31, -0x5610(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-22032 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82436AB0: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82436AB4: 4182017C  beq 0x82436c30
	if ctx.cr[0].eq {
	pc = 0x82436C30; continue 'dispatch;
	}
	// 82436AB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82436ABC: 4BF9F46D  bl 0x823d5f28
	ctx.lr = 0x82436AC0;
	sub_823D5F28(ctx, base);
	// 82436AC0: 83010054  lwz r24, 0x54(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82436AC4: 83810050  lwz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82436AC8: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 82436ACC: 93010054  stw r24, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[24].u32 ) };
	// 82436AD0: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82436AD4: 419A0024  beq cr6, 0x82436af8
	if ctx.cr[6].eq {
	pc = 0x82436AF8; continue 'dispatch;
	}
	// 82436AD8: 39780004  addi r11, r24, 4
	ctx.r[11].s64 = ctx.r[24].s64 + 4;
	// 82436ADC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82436AE0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82436AE4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82436AE8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82436AEC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82436AF0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82436AF4: 4082FFE8  bne 0x82436adc
	if !ctx.cr[0].eq {
	pc = 0x82436ADC; continue 'dispatch;
	}
	// 82436AF8: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82436AFC: 80DF00F0  lwz r6, 0xf0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 82436B00: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82436B04: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82436B08: 3BCB5A80  addi r30, r11, 0x5a80
	ctx.r[30].s64 = ctx.r[11].s64 + 23168;
	// 82436B0C: 38A002CC  li r5, 0x2cc
	ctx.r[5].s64 = 716;
	// 82436B10: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82436B14: 4BED1325  bl 0x82307e38
	ctx.lr = 0x82436B18;
	sub_82307E38(ctx, base);
	// 82436B18: C01C0018  lfs f0, 0x18(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82436B1C: EC00F828  fsubs f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 82436B20: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82436B24: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82436B28: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82436B2C: 4BF9F47D  bl 0x823d5fa8
	ctx.lr = 0x82436B30;
	sub_823D5FA8(ctx, base);
	// 82436B30: 8321005C  lwz r25, 0x5c(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82436B34: 83410058  lwz r26, 0x58(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82436B38: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 82436B3C: 9321005C  stw r25, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[25].u32 ) };
	// 82436B40: 93410058  stw r26, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[26].u32 ) };
	// 82436B44: 419A0024  beq cr6, 0x82436b68
	if ctx.cr[6].eq {
	pc = 0x82436B68; continue 'dispatch;
	}
	// 82436B48: 39790004  addi r11, r25, 4
	ctx.r[11].s64 = ctx.r[25].s64 + 4;
	// 82436B4C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82436B50: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82436B54: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82436B58: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82436B5C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82436B60: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82436B64: 4082FFE8  bne 0x82436b4c
	if !ctx.cr[0].eq {
	pc = 0x82436B4C; continue 'dispatch;
	}
	// 82436B68: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82436B6C: 80DF00F0  lwz r6, 0xf0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 82436B70: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 82436B74: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82436B78: 38A002CE  li r5, 0x2ce
	ctx.r[5].s64 = 718;
	// 82436B7C: 4BED12BD  bl 0x82307e38
	ctx.lr = 0x82436B80;
	sub_82307E38(ctx, base);
	// 82436B80: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82436B84: 4BF9F49D  bl 0x823d6020
	ctx.lr = 0x82436B88;
	sub_823D6020(ctx, base);
	// 82436B88: C01C0018  lfs f0, 0x18(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82436B8C: EC00F828  fsubs f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 82436B90: 83A1005C  lwz r29, 0x5c(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82436B94: 83610058  lwz r27, 0x58(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82436B98: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82436B9C: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 82436BA0: D01B0018  stfs f0, 0x18(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82436BA4: 93610058  stw r27, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[27].u32 ) };
	// 82436BA8: 419A0024  beq cr6, 0x82436bcc
	if ctx.cr[6].eq {
	pc = 0x82436BCC; continue 'dispatch;
	}
	// 82436BAC: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82436BB0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82436BB4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82436BB8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82436BBC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82436BC0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82436BC4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82436BC8: 4082FFE8  bne 0x82436bb0
	if !ctx.cr[0].eq {
	pc = 0x82436BB0; continue 'dispatch;
	}
	// 82436BCC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82436BD0: 80DF00F0  lwz r6, 0xf0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 82436BD4: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 82436BD8: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82436BDC: 38A002D1  li r5, 0x2d1
	ctx.r[5].s64 = 721;
	// 82436BE0: 4BED1259  bl 0x82307e38
	ctx.lr = 0x82436BE4;
	sub_82307E38(ctx, base);
	// 82436BE4: C01C0018  lfs f0, 0x18(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82436BE8: D01F00B8  stfs f0, 0xb8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 82436BEC: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 82436BF0: 39400080  li r10, 0x80
	ctx.r[10].s64 = 128;
	// 82436BF4: 392000A0  li r9, 0xa0
	ctx.r[9].s64 = 160;
	// 82436BF8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82436BFC: C01A0018  lfs f0, 0x18(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82436C00: D01F00B4  stfs f0, 0xb4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82436C04: 13FA58C7  vcmpequd (lvx128) v31, v26, v11
	tmp.u32 = ctx.r[26].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82436DB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82436DB0 size=140
    let mut pc: u32 = 0x82436DB0;
    'dispatch: loop {
        match pc {
            0x82436DB0 => {
    //   block [0x82436DB0..0x82436E3C)
	// 82436DB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82436DB4: 48D713B9  bl 0x831a816c
	ctx.lr = 0x82436DB8;
	sub_831A8130(ctx, base);
	// 82436DB8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82436DBC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82436DC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82436DC4: 4BF9F165  bl 0x823d5f28
	ctx.lr = 0x82436DC8;
	sub_823D5F28(ctx, base);
	// 82436DC8: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82436DCC: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82436DD0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82436DD4: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82436DD8: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82436DDC: 419A0024  beq cr6, 0x82436e00
	if ctx.cr[6].eq {
	pc = 0x82436E00; continue 'dispatch;
	}
	// 82436DE0: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 82436DE4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82436DE8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82436DEC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82436DF0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82436DF4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82436DF8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82436DFC: 4082FFE8  bne 0x82436de4
	if !ctx.cr[0].eq {
	pc = 0x82436DE4; continue 'dispatch;
	}
	// 82436E00: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82436E04: 80DF00F0  lwz r6, 0xf0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 82436E08: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82436E0C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82436E10: 388B5A80  addi r4, r11, 0x5a80
	ctx.r[4].s64 = ctx.r[11].s64 + 23168;
	// 82436E14: 38A002EA  li r5, 0x2ea
	ctx.r[5].s64 = 746;
	// 82436E18: 4BED1021  bl 0x82307e38
	ctx.lr = 0x82436E1C;
	sub_82307E38(ctx, base);
	// 82436E1C: C01D0018  lfs f0, 0x18(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82436E20: D01F00B8  stfs f0, 0xb8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 82436E24: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82436E28: 419A000C  beq cr6, 0x82436e34
	if ctx.cr[6].eq {
	pc = 0x82436E34; continue 'dispatch;
	}
	// 82436E2C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82436E30: 4BE89A61  bl 0x822c0890
	ctx.lr = 0x82436E34;
	sub_822C0890(ctx, base);
	// 82436E34: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82436E38: 48D71384  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82436E40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82436E40 size=2432
    let mut pc: u32 = 0x82436E40;
    'dispatch: loop {
        match pc {
            0x82436E40 => {
    //   block [0x82436E40..0x824377C0)
	// 82436E40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82436E44: 48D712F5  bl 0x831a8138
	ctx.lr = 0x82436E48;
	sub_831A8130(ctx, base);
	// 82436E48: DBA1FF60  stfd f29, -0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.f[29].u64 ) };
	// 82436E4C: DBC1FF68  stfd f30, -0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-152 as u32), ctx.f[30].u64 ) };
	// 82436E50: DBE1FF70  stfd f31, -0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.f[31].u64 ) };
	// 82436E54: 9421FE70  stwu r1, -0x190(r1)
	ea = ctx.r[1].u32.wrapping_add(-400 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82436E58: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82436E5C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82436E60: 7CB02B78  mr r16, r5
	ctx.r[16].u64 = ctx.r[5].u64;
	// 82436E64: 5491063F  clrlwi. r17, r4, 0x18
	ctx.r[17].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[17].s32, 0, &mut ctx.xer);
	// 82436E68: C3AB08A4  lfs f29, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82436E6C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82436E70: FFC0E890  fmr f30, f29
	ctx.f[30].f64 = ctx.f[29].f64;
	// 82436E74: 418203C8  beq 0x8243723c
	if ctx.cr[0].eq {
	pc = 0x8243723C; continue 'dispatch;
	}
	// 82436E78: D3A10050  stfs f29, 0x50(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82436E7C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82436E80: 4BF9F129  bl 0x823d5fa8
	ctx.lr = 0x82436E84;
	sub_823D5FA8(ctx, base);
	// 82436E84: 82810064  lwz r20, 0x64(r1)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82436E88: 82E10060  lwz r23, 0x60(r1)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82436E8C: 2B140000  cmplwi cr6, r20, 0
	ctx.cr[6].compare_u32(ctx.r[20].u32, 0 as u32, &mut ctx.xer);
	// 82436E90: 92810064  stw r20, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[20].u32 ) };
	// 82436E94: 92E10060  stw r23, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[23].u32 ) };
	// 82436E98: 419A0024  beq cr6, 0x82436ebc
	if ctx.cr[6].eq {
	pc = 0x82436EBC; continue 'dispatch;
	}
	// 82436E9C: 39740004  addi r11, r20, 4
	ctx.r[11].s64 = ctx.r[20].s64 + 4;
	// 82436EA0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82436EA4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82436EA8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82436EAC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82436EB0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82436EB4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82436EB8: 4082FFE8  bne 0x82436ea0
	if !ctx.cr[0].eq {
	pc = 0x82436EA0; continue 'dispatch;
	}
	// 82436EBC: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82436EC0: 80DF00F0  lwz r6, 0xf0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 82436EC4: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 82436EC8: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82436ECC: 3BCB5A80  addi r30, r11, 0x5a80
	ctx.r[30].s64 = ctx.r[11].s64 + 23168;
	// 82436ED0: 38A0040D  li r5, 0x40d
	ctx.r[5].s64 = 1037;
	// 82436ED4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82436ED8: 4BED0F61  bl 0x82307e38
	ctx.lr = 0x82436EDC;
	sub_82307E38(ctx, base);
	// 82436EDC: 3B170020  addi r24, r23, 0x20
	ctx.r[24].s64 = ctx.r[23].s64 + 32;
	// 82436EE0: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 82436EE4: 807F0114  lwz r3, 0x114(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 82436EE8: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82436EEC: 13E0C0C7  vcmpequd (lvx128) v31, v0, v24
	tmp.u32 = ctx.r[24].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824377C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824377C0 size=112
    let mut pc: u32 = 0x824377C0;
    'dispatch: loop {
        match pc {
            0x824377C0 => {
    //   block [0x824377C0..0x82437830)
	// 824377C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824377C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824377C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824377CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824377D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824377D4: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 824377D8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 824377DC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 824377E0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 824377E4: 388B5A80  addi r4, r11, 0x5a80
	ctx.r[4].s64 = ctx.r[11].s64 + 23168;
	// 824377E8: 38A0005D  li r5, 0x5d
	ctx.r[5].s64 = 93;
	// 824377EC: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 824377F0: 4BE88BE9  bl 0x822c03d8
	ctx.lr = 0x824377F4;
	sub_822C03D8(ctx, base);
	// 824377F4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 824377F8: 41820014  beq 0x8243780c
	if ctx.cr[0].eq {
	pc = 0x8243780C; continue 'dispatch;
	}
	// 824377FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82437800: 480598F1  bl 0x824910f0
	ctx.lr = 0x82437804;
	sub_824910F0(ctx, base);
	// 82437804: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82437808: 48000008  b 0x82437810
	pc = 0x82437810; continue 'dispatch;
	// 8243780C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82437810: 387E010C  addi r3, r30, 0x10c
	ctx.r[3].s64 = ctx.r[30].s64 + 268;
	// 82437814: 4BED2ECD  bl 0x8230a6e0
	ctx.lr = 0x82437818;
	sub_8230A6E0(ctx, base);
	// 82437818: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8243781C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82437820: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82437824: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82437828: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8243782C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82437830(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82437830 size=1840
    let mut pc: u32 = 0x82437830;
    'dispatch: loop {
        match pc {
            0x82437830 => {
    //   block [0x82437830..0x82437F60)
	// 82437830: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82437834: 48D708FD  bl 0x831a8130
	ctx.lr = 0x82437838;
	sub_831A8130(ctx, base);
	// 82437838: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 8243783C: 48D71239  bl 0x831a8a74
	ctx.lr = 0x82437840;
	sub_831A8A40(ctx, base);
	// 82437840: 9421FD80  stwu r1, -0x280(r1)
	ea = ctx.r[1].u32.wrapping_add(-640 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82437844: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82437848: 7CAE2B78  mr r14, r5
	ctx.r[14].u64 = ctx.r[5].u64;
	// 8243784C: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82437850: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 82437854: 91C102A4  stw r14, 0x2a4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(676 as u32), ctx.r[14].u32 ) };
	// 82437858: 7D194378  mr r25, r8
	ctx.r[25].u64 = ctx.r[8].u64;
	// 8243785C: 938102AC  stw r28, 0x2ac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(684 as u32), ctx.r[28].u32 ) };
	// 82437860: 7D384B78  mr r24, r9
	ctx.r[24].u64 = ctx.r[9].u64;
	// 82437864: 934102B4  stw r26, 0x2b4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(692 as u32), ctx.r[26].u32 ) };
	// 82437868: 7D565378  mr r22, r10
	ctx.r[22].u64 = ctx.r[10].u64;
	// 8243786C: 932102BC  stw r25, 0x2bc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(700 as u32), ctx.r[25].u32 ) };
	// 82437870: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82437874: 930102C4  stw r24, 0x2c4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(708 as u32), ctx.r[24].u32 ) };
	// 82437878: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8243787C: 92C102CC  stw r22, 0x2cc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(716 as u32), ctx.r[22].u32 ) };
	// 82437880: 4BF9E6A9  bl 0x823d5f28
	ctx.lr = 0x82437884;
	sub_823D5F28(ctx, base);
	// 82437884: 82810084  lwz r20, 0x84(r1)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82437888: 83A10080  lwz r29, 0x80(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 8243788C: 2B140000  cmplwi cr6, r20, 0
	ctx.cr[6].compare_u32(ctx.r[20].u32, 0 as u32, &mut ctx.xer);
	// 82437890: 92810054  stw r20, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[20].u32 ) };
	// 82437894: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82437898: 419A0024  beq cr6, 0x824378bc
	if ctx.cr[6].eq {
	pc = 0x824378BC; continue 'dispatch;
	}
	// 8243789C: 39740004  addi r11, r20, 4
	ctx.r[11].s64 = ctx.r[20].s64 + 4;
	// 824378A0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 824378A4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 824378A8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 824378AC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 824378B0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 824378B4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 824378B8: 4082FFE8  bne 0x824378a0
	if !ctx.cr[0].eq {
	pc = 0x824378A0; continue 'dispatch;
	}
	// 824378BC: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 824378C0: 80DF00F0  lwz r6, 0xf0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 824378C4: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 824378C8: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824378CC: 3AEB5A80  addi r23, r11, 0x5a80
	ctx.r[23].s64 = ctx.r[11].s64 + 23168;
	// 824378D0: 38A002F1  li r5, 0x2f1
	ctx.r[5].s64 = 753;
	// 824378D4: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 824378D8: 4BED0561  bl 0x82307e38
	ctx.lr = 0x824378DC;
	sub_82307E38(ctx, base);
	// 824378DC: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 824378E0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 824378E4: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 824378E8: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 824378EC: 392100C0  addi r9, r1, 0xc0
	ctx.r[9].s64 = ctx.r[1].s64 + 192;
	// 824378F0: 57CF063F  clrlwi. r15, r30, 0x18
	ctx.r[15].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[15].s32, 0, &mut ctx.xer);
	// 824378F4: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 824378F8: 9B6E0000  stb r27, 0(r14)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[14].u32.wrapping_add(0 as u32), ctx.r[27].u8 ) };
	// 824378FC: 9B7C0000  stb r27, 0(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[27].u8 ) };
	// 82437900: C38A08A4  lfs f28, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82437904: 9B7A0000  stb r27, 0(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[27].u8 ) };
	// 82437908: D3990000  stfs f28, 0(r25)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 8243790C: D3980000  stfs f28, 0(r24)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82437910: 91E1008C  stw r15, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[15].u32 ) };
	// 82437914: D3960000  stfs f28, 0(r22)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82437918: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82437F60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82437F60 size=2056
    let mut pc: u32 = 0x82437F60;
    'dispatch: loop {
        match pc {
            0x82437F60 => {
    //   block [0x82437F60..0x82438768)
	// 82437F60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82437F64: 48D701CD  bl 0x831a8130
	ctx.lr = 0x82437F68;
	sub_831A8130(ctx, base);
	// 82437F68: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 82437F6C: 48D70B05  bl 0x831a8a70
	ctx.lr = 0x82437F70;
	sub_831A8A40(ctx, base);
	// 82437F70: 9421FE00  stwu r1, -0x200(r1)
	ea = ctx.r[1].u32.wrapping_add(-512 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82437F74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82437F78: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82437F7C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82437F80: 4BF6F241  bl 0x823a71c0
	ctx.lr = 0x82437F84;
	sub_823A71C0(ctx, base);
	// 82437F84: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82437F88: 556B04A5  rlwinm. r11, r11, 0, 0x12, 0x12
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82437F8C: 408207CC  bne 0x82438758
	if !ctx.cr[0].eq {
	pc = 0x82438758; continue 'dispatch;
	}
	// 82437F90: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82437F94: 89640B40  lbz r11, 0xb40(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(2880 as u32) ) } as u64;
	// 82437F98: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82437F9C: 4082001C  bne 0x82437fb8
	if !ctx.cr[0].eq {
	pc = 0x82437FB8; continue 'dispatch;
	}
	// 82437FA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82437FA4: 4BECDACD  bl 0x82305a70
	ctx.lr = 0x82437FA8;
	sub_82305A70(ctx, base);
	// 82437FA8: 39600150  li r11, 0x150
	ctx.r[11].s64 = 336;
	// 82437FAC: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82438768(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82438768 size=1260
    let mut pc: u32 = 0x82438768;
    'dispatch: loop {
        match pc {
            0x82438768 => {
    //   block [0x82438768..0x82438C54)
	// 82438768: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8243876C: 48D6F9D1  bl 0x831a813c
	ctx.lr = 0x82438770;
	sub_831A8130(ctx, base);
	// 82438770: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82438774: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82438778: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8243877C: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 82438780: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 82438784: 4BFF438D  bl 0x8242cb10
	ctx.lr = 0x82438788;
	sub_8242CB10(ctx, base);
	// 82438788: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 8243878C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82438790: 9BDF0050  stb r30, 0x50(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[30].u8 ) };
	// 82438794: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82438798: 9BDF0051  stb r30, 0x51(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(81 as u32), ctx.r[30].u8 ) };
	// 8243879C: 3D008202  lis r8, -0x7dfe
	ctx.r[8].s64 = -2113798144;
	// 824387A0: 3B2B6910  addi r25, r11, 0x6910
	ctx.r[25].s64 = ctx.r[11].s64 + 26896;
	// 824387A4: C00A6150  lfs f0, 0x6150(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24912 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824387A8: 38E00080  li r7, 0x80
	ctx.r[7].s64 = 128;
	// 824387AC: 3CA08200  lis r5, -0x7e00
	ctx.r[5].s64 = -2113929216;
	// 824387B0: D01F0054  stfs f0, 0x54(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 824387B4: 39485B24  addi r10, r8, 0x5b24
	ctx.r[10].s64 = ctx.r[8].s64 + 23332;
	// 824387B8: C1A9A9F0  lfs f13, -0x5610(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-22032 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824387BC: D1BF0058  stfs f13, 0x58(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 824387C0: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 824387C4: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 824387C8: 13E0C8C7  vcmpequd (lvx128) v31, v0, v25
	tmp.u32 = ctx.r[25].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82438C58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82438C58 size=196
    let mut pc: u32 = 0x82438C58;
    'dispatch: loop {
        match pc {
            0x82438C58 => {
    //   block [0x82438C58..0x82438D1C)
	// 82438C58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82438C5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82438C60: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82438C64: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82438C68: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82438C6C: 807F0128  lwz r3, 0x128(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(296 as u32) ) } as u64;
	// 82438C70: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82438C74: 419A0008  beq cr6, 0x82438c7c
	if ctx.cr[6].eq {
	pc = 0x82438C7C; continue 'dispatch;
	}
	// 82438C78: 4BE87C19  bl 0x822c0890
	ctx.lr = 0x82438C7C;
	sub_822C0890(ctx, base);
	// 82438C7C: 807F0120  lwz r3, 0x120(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) } as u64;
	// 82438C80: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82438C84: 419A0008  beq cr6, 0x82438c8c
	if ctx.cr[6].eq {
	pc = 0x82438C8C; continue 'dispatch;
	}
	// 82438C88: 4BE87C09  bl 0x822c0890
	ctx.lr = 0x82438C8C;
	sub_822C0890(ctx, base);
	// 82438C8C: 807F0118  lwz r3, 0x118(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 82438C90: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82438C94: 419A0008  beq cr6, 0x82438c9c
	if ctx.cr[6].eq {
	pc = 0x82438C9C; continue 'dispatch;
	}
	// 82438C98: 4BE87BF9  bl 0x822c0890
	ctx.lr = 0x82438C9C;
	sub_822C0890(ctx, base);
	// 82438C9C: 807F0110  lwz r3, 0x110(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 82438CA0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82438CA4: 419A0008  beq cr6, 0x82438cac
	if ctx.cr[6].eq {
	pc = 0x82438CAC; continue 'dispatch;
	}
	// 82438CA8: 4BE87BE9  bl 0x822c0890
	ctx.lr = 0x82438CAC;
	sub_822C0890(ctx, base);
	// 82438CAC: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 82438CB0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82438CB4: 419A0008  beq cr6, 0x82438cbc
	if ctx.cr[6].eq {
	pc = 0x82438CBC; continue 'dispatch;
	}
	// 82438CB8: 4BE87BD9  bl 0x822c0890
	ctx.lr = 0x82438CBC;
	sub_822C0890(ctx, base);
	// 82438CBC: 807F00EC  lwz r3, 0xec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82438CC0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82438CC4: 419A0008  beq cr6, 0x82438ccc
	if ctx.cr[6].eq {
	pc = 0x82438CCC; continue 'dispatch;
	}
	// 82438CC8: 4BE87BC9  bl 0x822c0890
	ctx.lr = 0x82438CCC;
	sub_822C0890(ctx, base);
	// 82438CCC: 807F00E4  lwz r3, 0xe4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 82438CD0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82438CD4: 419A0008  beq cr6, 0x82438cdc
	if ctx.cr[6].eq {
	pc = 0x82438CDC; continue 'dispatch;
	}
	// 82438CD8: 4BE87BB9  bl 0x822c0890
	ctx.lr = 0x82438CDC;
	sub_822C0890(ctx, base);
	// 82438CDC: 807F00DC  lwz r3, 0xdc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) } as u64;
	// 82438CE0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82438CE4: 419A0008  beq cr6, 0x82438cec
	if ctx.cr[6].eq {
	pc = 0x82438CEC; continue 'dispatch;
	}
	// 82438CE8: 4BE87BA9  bl 0x822c0890
	ctx.lr = 0x82438CEC;
	sub_822C0890(ctx, base);
	// 82438CEC: 807F00D4  lwz r3, 0xd4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 82438CF0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82438CF4: 419A0008  beq cr6, 0x82438cfc
	if ctx.cr[6].eq {
	pc = 0x82438CFC; continue 'dispatch;
	}
	// 82438CF8: 4BE87B99  bl 0x822c0890
	ctx.lr = 0x82438CFC;
	sub_822C0890(ctx, base);
	// 82438CFC: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82438D00: 396B55C8  addi r11, r11, 0x55c8
	ctx.r[11].s64 = ctx.r[11].s64 + 21960;
	// 82438D04: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82438D08: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82438D0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82438D10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82438D14: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82438D18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82438D20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82438D20 size=76
    let mut pc: u32 = 0x82438D20;
    'dispatch: loop {
        match pc {
            0x82438D20 => {
    //   block [0x82438D20..0x82438D6C)
	// 82438D20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82438D24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82438D28: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82438D2C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82438D30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82438D34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82438D38: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82438D3C: 4BFFFF1D  bl 0x82438c58
	ctx.lr = 0x82438D40;
	sub_82438C58(ctx, base);
	// 82438D40: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82438D44: 4182000C  beq 0x82438d50
	if ctx.cr[0].eq {
	pc = 0x82438D50; continue 'dispatch;
	}
	// 82438D48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82438D4C: 489B968D  bl 0x82df23d8
	ctx.lr = 0x82438D50;
	sub_82DF23D8(ctx, base);
	// 82438D50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82438D54: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82438D58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82438D5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82438D60: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82438D64: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82438D68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82438D70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82438D70 size=1364
    let mut pc: u32 = 0x82438D70;
    'dispatch: loop {
        match pc {
            0x82438D70 => {
    //   block [0x82438D70..0x824392C4)
	// 82438D70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82438D74: 48D6F3D9  bl 0x831a814c
	ctx.lr = 0x82438D78;
	sub_831A8130(ctx, base);
	// 82438D78: DBA1FF88  stfd f29, -0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.f[29].u64 ) };
	// 82438D7C: DBC1FF90  stfd f30, -0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.f[30].u64 ) };
	// 82438D80: DBE1FF98  stfd f31, -0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[31].u64 ) };
	// 82438D84: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82438D88: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82438D8C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82438D90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82438D94: FFA01090  fmr f29, f2
	ctx.f[29].f64 = ctx.f[2].f64;
	// 82438D98: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82438D9C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82438DA0: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 82438DA4: C3CB08A4  lfs f30, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82438DA8: 7CD73378  mr r23, r6
	ctx.r[23].u64 = ctx.r[6].u64;
	// 82438DAC: D3C10050  stfs f30, 0x50(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82438DB0: 7CF63B78  mr r22, r7
	ctx.r[22].u64 = ctx.r[7].u64;
	// 82438DB4: 4BF9D1F5  bl 0x823d5fa8
	ctx.lr = 0x82438DB8;
	sub_823D5FA8(ctx, base);
	// 82438DB8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82438DBC: 4802D71D  bl 0x824664d8
	ctx.lr = 0x82438DC0;
	sub_824664D8(ctx, base);
	// 82438DC0: EFFFE82A  fadds f31, f31, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ((ctx.f[31].f64 + ctx.f[29].f64) as f32) as f64;
	// 82438DC4: 3AA00000  li r21, 0
	ctx.r[21].s64 = 0;
	// 82438DC8: C01F00B8  lfs f0, 0xb8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82438DCC: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82438DD0: 8301005C  lwz r24, 0x5c(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82438DD4: 83C10058  lwz r30, 0x58(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82438DD8: 90610064  stw r3, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[3].u32 ) };
	// 82438DDC: 3BAB5A80  addi r29, r11, 0x5a80
	ctx.r[29].s64 = ctx.r[11].s64 + 23168;
	// 82438DE0: 92A10068  stw r21, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[21].u32 ) };
	// 82438DE4: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82438DE8: 409901F8  ble cr6, 0x82438fe0
	if !ctx.cr[6].gt {
	pc = 0x82438FE0; continue 'dispatch;
	}
	// 82438DEC: D01E0018  stfs f0, 0x18(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82438DF0: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 82438DF4: 9301005C  stw r24, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[24].u32 ) };
	// 82438DF8: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 82438DFC: 419A0024  beq cr6, 0x82438e20
	if ctx.cr[6].eq {
	pc = 0x82438E20; continue 'dispatch;
	}
	// 82438E00: 39780004  addi r11, r24, 4
	ctx.r[11].s64 = ctx.r[24].s64 + 4;
	// 82438E04: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82438E08: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82438E0C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82438E10: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82438E14: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82438E18: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82438E1C: 4082FFE8  bne 0x82438e04
	if !ctx.cr[0].eq {
	pc = 0x82438E04; continue 'dispatch;
	}
	// 82438E20: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82438E24: 80DF00F0  lwz r6, 0xf0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 82438E28: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 82438E2C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82438E30: 38A0009D  li r5, 0x9d
	ctx.r[5].s64 = 157;
	// 82438E34: 4BECF005  bl 0x82307e38
	ctx.lr = 0x82438E38;
	sub_82307E38(ctx, base);
	// 82438E38: 3B5E0020  addi r26, r30, 0x20
	ctx.r[26].s64 = ctx.r[30].s64 + 32;
	// 82438E3C: 807F0114  lwz r3, 0x114(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 82438E40: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82438E44: 48059135  bl 0x82491f78
	ctx.lr = 0x82438E48;
	sub_82491F78(ctx, base);
	// 82438E48: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82438E4C: 80BF00F0  lwz r5, 0xf0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 82438E50: 807F0114  lwz r3, 0x114(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 82438E54: 480590FD  bl 0x82491f50
	ctx.lr = 0x82438E58;
	sub_82491F50(ctx, base);
	// 82438E58: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82438E5C: 4BFFC1B5  bl 0x82435010
	ctx.lr = 0x82438E60;
	sub_82435010(ctx, base);
	// 82438E60: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82438E64: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 82438E68: 838B0000  lwz r28, 0(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82438E6C: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82438E70: 419A0030  beq cr6, 0x82438ea0
	if ctx.cr[6].eq {
	pc = 0x82438EA0; continue 'dispatch;
	}
	// 82438E74: 807C0008  lwz r3, 8(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82438E78: 483A1159  bl 0x827d9fd0
	ctx.lr = 0x82438E7C;
	sub_827D9FD0(ctx, base);
	// 82438E7C: 48BD013D  bl 0x83008fb8
	ctx.lr = 0x82438E80;
	sub_83008FB8(ctx, base);
	// 82438E80: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82438E84: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82438E88: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82438E8C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82438E90: 48117AC9  bl 0x82550958
	ctx.lr = 0x82438E94;
	sub_82550958(ctx, base);
	// 82438E94: 839C0000  lwz r28, 0(r28)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82438E98: 7F1CD840  cmplw cr6, r28, r27
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82438E9C: 409AFFD8  bne cr6, 0x82438e74
	if !ctx.cr[6].eq {
	pc = 0x82438E74; continue 'dispatch;
	}
	// 82438EA0: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 82438EA4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82438EA8: 409A0130  bne cr6, 0x82438fd8
	if !ctx.cr[6].eq {
	pc = 0x82438FD8; continue 'dispatch;
	}
	// 82438EAC: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82438EB0: C01F00B8  lfs f0, 0xb8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82438EB4: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 82438EB8: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 82438EBC: 9301005C  stw r24, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[24].u32 ) };
	// 82438EC0: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 82438EC4: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82438EC8: D01E0018  stfs f0, 0x18(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82438ECC: 419A0024  beq cr6, 0x82438ef0
	if ctx.cr[6].eq {
	pc = 0x82438EF0; continue 'dispatch;
	}
	// 82438ED0: 39780004  addi r11, r24, 4
	ctx.r[11].s64 = ctx.r[24].s64 + 4;
	// 82438ED4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82438ED8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82438EDC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82438EE0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82438EE4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82438EE8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82438EEC: 4082FFE8  bne 0x82438ed4
	if !ctx.cr[0].eq {
	pc = 0x82438ED4; continue 'dispatch;
	}
	// 82438EF0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82438EF4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82438EF8: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 82438EFC: 80DB000C  lwz r6, 0xc(r27)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 82438F00: 38A000AE  li r5, 0xae
	ctx.r[5].s64 = 174;
	// 82438F04: 4BECEF35  bl 0x82307e38
	ctx.lr = 0x82438F08;
	sub_82307E38(ctx, base);
	// 82438F08: 13E0D0C7  vcmpequd (lvx128) v31, v0, v26
	tmp.u32 = ctx.r[26].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824392C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824392C8 size=664
    let mut pc: u32 = 0x824392C8;
    'dispatch: loop {
        match pc {
            0x824392C8 => {
    //   block [0x824392C8..0x82439560)
	// 824392C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824392CC: 48D6EE85  bl 0x831a8150
	ctx.lr = 0x824392D0;
	sub_831A8130(ctx, base);
	// 824392D0: DBC1FF98  stfd f30, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[30].u64 ) };
	// 824392D4: DBE1FFA0  stfd f31, -0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[31].u64 ) };
	// 824392D8: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824392DC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 824392E0: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 824392E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824392E8: 548B063F  clrlwi. r11, r4, 0x18
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824392EC: 92E1005C  stw r23, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[23].u32 ) };
	// 824392F0: C3CA08A4  lfs f30, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 824392F4: 41820034  beq 0x82439328
	if ctx.cr[0].eq {
	pc = 0x82439328; continue 'dispatch;
	}
	// 824392F8: D3C10050  stfs f30, 0x50(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 824392FC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82439300: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82439304: 4BF9CCA5  bl 0x823d5fa8
	ctx.lr = 0x82439308;
	sub_823D5FA8(ctx, base);
	// 82439308: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8243930C: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82439310: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82439314: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82439318: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8243931C: 4BE8B145  bl 0x822c4460
	ctx.lr = 0x82439320;
	sub_822C4460(ctx, base);
	// 82439320: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82439324: 4800002C  b 0x82439350
	pc = 0x82439350; continue 'dispatch;
	// 82439328: 389F00B8  addi r4, r31, 0xb8
	ctx.r[4].s64 = ctx.r[31].s64 + 184;
	// 8243932C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82439330: 4BF9CC79  bl 0x823d5fa8
	ctx.lr = 0x82439334;
	sub_823D5FA8(ctx, base);
	// 82439334: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82439338: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 8243933C: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82439340: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82439344: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82439348: 4BE8B119  bl 0x822c4460
	ctx.lr = 0x8243934C;
	sub_822C4460(ctx, base);
	// 8243934C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82439350: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82439354: 419A0008  beq cr6, 0x8243935c
	if ctx.cr[6].eq {
	pc = 0x8243935C; continue 'dispatch;
	}
	// 82439358: 4BE87539  bl 0x822c0890
	ctx.lr = 0x8243935C;
	sub_822C0890(ctx, base);
	// 8243935C: 82C1005C  lwz r22, 0x5c(r1)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82439360: 83C10058  lwz r30, 0x58(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82439364: 2B160000  cmplwi cr6, r22, 0
	ctx.cr[6].compare_u32(ctx.r[22].u32, 0 as u32, &mut ctx.xer);
	// 82439368: 92C1005C  stw r22, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[22].u32 ) };
	// 8243936C: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 82439370: 419A0024  beq cr6, 0x82439394
	if ctx.cr[6].eq {
	pc = 0x82439394; continue 'dispatch;
	}
	// 82439374: 39760004  addi r11, r22, 4
	ctx.r[11].s64 = ctx.r[22].s64 + 4;
	// 82439378: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8243937C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82439380: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82439384: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82439388: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8243938C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82439390: 4082FFE8  bne 0x82439378
	if !ctx.cr[0].eq {
	pc = 0x82439378; continue 'dispatch;
	}
	// 82439394: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82439398: 80DF00F0  lwz r6, 0xf0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 8243939C: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 824393A0: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824393A4: 3BAB5A80  addi r29, r11, 0x5a80
	ctx.r[29].s64 = ctx.r[11].s64 + 23168;
	// 824393A8: 38A00078  li r5, 0x78
	ctx.r[5].s64 = 120;
	// 824393AC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 824393B0: 4BECEA89  bl 0x82307e38
	ctx.lr = 0x824393B4;
	sub_82307E38(ctx, base);
	// 824393B4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 824393B8: 4802D121  bl 0x824664d8
	ctx.lr = 0x824393BC;
	sub_824664D8(ctx, base);
	// 824393BC: 90610084  stw r3, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 824393C0: 92E10088  stw r23, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[23].u32 ) };
	// 824393C4: 389E0020  addi r4, r30, 0x20
	ctx.r[4].s64 = ctx.r[30].s64 + 32;
	// 824393C8: 807F0114  lwz r3, 0x114(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 824393CC: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	// 824393D0: 48058BA9  bl 0x82491f78
	ctx.lr = 0x824393D4;
	sub_82491F78(ctx, base);
	// 824393D4: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 824393D8: 80BF00F0  lwz r5, 0xf0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 824393DC: 807F0114  lwz r3, 0x114(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 824393E0: 48058B71  bl 0x82491f50
	ctx.lr = 0x824393E4;
	sub_82491F50(ctx, base);
	// 824393E4: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 824393E8: 4BFFBC29  bl 0x82435010
	ctx.lr = 0x824393EC;
	sub_82435010(ctx, base);
	// 824393EC: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 824393F0: 7D795B78  mr r25, r11
	ctx.r[25].u64 = ctx.r[11].u64;
	// 824393F4: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824393F8: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 824393FC: 419A00E0  beq cr6, 0x824394dc
	if ctx.cr[6].eq {
	pc = 0x824394DC; continue 'dispatch;
	}
	// 82439400: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82439404: C3EBACFC  lfs f31, -0x5304(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-21252 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82439408: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8243940C: 483A0BC5  bl 0x827d9fd0
	ctx.lr = 0x82439410;
	sub_827D9FD0(ctx, base);
	// 82439410: 48BCFBA9  bl 0x83008fb8
	ctx.lr = 0x82439414;
	sub_83008FB8(ctx, base);
	// 82439414: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82439418: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8243941C: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 82439420: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 82439424: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82439428: 48117531  bl 0x82550958
	ctx.lr = 0x8243942C;
	sub_82550958(ctx, base);
	// 8243942C: 81610098  lwz r11, 0x98(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 82439430: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82439434: 419900F0  bgt cr6, 0x82439524
	if ctx.cr[6].gt {
	pc = 0x82439524; continue 'dispatch;
	}
	// 82439438: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8243943C: 4BF9CBE5  bl 0x823d6020
	ctx.lr = 0x82439440;
	sub_823D6020(ctx, base);
	// 82439440: 8341005C  lwz r26, 0x5c(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82439444: 83810058  lwz r28, 0x58(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82439448: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 8243944C: 93410064  stw r26, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[26].u32 ) };
	// 82439450: D3DC0018  stfs f30, 0x18(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82439454: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 82439458: 419A0024  beq cr6, 0x8243947c
	if ctx.cr[6].eq {
	pc = 0x8243947C; continue 'dispatch;
	}
	// 8243945C: 397A0004  addi r11, r26, 4
	ctx.r[11].s64 = ctx.r[26].s64 + 4;
	// 82439460: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82439464: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82439468: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8243946C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82439470: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82439474: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82439478: 4082FFE8  bne 0x82439460
	if !ctx.cr[0].eq {
	pc = 0x82439460; continue 'dispatch;
	}
	// 8243947C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82439480: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82439484: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 82439488: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 8243948C: 38A0008D  li r5, 0x8d
	ctx.r[5].s64 = 141;
	// 82439490: 4BECE9A9  bl 0x82307e38
	ctx.lr = 0x82439494;
	sub_82307E38(ctx, base);
	// 82439494: 396000A0  li r11, 0xa0
	ctx.r[11].s64 = 160;
	// 82439498: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 8243949C: 392100A0  addi r9, r1, 0xa0
	ctx.r[9].s64 = ctx.r[1].s64 + 160;
	// 824394A0: 13FF58C7  vcmpequd (lvx128) v31, v31, v11
	tmp.u32 = ctx.r[31].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 824394A4: 13DC50C7  vcmpequd (lvx128) v30, v28, v10
	tmp.u32 = ctx.r[28].u32 + ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82439560(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82439560 size=196
    let mut pc: u32 = 0x82439560;
    'dispatch: loop {
        match pc {
            0x82439560 => {
    //   block [0x82439560..0x82439624)
	// 82439560: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82439564: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82439568: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8243956C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82439570: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82439574: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82439578: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8243957C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82439580: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82439584: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82439588: 4BE873B1  bl 0x822c0938
	ctx.lr = 0x8243958C;
	sub_822C0938(ctx, base);
	// 8243958C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82439590: 41820028  beq 0x824395b8
	if ctx.cr[0].eq {
	pc = 0x824395B8; continue 'dispatch;
	}
	// 82439594: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82439598: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8243959C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 824395A0: 392B5B3C  addi r9, r11, 0x5b3c
	ctx.r[9].s64 = ctx.r[11].s64 + 23356;
	// 824395A4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 824395A8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 824395AC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824395B0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 824395B4: 48000008  b 0x824395bc
	pc = 0x824395BC; continue 'dispatch;
	// 824395B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824395BC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824395C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824395C4: 409A0044  bne cr6, 0x82439608
	if !ctx.cr[6].eq {
	pc = 0x82439608; continue 'dispatch;
	}
	// 824395C8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 824395CC: 419A001C  beq cr6, 0x824395e8
	if ctx.cr[6].eq {
	pc = 0x824395E8; continue 'dispatch;
	}
	// 824395D0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824395D4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 824395D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824395DC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824395E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824395E4: 4E800421  bctrl
	ctx.lr = 0x824395E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824395E8: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 824395EC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 824395F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 824395F4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 824395F8: 816B21CC  lwz r11, 0x21cc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8652 as u32) ) } as u64;
	// 824395FC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82439600: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82439604: 4BE869FD  bl 0x822c0000
	ctx.lr = 0x82439608;
	sub_822C0000(ctx, base);
	// 82439608: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8243960C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82439610: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82439614: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82439618: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8243961C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82439620: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82439628(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82439628 size=112
    let mut pc: u32 = 0x82439628;
    'dispatch: loop {
        match pc {
            0x82439628 => {
    //   block [0x82439628..0x82439698)
	// 82439628: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8243962C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82439630: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82439634: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82439638: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8243963C: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82439640: 396B5B50  addi r11, r11, 0x5b50
	ctx.r[11].s64 = ctx.r[11].s64 + 23376;
	// 82439644: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82439648: 807F0054  lwz r3, 0x54(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 8243964C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82439650: 419A0008  beq cr6, 0x82439658
	if ctx.cr[6].eq {
	pc = 0x82439658; continue 'dispatch;
	}
	// 82439654: 4BE8723D  bl 0x822c0890
	ctx.lr = 0x82439658;
	sub_822C0890(ctx, base);
	// 82439658: 807F004C  lwz r3, 0x4c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 8243965C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82439660: 419A0008  beq cr6, 0x82439668
	if ctx.cr[6].eq {
	pc = 0x82439668; continue 'dispatch;
	}
	// 82439664: 4BE8722D  bl 0x822c0890
	ctx.lr = 0x82439668;
	sub_822C0890(ctx, base);
	// 82439668: 807F0044  lwz r3, 0x44(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 8243966C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82439670: 419A0008  beq cr6, 0x82439678
	if ctx.cr[6].eq {
	pc = 0x82439678; continue 'dispatch;
	}
	// 82439674: 4BE8721D  bl 0x822c0890
	ctx.lr = 0x82439678;
	sub_822C0890(ctx, base);
	// 82439678: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8243967C: 396B55C8  addi r11, r11, 0x55c8
	ctx.r[11].s64 = ctx.r[11].s64 + 21960;
	// 82439680: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82439684: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82439688: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8243968C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82439690: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82439694: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82439698(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82439698 size=104
    let mut pc: u32 = 0x82439698;
    'dispatch: loop {
        match pc {
            0x82439698 => {
    //   block [0x82439698..0x82439700)
	// 82439698: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8243969C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824396A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824396A4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824396A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824396AC: 4BFF3465  bl 0x8242cb10
	ctx.lr = 0x824396B0;
	sub_8242CB10(ctx, base);
	// 824396B0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 824396B4: 3D208202  lis r9, -0x7dfe
	ctx.r[9].s64 = -2113798144;
	// 824396B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824396BC: 39295B50  addi r9, r9, 0x5b50
	ctx.r[9].s64 = ctx.r[9].s64 + 23376;
	// 824396C0: 917F0034  stw r11, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 824396C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824396C8: C00A08A8  lfs f0, 0x8a8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824396CC: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824396D0: D01F003C  stfs f0, 0x3c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 824396D4: 917F0040  stw r11, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 824396D8: 917F0044  stw r11, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[11].u32 ) };
	// 824396DC: 917F0048  stw r11, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 824396E0: 917F004C  stw r11, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[11].u32 ) };
	// 824396E4: 917F0050  stw r11, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 824396E8: 917F0054  stw r11, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 824396EC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 824396F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824396F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824396F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824396FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82439700(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82439700 size=76
    let mut pc: u32 = 0x82439700;
    'dispatch: loop {
        match pc {
            0x82439700 => {
    //   block [0x82439700..0x8243974C)
	// 82439700: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82439704: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82439708: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8243970C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82439710: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82439714: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82439718: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8243971C: 4BFFFF0D  bl 0x82439628
	ctx.lr = 0x82439720;
	sub_82439628(ctx, base);
	// 82439720: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82439724: 4182000C  beq 0x82439730
	if ctx.cr[0].eq {
	pc = 0x82439730; continue 'dispatch;
	}
	// 82439728: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8243972C: 489B8CAD  bl 0x82df23d8
	ctx.lr = 0x82439730;
	sub_82DF23D8(ctx, base);
	// 82439730: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82439734: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82439738: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8243973C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82439740: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82439744: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82439748: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82439750(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82439750 size=124
    let mut pc: u32 = 0x82439750;
    'dispatch: loop {
        match pc {
            0x82439750 => {
    //   block [0x82439750..0x824397CC)
	// 82439750: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82439754: 48D6EA19  bl 0x831a816c
	ctx.lr = 0x82439758;
	sub_831A8130(ctx, base);
	// 82439758: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8243975C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82439760: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82439764: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82439768: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 8243976C: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 82439770: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82439774: 489B8C75  bl 0x82df23e8
	ctx.lr = 0x82439778;
	sub_82DF23E8(ctx, base);
	// 82439778: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8243977C: 4182001C  beq 0x82439798
	if ctx.cr[0].eq {
	pc = 0x82439798; continue 'dispatch;
	}
	// 82439780: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82439784: 48A1FF1D  bl 0x82e596a0
	ctx.lr = 0x82439788;
	sub_82E596A0(ctx, base);
	// 82439788: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8243978C: 396B5B34  addi r11, r11, 0x5b34
	ctx.r[11].s64 = ctx.r[11].s64 + 23348;
	// 82439790: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82439794: 48000008  b 0x8243979c
	pc = 0x8243979C; continue 'dispatch;
	// 82439798: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8243979C: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 824397A0: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 824397A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 824397A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824397AC: 4BFFFDB5  bl 0x82439560
	ctx.lr = 0x824397B0;
	sub_82439560(ctx, base);
	// 824397B0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 824397B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 824397B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824397BC: 4BE86845  bl 0x822c0000
	ctx.lr = 0x824397C0;
	sub_822C0000(ctx, base);
	// 824397C0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 824397C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824397C8: 48D6E9F4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824397D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824397D0 size=280
    let mut pc: u32 = 0x824397D0;
    'dispatch: loop {
        match pc {
            0x824397D0 => {
    //   block [0x824397D0..0x824398E8)
	// 824397D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824397D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824397D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824397DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824397E0: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824398E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824398E8 size=328
    let mut pc: u32 = 0x824398E8;
    'dispatch: loop {
        match pc {
            0x824398E8 => {
    //   block [0x824398E8..0x82439A30)
	// 824398E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824398EC: 48D6E87D  bl 0x831a8168
	ctx.lr = 0x824398F0;
	sub_831A8130(ctx, base);
	// 824398F0: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82439A30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82439A30 size=1888
    let mut pc: u32 = 0x82439A30;
    'dispatch: loop {
        match pc {
            0x82439A30 => {
    //   block [0x82439A30..0x8243A190)
	// 82439A30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82439A34: 48D6E71D  bl 0x831a8150
	ctx.lr = 0x82439A38;
	sub_831A8130(ctx, base);
	// 82439A38: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 82439A3C: 48D6F035  bl 0x831a8a70
	ctx.lr = 0x82439A40;
	sub_831A8A40(ctx, base);
	// 82439A40: 3981FF70  addi r12, r1, -0x90
	ctx.r[12].s64 = ctx.r[1].s64 + -144;
	// 82439A44: 48D711D1  bl 0x831aac14
	ctx.lr = 0x82439A48;
	sub_831AA9A0(ctx, base);
	// 82439A48: 9421FD10  stwu r1, -0x2f0(r1)
	ea = ctx.r[1].u32.wrapping_add(-752 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82439A4C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82439A50: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 82439A54: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82439A58: 4BF6D769  bl 0x823a71c0
	ctx.lr = 0x82439A5C;
	sub_823A71C0(ctx, base);
	// 82439A5C: 388100F0  addi r4, r1, 0xf0
	ctx.r[4].s64 = ctx.r[1].s64 + 240;
	// 82439A60: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 82439A64: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82439A68: 4BECC139  bl 0x82305ba0
	ctx.lr = 0x82439A6C;
	sub_82305BA0(ctx, base);
	// 82439A6C: 396100F0  addi r11, r1, 0xf0
	ctx.r[11].s64 = ctx.r[1].s64 + 240;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8243A190(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8243A190 size=524
    let mut pc: u32 = 0x8243A190;
    'dispatch: loop {
        match pc {
            0x8243A190 => {
    //   block [0x8243A190..0x8243A39C)
	// 8243A190: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8243A194: 48D6DFB9  bl 0x831a814c
	ctx.lr = 0x8243A198;
	sub_831A8130(ctx, base);
	// 8243A198: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8243A19C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8243A1A0: 838D0000  lwz r28, 0(r13)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 8243A1A4: 3B600014  li r27, 0x14
	ctx.r[27].s64 = 20;
	// 8243A1A8: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 8243A1AC: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 8243A1B0: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 8243A1B4: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 8243A1B8: 7C751B78  mr r21, r3
	ctx.r[21].u64 = ctx.r[3].u64;
	// 8243A1BC: 7C7BE02E  lwzx r3, r27, r28
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 8243A1C0: 48A66571  bl 0x82ea0730
	ctx.lr = 0x8243A1C4;
	sub_82EA0730(ctx, base);
	// 8243A1C4: 3AC00020  li r22, 0x20
	ctx.r[22].s64 = 32;
	// 8243A1C8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8243A1CC: B2C30004  sth r22, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[22].u16 ) };
	// 8243A1D0: C02B9450  lfs f1, -0x6bb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8243A1D4: 48AE001D  bl 0x82f1a1f0
	ctx.lr = 0x8243A1D8;
	sub_82F1A1F0(ctx, base);
	// 8243A1D8: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8243A1DC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8243A1E0: 3AEB5B60  addi r23, r11, 0x5b60
	ctx.r[23].s64 = ctx.r[11].s64 + 23392;
	// 8243A1E4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8243A1E8: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 8243A1EC: 38A00039  li r5, 0x39
	ctx.r[5].s64 = 57;
	// 8243A1F0: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 8243A1F4: 4BE861E5  bl 0x822c03d8
	ctx.lr = 0x8243A1F8;
	sub_822C03D8(ctx, base);
	// 8243A1F8: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 8243A1FC: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 8243A200: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 8243A204: 3B4B6910  addi r26, r11, 0x6910
	ctx.r[26].s64 = ctx.r[11].s64 + 26896;
	// 8243A208: 3B2ABA80  addi r25, r10, -0x4580
	ctx.r[25].s64 = ctx.r[10].s64 + -17792;
	// 8243A20C: 41820064  beq 0x8243a270
	if ctx.cr[0].eq {
	pc = 0x8243A270; continue 'dispatch;
	}
	// 8243A210: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 8243A214: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 8243A218: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8243A21C: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 8243A220: 808B685C  lwz r4, 0x685c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26716 as u32) ) } as u64;
	// 8243A224: 4BEAAD0D  bl 0x822e4f30
	ctx.lr = 0x8243A228;
	sub_822E4F30(ctx, base);
	// 8243A228: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8243A22C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8243A230: 4BEAAC91  bl 0x822e4ec0
	ctx.lr = 0x8243A234;
	sub_822E4EC0(ctx, base);
	// 8243A234: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8243A238: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8243A23C: E89D0000  ld r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	// 8243A240: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8243A244: E8630000  ld r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 8243A248: 48052041  bl 0x8248c288
	ctx.lr = 0x8243A24C;
	sub_8248C288(ctx, base);
	// 8243A24C: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 8243A250: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 8243A254: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 8243A258: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8243A25C: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 8243A260: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8243A264: 48057F3D  bl 0x824921a0
	ctx.lr = 0x8243A268;
	sub_824921A0(ctx, base);
	// 8243A268: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8243A26C: 48000008  b 0x8243a274
	pc = 0x8243A274; continue 'dispatch;
	// 8243A270: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8243A274: 38750040  addi r3, r21, 0x40
	ctx.r[3].s64 = ctx.r[21].s64 + 64;
	// 8243A278: 4BEAAB71  bl 0x822e4de8
	ctx.lr = 0x8243A27C;
	sub_822E4DE8(ctx, base);
	// 8243A27C: 57EB07FF  clrlwi. r11, r31, 0x1f
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8243A280: 41820018  beq 0x8243a298
	if ctx.cr[0].eq {
	pc = 0x8243A298; continue 'dispatch;
	}
	// 8243A284: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8243A288: 57FF003C  rlwinm r31, r31, 0, 0, 0x1e
	ctx.r[31].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	// 8243A28C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8243A290: 419A0008  beq cr6, 0x8243a298
	if ctx.cr[6].eq {
	pc = 0x8243A298; continue 'dispatch;
	}
	// 8243A294: 4BEADFD5  bl 0x822e8268
	ctx.lr = 0x8243A298;
	sub_822E8268(ctx, base);
	// 8243A298: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 8243A29C: 7C7BE02E  lwzx r3, r27, r28
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 8243A2A0: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 8243A2A4: 48A6648D  bl 0x82ea0730
	ctx.lr = 0x8243A2A8;
	sub_82EA0730(ctx, base);
	// 8243A2A8: B2C30004  sth r22, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[22].u16 ) };
	// 8243A2AC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8243A2B0: C02B964C  lfs f1, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8243A2B4: 48ADFF3D  bl 0x82f1a1f0
	ctx.lr = 0x8243A2B8;
	sub_82F1A1F0(ctx, base);
	// 8243A2B8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8243A2BC: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 8243A2C0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8243A2C4: 38A0003C  li r5, 0x3c
	ctx.r[5].s64 = 60;
	// 8243A2C8: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 8243A2CC: 4BE8610D  bl 0x822c03d8
	ctx.lr = 0x8243A2D0;
	sub_822C03D8(ctx, base);
	// 8243A2D0: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 8243A2D4: 41820064  beq 0x8243a338
	if ctx.cr[0].eq {
	pc = 0x8243A338; continue 'dispatch;
	}
	// 8243A2D8: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 8243A2DC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 8243A2E0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8243A2E4: 63FF0002  ori r31, r31, 2
	ctx.r[31].u64 = ctx.r[31].u64 | 2;
	// 8243A2E8: 808B6860  lwz r4, 0x6860(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26720 as u32) ) } as u64;
	// 8243A2EC: 4BEAAC45  bl 0x822e4f30
	ctx.lr = 0x8243A2F0;
	sub_822E4F30(ctx, base);
	// 8243A2F0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8243A2F4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8243A2F8: 4BEAABC9  bl 0x822e4ec0
	ctx.lr = 0x8243A2FC;
	sub_822E4EC0(ctx, base);
	// 8243A2FC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8243A300: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8243A304: E89D0000  ld r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	// 8243A308: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8243A30C: E8630000  ld r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 8243A310: 48051F79  bl 0x8248c288
	ctx.lr = 0x8243A314;
	sub_8248C288(ctx, base);
	// 8243A314: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 8243A318: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 8243A31C: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 8243A320: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 8243A324: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 8243A328: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8243A32C: 48057E75  bl 0x824921a0
	ctx.lr = 0x8243A330;
	sub_824921A0(ctx, base);
	// 8243A330: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8243A334: 48000008  b 0x8243a33c
	pc = 0x8243A33C; continue 'dispatch;
	// 8243A338: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8243A33C: 38750048  addi r3, r21, 0x48
	ctx.r[3].s64 = ctx.r[21].s64 + 72;
	// 8243A340: 4BEAAAA9  bl 0x822e4de8
	ctx.lr = 0x8243A344;
	sub_822E4DE8(ctx, base);
	// 8243A344: 57EB07BD  rlwinm. r11, r31, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8243A348: 41820014  beq 0x8243a35c
	if ctx.cr[0].eq {
	pc = 0x8243A35C; continue 'dispatch;
	}
	// 8243A34C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8243A350: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8243A354: 419A0008  beq cr6, 0x8243a35c
	if ctx.cr[6].eq {
	pc = 0x8243A35C; continue 'dispatch;
	}
	// 8243A358: 4BEADF11  bl 0x822e8268
	ctx.lr = 0x8243A35C;
	sub_822E8268(ctx, base);
	// 8243A35C: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 8243A360: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8243A364: 38A0003E  li r5, 0x3e
	ctx.r[5].s64 = 62;
	// 8243A368: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 8243A36C: 4BE8606D  bl 0x822c03d8
	ctx.lr = 0x8243A370;
	sub_822C03D8(ctx, base);
	// 8243A370: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8243A374: 41820014  beq 0x8243a388
	if ctx.cr[0].eq {
	pc = 0x8243A388; continue 'dispatch;
	}
	// 8243A378: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 8243A37C: 48056D75  bl 0x824910f0
	ctx.lr = 0x8243A380;
	sub_824910F0(ctx, base);
	// 8243A380: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8243A384: 48000008  b 0x8243a38c
	pc = 0x8243A38C; continue 'dispatch;
	// 8243A388: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8243A38C: 38750050  addi r3, r21, 0x50
	ctx.r[3].s64 = ctx.r[21].s64 + 80;
	// 8243A390: 4BED0351  bl 0x8230a6e0
	ctx.lr = 0x8243A394;
	sub_8230A6E0(ctx, base);
	// 8243A394: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 8243A398: 48D6DE04  b 0x831a819c
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8243A3A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8243A3A0 size=60
    let mut pc: u32 = 0x8243A3A0;
    'dispatch: loop {
        match pc {
            0x8243A3A0 => {
    //   block [0x8243A3A0..0x8243A3DC)
	// 8243A3A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8243A3A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8243A3A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8243A3AC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8243A3B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8243A3B4: 4BFF275D  bl 0x8242cb10
	ctx.lr = 0x8243A3B8;
	sub_8242CB10(ctx, base);
	// 8243A3B8: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8243A3BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8243A3C0: 396B5BC4  addi r11, r11, 0x5bc4
	ctx.r[11].s64 = ctx.r[11].s64 + 23492;
	// 8243A3C4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8243A3C8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8243A3CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8243A3D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8243A3D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8243A3D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8243A3E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8243A3E0 size=392
    let mut pc: u32 = 0x8243A3E0;
    'dispatch: loop {
        match pc {
            0x8243A3E0 => {
    //   block [0x8243A3E0..0x8243A568)
	// 8243A3E0: 3545FFFF  addic. r10, r5, -1
	ctx.xer.ca = (ctx.r[5].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[5].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8243A3E4: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 8243A3E8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8243A3EC: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8243A3F0: 41800028  blt 0x8243a418
	if ctx.cr[0].lt {
	pc = 0x8243A418; continue 'dispatch;
	}
	// 8243A3F4: 39430004  addi r10, r3, 4
	ctx.r[10].s64 = ctx.r[3].s64 + 4;
	// 8243A3F8: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8243A3FC: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 8243A400: D00A0000  stfs f0, 0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 8243A404: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8243A408: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8243A40C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 8243A410: 7F094000  cmpw cr6, r9, r8
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[8].s32, &mut ctx.xer);
	// 8243A414: 4099FFE4  ble cr6, 0x8243a3f8
	if !ctx.cr[6].gt {
	pc = 0x8243A3F8; continue 'dispatch;
	}
	// 8243A418: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8243A41C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 8243A420: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8243A424: 396B000B  addi r11, r11, 0xb
	ctx.r[11].s64 = ctx.r[11].s64 + 11;
	// 8243A428: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8243A42C: C18908A4  lfs f12, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8243A430: 7D8B1D2E  stfsx f12, r11, r3
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32), tmp.u32) };
	// 8243A434: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8243A438: D183002C  stfs f12, 0x2c(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 8243A43C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 8243A440: 40990048  ble cr6, 0x8243a488
	if !ctx.cr[6].gt {
	pc = 0x8243A488; continue 'dispatch;
	}
	// 8243A444: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 8243A448: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 8243A44C: 3963000C  addi r11, r3, 0xc
	ctx.r[11].s64 = ctx.r[3].s64 + 12;
	// 8243A450: C1A9A1C4  lfs f13, -0x5e3c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8243A454: C0089524  lfs f0, -0x6adc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8243A458: C14BFFF8  lfs f10, -8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8243A45C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8243A460: C16BFFFC  lfs f11, -4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8243A464: ED6B503C  fnmsubs f11, f11, f0, f10
	ctx.f[11].f64 = -(((ctx.f[11].f64 * ctx.f[0].f64 - ctx.f[10].f64) as f32) as f64);
	// 8243A468: C14B0000  lfs f10, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8243A46C: ED6B502A  fadds f11, f11, f10
	ctx.f[11].f64 = ((ctx.f[11].f64 + ctx.f[10].f64) as f32) as f64;
	// 8243A470: ED6B0372  fmuls f11, f11, f13
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 8243A474: D16B0024  stfs f11, 0x24(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 8243A478: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8243A47C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8243A480: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 8243A484: 4198FFD4  blt cr6, 0x8243a458
	if ctx.cr[6].lt {
	pc = 0x8243A458; continue 'dispatch;
	}
	// 8243A488: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8243A48C: D181FFE0  stfs f12, -0x20(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), tmp.u32 ) };
	// 8243A490: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 8243A494: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 8243A498: 40990058  ble cr6, 0x8243a4f0
	if !ctx.cr[6].gt {
	pc = 0x8243A4F0; continue 'dispatch;
	}
	// 8243A49C: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 8243A4A0: 3CE08208  lis r7, -0x7df8
	ctx.r[7].s64 = -2113404928;
	// 8243A4A4: 3941FFE4  addi r10, r1, -0x1c
	ctx.r[10].s64 = ctx.r[1].s64 + -28;
	// 8243A4A8: 39630030  addi r11, r3, 0x30
	ctx.r[11].s64 = ctx.r[3].s64 + 48;
	// 8243A4AC: C1A808A8  lfs f13, 0x8a8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8243A4B0: C007E830  lfs f0, -0x17d0(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-6096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8243A4B4: C16AFFFC  lfs f11, -4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8243A4B8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 8243A4BC: ED605828  fsubs f11, f0, f11
	ctx.f[11].f64 = (((ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 8243A4C0: C14B0000  lfs f10, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8243A4C4: C12BFFFC  lfs f9, -4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 8243A4C8: ED4A4828  fsubs f10, f10, f9
	ctx.f[10].f64 = (((ctx.f[10].f64 - ctx.f[9].f64) as f32) as f64);
	// 8243A4CC: ED6D5824  fdivs f11, f13, f11
	ctx.f[11].f64 = ((ctx.f[13].f64 / ctx.f[11].f64) as f32) as f64;
	// 8243A4D0: D16A0000  stfs f11, 0(r10)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 8243A4D4: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 8243A4D8: ED6A02F2  fmuls f11, f10, f11
	ctx.f[11].f64 = (((ctx.f[10].f64 * ctx.f[11].f64) as f32) as f64);
	// 8243A4DC: D16B0000  stfs f11, 0(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 8243A4E0: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8243A4E4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8243A4E8: 7F094000  cmpw cr6, r9, r8
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[8].s32, &mut ctx.xer);
	// 8243A4EC: 4198FFC8  blt cr6, 0x8243a4b4
	if ctx.cr[6].lt {
	pc = 0x8243A4B4; continue 'dispatch;
	}
	// 8243A4F0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8243A4F4: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8243A4F8: 40810040  ble 0x8243a538
	if !ctx.cr[0].gt {
	pc = 0x8243A538; continue 'dispatch;
	}
	// 8243A4FC: 390B000B  addi r8, r11, 0xb
	ctx.r[8].s64 = ctx.r[11].s64 + 11;
	// 8243A500: 3941FFE0  addi r10, r1, -0x20
	ctx.r[10].s64 = ctx.r[1].s64 + -32;
	// 8243A504: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 8243A508: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8243A50C: 7D295214  add r9, r9, r10
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 8243A510: 7D481A14  add r10, r8, r3
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[3].u64;
	// 8243A514: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8243A518: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8243A51C: C1AA0004  lfs f13, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8243A520: C1690000  lfs f11, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8243A524: 3929FFFC  addi r9, r9, -4
	ctx.r[9].s64 = ctx.r[9].s64 + -4;
	// 8243A528: EC0D02FC  fnmsubs f0, f13, f11, f0
	ctx.f[0].f64 = -(((ctx.f[13].f64 * ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 8243A52C: D00A0000  stfs f0, 0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 8243A530: 394AFFFC  addi r10, r10, -4
	ctx.r[10].s64 = ctx.r[10].s64 + -4;
	// 8243A534: 4181FFE0  bgt 0x8243a514
	if ctx.cr[0].gt {
	pc = 0x8243A514; continue 'dispatch;
	}
	// 8243A538: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8243A53C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8243A540: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 8243A544: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8243A548: 7D8B1D2E  stfsx f12, r11, r3
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32), tmp.u32) };
	// 8243A54C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8243A550: 396B0006  addi r11, r11, 6
	ctx.r[11].s64 = ctx.r[11].s64 + 6;
	// 8243A554: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8243A558: 7D8B1D2E  stfsx f12, r11, r3
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32), tmp.u32) };
	// 8243A55C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8243A560: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8243A564: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8243A568(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8243A568 size=80
    let mut pc: u32 = 0x8243A568;
    'dispatch: loop {
        match pc {
            0x8243A568 => {
    //   block [0x8243A568..0x8243A5B8)
	// 8243A568: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 8243A56C: 39630008  addi r11, r3, 8
	ctx.r[11].s64 = ctx.r[3].s64 + 8;
	// 8243A570: C009603C  lfs f0, 0x603c(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(24636 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8243A574: C1AB0024  lfs f13, 0x24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8243A578: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8243A57C: C18B0028  lfs f12, 0x28(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8243A580: ED8C6828  fsubs f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 8243A584: C16B0000  lfs f11, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8243A588: C14BFFFC  lfs f10, -4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8243A58C: ED6B5028  fsubs f11, f11, f10
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[10].f64) as f32) as f64);
	// 8243A590: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 8243A594: D18B0038  stfs f12, 0x38(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 8243A598: EDAB6828  fsubs f13, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 - ctx.f[13].f64) as f32) as f64);
	// 8243A59C: EDAD6028  fsubs f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 8243A5A0: D1AB0010  stfs f13, 0x10(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 8243A5A4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8243A5A8: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8243A5AC: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 8243A5B0: 4198FFC4  blt cr6, 0x8243a574
	if ctx.cr[6].lt {
	pc = 0x8243A574; continue 'dispatch;
	}
	// 8243A5B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8243A5B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8243A5B8 size=188
    let mut pc: u32 = 0x8243A5B8;
    'dispatch: loop {
        match pc {
            0x8243A5B8 => {
    //   block [0x8243A5B8..0x8243A674)
	// 8243A5B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8243A5BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8243A5C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8243A5C4: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 8243A5C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8243A5CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8243A5D0: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8243A5D4: 48D71735  bl 0x831abd08
	ctx.lr = 0x8243A5D8;
	sub_831ABD08(ctx, base);
	// 8243A5D8: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 8243A5DC: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 8243A5E0: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 8243A5E4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8243A5E8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8243A5EC: 4098000C  bge cr6, 0x8243a5f8
	if !ctx.cr[6].lt {
	pc = 0x8243A5F8; continue 'dispatch;
	}
	// 8243A5F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8243A5F4: 48000014  b 0x8243a608
	pc = 0x8243A608; continue 'dispatch;
	// 8243A5F8: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8243A5FC: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 8243A600: 41980008  blt cr6, 0x8243a608
	if ctx.cr[6].lt {
	pc = 0x8243A608; continue 'dispatch;
	}
	// 8243A604: 396AFFFF  addi r11, r10, -1
	ctx.r[11].s64 = ctx.r[10].s64 + -1;
	// 8243A608: 7D6A07B4  extsw r10, r11
	ctx.r[10].s64 = ctx.r[11].s32 as i64;
	// 8243A60C: 392B0010  addi r9, r11, 0x10
	ctx.r[9].s64 = ctx.r[11].s64 + 16;
	// 8243A610: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 8243A614: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8243A618: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 8243A61C: 394B000B  addi r10, r11, 0xb
	ctx.r[10].s64 = ctx.r[11].s64 + 11;
	// 8243A620: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8243A624: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 8243A628: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8243A62C: 390B0006  addi r8, r11, 6
	ctx.r[8].s64 = ctx.r[11].s64 + 6;
	// 8243A630: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8243A634: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8243A638: 7DA9FC2E  lfsx f13, r9, r31
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8243A63C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8243A640: 7D8AFC2E  lfsx f12, r10, r31
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8243A644: 7D68FC2E  lfsx f11, r8, r31
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8243A648: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 8243A64C: 7D4BFC2E  lfsx f10, r11, r31
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8243A650: EDAD603A  fmadds f13, f13, f0, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 8243A654: EDAD583A  fmadds f13, f13, f0, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 8243A658: EC2D503A  fmadds f1, f13, f0, f10
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[10].f64) as f32) as f64);
	// 8243A65C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8243A660: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8243A664: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8243A668: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8243A66C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8243A670: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8243A678(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8243A678 size=96
    let mut pc: u32 = 0x8243A678;
    'dispatch: loop {
        match pc {
            0x8243A678 => {
    //   block [0x8243A678..0x8243A6D8)
	// 8243A678: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8243A67C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8243A680: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8243A684: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8243A688: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8243A68C: 48A1F015  bl 0x82e596a0
	ctx.lr = 0x8243A690;
	sub_82E596A0(ctx, base);
	// 8243A690: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 8243A694: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 8243A698: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 8243A69C: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 8243A6A0: 394A5C04  addi r10, r10, 0x5c04
	ctx.r[10].s64 = ctx.r[10].s64 + 23556;
	// 8243A6A4: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 8243A6A8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8243A6AC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8243A6B0: 991F0018  stb r8, 0x18(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[8].u8 ) };
	// 8243A6B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8243A6B8: 98FF0019  stb r7, 0x19(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(25 as u32), ctx.r[7].u8 ) };
	// 8243A6BC: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8243A6D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8243A6D8 size=160
    let mut pc: u32 = 0x8243A6D8;
    'dispatch: loop {
        match pc {
            0x8243A6D8 => {
    //   block [0x8243A6D8..0x8243A778)
	// 8243A6D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8243A6DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8243A6E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8243A6E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8243A6E8: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 8243A6EC: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8243A6F0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8243A6F4: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8243A6F8: 485D8EA1  bl 0x82a13598
	ctx.lr = 0x8243A6FC;
	sub_82A13598(ctx, base);
	// 8243A6FC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8243A700: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8243A704: 480D4DC5  bl 0x8250f4c8
	ctx.lr = 0x8243A708;
	sub_8250F4C8(ctx, base);
	// 8243A708: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8243A70C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8243A710: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 8243A714: 409A0008  bne cr6, 0x8243a71c
	if !ctx.cr[6].eq {
	pc = 0x8243A71C; continue 'dispatch;
	}
	// 8243A718: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8243A71C: C3FE015C  lfs f31, 0x15c(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(348 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8243A720: 480CDDF9  bl 0x82508518
	ctx.lr = 0x8243A724;
	sub_82508518(ctx, base);
	// 8243A724: EDBF0828  fsubs f13, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (((ctx.f[31].f64 - ctx.f[1].f64) as f32) as f64);
	// 8243A728: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8243A72C: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 8243A730: C00B964C  lfs f0, -0x69b4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8243A734: FDA06A10  fabs f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 & !0x8000_0000_0000_0000u64;
	// 8243A738: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 8243A73C: 41990008  bgt cr6, 0x8243a744
	if ctx.cr[6].gt {
	pc = 0x8243A744; continue 'dispatch;
	}
	// 8243A740: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8243A744: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8243A748: 489B7549  bl 0x82df1c90
	ctx.lr = 0x8243A74C;
	sub_82DF1C90(ctx, base);
	// 8243A74C: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8243A750: 4182000C  beq 0x8243a75c
	if ctx.cr[0].eq {
	pc = 0x8243A75C; continue 'dispatch;
	}
	// 8243A754: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8243A758: 917E0158  stw r11, 0x158(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(344 as u32), ctx.r[11].u32 ) };
	// 8243A75C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8243A760: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8243A764: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8243A768: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 8243A76C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8243A770: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8243A774: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8243A778(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8243A778 size=372
    let mut pc: u32 = 0x8243A778;
    'dispatch: loop {
        match pc {
            0x8243A778 => {
    //   block [0x8243A778..0x8243A8EC)
	// 8243A778: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8243A77C: 48D6D9E1  bl 0x831a815c
	ctx.lr = 0x8243A780;
	sub_831A8130(ctx, base);
	// 8243A780: DBA1FFA8  stfd f29, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[29].u64 ) };
	// 8243A784: DBC1FFB0  stfd f30, -0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 8243A788: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 8243A78C: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8243A790: FFA01090  fmr f29, f2
	ctx.f[29].f64 = ctx.f[2].f64;
	// 8243A794: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8243A798: 3F808335  lis r28, -0x7ccb
	ctx.r[28].s64 = -2093678592;
	// 8243A79C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 8243A7A0: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 8243A7A4: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 8243A7A8: C3EB08A8  lfs f31, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8243A7AC: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 8243A7B0: C1BC5DFC  lfs f13, 0x5dfc(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24060 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8243A7B4: C00A54E8  lfs f0, 0x54e8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(21736 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8243A7B8: C1899524  lfs f12, -0x6adc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8243A7BC: EC01683A  fmadds f0, f1, f0, f13
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 8243A7C0: C1A808A4  lfs f13, 0x8a4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8243A7C4: EFDFE824  fdivs f30, f31, f29
	ctx.f[30].f64 = ((ctx.f[31].f64 / ctx.f[29].f64) as f32) as f64;
	// 8243A7C8: D01C5DFC  stfs f0, 0x5dfc(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(24060 as u32), tmp.u32 ) };
	// 8243A7CC: ED9E0332  fmuls f12, f30, f12
	ctx.f[12].f64 = (((ctx.f[30].f64 * ctx.f[12].f64) as f32) as f64);
	// 8243A7D0: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 8243A7D4: 4099000C  ble cr6, 0x8243a7e0
	if !ctx.cr[6].gt {
	pc = 0x8243A7E0; continue 'dispatch;
	}
	// 8243A7D8: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 8243A7DC: D01C5DFC  stfs f0, 0x5dfc(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(24060 as u32), tmp.u32 ) };
	// 8243A7E0: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 8243A7E4: FF1D6800  fcmpu cr6, f29, f13
	ctx.cr[6].compare_f64(ctx.f[29].f64, ctx.f[13].f64);
	// 8243A7E8: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 8243A7EC: 409900EC  ble cr6, 0x8243a8d8
	if !ctx.cr[6].gt {
	pc = 0x8243A8D8; continue 'dispatch;
	}
	// 8243A7F0: 3BB90010  addi r29, r25, 0x10
	ctx.r[29].s64 = ctx.r[25].s64 + 16;
	// 8243A7F4: 3B6000FF  li r27, 0xff
	ctx.r[27].s64 = 255;
	// 8243A7F8: 48000008  b 0x8243a800
	pc = 0x8243A800; continue 'dispatch;
	// 8243A7FC: C01C5DFC  lfs f0, 0x5dfc(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24060 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8243A800: EC0D07BA  fmadds f0, f13, f30, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[30].f64 + ctx.f[0].f64) as f32) as f64);
	// 8243A804: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 8243A808: 41980008  blt cr6, 0x8243a810
	if ctx.cr[6].lt {
	pc = 0x8243A810; continue 'dispatch;
	}
	// 8243A80C: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 8243A810: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 8243A814: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	// 8243A818: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8243A81C: 4BFDAB45  bl 0x82415360
	ctx.lr = 0x8243A820;
	sub_82415360(ctx, base);
	// 8243A820: 3BDF0001  addi r30, r31, 1
	ctx.r[30].s64 = ctx.r[31].s64 + 1;
	// 8243A824: C01C5DFC  lfs f0, 0x5dfc(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24060 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8243A828: 7FCB07B4  extsw r11, r30
	ctx.r[11].s64 = ctx.r[30].s32 as i64;
	// 8243A82C: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 8243A830: C9A10058  lfd f13, 0x58(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8243A834: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 8243A838: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 8243A83C: EC0D07BA  fmadds f0, f13, f30, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[30].f64 + ctx.f[0].f64) as f32) as f64);
	// 8243A840: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 8243A844: 41980008  blt cr6, 0x8243a84c
	if ctx.cr[6].lt {
	pc = 0x8243A84C; continue 'dispatch;
	}
	// 8243A848: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 8243A84C: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 8243A850: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	// 8243A854: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8243A858: 4BFDAB09  bl 0x82415360
	ctx.lr = 0x8243A85C;
	sub_82415360(ctx, base);
	// 8243A85C: 7FEB0E70  srawi r11, r31, 1
	ctx.xer.ca = (ctx.r[31].s32 < 0) && ((ctx.r[31].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[31].s32 >> 1) as i64;
	// 8243A860: 7D6B0194  addze r11, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[11].s64 = tmp.s64;
	// 8243A864: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8243A868: 7D6BF851  subf. r11, r11, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8243A86C: 4082004C  bne 0x8243a8b8
	if !ctx.cr[0].eq {
	pc = 0x8243A8B8; continue 'dispatch;
	}
	// 8243A870: 9B610050  stb r27, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u8 ) };
	// 8243A874: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8243A878: 9B410051  stb r26, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[26].u8 ) };
	// 8243A87C: 9B610052  stb r27, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[27].u8 ) };
	// 8243A880: 9B410053  stb r26, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[26].u8 ) };
	// 8243A884: 80990004  lwz r4, 4(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 8243A888: 4BF66FB1  bl 0x823a1838
	ctx.lr = 0x8243A88C;
	sub_823A1838(ctx, base);
	// 8243A88C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8243A890: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8243A894: 386BFF34  addi r3, r11, -0xcc
	ctx.r[3].s64 = ctx.r[11].s64 + -204;
	// 8243A898: 409A0008  bne cr6, 0x8243a8a0
	if !ctx.cr[6].eq {
	pc = 0x8243A8A0; continue 'dispatch;
	}
	// 8243A89C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8243A8A0: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 8243A8A4: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 8243A8A8: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 8243A8AC: 4BE8D0F5  bl 0x822c79a0
	ctx.lr = 0x8243A8B0;
	sub_822C79A0(ctx, base);
	// 8243A8B0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8243A8B4: 489B73DD  bl 0x82df1c90
	ctx.lr = 0x8243A8B8;
	sub_82DF1C90(ctx, base);
	// 8243A8B8: 7FCB07B4  extsw r11, r30
	ctx.r[11].s64 = ctx.r[30].s32 as i64;
	// 8243A8BC: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 8243A8C0: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 8243A8C4: C8010068  lfd f0, 0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 8243A8C8: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 8243A8CC: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8243A8D0: FF0DE800  fcmpu cr6, f13, f29
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[29].f64);
	// 8243A8D4: 4198FF28  blt cr6, 0x8243a7fc
	if ctx.cr[6].lt {
	pc = 0x8243A7FC; continue 'dispatch;
	}
	// 8243A8D8: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 8243A8DC: CBA1FFA8  lfd f29, -0x58(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 8243A8E0: CBC1FFB0  lfd f30, -0x50(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 8243A8E4: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 8243A8E8: 48D6D8C4  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8243A8F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8243A8F0 size=196
    let mut pc: u32 = 0x8243A8F0;
    'dispatch: loop {
        match pc {
            0x8243A8F0 => {
    //   block [0x8243A8F0..0x8243A9B4)
	// 8243A8F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8243A8F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8243A8F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8243A8FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8243A900: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8243A904: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8243A908: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8243A90C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8243A910: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8243A914: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8243A918: 4BE86021  bl 0x822c0938
	ctx.lr = 0x8243A91C;
	sub_822C0938(ctx, base);
	// 8243A91C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8243A920: 41820028  beq 0x8243a948
	if ctx.cr[0].eq {
	pc = 0x8243A948; continue 'dispatch;
	}
	// 8243A924: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8243A928: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8243A92C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8243A930: 392B5BDC  addi r9, r11, 0x5bdc
	ctx.r[9].s64 = ctx.r[11].s64 + 23516;
	// 8243A934: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8243A938: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8243A93C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8243A940: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8243A944: 48000008  b 0x8243a94c
	pc = 0x8243A94C; continue 'dispatch;
	// 8243A948: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8243A94C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8243A950: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8243A954: 409A0044  bne cr6, 0x8243a998
	if !ctx.cr[6].eq {
	pc = 0x8243A998; continue 'dispatch;
	}
	// 8243A958: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8243A95C: 419A001C  beq cr6, 0x8243a978
	if ctx.cr[6].eq {
	pc = 0x8243A978; continue 'dispatch;
	}
	// 8243A960: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8243A964: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8243A968: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8243A96C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8243A970: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8243A974: 4E800421  bctrl
	ctx.lr = 0x8243A978;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8243A978: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 8243A97C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8243A980: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8243A984: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8243A988: 816B22A4  lwz r11, 0x22a4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8868 as u32) ) } as u64;
	// 8243A98C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8243A990: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8243A994: 4BE8566D  bl 0x822c0000
	ctx.lr = 0x8243A998;
	sub_822C0000(ctx, base);
	// 8243A998: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8243A99C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8243A9A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8243A9A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8243A9A8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8243A9AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8243A9B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8243A9B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8243A9B8 size=196
    let mut pc: u32 = 0x8243A9B8;
    'dispatch: loop {
        match pc {
            0x8243A9B8 => {
    //   block [0x8243A9B8..0x8243AA7C)
	// 8243A9B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8243A9BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8243A9C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8243A9C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8243A9C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8243A9CC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8243A9D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8243A9D4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8243A9D8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8243A9DC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8243A9E0: 4BE85F59  bl 0x822c0938
	ctx.lr = 0x8243A9E4;
	sub_822C0938(ctx, base);
	// 8243A9E4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8243A9E8: 41820028  beq 0x8243aa10
	if ctx.cr[0].eq {
	pc = 0x8243AA10; continue 'dispatch;
	}
	// 8243A9EC: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8243A9F0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8243A9F4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8243A9F8: 392B5BF0  addi r9, r11, 0x5bf0
	ctx.r[9].s64 = ctx.r[11].s64 + 23536;
	// 8243A9FC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8243AA00: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8243AA04: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8243AA08: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8243AA0C: 48000008  b 0x8243aa14
	pc = 0x8243AA14; continue 'dispatch;
	// 8243AA10: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8243AA14: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8243AA18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8243AA1C: 409A0044  bne cr6, 0x8243aa60
	if !ctx.cr[6].eq {
	pc = 0x8243AA60; continue 'dispatch;
	}
	// 8243AA20: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8243AA24: 419A001C  beq cr6, 0x8243aa40
	if ctx.cr[6].eq {
	pc = 0x8243AA40; continue 'dispatch;
	}
	// 8243AA28: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8243AA2C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8243AA30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8243AA34: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8243AA38: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8243AA3C: 4E800421  bctrl
	ctx.lr = 0x8243AA40;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8243AA40: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 8243AA44: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8243AA48: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8243AA4C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8243AA50: 816B22A4  lwz r11, 0x22a4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8868 as u32) ) } as u64;
	// 8243AA54: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8243AA58: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8243AA5C: 4BE855A5  bl 0x822c0000
	ctx.lr = 0x8243AA60;
	sub_822C0000(ctx, base);
	// 8243AA60: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8243AA64: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8243AA68: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8243AA6C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8243AA70: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8243AA74: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8243AA78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8243AA80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8243AA80 size=80
    let mut pc: u32 = 0x8243AA80;
    'dispatch: loop {
        match pc {
            0x8243AA80 => {
    //   block [0x8243AA80..0x8243AAD0)
	// 8243AA80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8243AA84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8243AA88: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8243AA8C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8243AA90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8243AA94: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8243AA98: 396B5C0C  addi r11, r11, 0x5c0c
	ctx.r[11].s64 = ctx.r[11].s64 + 23564;
	// 8243AA9C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8243AAA0: 807F0150  lwz r3, 0x150(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) } as u64;
	// 8243AAA4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8243AAA8: 419A0008  beq cr6, 0x8243aab0
	if ctx.cr[6].eq {
	pc = 0x8243AAB0; continue 'dispatch;
	}
	// 8243AAAC: 4BE85DE5  bl 0x822c0890
	ctx.lr = 0x8243AAB0;
	sub_822C0890(ctx, base);
	// 8243AAB0: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8243AAB4: 396B55C8  addi r11, r11, 0x55c8
	ctx.r[11].s64 = ctx.r[11].s64 + 21960;
	// 8243AAB8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8243AABC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8243AAC0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8243AAC4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8243AAC8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8243AACC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8243AAD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8243AAD0 size=220
    let mut pc: u32 = 0x8243AAD0;
    'dispatch: loop {
        match pc {
            0x8243AAD0 => {
    //   block [0x8243AAD0..0x8243ABAC)
	// 8243AAD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8243AAD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8243AAD8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8243AADC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8243AAE0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8243AAE4: 4BFF202D  bl 0x8242cb10
	ctx.lr = 0x8243AAE8;
	sub_8242CB10(ctx, base);
	// 8243AAE8: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 8243AAEC: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 8243AAF0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8243AAF4: 390A5C0C  addi r8, r10, 0x5c0c
	ctx.r[8].s64 = ctx.r[10].s64 + 23564;
	// 8243AAF8: 395F0010  addi r10, r31, 0x10
	ctx.r[10].s64 = ctx.r[31].s64 + 16;
	// 8243AAFC: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 8243AB00: C009093C  lfs f0, 0x93c(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2364 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8243AB04: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 8243AB08: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 8243AB0C: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	// 8243AB10: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 8243AB14: 91680000  stw r11, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8243AB18: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8243AB1C: 39080068  addi r8, r8, 0x68
	ctx.r[8].s64 = ctx.r[8].s64 + 104;
	// 8243AB20: 4080FFF4  bge 0x8243ab14
	if !ctx.cr[0].lt {
	pc = 0x8243AB14; continue 'dispatch;
	}
	// 8243AB24: 3D208338  lis r9, -0x7cc8
	ctx.r[9].s64 = -2093481984;
	// 8243AB28: 917F0148  stw r11, 0x148(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(328 as u32), ctx.r[11].u32 ) };
	// 8243AB2C: 3D008209  lis r8, -0x7df7
	ctx.r[8].s64 = -2113339392;
	// 8243AB30: 917F014C  stw r11, 0x14c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(332 as u32), ctx.r[11].u32 ) };
	// 8243AB34: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 8243AB38: 917F0150  stw r11, 0x150(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), ctx.r[11].u32 ) };
	// 8243AB3C: 3CC08208  lis r6, -0x7df8
	ctx.r[6].s64 = -2113404928;
	// 8243AB40: 917F0158  stw r11, 0x158(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(344 as u32), ctx.r[11].u32 ) };
	// 8243AB44: 38A96910  addi r5, r9, 0x6910
	ctx.r[5].s64 = ctx.r[9].s64 + 26896;
	// 8243AB48: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 8243AB4C: C008ACFC  lfs f0, -0x5304(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-21252 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8243AB50: 39000170  li r8, 0x170
	ctx.r[8].s64 = 368;
	// 8243AB54: C1A708A4  lfs f13, 0x8a4(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8243AB58: 993F0164  stb r9, 0x164(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(356 as u32), ctx.r[9].u8 ) };
	// 8243AB5C: C186E830  lfs f12, -0x17d0(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-6096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8243AB60: 38E00190  li r7, 0x190
	ctx.r[7].s64 = 400;
	// 8243AB64: D01F0154  stfs f0, 0x154(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(340 as u32), tmp.u32 ) };
	// 8243AB68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8243AB6C: D1BF015C  stfs f13, 0x15c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(348 as u32), tmp.u32 ) };
	// 8243AB70: D19F0160  stfs f12, 0x160(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), tmp.u32 ) };
	// 8243AB74: 13E028C7  vcmpequd (lvx128) v31, v0, v5
	tmp.u32 = ctx.r[5].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8243ABB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8243ABB0 size=76
    let mut pc: u32 = 0x8243ABB0;
    'dispatch: loop {
        match pc {
            0x8243ABB0 => {
    //   block [0x8243ABB0..0x8243ABFC)
	// 8243ABB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8243ABB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8243ABB8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8243ABBC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8243ABC0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8243ABC4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8243ABC8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8243ABCC: 4BFFFEB5  bl 0x8243aa80
	ctx.lr = 0x8243ABD0;
	sub_8243AA80(ctx, base);
	// 8243ABD0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8243ABD4: 4182000C  beq 0x8243abe0
	if ctx.cr[0].eq {
	pc = 0x8243ABE0; continue 'dispatch;
	}
	// 8243ABD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8243ABDC: 489B77FD  bl 0x82df23d8
	ctx.lr = 0x8243ABE0;
	sub_82DF23D8(ctx, base);
	// 8243ABE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8243ABE4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8243ABE8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8243ABEC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8243ABF0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8243ABF4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8243ABF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8243AC00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8243AC00 size=112
    let mut pc: u32 = 0x8243AC00;
    'dispatch: loop {
        match pc {
            0x8243AC00 => {
    //   block [0x8243AC00..0x8243AC70)
	// 8243AC00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8243AC04: 48D6D569  bl 0x831a816c
	ctx.lr = 0x8243AC08;
	sub_831A8130(ctx, base);
	// 8243AC08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8243AC0C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8243AC10: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8243AC14: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8243AC18: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 8243AC1C: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 8243AC20: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 8243AC24: 489B77C5  bl 0x82df23e8
	ctx.lr = 0x8243AC28;
	sub_82DF23E8(ctx, base);
	// 8243AC28: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8243AC2C: 41820010  beq 0x8243ac3c
	if ctx.cr[0].eq {
	pc = 0x8243AC3C; continue 'dispatch;
	}
	// 8243AC30: 4BFFFA49  bl 0x8243a678
	ctx.lr = 0x8243AC34;
	sub_8243A678(ctx, base);
	// 8243AC34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8243AC38: 48000008  b 0x8243ac40
	pc = 0x8243AC40; continue 'dispatch;
	// 8243AC3C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8243AC40: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8243AC44: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8243AC48: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8243AC4C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8243AC50: 4BFFFCA1  bl 0x8243a8f0
	ctx.lr = 0x8243AC54;
	sub_8243A8F0(ctx, base);
	// 8243AC54: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8243AC58: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8243AC5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8243AC60: 4BE853A1  bl 0x822c0000
	ctx.lr = 0x8243AC64;
	sub_822C0000(ctx, base);
	// 8243AC64: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8243AC68: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8243AC6C: 48D6D550  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8243AC70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8243AC70 size=124
    let mut pc: u32 = 0x8243AC70;
    'dispatch: loop {
        match pc {
            0x8243AC70 => {
    //   block [0x8243AC70..0x8243ACEC)
	// 8243AC70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8243AC74: 48D6D4F9  bl 0x831a816c
	ctx.lr = 0x8243AC78;
	sub_831A8130(ctx, base);
	// 8243AC78: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8243AC7C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8243AC80: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8243AC84: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8243AC88: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 8243AC8C: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 8243AC90: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 8243AC94: 489B7755  bl 0x82df23e8
	ctx.lr = 0x8243AC98;
	sub_82DF23E8(ctx, base);
	// 8243AC98: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8243AC9C: 4182001C  beq 0x8243acb8
	if ctx.cr[0].eq {
	pc = 0x8243ACB8; continue 'dispatch;
	}
	// 8243ACA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8243ACA4: 48A1E9FD  bl 0x82e596a0
	ctx.lr = 0x8243ACA8;
	sub_82E596A0(ctx, base);
	// 8243ACA8: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8243ACAC: 396B5BD4  addi r11, r11, 0x5bd4
	ctx.r[11].s64 = ctx.r[11].s64 + 23508;
	// 8243ACB0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8243ACB4: 48000008  b 0x8243acbc
	pc = 0x8243ACBC; continue 'dispatch;
	// 8243ACB8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8243ACBC: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8243ACC0: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8243ACC4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8243ACC8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8243ACCC: 4BFFFCED  bl 0x8243a9b8
	ctx.lr = 0x8243ACD0;
	sub_8243A9B8(ctx, base);
	// 8243ACD0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8243ACD4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8243ACD8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8243ACDC: 4BE85325  bl 0x822c0000
	ctx.lr = 0x8243ACE0;
	sub_822C0000(ctx, base);
	// 8243ACE0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8243ACE4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8243ACE8: 48D6D4D4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8243ACF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8243ACF0 size=316
    let mut pc: u32 = 0x8243ACF0;
    'dispatch: loop {
        match pc {
            0x8243ACF0 => {
    //   block [0x8243ACF0..0x8243AE2C)
	// 8243ACF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8243ACF4: 48D6D471  bl 0x831a8164
	ctx.lr = 0x8243ACF8;
	sub_831A8130(ctx, base);
	// 8243ACF8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8243ACFC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8243AD00: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8243AD04: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 8243AD08: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8243AD0C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8243AD10: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8243AD14: 388B5C18  addi r4, r11, 0x5c18
	ctx.r[4].s64 = ctx.r[11].s64 + 23576;
	// 8243AD18: 38A00070  li r5, 0x70
	ctx.r[5].s64 = 112;
	// 8243AD1C: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 8243AD20: 4BE856B9  bl 0x822c03d8
	ctx.lr = 0x8243AD24;
	sub_822C03D8(ctx, base);
	// 8243AD24: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8243AD28: 41820098  beq 0x8243adc0
	if ctx.cr[0].eq {
	pc = 0x8243ADC0; continue 'dispatch;
	}
	// 8243AD2C: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 8243AD30: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 8243AD34: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 8243AD38: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 8243AD3C: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8243AD40: 48A659F1  bl 0x82ea0730
	ctx.lr = 0x8243AD44;
	sub_82EA0730(ctx, base);
	// 8243AD44: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 8243AD48: 3D408326  lis r10, -0x7cda
	ctx.r[10].s64 = -2094661632;
	// 8243AD4C: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 8243AD50: C02A6464  lfs f1, 0x6464(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25700 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8243AD54: 48ADF49D  bl 0x82f1a1f0
	ctx.lr = 0x8243AD58;
	sub_82F1A1F0(ctx, base);
	// 8243AD58: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 8243AD5C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 8243AD60: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8243AD64: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 8243AD68: 808B6890  lwz r4, 0x6890(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26768 as u32) ) } as u64;
	// 8243AD6C: 4BEAA1C5  bl 0x822e4f30
	ctx.lr = 0x8243AD70;
	sub_822E4F30(ctx, base);
	// 8243AD70: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8243AD74: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8243AD78: 4BEAA149  bl 0x822e4ec0
	ctx.lr = 0x8243AD7C;
	sub_822E4EC0(ctx, base);
	// 8243AD7C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8243AD80: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8243AD84: E89B0000  ld r4, 0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	// 8243AD88: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8243AD8C: E8630000  ld r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 8243AD90: 480514F9  bl 0x8248c288
	ctx.lr = 0x8243AD94;
	sub_8248C288(ctx, base);
	// 8243AD94: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 8243AD98: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 8243AD9C: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 8243ADA0: 38EBBA80  addi r7, r11, -0x4580
	ctx.r[7].s64 = ctx.r[11].s64 + -17792;
	// 8243ADA4: 38CA6910  addi r6, r10, 0x6910
	ctx.r[6].s64 = ctx.r[10].s64 + 26896;
	// 8243ADA8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8243ADAC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8243ADB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8243ADB4: 480573ED  bl 0x824921a0
	ctx.lr = 0x8243ADB8;
	sub_824921A0(ctx, base);
	// 8243ADB8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8243ADBC: 48000008  b 0x8243adc4
	pc = 0x8243ADC4; continue 'dispatch;
	// 8243ADC0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8243ADC4: 387C014C  addi r3, r28, 0x14c
	ctx.r[3].s64 = ctx.r[28].s64 + 332;
	// 8243ADC8: 4BEAA021  bl 0x822e4de8
	ctx.lr = 0x8243ADCC;
	sub_822E4DE8(ctx, base);
	// 8243ADCC: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8243ADD0: 41820014  beq 0x8243ade4
	if ctx.cr[0].eq {
	pc = 0x8243ADE4; continue 'dispatch;
	}
	// 8243ADD4: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8243ADD8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8243ADDC: 419A0008  beq cr6, 0x8243ade4
	if ctx.cr[6].eq {
	pc = 0x8243ADE4; continue 'dispatch;
	}
	// 8243ADE0: 4BEAD489  bl 0x822e8268
	ctx.lr = 0x8243ADE4;
	sub_822E8268(ctx, base);
	// 8243ADE4: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 8243ADE8: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 8243ADEC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8243ADF0: 80AB6870  lwz r5, 0x6870(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26736 as u32) ) } as u64;
	// 8243ADF4: 808A6750  lwz r4, 0x6750(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(26448 as u32) ) } as u64;
	// 8243ADF8: 4BEBC9A9  bl 0x822f77a0
	ctx.lr = 0x8243ADFC;
	sub_822F77A0(ctx, base);
	// 8243ADFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8243AE00: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8243AE04: 4BEAA0BD  bl 0x822e4ec0
	ctx.lr = 0x8243AE08;
	sub_822E4EC0(ctx, base);
	// 8243AE08: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8243AE0C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8243AE10: E89F0000  ld r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	// 8243AE14: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8243AE18: E8630000  ld r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 8243AE1C: 4805146D  bl 0x8248c288
	ctx.lr = 0x8243AE20;
	sub_8248C288(ctx, base);
	// 8243AE20: 907C0168  stw r3, 0x168(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(360 as u32), ctx.r[3].u32 ) };
	// 8243AE24: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8243AE28: 48D6D38C  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8243AE30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8243AE30 size=2952
    let mut pc: u32 = 0x8243AE30;
    'dispatch: loop {
        match pc {
            0x8243AE30 => {
    //   block [0x8243AE30..0x8243B9B8)
	// 8243AE30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8243AE34: 48D6D305  bl 0x831a8138
	ctx.lr = 0x8243AE38;
	sub_831A8130(ctx, base);
	// 8243AE38: 3981FF78  addi r12, r1, -0x88
	ctx.r[12].s64 = ctx.r[1].s64 + -136;
	// 8243AE3C: 48D6DC2D  bl 0x831a8a68
	ctx.lr = 0x8243AE40;
	sub_831A8A40(ctx, base);
	// 8243AE40: 3980FF20  li r12, -0xe0
	ctx.r[12].s64 = -224;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8243B9B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8243B9B8 size=612
    let mut pc: u32 = 0x8243B9B8;
    'dispatch: loop {
        match pc {
            0x8243B9B8 => {
    //   block [0x8243B9B8..0x8243BC1C)
	// 8243B9B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8243B9BC: 48D6C7A9  bl 0x831a8164
	ctx.lr = 0x8243B9C0;
	sub_831A8130(ctx, base);
	// 8243B9C0: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8243B9C4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8243B9C8: 39410058  addi r10, r1, 0x58
	ctx.r[10].s64 = ctx.r[1].s64 + 88;
	// 8243B9CC: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 8243B9D0: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 8243B9D4: 3D208202  lis r9, -0x7dfe
	ctx.r[9].s64 = -2113798144;
	// 8243B9D8: C00BC664  lfs f0, -0x399c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-14748 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8243B9DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8243B9E0: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8243B9E4: 39292770  addi r9, r9, 0x2770
	ctx.r[9].s64 = ctx.r[9].s64 + 10096;
	// 8243B9E8: 13A05407  vcmpneb. (lvlx128) v29, v0, v10
	tmp.u32 = ctx.r[10].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8243BC20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8243BC20 size=496
    let mut pc: u32 = 0x8243BC20;
    'dispatch: loop {
        match pc {
            0x8243BC20 => {
    //   block [0x8243BC20..0x8243BE10)
	// 8243BC20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8243BC24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8243BC28: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8243BC2C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8243BC30: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 8243BC34: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8243BE10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8243BE10 size=760
    let mut pc: u32 = 0x8243BE10;
    'dispatch: loop {
        match pc {
            0x8243BE10 => {
    //   block [0x8243BE10..0x8243C108)
	// 8243BE10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8243BE14: 48D6C351  bl 0x831a8164
	ctx.lr = 0x8243BE18;
	sub_831A8130(ctx, base);
	// 8243BE18: 3980FFA0  li r12, -0x60
	ctx.r[12].s64 = -96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8243C108(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8243C108 size=460
    let mut pc: u32 = 0x8243C108;
    'dispatch: loop {
        match pc {
            0x8243C108 => {
    //   block [0x8243C108..0x8243C2D4)
	// 8243C108: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8243C10C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8243C110: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8243C114: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8243C118: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8243C2D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8243C2D8 size=488
    let mut pc: u32 = 0x8243C2D8;
    'dispatch: loop {
        match pc {
            0x8243C2D8 => {
    //   block [0x8243C2D8..0x8243C4C0)
	// 8243C2D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8243C2DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8243C2E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8243C2E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8243C2E8: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8243C4C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8243C4C0 size=648
    let mut pc: u32 = 0x8243C4C0;
    'dispatch: loop {
        match pc {
            0x8243C4C0 => {
    //   block [0x8243C4C0..0x8243C748)
	// 8243C4C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8243C4C4: 48D6BCA9  bl 0x831a816c
	ctx.lr = 0x8243C4C8;
	sub_831A8130(ctx, base);
	// 8243C4C8: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8243C748(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8243C748 size=208
    let mut pc: u32 = 0x8243C748;
    'dispatch: loop {
        match pc {
            0x8243C748 => {
    //   block [0x8243C748..0x8243C818)
	// 8243C748: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8243C74C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8243C750: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8243C754: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8243C758: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8243C75C: 4BFF03B5  bl 0x8242cb10
	ctx.lr = 0x8243C760;
	sub_8242CB10(ctx, base);
	// 8243C760: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8243C764: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 8243C768: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 8243C76C: 3CE08203  lis r7, -0x7dfd
	ctx.r[7].s64 = -2113732608;
	// 8243C770: 3CC08202  lis r6, -0x7dfe
	ctx.r[6].s64 = -2113798144;
	// 8243C774: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8243C778: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8243C77C: 39465C84  addi r10, r6, 0x5c84
	ctx.r[10].s64 = ctx.r[6].s64 + 23684;
	// 8243C780: C1896150  lfs f12, 0x6150(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(24912 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8243C784: C1A89450  lfs f13, -0x6bb0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8243C788: 997F006C  stb r11, 0x6c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[11].u8 ) };
	// 8243C78C: C1677BC8  lfs f11, 0x7bc8(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(31688 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8243C790: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8243C794: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8243C798: 997F006D  stb r11, 0x6d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(109 as u32), ctx.r[11].u8 ) };
	// 8243C79C: D01F0064  stfs f0, 0x64(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 8243C7A0: 997F006E  stb r11, 0x6e(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(110 as u32), ctx.r[11].u8 ) };
	// 8243C7A4: D19F0070  stfs f12, 0x70(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8243C7A8: 997F006F  stb r11, 0x6f(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(111 as u32), ctx.r[11].u8 ) };
	// 8243C7AC: D1BF0074  stfs f13, 0x74(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 8243C7B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8243C7B4: D17F0078  stfs f11, 0x78(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8243C7B8: D1BF007C  stfs f13, 0x7c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 8243C7BC: 917F00E0  stw r11, 0xe0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), ctx.r[11].u32 ) };
	// 8243C7C0: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 8243C7C4: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 8243C7C8: 917F00EC  stw r11, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 8243C7CC: 917F00F0  stw r11, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 8243C7D0: 917F00F4  stw r11, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 8243C7D4: 917F00F8  stw r11, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[11].u32 ) };
	// 8243C7D8: 917F00FC  stw r11, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[11].u32 ) };
	// 8243C7DC: 917F0100  stw r11, 0x100(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[11].u32 ) };
	// 8243C7E0: 917F0104  stw r11, 0x104(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[11].u32 ) };
	// 8243C7E4: 917F0108  stw r11, 0x108(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[11].u32 ) };
	// 8243C7E8: 917F010C  stw r11, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[11].u32 ) };
	// 8243C7EC: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 8243C7F0: 917F0114  stw r11, 0x114(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), ctx.r[11].u32 ) };
	// 8243C7F4: 917F0118  stw r11, 0x118(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), ctx.r[11].u32 ) };
	// 8243C7F8: 917F011C  stw r11, 0x11c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(284 as u32), ctx.r[11].u32 ) };
	// 8243C7FC: 917F0120  stw r11, 0x120(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), ctx.r[11].u32 ) };
	// 8243C800: 917F0124  stw r11, 0x124(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(292 as u32), ctx.r[11].u32 ) };
	// 8243C804: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8243C808: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8243C80C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8243C810: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8243C814: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8243C818(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8243C818 size=164
    let mut pc: u32 = 0x8243C818;
    'dispatch: loop {
        match pc {
            0x8243C818 => {
    //   block [0x8243C818..0x8243C8BC)
	// 8243C818: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8243C81C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8243C820: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8243C824: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8243C828: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8243C82C: 807F0124  lwz r3, 0x124(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(292 as u32) ) } as u64;
	// 8243C830: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8243C834: 419A0008  beq cr6, 0x8243c83c
	if ctx.cr[6].eq {
	pc = 0x8243C83C; continue 'dispatch;
	}
	// 8243C838: 4BE84059  bl 0x822c0890
	ctx.lr = 0x8243C83C;
	sub_822C0890(ctx, base);
	// 8243C83C: 807F011C  lwz r3, 0x11c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(284 as u32) ) } as u64;
	// 8243C840: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8243C844: 419A0008  beq cr6, 0x8243c84c
	if ctx.cr[6].eq {
	pc = 0x8243C84C; continue 'dispatch;
	}
	// 8243C848: 4BE84049  bl 0x822c0890
	ctx.lr = 0x8243C84C;
	sub_822C0890(ctx, base);
	// 8243C84C: 807F0104  lwz r3, 0x104(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) } as u64;
	// 8243C850: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8243C854: 419A0008  beq cr6, 0x8243c85c
	if ctx.cr[6].eq {
	pc = 0x8243C85C; continue 'dispatch;
	}
	// 8243C858: 4BE84039  bl 0x822c0890
	ctx.lr = 0x8243C85C;
	sub_822C0890(ctx, base);
	// 8243C85C: 807F00FC  lwz r3, 0xfc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 8243C860: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8243C864: 419A0008  beq cr6, 0x8243c86c
	if ctx.cr[6].eq {
	pc = 0x8243C86C; continue 'dispatch;
	}
	// 8243C868: 4BE84029  bl 0x822c0890
	ctx.lr = 0x8243C86C;
	sub_822C0890(ctx, base);
	// 8243C86C: 807F00F4  lwz r3, 0xf4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 8243C870: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8243C874: 419A0008  beq cr6, 0x8243c87c
	if ctx.cr[6].eq {
	pc = 0x8243C87C; continue 'dispatch;
	}
	// 8243C878: 4BE84019  bl 0x822c0890
	ctx.lr = 0x8243C87C;
	sub_822C0890(ctx, base);
	// 8243C87C: 807F00EC  lwz r3, 0xec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 8243C880: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8243C884: 419A0008  beq cr6, 0x8243c88c
	if ctx.cr[6].eq {
	pc = 0x8243C88C; continue 'dispatch;
	}
	// 8243C888: 4BE84009  bl 0x822c0890
	ctx.lr = 0x8243C88C;
	sub_822C0890(ctx, base);
	// 8243C88C: 807F00E4  lwz r3, 0xe4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 8243C890: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8243C894: 419A0008  beq cr6, 0x8243c89c
	if ctx.cr[6].eq {
	pc = 0x8243C89C; continue 'dispatch;
	}
	// 8243C898: 4BE83FF9  bl 0x822c0890
	ctx.lr = 0x8243C89C;
	sub_822C0890(ctx, base);
	// 8243C89C: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8243C8A0: 396B55C8  addi r11, r11, 0x55c8
	ctx.r[11].s64 = ctx.r[11].s64 + 21960;
	// 8243C8A4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8243C8A8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8243C8AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8243C8B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8243C8B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8243C8B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8243C8C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8243C8C0 size=76
    let mut pc: u32 = 0x8243C8C0;
    'dispatch: loop {
        match pc {
            0x8243C8C0 => {
    //   block [0x8243C8C0..0x8243C90C)
	// 8243C8C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8243C8C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8243C8C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8243C8CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8243C8D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8243C8D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8243C8D8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8243C8DC: 4BFFFF3D  bl 0x8243c818
	ctx.lr = 0x8243C8E0;
	sub_8243C818(ctx, base);
	// 8243C8E0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8243C8E4: 4182000C  beq 0x8243c8f0
	if ctx.cr[0].eq {
	pc = 0x8243C8F0; continue 'dispatch;
	}
	// 8243C8E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8243C8EC: 489B5AED  bl 0x82df23d8
	ctx.lr = 0x8243C8F0;
	sub_82DF23D8(ctx, base);
	// 8243C8F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8243C8F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8243C8F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8243C8FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8243C900: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8243C904: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8243C908: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8243C910(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8243C910 size=536
    let mut pc: u32 = 0x8243C910;
    'dispatch: loop {
        match pc {
            0x8243C910 => {
    //   block [0x8243C910..0x8243CB28)
	// 8243C910: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8243C914: 48D6B845  bl 0x831a8158
	ctx.lr = 0x8243C918;
	sub_831A8130(ctx, base);
	// 8243C918: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8243C91C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8243C920: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8243C924: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8243C928: 4BF99601  bl 0x823d5f28
	ctx.lr = 0x8243C92C;
	sub_823D5F28(ctx, base);
	// 8243C92C: 83010054  lwz r24, 0x54(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8243C930: 83210050  lwz r25, 0x50(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8243C934: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 8243C938: 93010054  stw r24, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[24].u32 ) };
	// 8243C93C: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 8243C940: 419A0024  beq cr6, 0x8243c964
	if ctx.cr[6].eq {
	pc = 0x8243C964; continue 'dispatch;
	}
	// 8243C944: 39780004  addi r11, r24, 4
	ctx.r[11].s64 = ctx.r[24].s64 + 4;
	// 8243C948: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8243C94C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8243C950: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8243C954: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8243C958: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8243C95C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8243C960: 4082FFE8  bne 0x8243c948
	if !ctx.cr[0].eq {
	pc = 0x8243C948; continue 'dispatch;
	}
	// 8243C964: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8243C968: 80DF0108  lwz r6, 0x108(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 8243C96C: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 8243C970: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8243C974: 3B4B5C90  addi r26, r11, 0x5c90
	ctx.r[26].s64 = ctx.r[11].s64 + 23696;
	// 8243C978: 38A000CA  li r5, 0xca
	ctx.r[5].s64 = 202;
	// 8243C97C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 8243C980: 4BECB4B9  bl 0x82307e38
	ctx.lr = 0x8243C984;
	sub_82307E38(ctx, base);
	// 8243C984: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8243C988: 4082001C  bne 0x8243c9a4
	if !ctx.cr[0].eq {
	pc = 0x8243C9A4; continue 'dispatch;
	}
	// 8243C98C: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 8243C990: 419A000C  beq cr6, 0x8243c99c
	if ctx.cr[6].eq {
	pc = 0x8243C99C; continue 'dispatch;
	}
	// 8243C994: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 8243C998: 4BE83EF9  bl 0x822c0890
	ctx.lr = 0x8243C99C;
	sub_822C0890(ctx, base);
	// 8243C99C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8243C9A0: 48000180  b 0x8243cb20
	pc = 0x8243CB20; continue 'dispatch;
	// 8243C9A4: C1BE0000  lfs f13, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8243C9A8: C0190018  lfs f0, 0x18(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8243C9AC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 8243C9B0: 40990008  ble cr6, 0x8243c9b8
	if !ctx.cr[6].gt {
	pc = 0x8243C9B8; continue 'dispatch;
	}
	// 8243C9B4: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 8243C9B8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8243C9BC: C1BE0000  lfs f13, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8243C9C0: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8243C9C4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 8243C9C8: 40980008  bge cr6, 0x8243c9d0
	if !ctx.cr[6].lt {
	pc = 0x8243C9D0; continue 'dispatch;
	}
	// 8243C9CC: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 8243C9D0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8243C9D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8243C9D8: 4BF995D1  bl 0x823d5fa8
	ctx.lr = 0x8243C9DC;
	sub_823D5FA8(ctx, base);
	// 8243C9DC: 83610054  lwz r27, 0x54(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8243C9E0: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8243C9E4: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 8243C9E8: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 8243C9EC: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 8243C9F0: 419A0024  beq cr6, 0x8243ca14
	if ctx.cr[6].eq {
	pc = 0x8243CA14; continue 'dispatch;
	}
	// 8243C9F4: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 8243C9F8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8243C9FC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8243CA00: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8243CA04: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8243CA08: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8243CA0C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8243CA10: 4082FFE8  bne 0x8243c9f8
	if !ctx.cr[0].eq {
	pc = 0x8243C9F8; continue 'dispatch;
	}
	// 8243CA14: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 8243CA18: 80DF0108  lwz r6, 0x108(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 8243CA1C: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 8243CA20: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8243CA24: 38A000D5  li r5, 0xd5
	ctx.r[5].s64 = 213;
	// 8243CA28: 4BECB411  bl 0x82307e38
	ctx.lr = 0x8243CA2C;
	sub_82307E38(ctx, base);
	// 8243CA2C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8243CA30: 40820018  bne 0x8243ca48
	if !ctx.cr[0].eq {
	pc = 0x8243CA48; continue 'dispatch;
	}
	// 8243CA34: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 8243CA38: 419AFF54  beq cr6, 0x8243c98c
	if ctx.cr[6].eq {
	pc = 0x8243C98C; continue 'dispatch;
	}
	// 8243CA3C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8243CA40: 4BE83E51  bl 0x822c0890
	ctx.lr = 0x8243CA44;
	sub_822C0890(ctx, base);
	// 8243CA44: 4BFFFF48  b 0x8243c98c
	pc = 0x8243C98C; continue 'dispatch;
	// 8243CA48: 3B800020  li r28, 0x20
	ctx.r[28].s64 = 32;
	// 8243CA4C: C01E0018  lfs f0, 0x18(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8243CA50: 396000A0  li r11, 0xa0
	ctx.r[11].s64 = 160;
	// 8243CA54: D01F00C0  stfs f0, 0xc0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 8243CA58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8243CA5C: 13FEE0C7  vcmpequd (lvx128) v31, v30, v28
	tmp.u32 = ctx.r[30].u32 + ctx.r[28].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8243CB28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8243CB28 size=484
    let mut pc: u32 = 0x8243CB28;
    'dispatch: loop {
        match pc {
            0x8243CB28 => {
    //   block [0x8243CB28..0x8243CD0C)
	// 8243CB28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8243CB2C: 48D6B635  bl 0x831a8160
	ctx.lr = 0x8243CB30;
	sub_831A8130(ctx, base);
	// 8243CB30: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8243CB34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8243CB38: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8243CB3C: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8243CB40: 4BEC8F31  bl 0x82305a70
	ctx.lr = 0x8243CB44;
	sub_82305A70(ctx, base);
	// 8243CB44: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8243CB48: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8243CB4C: 4BF99365  bl 0x823d5eb0
	ctx.lr = 0x8243CB50;
	sub_823D5EB0(ctx, base);
	// 8243CB50: 83410054  lwz r26, 0x54(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8243CB54: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8243CB58: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 8243CB5C: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	// 8243CB60: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 8243CB64: 419A0024  beq cr6, 0x8243cb88
	if ctx.cr[6].eq {
	pc = 0x8243CB88; continue 'dispatch;
	}
	// 8243CB68: 397A0004  addi r11, r26, 4
	ctx.r[11].s64 = ctx.r[26].s64 + 4;
	// 8243CB6C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8243CB70: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8243CB74: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8243CB78: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8243CB7C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8243CB80: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8243CB84: 4082FFE8  bne 0x8243cb6c
	if !ctx.cr[0].eq {
	pc = 0x8243CB6C; continue 'dispatch;
	}
	// 8243CB88: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8243CB8C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8243CB90: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 8243CB94: 80DF0108  lwz r6, 0x108(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 8243CB98: 3B6B5C90  addi r27, r11, 0x5c90
	ctx.r[27].s64 = ctx.r[11].s64 + 23696;
	// 8243CB9C: 38A000EB  li r5, 0xeb
	ctx.r[5].s64 = 235;
	// 8243CBA0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8243CBA4: 4BECB295  bl 0x82307e38
	ctx.lr = 0x8243CBA8;
	sub_82307E38(ctx, base);
	// 8243CBA8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8243CBAC: 4082001C  bne 0x8243cbc8
	if !ctx.cr[0].eq {
	pc = 0x8243CBC8; continue 'dispatch;
	}
	// 8243CBB0: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 8243CBB4: 419A000C  beq cr6, 0x8243cbc0
	if ctx.cr[6].eq {
	pc = 0x8243CBC0; continue 'dispatch;
	}
	// 8243CBB8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8243CBBC: 4BE83CD5  bl 0x822c0890
	ctx.lr = 0x8243CBC0;
	sub_822C0890(ctx, base);
	// 8243CBC0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8243CBC4: 48000140  b 0x8243cd04
	pc = 0x8243CD04; continue 'dispatch;
	// 8243CBC8: 3BA00020  li r29, 0x20
	ctx.r[29].s64 = 32;
	// 8243CBCC: C01E0030  lfs f0, 0x30(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8243CBD0: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8243CBD4: 396000A0  li r11, 0xa0
	ctx.r[11].s64 = 160;
	// 8243CBD8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8243CBDC: 13FEE8C7  vcmpequd (lvx128) v31, v30, v29
	tmp.u32 = ctx.r[30].u32 + ctx.r[29].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8243CD10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8243CD10 size=372
    let mut pc: u32 = 0x8243CD10;
    'dispatch: loop {
        match pc {
            0x8243CD10 => {
    //   block [0x8243CD10..0x8243CE84)
	// 8243CD10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8243CD14: 48D6B449  bl 0x831a815c
	ctx.lr = 0x8243CD18;
	sub_831A8130(ctx, base);
	// 8243CD18: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 8243CD1C: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8243CD20: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8243CD24: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 8243CD28: 7CD93378  mr r25, r6
	ctx.r[25].u64 = ctx.r[6].u64;
	// 8243CD2C: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 8243CD30: 419A000C  beq cr6, 0x8243cd3c
	if ctx.cr[6].eq {
	pc = 0x8243CD3C; continue 'dispatch;
	}
	// 8243CD34: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8243CD38: 4800000C  b 0x8243cd44
	pc = 0x8243CD44; continue 'dispatch;
	// 8243CD3C: C01C0064  lfs f0, 0x64(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8243CD40: EFE00828  fsubs f31, f0, f1
	ctx.f[31].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 8243CD44: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8243CD48: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8243CD4C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8243CD50: 4BF99259  bl 0x823d5fa8
	ctx.lr = 0x8243CD54;
	sub_823D5FA8(ctx, base);
	// 8243CD54: 8341005C  lwz r26, 0x5c(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8243CD58: 83E10058  lwz r31, 0x58(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8243CD5C: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 8243CD60: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 8243CD64: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 8243CD68: 419A0024  beq cr6, 0x8243cd8c
	if ctx.cr[6].eq {
	pc = 0x8243CD8C; continue 'dispatch;
	}
	// 8243CD6C: 397A0004  addi r11, r26, 4
	ctx.r[11].s64 = ctx.r[26].s64 + 4;
	// 8243CD70: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8243CD74: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8243CD78: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8243CD7C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8243CD80: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8243CD84: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8243CD88: 4082FFE8  bne 0x8243cd70
	if !ctx.cr[0].eq {
	pc = 0x8243CD70; continue 'dispatch;
	}
	// 8243CD8C: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8243CD90: 80DC0108  lwz r6, 0x108(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(264 as u32) ) } as u64;
	// 8243CD94: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 8243CD98: 807C0004  lwz r3, 4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8243CD9C: 3B6B5C90  addi r27, r11, 0x5c90
	ctx.r[27].s64 = ctx.r[11].s64 + 23696;
	// 8243CDA0: 38A0010A  li r5, 0x10a
	ctx.r[5].s64 = 266;
	// 8243CDA4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8243CDA8: 4BECB091  bl 0x82307e38
	ctx.lr = 0x8243CDAC;
	sub_82307E38(ctx, base);
	// 8243CDAC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8243CDB0: 4082001C  bne 0x8243cdcc
	if !ctx.cr[0].eq {
	pc = 0x8243CDCC; continue 'dispatch;
	}
	// 8243CDB4: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 8243CDB8: 419A000C  beq cr6, 0x8243cdc4
	if ctx.cr[6].eq {
	pc = 0x8243CDC4; continue 'dispatch;
	}
	// 8243CDBC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8243CDC0: 4BE83AD1  bl 0x822c0890
	ctx.lr = 0x8243CDC4;
	sub_822C0890(ctx, base);
	// 8243CDC4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8243CDC8: 480000B0  b 0x8243ce78
	pc = 0x8243CE78; continue 'dispatch;
	// 8243CDCC: 3BA00020  li r29, 0x20
	ctx.r[29].s64 = 32;
	// 8243CDD0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8243CDD4: 13FFE8C7  vcmpequd (lvx128) v31, v31, v29
	tmp.u32 = ctx.r[31].u32 + ctx.r[29].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8243CE88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8243CE88 size=184
    let mut pc: u32 = 0x8243CE88;
    'dispatch: loop {
        match pc {
            0x8243CE88 => {
    //   block [0x8243CE88..0x8243CF40)
	// 8243CE88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8243CE8C: 48D6B2E1  bl 0x831a816c
	ctx.lr = 0x8243CE90;
	sub_831A8130(ctx, base);
	// 8243CE90: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8243CE94: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8243CE98: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8243CE9C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8243CEA0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8243CEA4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8243CEA8: C00B08A8  lfs f0, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8243CEAC: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8243CEB0: 4BF990F9  bl 0x823d5fa8
	ctx.lr = 0x8243CEB4;
	sub_823D5FA8(ctx, base);
	// 8243CEB4: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8243CEB8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8243CEBC: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8243CEC0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8243CEC4: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 8243CEC8: 419A0024  beq cr6, 0x8243ceec
	if ctx.cr[6].eq {
	pc = 0x8243CEEC; continue 'dispatch;
	}
	// 8243CECC: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 8243CED0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8243CED4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8243CED8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8243CEDC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8243CEE0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8243CEE4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8243CEE8: 4082FFE8  bne 0x8243ced0
	if !ctx.cr[0].eq {
	pc = 0x8243CED0; continue 'dispatch;
	}
	// 8243CEEC: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8243CEF0: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8243CEF4: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 8243CEF8: 388B5C90  addi r4, r11, 0x5c90
	ctx.r[4].s64 = ctx.r[11].s64 + 23696;
	// 8243CEFC: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 8243CF00: 38A0011D  li r5, 0x11d
	ctx.r[5].s64 = 285;
	// 8243CF04: 4BECAF35  bl 0x82307e38
	ctx.lr = 0x8243CF08;
	sub_82307E38(ctx, base);
	// 8243CF08: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8243CF0C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8243CF10: 41820018  beq 0x8243cf28
	if ctx.cr[0].eq {
	pc = 0x8243CF28; continue 'dispatch;
	}
	// 8243CF14: 419A000C  beq cr6, 0x8243cf20
	if ctx.cr[6].eq {
	pc = 0x8243CF20; continue 'dispatch;
	}
	// 8243CF18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8243CF1C: 4BE83975  bl 0x822c0890
	ctx.lr = 0x8243CF20;
	sub_822C0890(ctx, base);
	// 8243CF20: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 8243CF24: 48000014  b 0x8243cf38
	pc = 0x8243CF38; continue 'dispatch;
	// 8243CF28: 419A000C  beq cr6, 0x8243cf34
	if ctx.cr[6].eq {
	pc = 0x8243CF34; continue 'dispatch;
	}
	// 8243CF2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8243CF30: 4BE83961  bl 0x822c0890
	ctx.lr = 0x8243CF34;
	sub_822C0890(ctx, base);
	// 8243CF34: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8243CF38: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8243CF3C: 48D6B280  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8243CF40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8243CF40 size=1192
    let mut pc: u32 = 0x8243CF40;
    'dispatch: loop {
        match pc {
            0x8243CF40 => {
    //   block [0x8243CF40..0x8243D3E8)
	// 8243CF40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8243CF44: 48D6B21D  bl 0x831a8160
	ctx.lr = 0x8243CF48;
	sub_831A8130(ctx, base);
	// 8243CF48: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8243D3E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8243D3E8 size=808
    let mut pc: u32 = 0x8243D3E8;
    'dispatch: loop {
        match pc {
            0x8243D3E8 => {
    //   block [0x8243D3E8..0x8243D710)
	// 8243D3E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8243D3EC: 48D6AD75  bl 0x831a8160
	ctx.lr = 0x8243D3F0;
	sub_831A8130(ctx, base);
	// 8243D3F0: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8243D3F4: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 8243D3F8: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 8243D3FC: 394A6910  addi r10, r10, 0x6910
	ctx.r[10].s64 = ctx.r[10].s64 + 26896;
	// 8243D400: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8243D404: 548B063F  clrlwi. r11, r4, 0x18
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8243D408: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8243D40C: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8243D710(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8243D710 size=1060
    let mut pc: u32 = 0x8243D710;
    'dispatch: loop {
        match pc {
            0x8243D710 => {
    //   block [0x8243D710..0x8243DB34)
	// 8243D710: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8243D714: 48D6AA1D  bl 0x831a8130
	ctx.lr = 0x8243D718;
	sub_831A8130(ctx, base);
	// 8243D718: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 8243D71C: 48D6B35D  bl 0x831a8a78
	ctx.lr = 0x8243D720;
	sub_831A8A40(ctx, base);
	// 8243D720: 3980FF30  li r12, -0xd0
	ctx.r[12].s64 = -208;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8243DB38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8243DB38 size=540
    let mut pc: u32 = 0x8243DB38;
    'dispatch: loop {
        match pc {
            0x8243DB38 => {
    //   block [0x8243DB38..0x8243DD54)
	// 8243DB38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8243DB3C: 48D6A621  bl 0x831a815c
	ctx.lr = 0x8243DB40;
	sub_831A8130(ctx, base);
	// 8243DB40: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 8243DB44: 3980FFA0  li r12, -0x60
	ctx.r[12].s64 = -96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8243DD58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8243DD58 size=1440
    let mut pc: u32 = 0x8243DD58;
    'dispatch: loop {
        match pc {
            0x8243DD58 => {
    //   block [0x8243DD58..0x8243E2F8)
	// 8243DD58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8243DD5C: 48D6A3ED  bl 0x831a8148
	ctx.lr = 0x8243DD60;
	sub_831A8130(ctx, base);
	// 8243DD60: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8243DD64: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8243DD68: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8243DD6C: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 8243DD70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8243DD74: 3ACB5C90  addi r22, r11, 0x5c90
	ctx.r[22].s64 = ctx.r[11].s64 + 23696;
	// 8243DD78: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8243DD7C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8243DD80: 38A0004A  li r5, 0x4a
	ctx.r[5].s64 = 74;
	// 8243DD84: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 8243DD88: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 8243DD8C: 4BE8264D  bl 0x822c03d8
	ctx.lr = 0x8243DD90;
	sub_822C03D8(ctx, base);
	// 8243DD90: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8243DD94: 41820014  beq 0x8243dda8
	if ctx.cr[0].eq {
	pc = 0x8243DDA8; continue 'dispatch;
	}
	// 8243DD98: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8243DD9C: 48053355  bl 0x824910f0
	ctx.lr = 0x8243DDA0;
	sub_824910F0(ctx, base);
	// 8243DDA0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8243DDA4: 48000008  b 0x8243ddac
	pc = 0x8243DDAC; continue 'dispatch;
	// 8243DDA8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8243DDAC: 387F0120  addi r3, r31, 0x120
	ctx.r[3].s64 = ctx.r[31].s64 + 288;
	// 8243DDB0: 4BECC931  bl 0x8230a6e0
	ctx.lr = 0x8243DDB4;
	sub_8230A6E0(ctx, base);
	// 8243DDB4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8243DDB8: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 8243DDBC: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 8243DDC0: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 8243DDC4: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 8243DDC8: C1ABACFC  lfs f13, -0x5304(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-21252 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8243DDCC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8243DDD0: C00A964C  lfs f0, -0x69b4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8243DDD4: 38A00053  li r5, 0x53
	ctx.r[5].s64 = 83;
	// 8243DDD8: C189A9F0  lfs f12, -0x5610(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-22032 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8243DDDC: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 8243DDE0: C16808A8  lfs f11, 0x8a8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2216 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8243DDE4: D1BF000C  stfs f13, 0xc(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 8243DDE8: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 8243DDEC: D19F0014  stfs f12, 0x14(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8243DDF0: D17F0018  stfs f11, 0x18(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 8243DDF4: D01F001C  stfs f0, 0x1c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 8243DDF8: 4BE825E1  bl 0x822c03d8
	ctx.lr = 0x8243DDFC;
	sub_822C03D8(ctx, base);
	// 8243DDFC: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 8243DE00: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 8243DE04: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 8243DE08: 3B000020  li r24, 0x20
	ctx.r[24].s64 = 32;
	// 8243DE0C: 3EE08335  lis r23, -0x7ccb
	ctx.r[23].s64 = -2093678592;
	// 8243DE10: 3B8B6910  addi r28, r11, 0x6910
	ctx.r[28].s64 = ctx.r[11].s64 + 26896;
	// 8243DE14: 3B6ABA80  addi r27, r10, -0x4580
	ctx.r[27].s64 = ctx.r[10].s64 + -17792;
	// 8243DE18: 41820098  beq 0x8243deb0
	if ctx.cr[0].eq {
	pc = 0x8243DEB0; continue 'dispatch;
	}
	// 8243DE1C: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 8243DE20: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 8243DE24: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 8243DE28: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 8243DE2C: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8243DE30: 48A62901  bl 0x82ea0730
	ctx.lr = 0x8243DE34;
	sub_82EA0730(ctx, base);
	// 8243DE34: B3030004  sth r24, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[24].u16 ) };
	// 8243DE38: C03F000C  lfs f1, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8243DE3C: 48ADC3B5  bl 0x82f1a1f0
	ctx.lr = 0x8243DE40;
	sub_82F1A1F0(ctx, base);
	// 8243DE40: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 8243DE44: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 8243DE48: 80976858  lwz r4, 0x6858(r23)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(26712 as u32) ) } as u64;
	// 8243DE4C: 3BC00003  li r30, 3
	ctx.r[30].s64 = 3;
	// 8243DE50: 4BEA70E1  bl 0x822e4f30
	ctx.lr = 0x8243DE54;
	sub_822E4F30(ctx, base);
	// 8243DE54: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 8243DE58: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 8243DE5C: 4BEA7065  bl 0x822e4ec0
	ctx.lr = 0x8243DE60;
	sub_822E4EC0(ctx, base);
	// 8243DE60: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8243DE64: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8243DE68: E89A0000  ld r4, 0(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) };
	// 8243DE6C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8243DE70: E8630000  ld r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 8243DE74: 4804E415  bl 0x8248c288
	ctx.lr = 0x8243DE78;
	sub_8248C288(ctx, base);
	// 8243DE78: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 8243DE7C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8243DE80: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8243DE84: 3B210050  addi r25, r1, 0x50
	ctx.r[25].s64 = ctx.r[1].s64 + 80;
	// 8243DE88: 4BF63441  bl 0x823a12c8
	ctx.lr = 0x8243DE8C;
	sub_823A12C8(ctx, base);
	// 8243DE8C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8243DE90: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8243DE94: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 8243DE98: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 8243DE9C: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 8243DEA0: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 8243DEA4: 480542FD  bl 0x824921a0
	ctx.lr = 0x8243DEA8;
	sub_824921A0(ctx, base);
	// 8243DEA8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8243DEAC: 48000008  b 0x8243deb4
	pc = 0x8243DEB4; continue 'dispatch;
	// 8243DEB0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8243DEB4: 387F00E0  addi r3, r31, 0xe0
	ctx.r[3].s64 = ctx.r[31].s64 + 224;
	// 8243DEB8: 4BEA6F31  bl 0x822e4de8
	ctx.lr = 0x8243DEBC;
	sub_822E4DE8(ctx, base);
	// 8243DEBC: 57CB07BD  rlwinm. r11, r30, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8243DEC0: 41820010  beq 0x8243ded0
	if ctx.cr[0].eq {
	pc = 0x8243DED0; continue 'dispatch;
	}
	// 8243DEC4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8243DEC8: 57DE07FA  rlwinm r30, r30, 0, 0x1f, 0x1d
	ctx.r[30].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 8243DECC: 489B3DC5  bl 0x82df1c90
	ctx.lr = 0x8243DED0;
	sub_82DF1C90(ctx, base);
	// 8243DED0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8243DED4: 41820018  beq 0x8243deec
	if ctx.cr[0].eq {
	pc = 0x8243DEEC; continue 'dispatch;
	}
	// 8243DED8: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8243DEDC: 57DE003C  rlwinm r30, r30, 0, 0, 0x1e
	ctx.r[30].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 8243DEE0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8243DEE4: 419A0008  beq cr6, 0x8243deec
	if ctx.cr[6].eq {
	pc = 0x8243DEEC; continue 'dispatch;
	}
	// 8243DEE8: 4BEAA381  bl 0x822e8268
	ctx.lr = 0x8243DEEC;
	sub_822E8268(ctx, base);
	// 8243DEEC: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 8243DEF0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8243DEF4: 38A00054  li r5, 0x54
	ctx.r[5].s64 = 84;
	// 8243DEF8: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 8243DEFC: 4BE824DD  bl 0x822c03d8
	ctx.lr = 0x8243DF00;
	sub_822C03D8(ctx, base);
	// 8243DF00: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 8243DF04: 4182009C  beq 0x8243dfa0
	if ctx.cr[0].eq {
	pc = 0x8243DFA0; continue 'dispatch;
	}
	// 8243DF08: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 8243DF0C: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 8243DF10: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 8243DF14: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 8243DF18: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8243DF1C: 48A62815  bl 0x82ea0730
	ctx.lr = 0x8243DF20;
	sub_82EA0730(ctx, base);
	// 8243DF20: B3030004  sth r24, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[24].u16 ) };
	// 8243DF24: C03F0010  lfs f1, 0x10(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8243DF28: 48ADC2C9  bl 0x82f1a1f0
	ctx.lr = 0x8243DF2C;
	sub_82F1A1F0(ctx, base);
	// 8243DF2C: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 8243DF30: 63CB0004  ori r11, r30, 4
	ctx.r[11].u64 = ctx.r[30].u64 | 4;
	// 8243DF34: 80976858  lwz r4, 0x6858(r23)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(26712 as u32) ) } as u64;
	// 8243DF38: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 8243DF3C: 617E0008  ori r30, r11, 8
	ctx.r[30].u64 = ctx.r[11].u64 | 8;
	// 8243DF40: 4BEA6FF1  bl 0x822e4f30
	ctx.lr = 0x8243DF44;
	sub_822E4F30(ctx, base);
	// 8243DF44: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 8243DF48: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 8243DF4C: 4BEA6F75  bl 0x822e4ec0
	ctx.lr = 0x8243DF50;
	sub_822E4EC0(ctx, base);
	// 8243DF50: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8243DF54: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8243DF58: E89A0000  ld r4, 0(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) };
	// 8243DF5C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8243DF60: E8630000  ld r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 8243DF64: 4804E325  bl 0x8248c288
	ctx.lr = 0x8243DF68;
	sub_8248C288(ctx, base);
	// 8243DF68: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 8243DF6C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8243DF70: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8243DF74: 3B210054  addi r25, r1, 0x54
	ctx.r[25].s64 = ctx.r[1].s64 + 84;
	// 8243DF78: 4BF63351  bl 0x823a12c8
	ctx.lr = 0x8243DF7C;
	sub_823A12C8(ctx, base);
	// 8243DF7C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8243DF80: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8243DF84: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 8243DF88: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 8243DF8C: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 8243DF90: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 8243DF94: 4805420D  bl 0x824921a0
	ctx.lr = 0x8243DF98;
	sub_824921A0(ctx, base);
	// 8243DF98: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8243DF9C: 48000008  b 0x8243dfa4
	pc = 0x8243DFA4; continue 'dispatch;
	// 8243DFA0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8243DFA4: 387F00E8  addi r3, r31, 0xe8
	ctx.r[3].s64 = ctx.r[31].s64 + 232;
	// 8243DFA8: 4BEA6E41  bl 0x822e4de8
	ctx.lr = 0x8243DFAC;
	sub_822E4DE8(ctx, base);
	// 8243DFAC: 57CB0739  rlwinm. r11, r30, 0, 0x1c, 0x1c
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8243DFB0: 41820010  beq 0x8243dfc0
	if ctx.cr[0].eq {
	pc = 0x8243DFC0; continue 'dispatch;
	}
	// 8243DFB4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8243DFB8: 57DE0776  rlwinm r30, r30, 0, 0x1d, 0x1b
	ctx.r[30].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 8243DFBC: 489B3CD5  bl 0x82df1c90
	ctx.lr = 0x8243DFC0;
	sub_82DF1C90(ctx, base);
	// 8243DFC0: 57CB077B  rlwinm. r11, r30, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8243DFC4: 41820018  beq 0x8243dfdc
	if ctx.cr[0].eq {
	pc = 0x8243DFDC; continue 'dispatch;
	}
	// 8243DFC8: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8243DFCC: 57DE07B8  rlwinm r30, r30, 0, 0x1e, 0x1c
	ctx.r[30].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 8243DFD0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8243DFD4: 419A0008  beq cr6, 0x8243dfdc
	if ctx.cr[6].eq {
	pc = 0x8243DFDC; continue 'dispatch;
	}
	// 8243DFD8: 4BEAA291  bl 0x822e8268
	ctx.lr = 0x8243DFDC;
	sub_822E8268(ctx, base);
	// 8243DFDC: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 8243DFE0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8243DFE4: 38A00055  li r5, 0x55
	ctx.r[5].s64 = 85;
	// 8243DFE8: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 8243DFEC: 4BE823ED  bl 0x822c03d8
	ctx.lr = 0x8243DFF0;
	sub_822C03D8(ctx, base);
	// 8243DFF0: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 8243DFF4: 3F408335  lis r26, -0x7ccb
	ctx.r[26].s64 = -2093678592;
	// 8243DFF8: 3F208335  lis r25, -0x7ccb
	ctx.r[25].s64 = -2093678592;
	// 8243DFFC: 418200A0  beq 0x8243e09c
	if ctx.cr[0].eq {
	pc = 0x8243E09C; continue 'dispatch;
	}
	// 8243E000: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 8243E004: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 8243E008: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 8243E00C: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 8243E010: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8243E014: 48A6271D  bl 0x82ea0730
	ctx.lr = 0x8243E018;
	sub_82EA0730(ctx, base);
	// 8243E018: B3030004  sth r24, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[24].u16 ) };
	// 8243E01C: C03F0014  lfs f1, 0x14(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8243E020: 48ADC1D1  bl 0x82f1a1f0
	ctx.lr = 0x8243E024;
	sub_82F1A1F0(ctx, base);
	// 8243E024: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 8243E028: 63CB0010  ori r11, r30, 0x10
	ctx.r[11].u64 = ctx.r[30].u64 | 16;
	// 8243E02C: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 8243E030: 80B96754  lwz r5, 0x6754(r25)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(26452 as u32) ) } as u64;
	// 8243E034: 809A6750  lwz r4, 0x6750(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(26448 as u32) ) } as u64;
	// 8243E038: 617E0020  ori r30, r11, 0x20
	ctx.r[30].u64 = ctx.r[11].u64 | 32;
	// 8243E03C: 4BEB9765  bl 0x822f77a0
	ctx.lr = 0x8243E040;
	sub_822F77A0(ctx, base);
	// 8243E040: 7C751B78  mr r21, r3
	ctx.r[21].u64 = ctx.r[3].u64;
	// 8243E044: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 8243E048: 4BEA6E79  bl 0x822e4ec0
	ctx.lr = 0x8243E04C;
	sub_822E4EC0(ctx, base);
	// 8243E04C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8243E050: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8243E054: E8950000  ld r4, 0(r21)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[21].u32.wrapping_add(0 as u32) ) };
	// 8243E058: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8243E05C: E8630000  ld r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 8243E060: 4804E229  bl 0x8248c288
	ctx.lr = 0x8243E064;
	sub_8248C288(ctx, base);
	// 8243E064: 7C751B78  mr r21, r3
	ctx.r[21].u64 = ctx.r[3].u64;
	// 8243E068: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 8243E06C: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8243E070: 3A810058  addi r20, r1, 0x58
	ctx.r[20].s64 = ctx.r[1].s64 + 88;
	// 8243E074: 4BF63255  bl 0x823a12c8
	ctx.lr = 0x8243E078;
	sub_823A12C8(ctx, base);
	// 8243E078: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8243E07C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8243E080: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 8243E084: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 8243E088: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 8243E08C: 7EA8AB78  mr r8, r21
	ctx.r[8].u64 = ctx.r[21].u64;
	// 8243E090: 48054111  bl 0x824921a0
	ctx.lr = 0x8243E094;
	sub_824921A0(ctx, base);
	// 8243E094: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8243E098: 48000008  b 0x8243e0a0
	pc = 0x8243E0A0; continue 'dispatch;
	// 8243E09C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8243E0A0: 387F00F0  addi r3, r31, 0xf0
	ctx.r[3].s64 = ctx.r[31].s64 + 240;
	// 8243E0A4: 4BEA6D45  bl 0x822e4de8
	ctx.lr = 0x8243E0A8;
	sub_822E4DE8(ctx, base);
	// 8243E0A8: 57CB06B5  rlwinm. r11, r30, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8243E0AC: 41820010  beq 0x8243e0bc
	if ctx.cr[0].eq {
	pc = 0x8243E0BC; continue 'dispatch;
	}
	// 8243E0B0: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 8243E0B4: 57DE06F2  rlwinm r30, r30, 0, 0x1b, 0x19
	ctx.r[30].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 8243E0B8: 489B3BD9  bl 0x82df1c90
	ctx.lr = 0x8243E0BC;
	sub_82DF1C90(ctx, base);
	// 8243E0BC: 57CB06F7  rlwinm. r11, r30, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8243E0C0: 41820018  beq 0x8243e0d8
	if ctx.cr[0].eq {
	pc = 0x8243E0D8; continue 'dispatch;
	}
	// 8243E0C4: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8243E0C8: 57DE0734  rlwinm r30, r30, 0, 0x1c, 0x1a
	ctx.r[30].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 8243E0CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8243E0D0: 419A0008  beq cr6, 0x8243e0d8
	if ctx.cr[6].eq {
	pc = 0x8243E0D8; continue 'dispatch;
	}
	// 8243E0D4: 4BEAA195  bl 0x822e8268
	ctx.lr = 0x8243E0D8;
	sub_822E8268(ctx, base);
	// 8243E0D8: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 8243E0DC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8243E0E0: 38A00056  li r5, 0x56
	ctx.r[5].s64 = 86;
	// 8243E0E4: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 8243E0E8: 4BE822F1  bl 0x822c03d8
	ctx.lr = 0x8243E0EC;
	sub_822C03D8(ctx, base);
	// 8243E0EC: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 8243E0F0: 4182009C  beq 0x8243e18c
	if ctx.cr[0].eq {
	pc = 0x8243E18C; continue 'dispatch;
	}
	// 8243E0F4: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 8243E0F8: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 8243E0FC: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 8243E100: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 8243E104: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8243E108: 48A62629  bl 0x82ea0730
	ctx.lr = 0x8243E10C;
	sub_82EA0730(ctx, base);
	// 8243E10C: B3030004  sth r24, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[24].u16 ) };
	// 8243E110: C03F0018  lfs f1, 0x18(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8243E114: 48ADC0DD  bl 0x82f1a1f0
	ctx.lr = 0x8243E118;
	sub_82F1A1F0(ctx, base);
	// 8243E118: 9061005C  stw r3, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[3].u32 ) };
	// 8243E11C: 63CB0040  ori r11, r30, 0x40
	ctx.r[11].u64 = ctx.r[30].u64 | 64;
	// 8243E120: 80976858  lwz r4, 0x6858(r23)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(26712 as u32) ) } as u64;
	// 8243E124: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 8243E128: 617E0080  ori r30, r11, 0x80
	ctx.r[30].u64 = ctx.r[11].u64 | 128;
	// 8243E12C: 4BEA6E05  bl 0x822e4f30
	ctx.lr = 0x8243E130;
	sub_822E4F30(ctx, base);
	// 8243E130: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 8243E134: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 8243E138: 4BEA6D89  bl 0x822e4ec0
	ctx.lr = 0x8243E13C;
	sub_822E4EC0(ctx, base);
	// 8243E13C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8243E140: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8243E144: E8970000  ld r4, 0(r23)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) };
	// 8243E148: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8243E14C: E8630000  ld r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 8243E150: 4804E139  bl 0x8248c288
	ctx.lr = 0x8243E154;
	sub_8248C288(ctx, base);
	// 8243E154: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 8243E158: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8243E15C: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8243E160: 3AA1005C  addi r21, r1, 0x5c
	ctx.r[21].s64 = ctx.r[1].s64 + 92;
	// 8243E164: 4BF63165  bl 0x823a12c8
	ctx.lr = 0x8243E168;
	sub_823A12C8(ctx, base);
	// 8243E168: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8243E16C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8243E170: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	// 8243E174: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 8243E178: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 8243E17C: 7EE8BB78  mr r8, r23
	ctx.r[8].u64 = ctx.r[23].u64;
	// 8243E180: 48054021  bl 0x824921a0
	ctx.lr = 0x8243E184;
	sub_824921A0(ctx, base);
	// 8243E184: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8243E188: 48000008  b 0x8243e190
	pc = 0x8243E190; continue 'dispatch;
	// 8243E18C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8243E190: 387F0100  addi r3, r31, 0x100
	ctx.r[3].s64 = ctx.r[31].s64 + 256;
	// 8243E194: 4BEA6C55  bl 0x822e4de8
	ctx.lr = 0x8243E198;
	sub_822E4DE8(ctx, base);
	// 8243E198: 57CB0631  rlwinm. r11, r30, 0, 0x18, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8243E19C: 41820010  beq 0x8243e1ac
	if ctx.cr[0].eq {
	pc = 0x8243E1AC; continue 'dispatch;
	}
	// 8243E1A0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8243E1A4: 57DE066E  rlwinm r30, r30, 0, 0x19, 0x17
	ctx.r[30].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 8243E1A8: 489B3AE9  bl 0x82df1c90
	ctx.lr = 0x8243E1AC;
	sub_82DF1C90(ctx, base);
	// 8243E1AC: 57CB0673  rlwinm. r11, r30, 0, 0x19, 0x19
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8243E1B0: 41820018  beq 0x8243e1c8
	if ctx.cr[0].eq {
	pc = 0x8243E1C8; continue 'dispatch;
	}
	// 8243E1B4: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8243E1B8: 57DE06B0  rlwinm r30, r30, 0, 0x1a, 0x18
	ctx.r[30].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 8243E1BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8243E1C0: 419A0008  beq cr6, 0x8243e1c8
	if ctx.cr[6].eq {
	pc = 0x8243E1C8; continue 'dispatch;
	}
	// 8243E1C4: 4BEAA0A5  bl 0x822e8268
	ctx.lr = 0x8243E1C8;
	sub_822E8268(ctx, base);
	// 8243E1C8: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 8243E1CC: 80B96754  lwz r5, 0x6754(r25)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(26452 as u32) ) } as u64;
	// 8243E1D0: 809A6750  lwz r4, 0x6750(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(26448 as u32) ) } as u64;
	// 8243E1D4: 4BEB95CD  bl 0x822f77a0
	ctx.lr = 0x8243E1D8;
	sub_822F77A0(ctx, base);
	// 8243E1D8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8243E1DC: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 8243E1E0: 4BEA6CE1  bl 0x822e4ec0
	ctx.lr = 0x8243E1E4;
	sub_822E4EC0(ctx, base);
	// 8243E1E4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8243E1E8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8243E1EC: E89D0000  ld r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	// 8243E1F0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8243E1F4: E8630000  ld r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 8243E1F8: 4804E091  bl 0x8248c288
	ctx.lr = 0x8243E1FC;
	sub_8248C288(ctx, base);
	// 8243E1FC: 907F0128  stw r3, 0x128(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(296 as u32), ctx.r[3].u32 ) };
	// 8243E200: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 8243E204: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8243E208: 38A00058  li r5, 0x58
	ctx.r[5].s64 = 88;
	// 8243E20C: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 8243E210: 4BE821C9  bl 0x822c03d8
	ctx.lr = 0x8243E214;
	sub_822C03D8(ctx, base);
	// 8243E214: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 8243E218: 418200A0  beq 0x8243e2b8
	if ctx.cr[0].eq {
	pc = 0x8243E2B8; continue 'dispatch;
	}
	// 8243E21C: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 8243E220: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 8243E224: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 8243E228: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 8243E22C: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8243E230: 48A62501  bl 0x82ea0730
	ctx.lr = 0x8243E234;
	sub_82EA0730(ctx, base);
	// 8243E234: B3030004  sth r24, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[24].u16 ) };
	// 8243E238: C03F001C  lfs f1, 0x1c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8243E23C: 48ADBFB5  bl 0x82f1a1f0
	ctx.lr = 0x8243E240;
	sub_82F1A1F0(ctx, base);
	// 8243E240: 90610060  stw r3, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 8243E244: 63CB0100  ori r11, r30, 0x100
	ctx.r[11].u64 = ctx.r[30].u64 | 256;
	// 8243E248: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 8243E24C: 80B96754  lwz r5, 0x6754(r25)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(26452 as u32) ) } as u64;
	// 8243E250: 809A6750  lwz r4, 0x6750(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(26448 as u32) ) } as u64;
	// 8243E254: 617E0200  ori r30, r11, 0x200
	ctx.r[30].u64 = ctx.r[11].u64 | 512;
	// 8243E258: 4BEB9549  bl 0x822f77a0
	ctx.lr = 0x8243E25C;
	sub_822F77A0(ctx, base);
	// 8243E25C: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 8243E260: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 8243E264: 4BEA6C5D  bl 0x822e4ec0
	ctx.lr = 0x8243E268;
	sub_822E4EC0(ctx, base);
	// 8243E268: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8243E26C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8243E270: E89A0000  ld r4, 0(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) };
	// 8243E274: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8243E278: E8630000  ld r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 8243E27C: 4804E00D  bl 0x8248c288
	ctx.lr = 0x8243E280;
	sub_8248C288(ctx, base);
	// 8243E280: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 8243E284: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 8243E288: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8243E28C: 3B210060  addi r25, r1, 0x60
	ctx.r[25].s64 = ctx.r[1].s64 + 96;
	// 8243E290: 4BF63039  bl 0x823a12c8
	ctx.lr = 0x8243E294;
	sub_823A12C8(ctx, base);
	// 8243E294: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8243E298: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8243E29C: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 8243E2A0: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 8243E2A4: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 8243E2A8: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 8243E2AC: 48053EF5  bl 0x824921a0
	ctx.lr = 0x8243E2B0;
	sub_824921A0(ctx, base);
	// 8243E2B0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8243E2B4: 48000008  b 0x8243e2bc
	pc = 0x8243E2BC; continue 'dispatch;
	// 8243E2B8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8243E2BC: 387F00F8  addi r3, r31, 0xf8
	ctx.r[3].s64 = ctx.r[31].s64 + 248;
	// 8243E2C0: 4BEA6B29  bl 0x822e4de8
	ctx.lr = 0x8243E2C4;
	sub_822E4DE8(ctx, base);
	// 8243E2C4: 57CB05AD  rlwinm. r11, r30, 0, 0x16, 0x16
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8243E2C8: 41820010  beq 0x8243e2d8
	if ctx.cr[0].eq {
	pc = 0x8243E2D8; continue 'dispatch;
	}
	// 8243E2CC: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 8243E2D0: 57DE05EA  rlwinm r30, r30, 0, 0x17, 0x15
	ctx.r[30].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 8243E2D4: 489B39BD  bl 0x82df1c90
	ctx.lr = 0x8243E2D8;
	sub_82DF1C90(ctx, base);
	// 8243E2D8: 57CB05EF  rlwinm. r11, r30, 0, 0x17, 0x17
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8243E2DC: 41820014  beq 0x8243e2f0
	if ctx.cr[0].eq {
	pc = 0x8243E2F0; continue 'dispatch;
	}
	// 8243E2E0: 80610060  lwz r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 8243E2E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8243E2E8: 419A0008  beq cr6, 0x8243e2f0
	if ctx.cr[6].eq {
	pc = 0x8243E2F0; continue 'dispatch;
	}
	// 8243E2EC: 4BEA9F7D  bl 0x822e8268
	ctx.lr = 0x8243E2F0;
	sub_822E8268(ctx, base);
	// 8243E2F0: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 8243E2F4: 48D69EA4  b 0x831a8198
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8243E2F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8243E2F8 size=2120
    let mut pc: u32 = 0x8243E2F8;
    'dispatch: loop {
        match pc {
            0x8243E2F8 => {
    //   block [0x8243E2F8..0x8243EB40)
	// 8243E2F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8243E2FC: 48D69E35  bl 0x831a8130
	ctx.lr = 0x8243E300;
	sub_831A8130(ctx, base);
	// 8243E300: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 8243E304: 48D6A761  bl 0x831a8a64
	ctx.lr = 0x8243E308;
	sub_831A8A40(ctx, base);
	// 8243E308: 3980FF10  li r12, -0xf0
	ctx.r[12].s64 = -240;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8243EB40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8243EB40 size=644
    let mut pc: u32 = 0x8243EB40;
    'dispatch: loop {
        match pc {
            0x8243EB40 => {
    //   block [0x8243EB40..0x8243EDC4)
	// 8243EB40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8243EB44: 48D69629  bl 0x831a816c
	ctx.lr = 0x8243EB48;
	sub_831A8130(ctx, base);
	// 8243EB48: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 8243EB4C: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8243EB50: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8243EB54: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8243EB58: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8243EB5C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8243EB60: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8243EB64: 4BF67AED  bl 0x823a6650
	ctx.lr = 0x8243EB68;
	sub_823A6650(ctx, base);
	// 8243EB68: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8243EB6C: C1A30004  lfs f13, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8243EB70: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8243EB74: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 8243EB78: 41990240  bgt cr6, 0x8243edb8
	if ctx.cr[6].gt {
	pc = 0x8243EDB8; continue 'dispatch;
	}
	// 8243EB7C: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 8243EB80: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8243EB84: 808B7DE8  lwz r4, 0x7de8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32232 as u32) ) } as u64;
	// 8243EB88: 489B4E81  bl 0x82df3a08
	ctx.lr = 0x8243EB8C;
	sub_82DF3A08(ctx, base);
	// 8243EB8C: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8243EB90: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 8243EB94: 3BA10068  addi r29, r1, 0x68
	ctx.r[29].s64 = ctx.r[1].s64 + 104;
	// 8243EB98: 4BEC6A01  bl 0x82305598
	ctx.lr = 0x8243EB9C;
	sub_82305598(ctx, base);
	// 8243EB9C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8243EBA0: 489B4769  bl 0x82df3308
	ctx.lr = 0x8243EBA4;
	sub_82DF3308(ctx, base);
	// 8243EBA4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8243EBA8: 40820138  bne 0x8243ece0
	if !ctx.cr[0].eq {
	pc = 0x8243ECE0; continue 'dispatch;
	}
	// 8243EBAC: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 8243EBB0: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 8243EBB4: 808B7CD0  lwz r4, 0x7cd0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31952 as u32) ) } as u64;
	// 8243EBB8: 489B4E51  bl 0x82df3a08
	ctx.lr = 0x8243EBBC;
	sub_82DF3A08(ctx, base);
	// 8243EBBC: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8243EBC0: 3BE00003  li r31, 3
	ctx.r[31].s64 = 3;
	// 8243EBC4: 3BA10064  addi r29, r1, 0x64
	ctx.r[29].s64 = ctx.r[1].s64 + 100;
	// 8243EBC8: 4BEC69D1  bl 0x82305598
	ctx.lr = 0x8243EBCC;
	sub_82305598(ctx, base);
	// 8243EBCC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8243EBD0: 489B4739  bl 0x82df3308
	ctx.lr = 0x8243EBD4;
	sub_82DF3308(ctx, base);
	// 8243EBD4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8243EBD8: 40820108  bne 0x8243ece0
	if !ctx.cr[0].eq {
	pc = 0x8243ECE0; continue 'dispatch;
	}
	// 8243EBDC: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 8243EBE0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8243EBE4: 808B7D9C  lwz r4, 0x7d9c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32156 as u32) ) } as u64;
	// 8243EBE8: 489B4E21  bl 0x82df3a08
	ctx.lr = 0x8243EBEC;
	sub_82DF3A08(ctx, base);
	// 8243EBEC: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8243EBF0: 3BE00007  li r31, 7
	ctx.r[31].s64 = 7;
	// 8243EBF4: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 8243EBF8: 4BEC69A1  bl 0x82305598
	ctx.lr = 0x8243EBFC;
	sub_82305598(ctx, base);
	// 8243EBFC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8243EC00: 489B4709  bl 0x82df3308
	ctx.lr = 0x8243EC04;
	sub_82DF3308(ctx, base);
	// 8243EC04: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8243EC08: 408200D8  bne 0x8243ece0
	if !ctx.cr[0].eq {
	pc = 0x8243ECE0; continue 'dispatch;
	}
	// 8243EC0C: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 8243EC10: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 8243EC14: 808B7CC0  lwz r4, 0x7cc0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31936 as u32) ) } as u64;
	// 8243EC18: 489B4DF1  bl 0x82df3a08
	ctx.lr = 0x8243EC1C;
	sub_82DF3A08(ctx, base);
	// 8243EC1C: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8243EC20: 3BE0000F  li r31, 0xf
	ctx.r[31].s64 = 15;
	// 8243EC24: 3BA1005C  addi r29, r1, 0x5c
	ctx.r[29].s64 = ctx.r[1].s64 + 92;
	// 8243EC28: 4BEC6971  bl 0x82305598
	ctx.lr = 0x8243EC2C;
	sub_82305598(ctx, base);
	// 8243EC2C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8243EC30: 489B46D9  bl 0x82df3308
	ctx.lr = 0x8243EC34;
	sub_82DF3308(ctx, base);
	// 8243EC34: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8243EC38: 408200A8  bne 0x8243ece0
	if !ctx.cr[0].eq {
	pc = 0x8243ECE0; continue 'dispatch;
	}
	// 8243EC3C: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 8243EC40: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8243EC44: 808B7CC4  lwz r4, 0x7cc4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31940 as u32) ) } as u64;
	// 8243EC48: 489B4DC1  bl 0x82df3a08
	ctx.lr = 0x8243EC4C;
	sub_82DF3A08(ctx, base);
	// 8243EC4C: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8243EC50: 3BE0001F  li r31, 0x1f
	ctx.r[31].s64 = 31;
	// 8243EC54: 3BA10058  addi r29, r1, 0x58
	ctx.r[29].s64 = ctx.r[1].s64 + 88;
	// 8243EC58: 4BEC6941  bl 0x82305598
	ctx.lr = 0x8243EC5C;
	sub_82305598(ctx, base);
	// 8243EC5C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8243EC60: 489B46A9  bl 0x82df3308
	ctx.lr = 0x8243EC64;
	sub_82DF3308(ctx, base);
	// 8243EC64: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8243EC68: 40820078  bne 0x8243ece0
	if !ctx.cr[0].eq {
	pc = 0x8243ECE0; continue 'dispatch;
	}
	// 8243EC6C: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 8243EC70: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8243EC74: 808B7CC8  lwz r4, 0x7cc8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31944 as u32) ) } as u64;
	// 8243EC78: 489B4D91  bl 0x82df3a08
	ctx.lr = 0x8243EC7C;
	sub_82DF3A08(ctx, base);
	// 8243EC7C: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8243EC80: 3BE0003F  li r31, 0x3f
	ctx.r[31].s64 = 63;
	// 8243EC84: 3BA10054  addi r29, r1, 0x54
	ctx.r[29].s64 = ctx.r[1].s64 + 84;
	// 8243EC88: 4BEC6911  bl 0x82305598
	ctx.lr = 0x8243EC8C;
	sub_82305598(ctx, base);
	// 8243EC8C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8243EC90: 489B4679  bl 0x82df3308
	ctx.lr = 0x8243EC94;
	sub_82DF3308(ctx, base);
	// 8243EC94: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8243EC98: 40820048  bne 0x8243ece0
	if !ctx.cr[0].eq {
	pc = 0x8243ECE0; continue 'dispatch;
	}
	// 8243EC9C: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 8243ECA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8243ECA4: 808B7D78  lwz r4, 0x7d78(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32120 as u32) ) } as u64;
	// 8243ECA8: 489B4D61  bl 0x82df3a08
	ctx.lr = 0x8243ECAC;
	sub_82DF3A08(ctx, base);
	// 8243ECAC: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8243ECB0: 3BE0007F  li r31, 0x7f
	ctx.r[31].s64 = 127;
	// 8243ECB4: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 8243ECB8: 4BEC68E1  bl 0x82305598
	ctx.lr = 0x8243ECBC;
	sub_82305598(ctx, base);
	// 8243ECBC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8243ECC0: 489B4649  bl 0x82df3308
	ctx.lr = 0x8243ECC4;
	sub_82DF3308(ctx, base);
	// 8243ECC4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8243ECC8: 40820018  bne 0x8243ece0
	if !ctx.cr[0].eq {
	pc = 0x8243ECE0; continue 'dispatch;
	}
	// 8243ECCC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8243ECD0: 896B0B44  lbz r11, 0xb44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2884 as u32) ) } as u64;
	// 8243ECD4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8243ECD8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8243ECDC: 41820008  beq 0x8243ece4
	if ctx.cr[0].eq {
	pc = 0x8243ECE4; continue 'dispatch;
	}
	// 8243ECE0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8243ECE4: 57EA0673  rlwinm. r10, r31, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8243ECE8: 557D063E  clrlwi r29, r11, 0x18
	ctx.r[29].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8243ECEC: 41820010  beq 0x8243ecfc
	if ctx.cr[0].eq {
	pc = 0x8243ECFC; continue 'dispatch;
	}
	// 8243ECF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8243ECF4: 57FF06B0  rlwinm r31, r31, 0, 0x1a, 0x18
	ctx.r[31].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	// 8243ECF8: 489B4731  bl 0x82df3428
	ctx.lr = 0x8243ECFC;
	sub_82DF3428(ctx, base);
	// 8243ECFC: 57EB06B5  rlwinm. r11, r31, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8243ED00: 41820010  beq 0x8243ed10
	if ctx.cr[0].eq {
	pc = 0x8243ED10; continue 'dispatch;
	}
	// 8243ED04: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8243ED08: 57FF06F2  rlwinm r31, r31, 0, 0x1b, 0x19
	ctx.r[31].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	// 8243ED0C: 489B471D  bl 0x82df3428
	ctx.lr = 0x8243ED10;
	sub_82DF3428(ctx, base);
	// 8243ED10: 57EB06F7  rlwinm. r11, r31, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8243ED14: 41820010  beq 0x8243ed24
	if ctx.cr[0].eq {
	pc = 0x8243ED24; continue 'dispatch;
	}
	// 8243ED18: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8243ED1C: 57FF0734  rlwinm r31, r31, 0, 0x1c, 0x1a
	ctx.r[31].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	// 8243ED20: 489B4709  bl 0x82df3428
	ctx.lr = 0x8243ED24;
	sub_82DF3428(ctx, base);
	// 8243ED24: 57EB0739  rlwinm. r11, r31, 0, 0x1c, 0x1c
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8243ED28: 41820010  beq 0x8243ed38
	if ctx.cr[0].eq {
	pc = 0x8243ED38; continue 'dispatch;
	}
	// 8243ED2C: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 8243ED30: 57FF0776  rlwinm r31, r31, 0, 0x1d, 0x1b
	ctx.r[31].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	// 8243ED34: 489B46F5  bl 0x82df3428
	ctx.lr = 0x8243ED38;
	sub_82DF3428(ctx, base);
	// 8243ED38: 57EB077B  rlwinm. r11, r31, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8243ED3C: 41820010  beq 0x8243ed4c
	if ctx.cr[0].eq {
	pc = 0x8243ED4C; continue 'dispatch;
	}
	// 8243ED40: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8243ED44: 57FF07B8  rlwinm r31, r31, 0, 0x1e, 0x1c
	ctx.r[31].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	// 8243ED48: 489B46E1  bl 0x82df3428
	ctx.lr = 0x8243ED4C;
	sub_82DF3428(ctx, base);
	// 8243ED4C: 57EB07BD  rlwinm. r11, r31, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8243ED50: 41820010  beq 0x8243ed60
	if ctx.cr[0].eq {
	pc = 0x8243ED60; continue 'dispatch;
	}
	// 8243ED54: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 8243ED58: 57FF07FA  rlwinm r31, r31, 0, 0x1f, 0x1d
	ctx.r[31].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	// 8243ED5C: 489B46CD  bl 0x82df3428
	ctx.lr = 0x8243ED60;
	sub_82DF3428(ctx, base);
	// 8243ED60: 57EB07FF  clrlwi. r11, r31, 0x1f
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8243ED64: 4182000C  beq 0x8243ed70
	if ctx.cr[0].eq {
	pc = 0x8243ED70; continue 'dispatch;
	}
	// 8243ED68: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8243ED6C: 489B46BD  bl 0x82df3428
	ctx.lr = 0x8243ED70;
	sub_82DF3428(ctx, base);
	// 8243ED70: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8243ED74: 41820044  beq 0x8243edb8
	if ctx.cr[0].eq {
	pc = 0x8243EDB8; continue 'dispatch;
	}
	// 8243ED78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8243ED7C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8243ED80: 4BE81281  bl 0x822c0000
	ctx.lr = 0x8243ED84;
	sub_822C0000(ctx, base);
	// 8243ED84: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8243ED88: 4BFFF571  bl 0x8243e2f8
	ctx.lr = 0x8243ED8C;
	sub_8243E2F8(ctx, base);
	// 8243ED8C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8243ED90: 41820028  beq 0x8243edb8
	if ctx.cr[0].eq {
	pc = 0x8243EDB8; continue 'dispatch;
	}
	// 8243ED94: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 8243ED98: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8243ED9C: 808B7DC0  lwz r4, 0x7dc0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32192 as u32) ) } as u64;
	// 8243EDA0: 489B4C69  bl 0x82df3a08
	ctx.lr = 0x8243EDA4;
	sub_82DF3A08(ctx, base);
	// 8243EDA4: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 8243EDA8: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8243EDAC: 4BEC67E5  bl 0x82305590
	ctx.lr = 0x8243EDB0;
	sub_82305590(ctx, base);
	// 8243EDB0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8243EDB4: 489B4675  bl 0x82df3428
	ctx.lr = 0x8243EDB8;
	sub_82DF3428(ctx, base);
	// 8243EDB8: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 8243EDBC: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 8243EDC0: 48D693FC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8243EDC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8243EDC8 size=48
    let mut pc: u32 = 0x8243EDC8;
    'dispatch: loop {
        match pc {
            0x8243EDC8 => {
    //   block [0x8243EDC8..0x8243EDF8)
	// 8243EDC8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8243EDCC: C00B9F7C  lfs f0, -0x6084(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24708 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8243EDD0: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 8243EDD4: 40980008  bge cr6, 0x8243eddc
	if !ctx.cr[6].lt {
	pc = 0x8243EDDC; continue 'dispatch;
	}
	// 8243EDD8: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	// 8243EDDC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8243EDE0: D02300D0  stfs f1, 0xd0(r3)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 8243EDE4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8243EDE8: 994300D8  stb r10, 0xd8(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(216 as u32), ctx.r[10].u8 ) };
	// 8243EDEC: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8243EDF0: D00300D4  stfs f0, 0xd4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 8243EDF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8243EDF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8243EDF8 size=48
    let mut pc: u32 = 0x8243EDF8;
    'dispatch: loop {
        match pc {
            0x8243EDF8 => {
    //   block [0x8243EDF8..0x8243EE28)
	// 8243EDF8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8243EDFC: C00B9F7C  lfs f0, -0x6084(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24708 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8243EE00: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 8243EE04: 40980008  bge cr6, 0x8243ee0c
	if !ctx.cr[6].lt {
	pc = 0x8243EE0C; continue 'dispatch;
	}
	// 8243EE08: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	// 8243EE0C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8243EE10: D02300DC  stfs f1, 0xdc(r3)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 8243EE14: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8243EE18: 994300E4  stb r10, 0xe4(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(228 as u32), ctx.r[10].u8 ) };
	// 8243EE1C: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8243EE20: D00300E0  stfs f0, 0xe0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 8243EE24: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8243EE28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8243EE28 size=12
    let mut pc: u32 = 0x8243EE28;
    'dispatch: loop {
        match pc {
            0x8243EE28 => {
    //   block [0x8243EE28..0x8243EE34)
	// 8243EE28: 896300D8  lbz r11, 0xd8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(216 as u32) ) } as u64;
	// 8243EE2C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8243EE30: 4D820020  beqlr
	if ctx.cr[0].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8243EE34(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8243EE34 size=32
    let mut pc: u32 = 0x8243EE34;
    'dispatch: loop {
        match pc {
            0x8243EE34 => {
    //   block [0x8243EE34..0x8243EE54)
	// 8243EE34: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8243EE38: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8243EE3C: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 8243EE40: 409A0014  bne cr6, 0x8243ee54
	if !ctx.cr[6].eq {
		sub_8243EE54(ctx, base);
		return;
	}
	// 8243EE44: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8243EE48: D00300D4  stfs f0, 0xd4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 8243EE4C: 996300D8  stb r11, 0xd8(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(216 as u32), ctx.r[11].u8 ) };
	// 8243EE50: 4800001C  b 0x8243ee6c
	sub_8243EE54(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8243EE54(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8243EE54 size=32
    let mut pc: u32 = 0x8243EE54;
    'dispatch: loop {
        match pc {
            0x8243EE54 => {
    //   block [0x8243EE54..0x8243EE74)
	// 8243EE54: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8243EE58: C00B9F7C  lfs f0, -0x6084(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24708 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8243EE5C: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 8243EE60: 40980008  bge cr6, 0x8243ee68
	if !ctx.cr[6].lt {
	pc = 0x8243EE68; continue 'dispatch;
	}
	// 8243EE64: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	// 8243EE68: FC000850  fneg f0, f1
	ctx.f[0].u64 = ctx.f[1].u64 ^ 0x8000_0000_0000_0000u64;
	// 8243EE6C: D00300D0  stfs f0, 0xd0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 8243EE70: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8243EE78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8243EE78 size=12
    let mut pc: u32 = 0x8243EE78;
    'dispatch: loop {
        match pc {
            0x8243EE78 => {
    //   block [0x8243EE78..0x8243EE84)
	// 8243EE78: 896300E4  lbz r11, 0xe4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(228 as u32) ) } as u64;
	// 8243EE7C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8243EE80: 4D820020  beqlr
	if ctx.cr[0].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8243EE84(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8243EE84 size=32
    let mut pc: u32 = 0x8243EE84;
    'dispatch: loop {
        match pc {
            0x8243EE84 => {
    //   block [0x8243EE84..0x8243EEA4)
	// 8243EE84: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8243EE88: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8243EE8C: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 8243EE90: 409A0014  bne cr6, 0x8243eea4
	if !ctx.cr[6].eq {
		sub_8243EEA4(ctx, base);
		return;
	}
	// 8243EE94: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8243EE98: D00300E0  stfs f0, 0xe0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 8243EE9C: 996300E4  stb r11, 0xe4(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(228 as u32), ctx.r[11].u8 ) };
	// 8243EEA0: 4800001C  b 0x8243eebc
	sub_8243EEA4(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8243EEA4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8243EEA4 size=32
    let mut pc: u32 = 0x8243EEA4;
    'dispatch: loop {
        match pc {
            0x8243EEA4 => {
    //   block [0x8243EEA4..0x8243EEC4)
	// 8243EEA4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8243EEA8: C00B9F7C  lfs f0, -0x6084(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24708 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8243EEAC: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 8243EEB0: 40980008  bge cr6, 0x8243eeb8
	if !ctx.cr[6].lt {
	pc = 0x8243EEB8; continue 'dispatch;
	}
	// 8243EEB4: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	// 8243EEB8: FC000850  fneg f0, f1
	ctx.f[0].u64 = ctx.f[1].u64 ^ 0x8000_0000_0000_0000u64;
	// 8243EEBC: D00300DC  stfs f0, 0xdc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 8243EEC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8243EEC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8243EEC8 size=96
    let mut pc: u32 = 0x8243EEC8;
    'dispatch: loop {
        match pc {
            0x8243EEC8 => {
    //   block [0x8243EEC8..0x8243EF28)
	// 8243EEC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8243EECC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8243EED0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8243EED4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8243EED8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8243EEDC: 80640054  lwz r3, 0x54(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(84 as u32) ) } as u64;
	// 8243EEE0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8243EEE4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8243EEE8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8243EEEC: 4E800421  bctrl
	ctx.lr = 0x8243EEF0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8243EEF0: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8243EEF4: C1A30034  lfs f13, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8243EEF8: C1830038  lfs f12, 0x38(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8243EEFC: C163003C  lfs f11, 0x3c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8243EF00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8243EF04: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 8243EF08: D1BF0004  stfs f13, 4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 8243EF0C: D19F0008  stfs f12, 8(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 8243EF10: D17F000C  stfs f11, 0xc(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 8243EF14: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8243EF18: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8243EF1C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8243EF20: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8243EF24: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8243EF28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8243EF28 size=96
    let mut pc: u32 = 0x8243EF28;
    'dispatch: loop {
        match pc {
            0x8243EF28 => {
    //   block [0x8243EF28..0x8243EF88)
	// 8243EF28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8243EF2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8243EF30: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8243EF34: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8243EF38: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8243EF3C: 8064005C  lwz r3, 0x5c(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(92 as u32) ) } as u64;
	// 8243EF40: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8243EF44: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8243EF48: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8243EF4C: 4E800421  bctrl
	ctx.lr = 0x8243EF50;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8243EF50: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8243EF54: C1A30034  lfs f13, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8243EF58: C1830038  lfs f12, 0x38(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8243EF5C: C163003C  lfs f11, 0x3c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8243EF60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8243EF64: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 8243EF68: D1BF0004  stfs f13, 4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 8243EF6C: D19F0008  stfs f12, 8(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 8243EF70: D17F000C  stfs f11, 0xc(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 8243EF74: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8243EF78: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8243EF7C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8243EF80: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8243EF84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8243EF88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8243EF88 size=96
    let mut pc: u32 = 0x8243EF88;
    'dispatch: loop {
        match pc {
            0x8243EF88 => {
    //   block [0x8243EF88..0x8243EFE8)
	// 8243EF88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8243EF8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8243EF90: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8243EF94: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8243EF98: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8243EF9C: 80640064  lwz r3, 0x64(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(100 as u32) ) } as u64;
	// 8243EFA0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8243EFA4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8243EFA8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8243EFAC: 4E800421  bctrl
	ctx.lr = 0x8243EFB0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8243EFB0: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8243EFB4: C1A30034  lfs f13, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8243EFB8: C1830038  lfs f12, 0x38(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8243EFBC: C163003C  lfs f11, 0x3c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8243EFC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8243EFC4: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 8243EFC8: D1BF0004  stfs f13, 4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 8243EFCC: D19F0008  stfs f12, 8(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 8243EFD0: D17F000C  stfs f11, 0xc(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 8243EFD4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8243EFD8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8243EFDC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8243EFE0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8243EFE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8243EFE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8243EFE8 size=96
    let mut pc: u32 = 0x8243EFE8;
    'dispatch: loop {
        match pc {
            0x8243EFE8 => {
    //   block [0x8243EFE8..0x8243F048)
	// 8243EFE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8243EFEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8243EFF0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8243EFF4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8243EFF8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8243EFFC: 8064004C  lwz r3, 0x4c(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 8243F000: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8243F004: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8243F008: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8243F00C: 4E800421  bctrl
	ctx.lr = 0x8243F010;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8243F010: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8243F014: C1A30034  lfs f13, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8243F018: C1830038  lfs f12, 0x38(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8243F01C: C163003C  lfs f11, 0x3c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8243F020: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8243F024: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 8243F028: D1BF0004  stfs f13, 4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 8243F02C: D19F0008  stfs f12, 8(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 8243F030: D17F000C  stfs f11, 0xc(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 8243F034: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8243F038: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8243F03C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8243F040: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8243F044: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8243F048(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8243F048 size=96
    let mut pc: u32 = 0x8243F048;
    'dispatch: loop {
        match pc {
            0x8243F048 => {
    //   block [0x8243F048..0x8243F0A8)
	// 8243F048: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8243F04C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8243F050: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8243F054: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8243F058: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8243F05C: 8064006C  lwz r3, 0x6c(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(108 as u32) ) } as u64;
	// 8243F060: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8243F064: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8243F068: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8243F06C: 4E800421  bctrl
	ctx.lr = 0x8243F070;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8243F070: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8243F074: C1A30034  lfs f13, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8243F078: C1830038  lfs f12, 0x38(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8243F07C: C163003C  lfs f11, 0x3c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8243F080: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8243F084: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 8243F088: D1BF0004  stfs f13, 4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 8243F08C: D19F0008  stfs f12, 8(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 8243F090: D17F000C  stfs f11, 0xc(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 8243F094: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8243F098: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8243F09C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8243F0A0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8243F0A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8243F0A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8243F0A8 size=76
    let mut pc: u32 = 0x8243F0A8;
    'dispatch: loop {
        match pc {
            0x8243F0A8 => {
    //   block [0x8243F0A8..0x8243F0F4)
	// 8243F0A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8243F0AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8243F0B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8243F0B4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8243F0B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8243F0BC: 8064006C  lwz r3, 0x6c(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(108 as u32) ) } as u64;
	// 8243F0C0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8243F0C4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8243F0C8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8243F0CC: 4E800421  bctrl
	ctx.lr = 0x8243F0D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8243F0D0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8243F0D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8243F0D8: 48A3DD31  bl 0x82e7ce08
	ctx.lr = 0x8243F0DC;
	sub_82E7CE08(ctx, base);
	// 8243F0DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8243F0E0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8243F0E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8243F0E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8243F0EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8243F0F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8243F0F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8243F0F8 size=2092
    let mut pc: u32 = 0x8243F0F8;
    'dispatch: loop {
        match pc {
            0x8243F0F8 => {
    //   block [0x8243F0F8..0x8243F924)
	// 8243F0F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8243F0FC: 48D69051  bl 0x831a814c
	ctx.lr = 0x8243F100;
	sub_831A8130(ctx, base);
	// 8243F100: 3981FFA0  addi r12, r1, -0x60
	ctx.r[12].s64 = ctx.r[1].s64 + -96;
	// 8243F104: 48D69975  bl 0x831a8a78
	ctx.lr = 0x8243F108;
	sub_831A8A40(ctx, base);
	// 8243F108: 3981FF80  addi r12, r1, -0x80
	ctx.r[12].s64 = ctx.r[1].s64 + -128;
	// 8243F10C: 48D6BAA9  bl 0x831aabb4
	ctx.lr = 0x8243F110;
	sub_831AA9A0(ctx, base);
	// 8243F110: 9421FD30  stwu r1, -0x2d0(r1)
	ea = ctx.r[1].u32.wrapping_add(-720 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8243F114: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8243F118: 897E0019  lbz r11, 0x19(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(25 as u32) ) } as u64;
	// 8243F11C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8243F120: 418207EC  beq 0x8243f90c
	if ctx.cr[0].eq {
	pc = 0x8243F90C; continue 'dispatch;
	}
	// 8243F124: 396100A0  addi r11, r1, 0xa0
	ctx.r[11].s64 = ctx.r[1].s64 + 160;
	// 8243F128: 807E0014  lwz r3, 0x14(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 8243F12C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8243F130: 392100C0  addi r9, r1, 0xc0
	ctx.r[9].s64 = ctx.r[1].s64 + 192;
	// 8243F134: 390100C0  addi r8, r1, 0xc0
	ctx.r[8].s64 = ctx.r[1].s64 + 192;
	// 8243F138: 3CE08212  lis r7, -0x7dee
	ctx.r[7].s64 = -2112749568;
	// 8243F13C: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8243F140: 396100A0  addi r11, r1, 0xa0
	ctx.r[11].s64 = ctx.r[1].s64 + 160;
	// 8243F144: C3EA08A8  lfs f31, 0x8a8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8243F148: 3947FFE0  addi r10, r7, -0x20
	ctx.r[10].s64 = ctx.r[7].s64 + -32;
	// 8243F14C: D3E100C0  stfs f31, 0xc0(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 8243F150: 38E100B0  addi r7, r1, 0xb0
	ctx.r[7].s64 = ctx.r[1].s64 + 176;
	// 8243F154: 13C048C7  vcmpequd (lvx128) v30, v0, v9
	tmp.u32 = ctx.r[9].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8243F928(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8243F928 size=4956
    let mut pc: u32 = 0x8243F928;
    'dispatch: loop {
        match pc {
            0x8243F928 => {
    //   block [0x8243F928..0x82440C84)
	// 8243F928: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8243F92C: 48D6880D  bl 0x831a8138
	ctx.lr = 0x8243F930;
	sub_831A8130(ctx, base);
	// 8243F930: 3981FF78  addi r12, r1, -0x88
	ctx.r[12].s64 = ctx.r[1].s64 + -136;
	// 8243F934: 48D69145  bl 0x831a8a78
	ctx.lr = 0x8243F938;
	sub_831A8A40(ctx, base);
	// 8243F938: 3981FF50  addi r12, r1, -0xb0
	ctx.r[12].s64 = ctx.r[1].s64 + -176;
	// 8243F93C: 48D6B2A1  bl 0x831aabdc
	ctx.lr = 0x8243F940;
	sub_831AA9A0(ctx, base);
	// 8243F940: 9421FCD0  stwu r1, -0x330(r1)
	ea = ctx.r[1].u32.wrapping_add(-816 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8243F944: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8243F948: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8243F94C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 8243F950: 3A000000  li r16, 0
	ctx.r[16].s64 = 0;
	// 8243F954: 895F00D8  lbz r10, 0xd8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(216 as u32) ) } as u64;
	// 8243F958: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8243F95C: C3A908A8  lfs f29, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 8243F960: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8243F964: 41820038  beq 0x8243f99c
	if ctx.cr[0].eq {
	pc = 0x8243F99C; continue 'dispatch;
	}
	// 8243F968: C01F00D0  lfs f0, 0xd0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8243F96C: EC010024  fdivs f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 / ctx.f[0].f64) as f32) as f64;
	// 8243F970: C1BF00D4  lfs f13, 0xd4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8243F974: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 8243F978: D01F00D4  stfs f0, 0xd4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 8243F97C: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 8243F980: 40990008  ble cr6, 0x8243f988
	if !ctx.cr[6].gt {
	pc = 0x8243F988; continue 'dispatch;
	}
	// 8243F984: D3BF00D4  stfs f29, 0xd4(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 8243F988: C01F00D4  lfs f0, 0xd4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8243F98C: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 8243F990: 4199000C  bgt cr6, 0x8243f99c
	if ctx.cr[6].gt {
	pc = 0x8243F99C; continue 'dispatch;
	}
	// 8243F994: D3FF00D4  stfs f31, 0xd4(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 8243F998: 9A1F00D8  stb r16, 0xd8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), ctx.r[16].u8 ) };
	// 8243F99C: 897F00E4  lbz r11, 0xe4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 8243F9A0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8243F9A4: 41820038  beq 0x8243f9dc
	if ctx.cr[0].eq {
	pc = 0x8243F9DC; continue 'dispatch;
	}
	// 8243F9A8: C01F00DC  lfs f0, 0xdc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8243F9AC: EC010024  fdivs f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 / ctx.f[0].f64) as f32) as f64;
	// 8243F9B0: C1BF00E0  lfs f13, 0xe0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8243F9B4: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 8243F9B8: D01F00E0  stfs f0, 0xe0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 8243F9BC: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 8243F9C0: 40990008  ble cr6, 0x8243f9c8
	if !ctx.cr[6].gt {
	pc = 0x8243F9C8; continue 'dispatch;
	}
	// 8243F9C4: D3BF00E0  stfs f29, 0xe0(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 8243F9C8: C01F00E0  lfs f0, 0xe0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8243F9CC: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 8243F9D0: 4199000C  bgt cr6, 0x8243f9dc
	if ctx.cr[6].gt {
	pc = 0x8243F9DC; continue 'dispatch;
	}
	// 8243F9D4: D3FF00E0  stfs f31, 0xe0(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 8243F9D8: 9A1F00E4  stb r16, 0xe4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[16].u8 ) };
	// 8243F9DC: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 8243F9E0: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 8243F9E4: 39210090  addi r9, r1, 0x90
	ctx.r[9].s64 = ctx.r[1].s64 + 144;
	// 8243F9E8: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 8243F9EC: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 8243F9F0: 3B2BFFE0  addi r25, r11, -0x20
	ctx.r[25].s64 = ctx.r[11].s64 + -32;
	// 8243F9F4: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8243F9F8: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 8243F9FC: D3A10090  stfs f29, 0x90(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 8243FA00: 39410090  addi r10, r1, 0x90
	ctx.r[10].s64 = ctx.r[1].s64 + 144;
	// 8243FA04: 13C048C7  vcmpequd (lvx128) v30, v0, v9
	tmp.u32 = ctx.r[9].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82440C88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82440C88 size=568
    let mut pc: u32 = 0x82440C88;
    'dispatch: loop {
        match pc {
            0x82440C88 => {
    //   block [0x82440C88..0x82440EC0)
	// 82440C88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82440C8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82440C90: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82440C94: DBC1FFE0  stfd f30, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[30].u64 ) };
	// 82440C98: DBE1FFE8  stfd f31, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82440C9C: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82440EC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82440EC0 size=4232
    let mut pc: u32 = 0x82440EC0;
    'dispatch: loop {
        match pc {
            0x82440EC0 => {
    //   block [0x82440EC0..0x82441F48)
	// 82440EC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82440EC4: 48D67271  bl 0x831a8134
	ctx.lr = 0x82440EC8;
	sub_831A8130(ctx, base);
	// 82440EC8: 3981FF70  addi r12, r1, -0x90
	ctx.r[12].s64 = ctx.r[1].s64 + -144;
	// 82440ECC: 48D67BA9  bl 0x831a8a74
	ctx.lr = 0x82440ED0;
	sub_831A8A40(ctx, base);
	// 82440ED0: 3980FF30  li r12, -0xd0
	ctx.r[12].s64 = -208;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82441F48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82441F48 size=600
    let mut pc: u32 = 0x82441F48;
    'dispatch: loop {
        match pc {
            0x82441F48 => {
    //   block [0x82441F48..0x824421A0)
	// 82441F48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82441F4C: 48D66215  bl 0x831a8160
	ctx.lr = 0x82441F50;
	sub_831A8130(ctx, base);
	// 82441F50: DBC1FFB8  stfd f30, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[30].u64 ) };
	// 82441F54: DBE1FFC0  stfd f31, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 82441F58: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82441F5C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82441F60: FFC00890  fmr f30, f1
	ctx.f[30].f64 = ctx.f[1].f64;
	// 82441F64: 897E0018  lbz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 82441F68: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82441F6C: 418201F8  beq 0x82442164
	if ctx.cr[0].eq {
	pc = 0x82442164; continue 'dispatch;
	}
	// 82441F70: 3BE000FF  li r31, 0xff
	ctx.r[31].s64 = 255;
	// 82441F74: 809E0014  lwz r4, 0x14(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82441F78: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82441F7C: 9BE10050  stb r31, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u8 ) };
	// 82441F80: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82441F84: 9BA10051  stb r29, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[29].u8 ) };
	// 82441F88: 9BE10052  stb r31, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[31].u8 ) };
	// 82441F8C: 9BA10053  stb r29, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[29].u8 ) };
	// 82441F90: 4BF5F8A9  bl 0x823a1838
	ctx.lr = 0x82441F94;
	sub_823A1838(ctx, base);
	// 82441F94: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82441F98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82441F9C: 3B6BFF34  addi r27, r11, -0xcc
	ctx.r[27].s64 = ctx.r[11].s64 + -204;
	// 82441FA0: 409A0008  bne cr6, 0x82441fa8
	if !ctx.cr[6].eq {
	pc = 0x82441FA8; continue 'dispatch;
	}
	// 82441FA4: 7FBBEB78  mr r27, r29
	ctx.r[27].u64 = ctx.r[29].u64;
	// 82441FA8: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82441FAC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82441FB0: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82441FB4: 3B8BBA80  addi r28, r11, -0x4580
	ctx.r[28].s64 = ctx.r[11].s64 + -17792;
	// 82441FB8: 3B410050  addi r26, r1, 0x50
	ctx.r[26].s64 = ctx.r[1].s64 + 80;
	// 82441FBC: 4BFFCF0D  bl 0x8243eec8
	ctx.lr = 0x82441FC0;
	sub_8243EEC8(ctx, base);
	// 82441FC0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82441FC4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82441FC8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82441FCC: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 82441FD0: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82441FD4: C3EB964C  lfs f31, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82441FD8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82441FDC: 4BE85A8D  bl 0x822c7a68
	ctx.lr = 0x82441FE0;
	sub_822C7A68(ctx, base);
	// 82441FE0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82441FE4: 489AFCAD  bl 0x82df1c90
	ctx.lr = 0x82441FE8;
	sub_82DF1C90(ctx, base);
	// 82441FE8: 9BE10054  stb r31, 0x54(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u8 ) };
	// 82441FEC: 9BA10055  stb r29, 0x55(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(85 as u32), ctx.r[29].u8 ) };
	// 82441FF0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82441FF4: 9BA10056  stb r29, 0x56(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(86 as u32), ctx.r[29].u8 ) };
	// 82441FF8: 9BE10057  stb r31, 0x57(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(87 as u32), ctx.r[31].u8 ) };
	// 82441FFC: 809E0014  lwz r4, 0x14(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82442000: 4BF5F839  bl 0x823a1838
	ctx.lr = 0x82442004;
	sub_823A1838(ctx, base);
	// 82442004: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82442008: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8244200C: 3B6BFF34  addi r27, r11, -0xcc
	ctx.r[27].s64 = ctx.r[11].s64 + -204;
	// 82442010: 409A0008  bne cr6, 0x82442018
	if !ctx.cr[6].eq {
	pc = 0x82442018; continue 'dispatch;
	}
	// 82442014: 7FBBEB78  mr r27, r29
	ctx.r[27].u64 = ctx.r[29].u64;
	// 82442018: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8244201C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82442020: 3B410054  addi r26, r1, 0x54
	ctx.r[26].s64 = ctx.r[1].s64 + 84;
	// 82442024: 4BFFCF65  bl 0x8243ef88
	ctx.lr = 0x82442028;
	sub_8243EF88(ctx, base);
	// 82442028: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8244202C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82442030: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82442034: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 82442038: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 8244203C: 4BE85A2D  bl 0x822c7a68
	ctx.lr = 0x82442040;
	sub_822C7A68(ctx, base);
	// 82442040: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82442044: 489AFC4D  bl 0x82df1c90
	ctx.lr = 0x82442048;
	sub_82DF1C90(ctx, base);
	// 82442048: 9BE10058  stb r31, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u8 ) };
	// 8244204C: 9BA10059  stb r29, 0x59(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(89 as u32), ctx.r[29].u8 ) };
	// 82442050: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82442054: 9BE1005A  stb r31, 0x5a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(90 as u32), ctx.r[31].u8 ) };
	// 82442058: 9BA1005B  stb r29, 0x5b(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(91 as u32), ctx.r[29].u8 ) };
	// 8244205C: 809E0014  lwz r4, 0x14(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82442060: 4BF5F7D9  bl 0x823a1838
	ctx.lr = 0x82442064;
	sub_823A1838(ctx, base);
	// 82442064: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82442068: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8244206C: 3B6BFF34  addi r27, r11, -0xcc
	ctx.r[27].s64 = ctx.r[11].s64 + -204;
	// 82442070: 409A0008  bne cr6, 0x82442078
	if !ctx.cr[6].eq {
	pc = 0x82442078; continue 'dispatch;
	}
	// 82442074: 7FBBEB78  mr r27, r29
	ctx.r[27].u64 = ctx.r[29].u64;
	// 82442078: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8244207C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82442080: 3B410058  addi r26, r1, 0x58
	ctx.r[26].s64 = ctx.r[1].s64 + 88;
	// 82442084: 4BFFCEA5  bl 0x8243ef28
	ctx.lr = 0x82442088;
	sub_8243EF28(ctx, base);
	// 82442088: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8244208C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82442090: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82442094: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 82442098: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 8244209C: 4BE859CD  bl 0x822c7a68
	ctx.lr = 0x824420A0;
	sub_822C7A68(ctx, base);
	// 824420A0: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 824420A4: 489AFBED  bl 0x82df1c90
	ctx.lr = 0x824420A8;
	sub_82DF1C90(ctx, base);
	// 824420A8: 9BE1005C  stb r31, 0x5c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u8 ) };
	// 824420AC: 9BA1005D  stb r29, 0x5d(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(93 as u32), ctx.r[29].u8 ) };
	// 824420B0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 824420B4: 9BA1005E  stb r29, 0x5e(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(94 as u32), ctx.r[29].u8 ) };
	// 824420B8: 9BE1005F  stb r31, 0x5f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(95 as u32), ctx.r[31].u8 ) };
	// 824420BC: 809E0014  lwz r4, 0x14(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 824420C0: 4BF5F779  bl 0x823a1838
	ctx.lr = 0x824420C4;
	sub_823A1838(ctx, base);
	// 824420C4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824420C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824420CC: 3B6BFF34  addi r27, r11, -0xcc
	ctx.r[27].s64 = ctx.r[11].s64 + -204;
	// 824420D0: 409A0008  bne cr6, 0x824420d8
	if !ctx.cr[6].eq {
	pc = 0x824420D8; continue 'dispatch;
	}
	// 824420D4: 7FBBEB78  mr r27, r29
	ctx.r[27].u64 = ctx.r[29].u64;
	// 824420D8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 824420DC: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 824420E0: 3B41005C  addi r26, r1, 0x5c
	ctx.r[26].s64 = ctx.r[1].s64 + 92;
	// 824420E4: 4BFFCF05  bl 0x8243efe8
	ctx.lr = 0x824420E8;
	sub_8243EFE8(ctx, base);
	// 824420E8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 824420EC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 824420F0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 824420F4: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 824420F8: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 824420FC: 4BE8596D  bl 0x822c7a68
	ctx.lr = 0x82442100;
	sub_822C7A68(ctx, base);
	// 82442100: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82442104: 489AFB8D  bl 0x82df1c90
	ctx.lr = 0x82442108;
	sub_82DF1C90(ctx, base);
	// 82442108: 9BE10060  stb r31, 0x60(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u8 ) };
	// 8244210C: 9BE10061  stb r31, 0x61(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(97 as u32), ctx.r[31].u8 ) };
	// 82442110: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82442114: 9BE10062  stb r31, 0x62(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(98 as u32), ctx.r[31].u8 ) };
	// 82442118: 9BE10063  stb r31, 0x63(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(99 as u32), ctx.r[31].u8 ) };
	// 8244211C: 809E0014  lwz r4, 0x14(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82442120: 4BF5F719  bl 0x823a1838
	ctx.lr = 0x82442124;
	sub_823A1838(ctx, base);
	// 82442124: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82442128: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8244212C: 419A0008  beq cr6, 0x82442134
	if ctx.cr[6].eq {
	pc = 0x82442134; continue 'dispatch;
	}
	// 82442130: 3BABFF34  addi r29, r11, -0xcc
	ctx.r[29].s64 = ctx.r[11].s64 + -204;
	// 82442134: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82442138: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 8244213C: 3BE10060  addi r31, r1, 0x60
	ctx.r[31].s64 = ctx.r[1].s64 + 96;
	// 82442140: 4BFFCF09  bl 0x8243f048
	ctx.lr = 0x82442144;
	sub_8243F048(ctx, base);
	// 82442144: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82442148: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8244214C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82442150: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82442154: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82442158: 4BE85911  bl 0x822c7a68
	ctx.lr = 0x8244215C;
	sub_822C7A68(ctx, base);
	// 8244215C: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82442160: 489AFB31  bl 0x82df1c90
	ctx.lr = 0x82442164;
	sub_82DF1C90(ctx, base);
	// 82442164: 897E00D8  lbz r11, 0xd8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(216 as u32) ) } as u64;
	// 82442168: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8244216C: 40820010  bne 0x8244217c
	if !ctx.cr[0].eq {
	pc = 0x8244217C; continue 'dispatch;
	}
	// 82442170: 897E00E4  lbz r11, 0xe4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(228 as u32) ) } as u64;
	// 82442174: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82442178: 41820018  beq 0x82442190
	if ctx.cr[0].eq {
	pc = 0x82442190; continue 'dispatch;
	}
	// 8244217C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82442180: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82442184: 4BFFD7A5  bl 0x8243f928
	ctx.lr = 0x82442188;
	sub_8243F928(ctx, base);
	// 82442188: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8244218C: 4BFFCF6D  bl 0x8243f0f8
	ctx.lr = 0x82442190;
	sub_8243F0F8(ctx, base);
	// 82442190: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82442194: CBC1FFB8  lfd f30, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82442198: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 8244219C: 48D66014  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824421A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824421A0 size=664
    let mut pc: u32 = 0x824421A0;
    'dispatch: loop {
        match pc {
            0x824421A0 => {
    //   block [0x824421A0..0x82442438)
	// 824421A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824421A4: 48D65FC1  bl 0x831a8164
	ctx.lr = 0x824421A8;
	sub_831A8130(ctx, base);
	// 824421A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824421AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824421B0: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 824421B4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 824421B8: 396B5D88  addi r11, r11, 0x5d88
	ctx.r[11].s64 = ctx.r[11].s64 + 23944;
	// 824421BC: 3D408000  lis r10, -0x8000
	ctx.r[10].s64 = -2147483648;
	// 824421C0: 909F0014  stw r4, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[4].u32 ) };
	// 824421C4: 387F0044  addi r3, r31, 0x44
	ctx.r[3].s64 = ctx.r[31].s64 + 68;
	// 824421C8: 9BBF0010  stb r29, 0x10(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[29].u8 ) };
	// 824421CC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824421D0: 9BBF0018  stb r29, 0x18(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[29].u8 ) };
	// 824421D4: 9BBF0019  stb r29, 0x19(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(25 as u32), ctx.r[29].u8 ) };
	// 824421D8: 93BF0030  stw r29, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[29].u32 ) };
	// 824421DC: 93BF0034  stw r29, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[29].u32 ) };
	// 824421E0: 93BF0038  stw r29, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[29].u32 ) };
	// 824421E4: 93BF003C  stw r29, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[29].u32 ) };
	// 824421E8: 915F0040  stw r10, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[10].u32 ) };
	// 824421EC: 489B0F05  bl 0x82df30f0
	ctx.lr = 0x824421F0;
	sub_82DF30F0(ctx, base);
	// 824421F0: 93BF0048  stw r29, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[29].u32 ) };
	// 824421F4: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 824421F8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 824421FC: 3B6B5D20  addi r27, r11, 0x5d20
	ctx.r[27].s64 = ctx.r[11].s64 + 23840;
	// 82442200: 38A00034  li r5, 0x34
	ctx.r[5].s64 = 52;
	// 82442204: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82442208: 38600100  li r3, 0x100
	ctx.r[3].s64 = 256;
	// 8244220C: 489B01DD  bl 0x82df23e8
	ctx.lr = 0x82442210;
	sub_82DF23E8(ctx, base);
	// 82442210: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82442214: 41820010  beq 0x82442224
	if ctx.cr[0].eq {
	pc = 0x82442224; continue 'dispatch;
	}
	// 82442218: 48148A81  bl 0x8258ac98
	ctx.lr = 0x8244221C;
	sub_8258AC98(ctx, base);
	// 8244221C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82442220: 48000008  b 0x82442228
	pc = 0x82442228; continue 'dispatch;
	// 82442224: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 82442228: 93DF004C  stw r30, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[30].u32 ) };
	// 8244222C: 397F004C  addi r11, r31, 0x4c
	ctx.r[11].s64 = ctx.r[31].s64 + 76;
	// 82442230: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82442234: 3B8B0004  addi r28, r11, 4
	ctx.r[28].s64 = ctx.r[11].s64 + 4;
	// 82442238: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8244223C: 4BEC4755  bl 0x82306990
	ctx.lr = 0x82442240;
	sub_82306990(ctx, base);
	// 82442240: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82442244: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82442248: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8244224C: 4BE7DDB5  bl 0x822c0000
	ctx.lr = 0x82442250;
	sub_822C0000(ctx, base);
	// 82442250: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82442254: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82442258: 38A00031  li r5, 0x31
	ctx.r[5].s64 = 49;
	// 8244225C: 38600100  li r3, 0x100
	ctx.r[3].s64 = 256;
	// 82442260: 489B0189  bl 0x82df23e8
	ctx.lr = 0x82442264;
	sub_82DF23E8(ctx, base);
	// 82442264: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82442268: 41820010  beq 0x82442278
	if ctx.cr[0].eq {
	pc = 0x82442278; continue 'dispatch;
	}
	// 8244226C: 48148A2D  bl 0x8258ac98
	ctx.lr = 0x82442270;
	sub_8258AC98(ctx, base);
	// 82442270: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82442274: 48000008  b 0x8244227c
	pc = 0x8244227C; continue 'dispatch;
	// 82442278: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 8244227C: 93DF0054  stw r30, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82442280: 397F0054  addi r11, r31, 0x54
	ctx.r[11].s64 = ctx.r[31].s64 + 84;
	// 82442284: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82442288: 3B8B0004  addi r28, r11, 4
	ctx.r[28].s64 = ctx.r[11].s64 + 4;
	// 8244228C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82442290: 4BEC4701  bl 0x82306990
	ctx.lr = 0x82442294;
	sub_82306990(ctx, base);
	// 82442294: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82442298: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8244229C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 824422A0: 4BE7DD61  bl 0x822c0000
	ctx.lr = 0x824422A4;
	sub_822C0000(ctx, base);
	// 824422A4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 824422A8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 824422AC: 38A00032  li r5, 0x32
	ctx.r[5].s64 = 50;
	// 824422B0: 38600100  li r3, 0x100
	ctx.r[3].s64 = 256;
	// 824422B4: 489B0135  bl 0x82df23e8
	ctx.lr = 0x824422B8;
	sub_82DF23E8(ctx, base);
	// 824422B8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 824422BC: 41820010  beq 0x824422cc
	if ctx.cr[0].eq {
	pc = 0x824422CC; continue 'dispatch;
	}
	// 824422C0: 481489D9  bl 0x8258ac98
	ctx.lr = 0x824422C4;
	sub_8258AC98(ctx, base);
	// 824422C4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 824422C8: 48000008  b 0x824422d0
	pc = 0x824422D0; continue 'dispatch;
	// 824422CC: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 824422D0: 93DF005C  stw r30, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 824422D4: 397F005C  addi r11, r31, 0x5c
	ctx.r[11].s64 = ctx.r[31].s64 + 92;
	// 824422D8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 824422DC: 3B8B0004  addi r28, r11, 4
	ctx.r[28].s64 = ctx.r[11].s64 + 4;
	// 824422E0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 824422E4: 4BEC46AD  bl 0x82306990
	ctx.lr = 0x824422E8;
	sub_82306990(ctx, base);
	// 824422E8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 824422EC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 824422F0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 824422F4: 4BE7DD0D  bl 0x822c0000
	ctx.lr = 0x824422F8;
	sub_822C0000(ctx, base);
	// 824422F8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 824422FC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82442300: 38A00033  li r5, 0x33
	ctx.r[5].s64 = 51;
	// 82442304: 38600100  li r3, 0x100
	ctx.r[3].s64 = 256;
	// 82442308: 489B00E1  bl 0x82df23e8
	ctx.lr = 0x8244230C;
	sub_82DF23E8(ctx, base);
	// 8244230C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82442310: 41820010  beq 0x82442320
	if ctx.cr[0].eq {
	pc = 0x82442320; continue 'dispatch;
	}
	// 82442314: 48148985  bl 0x8258ac98
	ctx.lr = 0x82442318;
	sub_8258AC98(ctx, base);
	// 82442318: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8244231C: 48000008  b 0x82442324
	pc = 0x82442324; continue 'dispatch;
	// 82442320: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 82442324: 93DF0064  stw r30, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 82442328: 397F0064  addi r11, r31, 0x64
	ctx.r[11].s64 = ctx.r[31].s64 + 100;
	// 8244232C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82442330: 3B8B0004  addi r28, r11, 4
	ctx.r[28].s64 = ctx.r[11].s64 + 4;
	// 82442334: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82442338: 4BEC4659  bl 0x82306990
	ctx.lr = 0x8244233C;
	sub_82306990(ctx, base);
	// 8244233C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82442340: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82442344: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82442348: 4BE7DCB9  bl 0x822c0000
	ctx.lr = 0x8244234C;
	sub_822C0000(ctx, base);
	// 8244234C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82442350: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82442354: 38A00035  li r5, 0x35
	ctx.r[5].s64 = 53;
	// 82442358: 38600100  li r3, 0x100
	ctx.r[3].s64 = 256;
	// 8244235C: 489B008D  bl 0x82df23e8
	ctx.lr = 0x82442360;
	sub_82DF23E8(ctx, base);
	// 82442360: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82442364: 41820010  beq 0x82442374
	if ctx.cr[0].eq {
	pc = 0x82442374; continue 'dispatch;
	}
	// 82442368: 48148931  bl 0x8258ac98
	ctx.lr = 0x8244236C;
	sub_8258AC98(ctx, base);
	// 8244236C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82442370: 48000008  b 0x82442378
	pc = 0x82442378; continue 'dispatch;
	// 82442374: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 82442378: 93DF006C  stw r30, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[30].u32 ) };
	// 8244237C: 397F006C  addi r11, r31, 0x6c
	ctx.r[11].s64 = ctx.r[31].s64 + 108;
	// 82442380: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82442384: 3B8B0004  addi r28, r11, 4
	ctx.r[28].s64 = ctx.r[11].s64 + 4;
	// 82442388: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8244238C: 4BEC4605  bl 0x82306990
	ctx.lr = 0x82442390;
	sub_82306990(ctx, base);
	// 82442390: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82442394: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82442398: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8244239C: 4BE7DC65  bl 0x822c0000
	ctx.lr = 0x824423A0;
	sub_822C0000(ctx, base);
	// 824423A0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 824423A4: 9BBF00D8  stb r29, 0xd8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), ctx.r[29].u8 ) };
	// 824423A8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 824423AC: 9BBF00E4  stb r29, 0xe4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[29].u8 ) };
	// 824423B0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 824423B4: 38A00038  li r5, 0x38
	ctx.r[5].s64 = 56;
	// 824423B8: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 824423BC: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824423C0: D01F00D0  stfs f0, 0xd0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 824423C4: D01F00D4  stfs f0, 0xd4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 824423C8: D01F00DC  stfs f0, 0xdc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 824423CC: D01F00E0  stfs f0, 0xe0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 824423D0: 489B0019  bl 0x82df23e8
	ctx.lr = 0x824423D4;
	sub_82DF23E8(ctx, base);
	// 824423D4: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 824423D8: 41820024  beq 0x824423fc
	if ctx.cr[0].eq {
	pc = 0x824423FC; continue 'dispatch;
	}
	// 824423DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824423E0: 48A172C1  bl 0x82e596a0
	ctx.lr = 0x824423E4;
	sub_82E596A0(ctx, base);
	// 824423E4: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 824423E8: 396BC2FC  addi r11, r11, -0x3d04
	ctx.r[11].s64 = ctx.r[11].s64 + -15620;
	// 824423EC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824423F0: 93BE0018  stw r29, 0x18(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), ctx.r[29].u32 ) };
	// 824423F4: 93BE001C  stw r29, 0x1c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), ctx.r[29].u32 ) };
	// 824423F8: 48000008  b 0x82442400
	pc = 0x82442400; continue 'dispatch;
	// 824423FC: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 82442400: 93DF00E8  stw r30, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[30].u32 ) };
	// 82442404: 397F00E8  addi r11, r31, 0xe8
	ctx.r[11].s64 = ctx.r[31].s64 + 232;
	// 82442408: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8244240C: 3B8B0004  addi r28, r11, 4
	ctx.r[28].s64 = ctx.r[11].s64 + 4;
	// 82442410: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82442414: 4BF619AD  bl 0x823a3dc0
	ctx.lr = 0x82442418;
	sub_823A3DC0(ctx, base);
	// 82442418: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8244241C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82442420: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82442424: 4BE7DBDD  bl 0x822c0000
	ctx.lr = 0x82442428;
	sub_822C0000(ctx, base);
	// 82442428: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8244242C: 9BBF0018  stb r29, 0x18(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[29].u8 ) };
	// 82442430: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82442434: 48D65D80  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82442438(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82442438 size=216
    let mut pc: u32 = 0x82442438;
    'dispatch: loop {
        match pc {
            0x82442438 => {
    //   block [0x82442438..0x82442510)
	// 82442438: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8244243C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82442440: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82442444: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82442448: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8244244C: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82442450: 396B5D88  addi r11, r11, 0x5d88
	ctx.r[11].s64 = ctx.r[11].s64 + 23944;
	// 82442454: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82442458: 807F00EC  lwz r3, 0xec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 8244245C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82442460: 419A0008  beq cr6, 0x82442468
	if ctx.cr[6].eq {
	pc = 0x82442468; continue 'dispatch;
	}
	// 82442464: 4BE7E42D  bl 0x822c0890
	ctx.lr = 0x82442468;
	sub_822C0890(ctx, base);
	// 82442468: 807F0070  lwz r3, 0x70(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 8244246C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82442470: 419A0008  beq cr6, 0x82442478
	if ctx.cr[6].eq {
	pc = 0x82442478; continue 'dispatch;
	}
	// 82442474: 4BE7E41D  bl 0x822c0890
	ctx.lr = 0x82442478;
	sub_822C0890(ctx, base);
	// 82442478: 807F0068  lwz r3, 0x68(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 8244247C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82442480: 419A0008  beq cr6, 0x82442488
	if ctx.cr[6].eq {
	pc = 0x82442488; continue 'dispatch;
	}
	// 82442484: 4BE7E40D  bl 0x822c0890
	ctx.lr = 0x82442488;
	sub_822C0890(ctx, base);
	// 82442488: 807F0060  lwz r3, 0x60(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 8244248C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82442490: 419A0008  beq cr6, 0x82442498
	if ctx.cr[6].eq {
	pc = 0x82442498; continue 'dispatch;
	}
	// 82442494: 4BE7E3FD  bl 0x822c0890
	ctx.lr = 0x82442498;
	sub_822C0890(ctx, base);
	// 82442498: 807F0058  lwz r3, 0x58(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 8244249C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 824424A0: 419A0008  beq cr6, 0x824424a8
	if ctx.cr[6].eq {
	pc = 0x824424A8; continue 'dispatch;
	}
	// 824424A4: 4BE7E3ED  bl 0x822c0890
	ctx.lr = 0x824424A8;
	sub_822C0890(ctx, base);
	// 824424A8: 807F0050  lwz r3, 0x50(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 824424AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 824424B0: 419A0008  beq cr6, 0x824424b8
	if ctx.cr[6].eq {
	pc = 0x824424B8; continue 'dispatch;
	}
	// 824424B4: 4BE7E3DD  bl 0x822c0890
	ctx.lr = 0x824424B8;
	sub_822C0890(ctx, base);
	// 824424B8: 387F0044  addi r3, r31, 0x44
	ctx.r[3].s64 = ctx.r[31].s64 + 68;
	// 824424BC: 489B0F6D  bl 0x82df3428
	ctx.lr = 0x824424C0;
	sub_82DF3428(ctx, base);
	// 824424C0: 817F0040  lwz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 824424C4: 556A0001  rlwinm. r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824424C8: 40820024  bne 0x824424ec
	if !ctx.cr[0].eq {
	pc = 0x824424EC; continue 'dispatch;
	}
	// 824424CC: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824424D0: 39200014  li r9, 0x14
	ctx.r[9].s64 = 20;
	// 824424D4: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 824424D8: 809F0038  lwz r4, 0x38(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 824424DC: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 824424E0: 1CAB0030  mulli r5, r11, 0x30
	ctx.r[5].s64 = ctx.r[11].s64 * 48;
	// 824424E4: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 824424E8: 48A5E2C9  bl 0x82ea07b0
	ctx.lr = 0x824424EC;
	sub_82EA07B0(ctx, base);
	// 824424EC: 807F0034  lwz r3, 0x34(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 824424F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 824424F4: 419A0008  beq cr6, 0x824424fc
	if ctx.cr[6].eq {
	pc = 0x824424FC; continue 'dispatch;
	}
	// 824424F8: 4BE7E399  bl 0x822c0890
	ctx.lr = 0x824424FC;
	sub_822C0890(ctx, base);
	// 824424FC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82442500: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82442504: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82442508: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8244250C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82442510(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82442510 size=76
    let mut pc: u32 = 0x82442510;
    'dispatch: loop {
        match pc {
            0x82442510 => {
    //   block [0x82442510..0x8244255C)
	// 82442510: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82442514: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82442518: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8244251C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82442520: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82442524: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82442528: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8244252C: 4BFFFF0D  bl 0x82442438
	ctx.lr = 0x82442530;
	sub_82442438(ctx, base);
	// 82442530: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82442534: 4182000C  beq 0x82442540
	if ctx.cr[0].eq {
	pc = 0x82442540; continue 'dispatch;
	}
	// 82442538: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8244253C: 489AFE9D  bl 0x82df23d8
	ctx.lr = 0x82442540;
	sub_82DF23D8(ctx, base);
	// 82442540: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82442544: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82442548: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8244254C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82442550: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82442554: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82442558: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82442560(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82442560 size=2208
    let mut pc: u32 = 0x82442560;
    'dispatch: loop {
        match pc {
            0x82442560 => {
    //   block [0x82442560..0x82442E00)
	// 82442560: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82442564: 48D65BE9  bl 0x831a814c
	ctx.lr = 0x82442568;
	sub_831A8130(ctx, base);
	// 82442568: DBE1FF98  stfd f31, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[31].u64 ) };
	// 8244256C: 9421FD50  stwu r1, -0x2b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-688 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82442570: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82442574: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82442578: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 8244257C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82442580: 807F0054  lwz r3, 0x54(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82442584: 48C101C5  bl 0x83052748
	ctx.lr = 0x82442588;
	sub_83052748(ctx, base);
	// 82442588: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8244258C: 41820018  beq 0x824425a4
	if ctx.cr[0].eq {
	pc = 0x824425A4; continue 'dispatch;
	}
	// 82442590: 83DF0054  lwz r30, 0x54(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82442594: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82442598: 48C101B1  bl 0x83052748
	ctx.lr = 0x8244259C;
	sub_83052748(ctx, base);
	// 8244259C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 824425A0: 489D0459  bl 0x82e129f8
	ctx.lr = 0x824425A4;
	sub_82E129F8(ctx, base);
	// 824425A4: 807F0064  lwz r3, 0x64(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 824425A8: 48C101A1  bl 0x83052748
	ctx.lr = 0x824425AC;
	sub_83052748(ctx, base);
	// 824425AC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 824425B0: 41820018  beq 0x824425c8
	if ctx.cr[0].eq {
	pc = 0x824425C8; continue 'dispatch;
	}
	// 824425B4: 83DF0064  lwz r30, 0x64(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 824425B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824425BC: 48C1018D  bl 0x83052748
	ctx.lr = 0x824425C0;
	sub_83052748(ctx, base);
	// 824425C0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 824425C4: 489D0435  bl 0x82e129f8
	ctx.lr = 0x824425C8;
	sub_82E129F8(ctx, base);
	// 824425C8: 807F005C  lwz r3, 0x5c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 824425CC: 48C1017D  bl 0x83052748
	ctx.lr = 0x824425D0;
	sub_83052748(ctx, base);
	// 824425D0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 824425D4: 41820018  beq 0x824425ec
	if ctx.cr[0].eq {
	pc = 0x824425EC; continue 'dispatch;
	}
	// 824425D8: 83DF005C  lwz r30, 0x5c(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 824425DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824425E0: 48C10169  bl 0x83052748
	ctx.lr = 0x824425E4;
	sub_83052748(ctx, base);
	// 824425E4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 824425E8: 489D0411  bl 0x82e129f8
	ctx.lr = 0x824425EC;
	sub_82E129F8(ctx, base);
	// 824425EC: 807F004C  lwz r3, 0x4c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 824425F0: 48C10159  bl 0x83052748
	ctx.lr = 0x824425F4;
	sub_83052748(ctx, base);
	// 824425F4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 824425F8: 41820018  beq 0x82442610
	if ctx.cr[0].eq {
	pc = 0x82442610; continue 'dispatch;
	}
	// 824425FC: 83DF004C  lwz r30, 0x4c(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82442600: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82442604: 48C10145  bl 0x83052748
	ctx.lr = 0x82442608;
	sub_83052748(ctx, base);
	// 82442608: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8244260C: 489D03ED  bl 0x82e129f8
	ctx.lr = 0x82442610;
	sub_82E129F8(ctx, base);
	// 82442610: 807F006C  lwz r3, 0x6c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82442614: 48C10135  bl 0x83052748
	ctx.lr = 0x82442618;
	sub_83052748(ctx, base);
	// 82442618: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8244261C: 41820018  beq 0x82442634
	if ctx.cr[0].eq {
	pc = 0x82442634; continue 'dispatch;
	}
	// 82442620: 83DF006C  lwz r30, 0x6c(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82442624: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82442628: 48C10121  bl 0x83052748
	ctx.lr = 0x8244262C;
	sub_83052748(ctx, base);
	// 8244262C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82442630: 489D03C9  bl 0x82e129f8
	ctx.lr = 0x82442634;
	sub_82E129F8(ctx, base);
	// 82442634: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82442638: 4BF939E9  bl 0x823d6020
	ctx.lr = 0x8244263C;
	sub_823D6020(ctx, base);
	// 8244263C: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82442640: 3AC00070  li r22, 0x70
	ctx.r[22].s64 = 112;
	// 82442644: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82442648: 814A0398  lwz r10, 0x398(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(920 as u32) ) } as u64;
	// 8244264C: 82A10064  lwz r21, 0x64(r1)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82442650: 83C10060  lwz r30, 0x60(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82442654: 2B150000  cmplwi cr6, r21, 0
	ctx.cr[6].compare_u32(ctx.r[21].u32, 0 as u32, &mut ctx.xer);
	// 82442658: 13EAB0C7  vcmpequd (lvx128) v31, v10, v22
	tmp.u32 = ctx.r[10].u32 + ctx.r[22].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82442E00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82442E00 size=752
    let mut pc: u32 = 0x82442E00;
    'dispatch: loop {
        match pc {
            0x82442E00 => {
    //   block [0x82442E00..0x824430F0)
	// 82442E00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82442E04: 48D65359  bl 0x831a815c
	ctx.lr = 0x82442E08;
	sub_831A8130(ctx, base);
	// 82442E08: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82442E0C: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82442E10: 807A0014  lwz r3, 0x14(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(20 as u32) ) } as u64;
	// 82442E14: 4BEC25D5  bl 0x823053e8
	ctx.lr = 0x82442E18;
	sub_823053E8(ctx, base);
	// 82442E18: 487699F1  bl 0x82bac808
	ctx.lr = 0x82442E1C;
	sub_82BAC808(ctx, base);
	// 82442E1C: 483A744D  bl 0x827ea268
	ctx.lr = 0x82442E20;
	sub_827EA268(ctx, base);
	// 82442E20: 907A001C  stw r3, 0x1c(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(28 as u32), ctx.r[3].u32 ) };
	// 82442E24: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82442E28: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82442E2C: 388B3EF8  addi r4, r11, 0x3ef8
	ctx.r[4].s64 = ctx.r[11].s64 + 16120;
	// 82442E30: 48B69EE1  bl 0x82facd10
	ctx.lr = 0x82442E34;
	sub_82FACD10(ctx, base);
	// 82442E34: 7C6B0734  extsh r11, r3
	ctx.r[11].s64 = ctx.r[3].s16 as i64;
	// 82442E38: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 82442E3C: 807A001C  lwz r3, 0x1c(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(28 as u32) ) } as u64;
	// 82442E40: 917A0020  stw r11, 0x20(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82442E44: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82442E48: 3BEAF820  addi r31, r10, -0x7e0
	ctx.r[31].s64 = ctx.r[10].s64 + -2016;
	// 82442E4C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82442E50: 48B69EC1  bl 0x82facd10
	ctx.lr = 0x82442E54;
	sub_82FACD10(ctx, base);
	// 82442E54: 7C6B0734  extsh r11, r3
	ctx.r[11].s64 = ctx.r[3].s16 as i64;
	// 82442E58: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 82442E5C: 807A001C  lwz r3, 0x1c(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(28 as u32) ) } as u64;
	// 82442E60: 917A0024  stw r11, 0x24(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 82442E64: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82442E68: 388A3EE8  addi r4, r10, 0x3ee8
	ctx.r[4].s64 = ctx.r[10].s64 + 16104;
	// 82442E6C: 48B69EA5  bl 0x82facd10
	ctx.lr = 0x82442E70;
	sub_82FACD10(ctx, base);
	// 82442E70: 7C6B0734  extsh r11, r3
	ctx.r[11].s64 = ctx.r[3].s16 as i64;
	// 82442E74: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 82442E78: 807A001C  lwz r3, 0x1c(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(28 as u32) ) } as u64;
	// 82442E7C: 917A0028  stw r11, 0x28(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 82442E80: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82442E84: 3BCAF818  addi r30, r10, -0x7e8
	ctx.r[30].s64 = ctx.r[10].s64 + -2024;
	// 82442E88: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82442E8C: 48B69E85  bl 0x82facd10
	ctx.lr = 0x82442E90;
	sub_82FACD10(ctx, base);
	// 82442E90: 7C6B0734  extsh r11, r3
	ctx.r[11].s64 = ctx.r[3].s16 as i64;
	// 82442E94: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82442E98: 917A002C  stw r11, 0x2c(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 82442E9C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82442EA0: 489B0B69  bl 0x82df3a08
	ctx.lr = 0x82442EA4;
	sub_82DF3A08(ctx, base);
	// 82442EA4: 807A0014  lwz r3, 0x14(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(20 as u32) ) } as u64;
	// 82442EA8: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 82442EAC: 4BEC253D  bl 0x823053e8
	ctx.lr = 0x82442EB0;
	sub_823053E8(ctx, base);
	// 82442EB0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82442EB4: 4876ADAD  bl 0x82badc60
	ctx.lr = 0x82442EB8;
	sub_82BADC60(ctx, base);
	// 82442EB8: 7C6B0734  extsh r11, r3
	ctx.r[11].s64 = ctx.r[3].s16 as i64;
	// 82442EBC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82442EC0: 917A0024  stw r11, 0x24(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 82442EC4: 489B0565  bl 0x82df3428
	ctx.lr = 0x82442EC8;
	sub_82DF3428(ctx, base);
	// 82442EC8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82442ECC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82442ED0: 489B0B39  bl 0x82df3a08
	ctx.lr = 0x82442ED4;
	sub_82DF3A08(ctx, base);
	// 82442ED4: 807A0014  lwz r3, 0x14(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(20 as u32) ) } as u64;
	// 82442ED8: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 82442EDC: 4BEC250D  bl 0x823053e8
	ctx.lr = 0x82442EE0;
	sub_823053E8(ctx, base);
	// 82442EE0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82442EE4: 4876AD7D  bl 0x82badc60
	ctx.lr = 0x82442EE8;
	sub_82BADC60(ctx, base);
	// 82442EE8: 7C6B0734  extsh r11, r3
	ctx.r[11].s64 = ctx.r[3].s16 as i64;
	// 82442EEC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82442EF0: 917A002C  stw r11, 0x2c(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 82442EF4: 489B0535  bl 0x82df3428
	ctx.lr = 0x82442EF8;
	sub_82DF3428(ctx, base);
	// 82442EF8: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82442EFC: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 82442F00: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82442F04: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82442F08: 81630060  lwz r11, 0x60(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(96 as u32) ) } as u64;
	// 82442F0C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82442F10: 41820020  beq 0x82442f30
	if ctx.cr[0].eq {
	pc = 0x82442F30; continue 'dispatch;
	}
	// 82442F14: 81430064  lwz r10, 0x64(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(100 as u32) ) } as u64;
	// 82442F18: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82442F1C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82442F20: 91430064  stw r10, 0x64(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 82442F24: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82442F28: 91630060  stw r11, 0x60(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82442F2C: 48000008  b 0x82442f34
	pc = 0x82442F34; continue 'dispatch;
	// 82442F30: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 82442F34: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82442F38: 409A001C  bne cr6, 0x82442f54
	if !ctx.cr[6].eq {
	pc = 0x82442F54; continue 'dispatch;
	}
	// 82442F3C: 38A0000E  li r5, 0xe
	ctx.r[5].s64 = 14;
	// 82442F40: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 82442F44: 48A5D71D  bl 0x82ea0660
	ctx.lr = 0x82442F48;
	sub_82EA0660(ctx, base);
	// 82442F48: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82442F4C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82442F50: 419A014C  beq cr6, 0x8244309c
	if ctx.cr[6].eq {
	pc = 0x8244309C; continue 'dispatch;
	}
	// 82442F54: 807A0014  lwz r3, 0x14(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(20 as u32) ) } as u64;
	// 82442F58: 4BEC2491  bl 0x823053e8
	ctx.lr = 0x82442F5C;
	sub_823053E8(ctx, base);
	// 82442F5C: 486A0935  bl 0x82ae3890
	ctx.lr = 0x82442F60;
	sub_82AE3890(ctx, base);
	// 82442F60: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82442F64: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 82442F68: 3B7F0010  addi r27, r31, 0x10
	ctx.r[27].s64 = ctx.r[31].s64 + 16;
	// 82442F6C: 3BBF0004  addi r29, r31, 4
	ctx.r[29].s64 = ctx.r[31].s64 + 4;
	// 82442F70: 3B9F001C  addi r28, r31, 0x1c
	ctx.r[28].s64 = ctx.r[31].s64 + 28;
	// 82442F74: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82442F78: 3B3F002C  addi r25, r31, 0x2c
	ctx.r[25].s64 = ctx.r[31].s64 + 44;
	// 82442F7C: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82442F80: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82442F84: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82442F88: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82442F8C: 93DF0010  stw r30, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 82442F90: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 82442F94: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 82442F98: 93DF001C  stw r30, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 82442F9C: 93DF0020  stw r30, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
	// 82442FA0: 9BDF0028  stb r30, 0x28(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[30].u8 ) };
	// 82442FA4: 9BDF0029  stb r30, 0x29(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(41 as u32), ctx.r[30].u8 ) };
	// 82442FA8: 917F0034  stw r11, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 82442FAC: 93DF002C  stw r30, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[30].u32 ) };
	// 82442FB0: 93DF0030  stw r30, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[30].u32 ) };
	// 82442FB4: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82442FB8: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82442FBC: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 82442FC0: 83CA0010  lwz r30, 0x10(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82442FC4: 7F0BF000  cmpw cr6, r11, r30
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[30].s32, &mut ctx.xer);
	// 82442FC8: 40980024  bge cr6, 0x82442fec
	if !ctx.cr[6].lt {
	pc = 0x82442FEC; continue 'dispatch;
	}
	// 82442FCC: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82442FD0: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82442FD4: 41980008  blt cr6, 0x82442fdc
	if ctx.cr[6].lt {
	pc = 0x82442FDC; continue 'dispatch;
	}
	// 82442FD8: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82442FDC: 38A00030  li r5, 0x30
	ctx.r[5].s64 = 48;
	// 82442FE0: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82442FE4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82442FE8: 48A63811  bl 0x82ea67f8
	ctx.lr = 0x82442FEC;
	sub_82EA67F8(ctx, base);
	// 82442FEC: 93DB0004  stw r30, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82442FF0: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82442FF4: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 82442FF8: 7F0BF000  cmpw cr6, r11, r30
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[30].s32, &mut ctx.xer);
	// 82442FFC: 40980024  bge cr6, 0x82443020
	if !ctx.cr[6].lt {
	pc = 0x82443020; continue 'dispatch;
	}
	// 82443000: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82443004: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82443008: 41980008  blt cr6, 0x82443010
	if ctx.cr[6].lt {
	pc = 0x82443010; continue 'dispatch;
	}
	// 8244300C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82443010: 38A00030  li r5, 0x30
	ctx.r[5].s64 = 48;
	// 82443014: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82443018: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8244301C: 48A637DD  bl 0x82ea67f8
	ctx.lr = 0x82443020;
	sub_82EA67F8(ctx, base);
	// 82443020: 93DD0004  stw r30, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82443024: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82443028: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 8244302C: 7F0BF000  cmpw cr6, r11, r30
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[30].s32, &mut ctx.xer);
	// 82443030: 40980024  bge cr6, 0x82443054
	if !ctx.cr[6].lt {
	pc = 0x82443054; continue 'dispatch;
	}
	// 82443034: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82443038: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8244303C: 41980008  blt cr6, 0x82443044
	if ctx.cr[6].lt {
	pc = 0x82443044; continue 'dispatch;
	}
	// 82443040: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82443044: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82443048: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 8244304C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82443050: 48A637A9  bl 0x82ea67f8
	ctx.lr = 0x82443054;
	sub_82EA67F8(ctx, base);
	// 82443054: 93DC0004  stw r30, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82443058: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 8244305C: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 82443060: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82443064: 83CA0020  lwz r30, 0x20(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82443068: 7F0BF000  cmpw cr6, r11, r30
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[30].s32, &mut ctx.xer);
	// 8244306C: 40980024  bge cr6, 0x82443090
	if !ctx.cr[6].lt {
	pc = 0x82443090; continue 'dispatch;
	}
	// 82443070: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82443074: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82443078: 41980008  blt cr6, 0x82443080
	if ctx.cr[6].lt {
	pc = 0x82443080; continue 'dispatch;
	}
	// 8244307C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82443080: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82443084: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82443088: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 8244308C: 48A6376D  bl 0x82ea67f8
	ctx.lr = 0x82443090;
	sub_82EA67F8(ctx, base);
	// 82443090: 93D90004  stw r30, 4(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82443094: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82443098: 48000008  b 0x824430a0
	pc = 0x824430A0; continue 'dispatch;
	// 8244309C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 824430A0: 387A0030  addi r3, r26, 0x30
	ctx.r[3].s64 = ctx.r[26].s64 + 48;
	// 824430A4: 4BEB40AD  bl 0x822f7150
	ctx.lr = 0x824430A8;
	sub_822F7150(ctx, base);
	// 824430A8: 815A001C  lwz r10, 0x1c(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(28 as u32) ) } as u64;
	// 824430AC: 817A0040  lwz r11, 0x40(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(64 as u32) ) } as u64;
	// 824430B0: 3BDA0038  addi r30, r26, 0x38
	ctx.r[30].s64 = ctx.r[26].s64 + 56;
	// 824430B4: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 824430B8: 83EA0010  lwz r31, 0x10(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 824430BC: 7F0BF800  cmpw cr6, r11, r31
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[31].s32, &mut ctx.xer);
	// 824430C0: 40980024  bge cr6, 0x824430e4
	if !ctx.cr[6].lt {
	pc = 0x824430E4; continue 'dispatch;
	}
	// 824430C4: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824430C8: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824430CC: 41980008  blt cr6, 0x824430d4
	if ctx.cr[6].lt {
	pc = 0x824430D4; continue 'dispatch;
	}
	// 824430D0: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 824430D4: 38A00030  li r5, 0x30
	ctx.r[5].s64 = 48;
	// 824430D8: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 824430DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824430E0: 48A63719  bl 0x82ea67f8
	ctx.lr = 0x824430E4;
	sub_82EA67F8(ctx, base);
	// 824430E4: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 824430E8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 824430EC: 48D650C0  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824430F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x824430F0 size=32
    let mut pc: u32 = 0x824430F0;
    'dispatch: loop {
        match pc {
            0x824430F0 => {
    //   block [0x824430F0..0x82443110)
	// 824430F0: C00300B0  lfs f0, 0xb0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(176 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824430F4: C1A30074  lfs f13, 0x74(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(116 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824430F8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 824430FC: 41980014  blt cr6, 0x82443110
	if ctx.cr[6].lt {
		sub_82443110(ctx, base);
		return;
	}
	// 82443100: C1A30078  lfs f13, 0x78(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(120 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82443104: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82443108: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8244310C: 4C980020  bgelr cr6
	if !ctx.cr[6].lt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82443110(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82443110 size=8
    let mut pc: u32 = 0x82443110;
    'dispatch: loop {
        match pc {
            0x82443110 => {
    //   block [0x82443110..0x82443118)
	// 82443110: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82443114: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82443118(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82443118 size=24
    let mut pc: u32 = 0x82443118;
    'dispatch: loop {
        match pc {
            0x82443118 => {
    //   block [0x82443118..0x82443130)
	// 82443118: D02300A0  stfs f1, 0xa0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 8244311C: 98E300AC  stb r7, 0xac(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(172 as u32), ctx.r[7].u8 ) };
	// 82443120: D04300A4  stfs f2, 0xa4(r3)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82443124: 990300AD  stb r8, 0xad(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(173 as u32), ctx.r[8].u8 ) };
	// 82443128: D06300A8  stfs f3, 0xa8(r3)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 8244312C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82443130(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82443130 size=148
    let mut pc: u32 = 0x82443130;
    'dispatch: loop {
        match pc {
            0x82443130 => {
    //   block [0x82443130..0x824431C4)
	// 82443130: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82443134: 90830010  stw r4, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[4].u32 ) };
	// 82443138: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 8244313C: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 82443140: 392B6910  addi r9, r11, 0x6910
	ctx.r[9].s64 = ctx.r[11].s64 + 26896;
	// 82443144: 39000080  li r8, 0x80
	ctx.r[8].s64 = 128;
	// 82443148: 3CC08204  lis r6, -0x7dfc
	ctx.r[6].s64 = -2113667072;
	// 8244314C: 3CA08201  lis r5, -0x7dff
	ctx.r[5].s64 = -2113863680;
	// 82443150: C00708A4  lfs f0, 0x8a4(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82443154: 3C808201  lis r4, -0x7dff
	ctx.r[4].s64 = -2113863680;
	// 82443158: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8244315C: 394A5D90  addi r10, r10, 0x5d90
	ctx.r[10].s64 = ctx.r[10].s64 + 23952;
	// 82443160: 99630014  stb r11, 0x14(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u8 ) };
	// 82443164: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82443168: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8244316C: C1A6D7BC  lfs f13, -0x2844(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82443170: 91630018  stw r11, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82443174: C185FB2C  lfs f12, -0x4d4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-1236 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82443178: 91630020  stw r11, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 8244317C: C164A2EC  lfs f11, -0x5d14(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(-23828 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82443180: 91630024  stw r11, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 82443184: 99630070  stb r11, 0x70(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(112 as u32), ctx.r[11].u8 ) };
	// 82443188: 9963007C  stb r11, 0x7c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(124 as u32), ctx.r[11].u8 ) };
	// 8244318C: 13E048C7  vcmpequd (lvx128) v31, v0, v9
	tmp.u32 = ctx.r[9].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824431C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824431C8 size=68
    let mut pc: u32 = 0x824431C8;
    'dispatch: loop {
        match pc {
            0x824431C8 => {
    //   block [0x824431C8..0x8244320C)
	// 824431C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824431CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824431D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824431D4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824431D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824431DC: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 824431E0: 548A07FF  clrlwi. r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824431E4: 396B5D90  addi r11, r11, 0x5d90
	ctx.r[11].s64 = ctx.r[11].s64 + 23952;
	// 824431E8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824431EC: 41820008  beq 0x824431f4
	if ctx.cr[0].eq {
	pc = 0x824431F4; continue 'dispatch;
	}
	// 824431F0: 489AF1E9  bl 0x82df23d8
	ctx.lr = 0x824431F4;
	sub_82DF23D8(ctx, base);
	// 824431F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824431F8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 824431FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82443200: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82443204: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82443208: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82443210(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82443210 size=1308
    let mut pc: u32 = 0x82443210;
    'dispatch: loop {
        match pc {
            0x82443210 => {
    //   block [0x82443210..0x8244372C)
	// 82443210: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82443214: 48D64F39  bl 0x831a814c
	ctx.lr = 0x82443218;
	sub_831A8130(ctx, base);
	// 82443218: 3980FF80  li r12, -0x80
	ctx.r[12].s64 = -128;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82443730(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82443730 size=284
    let mut pc: u32 = 0x82443730;
    'dispatch: loop {
        match pc {
            0x82443730 => {
    //   block [0x82443730..0x8244384C)
	// 82443730: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82443734: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82443738: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8244373C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82443740: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82443744: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82443748: 897F0070  lbz r11, 0x70(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 8244374C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82443750: 418200E4  beq 0x82443834
	if ctx.cr[0].eq {
	pc = 0x82443834; continue 'dispatch;
	}
	// 82443754: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82443758: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 8244375C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82443760: 997F0070  stb r11, 0x70(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u8 ) };
	// 82443764: 808A030C  lwz r4, 0x30c(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(780 as u32) ) } as u64;
	// 82443768: 48372E71  bl 0x827b65d8
	ctx.lr = 0x8244376C;
	sub_827B65D8(ctx, base);
	// 8244376C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82443770: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82443774: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82443778: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8244377C: 83CA0008  lwz r30, 8(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82443780: 419A000C  beq cr6, 0x8244378c
	if ctx.cr[6].eq {
	pc = 0x8244378C; continue 'dispatch;
	}
	// 82443784: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82443788: 4BE7D109  bl 0x822c0890
	ctx.lr = 0x8244378C;
	sub_822C0890(ctx, base);
	// 8244378C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82443790: 419A000C  beq cr6, 0x8244379c
	if ctx.cr[6].eq {
	pc = 0x8244379C; continue 'dispatch;
	}
	// 82443794: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82443798: 48A8B069  bl 0x82ece800
	ctx.lr = 0x8244379C;
	sub_82ECE800(ctx, base);
	// 8244379C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824437A0: 809F0020  lwz r4, 0x20(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 824437A4: 48A90475  bl 0x82ed3c18
	ctx.lr = 0x824437A8;
	sub_82ED3C18(ctx, base);
	// 824437A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824437AC: 809F0024  lwz r4, 0x24(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 824437B0: 48A90469  bl 0x82ed3c18
	ctx.lr = 0x824437B4;
	sub_82ED3C18(ctx, base);
	// 824437B4: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 824437B8: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 824437BC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 824437C0: 4182002C  beq 0x824437ec
	if ctx.cr[0].eq {
	pc = 0x824437EC; continue 'dispatch;
	}
	// 824437C4: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 824437C8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 824437CC: 7D6B0735  extsh. r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824437D0: B1630006  sth r11, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 824437D4: 40820018  bne 0x824437ec
	if !ctx.cr[0].eq {
	pc = 0x824437EC; continue 'dispatch;
	}
	// 824437D8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824437DC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 824437E0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824437E4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824437E8: 4E800421  bctrl
	ctx.lr = 0x824437EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824437EC: 807F0024  lwz r3, 0x24(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 824437F0: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 824437F4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 824437F8: 4182002C  beq 0x82443824
	if ctx.cr[0].eq {
	pc = 0x82443824; continue 'dispatch;
	}
	// 824437FC: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 82443800: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82443804: 7D6B0735  extsh. r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82443808: B1630006  sth r11, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 8244380C: 40820018  bne 0x82443824
	if !ctx.cr[0].eq {
	pc = 0x82443824; continue 'dispatch;
	}
	// 82443810: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82443814: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82443818: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8244381C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82443820: 4E800421  bctrl
	ctx.lr = 0x82443824;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82443824: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82443828: 419A000C  beq cr6, 0x82443834
	if ctx.cr[6].eq {
	pc = 0x82443834; continue 'dispatch;
	}
	// 8244382C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82443830: 48A897D9  bl 0x82ecd008
	ctx.lr = 0x82443834;
	sub_82ECD008(ctx, base);
	// 82443834: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82443838: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8244383C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82443840: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82443844: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82443848: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82443850(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82443850 size=1600
    let mut pc: u32 = 0x82443850;
    'dispatch: loop {
        match pc {
            0x82443850 => {
    //   block [0x82443850..0x82443E90)
	// 82443850: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82443854: 48D64909  bl 0x831a815c
	ctx.lr = 0x82443858;
	sub_831A8130(ctx, base);
	// 82443858: DBC1FFB0  stfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 8244385C: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 82443860: 3980FF90  li r12, -0x70
	ctx.r[12].s64 = -112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82443E90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82443E90 size=112
    let mut pc: u32 = 0x82443E90;
    'dispatch: loop {
        match pc {
            0x82443E90 => {
    //   block [0x82443E90..0x82443F00)
	// 82443E90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82443E94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82443E98: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82443E9C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82443EA0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82443EA4: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82443EA8: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82443EAC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82443EB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82443EB4: 80AB6754  lwz r5, 0x6754(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26452 as u32) ) } as u64;
	// 82443EB8: 808A6750  lwz r4, 0x6750(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(26448 as u32) ) } as u64;
	// 82443EBC: 4BEB38E5  bl 0x822f77a0
	ctx.lr = 0x82443EC0;
	sub_822F77A0(ctx, base);
	// 82443EC0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82443EC4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82443EC8: 4BEA0FF9  bl 0x822e4ec0
	ctx.lr = 0x82443ECC;
	sub_822E4EC0(ctx, base);
	// 82443ECC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82443ED0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82443ED4: E89E0000  ld r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 82443ED8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82443EDC: E8630000  ld r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 82443EE0: 480483A9  bl 0x8248c288
	ctx.lr = 0x82443EE4;
	sub_8248C288(ctx, base);
	// 82443EE4: 907F0028  stw r3, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[3].u32 ) };
	// 82443EE8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82443EEC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82443EF0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82443EF4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82443EF8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82443EFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82443F00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82443F00 size=64
    let mut pc: u32 = 0x82443F00;
    'dispatch: loop {
        match pc {
            0x82443F00 => {
    //   block [0x82443F00..0x82443F40)
	// 82443F00: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82443F04: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82443F08: 91440000  stw r10, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82443F0C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82443F10: 892A0019  lbz r9, 0x19(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(25 as u32) ) } as u64;
	// 82443F14: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82443F18: 409A0008  bne cr6, 0x82443f20
	if !ctx.cr[6].eq {
	pc = 0x82443F20; continue 'dispatch;
	}
	// 82443F1C: 908A0004  stw r4, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 82443F20: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82443F24: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82443F28: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82443F2C: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82443F30: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82443F34: 409A000C  bne cr6, 0x82443f40
	if !ctx.cr[6].eq {
		sub_82443F40(ctx, base);
		return;
	}
	// 82443F38: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82443F3C: 48000020  b 0x82443f5c
	sub_82443F58(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82443F40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82443F40 size=24
    let mut pc: u32 = 0x82443F40;
    'dispatch: loop {
        match pc {
            0x82443F40 => {
    //   block [0x82443F40..0x82443F58)
	// 82443F40: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82443F44: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82443F48: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82443F4C: 409A000C  bne cr6, 0x82443f58
	if !ctx.cr[6].eq {
		sub_82443F58(ctx, base);
		return;
	}
	// 82443F50: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82443F54: 48000008  b 0x82443f5c
	sub_82443F58(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82443F58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82443F58 size=16
    let mut pc: u32 = 0x82443F58;
    'dispatch: loop {
        match pc {
            0x82443F58 => {
    //   block [0x82443F58..0x82443F68)
	// 82443F58: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82443F5C: 908B0008  stw r4, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 82443F60: 91640004  stw r11, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82443F64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82443F68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82443F68 size=64
    let mut pc: u32 = 0x82443F68;
    'dispatch: loop {
        match pc {
            0x82443F68 => {
    //   block [0x82443F68..0x82443FA8)
	// 82443F68: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82443F6C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82443F70: 91440008  stw r10, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82443F74: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82443F78: 892A0019  lbz r9, 0x19(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(25 as u32) ) } as u64;
	// 82443F7C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82443F80: 409A0008  bne cr6, 0x82443f88
	if !ctx.cr[6].eq {
	pc = 0x82443F88; continue 'dispatch;
	}
	// 82443F84: 908A0004  stw r4, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 82443F88: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82443F8C: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82443F90: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82443F94: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82443F98: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82443F9C: 409A000C  bne cr6, 0x82443fa8
	if !ctx.cr[6].eq {
		sub_82443FA8(ctx, base);
		return;
	}
	// 82443FA0: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82443FA4: 48000020  b 0x82443fc4
	sub_82443FC0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82443FA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82443FA8 size=24
    let mut pc: u32 = 0x82443FA8;
    'dispatch: loop {
        match pc {
            0x82443FA8 => {
    //   block [0x82443FA8..0x82443FC0)
	// 82443FA8: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82443FAC: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82443FB0: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82443FB4: 409A000C  bne cr6, 0x82443fc0
	if !ctx.cr[6].eq {
		sub_82443FC0(ctx, base);
		return;
	}
	// 82443FB8: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82443FBC: 48000008  b 0x82443fc4
	sub_82443FC0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82443FC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82443FC0 size=16
    let mut pc: u32 = 0x82443FC0;
    'dispatch: loop {
        match pc {
            0x82443FC0 => {
    //   block [0x82443FC0..0x82443FD0)
	// 82443FC0: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82443FC4: 908B0000  stw r4, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 82443FC8: 91640004  stw r11, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82443FCC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82443FD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82443FD0 size=196
    let mut pc: u32 = 0x82443FD0;
    'dispatch: loop {
        match pc {
            0x82443FD0 => {
    //   block [0x82443FD0..0x82444094)
	// 82443FD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82443FD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82443FD8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82443FDC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82443FE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82443FE4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82443FE8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82443FEC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82443FF0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82443FF4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82443FF8: 4BE7C941  bl 0x822c0938
	ctx.lr = 0x82443FFC;
	sub_822C0938(ctx, base);
	// 82443FFC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82444000: 41820028  beq 0x82444028
	if ctx.cr[0].eq {
	pc = 0x82444028; continue 'dispatch;
	}
	// 82444004: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82444008: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8244400C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82444010: 392B5D98  addi r9, r11, 0x5d98
	ctx.r[9].s64 = ctx.r[11].s64 + 23960;
	// 82444014: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82444018: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8244401C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82444020: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82444024: 48000008  b 0x8244402c
	pc = 0x8244402C; continue 'dispatch;
	// 82444028: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8244402C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82444030: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82444034: 409A0044  bne cr6, 0x82444078
	if !ctx.cr[6].eq {
	pc = 0x82444078; continue 'dispatch;
	}
	// 82444038: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8244403C: 419A001C  beq cr6, 0x82444058
	if ctx.cr[6].eq {
	pc = 0x82444058; continue 'dispatch;
	}
	// 82444040: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82444044: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82444048: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8244404C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82444050: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82444054: 4E800421  bctrl
	ctx.lr = 0x82444058;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82444058: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 8244405C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82444060: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82444064: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82444068: 816B2478  lwz r11, 0x2478(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9336 as u32) ) } as u64;
	// 8244406C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82444070: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82444074: 4BE7BF8D  bl 0x822c0000
	ctx.lr = 0x82444078;
	sub_822C0000(ctx, base);
	// 82444078: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8244407C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82444080: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82444084: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82444088: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8244408C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82444090: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82444098(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82444098 size=120
    let mut pc: u32 = 0x82444098;
    'dispatch: loop {
        match pc {
            0x82444098 => {
    //   block [0x82444098..0x82444110)
	// 82444098: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8244409C: 48D640D1  bl 0x831a816c
	ctx.lr = 0x824440A0;
	sub_831A8130(ctx, base);
	// 824440A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824440A4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824440A8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 824440AC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 824440B0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 824440B4: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 824440B8: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 824440BC: 38600070  li r3, 0x70
	ctx.r[3].s64 = 112;
	// 824440C0: 489AE329  bl 0x82df23e8
	ctx.lr = 0x824440C4;
	sub_82DF23E8(ctx, base);
	// 824440C4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 824440C8: 41820014  beq 0x824440dc
	if ctx.cr[0].eq {
	pc = 0x824440DC; continue 'dispatch;
	}
	// 824440CC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 824440D0: 4870F499  bl 0x82b53568
	ctx.lr = 0x824440D4;
	sub_82B53568(ctx, base);
	// 824440D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824440D8: 48000008  b 0x824440e0
	pc = 0x824440E0; continue 'dispatch;
	// 824440DC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 824440E0: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 824440E4: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 824440E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 824440EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824440F0: 4BFFFEE1  bl 0x82443fd0
	ctx.lr = 0x824440F4;
	sub_82443FD0(ctx, base);
	// 824440F4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 824440F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 824440FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82444100: 4BE7BF01  bl 0x822c0000
	ctx.lr = 0x82444104;
	sub_822C0000(ctx, base);
	// 82444104: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82444108: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8244410C: 48D640B0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82444110(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82444110 size=376
    let mut pc: u32 = 0x82444110;
    'dispatch: loop {
        match pc {
            0x82444110 => {
    //   block [0x82444110..0x82444288)
	// 82444110: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82444114: 48D6404D  bl 0x831a8160
	ctx.lr = 0x82444118;
	sub_831A8130(ctx, base);
	// 82444118: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8244411C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82444120: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82444124: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82444128: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 8244412C: 480223AD  bl 0x824664d8
	ctx.lr = 0x82444130;
	sub_824664D8(ctx, base);
	// 82444130: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82444134: 13E0E8C7  vcmpequd (lvx128) v31, v0, v29
	tmp.u32 = ctx.r[29].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82444138: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 8244413C: 90610064  stw r3, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[3].u32 ) };
	// 82444140: 3B8B2770  addi r28, r11, 0x2770
	ctx.r[28].s64 = ctx.r[11].s64 + 10096;
	// 82444144: 807F00D0  lwz r3, 0xd0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 82444148: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 8244414C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82444150: 93610068  stw r27, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[27].u32 ) };
	// 82444154: 13C0E0C7  vcmpequd (lvx128) v30, v0, v28
	tmp.u32 = ctx.r[28].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


