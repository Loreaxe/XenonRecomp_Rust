pub fn sub_828DA410(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DA410 size=156
    let mut pc: u32 = 0x828DA410;
    'dispatch: loop {
        match pc {
            0x828DA410 => {
    //   block [0x828DA410..0x828DA4AC)
	// 828DA410: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DA414: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DA418: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828DA41C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DA420: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DA424: 2B050001  cmplwi cr6, r5, 1
	ctx.cr[6].compare_u32(ctx.r[5].u32, 1 as u32, &mut ctx.xer);
	// 828DA428: 41980040  blt cr6, 0x828da468
	if ctx.cr[6].lt {
	pc = 0x828DA468; continue 'dispatch;
	}
	// 828DA42C: 419A0030  beq cr6, 0x828da45c
	if ctx.cr[6].eq {
	pc = 0x828DA45C; continue 'dispatch;
	}
	// 828DA430: 2B050003  cmplwi cr6, r5, 3
	ctx.cr[6].compare_u32(ctx.r[5].u32, 3 as u32, &mut ctx.xer);
	// 828DA434: 4198001C  blt cr6, 0x828da450
	if ctx.cr[6].lt {
	pc = 0x828DA450; continue 'dispatch;
	}
	// 828DA438: 409A0050  bne cr6, 0x828da488
	if !ctx.cr[6].eq {
	pc = 0x828DA488; continue 'dispatch;
	}
	// 828DA43C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828DA440: 38ABFC38  addi r5, r11, -0x3c8
	ctx.r[5].s64 = ctx.r[11].s64 + -968;
	// 828DA444: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DA448: 4BC37AF1  bl 0x82511f38
	ctx.lr = 0x828DA44C;
	sub_82511F38(ctx, base);
	// 828DA44C: 48000048  b 0x828da494
	pc = 0x828DA494; continue 'dispatch;
	// 828DA450: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828DA454: 38ABFC24  addi r5, r11, -0x3dc
	ctx.r[5].s64 = ctx.r[11].s64 + -988;
	// 828DA458: 4BFFFFEC  b 0x828da444
	pc = 0x828DA444; continue 'dispatch;
	// 828DA45C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828DA460: 38ABFC14  addi r5, r11, -0x3ec
	ctx.r[5].s64 = ctx.r[11].s64 + -1004;
	// 828DA464: 4BFFFFE0  b 0x828da444
	pc = 0x828DA444; continue 'dispatch;
	// 828DA468: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828DA46C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DA470: 38ABFC00  addi r5, r11, -0x400
	ctx.r[5].s64 = ctx.r[11].s64 + -1024;
	// 828DA474: 4BC37D05  bl 0x82512178
	ctx.lr = 0x828DA478;
	sub_82512178(ctx, base);
	// 828DA478: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828DA47C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DA480: 419A0008  beq cr6, 0x828da488
	if ctx.cr[6].eq {
	pc = 0x828DA488; continue 'dispatch;
	}
	// 828DA484: 4B9E640D  bl 0x822c0890
	ctx.lr = 0x828DA488;
	sub_822C0890(ctx, base);
	// 828DA488: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DA48C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828DA490: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828DA494: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DA498: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828DA49C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DA4A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DA4A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828DA4A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DA4B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828DA4B0 size=600
    let mut pc: u32 = 0x828DA4B0;
    'dispatch: loop {
        match pc {
            0x828DA4B0 => {
    //   block [0x828DA4B0..0x828DA708)
	// 828DA4B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DA4B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DA4B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828DA4BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828DA4C0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DA4C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DA4C8: 54AB063F  clrlwi. r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DA4CC: 418201F0  beq 0x828da6bc
	if ctx.cr[0].eq {
	pc = 0x828DA6BC; continue 'dispatch;
	}
	// 828DA4D0: 2B040001  cmplwi cr6, r4, 1
	ctx.cr[6].compare_u32(ctx.r[4].u32, 1 as u32, &mut ctx.xer);
	// 828DA4D4: 41980148  blt cr6, 0x828da61c
	if ctx.cr[6].lt {
	pc = 0x828DA61C; continue 'dispatch;
	}
	// 828DA4D8: 419A00A8  beq cr6, 0x828da580
	if ctx.cr[6].eq {
	pc = 0x828DA580; continue 'dispatch;
	}
	// 828DA4DC: 2B040003  cmplwi cr6, r4, 3
	ctx.cr[6].compare_u32(ctx.r[4].u32, 3 as u32, &mut ctx.xer);
	// 828DA4E0: 40980210  bge cr6, 0x828da6f0
	if !ctx.cr[6].lt {
	pc = 0x828DA6F0; continue 'dispatch;
	}
	// 828DA4E4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828DA4E8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828DA4EC: 388BFC88  addi r4, r11, -0x378
	ctx.r[4].s64 = ctx.r[11].s64 + -888;
	// 828DA4F0: 48519519  bl 0x82df3a08
	ctx.lr = 0x828DA4F4;
	sub_82DF3A08(ctx, base);
	// 828DA4F4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828DA4F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DA4FC: 388BFC80  addi r4, r11, -0x380
	ctx.r[4].s64 = ctx.r[11].s64 + -896;
	// 828DA500: 48519509  bl 0x82df3a08
	ctx.lr = 0x828DA504;
	sub_82DF3A08(ctx, base);
	// 828DA504: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DA508: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828DA50C: 4BF120BD  bl 0x827ec5c8
	ctx.lr = 0x828DA510;
	sub_827EC5C8(ctx, base);
	// 828DA510: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828DA514: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828DA518: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828DA51C: 3BC10054  addi r30, r1, 0x54
	ctx.r[30].s64 = ctx.r[1].s64 + 84;
	// 828DA520: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DA524: 4853AB0D  bl 0x82e15030
	ctx.lr = 0x828DA528;
	sub_82E15030(ctx, base);
	// 828DA528: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828DA52C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DA530: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DA534: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828DA538: 38E00007  li r7, 7
	ctx.r[7].s64 = 7;
	// 828DA53C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828DA540: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828DA544: 4BF11CC5  bl 0x827ec208
	ctx.lr = 0x828DA548;
	sub_827EC208(ctx, base);
	// 828DA548: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828DA54C: 907F0390  stw r3, 0x390(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(912 as u32), ctx.r[3].u32 ) };
	// 828DA550: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DA554: 419A000C  beq cr6, 0x828da560
	if ctx.cr[6].eq {
	pc = 0x828DA560; continue 'dispatch;
	}
	// 828DA558: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828DA55C: 4B9E6335  bl 0x822c0890
	ctx.lr = 0x828DA560;
	sub_822C0890(ctx, base);
	// 828DA560: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828DA564: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DA568: 419A0008  beq cr6, 0x828da570
	if ctx.cr[6].eq {
	pc = 0x828DA570; continue 'dispatch;
	}
	// 828DA56C: 4B9E6325  bl 0x822c0890
	ctx.lr = 0x828DA570;
	sub_822C0890(ctx, base);
	// 828DA570: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DA574: 48518EB5  bl 0x82df3428
	ctx.lr = 0x828DA578;
	sub_82DF3428(ctx, base);
	// 828DA578: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828DA57C: 48000138  b 0x828da6b4
	pc = 0x828DA6B4; continue 'dispatch;
	// 828DA580: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828DA584: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828DA588: 388BFC68  addi r4, r11, -0x398
	ctx.r[4].s64 = ctx.r[11].s64 + -920;
	// 828DA58C: 4851947D  bl 0x82df3a08
	ctx.lr = 0x828DA590;
	sub_82DF3A08(ctx, base);
	// 828DA590: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828DA594: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DA598: 388BFC80  addi r4, r11, -0x380
	ctx.r[4].s64 = ctx.r[11].s64 + -896;
	// 828DA59C: 4851946D  bl 0x82df3a08
	ctx.lr = 0x828DA5A0;
	sub_82DF3A08(ctx, base);
	// 828DA5A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DA5A4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828DA5A8: 4BF12021  bl 0x827ec5c8
	ctx.lr = 0x828DA5AC;
	sub_827EC5C8(ctx, base);
	// 828DA5AC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828DA5B0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828DA5B4: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 828DA5B8: 3BC1005C  addi r30, r1, 0x5c
	ctx.r[30].s64 = ctx.r[1].s64 + 92;
	// 828DA5BC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DA5C0: 4853AA71  bl 0x82e15030
	ctx.lr = 0x828DA5C4;
	sub_82E15030(ctx, base);
	// 828DA5C4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828DA5C8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DA5CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DA5D0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828DA5D4: 38E00007  li r7, 7
	ctx.r[7].s64 = 7;
	// 828DA5D8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828DA5DC: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828DA5E0: 4BF11C29  bl 0x827ec208
	ctx.lr = 0x828DA5E4;
	sub_827EC208(ctx, base);
	// 828DA5E4: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 828DA5E8: 907F0390  stw r3, 0x390(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(912 as u32), ctx.r[3].u32 ) };
	// 828DA5EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DA5F0: 419A000C  beq cr6, 0x828da5fc
	if ctx.cr[6].eq {
	pc = 0x828DA5FC; continue 'dispatch;
	}
	// 828DA5F4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828DA5F8: 4B9E6299  bl 0x822c0890
	ctx.lr = 0x828DA5FC;
	sub_822C0890(ctx, base);
	// 828DA5FC: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 828DA600: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DA604: 419A0008  beq cr6, 0x828da60c
	if ctx.cr[6].eq {
	pc = 0x828DA60C; continue 'dispatch;
	}
	// 828DA608: 4B9E6289  bl 0x822c0890
	ctx.lr = 0x828DA60C;
	sub_822C0890(ctx, base);
	// 828DA60C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DA610: 48518E19  bl 0x82df3428
	ctx.lr = 0x828DA614;
	sub_82DF3428(ctx, base);
	// 828DA614: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828DA618: 4800009C  b 0x828da6b4
	pc = 0x828DA6B4; continue 'dispatch;
	// 828DA61C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828DA620: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 828DA624: 388BFC50  addi r4, r11, -0x3b0
	ctx.r[4].s64 = ctx.r[11].s64 + -944;
	// 828DA628: 485193E1  bl 0x82df3a08
	ctx.lr = 0x828DA62C;
	sub_82DF3A08(ctx, base);
	// 828DA62C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828DA630: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DA634: 388BFC80  addi r4, r11, -0x380
	ctx.r[4].s64 = ctx.r[11].s64 + -896;
	// 828DA638: 485193D1  bl 0x82df3a08
	ctx.lr = 0x828DA63C;
	sub_82DF3A08(ctx, base);
	// 828DA63C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DA640: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 828DA644: 4BF11F85  bl 0x827ec5c8
	ctx.lr = 0x828DA648;
	sub_827EC5C8(ctx, base);
	// 828DA648: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828DA64C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828DA650: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 828DA654: 3BC10064  addi r30, r1, 0x64
	ctx.r[30].s64 = ctx.r[1].s64 + 100;
	// 828DA658: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DA65C: 4853A9D5  bl 0x82e15030
	ctx.lr = 0x828DA660;
	sub_82E15030(ctx, base);
	// 828DA660: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828DA664: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DA668: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DA66C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828DA670: 38E00007  li r7, 7
	ctx.r[7].s64 = 7;
	// 828DA674: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828DA678: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828DA67C: 4BF11B8D  bl 0x827ec208
	ctx.lr = 0x828DA680;
	sub_827EC208(ctx, base);
	// 828DA680: 8161008C  lwz r11, 0x8c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 828DA684: 907F0390  stw r3, 0x390(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(912 as u32), ctx.r[3].u32 ) };
	// 828DA688: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DA68C: 419A000C  beq cr6, 0x828da698
	if ctx.cr[6].eq {
	pc = 0x828DA698; continue 'dispatch;
	}
	// 828DA690: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828DA694: 4B9E61FD  bl 0x822c0890
	ctx.lr = 0x828DA698;
	sub_822C0890(ctx, base);
	// 828DA698: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 828DA69C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DA6A0: 419A0008  beq cr6, 0x828da6a8
	if ctx.cr[6].eq {
	pc = 0x828DA6A8; continue 'dispatch;
	}
	// 828DA6A4: 4B9E61ED  bl 0x822c0890
	ctx.lr = 0x828DA6A8;
	sub_822C0890(ctx, base);
	// 828DA6A8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DA6AC: 48518D7D  bl 0x82df3428
	ctx.lr = 0x828DA6B0;
	sub_82DF3428(ctx, base);
	// 828DA6B0: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 828DA6B4: 48518D75  bl 0x82df3428
	ctx.lr = 0x828DA6B8;
	sub_82DF3428(ctx, base);
	// 828DA6B8: 48000038  b 0x828da6f0
	pc = 0x828DA6F0; continue 'dispatch;
	// 828DA6BC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DA6C0: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 828DA6C4: 4BC34E05  bl 0x8250f4c8
	ctx.lr = 0x828DA6C8;
	sub_8250F4C8(ctx, base);
	// 828DA6C8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DA6CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DA6D0: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 828DA6D4: 409A0008  bne cr6, 0x828da6dc
	if !ctx.cr[6].eq {
	pc = 0x828DA6DC; continue 'dispatch;
	}
	// 828DA6D8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828DA6DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DA6E0: 80BF0390  lwz r5, 0x390(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(912 as u32) ) } as u64;
	// 828DA6E4: 4BF11BAD  bl 0x827ec290
	ctx.lr = 0x828DA6E8;
	sub_827EC290(ctx, base);
	// 828DA6E8: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 828DA6EC: 485175A5  bl 0x82df1c90
	ctx.lr = 0x828DA6F0;
	sub_82DF1C90(ctx, base);
	// 828DA6F0: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828DA6F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DA6F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DA6FC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828DA700: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828DA704: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DA708(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DA708 size=404
    let mut pc: u32 = 0x828DA708;
    'dispatch: loop {
        match pc {
            0x828DA708 => {
    //   block [0x828DA708..0x828DA89C)
	// 828DA708: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DA70C: 488CDA5D  bl 0x831a8168
	ctx.lr = 0x828DA710;
	sub_831A8130(ctx, base);
	// 828DA710: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DA714: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DA718: 817F0394  lwz r11, 0x394(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(916 as u32) ) } as u64;
	// 828DA71C: 7F0B2000  cmpw cr6, r11, r4
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[4].s32, &mut ctx.xer);
	// 828DA720: 419A0174  beq cr6, 0x828da894
	if ctx.cr[6].eq {
	pc = 0x828DA894; continue 'dispatch;
	}
	// 828DA724: 909F0394  stw r4, 0x394(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(916 as u32), ctx.r[4].u32 ) };
	// 828DA728: 4802FD09  bl 0x8290a430
	ctx.lr = 0x828DA72C;
	sub_8290A430(ctx, base);
	// 828DA72C: 809F0398  lwz r4, 0x398(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(920 as u32) ) } as u64;
	// 828DA730: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828DA734: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828DA738: 419A0008  beq cr6, 0x828da740
	if ctx.cr[6].eq {
	pc = 0x828DA740; continue 'dispatch;
	}
	// 828DA73C: 4826B5ED  bl 0x82b45d28
	ctx.lr = 0x828DA740;
	sub_82B45D28(ctx, base);
	// 828DA740: 817F0394  lwz r11, 0x394(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(916 as u32) ) } as u64;
	// 828DA744: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 828DA748: 419A00AC  beq cr6, 0x828da7f4
	if ctx.cr[6].eq {
	pc = 0x828DA7F4; continue 'dispatch;
	}
	// 828DA74C: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 828DA750: 409A0144  bne cr6, 0x828da894
	if !ctx.cr[6].eq {
	pc = 0x828DA894; continue 'dispatch;
	}
	// 828DA754: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828DA758: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DA75C: 388BC604  addi r4, r11, -0x39fc
	ctx.r[4].s64 = ctx.r[11].s64 + -14844;
	// 828DA760: 485192A9  bl 0x82df3a08
	ctx.lr = 0x828DA764;
	sub_82DF3A08(ctx, base);
	// 828DA764: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DA768: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828DA76C: 4BF11E5D  bl 0x827ec5c8
	ctx.lr = 0x828DA770;
	sub_827EC5C8(ctx, base);
	// 828DA770: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828DA774: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DA778: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DA77C: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DA780: 4BC34D49  bl 0x8250f4c8
	ctx.lr = 0x828DA784;
	sub_8250F4C8(ctx, base);
	// 828DA784: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DA788: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DA78C: 3BCBFFFC  addi r30, r11, -4
	ctx.r[30].s64 = ctx.r[11].s64 + -4;
	// 828DA790: 409A0008  bne cr6, 0x828da798
	if !ctx.cr[6].eq {
	pc = 0x828DA798; continue 'dispatch;
	}
	// 828DA794: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828DA798: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828DA79C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828DA7A0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DA7A4: 4853A88D  bl 0x82e15030
	ctx.lr = 0x828DA7A8;
	sub_82E15030(ctx, base);
	// 828DA7A8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828DA7AC: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828DA7B0: 38ABFC24  addi r5, r11, -0x3dc
	ctx.r[5].s64 = ctx.r[11].s64 + -988;
	// 828DA7B4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DA7B8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828DA7BC: 4826BBF5  bl 0x82b463b0
	ctx.lr = 0x828DA7C0;
	sub_82B463B0(ctx, base);
	// 828DA7C0: 907F0398  stw r3, 0x398(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(920 as u32), ctx.r[3].u32 ) };
	// 828DA7C4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DA7C8: 485174C9  bl 0x82df1c90
	ctx.lr = 0x828DA7CC;
	sub_82DF1C90(ctx, base);
	// 828DA7CC: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828DA7D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DA7D4: 419A0008  beq cr6, 0x828da7dc
	if ctx.cr[6].eq {
	pc = 0x828DA7DC; continue 'dispatch;
	}
	// 828DA7D8: 4B9E60B9  bl 0x822c0890
	ctx.lr = 0x828DA7DC;
	sub_822C0890(ctx, base);
	// 828DA7DC: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828DA7E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DA7E4: 419A0008  beq cr6, 0x828da7ec
	if ctx.cr[6].eq {
	pc = 0x828DA7EC; continue 'dispatch;
	}
	// 828DA7E8: 4B9E60A9  bl 0x822c0890
	ctx.lr = 0x828DA7EC;
	sub_822C0890(ctx, base);
	// 828DA7EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DA7F0: 480000A0  b 0x828da890
	pc = 0x828DA890; continue 'dispatch;
	// 828DA7F4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828DA7F8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828DA7FC: 388BC604  addi r4, r11, -0x39fc
	ctx.r[4].s64 = ctx.r[11].s64 + -14844;
	// 828DA800: 48519209  bl 0x82df3a08
	ctx.lr = 0x828DA804;
	sub_82DF3A08(ctx, base);
	// 828DA804: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DA808: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828DA80C: 4BF11DBD  bl 0x827ec5c8
	ctx.lr = 0x828DA810;
	sub_827EC5C8(ctx, base);
	// 828DA810: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828DA814: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DA818: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828DA81C: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DA820: 4BC34CA9  bl 0x8250f4c8
	ctx.lr = 0x828DA824;
	sub_8250F4C8(ctx, base);
	// 828DA824: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DA828: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DA82C: 3BCBFFFC  addi r30, r11, -4
	ctx.r[30].s64 = ctx.r[11].s64 + -4;
	// 828DA830: 409A0008  bne cr6, 0x828da838
	if !ctx.cr[6].eq {
	pc = 0x828DA838; continue 'dispatch;
	}
	// 828DA834: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828DA838: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 828DA83C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828DA840: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 828DA844: 4853A7ED  bl 0x82e15030
	ctx.lr = 0x828DA848;
	sub_82E15030(ctx, base);
	// 828DA848: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828DA84C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828DA850: 38ABFC14  addi r5, r11, -0x3ec
	ctx.r[5].s64 = ctx.r[11].s64 + -1004;
	// 828DA854: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DA858: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828DA85C: 4826BB55  bl 0x82b463b0
	ctx.lr = 0x828DA860;
	sub_82B463B0(ctx, base);
	// 828DA860: 907F0398  stw r3, 0x398(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(920 as u32), ctx.r[3].u32 ) };
	// 828DA864: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828DA868: 48517429  bl 0x82df1c90
	ctx.lr = 0x828DA86C;
	sub_82DF1C90(ctx, base);
	// 828DA86C: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 828DA870: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DA874: 419A0008  beq cr6, 0x828da87c
	if ctx.cr[6].eq {
	pc = 0x828DA87C; continue 'dispatch;
	}
	// 828DA878: 4B9E6019  bl 0x822c0890
	ctx.lr = 0x828DA87C;
	sub_822C0890(ctx, base);
	// 828DA87C: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 828DA880: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DA884: 419A0008  beq cr6, 0x828da88c
	if ctx.cr[6].eq {
	pc = 0x828DA88C; continue 'dispatch;
	}
	// 828DA888: 4B9E6009  bl 0x822c0890
	ctx.lr = 0x828DA88C;
	sub_822C0890(ctx, base);
	// 828DA88C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828DA890: 48518B99  bl 0x82df3428
	ctx.lr = 0x828DA894;
	sub_82DF3428(ctx, base);
	// 828DA894: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828DA898: 488CD920  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DA8A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828DA8A0 size=212
    let mut pc: u32 = 0x828DA8A0;
    'dispatch: loop {
        match pc {
            0x828DA8A0 => {
    //   block [0x828DA8A0..0x828DA974)
	// 828DA8A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DA8A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DA8A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828DA8AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828DA8B0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DA8B4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828DA8B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DA8BC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DA8C0: 388B1EDC  addi r4, r11, 0x1edc
	ctx.r[4].s64 = ctx.r[11].s64 + 7900;
	// 828DA8C4: 48519145  bl 0x82df3a08
	ctx.lr = 0x828DA8C8;
	sub_82DF3A08(ctx, base);
	// 828DA8C8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828DA8CC: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 828DA8D0: 388B1360  addi r4, r11, 0x1360
	ctx.r[4].s64 = ctx.r[11].s64 + 4960;
	// 828DA8D4: 48519135  bl 0x82df3a08
	ctx.lr = 0x828DA8D8;
	sub_82DF3A08(ctx, base);
	// 828DA8D8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828DA8DC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828DA8E0: 3D208203  lis r9, -0x7dfd
	ctx.r[9].s64 = -2113732608;
	// 828DA8E4: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 828DA8E8: 38E00007  li r7, 7
	ctx.r[7].s64 = 7;
	// 828DA8EC: C18B964C  lfs f12, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828DA8F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DA8F4: C00A08A4  lfs f0, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828DA8F8: 90E10068  stw r7, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[7].u32 ) };
	// 828DA8FC: C169DAA0  lfs f11, -0x2560(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-9568 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 828DA900: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DA904: C1A831D8  lfs f13, 0x31d8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12760 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828DA908: 3BC10060  addi r30, r1, 0x60
	ctx.r[30].s64 = ctx.r[1].s64 + 96;
	// 828DA90C: D181006C  stfs f12, 0x6c(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 828DA910: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 828DA914: D1810074  stfs f12, 0x74(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 828DA918: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 828DA91C: D161007C  stfs f11, 0x7c(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 828DA920: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 828DA924: D1A10084  stfs f13, 0x84(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 828DA928: D1A10088  stfs f13, 0x88(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 828DA92C: D1A1008C  stfs f13, 0x8c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 828DA930: 4BF11C99  bl 0x827ec5c8
	ctx.lr = 0x828DA934;
	sub_827EC5C8(ctx, base);
	// 828DA934: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DA938: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DA93C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828DA940: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 828DA944: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828DA948: 4BF11EF9  bl 0x827ec840
	ctx.lr = 0x828DA94C;
	sub_827EC840(ctx, base);
	// 828DA94C: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 828DA950: 48518AD9  bl 0x82df3428
	ctx.lr = 0x828DA954;
	sub_82DF3428(ctx, base);
	// 828DA954: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DA958: 48518AD1  bl 0x82df3428
	ctx.lr = 0x828DA95C;
	sub_82DF3428(ctx, base);
	// 828DA95C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828DA960: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DA964: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DA968: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828DA96C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828DA970: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DA978(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828DA978 size=12
    let mut pc: u32 = 0x828DA978;
    'dispatch: loop {
        match pc {
            0x828DA978 => {
    //   block [0x828DA978..0x828DA984)
	// 828DA978: 81640018  lwz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 828DA97C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 828DA980: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DA984(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828DA984 size=8
    let mut pc: u32 = 0x828DA984;
    'dispatch: loop {
        match pc {
            0x828DA984 => {
    //   block [0x828DA984..0x828DA98C)
	// 828DA984: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828DA988: 4BFFFD80  b 0x828da708
	sub_828DA708(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DA98C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828DA98C size=4
    let mut pc: u32 = 0x828DA98C;
    'dispatch: loop {
        match pc {
            0x828DA98C => {
    //   block [0x828DA98C..0x828DA990)
	// 828DA98C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DA990(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828DA990 size=236
    let mut pc: u32 = 0x828DA990;
    'dispatch: loop {
        match pc {
            0x828DA990 => {
    //   block [0x828DA990..0x828DAA7C)
	// 828DA990: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DA994: 488CD7D5  bl 0x831a8168
	ctx.lr = 0x828DA998;
	sub_831A8130(ctx, base);
	// 828DA998: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 828DA99C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DA9A0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DA9A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DA9A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DA9AC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828DA9B0: 808B0B24  lwz r4, 0xb24(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2852 as u32) ) } as u64;
	// 828DA9B4: 48519055  bl 0x82df3a08
	ctx.lr = 0x828DA9B8;
	sub_82DF3A08(ctx, base);
	// 828DA9B8: 3BDF00FC  addi r30, r31, 0xfc
	ctx.r[30].s64 = ctx.r[31].s64 + 252;
	// 828DA9BC: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 828DA9C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DA9C4: 4857FD0D  bl 0x82e5a6d0
	ctx.lr = 0x828DA9C8;
	sub_82E5A6D0(ctx, base);
	// 828DA9C8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828DA9CC: 4851893D  bl 0x82df3308
	ctx.lr = 0x828DA9D0;
	sub_82DF3308(ctx, base);
	// 828DA9D0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828DA9D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DA9D8: 48518A51  bl 0x82df3428
	ctx.lr = 0x828DA9DC;
	sub_82DF3428(ctx, base);
	// 828DA9DC: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DA9E0: 41820090  beq 0x828daa70
	if ctx.cr[0].eq {
	pc = 0x828DAA70; continue 'dispatch;
	}
	// 828DA9E4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DA9E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DA9EC: 816B01A4  lwz r11, 0x1a4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(420 as u32) ) } as u64;
	// 828DA9F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828DA9F4: 4E800421  bctrl
	ctx.lr = 0x828DA9F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DA9F8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828DA9FC: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DAA00: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828DAA04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DAA08: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828DAA0C: 816A0080  lwz r11, 0x80(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(128 as u32) ) } as u64;
	// 828DAA10: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828DAA14: 4E800421  bctrl
	ctx.lr = 0x828DAA18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DAA18: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828DAA1C: 387C0108  addi r3, r28, 0x108
	ctx.r[3].s64 = ctx.r[28].s64 + 264;
	// 828DAA20: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 828DAA24: 4807D715  bl 0x82958138
	ctx.lr = 0x828DAA28;
	sub_82958138(ctx, base);
	// 828DAA28: FF1F0800  fcmpu cr6, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[1].f64);
	// 828DAA2C: 40980044  bge cr6, 0x828daa70
	if !ctx.cr[6].lt {
	pc = 0x828DAA70; continue 'dispatch;
	}
	// 828DAA30: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DAA34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DAA38: 808B80A0  lwz r4, -0x7f60(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-32608 as u32) ) } as u64;
	// 828DAA3C: 48518FCD  bl 0x82df3a08
	ctx.lr = 0x828DAA40;
	sub_82DF3A08(ctx, base);
	// 828DAA40: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828DAA44: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828DAA48: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DAA4C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DAA50: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828DAA54: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828DAA58: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828DAA5C: 48583F05  bl 0x82e5e960
	ctx.lr = 0x828DAA60;
	sub_82E5E960(ctx, base);
	// 828DAA60: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828DAA64: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DAA68: 419A0008  beq cr6, 0x828daa70
	if ctx.cr[6].eq {
	pc = 0x828DAA70; continue 'dispatch;
	}
	// 828DAA6C: 4B9E5E25  bl 0x822c0890
	ctx.lr = 0x828DAA70;
	sub_822C0890(ctx, base);
	// 828DAA70: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828DAA74: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 828DAA78: 488CD740  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DAA80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DAA80 size=232
    let mut pc: u32 = 0x828DAA80;
    'dispatch: loop {
        match pc {
            0x828DAA80 => {
    //   block [0x828DAA80..0x828DAB68)
	// 828DAA80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DAA84: 488CD6E1  bl 0x831a8164
	ctx.lr = 0x828DAA88;
	sub_831A8130(ctx, base);
	// 828DAA88: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DAA8C: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828DAA90: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828DAA94: 3BAB1460  addi r29, r11, 0x1460
	ctx.r[29].s64 = ctx.r[11].s64 + 5216;
	// 828DAA98: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828DAA9C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828DAAA0: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 828DAAA4: 3B6B0F7C  addi r27, r11, 0xf7c
	ctx.r[27].s64 = ctx.r[11].s64 + 3964;
	// 828DAAA8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828DAAAC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828DAAB0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828DAAB4: 488CE025  bl 0x831a8ad8
	ctx.lr = 0x828DAAB8;
	sub_831A8AD8(ctx, base);
	// 828DAAB8: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 828DAABC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DAAC0: 48518F49  bl 0x82df3a08
	ctx.lr = 0x828DAAC4;
	sub_82DF3A08(ctx, base);
	// 828DAAC4: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DAAC8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828DAACC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DAAD0: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DAAD4: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 828DAAD8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828DAADC: 4E800421  bctrl
	ctx.lr = 0x828DAAE0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DAAE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DAAE4: 48518945  bl 0x82df3428
	ctx.lr = 0x828DAAE8;
	sub_82DF3428(ctx, base);
	// 828DAAE8: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828DAAEC: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828DAAF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DAAF4: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828DAAF8: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 828DAAFC: 419A0024  beq cr6, 0x828dab20
	if ctx.cr[6].eq {
	pc = 0x828DAB20; continue 'dispatch;
	}
	// 828DAB00: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828DAB04: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828DAB08: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DAB0C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828DAB10: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828DAB14: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828DAB18: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DAB1C: 4082FFE8  bne 0x828dab04
	if !ctx.cr[0].eq {
	pc = 0x828DAB04; continue 'dispatch;
	}
	// 828DAB20: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828DAB24: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DAB28: 48004789  bl 0x828df2b0
	ctx.lr = 0x828DAB2C;
	sub_828DF2B0(ctx, base);
	// 828DAB2C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828DAB30: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DAB34: 419A0008  beq cr6, 0x828dab3c
	if ctx.cr[6].eq {
	pc = 0x828DAB3C; continue 'dispatch;
	}
	// 828DAB38: 4B9E5D59  bl 0x822c0890
	ctx.lr = 0x828DAB3C;
	sub_822C0890(ctx, base);
	// 828DAB3C: 3BDE01F4  addi r30, r30, 0x1f4
	ctx.r[30].s64 = ctx.r[30].s64 + 500;
	// 828DAB40: 397D1388  addi r11, r29, 0x1388
	ctx.r[11].s64 = ctx.r[29].s64 + 5000;
	// 828DAB44: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 828DAB48: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 828DAB4C: 4198FF5C  blt cr6, 0x828daaa8
	if ctx.cr[6].lt {
	pc = 0x828DAAA8; continue 'dispatch;
	}
	// 828DAB50: 807C0004  lwz r3, 4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DAB54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DAB58: 419A0008  beq cr6, 0x828dab60
	if ctx.cr[6].eq {
	pc = 0x828DAB60; continue 'dispatch;
	}
	// 828DAB5C: 4B9E5D35  bl 0x822c0890
	ctx.lr = 0x828DAB60;
	sub_822C0890(ctx, base);
	// 828DAB60: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828DAB64: 488CD650  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DAB68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DAB68 size=128
    let mut pc: u32 = 0x828DAB68;
    'dispatch: loop {
        match pc {
            0x828DAB68 => {
    //   block [0x828DAB68..0x828DABE8)
	// 828DAB68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DAB6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DAB70: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828DAB74: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DAB78: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DAB7C: 3BE30004  addi r31, r3, 4
	ctx.r[31].s64 = ctx.r[3].s64 + 4;
	// 828DAB80: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DAB84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DAB88: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828DAB8C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828DAB90: 419A0024  beq cr6, 0x828dabb4
	if ctx.cr[6].eq {
	pc = 0x828DABB4; continue 'dispatch;
	}
	// 828DAB94: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828DAB98: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828DAB9C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DABA0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828DABA4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828DABA8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828DABAC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DABB0: 4082FFE8  bne 0x828dab98
	if !ctx.cr[0].eq {
	pc = 0x828DAB98; continue 'dispatch;
	}
	// 828DABB4: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828DABB8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DABBC: 386B1388  addi r3, r11, 0x1388
	ctx.r[3].s64 = ctx.r[11].s64 + 5000;
	// 828DABC0: 48004A51  bl 0x828df610
	ctx.lr = 0x828DABC4;
	sub_828DF610(ctx, base);
	// 828DABC4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DABC8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DABCC: 419A0008  beq cr6, 0x828dabd4
	if ctx.cr[6].eq {
	pc = 0x828DABD4; continue 'dispatch;
	}
	// 828DABD0: 4B9E5CC1  bl 0x822c0890
	ctx.lr = 0x828DABD4;
	sub_822C0890(ctx, base);
	// 828DABD4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828DABD8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DABDC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DABE0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828DABE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DABE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828DABE8 size=8
    let mut pc: u32 = 0x828DABE8;
    'dispatch: loop {
        match pc {
            0x828DABE8 => {
    //   block [0x828DABE8..0x828DABF0)
	// 828DABE8: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 828DABEC: 48000DC4  b 0x828db9b0
	sub_828DB9B0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DABF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828DABF0 size=8
    let mut pc: u32 = 0x828DABF0;
    'dispatch: loop {
        match pc {
            0x828DABF0 => {
    //   block [0x828DABF0..0x828DABF8)
	// 828DABF0: 3863FDF8  addi r3, r3, -0x208
	ctx.r[3].s64 = ctx.r[3].s64 + -520;
	// 828DABF4: 48000DBC  b 0x828db9b0
	sub_828DB9B0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DABF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828DABF8 size=8
    let mut pc: u32 = 0x828DABF8;
    'dispatch: loop {
        match pc {
            0x828DABF8 => {
    //   block [0x828DABF8..0x828DAC00)
	// 828DABF8: 3863FCA0  addi r3, r3, -0x360
	ctx.r[3].s64 = ctx.r[3].s64 + -864;
	// 828DABFC: 48000DB4  b 0x828db9b0
	sub_828DB9B0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DAC00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DAC00 size=232
    let mut pc: u32 = 0x828DAC00;
    'dispatch: loop {
        match pc {
            0x828DAC00 => {
    //   block [0x828DAC00..0x828DACE8)
	// 828DAC00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DAC04: 488CD561  bl 0x831a8164
	ctx.lr = 0x828DAC08;
	sub_831A8130(ctx, base);
	// 828DAC08: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DAC0C: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828DAC10: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828DAC14: 3BAB28C0  addi r29, r11, 0x28c0
	ctx.r[29].s64 = ctx.r[11].s64 + 10432;
	// 828DAC18: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828DAC1C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828DAC20: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 828DAC24: 3B6B0F7C  addi r27, r11, 0xf7c
	ctx.r[27].s64 = ctx.r[11].s64 + 3964;
	// 828DAC28: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828DAC2C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828DAC30: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828DAC34: 488CDEA5  bl 0x831a8ad8
	ctx.lr = 0x828DAC38;
	sub_831A8AD8(ctx, base);
	// 828DAC38: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 828DAC3C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DAC40: 48518DC9  bl 0x82df3a08
	ctx.lr = 0x828DAC44;
	sub_82DF3A08(ctx, base);
	// 828DAC44: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DAC48: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828DAC4C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DAC50: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DAC54: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 828DAC58: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828DAC5C: 4E800421  bctrl
	ctx.lr = 0x828DAC60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DAC60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DAC64: 485187C5  bl 0x82df3428
	ctx.lr = 0x828DAC68;
	sub_82DF3428(ctx, base);
	// 828DAC68: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828DAC6C: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828DAC70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DAC74: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828DAC78: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 828DAC7C: 419A0024  beq cr6, 0x828daca0
	if ctx.cr[6].eq {
	pc = 0x828DACA0; continue 'dispatch;
	}
	// 828DAC80: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828DAC84: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828DAC88: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DAC8C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828DAC90: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828DAC94: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828DAC98: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DAC9C: 4082FFE8  bne 0x828dac84
	if !ctx.cr[0].eq {
	pc = 0x828DAC84; continue 'dispatch;
	}
	// 828DACA0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828DACA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DACA8: 48004609  bl 0x828df2b0
	ctx.lr = 0x828DACAC;
	sub_828DF2B0(ctx, base);
	// 828DACAC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828DACB0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DACB4: 419A0008  beq cr6, 0x828dacbc
	if ctx.cr[6].eq {
	pc = 0x828DACBC; continue 'dispatch;
	}
	// 828DACB8: 4B9E5BD9  bl 0x822c0890
	ctx.lr = 0x828DACBC;
	sub_822C0890(ctx, base);
	// 828DACBC: 3BDE01F4  addi r30, r30, 0x1f4
	ctx.r[30].s64 = ctx.r[30].s64 + 500;
	// 828DACC0: 397D1388  addi r11, r29, 0x1388
	ctx.r[11].s64 = ctx.r[29].s64 + 5000;
	// 828DACC4: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 828DACC8: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 828DACCC: 4198FF5C  blt cr6, 0x828dac28
	if ctx.cr[6].lt {
	pc = 0x828DAC28; continue 'dispatch;
	}
	// 828DACD0: 807C0004  lwz r3, 4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DACD4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DACD8: 419A0008  beq cr6, 0x828dace0
	if ctx.cr[6].eq {
	pc = 0x828DACE0; continue 'dispatch;
	}
	// 828DACDC: 4B9E5BB5  bl 0x822c0890
	ctx.lr = 0x828DACE0;
	sub_822C0890(ctx, base);
	// 828DACE0: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828DACE4: 488CD4D0  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DACE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DACE8 size=128
    let mut pc: u32 = 0x828DACE8;
    'dispatch: loop {
        match pc {
            0x828DACE8 => {
    //   block [0x828DACE8..0x828DAD68)
	// 828DACE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DACEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DACF0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828DACF4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DACF8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DACFC: 3BE30004  addi r31, r3, 4
	ctx.r[31].s64 = ctx.r[3].s64 + 4;
	// 828DAD00: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DAD04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DAD08: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828DAD0C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828DAD10: 419A0024  beq cr6, 0x828dad34
	if ctx.cr[6].eq {
	pc = 0x828DAD34; continue 'dispatch;
	}
	// 828DAD14: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828DAD18: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828DAD1C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DAD20: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828DAD24: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828DAD28: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828DAD2C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DAD30: 4082FFE8  bne 0x828dad18
	if !ctx.cr[0].eq {
	pc = 0x828DAD18; continue 'dispatch;
	}
	// 828DAD34: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828DAD38: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DAD3C: 386B27E8  addi r3, r11, 0x27e8
	ctx.r[3].s64 = ctx.r[11].s64 + 10216;
	// 828DAD40: 480048D1  bl 0x828df610
	ctx.lr = 0x828DAD44;
	sub_828DF610(ctx, base);
	// 828DAD44: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DAD48: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DAD4C: 419A0008  beq cr6, 0x828dad54
	if ctx.cr[6].eq {
	pc = 0x828DAD54; continue 'dispatch;
	}
	// 828DAD50: 4B9E5B41  bl 0x822c0890
	ctx.lr = 0x828DAD54;
	sub_822C0890(ctx, base);
	// 828DAD54: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828DAD58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DAD5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DAD60: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828DAD64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DAD68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828DAD68 size=8
    let mut pc: u32 = 0x828DAD68;
    'dispatch: loop {
        match pc {
            0x828DAD68 => {
    //   block [0x828DAD68..0x828DAD70)
	// 828DAD68: 3863FDF8  addi r3, r3, -0x208
	ctx.r[3].s64 = ctx.r[3].s64 + -520;
	// 828DAD6C: 48000D24  b 0x828dba90
	sub_828DBA90(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DAD70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828DAD70 size=8
    let mut pc: u32 = 0x828DAD70;
    'dispatch: loop {
        match pc {
            0x828DAD70 => {
    //   block [0x828DAD70..0x828DAD78)
	// 828DAD70: 3863FCA0  addi r3, r3, -0x360
	ctx.r[3].s64 = ctx.r[3].s64 + -864;
	// 828DAD74: 48000D1C  b 0x828dba90
	sub_828DBA90(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DAD78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828DAD78 size=8
    let mut pc: u32 = 0x828DAD78;
    'dispatch: loop {
        match pc {
            0x828DAD78 => {
    //   block [0x828DAD78..0x828DAD80)
	// 828DAD78: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 828DAD7C: 48000D14  b 0x828dba90
	sub_828DBA90(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DAD80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DAD80 size=72
    let mut pc: u32 = 0x828DAD80;
    'dispatch: loop {
        match pc {
            0x828DAD80 => {
    //   block [0x828DAD80..0x828DADC8)
	// 828DAD80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DAD84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DAD88: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DAD8C: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 828DAD90: 419A001C  beq cr6, 0x828dadac
	if ctx.cr[6].eq {
	pc = 0x828DADAC; continue 'dispatch;
	}
	// 828DAD94: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828DAD98: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828DAD9C: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 828DADA0: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828DADA4: 4BFFEE8D  bl 0x828d9c30
	ctx.lr = 0x828DADA8;
	sub_828D9C30(ctx, base);
	// 828DADA8: 48000010  b 0x828dadb8
	pc = 0x828DADB8; continue 'dispatch;
	// 828DADAC: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828DADB0: 396B6DF0  addi r11, r11, 0x6df0
	ctx.r[11].s64 = ctx.r[11].s64 + 28144;
	// 828DADB4: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828DADB8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828DADBC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DADC0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DADC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DADC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DADC8 size=72
    let mut pc: u32 = 0x828DADC8;
    'dispatch: loop {
        match pc {
            0x828DADC8 => {
    //   block [0x828DADC8..0x828DAE10)
	// 828DADC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DADCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DADD0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DADD4: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 828DADD8: 419A001C  beq cr6, 0x828dadf4
	if ctx.cr[6].eq {
	pc = 0x828DADF4; continue 'dispatch;
	}
	// 828DADDC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828DADE0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828DADE4: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 828DADE8: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828DADEC: 4BFFEECD  bl 0x828d9cb8
	ctx.lr = 0x828DADF0;
	sub_828D9CB8(ctx, base);
	// 828DADF0: 48000010  b 0x828dae00
	pc = 0x828DAE00; continue 'dispatch;
	// 828DADF4: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828DADF8: 396B6ED8  addi r11, r11, 0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + 28376;
	// 828DADFC: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828DAE00: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828DAE04: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DAE08: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DAE0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DAE10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DAE10 size=72
    let mut pc: u32 = 0x828DAE10;
    'dispatch: loop {
        match pc {
            0x828DAE10 => {
    //   block [0x828DAE10..0x828DAE58)
	// 828DAE10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DAE14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DAE18: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DAE1C: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 828DAE20: 419A001C  beq cr6, 0x828dae3c
	if ctx.cr[6].eq {
	pc = 0x828DAE3C; continue 'dispatch;
	}
	// 828DAE24: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828DAE28: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828DAE2C: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 828DAE30: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828DAE34: 4BFFEF0D  bl 0x828d9d40
	ctx.lr = 0x828DAE38;
	sub_828D9D40(ctx, base);
	// 828DAE38: 48000010  b 0x828dae48
	pc = 0x828DAE48; continue 'dispatch;
	// 828DAE3C: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828DAE40: 396B6F88  addi r11, r11, 0x6f88
	ctx.r[11].s64 = ctx.r[11].s64 + 28552;
	// 828DAE44: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828DAE48: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828DAE4C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DAE50: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DAE54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DAE58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DAE58 size=72
    let mut pc: u32 = 0x828DAE58;
    'dispatch: loop {
        match pc {
            0x828DAE58 => {
    //   block [0x828DAE58..0x828DAEA0)
	// 828DAE58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DAE5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DAE60: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DAE64: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 828DAE68: 419A001C  beq cr6, 0x828dae84
	if ctx.cr[6].eq {
	pc = 0x828DAE84; continue 'dispatch;
	}
	// 828DAE6C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828DAE70: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828DAE74: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 828DAE78: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828DAE7C: 4BFFEF55  bl 0x828d9dd0
	ctx.lr = 0x828DAE80;
	sub_828D9DD0(ctx, base);
	// 828DAE80: 48000010  b 0x828dae90
	pc = 0x828DAE90; continue 'dispatch;
	// 828DAE84: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828DAE88: 396B7058  addi r11, r11, 0x7058
	ctx.r[11].s64 = ctx.r[11].s64 + 28760;
	// 828DAE8C: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828DAE90: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828DAE94: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DAE98: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DAE9C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DAEA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DAEA0 size=72
    let mut pc: u32 = 0x828DAEA0;
    'dispatch: loop {
        match pc {
            0x828DAEA0 => {
    //   block [0x828DAEA0..0x828DAEE8)
	// 828DAEA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DAEA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DAEA8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DAEAC: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 828DAEB0: 419A001C  beq cr6, 0x828daecc
	if ctx.cr[6].eq {
	pc = 0x828DAECC; continue 'dispatch;
	}
	// 828DAEB4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828DAEB8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828DAEBC: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 828DAEC0: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828DAEC4: 4BFFEF95  bl 0x828d9e58
	ctx.lr = 0x828DAEC8;
	sub_828D9E58(ctx, base);
	// 828DAEC8: 48000010  b 0x828daed8
	pc = 0x828DAED8; continue 'dispatch;
	// 828DAECC: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828DAED0: 396B7110  addi r11, r11, 0x7110
	ctx.r[11].s64 = ctx.r[11].s64 + 28944;
	// 828DAED4: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828DAED8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828DAEDC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DAEE0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DAEE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DAEE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DAEE8 size=668
    let mut pc: u32 = 0x828DAEE8;
    'dispatch: loop {
        match pc {
            0x828DAEE8 => {
    //   block [0x828DAEE8..0x828DB184)
	// 828DAEE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DAEEC: 488CD27D  bl 0x831a8168
	ctx.lr = 0x828DAEF0;
	sub_831A8130(ctx, base);
	// 828DAEF0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DAEF4: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 828DAEF8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828DAEFC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828DAF00: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 828DAF04: 41820038  beq 0x828daf3c
	if ctx.cr[0].eq {
	pc = 0x828DAF3C; continue 'dispatch;
	}
	// 828DAF08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DAF0C: 488CEA7D  bl 0x831a9988
	ctx.lr = 0x828DAF10;
	sub_831A9988(ctx, base);
	// 828DAF10: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 828DAF14: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DAF18: 386B3984  addi r3, r11, 0x3984
	ctx.r[3].s64 = ctx.r[11].s64 + 14724;
	// 828DAF1C: 488CD1DD  bl 0x831a80f8
	ctx.lr = 0x828DAF20;
	sub_831A80F8(ctx, base);
	// 828DAF20: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DAF24: 41820018  beq 0x828daf3c
	if ctx.cr[0].eq {
	pc = 0x828DAF3C; continue 'dispatch;
	}
	// 828DAF28: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DAF2C: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 828DAF30: 4BFFEFE1  bl 0x828d9f10
	ctx.lr = 0x828DAF34;
	sub_828D9F10(ctx, base);
	// 828DAF34: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828DAF38: 48000244  b 0x828db17c
	pc = 0x828DB17C; continue 'dispatch;
	// 828DAF3C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828DAF40: 419A022C  beq cr6, 0x828db16c
	if ctx.cr[6].eq {
	pc = 0x828DB16C; continue 'dispatch;
	}
	// 828DAF44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DAF48: 488CEA41  bl 0x831a9988
	ctx.lr = 0x828DAF4C;
	sub_831A9988(ctx, base);
	// 828DAF4C: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 828DAF50: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DAF54: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 828DAF58: 488CD1A1  bl 0x831a80f8
	ctx.lr = 0x828DAF5C;
	sub_831A80F8(ctx, base);
	// 828DAF5C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DAF60: 41820014  beq 0x828daf74
	if ctx.cr[0].eq {
	pc = 0x828DAF74; continue 'dispatch;
	}
	// 828DAF64: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DAF68: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 828DAF6C: 4BFFEF75  bl 0x828d9ee0
	ctx.lr = 0x828DAF70;
	sub_828D9EE0(ctx, base);
	// 828DAF70: 4BFFFFC4  b 0x828daf34
	pc = 0x828DAF34; continue 'dispatch;
	// 828DAF74: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828DAF78: 419A01F4  beq cr6, 0x828db16c
	if ctx.cr[6].eq {
	pc = 0x828DB16C; continue 'dispatch;
	}
	// 828DAF7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DAF80: 488CEA09  bl 0x831a9988
	ctx.lr = 0x828DAF84;
	sub_831A9988(ctx, base);
	// 828DAF84: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 828DAF88: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DAF8C: 386B6C0C  addi r3, r11, 0x6c0c
	ctx.r[3].s64 = ctx.r[11].s64 + 27660;
	// 828DAF90: 488CD169  bl 0x831a80f8
	ctx.lr = 0x828DAF94;
	sub_831A80F8(ctx, base);
	// 828DAF94: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DAF98: 41820014  beq 0x828dafac
	if ctx.cr[0].eq {
	pc = 0x828DAFAC; continue 'dispatch;
	}
	// 828DAF9C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DAFA0: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 828DAFA4: 4BFFEF7D  bl 0x828d9f20
	ctx.lr = 0x828DAFA8;
	sub_828D9F20(ctx, base);
	// 828DAFA8: 4BFFFF8C  b 0x828daf34
	pc = 0x828DAF34; continue 'dispatch;
	// 828DAFAC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828DAFB0: 419A01BC  beq cr6, 0x828db16c
	if ctx.cr[6].eq {
	pc = 0x828DB16C; continue 'dispatch;
	}
	// 828DAFB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DAFB8: 488CE9D1  bl 0x831a9988
	ctx.lr = 0x828DAFBC;
	sub_831A9988(ctx, base);
	// 828DAFBC: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 828DAFC0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DAFC4: 386B6BDC  addi r3, r11, 0x6bdc
	ctx.r[3].s64 = ctx.r[11].s64 + 27612;
	// 828DAFC8: 488CD131  bl 0x831a80f8
	ctx.lr = 0x828DAFCC;
	sub_831A80F8(ctx, base);
	// 828DAFCC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DAFD0: 41820014  beq 0x828dafe4
	if ctx.cr[0].eq {
	pc = 0x828DAFE4; continue 'dispatch;
	}
	// 828DAFD4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DAFD8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 828DAFDC: 4BFFEF15  bl 0x828d9ef0
	ctx.lr = 0x828DAFE0;
	sub_828D9EF0(ctx, base);
	// 828DAFE0: 4BFFFF54  b 0x828daf34
	pc = 0x828DAF34; continue 'dispatch;
	// 828DAFE4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828DAFE8: 419A0184  beq cr6, 0x828db16c
	if ctx.cr[6].eq {
	pc = 0x828DB16C; continue 'dispatch;
	}
	// 828DAFEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DAFF0: 488CE999  bl 0x831a9988
	ctx.lr = 0x828DAFF4;
	sub_831A9988(ctx, base);
	// 828DAFF4: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 828DAFF8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DAFFC: 386B5CEC  addi r3, r11, 0x5cec
	ctx.r[3].s64 = ctx.r[11].s64 + 23788;
	// 828DB000: 488CD0F9  bl 0x831a80f8
	ctx.lr = 0x828DB004;
	sub_831A80F8(ctx, base);
	// 828DB004: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DB008: 41820014  beq 0x828db01c
	if ctx.cr[0].eq {
	pc = 0x828DB01C; continue 'dispatch;
	}
	// 828DB00C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DB010: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 828DB014: 4BFFEEED  bl 0x828d9f00
	ctx.lr = 0x828DB018;
	sub_828D9F00(ctx, base);
	// 828DB018: 4BFFFF1C  b 0x828daf34
	pc = 0x828DAF34; continue 'dispatch;
	// 828DB01C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828DB020: 419A014C  beq cr6, 0x828db16c
	if ctx.cr[6].eq {
	pc = 0x828DB16C; continue 'dispatch;
	}
	// 828DB024: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DB028: 488CE961  bl 0x831a9988
	ctx.lr = 0x828DB02C;
	sub_831A9988(ctx, base);
	// 828DB02C: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 828DB030: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DB034: 386B3A44  addi r3, r11, 0x3a44
	ctx.r[3].s64 = ctx.r[11].s64 + 14916;
	// 828DB038: 488CD0C1  bl 0x831a80f8
	ctx.lr = 0x828DB03C;
	sub_831A80F8(ctx, base);
	// 828DB03C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DB040: 41820014  beq 0x828db054
	if ctx.cr[0].eq {
	pc = 0x828DB054; continue 'dispatch;
	}
	// 828DB044: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DB048: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 828DB04C: 48009145  bl 0x828e4190
	ctx.lr = 0x828DB050;
	sub_828E4190(ctx, base);
	// 828DB050: 4BFFFEE4  b 0x828daf34
	pc = 0x828DAF34; continue 'dispatch;
	// 828DB054: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828DB058: 419A0114  beq cr6, 0x828db16c
	if ctx.cr[6].eq {
	pc = 0x828DB16C; continue 'dispatch;
	}
	// 828DB05C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DB060: 488CE929  bl 0x831a9988
	ctx.lr = 0x828DB064;
	sub_831A9988(ctx, base);
	// 828DB064: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 828DB068: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DB06C: 386B1FA4  addi r3, r11, 0x1fa4
	ctx.r[3].s64 = ctx.r[11].s64 + 8100;
	// 828DB070: 488CD089  bl 0x831a80f8
	ctx.lr = 0x828DB074;
	sub_831A80F8(ctx, base);
	// 828DB074: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DB078: 41820014  beq 0x828db08c
	if ctx.cr[0].eq {
	pc = 0x828DB08C; continue 'dispatch;
	}
	// 828DB07C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DB080: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 828DB084: 4BF9A4AD  bl 0x82875530
	ctx.lr = 0x828DB088;
	sub_82875530(ctx, base);
	// 828DB088: 4BFFFEAC  b 0x828daf34
	pc = 0x828DAF34; continue 'dispatch;
	// 828DB08C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828DB090: 419A00DC  beq cr6, 0x828db16c
	if ctx.cr[6].eq {
	pc = 0x828DB16C; continue 'dispatch;
	}
	// 828DB094: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DB098: 488CE8F1  bl 0x831a9988
	ctx.lr = 0x828DB09C;
	sub_831A9988(ctx, base);
	// 828DB09C: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 828DB0A0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DB0A4: 386B5CC4  addi r3, r11, 0x5cc4
	ctx.r[3].s64 = ctx.r[11].s64 + 23748;
	// 828DB0A8: 488CD051  bl 0x831a80f8
	ctx.lr = 0x828DB0AC;
	sub_831A80F8(ctx, base);
	// 828DB0AC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DB0B0: 41820014  beq 0x828db0c4
	if ctx.cr[0].eq {
	pc = 0x828DB0C4; continue 'dispatch;
	}
	// 828DB0B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DB0B8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 828DB0BC: 4BFFE965  bl 0x828d9a20
	ctx.lr = 0x828DB0C0;
	sub_828D9A20(ctx, base);
	// 828DB0C0: 4BFFFE74  b 0x828daf34
	pc = 0x828DAF34; continue 'dispatch;
	// 828DB0C4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828DB0C8: 419A00A4  beq cr6, 0x828db16c
	if ctx.cr[6].eq {
	pc = 0x828DB16C; continue 'dispatch;
	}
	// 828DB0CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DB0D0: 488CE8B9  bl 0x831a9988
	ctx.lr = 0x828DB0D4;
	sub_831A9988(ctx, base);
	// 828DB0D4: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 828DB0D8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DB0DC: 386B2380  addi r3, r11, 0x2380
	ctx.r[3].s64 = ctx.r[11].s64 + 9088;
	// 828DB0E0: 488CD019  bl 0x831a80f8
	ctx.lr = 0x828DB0E4;
	sub_831A80F8(ctx, base);
	// 828DB0E4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DB0E8: 41820014  beq 0x828db0fc
	if ctx.cr[0].eq {
	pc = 0x828DB0FC; continue 'dispatch;
	}
	// 828DB0EC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DB0F0: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 828DB0F4: 4BFFEE3D  bl 0x828d9f30
	ctx.lr = 0x828DB0F8;
	sub_828D9F30(ctx, base);
	// 828DB0F8: 4BFFFE3C  b 0x828daf34
	pc = 0x828DAF34; continue 'dispatch;
	// 828DB0FC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828DB100: 419A006C  beq cr6, 0x828db16c
	if ctx.cr[6].eq {
	pc = 0x828DB16C; continue 'dispatch;
	}
	// 828DB104: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DB108: 488CE881  bl 0x831a9988
	ctx.lr = 0x828DB10C;
	sub_831A9988(ctx, base);
	// 828DB10C: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828DB110: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DB114: 386BAE64  addi r3, r11, -0x519c
	ctx.r[3].s64 = ctx.r[11].s64 + -20892;
	// 828DB118: 488CCFE1  bl 0x831a80f8
	ctx.lr = 0x828DB11C;
	sub_831A80F8(ctx, base);
	// 828DB11C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DB120: 41820014  beq 0x828db134
	if ctx.cr[0].eq {
	pc = 0x828DB134; continue 'dispatch;
	}
	// 828DB124: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DB128: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 828DB12C: 4BFFF84D  bl 0x828da978
	ctx.lr = 0x828DB130;
	sub_828DA978(ctx, base);
	// 828DB130: 4BFFFE04  b 0x828daf34
	pc = 0x828DAF34; continue 'dispatch;
	// 828DB134: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828DB138: 419A0034  beq cr6, 0x828db16c
	if ctx.cr[6].eq {
	pc = 0x828DB16C; continue 'dispatch;
	}
	// 828DB13C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DB140: 488CE849  bl 0x831a9988
	ctx.lr = 0x828DB144;
	sub_831A9988(ctx, base);
	// 828DB144: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 828DB148: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DB14C: 386BF378  addi r3, r11, -0xc88
	ctx.r[3].s64 = ctx.r[11].s64 + -3208;
	// 828DB150: 488CCFA9  bl 0x831a80f8
	ctx.lr = 0x828DB154;
	sub_831A80F8(ctx, base);
	// 828DB154: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DB158: 41820014  beq 0x828db16c
	if ctx.cr[0].eq {
	pc = 0x828DB16C; continue 'dispatch;
	}
	// 828DB15C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DB160: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 828DB164: 4BFFF82D  bl 0x828da990
	ctx.lr = 0x828DB168;
	sub_828DA990(ctx, base);
	// 828DB168: 4BFFFDCC  b 0x828daf34
	pc = 0x828DAF34; continue 'dispatch;
	// 828DB16C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828DB170: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DB174: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DB178: 48034919  bl 0x8290fa90
	ctx.lr = 0x828DB17C;
	sub_8290FA90(ctx, base);
	// 828DB17C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828DB180: 488CD038  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DB188(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DB188 size=792
    let mut pc: u32 = 0x828DB188;
    'dispatch: loop {
        match pc {
            0x828DB188 => {
    //   block [0x828DB188..0x828DB4A0)
	// 828DB188: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DB18C: 488CCFD9  bl 0x831a8164
	ctx.lr = 0x828DB190;
	sub_831A8130(ctx, base);
	// 828DB190: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DB194: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828DB198: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828DB19C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DB1A0: 388B0134  addi r4, r11, 0x134
	ctx.r[4].s64 = ctx.r[11].s64 + 308;
	// 828DB1A4: 48518865  bl 0x82df3a08
	ctx.lr = 0x828DB1A8;
	sub_82DF3A08(ctx, base);
	// 828DB1A8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828DB1AC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828DB1B0: 3BEB32AC  addi r31, r11, 0x32ac
	ctx.r[31].s64 = ctx.r[11].s64 + 12972;
	// 828DB1B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DB1B8: 48518851  bl 0x82df3a08
	ctx.lr = 0x828DB1BC;
	sub_82DF3A08(ctx, base);
	// 828DB1BC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828DB1C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DB1C4: 3BCB32A0  addi r30, r11, 0x32a0
	ctx.r[30].s64 = ctx.r[11].s64 + 12960;
	// 828DB1C8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DB1CC: 4851883D  bl 0x82df3a08
	ctx.lr = 0x828DB1D0;
	sub_82DF3A08(ctx, base);
	// 828DB1D0: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 828DB1D4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828DB1D8: 809B0000  lwz r4, 0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DB1DC: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 828DB1E0: 4BCED9B9  bl 0x825c8b98
	ctx.lr = 0x828DB1E4;
	sub_825C8B98(ctx, base);
	// 828DB1E4: 80810090  lwz r4, 0x90(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 828DB1E8: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828DB1EC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828DB1F0: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DB1F4: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 828DB1F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828DB1FC: 4E800421  bctrl
	ctx.lr = 0x828DB200;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DB200: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 828DB204: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DB208: 419A0008  beq cr6, 0x828db210
	if ctx.cr[6].eq {
	pc = 0x828DB210; continue 'dispatch;
	}
	// 828DB20C: 4B9E5685  bl 0x822c0890
	ctx.lr = 0x828DB210;
	sub_822C0890(ctx, base);
	// 828DB210: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DB214: 48518215  bl 0x82df3428
	ctx.lr = 0x828DB218;
	sub_82DF3428(ctx, base);
	// 828DB218: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828DB21C: 4851820D  bl 0x82df3428
	ctx.lr = 0x828DB220;
	sub_82DF3428(ctx, base);
	// 828DB220: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DB224: 48518205  bl 0x82df3428
	ctx.lr = 0x828DB228;
	sub_82DF3428(ctx, base);
	// 828DB228: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828DB22C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DB230: 3BAB3290  addi r29, r11, 0x3290
	ctx.r[29].s64 = ctx.r[11].s64 + 12944;
	// 828DB234: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828DB238: 485187D1  bl 0x82df3a08
	ctx.lr = 0x828DB23C;
	sub_82DF3A08(ctx, base);
	// 828DB23C: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 828DB240: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DB244: 3B8B89A8  addi r28, r11, -0x7658
	ctx.r[28].s64 = ctx.r[11].s64 + -30296;
	// 828DB248: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828DB24C: 485187BD  bl 0x82df3a08
	ctx.lr = 0x828DB250;
	sub_82DF3A08(ctx, base);
	// 828DB250: 80810070  lwz r4, 0x70(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 828DB254: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828DB258: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828DB25C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828DB260: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DB264: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 828DB268: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828DB26C: 4E800421  bctrl
	ctx.lr = 0x828DB270;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DB270: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DB274: 485181B5  bl 0x82df3428
	ctx.lr = 0x828DB278;
	sub_82DF3428(ctx, base);
	// 828DB278: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DB27C: 485181AD  bl 0x82df3428
	ctx.lr = 0x828DB280;
	sub_82DF3428(ctx, base);
	// 828DB280: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 828DB284: 81410080  lwz r10, 0x80(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 828DB288: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DB28C: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828DB290: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 828DB294: 419A0024  beq cr6, 0x828db2b8
	if ctx.cr[6].eq {
	pc = 0x828DB2B8; continue 'dispatch;
	}
	// 828DB298: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828DB29C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828DB2A0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DB2A4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828DB2A8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828DB2AC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828DB2B0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DB2B4: 4082FFE8  bne 0x828db29c
	if !ctx.cr[0].eq {
	pc = 0x828DB29C; continue 'dispatch;
	}
	// 828DB2B8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DB2BC: 4BFFF8AD  bl 0x828dab68
	ctx.lr = 0x828DB2C0;
	sub_828DAB68(ctx, base);
	// 828DB2C0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828DB2C4: 81410070  lwz r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 828DB2C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DB2CC: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828DB2D0: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 828DB2D4: 419A0024  beq cr6, 0x828db2f8
	if ctx.cr[6].eq {
	pc = 0x828DB2F8; continue 'dispatch;
	}
	// 828DB2D8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828DB2DC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828DB2E0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DB2E4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828DB2E8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828DB2EC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828DB2F0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DB2F4: 4082FFE8  bne 0x828db2dc
	if !ctx.cr[0].eq {
	pc = 0x828DB2DC; continue 'dispatch;
	}
	// 828DB2F8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DB2FC: 4BFFF785  bl 0x828daa80
	ctx.lr = 0x828DB300;
	sub_828DAA80(ctx, base);
	// 828DB300: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 828DB304: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DB308: 419A0008  beq cr6, 0x828db310
	if ctx.cr[6].eq {
	pc = 0x828DB310; continue 'dispatch;
	}
	// 828DB30C: 4B9E5585  bl 0x822c0890
	ctx.lr = 0x828DB310;
	sub_822C0890(ctx, base);
	// 828DB310: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828DB314: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DB318: 419A0008  beq cr6, 0x828db320
	if ctx.cr[6].eq {
	pc = 0x828DB320; continue 'dispatch;
	}
	// 828DB31C: 4B9E5575  bl 0x822c0890
	ctx.lr = 0x828DB320;
	sub_822C0890(ctx, base);
	// 828DB320: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828DB324: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DB328: 388B0124  addi r4, r11, 0x124
	ctx.r[4].s64 = ctx.r[11].s64 + 292;
	// 828DB32C: 485186DD  bl 0x82df3a08
	ctx.lr = 0x828DB330;
	sub_82DF3A08(ctx, base);
	// 828DB330: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DB334: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 828DB338: 485186D1  bl 0x82df3a08
	ctx.lr = 0x828DB33C;
	sub_82DF3A08(ctx, base);
	// 828DB33C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DB340: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828DB344: 485186C5  bl 0x82df3a08
	ctx.lr = 0x828DB348;
	sub_82DF3A08(ctx, base);
	// 828DB348: 38C1006C  addi r6, r1, 0x6c
	ctx.r[6].s64 = ctx.r[1].s64 + 108;
	// 828DB34C: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 828DB350: 809B0000  lwz r4, 0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DB354: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 828DB358: 4BCED841  bl 0x825c8b98
	ctx.lr = 0x828DB35C;
	sub_825C8B98(ctx, base);
	// 828DB35C: 80810098  lwz r4, 0x98(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 828DB360: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828DB364: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 828DB368: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DB36C: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 828DB370: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828DB374: 4E800421  bctrl
	ctx.lr = 0x828DB378;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DB378: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 828DB37C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DB380: 419A0008  beq cr6, 0x828db388
	if ctx.cr[6].eq {
	pc = 0x828DB388; continue 'dispatch;
	}
	// 828DB384: 4B9E550D  bl 0x822c0890
	ctx.lr = 0x828DB388;
	sub_822C0890(ctx, base);
	// 828DB388: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828DB38C: 4851809D  bl 0x82df3428
	ctx.lr = 0x828DB390;
	sub_82DF3428(ctx, base);
	// 828DB390: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 828DB394: 48518095  bl 0x82df3428
	ctx.lr = 0x828DB398;
	sub_82DF3428(ctx, base);
	// 828DB398: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DB39C: 4851808D  bl 0x82df3428
	ctx.lr = 0x828DB3A0;
	sub_82DF3428(ctx, base);
	// 828DB3A0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828DB3A4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DB3A8: 48518661  bl 0x82df3a08
	ctx.lr = 0x828DB3AC;
	sub_82DF3A08(ctx, base);
	// 828DB3AC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828DB3B0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DB3B4: 48518655  bl 0x82df3a08
	ctx.lr = 0x828DB3B8;
	sub_82DF3A08(ctx, base);
	// 828DB3B8: 80810078  lwz r4, 0x78(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 828DB3BC: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 828DB3C0: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828DB3C4: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 828DB3C8: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DB3CC: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 828DB3D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828DB3D4: 4E800421  bctrl
	ctx.lr = 0x828DB3D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DB3D8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DB3DC: 4851804D  bl 0x82df3428
	ctx.lr = 0x828DB3E0;
	sub_82DF3428(ctx, base);
	// 828DB3E0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DB3E4: 48518045  bl 0x82df3428
	ctx.lr = 0x828DB3E8;
	sub_82DF3428(ctx, base);
	// 828DB3E8: 8161008C  lwz r11, 0x8c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 828DB3EC: 81410088  lwz r10, 0x88(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 828DB3F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DB3F4: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828DB3F8: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 828DB3FC: 419A0024  beq cr6, 0x828db420
	if ctx.cr[6].eq {
	pc = 0x828DB420; continue 'dispatch;
	}
	// 828DB400: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828DB404: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828DB408: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DB40C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828DB410: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828DB414: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828DB418: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DB41C: 4082FFE8  bne 0x828db404
	if !ctx.cr[0].eq {
	pc = 0x828DB404; continue 'dispatch;
	}
	// 828DB420: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DB424: 4BFFF8C5  bl 0x828dace8
	ctx.lr = 0x828DB428;
	sub_828DACE8(ctx, base);
	// 828DB428: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 828DB42C: 81410078  lwz r10, 0x78(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 828DB430: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DB434: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828DB438: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 828DB43C: 419A0024  beq cr6, 0x828db460
	if ctx.cr[6].eq {
	pc = 0x828DB460; continue 'dispatch;
	}
	// 828DB440: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828DB444: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828DB448: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DB44C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828DB450: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828DB454: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828DB458: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DB45C: 4082FFE8  bne 0x828db444
	if !ctx.cr[0].eq {
	pc = 0x828DB444; continue 'dispatch;
	}
	// 828DB460: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DB464: 4BFFF79D  bl 0x828dac00
	ctx.lr = 0x828DB468;
	sub_828DAC00(ctx, base);
	// 828DB468: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 828DB46C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DB470: 419A0008  beq cr6, 0x828db478
	if ctx.cr[6].eq {
	pc = 0x828DB478; continue 'dispatch;
	}
	// 828DB474: 4B9E541D  bl 0x822c0890
	ctx.lr = 0x828DB478;
	sub_822C0890(ctx, base);
	// 828DB478: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 828DB47C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DB480: 419A0008  beq cr6, 0x828db488
	if ctx.cr[6].eq {
	pc = 0x828DB488; continue 'dispatch;
	}
	// 828DB484: 4B9E540D  bl 0x822c0890
	ctx.lr = 0x828DB488;
	sub_822C0890(ctx, base);
	// 828DB488: 807B0004  lwz r3, 4(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DB48C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DB490: 419A0008  beq cr6, 0x828db498
	if ctx.cr[6].eq {
	pc = 0x828DB498; continue 'dispatch;
	}
	// 828DB494: 4B9E53FD  bl 0x822c0890
	ctx.lr = 0x828DB498;
	sub_822C0890(ctx, base);
	// 828DB498: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 828DB49C: 488CCD18  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DB4A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DB4A0 size=200
    let mut pc: u32 = 0x828DB4A0;
    'dispatch: loop {
        match pc {
            0x828DB4A0 => {
    //   block [0x828DB4A0..0x828DB568)
	// 828DB4A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DB4A4: 488CCCC5  bl 0x831a8168
	ctx.lr = 0x828DB4A8;
	sub_831A8130(ctx, base);
	// 828DB4A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DB4AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DB4B0: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 828DB4B4: 7D1C4378  mr r28, r8
	ctx.r[28].u64 = ctx.r[8].u64;
	// 828DB4B8: 48035661  bl 0x82910b18
	ctx.lr = 0x828DB4BC;
	sub_82910B18(ctx, base);
	// 828DB4BC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 828DB4C0: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828DB4C4: 396BA214  addi r11, r11, -0x5dec
	ctx.r[11].s64 = ctx.r[11].s64 + -24044;
	// 828DB4C8: 394AFA2C  addi r10, r10, -0x5d4
	ctx.r[10].s64 = ctx.r[10].s64 + -1492;
	// 828DB4CC: 3D008209  lis r8, -0x7df7
	ctx.r[8].s64 = -2113339392;
	// 828DB4D0: 917F0360  stw r11, 0x360(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(864 as u32), ctx.r[11].u32 ) };
	// 828DB4D4: 3CE08209  lis r7, -0x7df7
	ctx.r[7].s64 = -2113339392;
	// 828DB4D8: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828DB4DC: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828DB4E0: 3968F9F8  addi r11, r8, -0x608
	ctx.r[11].s64 = ctx.r[8].s64 + -1544;
	// 828DB4E4: 3929FA14  addi r9, r9, -0x5ec
	ctx.r[9].s64 = ctx.r[9].s64 + -1516;
	// 828DB4E8: 3947F9AC  addi r10, r7, -0x654
	ctx.r[10].s64 = ctx.r[7].s64 + -1620;
	// 828DB4EC: 917F0208  stw r11, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[11].u32 ) };
	// 828DB4F0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828DB4F4: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 828DB4F8: 915F0360  stw r10, 0x360(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(864 as u32), ctx.r[10].u32 ) };
	// 828DB4FC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828DB500: 93DF0364  stw r30, 0x364(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(868 as u32), ctx.r[30].u32 ) };
	// 828DB504: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828DB508: 93DF0368  stw r30, 0x368(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(872 as u32), ctx.r[30].u32 ) };
	// 828DB50C: 388B0140  addi r4, r11, 0x140
	ctx.r[4].s64 = ctx.r[11].s64 + 320;
	// 828DB510: 93DF036C  stw r30, 0x36c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(876 as u32), ctx.r[30].u32 ) };
	// 828DB514: 38A000B6  li r5, 0xb6
	ctx.r[5].s64 = 182;
	// 828DB518: 93DF0370  stw r30, 0x370(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(880 as u32), ctx.r[30].u32 ) };
	// 828DB51C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828DB520: 93DF0374  stw r30, 0x374(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(884 as u32), ctx.r[30].u32 ) };
	// 828DB524: 93DF0378  stw r30, 0x378(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(888 as u32), ctx.r[30].u32 ) };
	// 828DB528: 93DF0380  stw r30, 0x380(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(896 as u32), ctx.r[30].u32 ) };
	// 828DB52C: 93BF0384  stw r29, 0x384(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(900 as u32), ctx.r[29].u32 ) };
	// 828DB530: 939F0388  stw r28, 0x388(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(904 as u32), ctx.r[28].u32 ) };
	// 828DB534: 93DF038C  stw r30, 0x38c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(908 as u32), ctx.r[30].u32 ) };
	// 828DB538: 93DF0394  stw r30, 0x394(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(916 as u32), ctx.r[30].u32 ) };
	// 828DB53C: 93DF0398  stw r30, 0x398(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(920 as u32), ctx.r[30].u32 ) };
	// 828DB540: 4B9E4E99  bl 0x822c03d8
	ctx.lr = 0x828DB544;
	sub_822C03D8(ctx, base);
	// 828DB544: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828DB548: 4182000C  beq 0x828db554
	if ctx.cr[0].eq {
	pc = 0x828DB554; continue 'dispatch;
	}
	// 828DB54C: 4882B765  bl 0x83106cb0
	ctx.lr = 0x828DB550;
	sub_83106CB0(ctx, base);
	// 828DB550: 48000008  b 0x828db558
	pc = 0x828DB558; continue 'dispatch;
	// 828DB554: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DB558: 907F0380  stw r3, 0x380(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(896 as u32), ctx.r[3].u32 ) };
	// 828DB55C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DB560: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828DB564: 488CCC54  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DB568(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DB568 size=76
    let mut pc: u32 = 0x828DB568;
    'dispatch: loop {
        match pc {
            0x828DB568 => {
    //   block [0x828DB568..0x828DB5B4)
	// 828DB568: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DB56C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DB570: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828DB574: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828DB578: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DB57C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DB580: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828DB584: 4BFFED6D  bl 0x828da2f0
	ctx.lr = 0x828DB588;
	sub_828DA2F0(ctx, base);
	// 828DB588: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DB58C: 4182000C  beq 0x828db598
	if ctx.cr[0].eq {
	pc = 0x828DB598; continue 'dispatch;
	}
	// 828DB590: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DB594: 48516E45  bl 0x82df23d8
	ctx.lr = 0x828DB598;
	sub_82DF23D8(ctx, base);
	// 828DB598: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DB59C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828DB5A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DB5A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DB5A8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828DB5AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828DB5B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DB5B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828DB5B8 size=644
    let mut pc: u32 = 0x828DB5B8;
    'dispatch: loop {
        match pc {
            0x828DB5B8 => {
    //   block [0x828DB5B8..0x828DB83C)
	// 828DB5B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DB5BC: 488CCBA5  bl 0x831a8160
	ctx.lr = 0x828DB5C0;
	sub_831A8130(ctx, base);
	// 828DB5C0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DB5C4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828DB5C8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828DB5CC: 48067D8D  bl 0x82943358
	ctx.lr = 0x828DB5D0;
	sub_82943358(ctx, base);
	// 828DB5D0: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 828DB5D4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828DB5D8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828DB5DC: 3B8B0140  addi r28, r11, 0x140
	ctx.r[28].s64 = ctx.r[11].s64 + 320;
	// 828DB5E0: 38A0026E  li r5, 0x26e
	ctx.r[5].s64 = 622;
	// 828DB5E4: C00A4C5C  lfs f0, 0x4c5c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(19548 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828DB5E8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828DB5EC: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 828DB5F0: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 828DB5F4: 4B9E4DE5  bl 0x822c03d8
	ctx.lr = 0x828DB5F8;
	sub_822C03D8(ctx, base);
	// 828DB5F8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828DB5FC: 41820018  beq 0x828db614
	if ctx.cr[0].eq {
	pc = 0x828DB614; continue 'dispatch;
	}
	// 828DB600: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 828DB604: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DB608: 48067D81  bl 0x82943388
	ctx.lr = 0x828DB60C;
	sub_82943388(ctx, base);
	// 828DB60C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DB610: 48000008  b 0x828db618
	pc = 0x828DB618; continue 'dispatch;
	// 828DB614: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828DB618: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828DB61C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DB620: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828DB624: 4BF96895  bl 0x82871eb8
	ctx.lr = 0x828DB628;
	sub_82871EB8(ctx, base);
	// 828DB628: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828DB62C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DB630: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828DB634: 4B9E49CD  bl 0x822c0000
	ctx.lr = 0x828DB638;
	sub_822C0000(ctx, base);
	// 828DB638: 83410054  lwz r26, 0x54(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828DB63C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828DB640: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 828DB644: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	// 828DB648: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828DB64C: 419A0024  beq cr6, 0x828db670
	if ctx.cr[6].eq {
	pc = 0x828DB670; continue 'dispatch;
	}
	// 828DB650: 397A0004  addi r11, r26, 4
	ctx.r[11].s64 = ctx.r[26].s64 + 4;
	// 828DB654: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828DB658: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DB65C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828DB660: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828DB664: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828DB668: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DB66C: 4082FFE8  bne 0x828db654
	if !ctx.cr[0].eq {
	pc = 0x828DB654; continue 'dispatch;
	}
	// 828DB670: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DB674: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DB678: 48064E39  bl 0x829404b0
	ctx.lr = 0x828DB67C;
	sub_829404B0(ctx, base);
	// 828DB67C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828DB680: 48065DB1  bl 0x82941430
	ctx.lr = 0x828DB684;
	sub_82941430(ctx, base);
	// 828DB684: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828DB688: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 828DB68C: 3FA08208  lis r29, -0x7df8
	ctx.r[29].s64 = -2113404928;
	// 828DB690: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828DB694: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828DB698: C1AB6154  lfs f13, 0x6154(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24916 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828DB69C: 38A00276  li r5, 0x276
	ctx.r[5].s64 = 630;
	// 828DB6A0: C18A6150  lfs f12, 0x6150(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24912 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828DB6A4: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 828DB6A8: C01D614C  lfs f0, 0x614c(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24908 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828DB6AC: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 828DB6B0: D1A10084  stfs f13, 0x84(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 828DB6B4: D1810088  stfs f12, 0x88(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 828DB6B8: 4B9E4D21  bl 0x822c03d8
	ctx.lr = 0x828DB6BC;
	sub_822C03D8(ctx, base);
	// 828DB6BC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828DB6C0: 41820018  beq 0x828db6d8
	if ctx.cr[0].eq {
	pc = 0x828DB6D8; continue 'dispatch;
	}
	// 828DB6C4: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 828DB6C8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DB6CC: 4806683D  bl 0x82941f08
	ctx.lr = 0x828DB6D0;
	sub_82941F08(ctx, base);
	// 828DB6D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DB6D4: 48000008  b 0x828db6dc
	pc = 0x828DB6DC; continue 'dispatch;
	// 828DB6D8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828DB6DC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828DB6E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DB6E4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828DB6E8: 4BF976C1  bl 0x82872da8
	ctx.lr = 0x828DB6EC;
	sub_82872DA8(ctx, base);
	// 828DB6EC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828DB6F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DB6F4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828DB6F8: 4B9E4909  bl 0x822c0000
	ctx.lr = 0x828DB6FC;
	sub_822C0000(ctx, base);
	// 828DB6FC: 83610054  lwz r27, 0x54(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828DB700: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828DB704: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 828DB708: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 828DB70C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828DB710: 419A0024  beq cr6, 0x828db734
	if ctx.cr[6].eq {
	pc = 0x828DB734; continue 'dispatch;
	}
	// 828DB714: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 828DB718: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828DB71C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DB720: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828DB724: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828DB728: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828DB72C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DB730: 4082FFE8  bne 0x828db718
	if !ctx.cr[0].eq {
	pc = 0x828DB718; continue 'dispatch;
	}
	// 828DB734: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DB738: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DB73C: 48064D75  bl 0x829404b0
	ctx.lr = 0x828DB740;
	sub_829404B0(ctx, base);
	// 828DB740: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DB744: 480671AD  bl 0x829428f0
	ctx.lr = 0x828DB748;
	sub_829428F0(ctx, base);
	// 828DB748: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828DB74C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 828DB750: C01D614C  lfs f0, 0x614c(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24908 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828DB754: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828DB758: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828DB75C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828DB760: 38A0027F  li r5, 0x27f
	ctx.r[5].s64 = 639;
	// 828DB764: C1ABC664  lfs f13, -0x399c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-14748 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828DB768: 38600040  li r3, 0x40
	ctx.r[3].s64 = 64;
	// 828DB76C: C00A9524  lfs f0, -0x6adc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828DB770: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 828DB774: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 828DB778: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 828DB77C: 4B9E4C5D  bl 0x822c03d8
	ctx.lr = 0x828DB780;
	sub_822C03D8(ctx, base);
	// 828DB780: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828DB784: 41820018  beq 0x828db79c
	if ctx.cr[0].eq {
	pc = 0x828DB79C; continue 'dispatch;
	}
	// 828DB788: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828DB78C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DB790: 48067191  bl 0x82942920
	ctx.lr = 0x828DB794;
	sub_82942920(ctx, base);
	// 828DB794: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DB798: 48000008  b 0x828db7a0
	pc = 0x828DB7A0; continue 'dispatch;
	// 828DB79C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828DB7A0: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828DB7A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DB7A8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828DB7AC: 4BF967D5  bl 0x82871f80
	ctx.lr = 0x828DB7B0;
	sub_82871F80(ctx, base);
	// 828DB7B0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828DB7B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DB7B8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828DB7BC: 4B9E4845  bl 0x822c0000
	ctx.lr = 0x828DB7C0;
	sub_822C0000(ctx, base);
	// 828DB7C0: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828DB7C4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828DB7C8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828DB7CC: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 828DB7D0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828DB7D4: 419A0024  beq cr6, 0x828db7f8
	if ctx.cr[6].eq {
	pc = 0x828DB7F8; continue 'dispatch;
	}
	// 828DB7D8: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 828DB7DC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828DB7E0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DB7E4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828DB7E8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828DB7EC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828DB7F0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DB7F4: 4082FFE8  bne 0x828db7dc
	if !ctx.cr[0].eq {
	pc = 0x828DB7DC; continue 'dispatch;
	}
	// 828DB7F8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DB7FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DB800: 48064CB1  bl 0x829404b0
	ctx.lr = 0x828DB804;
	sub_829404B0(ctx, base);
	// 828DB804: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828DB808: 419A000C  beq cr6, 0x828db814
	if ctx.cr[6].eq {
	pc = 0x828DB814; continue 'dispatch;
	}
	// 828DB80C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DB810: 4B9E5081  bl 0x822c0890
	ctx.lr = 0x828DB814;
	sub_822C0890(ctx, base);
	// 828DB814: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 828DB818: 419A000C  beq cr6, 0x828db824
	if ctx.cr[6].eq {
	pc = 0x828DB824; continue 'dispatch;
	}
	// 828DB81C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828DB820: 4B9E5071  bl 0x822c0890
	ctx.lr = 0x828DB824;
	sub_822C0890(ctx, base);
	// 828DB824: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 828DB828: 419A000C  beq cr6, 0x828db834
	if ctx.cr[6].eq {
	pc = 0x828DB834; continue 'dispatch;
	}
	// 828DB82C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828DB830: 4B9E5061  bl 0x822c0890
	ctx.lr = 0x828DB834;
	sub_822C0890(ctx, base);
	// 828DB834: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 828DB838: 488CC978  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DB840(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828DB840 size=272
    let mut pc: u32 = 0x828DB840;
    'dispatch: loop {
        match pc {
            0x828DB840 => {
    //   block [0x828DB840..0x828DB950)
	// 828DB840: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DB844: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DB848: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828DB84C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828DB850: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DB854: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DB858: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DB85C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828DB860: 48066AB1  bl 0x82942310
	ctx.lr = 0x828DB864;
	sub_82942310(ctx, base);
	// 828DB864: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DB868: 4BF108F9  bl 0x827ec160
	ctx.lr = 0x828DB86C;
	sub_827EC160(ctx, base);
	// 828DB86C: 4BF13ECD  bl 0x827ef738
	ctx.lr = 0x828DB870;
	sub_827EF738(ctx, base);
	// 828DB870: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 828DB874: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 828DB878: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 828DB87C: 3D008209  lis r8, -0x7df7
	ctx.r[8].s64 = -2113339392;
	// 828DB880: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828DB884: 13E358C7  vcmpequd (lvx128) v31, v3, v11
	tmp.u32 = ctx.r[3].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828DB888: 38880140  addi r4, r8, 0x140
	ctx.r[4].s64 = ctx.r[8].s64 + 320;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DB950(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DB950 size=96
    let mut pc: u32 = 0x828DB950;
    'dispatch: loop {
        match pc {
            0x828DB950 => {
    //   block [0x828DB950..0x828DB9B0)
	// 828DB950: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DB954: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DB958: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828DB95C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DB960: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DB964: 4BFFFB3D  bl 0x828db4a0
	ctx.lr = 0x828DB968;
	sub_828DB4A0(ctx, base);
	// 828DB968: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828DB96C: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828DB970: 396BFD2C  addi r11, r11, -0x2d4
	ctx.r[11].s64 = ctx.r[11].s64 + -724;
	// 828DB974: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828DB978: 3D008209  lis r8, -0x7df7
	ctx.r[8].s64 = -2113339392;
	// 828DB97C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828DB980: 394AFD14  addi r10, r10, -0x2ec
	ctx.r[10].s64 = ctx.r[10].s64 + -748;
	// 828DB984: 3929FCF8  addi r9, r9, -0x308
	ctx.r[9].s64 = ctx.r[9].s64 + -776;
	// 828DB988: 3968FCAC  addi r11, r8, -0x354
	ctx.r[11].s64 = ctx.r[8].s64 + -852;
	// 828DB98C: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 828DB990: 913F0208  stw r9, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[9].u32 ) };
	// 828DB994: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DB998: 917F0360  stw r11, 0x360(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(864 as u32), ctx.r[11].u32 ) };
	// 828DB99C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828DB9A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DB9A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DB9A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828DB9AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DB9B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DB9B0 size=124
    let mut pc: u32 = 0x828DB9B0;
    'dispatch: loop {
        match pc {
            0x828DB9B0 => {
    //   block [0x828DB9B0..0x828DBA2C)
	// 828DB9B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DB9B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DB9B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828DB9BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828DB9C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DB9C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DB9C8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828DB9CC: 3D008209  lis r8, -0x7df7
	ctx.r[8].s64 = -2113339392;
	// 828DB9D0: 396BFD2C  addi r11, r11, -0x2d4
	ctx.r[11].s64 = ctx.r[11].s64 + -724;
	// 828DB9D4: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828DB9D8: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828DB9DC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828DB9E0: 394AFD14  addi r10, r10, -0x2ec
	ctx.r[10].s64 = ctx.r[10].s64 + -748;
	// 828DB9E4: 3929FCF8  addi r9, r9, -0x308
	ctx.r[9].s64 = ctx.r[9].s64 + -776;
	// 828DB9E8: 3968FCAC  addi r11, r8, -0x354
	ctx.r[11].s64 = ctx.r[8].s64 + -852;
	// 828DB9EC: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 828DB9F0: 913F0208  stw r9, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[9].u32 ) };
	// 828DB9F4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828DB9F8: 917F0360  stw r11, 0x360(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(864 as u32), ctx.r[11].u32 ) };
	// 828DB9FC: 4BFFE8F5  bl 0x828da2f0
	ctx.lr = 0x828DBA00;
	sub_828DA2F0(ctx, base);
	// 828DBA00: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DBA04: 4182000C  beq 0x828dba10
	if ctx.cr[0].eq {
	pc = 0x828DBA10; continue 'dispatch;
	}
	// 828DBA08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DBA0C: 485169CD  bl 0x82df23d8
	ctx.lr = 0x828DBA10;
	sub_82DF23D8(ctx, base);
	// 828DBA10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DBA14: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828DBA18: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DBA1C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DBA20: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828DBA24: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828DBA28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DBA30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DBA30 size=96
    let mut pc: u32 = 0x828DBA30;
    'dispatch: loop {
        match pc {
            0x828DBA30 => {
    //   block [0x828DBA30..0x828DBA90)
	// 828DBA30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DBA34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DBA38: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828DBA3C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DBA40: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DBA44: 4BFFFA5D  bl 0x828db4a0
	ctx.lr = 0x828DBA48;
	sub_828DB4A0(ctx, base);
	// 828DBA48: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828DBA4C: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828DBA50: 396BFF6C  addi r11, r11, -0x94
	ctx.r[11].s64 = ctx.r[11].s64 + -148;
	// 828DBA54: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828DBA58: 3D008209  lis r8, -0x7df7
	ctx.r[8].s64 = -2113339392;
	// 828DBA5C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828DBA60: 394AFF54  addi r10, r10, -0xac
	ctx.r[10].s64 = ctx.r[10].s64 + -172;
	// 828DBA64: 3929FF38  addi r9, r9, -0xc8
	ctx.r[9].s64 = ctx.r[9].s64 + -200;
	// 828DBA68: 3968FEEC  addi r11, r8, -0x114
	ctx.r[11].s64 = ctx.r[8].s64 + -276;
	// 828DBA6C: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 828DBA70: 913F0208  stw r9, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[9].u32 ) };
	// 828DBA74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DBA78: 917F0360  stw r11, 0x360(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(864 as u32), ctx.r[11].u32 ) };
	// 828DBA7C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828DBA80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DBA84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DBA88: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828DBA8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DBA90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DBA90 size=124
    let mut pc: u32 = 0x828DBA90;
    'dispatch: loop {
        match pc {
            0x828DBA90 => {
    //   block [0x828DBA90..0x828DBB0C)
	// 828DBA90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DBA94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DBA98: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828DBA9C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828DBAA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DBAA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DBAA8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828DBAAC: 3D008209  lis r8, -0x7df7
	ctx.r[8].s64 = -2113339392;
	// 828DBAB0: 396BFF6C  addi r11, r11, -0x94
	ctx.r[11].s64 = ctx.r[11].s64 + -148;
	// 828DBAB4: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828DBAB8: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828DBABC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828DBAC0: 394AFF54  addi r10, r10, -0xac
	ctx.r[10].s64 = ctx.r[10].s64 + -172;
	// 828DBAC4: 3929FF38  addi r9, r9, -0xc8
	ctx.r[9].s64 = ctx.r[9].s64 + -200;
	// 828DBAC8: 3968FEEC  addi r11, r8, -0x114
	ctx.r[11].s64 = ctx.r[8].s64 + -276;
	// 828DBACC: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 828DBAD0: 913F0208  stw r9, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[9].u32 ) };
	// 828DBAD4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828DBAD8: 917F0360  stw r11, 0x360(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(864 as u32), ctx.r[11].u32 ) };
	// 828DBADC: 4BFFE815  bl 0x828da2f0
	ctx.lr = 0x828DBAE0;
	sub_828DA2F0(ctx, base);
	// 828DBAE0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DBAE4: 4182000C  beq 0x828dbaf0
	if ctx.cr[0].eq {
	pc = 0x828DBAF0; continue 'dispatch;
	}
	// 828DBAE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DBAEC: 485168ED  bl 0x82df23d8
	ctx.lr = 0x828DBAF0;
	sub_82DF23D8(ctx, base);
	// 828DBAF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DBAF4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828DBAF8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DBAFC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DBB00: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828DBB04: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828DBB08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DBB10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DBB10 size=112
    let mut pc: u32 = 0x828DBB10;
    'dispatch: loop {
        match pc {
            0x828DBB10 => {
    //   block [0x828DBB10..0x828DBB80)
	// 828DBB10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DBB14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DBB18: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828DBB1C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828DBB20: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DBB24: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828DBB28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DBB2C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828DBB30: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828DBB34: 4BFFE5E5  bl 0x828da118
	ctx.lr = 0x828DBB38;
	sub_828DA118(ctx, base);
	// 828DBB38: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828DBB3C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DBB40: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828DBB44: 4B9E44BD  bl 0x822c0000
	ctx.lr = 0x828DBB48;
	sub_822C0000(ctx, base);
	// 828DBB48: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828DBB4C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828DBB50: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828DBB54: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DBB58: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DBB5C: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828DBB60: 419A0008  beq cr6, 0x828dbb68
	if ctx.cr[6].eq {
	pc = 0x828DBB68; continue 'dispatch;
	}
	// 828DBB64: 4B9E4D2D  bl 0x822c0890
	ctx.lr = 0x828DBB68;
	sub_822C0890(ctx, base);
	// 828DBB68: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828DBB6C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DBB70: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DBB74: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828DBB78: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828DBB7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DBB80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DBB80 size=112
    let mut pc: u32 = 0x828DBB80;
    'dispatch: loop {
        match pc {
            0x828DBB80 => {
    //   block [0x828DBB80..0x828DBBF0)
	// 828DBB80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DBB84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DBB88: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828DBB8C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828DBB90: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DBB94: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828DBB98: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DBB9C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828DBBA0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828DBBA4: 4BFFE63D  bl 0x828da1e0
	ctx.lr = 0x828DBBA8;
	sub_828DA1E0(ctx, base);
	// 828DBBA8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828DBBAC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DBBB0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828DBBB4: 4B9E444D  bl 0x822c0000
	ctx.lr = 0x828DBBB8;
	sub_822C0000(ctx, base);
	// 828DBBB8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828DBBBC: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828DBBC0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828DBBC4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DBBC8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DBBCC: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828DBBD0: 419A0008  beq cr6, 0x828dbbd8
	if ctx.cr[6].eq {
	pc = 0x828DBBD8; continue 'dispatch;
	}
	// 828DBBD4: 4B9E4CBD  bl 0x822c0890
	ctx.lr = 0x828DBBD8;
	sub_822C0890(ctx, base);
	// 828DBBD8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828DBBDC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DBBE0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DBBE4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828DBBE8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828DBBEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DBBF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828DBBF0 size=248
    let mut pc: u32 = 0x828DBBF0;
    'dispatch: loop {
        match pc {
            0x828DBBF0 => {
    //   block [0x828DBBF0..0x828DBCE8)
	// 828DBBF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DBBF4: 488CC579  bl 0x831a816c
	ctx.lr = 0x828DBBF8;
	sub_831A8130(ctx, base);
	// 828DBBF8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DBBFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DBC00: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828DBC04: 48034CBD  bl 0x829108c0
	ctx.lr = 0x828DBC08;
	sub_829108C0(ctx, base);
	// 828DBC08: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DBC0C: 408200C8  bne 0x828dbcd4
	if !ctx.cr[0].eq {
	pc = 0x828DBCD4; continue 'dispatch;
	}
	// 828DBC10: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 828DBC14: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828DBC18: 4BC2CA69  bl 0x82508680
	ctx.lr = 0x828DBC1C;
	sub_82508680(ctx, base);
	// 828DBC1C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828DBC20: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DBC24: 4BF9AB05  bl 0x82876728
	ctx.lr = 0x828DBC28;
	sub_82876728(ctx, base);
	// 828DBC28: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DBC2C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828DBC30: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DBC34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DBC38: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828DBC3C: 419A0024  beq cr6, 0x828dbc60
	if ctx.cr[6].eq {
	pc = 0x828DBC60; continue 'dispatch;
	}
	// 828DBC40: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828DBC44: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828DBC48: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DBC4C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828DBC50: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828DBC54: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828DBC58: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DBC5C: 4082FFE8  bne 0x828dbc44
	if !ctx.cr[0].eq {
	pc = 0x828DBC44; continue 'dispatch;
	}
	// 828DBC60: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828DBC64: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828DBC68: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 828DBC6C: 388A0140  addi r4, r10, 0x140
	ctx.r[4].s64 = ctx.r[10].s64 + 320;
	// 828DBC70: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 828DBC74: 38A001FF  li r5, 0x1ff
	ctx.r[5].s64 = 511;
	// 828DBC78: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828DBC7C: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 828DBC80: 4857CDC1  bl 0x82e58a40
	ctx.lr = 0x828DBC84;
	sub_82E58A40(ctx, base);
	// 828DBC84: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828DBC88: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DBC8C: 419A0008  beq cr6, 0x828dbc94
	if ctx.cr[6].eq {
	pc = 0x828DBC94; continue 'dispatch;
	}
	// 828DBC90: 4B9E4C01  bl 0x822c0890
	ctx.lr = 0x828DBC94;
	sub_822C0890(ctx, base);
	// 828DBC94: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828DBC98: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DBC9C: 419A0008  beq cr6, 0x828dbca4
	if ctx.cr[6].eq {
	pc = 0x828DBCA4; continue 'dispatch;
	}
	// 828DBCA0: 4B9E4BF1  bl 0x822c0890
	ctx.lr = 0x828DBCA4;
	sub_822C0890(ctx, base);
	// 828DBCA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DBCA8: 4BF10479  bl 0x827ec120
	ctx.lr = 0x828DBCAC;
	sub_827EC120(ctx, base);
	// 828DBCAC: 807F0364  lwz r3, 0x364(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(868 as u32) ) } as u64;
	// 828DBCB0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DBCB4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828DBCB8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828DBCBC: 4E800421  bctrl
	ctx.lr = 0x828DBCC0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DBCC0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828DBCC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DBCC8: 48032469  bl 0x8290e130
	ctx.lr = 0x828DBCCC;
	sub_8290E130(ctx, base);
	// 828DBCCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DBCD0: 48030F79  bl 0x8290cc48
	ctx.lr = 0x828DBCD4;
	sub_8290CC48(ctx, base);
	// 828DBCD4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828DBCD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DBCDC: 480354A5  bl 0x82911180
	ctx.lr = 0x828DBCE0;
	sub_82911180(ctx, base);
	// 828DBCE0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828DBCE4: 488CC4D8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DBCE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828DBCE8 size=376
    let mut pc: u32 = 0x828DBCE8;
    'dispatch: loop {
        match pc {
            0x828DBCE8 => {
    //   block [0x828DBCE8..0x828DBE60)
	// 828DBCE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DBCEC: 488CC46D  bl 0x831a8158
	ctx.lr = 0x828DBCF0;
	sub_831A8130(ctx, base);
	// 828DBCF0: DBE1FFB0  stfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 828DBCF4: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DBCF8: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DBCFC: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 828DBD00: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DBD04: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 828DBD08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DBD0C: 386BFF6C  addi r3, r11, -0x94
	ctx.r[3].s64 = ctx.r[11].s64 + -148;
	// 828DBD10: 409A0008  bne cr6, 0x828dbd18
	if !ctx.cr[6].eq {
	pc = 0x828DBD18; continue 'dispatch;
	}
	// 828DBD14: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828DBD18: 4BC4C371  bl 0x82528088
	ctx.lr = 0x828DBD1C;
	sub_82528088(ctx, base);
	// 828DBD1C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828DBD20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DBD24: 4BF1043D  bl 0x827ec160
	ctx.lr = 0x828DBD28;
	sub_827EC160(ctx, base);
	// 828DBD28: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DBD2C: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 828DBD30: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828DBD34: 4E800421  bctrl
	ctx.lr = 0x828DBD38;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DBD38: 3FA08335  lis r29, -0x7ccb
	ctx.r[29].s64 = -2093678592;
	// 828DBD3C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 828DBD40: C3E30000  lfs f31, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828DBD44: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 828DBD48: 3D008209  lis r8, -0x7df7
	ctx.r[8].s64 = -2113339392;
	// 828DBD4C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828DBD50: 817D6810  lwz r11, 0x6810(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(26640 as u32) ) } as u64;
	// 828DBD54: 38880140  addi r4, r8, 0x140
	ctx.r[4].s64 = ctx.r[8].s64 + 320;
	// 828DBD58: C00A964C  lfs f0, -0x69b4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828DBD5C: 38A0037C  li r5, 0x37c
	ctx.r[5].s64 = 892;
	// 828DBD60: EDBF002A  fadds f13, f31, f0
	ctx.f[13].f64 = ((ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64;
	// 828DBD64: C00908A4  lfs f0, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828DBD68: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828DBD6C: 38600200  li r3, 0x200
	ctx.r[3].s64 = 512;
	// 828DBD70: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 828DBD74: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 828DBD78: 917F0248  stw r11, 0x248(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(584 as u32), ctx.r[11].u32 ) };
	// 828DBD7C: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 828DBD80: 48516669  bl 0x82df23e8
	ctx.lr = 0x828DBD84;
	sub_82DF23E8(ctx, base);
	// 828DBD84: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828DBD88: 41820080  beq 0x828dbe08
	if ctx.cr[0].eq {
	pc = 0x828DBE08; continue 'dispatch;
	}
	// 828DBD8C: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DBD90: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 828DBD94: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 828DBD98: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 828DBD9C: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828DBDA0: 485C4991  bl 0x82ea0730
	ctx.lr = 0x828DBDA4;
	sub_82EA0730(ctx, base);
	// 828DBDA4: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 828DBDA8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828DBDAC: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 828DBDB0: 4863E441  bl 0x82f1a1f0
	ctx.lr = 0x828DBDB4;
	sub_82F1A1F0(ctx, base);
	// 828DBDB4: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 828DBDB8: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 828DBDBC: 83BD6810  lwz r29, 0x6810(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(26640 as u32) ) } as u64;
	// 828DBDC0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DBDC4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DBDC8: 3B4BBA80  addi r26, r11, -0x4580
	ctx.r[26].s64 = ctx.r[11].s64 + -17792;
	// 828DBDCC: 3B600003  li r27, 3
	ctx.r[27].s64 = 3;
	// 828DBDD0: 3B210060  addi r25, r1, 0x60
	ctx.r[25].s64 = ctx.r[1].s64 + 96;
	// 828DBDD4: 3B010050  addi r24, r1, 0x50
	ctx.r[24].s64 = ctx.r[1].s64 + 80;
	// 828DBDD8: 4BC33741  bl 0x8250f518
	ctx.lr = 0x828DBDDC;
	sub_8250F518(ctx, base);
	// 828DBDDC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828DBDE0: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 828DBDE4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DBDE8: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 828DBDEC: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 828DBDF0: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 828DBDF4: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 828DBDF8: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 828DBDFC: 4820B4E5  bl 0x82ae72e0
	ctx.lr = 0x828DBE00;
	sub_82AE72E0(ctx, base);
	// 828DBE00: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DBE04: 48000008  b 0x828dbe0c
	pc = 0x828DBE0C; continue 'dispatch;
	// 828DBE08: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828DBE0C: 3BFF01D4  addi r31, r31, 0x1d4
	ctx.r[31].s64 = ctx.r[31].s64 + 468;
	// 828DBE10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DBE14: 4BA98445  bl 0x82374258
	ctx.lr = 0x828DBE18;
	sub_82374258(ctx, base);
	// 828DBE18: 576B07BD  rlwinm. r11, r27, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DBE1C: 41820010  beq 0x828dbe2c
	if ctx.cr[0].eq {
	pc = 0x828DBE2C; continue 'dispatch;
	}
	// 828DBE20: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DBE24: 577B07FA  rlwinm r27, r27, 0, 0x1f, 0x1d
	ctx.r[27].u64 = ctx.r[27].u32 as u64 & 0xFFFFFFFFu64;
	// 828DBE28: 48515E69  bl 0x82df1c90
	ctx.lr = 0x828DBE2C;
	sub_82DF1C90(ctx, base);
	// 828DBE2C: 576B07FF  clrlwi. r11, r27, 0x1f
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DBE30: 41820014  beq 0x828dbe44
	if ctx.cr[0].eq {
	pc = 0x828DBE44; continue 'dispatch;
	}
	// 828DBE34: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828DBE38: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DBE3C: 419A0008  beq cr6, 0x828dbe44
	if ctx.cr[6].eq {
	pc = 0x828DBE44; continue 'dispatch;
	}
	// 828DBE40: 4BA0C429  bl 0x822e8268
	ctx.lr = 0x828DBE44;
	sub_822E8268(ctx, base);
	// 828DBE44: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DBE48: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DBE4C: C02BEE80  lfs f1, -0x1180(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4480 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828DBE50: 48207501  bl 0x82ae3350
	ctx.lr = 0x828DBE54;
	sub_82AE3350(ctx, base);
	// 828DBE54: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828DBE58: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 828DBE5C: 488CC34C  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DBE60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828DBE60 size=800
    let mut pc: u32 = 0x828DBE60;
    'dispatch: loop {
        match pc {
            0x828DBE60 => {
    //   block [0x828DBE60..0x828DC180)
	// 828DBE60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DBE64: 488CC305  bl 0x831a8168
	ctx.lr = 0x828DBE68;
	sub_831A8130(ctx, base);
	// 828DBE68: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 828DBE6C: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DBE70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DBE74: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828DBE78: 807F0364  lwz r3, 0x364(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(868 as u32) ) } as u64;
	// 828DBE7C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DBE80: 419A02F4  beq cr6, 0x828dc174
	if ctx.cr[6].eq {
	pc = 0x828DC174; continue 'dispatch;
	}
	// 828DBE84: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DBE88: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 828DBE8C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828DBE90: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DBE94: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 828DBE98: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828DBE9C: 4E800421  bctrl
	ctx.lr = 0x828DBEA0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DBEA0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DBEA4: 418202D0  beq 0x828dc174
	if ctx.cr[0].eq {
	pc = 0x828DC174; continue 'dispatch;
	}
	// 828DBEA8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DBEAC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DBEB0: 808B0B2C  lwz r4, 0xb2c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2860 as u32) ) } as u64;
	// 828DBEB4: 48517B55  bl 0x82df3a08
	ctx.lr = 0x828DBEB8;
	sub_82DF3A08(ctx, base);
	// 828DBEB8: 3B9F00FC  addi r28, r31, 0xfc
	ctx.r[28].s64 = ctx.r[31].s64 + 252;
	// 828DBEBC: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 828DBEC0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828DBEC4: 4857E80D  bl 0x82e5a6d0
	ctx.lr = 0x828DBEC8;
	sub_82E5A6D0(ctx, base);
	// 828DBEC8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DBECC: 485173D5  bl 0x82df32a0
	ctx.lr = 0x828DBED0;
	sub_82DF32A0(ctx, base);
	// 828DBED0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828DBED4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DBED8: 48517551  bl 0x82df3428
	ctx.lr = 0x828DBEDC;
	sub_82DF3428(ctx, base);
	// 828DBEDC: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DBEE0: 41820294  beq 0x828dc174
	if ctx.cr[0].eq {
	pc = 0x828DC174; continue 'dispatch;
	}
	// 828DBEE4: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DBEE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DBEEC: 808B0B24  lwz r4, 0xb24(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2852 as u32) ) } as u64;
	// 828DBEF0: 48517B19  bl 0x82df3a08
	ctx.lr = 0x828DBEF4;
	sub_82DF3A08(ctx, base);
	// 828DBEF4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828DBEF8: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 828DBEFC: 4857E7D5  bl 0x82e5a6d0
	ctx.lr = 0x828DBF00;
	sub_82E5A6D0(ctx, base);
	// 828DBF00: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DBF04: 48517405  bl 0x82df3308
	ctx.lr = 0x828DBF08;
	sub_82DF3308(ctx, base);
	// 828DBF08: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DBF0C: 4851751D  bl 0x82df3428
	ctx.lr = 0x828DBF10;
	sub_82DF3428(ctx, base);
	// 828DBF10: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DBF14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DBF18: 808B0B40  lwz r4, 0xb40(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2880 as u32) ) } as u64;
	// 828DBF1C: 48517AED  bl 0x82df3a08
	ctx.lr = 0x828DBF20;
	sub_82DF3A08(ctx, base);
	// 828DBF20: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828DBF24: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 828DBF28: 4857E7A9  bl 0x82e5a6d0
	ctx.lr = 0x828DBF2C;
	sub_82E5A6D0(ctx, base);
	// 828DBF2C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DBF30: 485173D9  bl 0x82df3308
	ctx.lr = 0x828DBF34;
	sub_82DF3308(ctx, base);
	// 828DBF34: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828DBF38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DBF3C: 485174ED  bl 0x82df3428
	ctx.lr = 0x828DBF40;
	sub_82DF3428(ctx, base);
	// 828DBF40: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DBF44: 40820230  bne 0x828dc174
	if !ctx.cr[0].eq {
	pc = 0x828DC174; continue 'dispatch;
	}
	// 828DBF48: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828DBF4C: 83DF036C  lwz r30, 0x36c(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(876 as u32) ) } as u64;
	// 828DBF50: 4857E781  bl 0x82e5a6d0
	ctx.lr = 0x828DBF54;
	sub_82E5A6D0(ctx, base);
	// 828DBF54: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DBF58: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DBF5C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828DBF60: 48046131  bl 0x82922090
	ctx.lr = 0x828DBF64;
	sub_82922090(ctx, base);
	// 828DBF64: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828DBF68: 4182020C  beq 0x828dc174
	if ctx.cr[0].eq {
	pc = 0x828DC174; continue 'dispatch;
	}
	// 828DBF6C: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828DBF70: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828DBF74: 814A0BD4  lwz r10, 0xbd4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3028 as u32) ) } as u64;
	// 828DBF78: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DBF7C: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DBF80: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 828DBF84: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 828DBF88: 41820014  beq 0x828dbf9c
	if ctx.cr[0].eq {
	pc = 0x828DBF9C; continue 'dispatch;
	}
	// 828DBF8C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828DBF90: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828DBF94: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828DBF98: 419AFFE0  beq cr6, 0x828dbf78
	if ctx.cr[6].eq {
	pc = 0x828DBF78; continue 'dispatch;
	}
	// 828DBF9C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DBFA0: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 828DBFA4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828DBFA8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828DBFAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DBFB0: 816B0068  lwz r11, 0x68(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 828DBFB4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828DBFB8: 40820058  bne 0x828dc010
	if !ctx.cr[0].eq {
	pc = 0x828DC010; continue 'dispatch;
	}
	// 828DBFBC: 4E800421  bctrl
	ctx.lr = 0x828DBFC0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DBFC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DBFC4: 4802CE95  bl 0x82908e58
	ctx.lr = 0x828DBFC8;
	sub_82908E58(ctx, base);
	// 828DBFC8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828DBFCC: 396B08A4  addi r11, r11, 0x8a4
	ctx.r[11].s64 = ctx.r[11].s64 + 2212;
	// 828DBFD0: C3EB0000  lfs f31, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828DBFD4: FF01F800  fcmpu cr6, f1, f31
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 828DBFD8: 419900CC  bgt cr6, 0x828dc0a4
	if ctx.cr[6].gt {
	pc = 0x828DC0A4; continue 'dispatch;
	}
	// 828DBFDC: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DBFE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DBFE4: 808B0B34  lwz r4, 0xb34(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2868 as u32) ) } as u64;
	// 828DBFE8: 48517A21  bl 0x82df3a08
	ctx.lr = 0x828DBFEC;
	sub_82DF3A08(ctx, base);
	// 828DBFEC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828DBFF0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828DBFF4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828DBFF8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828DBFFC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828DC000: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828DC004: 4858295D  bl 0x82e5e960
	ctx.lr = 0x828DC008;
	sub_82E5E960(ctx, base);
	// 828DC008: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828DC00C: 4800008C  b 0x828dc098
	pc = 0x828DC098; continue 'dispatch;
	// 828DC010: 4E800421  bctrl
	ctx.lr = 0x828DC014;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DC014: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DC018: 4BF10149  bl 0x827ec160
	ctx.lr = 0x828DC01C;
	sub_827EC160(ctx, base);
	// 828DC01C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DC020: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DC024: 4803AD75  bl 0x82916d98
	ctx.lr = 0x828DC028;
	sub_82916D98(ctx, base);
	// 828DC028: 39600050  li r11, 0x50
	ctx.r[11].s64 = 80;
	// 828DC02C: 80E10058  lwz r7, 0x58(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828DC030: 394000D0  li r10, 0xd0
	ctx.r[10].s64 = 208;
	// 828DC034: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 828DC038: 390000E0  li r8, 0xe0
	ctx.r[8].s64 = 224;
	// 828DC03C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DC040: 13FD58C7  vcmpequd (lvx128) v31, v29, v11
	tmp.u32 = ctx.r[29].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828DC044: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DC180(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828DC180 size=420
    let mut pc: u32 = 0x828DC180;
    'dispatch: loop {
        match pc {
            0x828DC180 => {
    //   block [0x828DC180..0x828DC324)
	// 828DC180: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DC184: 488CBFE1  bl 0x831a8164
	ctx.lr = 0x828DC188;
	sub_831A8130(ctx, base);
	// 828DC188: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DC18C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DC190: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828DC194: 4802E0AD  bl 0x8290a240
	ctx.lr = 0x828DC198;
	sub_8290A240(ctx, base);
	// 828DC198: 807F0364  lwz r3, 0x364(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(868 as u32) ) } as u64;
	// 828DC19C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DC1A0: 419A017C  beq cr6, 0x828dc31c
	if ctx.cr[6].eq {
	pc = 0x828DC31C; continue 'dispatch;
	}
	// 828DC1A4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DC1A8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828DC1AC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828DC1B0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828DC1B4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DC1B8: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 828DC1BC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828DC1C0: 4E800421  bctrl
	ctx.lr = 0x828DC1C4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DC1C4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DC1C8: 41820154  beq 0x828dc31c
	if ctx.cr[0].eq {
	pc = 0x828DC31C; continue 'dispatch;
	}
	// 828DC1CC: 897C001C  lbz r11, 0x1c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) } as u64;
	// 828DC1D0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828DC1D4: 41820018  beq 0x828dc1ec
	if ctx.cr[0].eq {
	pc = 0x828DC1EC; continue 'dispatch;
	}
	// 828DC1D8: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 828DC1DC: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 828DC1E0: 13FC58C7  vcmpequd (lvx128) v31, v28, v11
	tmp.u32 = ctx.r[28].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DC328(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828DC328 size=548
    let mut pc: u32 = 0x828DC328;
    'dispatch: loop {
        match pc {
            0x828DC328 => {
    //   block [0x828DC328..0x828DC54C)
	// 828DC328: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DC32C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DC330: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828DC334: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828DC338: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 828DC33C: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DC340: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DC344: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828DC348: 4BF0FE19  bl 0x827ec160
	ctx.lr = 0x828DC34C;
	sub_827EC160(ctx, base);
	// 828DC34C: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 828DC350: 4803ACE1  bl 0x82917030
	ctx.lr = 0x828DC354;
	sub_82917030(ctx, base);
	// 828DC354: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DC358: 41820098  beq 0x828dc3f0
	if ctx.cr[0].eq {
	pc = 0x828DC3F0; continue 'dispatch;
	}
	// 828DC35C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828DC360: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DC364: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828DC368: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828DC36C: 4BF8C14D  bl 0x828684b8
	ctx.lr = 0x828DC370;
	sub_828684B8(ctx, base);
	// 828DC370: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DC374: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828DC378: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DC37C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DC380: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828DC384: 419A0024  beq cr6, 0x828dc3a8
	if ctx.cr[6].eq {
	pc = 0x828DC3A8; continue 'dispatch;
	}
	// 828DC388: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828DC38C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828DC390: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DC394: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828DC398: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828DC39C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828DC3A0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DC3A4: 4082FFE8  bne 0x828dc38c
	if !ctx.cr[0].eq {
	pc = 0x828DC38C; continue 'dispatch;
	}
	// 828DC3A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DC3AC: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 828DC3B0: 4872BD79  bl 0x83008128
	ctx.lr = 0x828DC3B4;
	sub_83008128(ctx, base);
	// 828DC3B4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828DC3B8: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828DC3BC: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828DC3C0: 388A0140  addi r4, r10, 0x140
	ctx.r[4].s64 = ctx.r[10].s64 + 320;
	// 828DC3C4: 38A00436  li r5, 0x436
	ctx.r[5].s64 = 1078;
	// 828DC3C8: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 828DC3CC: C02BF8F8  lfs f1, -0x708(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1800 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828DC3D0: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 828DC3D4: 4857C66D  bl 0x82e58a40
	ctx.lr = 0x828DC3D8;
	sub_82E58A40(ctx, base);
	// 828DC3D8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828DC3DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DC3E0: 419A0008  beq cr6, 0x828dc3e8
	if ctx.cr[6].eq {
	pc = 0x828DC3E8; continue 'dispatch;
	}
	// 828DC3E4: 4B9E44AD  bl 0x822c0890
	ctx.lr = 0x828DC3E8;
	sub_822C0890(ctx, base);
	// 828DC3E8: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828DC3EC: 48000138  b 0x828dc524
	pc = 0x828DC524; continue 'dispatch;
	// 828DC3F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DC3F4: 4802CA65  bl 0x82908e58
	ctx.lr = 0x828DC3F8;
	sub_82908E58(ctx, base);
	// 828DC3F8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828DC3FC: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828DC400: FF01F800  fcmpu cr6, f1, f31
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 828DC404: 4099012C  ble cr6, 0x828dc530
	if !ctx.cr[6].gt {
	pc = 0x828DC530; continue 'dispatch;
	}
	// 828DC408: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DC40C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DC410: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DC414: 816B0190  lwz r11, 0x190(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(400 as u32) ) } as u64;
	// 828DC418: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828DC41C: 4E800421  bctrl
	ctx.lr = 0x828DC420;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DC420: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DC424: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DC428: 41820034  beq 0x828dc45c
	if ctx.cr[0].eq {
	pc = 0x828DC45C; continue 'dispatch;
	}
	// 828DC42C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DC430: 808B80A8  lwz r4, -0x7f58(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-32600 as u32) ) } as u64;
	// 828DC434: 485175D5  bl 0x82df3a08
	ctx.lr = 0x828DC438;
	sub_82DF3A08(ctx, base);
	// 828DC438: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828DC43C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828DC440: 389F00FC  addi r4, r31, 0xfc
	ctx.r[4].s64 = ctx.r[31].s64 + 252;
	// 828DC444: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828DC448: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828DC44C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828DC450: 48582511  bl 0x82e5e960
	ctx.lr = 0x828DC454;
	sub_82E5E960(ctx, base);
	// 828DC454: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828DC458: 48000030  b 0x828dc488
	pc = 0x828DC488; continue 'dispatch;
	// 828DC45C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DC460: 808B80A4  lwz r4, -0x7f5c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-32604 as u32) ) } as u64;
	// 828DC464: 485175A5  bl 0x82df3a08
	ctx.lr = 0x828DC468;
	sub_82DF3A08(ctx, base);
	// 828DC468: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828DC46C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828DC470: 389F00FC  addi r4, r31, 0xfc
	ctx.r[4].s64 = ctx.r[31].s64 + 252;
	// 828DC474: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 828DC478: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828DC47C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828DC480: 485824E1  bl 0x82e5e960
	ctx.lr = 0x828DC484;
	sub_82E5E960(ctx, base);
	// 828DC484: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 828DC488: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DC48C: 419A0008  beq cr6, 0x828dc494
	if ctx.cr[6].eq {
	pc = 0x828DC494; continue 'dispatch;
	}
	// 828DC490: 4B9E4401  bl 0x822c0890
	ctx.lr = 0x828DC494;
	sub_822C0890(ctx, base);
	// 828DC494: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DC498: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DC49C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828DC4A0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828DC4A4: 4BF8C015  bl 0x828684b8
	ctx.lr = 0x828DC4A8;
	sub_828684B8(ctx, base);
	// 828DC4A8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DC4AC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828DC4B0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DC4B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DC4B8: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828DC4BC: 419A0024  beq cr6, 0x828dc4e0
	if ctx.cr[6].eq {
	pc = 0x828DC4E0; continue 'dispatch;
	}
	// 828DC4C0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828DC4C4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828DC4C8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DC4CC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828DC4D0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828DC4D4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828DC4D8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DC4DC: 4082FFE8  bne 0x828dc4c4
	if !ctx.cr[0].eq {
	pc = 0x828DC4C4; continue 'dispatch;
	}
	// 828DC4E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DC4E4: 3BC10060  addi r30, r1, 0x60
	ctx.r[30].s64 = ctx.r[1].s64 + 96;
	// 828DC4E8: 4872BC41  bl 0x83008128
	ctx.lr = 0x828DC4EC;
	sub_83008128(ctx, base);
	// 828DC4EC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828DC4F0: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828DC4F4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828DC4F8: 388A0140  addi r4, r10, 0x140
	ctx.r[4].s64 = ctx.r[10].s64 + 320;
	// 828DC4FC: 38A00449  li r5, 0x449
	ctx.r[5].s64 = 1097;
	// 828DC500: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 828DC504: C02BF8F8  lfs f1, -0x708(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1800 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828DC508: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 828DC50C: 4857C535  bl 0x82e58a40
	ctx.lr = 0x828DC510;
	sub_82E58A40(ctx, base);
	// 828DC510: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828DC514: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DC518: 419A0008  beq cr6, 0x828dc520
	if ctx.cr[6].eq {
	pc = 0x828DC520; continue 'dispatch;
	}
	// 828DC51C: 4B9E4375  bl 0x822c0890
	ctx.lr = 0x828DC520;
	sub_822C0890(ctx, base);
	// 828DC520: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 828DC524: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DC528: 419A0008  beq cr6, 0x828dc530
	if ctx.cr[6].eq {
	pc = 0x828DC530; continue 'dispatch;
	}
	// 828DC52C: 4B9E4365  bl 0x822c0890
	ctx.lr = 0x828DC530;
	sub_822C0890(ctx, base);
	// 828DC530: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828DC534: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DC538: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DC53C: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 828DC540: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828DC544: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828DC548: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DC550(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DC550 size=148
    let mut pc: u32 = 0x828DC550;
    'dispatch: loop {
        match pc {
            0x828DC550 => {
    //   block [0x828DC550..0x828DC5E4)
	// 828DC550: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DC554: 488CBC11  bl 0x831a8164
	ctx.lr = 0x828DC558;
	sub_831A8130(ctx, base);
	// 828DC558: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DC55C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828DC560: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828DC564: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828DC568: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828DC56C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 828DC570: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828DC574: 388B0140  addi r4, r11, 0x140
	ctx.r[4].s64 = ctx.r[11].s64 + 320;
	// 828DC578: 38A0049C  li r5, 0x49c
	ctx.r[5].s64 = 1180;
	// 828DC57C: 386003A0  li r3, 0x3a0
	ctx.r[3].s64 = 928;
	// 828DC580: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 828DC584: 48515E65  bl 0x82df23e8
	ctx.lr = 0x828DC588;
	sub_82DF23E8(ctx, base);
	// 828DC588: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828DC58C: 41820024  beq 0x828dc5b0
	if ctx.cr[0].eq {
	pc = 0x828DC5B0; continue 'dispatch;
	}
	// 828DC590: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 828DC594: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 828DC598: 38C0000E  li r6, 0xe
	ctx.r[6].s64 = 14;
	// 828DC59C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828DC5A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DC5A4: 4BFFF3AD  bl 0x828db950
	ctx.lr = 0x828DC5A8;
	sub_828DB950(ctx, base);
	// 828DC5A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DC5AC: 48000008  b 0x828dc5b4
	pc = 0x828DC5B4; continue 'dispatch;
	// 828DC5B0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828DC5B4: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828DC5B8: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 828DC5BC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DC5C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DC5C4: 4BFFD9C5  bl 0x828d9f88
	ctx.lr = 0x828DC5C8;
	sub_828D9F88(ctx, base);
	// 828DC5C8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828DC5CC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DC5D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DC5D4: 4B9E3A2D  bl 0x822c0000
	ctx.lr = 0x828DC5D8;
	sub_822C0000(ctx, base);
	// 828DC5D8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828DC5DC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828DC5E0: 488CBBD4  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DC5E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DC5E8 size=148
    let mut pc: u32 = 0x828DC5E8;
    'dispatch: loop {
        match pc {
            0x828DC5E8 => {
    //   block [0x828DC5E8..0x828DC67C)
	// 828DC5E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DC5EC: 488CBB79  bl 0x831a8164
	ctx.lr = 0x828DC5F0;
	sub_831A8130(ctx, base);
	// 828DC5F0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DC5F4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828DC5F8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828DC5FC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828DC600: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828DC604: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 828DC608: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828DC60C: 388B0140  addi r4, r11, 0x140
	ctx.r[4].s64 = ctx.r[11].s64 + 320;
	// 828DC610: 38A004DE  li r5, 0x4de
	ctx.r[5].s64 = 1246;
	// 828DC614: 386003A0  li r3, 0x3a0
	ctx.r[3].s64 = 928;
	// 828DC618: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 828DC61C: 48515DCD  bl 0x82df23e8
	ctx.lr = 0x828DC620;
	sub_82DF23E8(ctx, base);
	// 828DC620: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828DC624: 41820024  beq 0x828dc648
	if ctx.cr[0].eq {
	pc = 0x828DC648; continue 'dispatch;
	}
	// 828DC628: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 828DC62C: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 828DC630: 38C0000F  li r6, 0xf
	ctx.r[6].s64 = 15;
	// 828DC634: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828DC638: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DC63C: 4BFFF3F5  bl 0x828dba30
	ctx.lr = 0x828DC640;
	sub_828DBA30(ctx, base);
	// 828DC640: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DC644: 48000008  b 0x828dc64c
	pc = 0x828DC64C; continue 'dispatch;
	// 828DC648: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828DC64C: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828DC650: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 828DC654: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DC658: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DC65C: 4BFFD9F5  bl 0x828da050
	ctx.lr = 0x828DC660;
	sub_828DA050(ctx, base);
	// 828DC660: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828DC664: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DC668: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DC66C: 4B9E3995  bl 0x822c0000
	ctx.lr = 0x828DC670;
	sub_822C0000(ctx, base);
	// 828DC670: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828DC674: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828DC678: 488CBB3C  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DC680(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DC680 size=128
    let mut pc: u32 = 0x828DC680;
    'dispatch: loop {
        match pc {
            0x828DC680 => {
    //   block [0x828DC680..0x828DC700)
	// 828DC680: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DC684: 488CBAE9  bl 0x831a816c
	ctx.lr = 0x828DC688;
	sub_831A8130(ctx, base);
	// 828DC688: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DC68C: 3D408337  lis r10, -0x7cc9
	ctx.r[10].s64 = -2093547520;
	// 828DC690: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828DC694: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828DC698: 3BEB1334  addi r31, r11, 0x1334
	ctx.r[31].s64 = ctx.r[11].s64 + 4916;
	// 828DC69C: 816A133C  lwz r11, 0x133c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4924 as u32) ) } as u64;
	// 828DC6A0: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828DC6A4: 40820024  bne 0x828dc6c8
	if !ctx.cr[0].eq {
	pc = 0x828DC6C8; continue 'dispatch;
	}
	// 828DC6A8: 3D208236  lis r9, -0x7dca
	ctx.r[9].s64 = -2110390272;
	// 828DC6AC: 3D00828E  lis r8, -0x7d72
	ctx.r[8].s64 = -2104623104;
	// 828DC6B0: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828DC6B4: 3929A778  addi r9, r9, -0x5888
	ctx.r[9].s64 = ctx.r[9].s64 + -22664;
	// 828DC6B8: 3908A2A8  addi r8, r8, -0x5d58
	ctx.r[8].s64 = ctx.r[8].s64 + -23896;
	// 828DC6BC: 916A133C  stw r11, 0x133c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4924 as u32), ctx.r[11].u32 ) };
	// 828DC6C0: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828DC6C4: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828DC6C8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828DC6CC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828DC6D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DC6D4: 38BE0008  addi r5, r30, 8
	ctx.r[5].s64 = ctx.r[30].s64 + 8;
	// 828DC6D8: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 828DC6DC: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828DC6E0: 4BFEB1F9  bl 0x828c78d8
	ctx.lr = 0x828DC6E4;
	sub_828C78D8(ctx, base);
	// 828DC6E4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DC6E8: 4182000C  beq 0x828dc6f4
	if ctx.cr[0].eq {
	pc = 0x828DC6F4; continue 'dispatch;
	}
	// 828DC6EC: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828DC6F0: 48000008  b 0x828dc6f8
	pc = 0x828DC6F8; continue 'dispatch;
	// 828DC6F4: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828DC6F8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828DC6FC: 488CBAC0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DC700(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828DC700 size=484
    let mut pc: u32 = 0x828DC700;
    'dispatch: loop {
        match pc {
            0x828DC700 => {
    //   block [0x828DC700..0x828DC8E4)
	// 828DC700: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DC704: 488CBA61  bl 0x831a8164
	ctx.lr = 0x828DC708;
	sub_831A8130(ctx, base);
	// 828DC708: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DC70C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828DC710: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828DC714: 3BCB0140  addi r30, r11, 0x140
	ctx.r[30].s64 = ctx.r[11].s64 + 320;
	// 828DC718: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828DC71C: 38A00491  li r5, 0x491
	ctx.r[5].s64 = 1169;
	// 828DC720: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DC724: 386003A0  li r3, 0x3a0
	ctx.r[3].s64 = 928;
	// 828DC728: 48515CC1  bl 0x82df23e8
	ctx.lr = 0x828DC72C;
	sub_82DF23E8(ctx, base);
	// 828DC72C: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 828DC730: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828DC734: 3BABBA80  addi r29, r11, -0x4580
	ctx.r[29].s64 = ctx.r[11].s64 + -17792;
	// 828DC738: 41820028  beq 0x828dc760
	if ctx.cr[0].eq {
	pc = 0x828DC760; continue 'dispatch;
	}
	// 828DC73C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828DC740: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828DC744: 388B6910  addi r4, r11, 0x6910
	ctx.r[4].s64 = ctx.r[11].s64 + 26896;
	// 828DC748: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828DC74C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828DC750: 38C0000E  li r6, 0xe
	ctx.r[6].s64 = 14;
	// 828DC754: 4BFFF1FD  bl 0x828db950
	ctx.lr = 0x828DC758;
	sub_828DB950(ctx, base);
	// 828DC758: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DC75C: 48000008  b 0x828dc764
	pc = 0x828DC764; continue 'dispatch;
	// 828DC760: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828DC764: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828DC768: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DC76C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828DC770: 4BFFD819  bl 0x828d9f88
	ctx.lr = 0x828DC774;
	sub_828D9F88(ctx, base);
	// 828DC774: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828DC778: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DC77C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828DC780: 4B9E3881  bl 0x822c0000
	ctx.lr = 0x828DC784;
	sub_822C0000(ctx, base);
	// 828DC784: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828DC788: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828DC78C: 397F0360  addi r11, r31, 0x360
	ctx.r[11].s64 = ctx.r[31].s64 + 864;
	// 828DC790: 409A0008  bne cr6, 0x828dc798
	if !ctx.cr[6].eq {
	pc = 0x828DC798; continue 'dispatch;
	}
	// 828DC794: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DC798: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828DC79C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828DC7A0: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828DC7A4: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 828DC7A8: 419A0024  beq cr6, 0x828dc7cc
	if ctx.cr[6].eq {
	pc = 0x828DC7CC; continue 'dispatch;
	}
	// 828DC7AC: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 828DC7B0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828DC7B4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DC7B8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828DC7BC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828DC7C0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828DC7C4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DC7C8: 4082FFE8  bne 0x828dc7b0
	if !ctx.cr[0].eq {
	pc = 0x828DC7B0; continue 'dispatch;
	}
	// 828DC7CC: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 828DC7D0: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828DC7D4: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 828DC7D8: 419A0024  beq cr6, 0x828dc7fc
	if ctx.cr[6].eq {
	pc = 0x828DC7FC; continue 'dispatch;
	}
	// 828DC7DC: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 828DC7E0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828DC7E4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DC7E8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828DC7EC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828DC7F0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828DC7F4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DC7F8: 4082FFE8  bne 0x828dc7e0
	if !ctx.cr[0].eq {
	pc = 0x828DC7E0; continue 'dispatch;
	}
	// 828DC7FC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828DC800: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 828DC804: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828DC808: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828DC80C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828DC810: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DC814: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828DC818: 4BEBC719  bl 0x82798f30
	ctx.lr = 0x828DC81C;
	sub_82798F30(ctx, base);
	// 828DC81C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DC820: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DC824: 816B0150  lwz r11, 0x150(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(336 as u32) ) } as u64;
	// 828DC828: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828DC82C: 4E800421  bctrl
	ctx.lr = 0x828DC830;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DC830: C0030010  lfs f0, 0x10(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828DC834: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 828DC838: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DC83C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DC840: 816B0150  lwz r11, 0x150(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(336 as u32) ) } as u64;
	// 828DC844: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828DC848: 4E800421  bctrl
	ctx.lr = 0x828DC84C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DC84C: C0030014  lfs f0, 0x14(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828DC850: D0010094  stfs f0, 0x94(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 828DC854: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DC858: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828DC85C: 38A00496  li r5, 0x496
	ctx.r[5].s64 = 1174;
	// 828DC860: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828DC864: 4B9E3B75  bl 0x822c03d8
	ctx.lr = 0x828DC868;
	sub_822C03D8(ctx, base);
	// 828DC868: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828DC86C: 41820014  beq 0x828dc880
	if ctx.cr[0].eq {
	pc = 0x828DC880; continue 'dispatch;
	}
	// 828DC870: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828DC874: 4BEBEDF5  bl 0x8279b668
	ctx.lr = 0x828DC878;
	sub_8279B668(ctx, base);
	// 828DC878: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DC87C: 48000008  b 0x828dc884
	pc = 0x828DC884; continue 'dispatch;
	// 828DC880: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828DC884: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828DC888: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 828DC88C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DC890: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DC894: 4BCBB3BD  bl 0x82597c50
	ctx.lr = 0x828DC898;
	sub_82597C50(ctx, base);
	// 828DC898: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828DC89C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DC8A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DC8A4: 4B9E375D  bl 0x822c0000
	ctx.lr = 0x828DC8A8;
	sub_822C0000(ctx, base);
	// 828DC8A8: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828DC8AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DC8B0: 419A0008  beq cr6, 0x828dc8b8
	if ctx.cr[6].eq {
	pc = 0x828DC8B8; continue 'dispatch;
	}
	// 828DC8B4: 4B9E3FDD  bl 0x822c0890
	ctx.lr = 0x828DC8B8;
	sub_822C0890(ctx, base);
	// 828DC8B8: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828DC8BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DC8C0: 419A0008  beq cr6, 0x828dc8c8
	if ctx.cr[6].eq {
	pc = 0x828DC8C8; continue 'dispatch;
	}
	// 828DC8C4: 4B9E3FCD  bl 0x822c0890
	ctx.lr = 0x828DC8C8;
	sub_822C0890(ctx, base);
	// 828DC8C8: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828DC8CC: 419A000C  beq cr6, 0x828dc8d8
	if ctx.cr[6].eq {
	pc = 0x828DC8D8; continue 'dispatch;
	}
	// 828DC8D0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828DC8D4: 4B9E3FBD  bl 0x822c0890
	ctx.lr = 0x828DC8D8;
	sub_822C0890(ctx, base);
	// 828DC8D8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828DC8DC: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 828DC8E0: 488CB8D4  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DC8E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828DC8E8 size=484
    let mut pc: u32 = 0x828DC8E8;
    'dispatch: loop {
        match pc {
            0x828DC8E8 => {
    //   block [0x828DC8E8..0x828DCACC)
	// 828DC8E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DC8EC: 488CB879  bl 0x831a8164
	ctx.lr = 0x828DC8F0;
	sub_831A8130(ctx, base);
	// 828DC8F0: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DC8F4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828DC8F8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828DC8FC: 3BCB0140  addi r30, r11, 0x140
	ctx.r[30].s64 = ctx.r[11].s64 + 320;
	// 828DC900: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828DC904: 38A004D3  li r5, 0x4d3
	ctx.r[5].s64 = 1235;
	// 828DC908: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DC90C: 386003A0  li r3, 0x3a0
	ctx.r[3].s64 = 928;
	// 828DC910: 48515AD9  bl 0x82df23e8
	ctx.lr = 0x828DC914;
	sub_82DF23E8(ctx, base);
	// 828DC914: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 828DC918: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828DC91C: 3BABBA80  addi r29, r11, -0x4580
	ctx.r[29].s64 = ctx.r[11].s64 + -17792;
	// 828DC920: 41820028  beq 0x828dc948
	if ctx.cr[0].eq {
	pc = 0x828DC948; continue 'dispatch;
	}
	// 828DC924: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828DC928: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828DC92C: 388B6910  addi r4, r11, 0x6910
	ctx.r[4].s64 = ctx.r[11].s64 + 26896;
	// 828DC930: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828DC934: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828DC938: 38C0000F  li r6, 0xf
	ctx.r[6].s64 = 15;
	// 828DC93C: 4BFFF0F5  bl 0x828dba30
	ctx.lr = 0x828DC940;
	sub_828DBA30(ctx, base);
	// 828DC940: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DC944: 48000008  b 0x828dc94c
	pc = 0x828DC94C; continue 'dispatch;
	// 828DC948: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828DC94C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828DC950: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DC954: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828DC958: 4BFFD6F9  bl 0x828da050
	ctx.lr = 0x828DC95C;
	sub_828DA050(ctx, base);
	// 828DC95C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828DC960: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DC964: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828DC968: 4B9E3699  bl 0x822c0000
	ctx.lr = 0x828DC96C;
	sub_822C0000(ctx, base);
	// 828DC96C: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828DC970: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828DC974: 397F0360  addi r11, r31, 0x360
	ctx.r[11].s64 = ctx.r[31].s64 + 864;
	// 828DC978: 409A0008  bne cr6, 0x828dc980
	if !ctx.cr[6].eq {
	pc = 0x828DC980; continue 'dispatch;
	}
	// 828DC97C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DC980: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828DC984: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828DC988: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828DC98C: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 828DC990: 419A0024  beq cr6, 0x828dc9b4
	if ctx.cr[6].eq {
	pc = 0x828DC9B4; continue 'dispatch;
	}
	// 828DC994: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 828DC998: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828DC99C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DC9A0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828DC9A4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828DC9A8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828DC9AC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DC9B0: 4082FFE8  bne 0x828dc998
	if !ctx.cr[0].eq {
	pc = 0x828DC998; continue 'dispatch;
	}
	// 828DC9B4: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 828DC9B8: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828DC9BC: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 828DC9C0: 419A0024  beq cr6, 0x828dc9e4
	if ctx.cr[6].eq {
	pc = 0x828DC9E4; continue 'dispatch;
	}
	// 828DC9C4: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 828DC9C8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828DC9CC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DC9D0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828DC9D4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828DC9D8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828DC9DC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DC9E0: 4082FFE8  bne 0x828dc9c8
	if !ctx.cr[0].eq {
	pc = 0x828DC9C8; continue 'dispatch;
	}
	// 828DC9E4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828DC9E8: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 828DC9EC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828DC9F0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828DC9F4: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828DC9F8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DC9FC: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828DCA00: 4BEBC531  bl 0x82798f30
	ctx.lr = 0x828DCA04;
	sub_82798F30(ctx, base);
	// 828DCA04: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DCA08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DCA0C: 816B0150  lwz r11, 0x150(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(336 as u32) ) } as u64;
	// 828DCA10: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828DCA14: 4E800421  bctrl
	ctx.lr = 0x828DCA18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DCA18: C0030010  lfs f0, 0x10(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828DCA1C: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 828DCA20: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DCA24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DCA28: 816B0150  lwz r11, 0x150(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(336 as u32) ) } as u64;
	// 828DCA2C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828DCA30: 4E800421  bctrl
	ctx.lr = 0x828DCA34;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DCA34: C0030014  lfs f0, 0x14(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828DCA38: D0010094  stfs f0, 0x94(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 828DCA3C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DCA40: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828DCA44: 38A004D8  li r5, 0x4d8
	ctx.r[5].s64 = 1240;
	// 828DCA48: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828DCA4C: 4B9E398D  bl 0x822c03d8
	ctx.lr = 0x828DCA50;
	sub_822C03D8(ctx, base);
	// 828DCA50: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828DCA54: 41820014  beq 0x828dca68
	if ctx.cr[0].eq {
	pc = 0x828DCA68; continue 'dispatch;
	}
	// 828DCA58: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828DCA5C: 4BEBEC0D  bl 0x8279b668
	ctx.lr = 0x828DCA60;
	sub_8279B668(ctx, base);
	// 828DCA60: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DCA64: 48000008  b 0x828dca6c
	pc = 0x828DCA6C; continue 'dispatch;
	// 828DCA68: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828DCA6C: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828DCA70: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 828DCA74: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DCA78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DCA7C: 4BCBB1D5  bl 0x82597c50
	ctx.lr = 0x828DCA80;
	sub_82597C50(ctx, base);
	// 828DCA80: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828DCA84: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DCA88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DCA8C: 4B9E3575  bl 0x822c0000
	ctx.lr = 0x828DCA90;
	sub_822C0000(ctx, base);
	// 828DCA90: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828DCA94: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DCA98: 419A0008  beq cr6, 0x828dcaa0
	if ctx.cr[6].eq {
	pc = 0x828DCAA0; continue 'dispatch;
	}
	// 828DCA9C: 4B9E3DF5  bl 0x822c0890
	ctx.lr = 0x828DCAA0;
	sub_822C0890(ctx, base);
	// 828DCAA0: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828DCAA4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DCAA8: 419A0008  beq cr6, 0x828dcab0
	if ctx.cr[6].eq {
	pc = 0x828DCAB0; continue 'dispatch;
	}
	// 828DCAAC: 4B9E3DE5  bl 0x822c0890
	ctx.lr = 0x828DCAB0;
	sub_822C0890(ctx, base);
	// 828DCAB0: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828DCAB4: 419A000C  beq cr6, 0x828dcac0
	if ctx.cr[6].eq {
	pc = 0x828DCAC0; continue 'dispatch;
	}
	// 828DCAB8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828DCABC: 4B9E3DD5  bl 0x822c0890
	ctx.lr = 0x828DCAC0;
	sub_822C0890(ctx, base);
	// 828DCAC0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828DCAC4: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 828DCAC8: 488CB6EC  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DCAD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DCAD0 size=128
    let mut pc: u32 = 0x828DCAD0;
    'dispatch: loop {
        match pc {
            0x828DCAD0 => {
    //   block [0x828DCAD0..0x828DCB50)
	// 828DCAD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DCAD4: 488CB699  bl 0x831a816c
	ctx.lr = 0x828DCAD8;
	sub_831A8130(ctx, base);
	// 828DCAD8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DCADC: 3D408337  lis r10, -0x7cc9
	ctx.r[10].s64 = -2093547520;
	// 828DCAE0: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828DCAE4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828DCAE8: 3BEB1340  addi r31, r11, 0x1340
	ctx.r[31].s64 = ctx.r[11].s64 + 4928;
	// 828DCAEC: 816A1348  lwz r11, 0x1348(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4936 as u32) ) } as u64;
	// 828DCAF0: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828DCAF4: 40820024  bne 0x828dcb18
	if !ctx.cr[0].eq {
	pc = 0x828DCB18; continue 'dispatch;
	}
	// 828DCAF8: 3D208290  lis r9, -0x7d70
	ctx.r[9].s64 = -2104492032;
	// 828DCAFC: 3D00828E  lis r8, -0x7d72
	ctx.r[8].s64 = -2104623104;
	// 828DCB00: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828DCB04: 3929DD90  addi r9, r9, -0x2270
	ctx.r[9].s64 = ctx.r[9].s64 + -8816;
	// 828DCB08: 3908AEA0  addi r8, r8, -0x5160
	ctx.r[8].s64 = ctx.r[8].s64 + -20832;
	// 828DCB0C: 916A1348  stw r11, 0x1348(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4936 as u32), ctx.r[11].u32 ) };
	// 828DCB10: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828DCB14: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828DCB18: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828DCB1C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828DCB20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DCB24: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 828DCB28: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 828DCB2C: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828DCB30: 4BD77A91  bl 0x826545c0
	ctx.lr = 0x828DCB34;
	sub_826545C0(ctx, base);
	// 828DCB34: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DCB38: 4182000C  beq 0x828dcb44
	if ctx.cr[0].eq {
	pc = 0x828DCB44; continue 'dispatch;
	}
	// 828DCB3C: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828DCB40: 48000008  b 0x828dcb48
	pc = 0x828DCB48; continue 'dispatch;
	// 828DCB44: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828DCB48: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828DCB4C: 488CB670  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DCB50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DCB50 size=128
    let mut pc: u32 = 0x828DCB50;
    'dispatch: loop {
        match pc {
            0x828DCB50 => {
    //   block [0x828DCB50..0x828DCBD0)
	// 828DCB50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DCB54: 488CB619  bl 0x831a816c
	ctx.lr = 0x828DCB58;
	sub_831A8130(ctx, base);
	// 828DCB58: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DCB5C: 3D408337  lis r10, -0x7cc9
	ctx.r[10].s64 = -2093547520;
	// 828DCB60: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828DCB64: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828DCB68: 3BEB134C  addi r31, r11, 0x134c
	ctx.r[31].s64 = ctx.r[11].s64 + 4940;
	// 828DCB6C: 816A1354  lwz r11, 0x1354(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4948 as u32) ) } as u64;
	// 828DCB70: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828DCB74: 40820024  bne 0x828dcb98
	if !ctx.cr[0].eq {
	pc = 0x828DCB98; continue 'dispatch;
	}
	// 828DCB78: 3D208289  lis r9, -0x7d77
	ctx.r[9].s64 = -2104950784;
	// 828DCB7C: 3D00828E  lis r8, -0x7d72
	ctx.r[8].s64 = -2104623104;
	// 828DCB80: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828DCB84: 392990C8  addi r9, r9, -0x6f38
	ctx.r[9].s64 = ctx.r[9].s64 + -28472;
	// 828DCB88: 3908AD80  addi r8, r8, -0x5280
	ctx.r[8].s64 = ctx.r[8].s64 + -21120;
	// 828DCB8C: 916A1354  stw r11, 0x1354(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4948 as u32), ctx.r[11].u32 ) };
	// 828DCB90: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828DCB94: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828DCB98: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828DCB9C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828DCBA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DCBA4: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 828DCBA8: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 828DCBAC: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828DCBB0: 4BD77A11  bl 0x826545c0
	ctx.lr = 0x828DCBB4;
	sub_826545C0(ctx, base);
	// 828DCBB4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DCBB8: 4182000C  beq 0x828dcbc4
	if ctx.cr[0].eq {
	pc = 0x828DCBC4; continue 'dispatch;
	}
	// 828DCBBC: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828DCBC0: 48000008  b 0x828dcbc8
	pc = 0x828DCBC8; continue 'dispatch;
	// 828DCBC4: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828DCBC8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828DCBCC: 488CB5F0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DCBD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DCBD0 size=128
    let mut pc: u32 = 0x828DCBD0;
    'dispatch: loop {
        match pc {
            0x828DCBD0 => {
    //   block [0x828DCBD0..0x828DCC50)
	// 828DCBD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DCBD4: 488CB599  bl 0x831a816c
	ctx.lr = 0x828DCBD8;
	sub_831A8130(ctx, base);
	// 828DCBD8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DCBDC: 3D408337  lis r10, -0x7cc9
	ctx.r[10].s64 = -2093547520;
	// 828DCBE0: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828DCBE4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828DCBE8: 3BEB1358  addi r31, r11, 0x1358
	ctx.r[31].s64 = ctx.r[11].s64 + 4952;
	// 828DCBEC: 816A1360  lwz r11, 0x1360(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4960 as u32) ) } as u64;
	// 828DCBF0: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828DCBF4: 40820024  bne 0x828dcc18
	if !ctx.cr[0].eq {
	pc = 0x828DCC18; continue 'dispatch;
	}
	// 828DCBF8: 3D208271  lis r9, -0x7d8f
	ctx.r[9].s64 = -2106523648;
	// 828DCBFC: 3D00828E  lis r8, -0x7d72
	ctx.r[8].s64 = -2104623104;
	// 828DCC00: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828DCC04: 39298E48  addi r9, r9, -0x71b8
	ctx.r[9].s64 = ctx.r[9].s64 + -29112;
	// 828DCC08: 3908ADC8  addi r8, r8, -0x5238
	ctx.r[8].s64 = ctx.r[8].s64 + -21048;
	// 828DCC0C: 916A1360  stw r11, 0x1360(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4960 as u32), ctx.r[11].u32 ) };
	// 828DCC10: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828DCC14: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828DCC18: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828DCC1C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828DCC20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DCC24: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 828DCC28: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 828DCC2C: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828DCC30: 4BD77991  bl 0x826545c0
	ctx.lr = 0x828DCC34;
	sub_826545C0(ctx, base);
	// 828DCC34: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DCC38: 4182000C  beq 0x828dcc44
	if ctx.cr[0].eq {
	pc = 0x828DCC44; continue 'dispatch;
	}
	// 828DCC3C: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828DCC40: 48000008  b 0x828dcc48
	pc = 0x828DCC48; continue 'dispatch;
	// 828DCC44: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828DCC48: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828DCC4C: 488CB570  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DCC50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DCC50 size=128
    let mut pc: u32 = 0x828DCC50;
    'dispatch: loop {
        match pc {
            0x828DCC50 => {
    //   block [0x828DCC50..0x828DCCD0)
	// 828DCC50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DCC54: 488CB519  bl 0x831a816c
	ctx.lr = 0x828DCC58;
	sub_831A8130(ctx, base);
	// 828DCC58: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DCC5C: 3D408337  lis r10, -0x7cc9
	ctx.r[10].s64 = -2093547520;
	// 828DCC60: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828DCC64: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828DCC68: 3BEB1364  addi r31, r11, 0x1364
	ctx.r[31].s64 = ctx.r[11].s64 + 4964;
	// 828DCC6C: 816A136C  lwz r11, 0x136c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4972 as u32) ) } as u64;
	// 828DCC70: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828DCC74: 40820024  bne 0x828dcc98
	if !ctx.cr[0].eq {
	pc = 0x828DCC98; continue 'dispatch;
	}
	// 828DCC78: 3D20828F  lis r9, -0x7d71
	ctx.r[9].s64 = -2104557568;
	// 828DCC7C: 3D00828E  lis r8, -0x7d72
	ctx.r[8].s64 = -2104623104;
	// 828DCC80: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828DCC84: 39298DF8  addi r9, r9, -0x7208
	ctx.r[9].s64 = ctx.r[9].s64 + -29192;
	// 828DCC88: 3908AE10  addi r8, r8, -0x51f0
	ctx.r[8].s64 = ctx.r[8].s64 + -20976;
	// 828DCC8C: 916A136C  stw r11, 0x136c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4972 as u32), ctx.r[11].u32 ) };
	// 828DCC90: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828DCC94: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828DCC98: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828DCC9C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828DCCA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DCCA4: 38FE0008  addi r7, r30, 8
	ctx.r[7].s64 = ctx.r[30].s64 + 8;
	// 828DCCA8: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 828DCCAC: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828DCCB0: 48006D21  bl 0x828e39d0
	ctx.lr = 0x828DCCB4;
	sub_828E39D0(ctx, base);
	// 828DCCB4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DCCB8: 4182000C  beq 0x828dccc4
	if ctx.cr[0].eq {
	pc = 0x828DCCC4; continue 'dispatch;
	}
	// 828DCCBC: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828DCCC0: 48000008  b 0x828dccc8
	pc = 0x828DCCC8; continue 'dispatch;
	// 828DCCC4: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828DCCC8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828DCCCC: 488CB4F0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DCCD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DCCD0 size=128
    let mut pc: u32 = 0x828DCCD0;
    'dispatch: loop {
        match pc {
            0x828DCCD0 => {
    //   block [0x828DCCD0..0x828DCD50)
	// 828DCCD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DCCD4: 488CB499  bl 0x831a816c
	ctx.lr = 0x828DCCD8;
	sub_831A8130(ctx, base);
	// 828DCCD8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DCCDC: 3D408337  lis r10, -0x7cc9
	ctx.r[10].s64 = -2093547520;
	// 828DCCE0: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828DCCE4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828DCCE8: 3BEB1370  addi r31, r11, 0x1370
	ctx.r[31].s64 = ctx.r[11].s64 + 4976;
	// 828DCCEC: 816A1378  lwz r11, 0x1378(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4984 as u32) ) } as u64;
	// 828DCCF0: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828DCCF4: 40820024  bne 0x828dcd18
	if !ctx.cr[0].eq {
	pc = 0x828DCD18; continue 'dispatch;
	}
	// 828DCCF8: 3D208289  lis r9, -0x7d77
	ctx.r[9].s64 = -2104950784;
	// 828DCCFC: 3D00828E  lis r8, -0x7d72
	ctx.r[8].s64 = -2104623104;
	// 828DCD00: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828DCD04: 39299108  addi r9, r9, -0x6ef8
	ctx.r[9].s64 = ctx.r[9].s64 + -28408;
	// 828DCD08: 3908AE58  addi r8, r8, -0x51a8
	ctx.r[8].s64 = ctx.r[8].s64 + -20904;
	// 828DCD0C: 916A1378  stw r11, 0x1378(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4984 as u32), ctx.r[11].u32 ) };
	// 828DCD10: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828DCD14: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828DCD18: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828DCD1C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828DCD20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DCD24: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 828DCD28: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 828DCD2C: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828DCD30: 4BD77891  bl 0x826545c0
	ctx.lr = 0x828DCD34;
	sub_826545C0(ctx, base);
	// 828DCD34: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DCD38: 4182000C  beq 0x828dcd44
	if ctx.cr[0].eq {
	pc = 0x828DCD44; continue 'dispatch;
	}
	// 828DCD3C: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828DCD40: 48000008  b 0x828dcd48
	pc = 0x828DCD48; continue 'dispatch;
	// 828DCD44: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828DCD48: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828DCD4C: 488CB470  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DCD50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828DCD50 size=560
    let mut pc: u32 = 0x828DCD50;
    'dispatch: loop {
        match pc {
            0x828DCD50 => {
    //   block [0x828DCD50..0x828DCF80)
	// 828DCD50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DCD54: 488CB419  bl 0x831a816c
	ctx.lr = 0x828DCD58;
	sub_831A8130(ctx, base);
	// 828DCD58: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 828DCD5C: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DCD60: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 828DCD64: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DCD68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DCD6C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828DCD70: 808BE264  lwz r4, -0x1d9c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7580 as u32) ) } as u64;
	// 828DCD74: 48516C95  bl 0x82df3a08
	ctx.lr = 0x828DCD78;
	sub_82DF3A08(ctx, base);
	// 828DCD78: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DCD7C: 387E0008  addi r3, r30, 8
	ctx.r[3].s64 = ctx.r[30].s64 + 8;
	// 828DCD80: 48516589  bl 0x82df3308
	ctx.lr = 0x828DCD84;
	sub_82DF3308(ctx, base);
	// 828DCD84: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828DCD88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DCD8C: 4851669D  bl 0x82df3428
	ctx.lr = 0x828DCD90;
	sub_82DF3428(ctx, base);
	// 828DCD90: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DCD94: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DCD98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DCD9C: 4182000C  beq 0x828dcda8
	if ctx.cr[0].eq {
	pc = 0x828DCDA8; continue 'dispatch;
	}
	// 828DCDA0: 48033B79  bl 0x82910918
	ctx.lr = 0x828DCDA4;
	sub_82910918(ctx, base);
	// 828DCDA4: 480001D0  b 0x828dcf74
	pc = 0x828DCF74; continue 'dispatch;
	// 828DCDA8: 48034479  bl 0x82911220
	ctx.lr = 0x828DCDAC;
	sub_82911220(ctx, base);
	// 828DCDAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DCDB0: 4BF0F3B1  bl 0x827ec160
	ctx.lr = 0x828DCDB4;
	sub_827EC160(ctx, base);
	// 828DCDB4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DCDB8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DCDBC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828DCDC0: 4E800421  bctrl
	ctx.lr = 0x828DCDC4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DCDC4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DCDC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DCDCC: 481E51C5  bl 0x82ac1f90
	ctx.lr = 0x828DCDD0;
	sub_82AC1F90(ctx, base);
	// 828DCDD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DCDD4: 4BF0F38D  bl 0x827ec160
	ctx.lr = 0x828DCDD8;
	sub_827EC160(ctx, base);
	// 828DCDD8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DCDDC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DCDE0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828DCDE4: 4E800421  bctrl
	ctx.lr = 0x828DCDE8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DCDE8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DCDEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DCDF0: 481CE6E9  bl 0x82aab4d8
	ctx.lr = 0x828DCDF4;
	sub_82AAB4D8(ctx, base);
	// 828DCDF4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DCDF8: 807F01CC  lwz r3, 0x1cc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(460 as u32) ) } as u64;
	// 828DCDFC: 4BF0D455  bl 0x827ea250
	ctx.lr = 0x828DCE00;
	sub_827EA250(ctx, base);
	// 828DCE00: 807F01CC  lwz r3, 0x1cc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(460 as u32) ) } as u64;
	// 828DCE04: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DCE08: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DCE0C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828DCE10: 4E800421  bctrl
	ctx.lr = 0x828DCE14;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DCE14: 482D7A05  bl 0x82bb4818
	ctx.lr = 0x828DCE18;
	sub_82BB4818(ctx, base);
	// 828DCE18: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DCE1C: 41820010  beq 0x828dce2c
	if ctx.cr[0].eq {
	pc = 0x828DCE2C; continue 'dispatch;
	}
	// 828DCE20: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DCE24: 807F0260  lwz r3, 0x260(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(608 as u32) ) } as u64;
	// 828DCE28: 48035831  bl 0x82912658
	ctx.lr = 0x828DCE2C;
	sub_82912658(ctx, base);
	// 828DCE2C: 807F0364  lwz r3, 0x364(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(868 as u32) ) } as u64;
	// 828DCE30: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DCE34: 419A0018  beq cr6, 0x828dce4c
	if ctx.cr[6].eq {
	pc = 0x828DCE4C; continue 'dispatch;
	}
	// 828DCE38: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DCE3C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DCE40: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DCE44: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828DCE48: 4E800421  bctrl
	ctx.lr = 0x828DCE4C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DCE4C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828DCE50: 817F038C  lwz r11, 0x38c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(908 as u32) ) } as u64;
	// 828DCE54: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DCE58: C3EA08A4  lfs f31, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828DCE5C: 418200B4  beq 0x828dcf10
	if ctx.cr[0].eq {
	pc = 0x828DCF10; continue 'dispatch;
	}
	// 828DCE60: 817F038C  lwz r11, 0x38c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(908 as u32) ) } as u64;
	// 828DCE64: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 828DCE68: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828DCE6C: 556B003C  rlwinm r11, r11, 0, 0, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828DCE70: 917F038C  stw r11, 0x38c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(908 as u32), ctx.r[11].u32 ) };
	// 828DCE74: 808A7300  lwz r4, 0x7300(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(29440 as u32) ) } as u64;
	// 828DCE78: 48516B91  bl 0x82df3a08
	ctx.lr = 0x828DCE7C;
	sub_82DF3A08(ctx, base);
	// 828DCE7C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828DCE80: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 828DCE84: 388B2DE0  addi r4, r11, 0x2de0
	ctx.r[4].s64 = ctx.r[11].s64 + 11744;
	// 828DCE88: 48516B81  bl 0x82df3a08
	ctx.lr = 0x828DCE8C;
	sub_82DF3A08(ctx, base);
	// 828DCE8C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828DCE90: 39400007  li r10, 7
	ctx.r[10].s64 = 7;
	// 828DCE94: D3E1007C  stfs f31, 0x7c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 828DCE98: D3E10080  stfs f31, 0x80(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 828DCE9C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828DCEA0: D3E10084  stfs f31, 0x84(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 828DCEA4: 91410078  stw r10, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 828DCEA8: D3E10088  stfs f31, 0x88(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 828DCEAC: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 828DCEB0: C00B08A8  lfs f0, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828DCEB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DCEB8: D3E1008C  stfs f31, 0x8c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 828DCEBC: D3E10090  stfs f31, 0x90(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 828DCEC0: D0010094  stfs f0, 0x94(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 828DCEC4: D0010098  stfs f0, 0x98(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 828DCEC8: D001009C  stfs f0, 0x9c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 828DCECC: 4BF0F7CD  bl 0x827ec698
	ctx.lr = 0x828DCED0;
	sub_827EC698(ctx, base);
	// 828DCED0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828DCED4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DCED8: 38AB9704  addi r5, r11, -0x68fc
	ctx.r[5].s64 = ctx.r[11].s64 + -26876;
	// 828DCEDC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DCEE0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DCEE4: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 828DCEE8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828DCEEC: 4E800421  bctrl
	ctx.lr = 0x828DCEF0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DCEF0: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828DCEF4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DCEF8: 419A0008  beq cr6, 0x828dcf00
	if ctx.cr[6].eq {
	pc = 0x828DCF00; continue 'dispatch;
	}
	// 828DCEFC: 4B9E3995  bl 0x822c0890
	ctx.lr = 0x828DCF00;
	sub_822C0890(ctx, base);
	// 828DCF00: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 828DCF04: 48516525  bl 0x82df3428
	ctx.lr = 0x828DCF08;
	sub_82DF3428(ctx, base);
	// 828DCF08: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828DCF0C: 4851651D  bl 0x82df3428
	ctx.lr = 0x828DCF10;
	sub_82DF3428(ctx, base);
	// 828DCF10: 817F038C  lwz r11, 0x38c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(908 as u32) ) } as u64;
	// 828DCF14: 556BFFFF  rlwinm. r11, r11, 0x1f, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DCF18: 40820050  bne 0x828dcf68
	if !ctx.cr[0].eq {
	pc = 0x828DCF68; continue 'dispatch;
	}
	// 828DCF1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DCF20: 4802BF39  bl 0x82908e58
	ctx.lr = 0x828DCF24;
	sub_82908E58(ctx, base);
	// 828DCF24: FF01F800  fcmpu cr6, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 828DCF28: 41990040  bgt cr6, 0x828dcf68
	if ctx.cr[6].gt {
	pc = 0x828DCF68; continue 'dispatch;
	}
	// 828DCF2C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DCF30: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828DCF34: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DCF38: 38AAFC38  addi r5, r10, -0x3c8
	ctx.r[5].s64 = ctx.r[10].s64 + -968;
	// 828DCF3C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DCF40: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 828DCF44: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828DCF48: 4E800421  bctrl
	ctx.lr = 0x828DCF4C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DCF4C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828DCF50: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DCF54: 419A0008  beq cr6, 0x828dcf5c
	if ctx.cr[6].eq {
	pc = 0x828DCF5C; continue 'dispatch;
	}
	// 828DCF58: 4B9E3939  bl 0x822c0890
	ctx.lr = 0x828DCF5C;
	sub_822C0890(ctx, base);
	// 828DCF5C: 817F038C  lwz r11, 0x38c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(908 as u32) ) } as u64;
	// 828DCF60: 616B0002  ori r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u64 | 2;
	// 828DCF64: 917F038C  stw r11, 0x38c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(908 as u32), ctx.r[11].u32 ) };
	// 828DCF68: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DCF6C: 807F036C  lwz r3, 0x36c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(876 as u32) ) } as u64;
	// 828DCF70: 48045A09  bl 0x82922978
	ctx.lr = 0x828DCF74;
	sub_82922978(ctx, base);
	// 828DCF74: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 828DCF78: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 828DCF7C: 488CB240  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DCF80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DCF80 size=80
    let mut pc: u32 = 0x828DCF80;
    'dispatch: loop {
        match pc {
            0x828DCF80 => {
    //   block [0x828DCF80..0x828DCFD0)
	// 828DCF80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DCF84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DCF88: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828DCF8C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DCF90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DCF94: 4802BD95  bl 0x82908d28
	ctx.lr = 0x828DCF98;
	sub_82908D28(ctx, base);
	// 828DCF98: 817F038C  lwz r11, 0x38c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(908 as u32) ) } as u64;
	// 828DCF9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DCFA0: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828DCFA4: 917F038C  stw r11, 0x38c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(908 as u32), ctx.r[11].u32 ) };
	// 828DCFA8: 480333A1  bl 0x82910348
	ctx.lr = 0x828DCFAC;
	sub_82910348(ctx, base);
	// 828DCFAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DCFB0: 480333E1  bl 0x82910390
	ctx.lr = 0x828DCFB4;
	sub_82910390(ctx, base);
	// 828DCFB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DCFB8: 4BC33619  bl 0x825105d0
	ctx.lr = 0x828DCFBC;
	sub_825105D0(ctx, base);
	// 828DCFBC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828DCFC0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DCFC4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DCFC8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828DCFCC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DCFD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828DCFD0 size=8048
    let mut pc: u32 = 0x828DCFD0;
    'dispatch: loop {
        match pc {
            0x828DCFD0 => {
    //   block [0x828DCFD0..0x828DEF40)
	// 828DCFD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DCFD4: 488CB171  bl 0x831a8144
	ctx.lr = 0x828DCFD8;
	sub_831A8130(ctx, base);
	// 828DCFD8: DBA1FF78  stfd f29, -0x88(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.f[29].u64 ) };
	// 828DCFDC: DBC1FF80  stfd f30, -0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), ctx.f[30].u64 ) };
	// 828DCFE0: DBE1FF88  stfd f31, -0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.f[31].u64 ) };
	// 828DCFE4: 9421FE50  stwu r1, -0x1b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-432 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DCFE8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828DCFEC: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 828DCFF0: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 828DCFF4: 7CD53378  mr r21, r6
	ctx.r[21].u64 = ctx.r[6].u64;
	// 828DCFF8: 48033D99  bl 0x82910d90
	ctx.lr = 0x828DCFFC;
	sub_82910D90(ctx, base);
	// 828DCFFC: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 828DD000: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828DD004: 4BC3236D  bl 0x8250f370
	ctx.lr = 0x828DD008;
	sub_8250F370(ctx, base);
	// 828DD008: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 828DD00C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DD010: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 828DD014: 485169F5  bl 0x82df3a08
	ctx.lr = 0x828DD018;
	sub_82DF3A08(ctx, base);
	// 828DD018: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 828DD01C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828DD020: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DD024: 4BC2B75D  bl 0x82508780
	ctx.lr = 0x828DD028;
	sub_82508780(ctx, base);
	// 828DD028: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DD02C: 485163FD  bl 0x82df3428
	ctx.lr = 0x828DD030;
	sub_82DF3428(ctx, base);
	// 828DD030: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 828DD034: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DD038: 808BE264  lwz r4, -0x1d9c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7580 as u32) ) } as u64;
	// 828DD03C: 485169CD  bl 0x82df3a08
	ctx.lr = 0x828DD040;
	sub_82DF3A08(ctx, base);
	// 828DD040: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828DD044: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DD048: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 828DD04C: 4BC2B735  bl 0x82508780
	ctx.lr = 0x828DD050;
	sub_82508780(ctx, base);
	// 828DD050: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DD054: 485163D5  bl 0x82df3428
	ctx.lr = 0x828DD058;
	sub_82DF3428(ctx, base);
	// 828DD058: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828DD05C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828DD060: 389D0028  addi r4, r29, 0x28
	ctx.r[4].s64 = ctx.r[29].s64 + 40;
	// 828DD064: 409A0008  bne cr6, 0x828dd06c
	if !ctx.cr[6].eq {
	pc = 0x828DD06C; continue 'dispatch;
	}
	// 828DD068: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DD06C: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 828DD070: 4BC2B731  bl 0x825087a0
	ctx.lr = 0x828DD074;
	sub_825087A0(ctx, base);
	// 828DD074: 817D02E0  lwz r11, 0x2e0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(736 as u32) ) } as u64;
	// 828DD078: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DD07C: 409A0018  bne cr6, 0x828dd094
	if !ctx.cr[6].eq {
	pc = 0x828DD094; continue 'dispatch;
	}
	// 828DD080: 817D0380  lwz r11, 0x380(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(896 as u32) ) } as u64;
	// 828DD084: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DD088: 915D0384  stw r10, 0x384(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(900 as u32), ctx.r[10].u32 ) };
	// 828DD08C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DD090: 917D0388  stw r11, 0x388(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(904 as u32), ctx.r[11].u32 ) };
	// 828DD094: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828DD098: 4802BD51  bl 0x82908de8
	ctx.lr = 0x828DD09C;
	sub_82908DE8(ctx, base);
	// 828DD09C: 2F03000E  cmpwi cr6, r3, 0xe
	ctx.cr[6].compare_i32(ctx.r[3].s32, 14, &mut ctx.xer);
	// 828DD0A0: 409A0010  bne cr6, 0x828dd0b0
	if !ctx.cr[6].eq {
	pc = 0x828DD0B0; continue 'dispatch;
	}
	// 828DD0A4: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828DD0A8: 808B72F0  lwz r4, 0x72f0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(29424 as u32) ) } as u64;
	// 828DD0AC: 48000014  b 0x828dd0c0
	pc = 0x828DD0C0; continue 'dispatch;
	// 828DD0B0: 2F03000F  cmpwi cr6, r3, 0xf
	ctx.cr[6].compare_i32(ctx.r[3].s32, 15, &mut ctx.xer);
	// 828DD0B4: 409A002C  bne cr6, 0x828dd0e0
	if !ctx.cr[6].eq {
	pc = 0x828DD0E0; continue 'dispatch;
	}
	// 828DD0B8: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828DD0BC: 808B72F4  lwz r4, 0x72f4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(29428 as u32) ) } as u64;
	// 828DD0C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DD0C4: 48516945  bl 0x82df3a08
	ctx.lr = 0x828DD0C8;
	sub_82DF3A08(ctx, base);
	// 828DD0C8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828DD0CC: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 828DD0D0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828DD0D4: 4803352D  bl 0x82910600
	ctx.lr = 0x828DD0D8;
	sub_82910600(ctx, base);
	// 828DD0D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DD0DC: 4851634D  bl 0x82df3428
	ctx.lr = 0x828DD0E0;
	sub_82DF3428(ctx, base);
	// 828DD0E0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828DD0E4: 480337DD  bl 0x829108c0
	ctx.lr = 0x828DD0E8;
	sub_829108C0(ctx, base);
	// 828DD0E8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DD0EC: 41820010  beq 0x828dd0fc
	if ctx.cr[0].eq {
	pc = 0x828DD0FC; continue 'dispatch;
	}
	// 828DD0F0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828DD0F4: 4BC334DD  bl 0x825105d0
	ctx.lr = 0x828DD0F8;
	sub_825105D0(ctx, base);
	// 828DD0F8: 48001E34  b 0x828def2c
	pc = 0x828DEF2C; continue 'dispatch;
	// 828DD0FC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828DD100: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828DD104: 3B2B0140  addi r25, r11, 0x140
	ctx.r[25].s64 = ctx.r[11].s64 + 320;
	// 828DD108: 38A000EC  li r5, 0xec
	ctx.r[5].s64 = 236;
	// 828DD10C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 828DD110: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 828DD114: 4B9E32C5  bl 0x822c03d8
	ctx.lr = 0x828DD118;
	sub_822C03D8(ctx, base);
	// 828DD118: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828DD11C: 41820020  beq 0x828dd13c
	if ctx.cr[0].eq {
	pc = 0x828DD13C; continue 'dispatch;
	}
	// 828DD120: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DD124: 4BF0DB8D  bl 0x827eacb0
	ctx.lr = 0x828DD128;
	sub_827EACB0(ctx, base);
	// 828DD128: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828DD12C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DD130: 396B09D8  addi r11, r11, 0x9d8
	ctx.r[11].s64 = ctx.r[11].s64 + 2520;
	// 828DD134: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828DD138: 48000008  b 0x828dd140
	pc = 0x828DD140; continue 'dispatch;
	// 828DD13C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DD140: 3BDD01CC  addi r30, r29, 0x1cc
	ctx.r[30].s64 = ctx.r[29].s64 + 460;
	// 828DD144: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DD148: 4BF8B139  bl 0x82868280
	ctx.lr = 0x828DD14C;
	sub_82868280(ctx, base);
	// 828DD14C: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828DD150: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DD154: 808B72F8  lwz r4, 0x72f8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(29432 as u32) ) } as u64;
	// 828DD158: 485168B1  bl 0x82df3a08
	ctx.lr = 0x828DD15C;
	sub_82DF3A08(ctx, base);
	// 828DD15C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828DD160: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 828DD164: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 828DD168: 837D01CC  lwz r27, 0x1cc(r29)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(460 as u32) ) } as u64;
	// 828DD16C: 4BC3235D  bl 0x8250f4c8
	ctx.lr = 0x828DD170;
	sub_8250F4C8(ctx, base);
	// 828DD170: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828DD174: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DD178: 3ACBF8EC  addi r22, r11, -0x714
	ctx.r[22].s64 = ctx.r[11].s64 + -1812;
	// 828DD17C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828DD180: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828DD184: C0360008  lfs f1, 8(r22)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(8 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828DD188: 4BF0D7E1  bl 0x827ea968
	ctx.lr = 0x828DD18C;
	sub_827EA968(ctx, base);
	// 828DD18C: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 828DD190: 48514B01  bl 0x82df1c90
	ctx.lr = 0x828DD194;
	sub_82DF1C90(ctx, base);
	// 828DD194: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DD198: 48516291  bl 0x82df3428
	ctx.lr = 0x828DD19C;
	sub_82DF3428(ctx, base);
	// 828DD19C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828DD1A0: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 828DD1A4: 807D01CC  lwz r3, 0x1cc(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(460 as u32) ) } as u64;
	// 828DD1A8: 388A7320  addi r4, r10, 0x7320
	ctx.r[4].s64 = ctx.r[10].s64 + 29472;
	// 828DD1AC: 80AB030C  lwz r5, 0x30c(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(780 as u32) ) } as u64;
	// 828DD1B0: 4BF0D511  bl 0x827ea6c0
	ctx.lr = 0x828DD1B4;
	sub_827EA6C0(ctx, base);
	// 828DD1B4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828DD1B8: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 828DD1BC: 4BF0F40D  bl 0x827ec5c8
	ctx.lr = 0x828DD1C0;
	sub_827EC5C8(ctx, base);
	// 828DD1C0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828DD1C4: 807D01CC  lwz r3, 0x1cc(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(460 as u32) ) } as u64;
	// 828DD1C8: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DD1CC: 4BF0D4FD  bl 0x827ea6c8
	ctx.lr = 0x828DD1D0;
	sub_827EA6C8(ctx, base);
	// 828DD1D0: 80610114  lwz r3, 0x114(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(276 as u32) ) } as u64;
	// 828DD1D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DD1D8: 419A0008  beq cr6, 0x828dd1e0
	if ctx.cr[6].eq {
	pc = 0x828DD1E0; continue 'dispatch;
	}
	// 828DD1DC: 4B9E36B5  bl 0x822c0890
	ctx.lr = 0x828DD1E0;
	sub_822C0890(ctx, base);
	// 828DD1E0: 3F60832D  lis r27, -0x7cd3
	ctx.r[27].s64 = -2094202880;
	// 828DD1E4: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 828DD1E8: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828DD1EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DD1F0: 396B2628  addi r11, r11, 0x2628
	ctx.r[11].s64 = ctx.r[11].s64 + 9768;
	// 828DD1F4: 809B8040  lwz r4, -0x7fc0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-32704 as u32) ) } as u64;
	// 828DD1F8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828DD1FC: 4851680D  bl 0x82df3a08
	ctx.lr = 0x828DD200;
	sub_82DF3A08(ctx, base);
	// 828DD200: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 828DD204: 93A10080  stw r29, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[29].u32 ) };
	// 828DD208: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828DD20C: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828DD210: E8A10080  ld r5, 0x80(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828DD214: 93E100B0  stw r31, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[31].u32 ) };
	// 828DD218: 4BFFF939  bl 0x828dcb50
	ctx.lr = 0x828DD21C;
	sub_828DCB50(ctx, base);
	// 828DD21C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828DD220: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DD224: 38C100B0  addi r6, r1, 0xb0
	ctx.r[6].s64 = ctx.r[1].s64 + 176;
	// 828DD228: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DD22C: C3EB9590  lfs f31, -0x6a70(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27248 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828DD230: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828DD234: 4BF0D57D  bl 0x827ea7b0
	ctx.lr = 0x828DD238;
	sub_827EA7B0(ctx, base);
	// 828DD238: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DD23C: 485161ED  bl 0x82df3428
	ctx.lr = 0x828DD240;
	sub_82DF3428(ctx, base);
	// 828DD240: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828DD244: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DD248: 809B8040  lwz r4, -0x7fc0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-32704 as u32) ) } as u64;
	// 828DD24C: 396B2628  addi r11, r11, 0x2628
	ctx.r[11].s64 = ctx.r[11].s64 + 9768;
	// 828DD250: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828DD254: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828DD258: 485167B1  bl 0x82df3a08
	ctx.lr = 0x828DD25C;
	sub_82DF3A08(ctx, base);
	// 828DD25C: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 828DD260: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 828DD264: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 828DD268: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828DD26C: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 828DD270: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828DD274: 93E100B0  stw r31, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[31].u32 ) };
	// 828DD278: 4BFFF8D9  bl 0x828dcb50
	ctx.lr = 0x828DD27C;
	sub_828DCB50(ctx, base);
	// 828DD27C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828DD280: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DD284: 38C100B0  addi r6, r1, 0xb0
	ctx.r[6].s64 = ctx.r[1].s64 + 176;
	// 828DD288: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DD28C: C3AB0940  lfs f29, 0x940(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2368 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 828DD290: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828DD294: 4BF0D51D  bl 0x827ea7b0
	ctx.lr = 0x828DD298;
	sub_827EA7B0(ctx, base);
	// 828DD298: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DD29C: 4851618D  bl 0x82df3428
	ctx.lr = 0x828DD2A0;
	sub_82DF3428(ctx, base);
	// 828DD2A0: 3F40832D  lis r26, -0x7cd3
	ctx.r[26].s64 = -2094202880;
	// 828DD2A4: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828DD2A8: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828DD2AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DD2B0: 396B2628  addi r11, r11, 0x2628
	ctx.r[11].s64 = ctx.r[11].s64 + 9768;
	// 828DD2B4: 809A8044  lwz r4, -0x7fbc(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-32700 as u32) ) } as u64;
	// 828DD2B8: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828DD2BC: 4851674D  bl 0x82df3a08
	ctx.lr = 0x828DD2C0;
	sub_82DF3A08(ctx, base);
	// 828DD2C0: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 828DD2C4: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 828DD2C8: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 828DD2CC: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828DD2D0: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828DD2D4: 93E100B0  stw r31, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[31].u32 ) };
	// 828DD2D8: 4BFFF879  bl 0x828dcb50
	ctx.lr = 0x828DD2DC;
	sub_828DCB50(ctx, base);
	// 828DD2DC: 38C100B0  addi r6, r1, 0xb0
	ctx.r[6].s64 = ctx.r[1].s64 + 176;
	// 828DD2E0: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DD2E4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DD2E8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828DD2EC: 4BF0D4C5  bl 0x827ea7b0
	ctx.lr = 0x828DD2F0;
	sub_827EA7B0(ctx, base);
	// 828DD2F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DD2F4: 48516135  bl 0x82df3428
	ctx.lr = 0x828DD2F8;
	sub_82DF3428(ctx, base);
	// 828DD2F8: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828DD2FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DD300: 809A8044  lwz r4, -0x7fbc(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-32700 as u32) ) } as u64;
	// 828DD304: 396B2628  addi r11, r11, 0x2628
	ctx.r[11].s64 = ctx.r[11].s64 + 9768;
	// 828DD308: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828DD30C: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828DD310: 485166F9  bl 0x82df3a08
	ctx.lr = 0x828DD314;
	sub_82DF3A08(ctx, base);
	// 828DD314: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828DD318: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 828DD31C: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 828DD320: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 828DD324: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828DD328: 93E100B0  stw r31, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[31].u32 ) };
	// 828DD32C: 4BFFF825  bl 0x828dcb50
	ctx.lr = 0x828DD330;
	sub_828DCB50(ctx, base);
	// 828DD330: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828DD334: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DD338: 38C100B0  addi r6, r1, 0xb0
	ctx.r[6].s64 = ctx.r[1].s64 + 176;
	// 828DD33C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DD340: C02B9588  lfs f1, -0x6a78(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27256 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828DD344: 4BF0D46D  bl 0x827ea7b0
	ctx.lr = 0x828DD348;
	sub_827EA7B0(ctx, base);
	// 828DD348: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DD34C: 485160DD  bl 0x82df3428
	ctx.lr = 0x828DD350;
	sub_82DF3428(ctx, base);
	// 828DD350: 3E80832D  lis r20, -0x7cd3
	ctx.r[20].s64 = -2094202880;
	// 828DD354: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828DD358: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828DD35C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DD360: 396B2628  addi r11, r11, 0x2628
	ctx.r[11].s64 = ctx.r[11].s64 + 9768;
	// 828DD364: 80948048  lwz r4, -0x7fb8(r20)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(-32696 as u32) ) } as u64;
	// 828DD368: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828DD36C: 4851669D  bl 0x82df3a08
	ctx.lr = 0x828DD370;
	sub_82DF3A08(ctx, base);
	// 828DD370: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 828DD374: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 828DD378: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 828DD37C: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828DD380: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828DD384: 93E100B0  stw r31, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[31].u32 ) };
	// 828DD388: 4BFFF7C9  bl 0x828dcb50
	ctx.lr = 0x828DD38C;
	sub_828DCB50(ctx, base);
	// 828DD38C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828DD390: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DD394: 38C100B0  addi r6, r1, 0xb0
	ctx.r[6].s64 = ctx.r[1].s64 + 176;
	// 828DD398: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DD39C: C02B6968  lfs f1, 0x6968(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26984 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828DD3A0: 4BF0D411  bl 0x827ea7b0
	ctx.lr = 0x828DD3A4;
	sub_827EA7B0(ctx, base);
	// 828DD3A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DD3A8: 48516081  bl 0x82df3428
	ctx.lr = 0x828DD3AC;
	sub_82DF3428(ctx, base);
	// 828DD3AC: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828DD3B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DD3B4: 80948048  lwz r4, -0x7fb8(r20)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(-32696 as u32) ) } as u64;
	// 828DD3B8: 396B2628  addi r11, r11, 0x2628
	ctx.r[11].s64 = ctx.r[11].s64 + 9768;
	// 828DD3BC: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828DD3C0: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828DD3C4: 48516645  bl 0x82df3a08
	ctx.lr = 0x828DD3C8;
	sub_82DF3A08(ctx, base);
	// 828DD3C8: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 828DD3CC: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 828DD3D0: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 828DD3D4: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828DD3D8: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828DD3DC: 93E100B0  stw r31, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[31].u32 ) };
	// 828DD3E0: 4BFFF771  bl 0x828dcb50
	ctx.lr = 0x828DD3E4;
	sub_828DCB50(ctx, base);
	// 828DD3E4: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 828DD3E8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DD3EC: 38C100B0  addi r6, r1, 0xb0
	ctx.r[6].s64 = ctx.r[1].s64 + 176;
	// 828DD3F0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DD3F4: C02B6218  lfs f1, 0x6218(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(25112 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828DD3F8: 4BF0D3B9  bl 0x827ea7b0
	ctx.lr = 0x828DD3FC;
	sub_827EA7B0(ctx, base);
	// 828DD3FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DD400: 48516029  bl 0x82df3428
	ctx.lr = 0x828DD404;
	sub_82DF3428(ctx, base);
	// 828DD404: 3E60832D  lis r19, -0x7cd3
	ctx.r[19].s64 = -2094202880;
	// 828DD408: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 828DD40C: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828DD410: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DD414: 396B3A90  addi r11, r11, 0x3a90
	ctx.r[11].s64 = ctx.r[11].s64 + 14992;
	// 828DD418: 8093F434  lwz r4, -0xbcc(r19)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(-3020 as u32) ) } as u64;
	// 828DD41C: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828DD420: 485165E9  bl 0x82df3a08
	ctx.lr = 0x828DD424;
	sub_82DF3A08(ctx, base);
	// 828DD424: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 828DD428: 93A10098  stw r29, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[29].u32 ) };
	// 828DD42C: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828DD430: E8A10098  ld r5, 0x98(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	// 828DD434: 93E100B0  stw r31, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[31].u32 ) };
	// 828DD438: 4BFFF799  bl 0x828dcbd0
	ctx.lr = 0x828DD43C;
	sub_828DCBD0(ctx, base);
	// 828DD43C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828DD440: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DD444: 38C100B0  addi r6, r1, 0xb0
	ctx.r[6].s64 = ctx.r[1].s64 + 176;
	// 828DD448: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DD44C: C02BE830  lfs f1, -0x17d0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6096 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828DD450: 4BF0D361  bl 0x827ea7b0
	ctx.lr = 0x828DD454;
	sub_827EA7B0(ctx, base);
	// 828DD454: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DD458: 48515FD1  bl 0x82df3428
	ctx.lr = 0x828DD45C;
	sub_82DF3428(ctx, base);
	// 828DD45C: 8093F434  lwz r4, -0xbcc(r19)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(-3020 as u32) ) } as u64;
	// 828DD460: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 828DD464: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DD468: 396B3A90  addi r11, r11, 0x3a90
	ctx.r[11].s64 = ctx.r[11].s64 + 14992;
	// 828DD46C: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828DD470: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828DD474: 48516595  bl 0x82df3a08
	ctx.lr = 0x828DD478;
	sub_82DF3A08(ctx, base);
	// 828DD478: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 828DD47C: 93A10098  stw r29, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[29].u32 ) };
	// 828DD480: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828DD484: E8A10098  ld r5, 0x98(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	// 828DD488: 93E100B0  stw r31, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[31].u32 ) };
	// 828DD48C: 4BFFF745  bl 0x828dcbd0
	ctx.lr = 0x828DD490;
	sub_828DCBD0(ctx, base);
	// 828DD490: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828DD494: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DD498: 38C100B0  addi r6, r1, 0xb0
	ctx.r[6].s64 = ctx.r[1].s64 + 176;
	// 828DD49C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DD4A0: C02B9594  lfs f1, -0x6a6c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27244 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828DD4A4: 4BF0D30D  bl 0x827ea7b0
	ctx.lr = 0x828DD4A8;
	sub_827EA7B0(ctx, base);
	// 828DD4A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DD4AC: 48515F7D  bl 0x82df3428
	ctx.lr = 0x828DD4B0;
	sub_82DF3428(ctx, base);
	// 828DD4B0: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828DD4B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DD4B8: 809B8040  lwz r4, -0x7fc0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-32704 as u32) ) } as u64;
	// 828DD4BC: 396BA4B0  addi r11, r11, -0x5b50
	ctx.r[11].s64 = ctx.r[11].s64 + -23376;
	// 828DD4C0: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828DD4C4: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828DD4C8: 48516541  bl 0x82df3a08
	ctx.lr = 0x828DD4CC;
	sub_82DF3A08(ctx, base);
	// 828DD4CC: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828DD4D0: 93A100B8  stw r29, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[29].u32 ) };
	// 828DD4D4: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 828DD4D8: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828DD4DC: 99610098  stb r11, 0x98(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[11].u8 ) };
	// 828DD4E0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DD4E4: 81610098  lwz r11, 0x98(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 828DD4E8: 914100BC  stw r10, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[10].u32 ) };
	// 828DD4EC: 916100C0  stw r11, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 828DD4F0: E8A100B8  ld r5, 0xb8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) };
	// 828DD4F4: E8C100C0  ld r6, 0xc0(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) };
	// 828DD4F8: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DD4FC: 4BFFF755  bl 0x828dcc50
	ctx.lr = 0x828DD500;
	sub_828DCC50(ctx, base);
	// 828DD500: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828DD504: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DD508: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828DD50C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DD510: C3CB08A4  lfs f30, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 828DD514: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828DD518: 4BF0D299  bl 0x827ea7b0
	ctx.lr = 0x828DD51C;
	sub_827EA7B0(ctx, base);
	// 828DD51C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DD520: 48515F09  bl 0x82df3428
	ctx.lr = 0x828DD524;
	sub_82DF3428(ctx, base);
	// 828DD524: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828DD528: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DD52C: 809B8040  lwz r4, -0x7fc0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-32704 as u32) ) } as u64;
	// 828DD530: 396BA4B0  addi r11, r11, -0x5b50
	ctx.r[11].s64 = ctx.r[11].s64 + -23376;
	// 828DD534: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828DD538: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828DD53C: 485164CD  bl 0x82df3a08
	ctx.lr = 0x828DD540;
	sub_82DF3A08(ctx, base);
	// 828DD540: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828DD544: 93A100B8  stw r29, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[29].u32 ) };
	// 828DD548: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 828DD54C: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828DD550: 99610098  stb r11, 0x98(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[11].u8 ) };
	// 828DD554: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DD558: 914100BC  stw r10, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[10].u32 ) };
	// 828DD55C: E8A100B8  ld r5, 0xb8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) };
	// 828DD560: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DD564: 81610098  lwz r11, 0x98(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 828DD568: 916100C0  stw r11, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 828DD56C: E8C100C0  ld r6, 0xc0(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) };
	// 828DD570: 4BFFF6E1  bl 0x828dcc50
	ctx.lr = 0x828DD574;
	sub_828DCC50(ctx, base);
	// 828DD574: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828DD578: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DD57C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DD580: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828DD584: 4BF0D22D  bl 0x827ea7b0
	ctx.lr = 0x828DD588;
	sub_827EA7B0(ctx, base);
	// 828DD588: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DD58C: 48515E9D  bl 0x82df3428
	ctx.lr = 0x828DD590;
	sub_82DF3428(ctx, base);
	// 828DD590: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828DD594: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DD598: 809A8044  lwz r4, -0x7fbc(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-32700 as u32) ) } as u64;
	// 828DD59C: 396BA4B0  addi r11, r11, -0x5b50
	ctx.r[11].s64 = ctx.r[11].s64 + -23376;
	// 828DD5A0: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828DD5A4: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828DD5A8: 48516461  bl 0x82df3a08
	ctx.lr = 0x828DD5AC;
	sub_82DF3A08(ctx, base);
	// 828DD5AC: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828DD5B0: 93A100B8  stw r29, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[29].u32 ) };
	// 828DD5B4: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 828DD5B8: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828DD5BC: 916100BC  stw r11, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[11].u32 ) };
	// 828DD5C0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DD5C4: 99410098  stb r10, 0x98(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[10].u8 ) };
	// 828DD5C8: 81410098  lwz r10, 0x98(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 828DD5CC: 914100C0  stw r10, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[10].u32 ) };
	// 828DD5D0: E8A100B8  ld r5, 0xb8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) };
	// 828DD5D4: E8C100C0  ld r6, 0xc0(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) };
	// 828DD5D8: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DD5DC: 4BFFF675  bl 0x828dcc50
	ctx.lr = 0x828DD5E0;
	sub_828DCC50(ctx, base);
	// 828DD5E0: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828DD5E4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DD5E8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DD5EC: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828DD5F0: 4BF0D1C1  bl 0x827ea7b0
	ctx.lr = 0x828DD5F4;
	sub_827EA7B0(ctx, base);
	// 828DD5F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DD5F8: 48515E31  bl 0x82df3428
	ctx.lr = 0x828DD5FC;
	sub_82DF3428(ctx, base);
	// 828DD5FC: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828DD600: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DD604: 809A8044  lwz r4, -0x7fbc(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-32700 as u32) ) } as u64;
	// 828DD608: 396BA4B0  addi r11, r11, -0x5b50
	ctx.r[11].s64 = ctx.r[11].s64 + -23376;
	// 828DD60C: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828DD610: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828DD614: 485163F5  bl 0x82df3a08
	ctx.lr = 0x828DD618;
	sub_82DF3A08(ctx, base);
	// 828DD618: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828DD61C: 93A100B8  stw r29, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[29].u32 ) };
	// 828DD620: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 828DD624: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828DD628: 99610098  stb r11, 0x98(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[11].u8 ) };
	// 828DD62C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DD630: 914100BC  stw r10, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[10].u32 ) };
	// 828DD634: E8A100B8  ld r5, 0xb8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) };
	// 828DD638: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DD63C: 81610098  lwz r11, 0x98(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 828DD640: 916100C0  stw r11, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 828DD644: E8C100C0  ld r6, 0xc0(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) };
	// 828DD648: 4BFFF609  bl 0x828dcc50
	ctx.lr = 0x828DD64C;
	sub_828DCC50(ctx, base);
	// 828DD64C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828DD650: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DD654: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828DD658: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DD65C: C02B336C  lfs f1, 0x336c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(13164 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828DD660: 4BF0D151  bl 0x827ea7b0
	ctx.lr = 0x828DD664;
	sub_827EA7B0(ctx, base);
	// 828DD664: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DD668: 48515DC1  bl 0x82df3428
	ctx.lr = 0x828DD66C;
	sub_82DF3428(ctx, base);
	// 828DD66C: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828DD670: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DD674: 80948048  lwz r4, -0x7fb8(r20)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(-32696 as u32) ) } as u64;
	// 828DD678: 396BA4B0  addi r11, r11, -0x5b50
	ctx.r[11].s64 = ctx.r[11].s64 + -23376;
	// 828DD67C: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828DD680: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828DD684: 48516385  bl 0x82df3a08
	ctx.lr = 0x828DD688;
	sub_82DF3A08(ctx, base);
	// 828DD688: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 828DD68C: 93A100B8  stw r29, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[29].u32 ) };
	// 828DD690: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 828DD694: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828DD698: 914100BC  stw r10, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[10].u32 ) };
	// 828DD69C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DD6A0: 99610098  stb r11, 0x98(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[11].u8 ) };
	// 828DD6A4: 81610098  lwz r11, 0x98(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 828DD6A8: 916100C0  stw r11, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 828DD6AC: E8A100B8  ld r5, 0xb8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) };
	// 828DD6B0: E8C100C0  ld r6, 0xc0(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) };
	// 828DD6B4: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DD6B8: 4BFFF599  bl 0x828dcc50
	ctx.lr = 0x828DD6BC;
	sub_828DCC50(ctx, base);
	// 828DD6BC: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828DD6C0: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DD6C4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DD6C8: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828DD6CC: 4BF0D0E5  bl 0x827ea7b0
	ctx.lr = 0x828DD6D0;
	sub_827EA7B0(ctx, base);
	// 828DD6D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DD6D4: 48515D55  bl 0x82df3428
	ctx.lr = 0x828DD6D8;
	sub_82DF3428(ctx, base);
	// 828DD6D8: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828DD6DC: 80948048  lwz r4, -0x7fb8(r20)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(-32696 as u32) ) } as u64;
	// 828DD6E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DD6E4: 396BA4B0  addi r11, r11, -0x5b50
	ctx.r[11].s64 = ctx.r[11].s64 + -23376;
	// 828DD6E8: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828DD6EC: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828DD6F0: 48516319  bl 0x82df3a08
	ctx.lr = 0x828DD6F4;
	sub_82DF3A08(ctx, base);
	// 828DD6F4: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 828DD6F8: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 828DD6FC: 93A100B8  stw r29, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[29].u32 ) };
	// 828DD700: 99410098  stb r10, 0x98(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[10].u8 ) };
	// 828DD704: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DD708: 916100BC  stw r11, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[11].u32 ) };
	// 828DD70C: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828DD710: E8A100B8  ld r5, 0xb8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) };
	// 828DD714: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DD718: 81610098  lwz r11, 0x98(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 828DD71C: 916100C0  stw r11, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 828DD720: E8C100C0  ld r6, 0xc0(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) };
	// 828DD724: 4BFFF52D  bl 0x828dcc50
	ctx.lr = 0x828DD728;
	sub_828DCC50(ctx, base);
	// 828DD728: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 828DD72C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DD730: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828DD734: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DD738: C02BD524  lfs f1, -0x2adc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10972 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828DD73C: 4BF0D075  bl 0x827ea7b0
	ctx.lr = 0x828DD740;
	sub_827EA7B0(ctx, base);
	// 828DD740: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DD744: 48515CE5  bl 0x82df3428
	ctx.lr = 0x828DD748;
	sub_82DF3428(ctx, base);
	// 828DD748: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DD74C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828DD750: 816B01A0  lwz r11, 0x1a0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(416 as u32) ) } as u64;
	// 828DD754: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828DD758: 4E800421  bctrl
	ctx.lr = 0x828DD75C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DD75C: 3E80832D  lis r20, -0x7cd3
	ctx.r[20].s64 = -2094202880;
	// 828DD760: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 828DD764: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828DD768: 7C731B78  mr r19, r3
	ctx.r[19].u64 = ctx.r[3].u64;
	// 828DD76C: 396B4048  addi r11, r11, 0x4048
	ctx.r[11].s64 = ctx.r[11].s64 + 16456;
	// 828DD770: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DD774: 8094F488  lwz r4, -0xb78(r20)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(-2936 as u32) ) } as u64;
	// 828DD778: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828DD77C: 4851628D  bl 0x82df3a08
	ctx.lr = 0x828DD780;
	sub_82DF3A08(ctx, base);
	// 828DD780: C0130004  lfs f0, 4(r19)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828DD784: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DD788: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 828DD78C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828DD790: 91610094  stw r11, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 828DD794: 93A10090  stw r29, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[29].u32 ) };
	// 828DD798: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828DD79C: E8A10090  ld r5, 0x90(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 828DD7A0: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DD7A4: 4BFFF52D  bl 0x828dccd0
	ctx.lr = 0x828DD7A8;
	sub_828DCCD0(ctx, base);
	// 828DD7A8: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828DD7AC: C033000C  lfs f1, 0xc(r19)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(12 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828DD7B0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DD7B4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DD7B8: 4BF0CFF9  bl 0x827ea7b0
	ctx.lr = 0x828DD7BC;
	sub_827EA7B0(ctx, base);
	// 828DD7BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DD7C0: 48515C69  bl 0x82df3428
	ctx.lr = 0x828DD7C4;
	sub_82DF3428(ctx, base);
	// 828DD7C4: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 828DD7C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DD7CC: 8094F488  lwz r4, -0xb78(r20)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(-2936 as u32) ) } as u64;
	// 828DD7D0: 396B4048  addi r11, r11, 0x4048
	ctx.r[11].s64 = ctx.r[11].s64 + 16456;
	// 828DD7D4: 93E10094  stw r31, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[31].u32 ) };
	// 828DD7D8: 91610090  stw r11, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 828DD7DC: 4851622D  bl 0x82df3a08
	ctx.lr = 0x828DD7E0;
	sub_82DF3A08(ctx, base);
	// 828DD7E0: C0130008  lfs f0, 8(r19)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828DD7E4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DD7E8: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 828DD7EC: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828DD7F0: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 828DD7F4: 93A10080  stw r29, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[29].u32 ) };
	// 828DD7F8: E8810090  ld r4, 0x90(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 828DD7FC: E8A10080  ld r5, 0x80(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828DD800: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DD804: 4BFFF4CD  bl 0x828dccd0
	ctx.lr = 0x828DD808;
	sub_828DCCD0(ctx, base);
	// 828DD808: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828DD80C: C0330010  lfs f1, 0x10(r19)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(16 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828DD810: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DD814: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DD818: 4BF0CF99  bl 0x827ea7b0
	ctx.lr = 0x828DD81C;
	sub_827EA7B0(ctx, base);
	// 828DD81C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DD820: 48515C09  bl 0x82df3428
	ctx.lr = 0x828DD824;
	sub_82DF3428(ctx, base);
	// 828DD824: 3E80832D  lis r20, -0x7cd3
	ctx.r[20].s64 = -2094202880;
	// 828DD828: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 828DD82C: 93E10094  stw r31, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[31].u32 ) };
	// 828DD830: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DD834: 396B4048  addi r11, r11, 0x4048
	ctx.r[11].s64 = ctx.r[11].s64 + 16456;
	// 828DD838: 8094F49C  lwz r4, -0xb64(r20)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(-2916 as u32) ) } as u64;
	// 828DD83C: 91610090  stw r11, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 828DD840: 485161C9  bl 0x82df3a08
	ctx.lr = 0x828DD844;
	sub_82DF3A08(ctx, base);
	// 828DD844: C01300AC  lfs f0, 0xac(r19)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(172 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828DD848: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DD84C: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 828DD850: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828DD854: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 828DD858: 93A10080  stw r29, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[29].u32 ) };
	// 828DD85C: E8810090  ld r4, 0x90(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 828DD860: E8A10080  ld r5, 0x80(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828DD864: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DD868: 4BFFF469  bl 0x828dccd0
	ctx.lr = 0x828DD86C;
	sub_828DCCD0(ctx, base);
	// 828DD86C: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828DD870: C03300B4  lfs f1, 0xb4(r19)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(180 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828DD874: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DD878: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DD87C: 4BF0CF35  bl 0x827ea7b0
	ctx.lr = 0x828DD880;
	sub_827EA7B0(ctx, base);
	// 828DD880: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DD884: 48515BA5  bl 0x82df3428
	ctx.lr = 0x828DD888;
	sub_82DF3428(ctx, base);
	// 828DD888: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 828DD88C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DD890: 8094F49C  lwz r4, -0xb64(r20)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(-2916 as u32) ) } as u64;
	// 828DD894: 396B4048  addi r11, r11, 0x4048
	ctx.r[11].s64 = ctx.r[11].s64 + 16456;
	// 828DD898: 93E10094  stw r31, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[31].u32 ) };
	// 828DD89C: 91610090  stw r11, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 828DD8A0: 48516169  bl 0x82df3a08
	ctx.lr = 0x828DD8A4;
	sub_82DF3A08(ctx, base);
	// 828DD8A4: C01300B0  lfs f0, 0xb0(r19)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(176 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828DD8A8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DD8AC: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 828DD8B0: 93A10080  stw r29, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[29].u32 ) };
	// 828DD8B4: E8810090  ld r4, 0x90(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 828DD8B8: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DD8BC: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828DD8C0: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 828DD8C4: E8A10080  ld r5, 0x80(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828DD8C8: 4BFFF409  bl 0x828dccd0
	ctx.lr = 0x828DD8CC;
	sub_828DCCD0(ctx, base);
	// 828DD8CC: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828DD8D0: C03300B8  lfs f1, 0xb8(r19)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(184 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828DD8D4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DD8D8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DD8DC: 4BF0CED5  bl 0x827ea7b0
	ctx.lr = 0x828DD8E0;
	sub_827EA7B0(ctx, base);
	// 828DD8E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DD8E4: 48515B45  bl 0x82df3428
	ctx.lr = 0x828DD8E8;
	sub_82DF3428(ctx, base);
	// 828DD8E8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DD8EC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828DD8F0: 816B01A4  lwz r11, 0x1a4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(420 as u32) ) } as u64;
	// 828DD8F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828DD8F8: 4E800421  bctrl
	ctx.lr = 0x828DD8FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DD8FC: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 828DD900: 7C741B78  mr r20, r3
	ctx.r[20].u64 = ctx.r[3].u64;
	// 828DD904: 809B8040  lwz r4, -0x7fc0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-32704 as u32) ) } as u64;
	// 828DD908: 396B4048  addi r11, r11, 0x4048
	ctx.r[11].s64 = ctx.r[11].s64 + 16456;
	// 828DD90C: 93E10094  stw r31, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[31].u32 ) };
	// 828DD910: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DD914: 91610090  stw r11, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 828DD918: 485160F1  bl 0x82df3a08
	ctx.lr = 0x828DD91C;
	sub_82DF3A08(ctx, base);
	// 828DD91C: C01401A4  lfs f0, 0x1a4(r20)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(420 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828DD920: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 828DD924: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DD928: 93A10080  stw r29, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[29].u32 ) };
	// 828DD92C: E8810090  ld r4, 0x90(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 828DD930: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DD934: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828DD938: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 828DD93C: E8A10080  ld r5, 0x80(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828DD940: 4BFFF391  bl 0x828dccd0
	ctx.lr = 0x828DD944;
	sub_828DCCD0(ctx, base);
	// 828DD944: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828DD948: C03401AC  lfs f1, 0x1ac(r20)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(428 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828DD94C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DD950: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DD954: 4BF0CE5D  bl 0x827ea7b0
	ctx.lr = 0x828DD958;
	sub_827EA7B0(ctx, base);
	// 828DD958: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DD95C: 48515ACD  bl 0x82df3428
	ctx.lr = 0x828DD960;
	sub_82DF3428(ctx, base);
	// 828DD960: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 828DD964: 809B8040  lwz r4, -0x7fc0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-32704 as u32) ) } as u64;
	// 828DD968: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DD96C: 396B4048  addi r11, r11, 0x4048
	ctx.r[11].s64 = ctx.r[11].s64 + 16456;
	// 828DD970: 93E10094  stw r31, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[31].u32 ) };
	// 828DD974: 91610090  stw r11, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 828DD978: 48516091  bl 0x82df3a08
	ctx.lr = 0x828DD97C;
	sub_82DF3A08(ctx, base);
	// 828DD97C: C01401A8  lfs f0, 0x1a8(r20)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(424 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828DD980: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 828DD984: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828DD988: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 828DD98C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DD990: 93A10080  stw r29, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[29].u32 ) };
	// 828DD994: E8810090  ld r4, 0x90(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 828DD998: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DD99C: E8A10080  ld r5, 0x80(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828DD9A0: 4BFFF331  bl 0x828dccd0
	ctx.lr = 0x828DD9A4;
	sub_828DCCD0(ctx, base);
	// 828DD9A4: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828DD9A8: C03401B0  lfs f1, 0x1b0(r20)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(432 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828DD9AC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DD9B0: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DD9B4: 4BF0CDFD  bl 0x827ea7b0
	ctx.lr = 0x828DD9B8;
	sub_827EA7B0(ctx, base);
	// 828DD9B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DD9BC: 48515A6D  bl 0x82df3428
	ctx.lr = 0x828DD9C0;
	sub_82DF3428(ctx, base);
	// 828DD9C0: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 828DD9C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DD9C8: 809A8044  lwz r4, -0x7fbc(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-32700 as u32) ) } as u64;
	// 828DD9CC: 396B4048  addi r11, r11, 0x4048
	ctx.r[11].s64 = ctx.r[11].s64 + 16456;
	// 828DD9D0: 93E10094  stw r31, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[31].u32 ) };
	// 828DD9D4: 91610090  stw r11, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 828DD9D8: 48516031  bl 0x82df3a08
	ctx.lr = 0x828DD9DC;
	sub_82DF3A08(ctx, base);
	// 828DD9DC: C01401C0  lfs f0, 0x1c0(r20)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(448 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828DD9E0: 93A10080  stw r29, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[29].u32 ) };
	// 828DD9E4: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 828DD9E8: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828DD9EC: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 828DD9F0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DD9F4: E8810090  ld r4, 0x90(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 828DD9F8: E8A10080  ld r5, 0x80(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828DD9FC: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DDA00: 4BFFF2D1  bl 0x828dccd0
	ctx.lr = 0x828DDA04;
	sub_828DCCD0(ctx, base);
	// 828DDA04: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828DDA08: C03401C8  lfs f1, 0x1c8(r20)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(456 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828DDA0C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DDA10: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DDA14: 4BF0CD9D  bl 0x827ea7b0
	ctx.lr = 0x828DDA18;
	sub_827EA7B0(ctx, base);
	// 828DDA18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DDA1C: 48515A0D  bl 0x82df3428
	ctx.lr = 0x828DDA20;
	sub_82DF3428(ctx, base);
	// 828DDA20: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 828DDA24: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DDA28: 809A8044  lwz r4, -0x7fbc(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-32700 as u32) ) } as u64;
	// 828DDA2C: 396B4048  addi r11, r11, 0x4048
	ctx.r[11].s64 = ctx.r[11].s64 + 16456;
	// 828DDA30: 93E10094  stw r31, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[31].u32 ) };
	// 828DDA34: 91610090  stw r11, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 828DDA38: 48515FD1  bl 0x82df3a08
	ctx.lr = 0x828DDA3C;
	sub_82DF3A08(ctx, base);
	// 828DDA3C: C01401C4  lfs f0, 0x1c4(r20)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(452 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828DDA40: E8810090  ld r4, 0x90(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 828DDA44: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 828DDA48: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828DDA4C: 91610094  stw r11, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 828DDA50: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DDA54: 93A10090  stw r29, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[29].u32 ) };
	// 828DDA58: E8A10090  ld r5, 0x90(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 828DDA5C: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DDA60: 4BFFF271  bl 0x828dccd0
	ctx.lr = 0x828DDA64;
	sub_828DCCD0(ctx, base);
	// 828DDA64: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828DDA68: C03401CC  lfs f1, 0x1cc(r20)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(460 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828DDA6C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DDA70: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DDA74: 4BF0CD3D  bl 0x827ea7b0
	ctx.lr = 0x828DDA78;
	sub_827EA7B0(ctx, base);
	// 828DDA78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DDA7C: 485159AD  bl 0x82df3428
	ctx.lr = 0x828DDA80;
	sub_82DF3428(ctx, base);
	// 828DDA80: 3F60832D  lis r27, -0x7cd3
	ctx.r[27].s64 = -2094202880;
	// 828DDA84: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 828DDA88: 93E10094  stw r31, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[31].u32 ) };
	// 828DDA8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DDA90: 396B4048  addi r11, r11, 0x4048
	ctx.r[11].s64 = ctx.r[11].s64 + 16456;
	// 828DDA94: 809B8060  lwz r4, -0x7fa0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-32672 as u32) ) } as u64;
	// 828DDA98: 91610090  stw r11, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 828DDA9C: 48515F6D  bl 0x82df3a08
	ctx.lr = 0x828DDAA0;
	sub_82DF3A08(ctx, base);
	// 828DDAA0: C01401DC  lfs f0, 0x1dc(r20)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(476 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828DDAA4: E8810090  ld r4, 0x90(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 828DDAA8: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 828DDAAC: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828DDAB0: 93A10080  stw r29, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[29].u32 ) };
	// 828DDAB4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DDAB8: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DDABC: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 828DDAC0: E8A10080  ld r5, 0x80(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828DDAC4: 4BFFF20D  bl 0x828dccd0
	ctx.lr = 0x828DDAC8;
	sub_828DCCD0(ctx, base);
	// 828DDAC8: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828DDACC: C03401E4  lfs f1, 0x1e4(r20)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(484 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828DDAD0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DDAD4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DDAD8: 4BF0CCD9  bl 0x827ea7b0
	ctx.lr = 0x828DDADC;
	sub_827EA7B0(ctx, base);
	// 828DDADC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DDAE0: 48515949  bl 0x82df3428
	ctx.lr = 0x828DDAE4;
	sub_82DF3428(ctx, base);
	// 828DDAE4: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 828DDAE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DDAEC: 809B8060  lwz r4, -0x7fa0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-32672 as u32) ) } as u64;
	// 828DDAF0: 396B4048  addi r11, r11, 0x4048
	ctx.r[11].s64 = ctx.r[11].s64 + 16456;
	// 828DDAF4: 93E10094  stw r31, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[31].u32 ) };
	// 828DDAF8: 91610090  stw r11, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 828DDAFC: 48515F0D  bl 0x82df3a08
	ctx.lr = 0x828DDB00;
	sub_82DF3A08(ctx, base);
	// 828DDB00: C01401E0  lfs f0, 0x1e0(r20)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(480 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828DDB04: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DDB08: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 828DDB0C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828DDB10: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 828DDB14: 93A10080  stw r29, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[29].u32 ) };
	// 828DDB18: E8810090  ld r4, 0x90(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 828DDB1C: E8A10080  ld r5, 0x80(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828DDB20: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DDB24: 4BFFF1AD  bl 0x828dccd0
	ctx.lr = 0x828DDB28;
	sub_828DCCD0(ctx, base);
	// 828DDB28: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828DDB2C: C03401E8  lfs f1, 0x1e8(r20)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(488 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828DDB30: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DDB34: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DDB38: 4BF0CC79  bl 0x827ea7b0
	ctx.lr = 0x828DDB3C;
	sub_827EA7B0(ctx, base);
	// 828DDB3C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DDB40: 485158E9  bl 0x82df3428
	ctx.lr = 0x828DDB44;
	sub_82DF3428(ctx, base);
	// 828DDB44: 3F60832D  lis r27, -0x7cd3
	ctx.r[27].s64 = -2094202880;
	// 828DDB48: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DDB4C: 809BF3F8  lwz r4, -0xc08(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-3080 as u32) ) } as u64;
	// 828DDB50: 48515EB9  bl 0x82df3a08
	ctx.lr = 0x828DDB54;
	sub_82DF3A08(ctx, base);
	// 828DDB54: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DDB58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DDB5C: 808BF420  lwz r4, -0xbe0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3040 as u32) ) } as u64;
	// 828DDB60: 48515EA9  bl 0x82df3a08
	ctx.lr = 0x828DDB64;
	sub_82DF3A08(ctx, base);
	// 828DDB64: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828DDB68: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DDB6C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DDB70: 4BF0C7B1  bl 0x827ea320
	ctx.lr = 0x828DDB74;
	sub_827EA320(ctx, base);
	// 828DDB74: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DDB78: 485158B1  bl 0x82df3428
	ctx.lr = 0x828DDB7C;
	sub_82DF3428(ctx, base);
	// 828DDB7C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DDB80: 485158A9  bl 0x82df3428
	ctx.lr = 0x828DDB84;
	sub_82DF3428(ctx, base);
	// 828DDB84: 3F40832D  lis r26, -0x7cd3
	ctx.r[26].s64 = -2094202880;
	// 828DDB88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DDB8C: 809AF4B4  lwz r4, -0xb4c(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-2892 as u32) ) } as u64;
	// 828DDB90: 48515E79  bl 0x82df3a08
	ctx.lr = 0x828DDB94;
	sub_82DF3A08(ctx, base);
	// 828DDB94: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DDB98: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DDB9C: 808BF4B0  lwz r4, -0xb50(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2896 as u32) ) } as u64;
	// 828DDBA0: 48515E69  bl 0x82df3a08
	ctx.lr = 0x828DDBA4;
	sub_82DF3A08(ctx, base);
	// 828DDBA4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828DDBA8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DDBAC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828DDBB0: 4BF0C771  bl 0x827ea320
	ctx.lr = 0x828DDBB4;
	sub_827EA320(ctx, base);
	// 828DDBB4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DDBB8: 48515871  bl 0x82df3428
	ctx.lr = 0x828DDBBC;
	sub_82DF3428(ctx, base);
	// 828DDBBC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DDBC0: 48515869  bl 0x82df3428
	ctx.lr = 0x828DDBC4;
	sub_82DF3428(ctx, base);
	// 828DDBC4: 3E80832D  lis r20, -0x7cd3
	ctx.r[20].s64 = -2094202880;
	// 828DDBC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DDBCC: 8094F4BC  lwz r4, -0xb44(r20)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(-2884 as u32) ) } as u64;
	// 828DDBD0: 48515E39  bl 0x82df3a08
	ctx.lr = 0x828DDBD4;
	sub_82DF3A08(ctx, base);
	// 828DDBD4: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DDBD8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DDBDC: 808BF4B8  lwz r4, -0xb48(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2888 as u32) ) } as u64;
	// 828DDBE0: 48515E29  bl 0x82df3a08
	ctx.lr = 0x828DDBE4;
	sub_82DF3A08(ctx, base);
	// 828DDBE4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828DDBE8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DDBEC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828DDBF0: 4BF0C731  bl 0x827ea320
	ctx.lr = 0x828DDBF4;
	sub_827EA320(ctx, base);
	// 828DDBF4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DDBF8: 48515831  bl 0x82df3428
	ctx.lr = 0x828DDBFC;
	sub_82DF3428(ctx, base);
	// 828DDBFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DDC00: 48515829  bl 0x82df3428
	ctx.lr = 0x828DDC04;
	sub_82DF3428(ctx, base);
	// 828DDC04: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DDC08: 809AF4B4  lwz r4, -0xb4c(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-2892 as u32) ) } as u64;
	// 828DDC0C: 48515DFD  bl 0x82df3a08
	ctx.lr = 0x828DDC10;
	sub_82DF3A08(ctx, base);
	// 828DDC10: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DDC14: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DDC18: 808BF4C0  lwz r4, -0xb40(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2880 as u32) ) } as u64;
	// 828DDC1C: 48515DED  bl 0x82df3a08
	ctx.lr = 0x828DDC20;
	sub_82DF3A08(ctx, base);
	// 828DDC20: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828DDC24: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DDC28: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828DDC2C: 4BF0C6F5  bl 0x827ea320
	ctx.lr = 0x828DDC30;
	sub_827EA320(ctx, base);
	// 828DDC30: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DDC34: 485157F5  bl 0x82df3428
	ctx.lr = 0x828DDC38;
	sub_82DF3428(ctx, base);
	// 828DDC38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DDC3C: 485157ED  bl 0x82df3428
	ctx.lr = 0x828DDC40;
	sub_82DF3428(ctx, base);
	// 828DDC40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DDC44: 8094F4BC  lwz r4, -0xb44(r20)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(-2884 as u32) ) } as u64;
	// 828DDC48: 48515DC1  bl 0x82df3a08
	ctx.lr = 0x828DDC4C;
	sub_82DF3A08(ctx, base);
	// 828DDC4C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DDC50: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DDC54: 808BF4C4  lwz r4, -0xb3c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2876 as u32) ) } as u64;
	// 828DDC58: 48515DB1  bl 0x82df3a08
	ctx.lr = 0x828DDC5C;
	sub_82DF3A08(ctx, base);
	// 828DDC5C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828DDC60: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DDC64: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828DDC68: 4BF0C6B9  bl 0x827ea320
	ctx.lr = 0x828DDC6C;
	sub_827EA320(ctx, base);
	// 828DDC6C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DDC70: 485157B9  bl 0x82df3428
	ctx.lr = 0x828DDC74;
	sub_82DF3428(ctx, base);
	// 828DDC74: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DDC78: 485157B1  bl 0x82df3428
	ctx.lr = 0x828DDC7C;
	sub_82DF3428(ctx, base);
	// 828DDC7C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DDC80: 809BF3F8  lwz r4, -0xc08(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-3080 as u32) ) } as u64;
	// 828DDC84: 48515D85  bl 0x82df3a08
	ctx.lr = 0x828DDC88;
	sub_82DF3A08(ctx, base);
	// 828DDC88: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828DDC8C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828DDC90: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DDC94: C3EBD5B8  lfs f31, -0x2a48(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10824 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828DDC98: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828DDC9C: 4BF0C69D  bl 0x827ea338
	ctx.lr = 0x828DDCA0;
	sub_827EA338(ctx, base);
	// 828DDCA0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DDCA4: 48515785  bl 0x82df3428
	ctx.lr = 0x828DDCA8;
	sub_82DF3428(ctx, base);
	// 828DDCA8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DDCAC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DDCB0: 808BF3FC  lwz r4, -0xc04(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3076 as u32) ) } as u64;
	// 828DDCB4: 48515D55  bl 0x82df3a08
	ctx.lr = 0x828DDCB8;
	sub_82DF3A08(ctx, base);
	// 828DDCB8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828DDCBC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DDCC0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828DDCC4: 4BF0C675  bl 0x827ea338
	ctx.lr = 0x828DDCC8;
	sub_827EA338(ctx, base);
	// 828DDCC8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DDCCC: 4851575D  bl 0x82df3428
	ctx.lr = 0x828DDCD0;
	sub_82DF3428(ctx, base);
	// 828DDCD0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DDCD4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DDCD8: 808BF400  lwz r4, -0xc00(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3072 as u32) ) } as u64;
	// 828DDCDC: 48515D2D  bl 0x82df3a08
	ctx.lr = 0x828DDCE0;
	sub_82DF3A08(ctx, base);
	// 828DDCE0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828DDCE4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DDCE8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828DDCEC: 4BF0C64D  bl 0x827ea338
	ctx.lr = 0x828DDCF0;
	sub_827EA338(ctx, base);
	// 828DDCF0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DDCF4: 48515735  bl 0x82df3428
	ctx.lr = 0x828DDCF8;
	sub_82DF3428(ctx, base);
	// 828DDCF8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DDCFC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DDD00: 808BF44C  lwz r4, -0xbb4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2996 as u32) ) } as u64;
	// 828DDD04: 48515D05  bl 0x82df3a08
	ctx.lr = 0x828DDD08;
	sub_82DF3A08(ctx, base);
	// 828DDD08: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828DDD0C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DDD10: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828DDD14: 4BF0C625  bl 0x827ea338
	ctx.lr = 0x828DDD18;
	sub_827EA338(ctx, base);
	// 828DDD18: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DDD1C: 4851570D  bl 0x82df3428
	ctx.lr = 0x828DDD20;
	sub_82DF3428(ctx, base);
	// 828DDD20: 3F60832D  lis r27, -0x7cd3
	ctx.r[27].s64 = -2094202880;
	// 828DDD24: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DDD28: 809B8064  lwz r4, -0x7f9c(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-32668 as u32) ) } as u64;
	// 828DDD2C: 48515CDD  bl 0x82df3a08
	ctx.lr = 0x828DDD30;
	sub_82DF3A08(ctx, base);
	// 828DDD30: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828DDD34: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DDD38: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828DDD3C: 4BF0C5FD  bl 0x827ea338
	ctx.lr = 0x828DDD40;
	sub_827EA338(ctx, base);
	// 828DDD40: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DDD44: 485156E5  bl 0x82df3428
	ctx.lr = 0x828DDD48;
	sub_82DF3428(ctx, base);
	// 828DDD48: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DDD4C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DDD50: 808B808C  lwz r4, -0x7f74(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-32628 as u32) ) } as u64;
	// 828DDD54: 48515CB5  bl 0x82df3a08
	ctx.lr = 0x828DDD58;
	sub_82DF3A08(ctx, base);
	// 828DDD58: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828DDD5C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DDD60: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828DDD64: 4BF0C5D5  bl 0x827ea338
	ctx.lr = 0x828DDD68;
	sub_827EA338(ctx, base);
	// 828DDD68: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DDD6C: 485156BD  bl 0x82df3428
	ctx.lr = 0x828DDD70;
	sub_82DF3428(ctx, base);
	// 828DDD70: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DDD74: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DDD78: 808B805C  lwz r4, -0x7fa4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-32676 as u32) ) } as u64;
	// 828DDD7C: 48515C8D  bl 0x82df3a08
	ctx.lr = 0x828DDD80;
	sub_82DF3A08(ctx, base);
	// 828DDD80: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828DDD84: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DDD88: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828DDD8C: 4BF0C5AD  bl 0x827ea338
	ctx.lr = 0x828DDD90;
	sub_827EA338(ctx, base);
	// 828DDD90: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DDD94: 48515695  bl 0x82df3428
	ctx.lr = 0x828DDD98;
	sub_82DF3428(ctx, base);
	// 828DDD98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DDD9C: 809B8064  lwz r4, -0x7f9c(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-32668 as u32) ) } as u64;
	// 828DDDA0: 48515C69  bl 0x82df3a08
	ctx.lr = 0x828DDDA4;
	sub_82DF3A08(ctx, base);
	// 828DDDA4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828DDDA8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DDDAC: 388B01AC  addi r4, r11, 0x1ac
	ctx.r[4].s64 = ctx.r[11].s64 + 428;
	// 828DDDB0: 48515C59  bl 0x82df3a08
	ctx.lr = 0x828DDDB4;
	sub_82DF3A08(ctx, base);
	// 828DDDB4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828DDDB8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828DDDBC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DDDC0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828DDDC4: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828DDDC8: 4BF0C591  bl 0x827ea358
	ctx.lr = 0x828DDDCC;
	sub_827EA358(ctx, base);
	// 828DDDCC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DDDD0: 48515659  bl 0x82df3428
	ctx.lr = 0x828DDDD4;
	sub_82DF3428(ctx, base);
	// 828DDDD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DDDD8: 48515651  bl 0x82df3428
	ctx.lr = 0x828DDDDC;
	sub_82DF3428(ctx, base);
	// 828DDDDC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828DDDE0: 38A00138  li r5, 0x138
	ctx.r[5].s64 = 312;
	// 828DDDE4: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 828DDDE8: 386000C0  li r3, 0xc0
	ctx.r[3].s64 = 192;
	// 828DDDEC: 4B9E25ED  bl 0x822c03d8
	ctx.lr = 0x828DDDF0;
	sub_822C03D8(ctx, base);
	// 828DDDF0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828DDDF4: 41820014  beq 0x828dde08
	if ctx.cr[0].eq {
	pc = 0x828DDE08; continue 'dispatch;
	}
	// 828DDDF8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828DDDFC: 4800138D  bl 0x828df188
	ctx.lr = 0x828DDE00;
	sub_828DF188(ctx, base);
	// 828DDE00: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DDE04: 48000008  b 0x828dde0c
	pc = 0x828DDE0C; continue 'dispatch;
	// 828DDE08: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DDE0C: 3B5D00E4  addi r26, r29, 0xe4
	ctx.r[26].s64 = ctx.r[29].s64 + 228;
	// 828DDE10: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828DDE14: 4BFFDCFD  bl 0x828dbb10
	ctx.lr = 0x828DDE18;
	sub_828DBB10(ctx, base);
	// 828DDE18: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828DDE1C: 4BF0E345  bl 0x827ec160
	ctx.lr = 0x828DDE20;
	sub_827EC160(ctx, base);
	// 828DDE20: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828DDE24: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 828DDE28: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DDE2C: 48038F6D  bl 0x82916d98
	ctx.lr = 0x828DDE30;
	sub_82916D98(ctx, base);
	// 828DDE30: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DDE34: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828DDE38: 816B01A4  lwz r11, 0x1a4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(420 as u32) ) } as u64;
	// 828DDE3C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828DDE40: 4E800421  bctrl
	ctx.lr = 0x828DDE44;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DDE44: 816100F0  lwz r11, 0xf0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(240 as u32) ) } as u64;
	// 828DDE48: C00300C8  lfs f0, 0xc8(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(200 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828DDE4C: D00B0078  stfs f0, 0x78(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 828DDE50: 806100F4  lwz r3, 0xf4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 828DDE54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DDE58: 419A0008  beq cr6, 0x828dde60
	if ctx.cr[6].eq {
	pc = 0x828DDE60; continue 'dispatch;
	}
	// 828DDE5C: 4B9E2A35  bl 0x822c0890
	ctx.lr = 0x828DDE60;
	sub_822C0890(ctx, base);
	// 828DDE60: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828DDE64: 837E0000  lwz r27, 0(r30)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DDE68: 48135819  bl 0x82a13680
	ctx.lr = 0x828DDE6C;
	sub_82A13680(ctx, base);
	// 828DDE6C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DDE70: 817B0010  lwz r11, 0x10(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 828DDE74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DDE78: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828DDE7C: 4E800421  bctrl
	ctx.lr = 0x828DDE80;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DDE80: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828DDE84: 837E0000  lwz r27, 0(r30)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DDE88: 48135801  bl 0x82a13688
	ctx.lr = 0x828DDE8C;
	sub_82A13688(ctx, base);
	// 828DDE8C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DDE90: 817B0014  lwz r11, 0x14(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 828DDE94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DDE98: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828DDE9C: 4E800421  bctrl
	ctx.lr = 0x828DDEA0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DDEA0: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 828DDEA4: 480434D5  bl 0x82921378
	ctx.lr = 0x828DDEA8;
	sub_82921378(ctx, base);
	// 828DDEA8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828DDEAC: 3D408203  lis r10, -0x7dfd
	ctx.r[10].s64 = -2113732608;
	// 828DDEB0: 9381009C  stw r28, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[28].u32 ) };
	// 828DDEB4: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 828DDEB8: 9B8100A0  stb r28, 0xa0(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[28].u8 ) };
	// 828DDEBC: 9B8100A1  stb r28, 0xa1(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(161 as u32), ctx.r[28].u8 ) };
	// 828DDEC0: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 828DDEC4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DDEC8: C00B9450  lfs f0, -0x6bb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828DDECC: C1AA7BC4  lfs f13, 0x7bc4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(31684 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828DDED0: C3E908A8  lfs f31, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828DDED4: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 828DDED8: D1A10094  stfs f13, 0x94(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 828DDEDC: D3E10098  stfs f31, 0x98(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 828DDEE0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DDEE4: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 828DDEE8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828DDEEC: 4E800421  bctrl
	ctx.lr = 0x828DDEF0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DDEF0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DDEF4: 888100A0  lbz r4, 0xa0(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) } as u64;
	// 828DDEF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DDEFC: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828DDF00: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828DDF04: 4E800421  bctrl
	ctx.lr = 0x828DDF08;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DDF08: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 828DDF0C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828DDF10: 4BFFDDD9  bl 0x828dbce8
	ctx.lr = 0x828DDF14;
	sub_828DBCE8(ctx, base);
	// 828DDF14: 817D00FC  lwz r11, 0xfc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(252 as u32) ) } as u64;
	// 828DDF18: 3BDD00FC  addi r30, r29, 0xfc
	ctx.r[30].s64 = ctx.r[29].s64 + 252;
	// 828DDF1C: 809A0000  lwz r4, 0(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DDF20: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DDF24: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DDF28: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828DDF2C: 4E800421  bctrl
	ctx.lr = 0x828DDF30;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DDF30: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DDF34: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828DDF38: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DDF3C: 388BFB78  addi r4, r11, -0x488
	ctx.r[4].s64 = ctx.r[11].s64 + -1160;
	// 828DDF40: 4BFFE741  bl 0x828dc680
	ctx.lr = 0x828DDF44;
	sub_828DC680(ctx, base);
	// 828DDF44: 3F60832D  lis r27, -0x7cd3
	ctx.r[27].s64 = -2094202880;
	// 828DDF48: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DDF4C: 3A810060  addi r20, r1, 0x60
	ctx.r[20].s64 = ctx.r[1].s64 + 96;
	// 828DDF50: 809B0AF0  lwz r4, 0xaf0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(2800 as u32) ) } as u64;
	// 828DDF54: 48515AB5  bl 0x82df3a08
	ctx.lr = 0x828DDF58;
	sub_82DF3A08(ctx, base);
	// 828DDF58: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DDF5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DDF60: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 828DDF64: 4857E1F5  bl 0x82e5c158
	ctx.lr = 0x828DDF68;
	sub_82E5C158(ctx, base);
	// 828DDF68: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DDF6C: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828DDF70: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DDF74: 388B1F48  addi r4, r11, 0x1f48
	ctx.r[4].s64 = ctx.r[11].s64 + 8008;
	// 828DDF78: 4BFFE709  bl 0x828dc680
	ctx.lr = 0x828DDF7C;
	sub_828DC680(ctx, base);
	// 828DDF7C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DDF80: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DDF84: 3A810060  addi r20, r1, 0x60
	ctx.r[20].s64 = ctx.r[1].s64 + 96;
	// 828DDF88: 808B0B24  lwz r4, 0xb24(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2852 as u32) ) } as u64;
	// 828DDF8C: 48515A7D  bl 0x82df3a08
	ctx.lr = 0x828DDF90;
	sub_82DF3A08(ctx, base);
	// 828DDF90: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DDF94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DDF98: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 828DDF9C: 4857E1BD  bl 0x82e5c158
	ctx.lr = 0x828DDFA0;
	sub_82E5C158(ctx, base);
	// 828DDFA0: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DDFA4: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828DDFA8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DDFAC: 388B1040  addi r4, r11, 0x1040
	ctx.r[4].s64 = ctx.r[11].s64 + 4160;
	// 828DDFB0: 4BFFE6D1  bl 0x828dc680
	ctx.lr = 0x828DDFB4;
	sub_828DC680(ctx, base);
	// 828DDFB4: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DDFB8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DDFBC: 3A810060  addi r20, r1, 0x60
	ctx.r[20].s64 = ctx.r[1].s64 + 96;
	// 828DDFC0: 808B0B28  lwz r4, 0xb28(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2856 as u32) ) } as u64;
	// 828DDFC4: 48515A45  bl 0x82df3a08
	ctx.lr = 0x828DDFC8;
	sub_82DF3A08(ctx, base);
	// 828DDFC8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DDFCC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DDFD0: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 828DDFD4: 4857E185  bl 0x82e5c158
	ctx.lr = 0x828DDFD8;
	sub_82E5C158(ctx, base);
	// 828DDFD8: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DDFDC: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 828DDFE0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DDFE4: 388B8A60  addi r4, r11, -0x75a0
	ctx.r[4].s64 = ctx.r[11].s64 + -30112;
	// 828DDFE8: 4BF8B0C1  bl 0x828690a8
	ctx.lr = 0x828DDFEC;
	sub_828690A8(ctx, base);
	// 828DDFEC: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DDFF0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DDFF4: 3A810060  addi r20, r1, 0x60
	ctx.r[20].s64 = ctx.r[1].s64 + 96;
	// 828DDFF8: 808B0B2C  lwz r4, 0xb2c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2860 as u32) ) } as u64;
	// 828DDFFC: 48515A0D  bl 0x82df3a08
	ctx.lr = 0x828DE000;
	sub_82DF3A08(ctx, base);
	// 828DE000: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DE004: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DE008: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 828DE00C: 4857E14D  bl 0x82e5c158
	ctx.lr = 0x828DE010;
	sub_82E5C158(ctx, base);
	// 828DE010: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DE014: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828DE018: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DE01C: 388B1408  addi r4, r11, 0x1408
	ctx.r[4].s64 = ctx.r[11].s64 + 5128;
	// 828DE020: 4BFFE661  bl 0x828dc680
	ctx.lr = 0x828DE024;
	sub_828DC680(ctx, base);
	// 828DE024: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DE028: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DE02C: 3A810060  addi r20, r1, 0x60
	ctx.r[20].s64 = ctx.r[1].s64 + 96;
	// 828DE030: 808B0B30  lwz r4, 0xb30(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2864 as u32) ) } as u64;
	// 828DE034: 485159D5  bl 0x82df3a08
	ctx.lr = 0x828DE038;
	sub_82DF3A08(ctx, base);
	// 828DE038: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DE03C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DE040: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 828DE044: 4857E115  bl 0x82e5c158
	ctx.lr = 0x828DE048;
	sub_82E5C158(ctx, base);
	// 828DE048: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DE04C: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828DE050: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DE054: 388B11C8  addi r4, r11, 0x11c8
	ctx.r[4].s64 = ctx.r[11].s64 + 4552;
	// 828DE058: 4BFFE629  bl 0x828dc680
	ctx.lr = 0x828DE05C;
	sub_828DC680(ctx, base);
	// 828DE05C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DE060: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DE064: 3A810060  addi r20, r1, 0x60
	ctx.r[20].s64 = ctx.r[1].s64 + 96;
	// 828DE068: 808B0B34  lwz r4, 0xb34(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2868 as u32) ) } as u64;
	// 828DE06C: 4851599D  bl 0x82df3a08
	ctx.lr = 0x828DE070;
	sub_82DF3A08(ctx, base);
	// 828DE070: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DE074: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DE078: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 828DE07C: 4857E0DD  bl 0x82e5c158
	ctx.lr = 0x828DE080;
	sub_82E5C158(ctx, base);
	// 828DE080: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DE084: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828DE088: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DE08C: 388B1478  addi r4, r11, 0x1478
	ctx.r[4].s64 = ctx.r[11].s64 + 5240;
	// 828DE090: 4BFFE5F1  bl 0x828dc680
	ctx.lr = 0x828DE094;
	sub_828DC680(ctx, base);
	// 828DE094: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DE098: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DE09C: 3A810060  addi r20, r1, 0x60
	ctx.r[20].s64 = ctx.r[1].s64 + 96;
	// 828DE0A0: 808B80A4  lwz r4, -0x7f5c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-32604 as u32) ) } as u64;
	// 828DE0A4: 48515965  bl 0x82df3a08
	ctx.lr = 0x828DE0A8;
	sub_82DF3A08(ctx, base);
	// 828DE0A8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DE0AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DE0B0: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 828DE0B4: 4857E0A5  bl 0x82e5c158
	ctx.lr = 0x828DE0B8;
	sub_82E5C158(ctx, base);
	// 828DE0B8: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DE0BC: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828DE0C0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DE0C4: 388B0FD0  addi r4, r11, 0xfd0
	ctx.r[4].s64 = ctx.r[11].s64 + 4048;
	// 828DE0C8: 4BFFE5B9  bl 0x828dc680
	ctx.lr = 0x828DE0CC;
	sub_828DC680(ctx, base);
	// 828DE0CC: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DE0D0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DE0D4: 3A810060  addi r20, r1, 0x60
	ctx.r[20].s64 = ctx.r[1].s64 + 96;
	// 828DE0D8: 808B80A8  lwz r4, -0x7f58(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-32600 as u32) ) } as u64;
	// 828DE0DC: 4851592D  bl 0x82df3a08
	ctx.lr = 0x828DE0E0;
	sub_82DF3A08(ctx, base);
	// 828DE0E0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DE0E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DE0E8: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 828DE0EC: 4857E06D  bl 0x82e5c158
	ctx.lr = 0x828DE0F0;
	sub_82E5C158(ctx, base);
	// 828DE0F0: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DE0F4: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828DE0F8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DE0FC: 388B1238  addi r4, r11, 0x1238
	ctx.r[4].s64 = ctx.r[11].s64 + 4664;
	// 828DE100: 4BFFE581  bl 0x828dc680
	ctx.lr = 0x828DE104;
	sub_828DC680(ctx, base);
	// 828DE104: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DE108: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DE10C: 3A810060  addi r20, r1, 0x60
	ctx.r[20].s64 = ctx.r[1].s64 + 96;
	// 828DE110: 808B80A0  lwz r4, -0x7f60(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-32608 as u32) ) } as u64;
	// 828DE114: 485158F5  bl 0x82df3a08
	ctx.lr = 0x828DE118;
	sub_82DF3A08(ctx, base);
	// 828DE118: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DE11C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DE120: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 828DE124: 4857E035  bl 0x82e5c158
	ctx.lr = 0x828DE128;
	sub_82E5C158(ctx, base);
	// 828DE128: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DE12C: 3D608294  lis r11, -0x7d6c
	ctx.r[11].s64 = -2104229888;
	// 828DE130: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DE134: 388BC478  addi r4, r11, -0x3b88
	ctx.r[4].s64 = ctx.r[11].s64 + -15240;
	// 828DE138: 4BF8AF71  bl 0x828690a8
	ctx.lr = 0x828DE13C;
	sub_828690A8(ctx, base);
	// 828DE13C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DE140: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DE144: 3A810060  addi r20, r1, 0x60
	ctx.r[20].s64 = ctx.r[1].s64 + 96;
	// 828DE148: 808B0AF8  lwz r4, 0xaf8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2808 as u32) ) } as u64;
	// 828DE14C: 485158BD  bl 0x82df3a08
	ctx.lr = 0x828DE150;
	sub_82DF3A08(ctx, base);
	// 828DE150: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DE154: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DE158: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 828DE15C: 4857DFFD  bl 0x82e5c158
	ctx.lr = 0x828DE160;
	sub_82E5C158(ctx, base);
	// 828DE160: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DE164: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828DE168: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DE16C: 388B19E8  addi r4, r11, 0x19e8
	ctx.r[4].s64 = ctx.r[11].s64 + 6632;
	// 828DE170: 4BFFE511  bl 0x828dc680
	ctx.lr = 0x828DE174;
	sub_828DC680(ctx, base);
	// 828DE174: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DE178: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DE17C: 3A810060  addi r20, r1, 0x60
	ctx.r[20].s64 = ctx.r[1].s64 + 96;
	// 828DE180: 808B0AF4  lwz r4, 0xaf4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2804 as u32) ) } as u64;
	// 828DE184: 48515885  bl 0x82df3a08
	ctx.lr = 0x828DE188;
	sub_82DF3A08(ctx, base);
	// 828DE188: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DE18C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DE190: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 828DE194: 4857DFC5  bl 0x82e5c158
	ctx.lr = 0x828DE198;
	sub_82E5C158(ctx, base);
	// 828DE198: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DE19C: 3D608294  lis r11, -0x7d6c
	ctx.r[11].s64 = -2104229888;
	// 828DE1A0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DE1A4: 388BC9E8  addi r4, r11, -0x3618
	ctx.r[4].s64 = ctx.r[11].s64 + -13848;
	// 828DE1A8: 4BF8AF01  bl 0x828690a8
	ctx.lr = 0x828DE1AC;
	sub_828690A8(ctx, base);
	// 828DE1AC: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DE1B0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DE1B4: 3A810060  addi r20, r1, 0x60
	ctx.r[20].s64 = ctx.r[1].s64 + 96;
	// 828DE1B8: 808B0AFC  lwz r4, 0xafc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2812 as u32) ) } as u64;
	// 828DE1BC: 4851584D  bl 0x82df3a08
	ctx.lr = 0x828DE1C0;
	sub_82DF3A08(ctx, base);
	// 828DE1C0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DE1C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DE1C8: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 828DE1CC: 4857DF8D  bl 0x82e5c158
	ctx.lr = 0x828DE1D0;
	sub_82E5C158(ctx, base);
	// 828DE1D0: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DE1D4: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 828DE1D8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DE1DC: 388B5B88  addi r4, r11, 0x5b88
	ctx.r[4].s64 = ctx.r[11].s64 + 23432;
	// 828DE1E0: 4BF8AEC9  bl 0x828690a8
	ctx.lr = 0x828DE1E4;
	sub_828690A8(ctx, base);
	// 828DE1E4: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DE1E8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DE1EC: 3A810060  addi r20, r1, 0x60
	ctx.r[20].s64 = ctx.r[1].s64 + 96;
	// 828DE1F0: 808B0B10  lwz r4, 0xb10(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2832 as u32) ) } as u64;
	// 828DE1F4: 48515815  bl 0x82df3a08
	ctx.lr = 0x828DE1F8;
	sub_82DF3A08(ctx, base);
	// 828DE1F8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DE1FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DE200: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 828DE204: 4857DF55  bl 0x82e5c158
	ctx.lr = 0x828DE208;
	sub_82E5C158(ctx, base);
	// 828DE208: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DE20C: 3D608292  lis r11, -0x7d6e
	ctx.r[11].s64 = -2104360960;
	// 828DE210: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DE214: 388B7E40  addi r4, r11, 0x7e40
	ctx.r[4].s64 = ctx.r[11].s64 + 32320;
	// 828DE218: 4BF8AE91  bl 0x828690a8
	ctx.lr = 0x828DE21C;
	sub_828690A8(ctx, base);
	// 828DE21C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DE220: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DE224: 3A810060  addi r20, r1, 0x60
	ctx.r[20].s64 = ctx.r[1].s64 + 96;
	// 828DE228: 808B0B40  lwz r4, 0xb40(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2880 as u32) ) } as u64;
	// 828DE22C: 485157DD  bl 0x82df3a08
	ctx.lr = 0x828DE230;
	sub_82DF3A08(ctx, base);
	// 828DE230: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DE234: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DE238: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 828DE23C: 4857DF1D  bl 0x82e5c158
	ctx.lr = 0x828DE240;
	sub_82E5C158(ctx, base);
	// 828DE240: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DE244: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 828DE248: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DE24C: 388B7F40  addi r4, r11, 0x7f40
	ctx.r[4].s64 = ctx.r[11].s64 + 32576;
	// 828DE250: 4BF8AE59  bl 0x828690a8
	ctx.lr = 0x828DE254;
	sub_828690A8(ctx, base);
	// 828DE254: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DE258: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DE25C: 3A810060  addi r20, r1, 0x60
	ctx.r[20].s64 = ctx.r[1].s64 + 96;
	// 828DE260: 808B0B48  lwz r4, 0xb48(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2888 as u32) ) } as u64;
	// 828DE264: 485157A5  bl 0x82df3a08
	ctx.lr = 0x828DE268;
	sub_82DF3A08(ctx, base);
	// 828DE268: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DE26C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DE270: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 828DE274: 4857DEE5  bl 0x82e5c158
	ctx.lr = 0x828DE278;
	sub_82E5C158(ctx, base);
	// 828DE278: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DE27C: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 828DE280: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DE284: 388B8648  addi r4, r11, -0x79b8
	ctx.r[4].s64 = ctx.r[11].s64 + -31160;
	// 828DE288: 4BF8AE21  bl 0x828690a8
	ctx.lr = 0x828DE28C;
	sub_828690A8(ctx, base);
	// 828DE28C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DE290: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DE294: 3A810060  addi r20, r1, 0x60
	ctx.r[20].s64 = ctx.r[1].s64 + 96;
	// 828DE298: 808B0BA4  lwz r4, 0xba4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2980 as u32) ) } as u64;
	// 828DE29C: 4851576D  bl 0x82df3a08
	ctx.lr = 0x828DE2A0;
	sub_82DF3A08(ctx, base);
	// 828DE2A0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DE2A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DE2A8: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 828DE2AC: 4857DEAD  bl 0x82e5c158
	ctx.lr = 0x828DE2B0;
	sub_82E5C158(ctx, base);
	// 828DE2B0: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DE2B4: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 828DE2B8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DE2BC: 388B8420  addi r4, r11, -0x7be0
	ctx.r[4].s64 = ctx.r[11].s64 + -31712;
	// 828DE2C0: 4BF8ADE9  bl 0x828690a8
	ctx.lr = 0x828DE2C4;
	sub_828690A8(ctx, base);
	// 828DE2C4: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DE2C8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DE2CC: 3A810060  addi r20, r1, 0x60
	ctx.r[20].s64 = ctx.r[1].s64 + 96;
	// 828DE2D0: 808B0BA8  lwz r4, 0xba8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2984 as u32) ) } as u64;
	// 828DE2D4: 48515735  bl 0x82df3a08
	ctx.lr = 0x828DE2D8;
	sub_82DF3A08(ctx, base);
	// 828DE2D8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DE2DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DE2E0: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 828DE2E4: 4857DE75  bl 0x82e5c158
	ctx.lr = 0x828DE2E8;
	sub_82E5C158(ctx, base);
	// 828DE2E8: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DE2EC: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 828DE2F0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DE2F4: 388BA7E0  addi r4, r11, -0x5820
	ctx.r[4].s64 = ctx.r[11].s64 + -22560;
	// 828DE2F8: 4BF8ADB1  bl 0x828690a8
	ctx.lr = 0x828DE2FC;
	sub_828690A8(ctx, base);
	// 828DE2FC: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DE300: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DE304: 3A810060  addi r20, r1, 0x60
	ctx.r[20].s64 = ctx.r[1].s64 + 96;
	// 828DE308: 808B0BA0  lwz r4, 0xba0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2976 as u32) ) } as u64;
	// 828DE30C: 485156FD  bl 0x82df3a08
	ctx.lr = 0x828DE310;
	sub_82DF3A08(ctx, base);
	// 828DE310: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DE314: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DE318: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 828DE31C: 4857DE3D  bl 0x82e5c158
	ctx.lr = 0x828DE320;
	sub_82E5C158(ctx, base);
	// 828DE320: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DE324: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 828DE328: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DE32C: 388B7AF8  addi r4, r11, 0x7af8
	ctx.r[4].s64 = ctx.r[11].s64 + 31480;
	// 828DE330: 4BF8AD79  bl 0x828690a8
	ctx.lr = 0x828DE334;
	sub_828690A8(ctx, base);
	// 828DE334: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DE338: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DE33C: 3A810060  addi r20, r1, 0x60
	ctx.r[20].s64 = ctx.r[1].s64 + 96;
	// 828DE340: 808B0B18  lwz r4, 0xb18(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2840 as u32) ) } as u64;
	// 828DE344: 485156C5  bl 0x82df3a08
	ctx.lr = 0x828DE348;
	sub_82DF3A08(ctx, base);
	// 828DE348: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DE34C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DE350: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 828DE354: 4857DE05  bl 0x82e5c158
	ctx.lr = 0x828DE358;
	sub_82E5C158(ctx, base);
	// 828DE358: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DE35C: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 828DE360: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DE364: 388B97E8  addi r4, r11, -0x6818
	ctx.r[4].s64 = ctx.r[11].s64 + -26648;
	// 828DE368: 4BF8AD41  bl 0x828690a8
	ctx.lr = 0x828DE36C;
	sub_828690A8(ctx, base);
	// 828DE36C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DE370: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DE374: 808B0B08  lwz r4, 0xb08(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2824 as u32) ) } as u64;
	// 828DE378: 3A810060  addi r20, r1, 0x60
	ctx.r[20].s64 = ctx.r[1].s64 + 96;
	// 828DE37C: 4851568D  bl 0x82df3a08
	ctx.lr = 0x828DE380;
	sub_82DF3A08(ctx, base);
	// 828DE380: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DE384: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DE388: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 828DE38C: 4857DDCD  bl 0x82e5c158
	ctx.lr = 0x828DE390;
	sub_82E5C158(ctx, base);
	// 828DE390: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DE394: 3D608294  lis r11, -0x7d6c
	ctx.r[11].s64 = -2104229888;
	// 828DE398: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DE39C: 388BA290  addi r4, r11, -0x5d70
	ctx.r[4].s64 = ctx.r[11].s64 + -23920;
	// 828DE3A0: 4BF8AD09  bl 0x828690a8
	ctx.lr = 0x828DE3A4;
	sub_828690A8(ctx, base);
	// 828DE3A4: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DE3A8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DE3AC: 3A810060  addi r20, r1, 0x60
	ctx.r[20].s64 = ctx.r[1].s64 + 96;
	// 828DE3B0: 808B0B0C  lwz r4, 0xb0c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2828 as u32) ) } as u64;
	// 828DE3B4: 48515655  bl 0x82df3a08
	ctx.lr = 0x828DE3B8;
	sub_82DF3A08(ctx, base);
	// 828DE3B8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DE3BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DE3C0: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 828DE3C4: 4857DD95  bl 0x82e5c158
	ctx.lr = 0x828DE3C8;
	sub_82E5C158(ctx, base);
	// 828DE3C8: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DE3CC: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 828DE3D0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DE3D4: 388B5E50  addi r4, r11, 0x5e50
	ctx.r[4].s64 = ctx.r[11].s64 + 24144;
	// 828DE3D8: 4BF8ACD1  bl 0x828690a8
	ctx.lr = 0x828DE3DC;
	sub_828690A8(ctx, base);
	// 828DE3DC: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DE3E0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DE3E4: 3A810060  addi r20, r1, 0x60
	ctx.r[20].s64 = ctx.r[1].s64 + 96;
	// 828DE3E8: 808B0B50  lwz r4, 0xb50(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2896 as u32) ) } as u64;
	// 828DE3EC: 4851561D  bl 0x82df3a08
	ctx.lr = 0x828DE3F0;
	sub_82DF3A08(ctx, base);
	// 828DE3F0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DE3F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DE3F8: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 828DE3FC: 4857DD5D  bl 0x82e5c158
	ctx.lr = 0x828DE400;
	sub_82E5C158(ctx, base);
	// 828DE400: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DE404: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 828DE408: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DE40C: 388B60A0  addi r4, r11, 0x60a0
	ctx.r[4].s64 = ctx.r[11].s64 + 24736;
	// 828DE410: 4BF8AC99  bl 0x828690a8
	ctx.lr = 0x828DE414;
	sub_828690A8(ctx, base);
	// 828DE414: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DE418: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DE41C: 3A810060  addi r20, r1, 0x60
	ctx.r[20].s64 = ctx.r[1].s64 + 96;
	// 828DE420: 808B0B54  lwz r4, 0xb54(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2900 as u32) ) } as u64;
	// 828DE424: 485155E5  bl 0x82df3a08
	ctx.lr = 0x828DE428;
	sub_82DF3A08(ctx, base);
	// 828DE428: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DE42C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DE430: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 828DE434: 4857DD25  bl 0x82e5c158
	ctx.lr = 0x828DE438;
	sub_82E5C158(ctx, base);
	// 828DE438: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DE43C: 3D608292  lis r11, -0x7d6e
	ctx.r[11].s64 = -2104360960;
	// 828DE440: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DE444: 388B4378  addi r4, r11, 0x4378
	ctx.r[4].s64 = ctx.r[11].s64 + 17272;
	// 828DE448: 4BF8AC61  bl 0x828690a8
	ctx.lr = 0x828DE44C;
	sub_828690A8(ctx, base);
	// 828DE44C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DE450: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DE454: 3A810060  addi r20, r1, 0x60
	ctx.r[20].s64 = ctx.r[1].s64 + 96;
	// 828DE458: 808B0B58  lwz r4, 0xb58(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2904 as u32) ) } as u64;
	// 828DE45C: 485155AD  bl 0x82df3a08
	ctx.lr = 0x828DE460;
	sub_82DF3A08(ctx, base);
	// 828DE460: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DE464: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DE468: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 828DE46C: 4857DCED  bl 0x82e5c158
	ctx.lr = 0x828DE470;
	sub_82E5C158(ctx, base);
	// 828DE470: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DE474: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 828DE478: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DE47C: 388B55E8  addi r4, r11, 0x55e8
	ctx.r[4].s64 = ctx.r[11].s64 + 21992;
	// 828DE480: 4BF8AC29  bl 0x828690a8
	ctx.lr = 0x828DE484;
	sub_828690A8(ctx, base);
	// 828DE484: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DE488: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DE48C: 3A810060  addi r20, r1, 0x60
	ctx.r[20].s64 = ctx.r[1].s64 + 96;
	// 828DE490: 808B0B5C  lwz r4, 0xb5c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2908 as u32) ) } as u64;
	// 828DE494: 48515575  bl 0x82df3a08
	ctx.lr = 0x828DE498;
	sub_82DF3A08(ctx, base);
	// 828DE498: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DE49C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DE4A0: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 828DE4A4: 4857DCB5  bl 0x82e5c158
	ctx.lr = 0x828DE4A8;
	sub_82E5C158(ctx, base);
	// 828DE4A8: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DE4AC: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 828DE4B0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DE4B4: 388B8DD8  addi r4, r11, -0x7228
	ctx.r[4].s64 = ctx.r[11].s64 + -29224;
	// 828DE4B8: 4BF8ABF1  bl 0x828690a8
	ctx.lr = 0x828DE4BC;
	sub_828690A8(ctx, base);
	// 828DE4BC: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DE4C0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DE4C4: 3A810060  addi r20, r1, 0x60
	ctx.r[20].s64 = ctx.r[1].s64 + 96;
	// 828DE4C8: 808B0B60  lwz r4, 0xb60(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2912 as u32) ) } as u64;
	// 828DE4CC: 4851553D  bl 0x82df3a08
	ctx.lr = 0x828DE4D0;
	sub_82DF3A08(ctx, base);
	// 828DE4D0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DE4D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DE4D8: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 828DE4DC: 4857DC7D  bl 0x82e5c158
	ctx.lr = 0x828DE4E0;
	sub_82E5C158(ctx, base);
	// 828DE4E0: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DE4E4: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 828DE4E8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DE4EC: 388B9EF8  addi r4, r11, -0x6108
	ctx.r[4].s64 = ctx.r[11].s64 + -24840;
	// 828DE4F0: 4BF8ABB9  bl 0x828690a8
	ctx.lr = 0x828DE4F4;
	sub_828690A8(ctx, base);
	// 828DE4F4: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DE4F8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DE4FC: 3A810060  addi r20, r1, 0x60
	ctx.r[20].s64 = ctx.r[1].s64 + 96;
	// 828DE500: 808B0B64  lwz r4, 0xb64(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2916 as u32) ) } as u64;
	// 828DE504: 48515505  bl 0x82df3a08
	ctx.lr = 0x828DE508;
	sub_82DF3A08(ctx, base);
	// 828DE508: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DE50C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DE510: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 828DE514: 4857DC45  bl 0x82e5c158
	ctx.lr = 0x828DE518;
	sub_82E5C158(ctx, base);
	// 828DE518: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DE51C: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 828DE520: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DE524: 388B4700  addi r4, r11, 0x4700
	ctx.r[4].s64 = ctx.r[11].s64 + 18176;
	// 828DE528: 4BF8AB81  bl 0x828690a8
	ctx.lr = 0x828DE52C;
	sub_828690A8(ctx, base);
	// 828DE52C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DE530: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DE534: 3A810060  addi r20, r1, 0x60
	ctx.r[20].s64 = ctx.r[1].s64 + 96;
	// 828DE538: 808B0B68  lwz r4, 0xb68(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2920 as u32) ) } as u64;
	// 828DE53C: 485154CD  bl 0x82df3a08
	ctx.lr = 0x828DE540;
	sub_82DF3A08(ctx, base);
	// 828DE540: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DE544: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DE548: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 828DE54C: 4857DC0D  bl 0x82e5c158
	ctx.lr = 0x828DE550;
	sub_82E5C158(ctx, base);
	// 828DE550: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DE554: 3D608294  lis r11, -0x7d6c
	ctx.r[11].s64 = -2104229888;
	// 828DE558: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DE55C: 388B8D88  addi r4, r11, -0x7278
	ctx.r[4].s64 = ctx.r[11].s64 + -29304;
	// 828DE560: 4BF8AB49  bl 0x828690a8
	ctx.lr = 0x828DE564;
	sub_828690A8(ctx, base);
	// 828DE564: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DE568: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DE56C: 3A810060  addi r20, r1, 0x60
	ctx.r[20].s64 = ctx.r[1].s64 + 96;
	// 828DE570: 808B0B6C  lwz r4, 0xb6c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2924 as u32) ) } as u64;
	// 828DE574: 48515495  bl 0x82df3a08
	ctx.lr = 0x828DE578;
	sub_82DF3A08(ctx, base);
	// 828DE578: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DE57C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DE580: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 828DE584: 4857DBD5  bl 0x82e5c158
	ctx.lr = 0x828DE588;
	sub_82E5C158(ctx, base);
	// 828DE588: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DE58C: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 828DE590: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DE594: 388BD278  addi r4, r11, -0x2d88
	ctx.r[4].s64 = ctx.r[11].s64 + -11656;
	// 828DE598: 4BF8AB11  bl 0x828690a8
	ctx.lr = 0x828DE59C;
	sub_828690A8(ctx, base);
	// 828DE59C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DE5A0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DE5A4: 3A810060  addi r20, r1, 0x60
	ctx.r[20].s64 = ctx.r[1].s64 + 96;
	// 828DE5A8: 808B0B70  lwz r4, 0xb70(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2928 as u32) ) } as u64;
	// 828DE5AC: 4851545D  bl 0x82df3a08
	ctx.lr = 0x828DE5B0;
	sub_82DF3A08(ctx, base);
	// 828DE5B0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DE5B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DE5B8: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 828DE5BC: 4857DB9D  bl 0x82e5c158
	ctx.lr = 0x828DE5C0;
	sub_82E5C158(ctx, base);
	// 828DE5C0: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DE5C4: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 828DE5C8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DE5CC: 388B39B8  addi r4, r11, 0x39b8
	ctx.r[4].s64 = ctx.r[11].s64 + 14776;
	// 828DE5D0: 4BF8AAD9  bl 0x828690a8
	ctx.lr = 0x828DE5D4;
	sub_828690A8(ctx, base);
	// 828DE5D4: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DE5D8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DE5DC: 3A810060  addi r20, r1, 0x60
	ctx.r[20].s64 = ctx.r[1].s64 + 96;
	// 828DE5E0: 808B0B78  lwz r4, 0xb78(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2936 as u32) ) } as u64;
	// 828DE5E4: 48515425  bl 0x82df3a08
	ctx.lr = 0x828DE5E8;
	sub_82DF3A08(ctx, base);
	// 828DE5E8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DE5EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DE5F0: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 828DE5F4: 4857DB65  bl 0x82e5c158
	ctx.lr = 0x828DE5F8;
	sub_82E5C158(ctx, base);
	// 828DE5F8: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DE5FC: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 828DE600: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DE604: 388BF950  addi r4, r11, -0x6b0
	ctx.r[4].s64 = ctx.r[11].s64 + -1712;
	// 828DE608: 4BF8AAA1  bl 0x828690a8
	ctx.lr = 0x828DE60C;
	sub_828690A8(ctx, base);
	// 828DE60C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DE610: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DE614: 3A810060  addi r20, r1, 0x60
	ctx.r[20].s64 = ctx.r[1].s64 + 96;
	// 828DE618: 808B0B7C  lwz r4, 0xb7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2940 as u32) ) } as u64;
	// 828DE61C: 485153ED  bl 0x82df3a08
	ctx.lr = 0x828DE620;
	sub_82DF3A08(ctx, base);
	// 828DE620: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DE624: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DE628: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 828DE62C: 4857DB2D  bl 0x82e5c158
	ctx.lr = 0x828DE630;
	sub_82E5C158(ctx, base);
	// 828DE630: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DE634: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 828DE638: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DE63C: 388B30E0  addi r4, r11, 0x30e0
	ctx.r[4].s64 = ctx.r[11].s64 + 12512;
	// 828DE640: 4BF8AA69  bl 0x828690a8
	ctx.lr = 0x828DE644;
	sub_828690A8(ctx, base);
	// 828DE644: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DE648: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DE64C: 3A810060  addi r20, r1, 0x60
	ctx.r[20].s64 = ctx.r[1].s64 + 96;
	// 828DE650: 808B0B80  lwz r4, 0xb80(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2944 as u32) ) } as u64;
	// 828DE654: 485153B5  bl 0x82df3a08
	ctx.lr = 0x828DE658;
	sub_82DF3A08(ctx, base);
	// 828DE658: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DE65C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DE660: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 828DE664: 4857DAF5  bl 0x82e5c158
	ctx.lr = 0x828DE668;
	sub_82E5C158(ctx, base);
	// 828DE668: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DE66C: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 828DE670: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DE674: 388BEFC8  addi r4, r11, -0x1038
	ctx.r[4].s64 = ctx.r[11].s64 + -4152;
	// 828DE678: 4BF8AA31  bl 0x828690a8
	ctx.lr = 0x828DE67C;
	sub_828690A8(ctx, base);
	// 828DE67C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DE680: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DE684: 3A810060  addi r20, r1, 0x60
	ctx.r[20].s64 = ctx.r[1].s64 + 96;
	// 828DE688: 808B0B84  lwz r4, 0xb84(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2948 as u32) ) } as u64;
	// 828DE68C: 4851537D  bl 0x82df3a08
	ctx.lr = 0x828DE690;
	sub_82DF3A08(ctx, base);
	// 828DE690: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DE694: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DE698: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 828DE69C: 4857DABD  bl 0x82e5c158
	ctx.lr = 0x828DE6A0;
	sub_82E5C158(ctx, base);
	// 828DE6A0: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DE6A4: 3D608294  lis r11, -0x7d6c
	ctx.r[11].s64 = -2104229888;
	// 828DE6A8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DE6AC: 388B9DC0  addi r4, r11, -0x6240
	ctx.r[4].s64 = ctx.r[11].s64 + -25152;
	// 828DE6B0: 4BF8A9F9  bl 0x828690a8
	ctx.lr = 0x828DE6B4;
	sub_828690A8(ctx, base);
	// 828DE6B4: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DE6B8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DE6BC: 3A810060  addi r20, r1, 0x60
	ctx.r[20].s64 = ctx.r[1].s64 + 96;
	// 828DE6C0: 808B0B90  lwz r4, 0xb90(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2960 as u32) ) } as u64;
	// 828DE6C4: 48515345  bl 0x82df3a08
	ctx.lr = 0x828DE6C8;
	sub_82DF3A08(ctx, base);
	// 828DE6C8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DE6CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DE6D0: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 828DE6D4: 4857DA85  bl 0x82e5c158
	ctx.lr = 0x828DE6D8;
	sub_82E5C158(ctx, base);
	// 828DE6D8: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DE6DC: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 828DE6E0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DE6E4: 388B27B8  addi r4, r11, 0x27b8
	ctx.r[4].s64 = ctx.r[11].s64 + 10168;
	// 828DE6E8: 4BF8A9C1  bl 0x828690a8
	ctx.lr = 0x828DE6EC;
	sub_828690A8(ctx, base);
	// 828DE6EC: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DE6F0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DE6F4: 3A810060  addi r20, r1, 0x60
	ctx.r[20].s64 = ctx.r[1].s64 + 96;
	// 828DE6F8: 808B0B94  lwz r4, 0xb94(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2964 as u32) ) } as u64;
	// 828DE6FC: 4851530D  bl 0x82df3a08
	ctx.lr = 0x828DE700;
	sub_82DF3A08(ctx, base);
	// 828DE700: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DE704: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DE708: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 828DE70C: 4857DA4D  bl 0x82e5c158
	ctx.lr = 0x828DE710;
	sub_82E5C158(ctx, base);
	// 828DE710: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DE714: 3D608294  lis r11, -0x7d6c
	ctx.r[11].s64 = -2104229888;
	// 828DE718: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DE71C: 388BB318  addi r4, r11, -0x4ce8
	ctx.r[4].s64 = ctx.r[11].s64 + -19688;
	// 828DE720: 4BF8A989  bl 0x828690a8
	ctx.lr = 0x828DE724;
	sub_828690A8(ctx, base);
	// 828DE724: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DE728: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DE72C: 3A810060  addi r20, r1, 0x60
	ctx.r[20].s64 = ctx.r[1].s64 + 96;
	// 828DE730: 808B0B98  lwz r4, 0xb98(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2968 as u32) ) } as u64;
	// 828DE734: 485152D5  bl 0x82df3a08
	ctx.lr = 0x828DE738;
	sub_82DF3A08(ctx, base);
	// 828DE738: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DE73C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DE740: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 828DE744: 4857DA15  bl 0x82e5c158
	ctx.lr = 0x828DE748;
	sub_82E5C158(ctx, base);
	// 828DE748: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DE74C: 3D608294  lis r11, -0x7d6c
	ctx.r[11].s64 = -2104229888;
	// 828DE750: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DE754: 388BB3E8  addi r4, r11, -0x4c18
	ctx.r[4].s64 = ctx.r[11].s64 + -19480;
	// 828DE758: 4BF8A951  bl 0x828690a8
	ctx.lr = 0x828DE75C;
	sub_828690A8(ctx, base);
	// 828DE75C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DE760: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DE764: 3A810060  addi r20, r1, 0x60
	ctx.r[20].s64 = ctx.r[1].s64 + 96;
	// 828DE768: 808B0B9C  lwz r4, 0xb9c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2972 as u32) ) } as u64;
	// 828DE76C: 4851529D  bl 0x82df3a08
	ctx.lr = 0x828DE770;
	sub_82DF3A08(ctx, base);
	// 828DE770: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DE774: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DE778: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 828DE77C: 4857D9DD  bl 0x82e5c158
	ctx.lr = 0x828DE780;
	sub_82E5C158(ctx, base);
	// 828DE780: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DE784: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 828DE788: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DE78C: 388B73F8  addi r4, r11, 0x73f8
	ctx.r[4].s64 = ctx.r[11].s64 + 29688;
	// 828DE790: 4BF8A919  bl 0x828690a8
	ctx.lr = 0x828DE794;
	sub_828690A8(ctx, base);
	// 828DE794: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DE798: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DE79C: 3A810060  addi r20, r1, 0x60
	ctx.r[20].s64 = ctx.r[1].s64 + 96;
	// 828DE7A0: 808B0B00  lwz r4, 0xb00(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2816 as u32) ) } as u64;
	// 828DE7A4: 48515265  bl 0x82df3a08
	ctx.lr = 0x828DE7A8;
	sub_82DF3A08(ctx, base);
	// 828DE7A8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DE7AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DE7B0: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 828DE7B4: 4857D9A5  bl 0x82e5c158
	ctx.lr = 0x828DE7B8;
	sub_82E5C158(ctx, base);
	// 828DE7B8: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DE7BC: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 828DE7C0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DE7C4: 388B7810  addi r4, r11, 0x7810
	ctx.r[4].s64 = ctx.r[11].s64 + 30736;
	// 828DE7C8: 4BF8A8E1  bl 0x828690a8
	ctx.lr = 0x828DE7CC;
	sub_828690A8(ctx, base);
	// 828DE7CC: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DE7D0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DE7D4: 3A810060  addi r20, r1, 0x60
	ctx.r[20].s64 = ctx.r[1].s64 + 96;
	// 828DE7D8: 808B0B04  lwz r4, 0xb04(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2820 as u32) ) } as u64;
	// 828DE7DC: 4851522D  bl 0x82df3a08
	ctx.lr = 0x828DE7E0;
	sub_82DF3A08(ctx, base);
	// 828DE7E0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DE7E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DE7E8: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 828DE7EC: 4857D96D  bl 0x82e5c158
	ctx.lr = 0x828DE7F0;
	sub_82E5C158(ctx, base);
	// 828DE7F0: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DE7F4: 3D608292  lis r11, -0x7d6e
	ctx.r[11].s64 = -2104360960;
	// 828DE7F8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DE7FC: 388B5EB8  addi r4, r11, 0x5eb8
	ctx.r[4].s64 = ctx.r[11].s64 + 24248;
	// 828DE800: 4BF8A8A9  bl 0x828690a8
	ctx.lr = 0x828DE804;
	sub_828690A8(ctx, base);
	// 828DE804: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DE808: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DE80C: 3A810060  addi r20, r1, 0x60
	ctx.r[20].s64 = ctx.r[1].s64 + 96;
	// 828DE810: 808B0BC4  lwz r4, 0xbc4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3012 as u32) ) } as u64;
	// 828DE814: 485151F5  bl 0x82df3a08
	ctx.lr = 0x828DE818;
	sub_82DF3A08(ctx, base);
	// 828DE818: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DE81C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DE820: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 828DE824: 4857D935  bl 0x82e5c158
	ctx.lr = 0x828DE828;
	sub_82E5C158(ctx, base);
	// 828DE828: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DE82C: 3D608292  lis r11, -0x7d6e
	ctx.r[11].s64 = -2104360960;
	// 828DE830: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DE834: 388B74E8  addi r4, r11, 0x74e8
	ctx.r[4].s64 = ctx.r[11].s64 + 29928;
	// 828DE838: 4BF8A871  bl 0x828690a8
	ctx.lr = 0x828DE83C;
	sub_828690A8(ctx, base);
	// 828DE83C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DE840: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DE844: 3A810060  addi r20, r1, 0x60
	ctx.r[20].s64 = ctx.r[1].s64 + 96;
	// 828DE848: 808B0BC8  lwz r4, 0xbc8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3016 as u32) ) } as u64;
	// 828DE84C: 485151BD  bl 0x82df3a08
	ctx.lr = 0x828DE850;
	sub_82DF3A08(ctx, base);
	// 828DE850: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DE854: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DE858: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 828DE85C: 4857D8FD  bl 0x82e5c158
	ctx.lr = 0x828DE860;
	sub_82E5C158(ctx, base);
	// 828DE860: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DE864: 3D608292  lis r11, -0x7d6e
	ctx.r[11].s64 = -2104360960;
	// 828DE868: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DE86C: 388B7238  addi r4, r11, 0x7238
	ctx.r[4].s64 = ctx.r[11].s64 + 29240;
	// 828DE870: 4BF8A839  bl 0x828690a8
	ctx.lr = 0x828DE874;
	sub_828690A8(ctx, base);
	// 828DE874: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DE878: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DE87C: 3A810060  addi r20, r1, 0x60
	ctx.r[20].s64 = ctx.r[1].s64 + 96;
	// 828DE880: 808B0BCC  lwz r4, 0xbcc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3020 as u32) ) } as u64;
	// 828DE884: 48515185  bl 0x82df3a08
	ctx.lr = 0x828DE888;
	sub_82DF3A08(ctx, base);
	// 828DE888: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DE88C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DE890: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 828DE894: 4857D8C5  bl 0x82e5c158
	ctx.lr = 0x828DE898;
	sub_82E5C158(ctx, base);
	// 828DE898: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DE89C: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 828DE8A0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DE8A4: 388BE9D0  addi r4, r11, -0x1630
	ctx.r[4].s64 = ctx.r[11].s64 + -5680;
	// 828DE8A8: 4BF8A801  bl 0x828690a8
	ctx.lr = 0x828DE8AC;
	sub_828690A8(ctx, base);
	// 828DE8AC: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DE8B0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DE8B4: 3A810060  addi r20, r1, 0x60
	ctx.r[20].s64 = ctx.r[1].s64 + 96;
	// 828DE8B8: 808B0BB8  lwz r4, 0xbb8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3000 as u32) ) } as u64;
	// 828DE8BC: 4851514D  bl 0x82df3a08
	ctx.lr = 0x828DE8C0;
	sub_82DF3A08(ctx, base);
	// 828DE8C0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DE8C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DE8C8: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 828DE8CC: 4857D88D  bl 0x82e5c158
	ctx.lr = 0x828DE8D0;
	sub_82E5C158(ctx, base);
	// 828DE8D0: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DE8D4: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 828DE8D8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DE8DC: 388BE370  addi r4, r11, -0x1c90
	ctx.r[4].s64 = ctx.r[11].s64 + -7312;
	// 828DE8E0: 4BF8A7C9  bl 0x828690a8
	ctx.lr = 0x828DE8E4;
	sub_828690A8(ctx, base);
	// 828DE8E4: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DE8E8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DE8EC: 3A810060  addi r20, r1, 0x60
	ctx.r[20].s64 = ctx.r[1].s64 + 96;
	// 828DE8F0: 808B0BBC  lwz r4, 0xbbc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3004 as u32) ) } as u64;
	// 828DE8F4: 48515115  bl 0x82df3a08
	ctx.lr = 0x828DE8F8;
	sub_82DF3A08(ctx, base);
	// 828DE8F8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DE8FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DE900: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 828DE904: 4857D855  bl 0x82e5c158
	ctx.lr = 0x828DE908;
	sub_82E5C158(ctx, base);
	// 828DE908: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DE90C: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 828DE910: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DE914: 388B65B8  addi r4, r11, 0x65b8
	ctx.r[4].s64 = ctx.r[11].s64 + 26040;
	// 828DE918: 4BF8A791  bl 0x828690a8
	ctx.lr = 0x828DE91C;
	sub_828690A8(ctx, base);
	// 828DE91C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DE920: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DE924: 3A810060  addi r20, r1, 0x60
	ctx.r[20].s64 = ctx.r[1].s64 + 96;
	// 828DE928: 808B0BB0  lwz r4, 0xbb0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2992 as u32) ) } as u64;
	// 828DE92C: 485150DD  bl 0x82df3a08
	ctx.lr = 0x828DE930;
	sub_82DF3A08(ctx, base);
	// 828DE930: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DE934: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DE938: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 828DE93C: 4857D81D  bl 0x82e5c158
	ctx.lr = 0x828DE940;
	sub_82E5C158(ctx, base);
	// 828DE940: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DE944: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 828DE948: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DE94C: 388B62E8  addi r4, r11, 0x62e8
	ctx.r[4].s64 = ctx.r[11].s64 + 25320;
	// 828DE950: 4BF8A759  bl 0x828690a8
	ctx.lr = 0x828DE954;
	sub_828690A8(ctx, base);
	// 828DE954: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DE958: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DE95C: 3A810060  addi r20, r1, 0x60
	ctx.r[20].s64 = ctx.r[1].s64 + 96;
	// 828DE960: 808B0BB4  lwz r4, 0xbb4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2996 as u32) ) } as u64;
	// 828DE964: 485150A5  bl 0x82df3a08
	ctx.lr = 0x828DE968;
	sub_82DF3A08(ctx, base);
	// 828DE968: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DE96C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DE970: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 828DE974: 4857D7E5  bl 0x82e5c158
	ctx.lr = 0x828DE978;
	sub_82E5C158(ctx, base);
	// 828DE978: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DE97C: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 828DE980: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DE984: 388B4D00  addi r4, r11, 0x4d00
	ctx.r[4].s64 = ctx.r[11].s64 + 19712;
	// 828DE988: 4BF8A721  bl 0x828690a8
	ctx.lr = 0x828DE98C;
	sub_828690A8(ctx, base);
	// 828DE98C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DE990: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DE994: 3A810060  addi r20, r1, 0x60
	ctx.r[20].s64 = ctx.r[1].s64 + 96;
	// 828DE998: 808B0BAC  lwz r4, 0xbac(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2988 as u32) ) } as u64;
	// 828DE99C: 4851506D  bl 0x82df3a08
	ctx.lr = 0x828DE9A0;
	sub_82DF3A08(ctx, base);
	// 828DE9A0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DE9A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DE9A8: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 828DE9AC: 4857D7AD  bl 0x82e5c158
	ctx.lr = 0x828DE9B0;
	sub_82E5C158(ctx, base);
	// 828DE9B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DE9B4: 809B0AF0  lwz r4, 0xaf0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(2800 as u32) ) } as u64;
	// 828DE9B8: 48515051  bl 0x82df3a08
	ctx.lr = 0x828DE9BC;
	sub_82DF3A08(ctx, base);
	// 828DE9BC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828DE9C0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DE9C4: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 828DE9C8: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828DE9CC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828DE9D0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828DE9D4: 4857FF8D  bl 0x82e5e960
	ctx.lr = 0x828DE9D8;
	sub_82E5E960(ctx, base);
	// 828DE9D8: 80610124  lwz r3, 0x124(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(292 as u32) ) } as u64;
	// 828DE9DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DE9E0: 419A0008  beq cr6, 0x828de9e8
	if ctx.cr[6].eq {
	pc = 0x828DE9E8; continue 'dispatch;
	}
	// 828DE9E4: 4B9E1EAD  bl 0x822c0890
	ctx.lr = 0x828DE9E8;
	sub_822C0890(ctx, base);
	// 828DE9E8: 817D0164  lwz r11, 0x164(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(356 as u32) ) } as u64;
	// 828DE9EC: 3BDD0164  addi r30, r29, 0x164
	ctx.r[30].s64 = ctx.r[29].s64 + 356;
	// 828DE9F0: 809A0000  lwz r4, 0(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DE9F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DE9F8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DE9FC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828DEA00: 4E800421  bctrl
	ctx.lr = 0x828DEA04;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DEA04: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DEA08: 3D608294  lis r11, -0x7d6c
	ctx.r[11].s64 = -2104229888;
	// 828DEA0C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DEA10: 388BD8C8  addi r4, r11, -0x2738
	ctx.r[4].s64 = ctx.r[11].s64 + -10040;
	// 828DEA14: 4BF8A695  bl 0x828690a8
	ctx.lr = 0x828DEA18;
	sub_828690A8(ctx, base);
	// 828DEA18: 3F60832D  lis r27, -0x7cd3
	ctx.r[27].s64 = -2094202880;
	// 828DEA1C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DEA20: 3B410060  addi r26, r1, 0x60
	ctx.r[26].s64 = ctx.r[1].s64 + 96;
	// 828DEA24: 809B0BD8  lwz r4, 0xbd8(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(3032 as u32) ) } as u64;
	// 828DEA28: 48514FE1  bl 0x82df3a08
	ctx.lr = 0x828DEA2C;
	sub_82DF3A08(ctx, base);
	// 828DEA2C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DEA30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DEA34: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 828DEA38: 4857D721  bl 0x82e5c158
	ctx.lr = 0x828DEA3C;
	sub_82E5C158(ctx, base);
	// 828DEA3C: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DEA40: 3D608294  lis r11, -0x7d6c
	ctx.r[11].s64 = -2104229888;
	// 828DEA44: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DEA48: 388BE1E0  addi r4, r11, -0x1e20
	ctx.r[4].s64 = ctx.r[11].s64 + -7712;
	// 828DEA4C: 4BF8A65D  bl 0x828690a8
	ctx.lr = 0x828DEA50;
	sub_828690A8(ctx, base);
	// 828DEA50: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DEA54: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DEA58: 3B410060  addi r26, r1, 0x60
	ctx.r[26].s64 = ctx.r[1].s64 + 96;
	// 828DEA5C: 808B0BDC  lwz r4, 0xbdc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3036 as u32) ) } as u64;
	// 828DEA60: 48514FA9  bl 0x82df3a08
	ctx.lr = 0x828DEA64;
	sub_82DF3A08(ctx, base);
	// 828DEA64: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DEA68: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DEA6C: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 828DEA70: 4857D6E9  bl 0x82e5c158
	ctx.lr = 0x828DEA74;
	sub_82E5C158(ctx, base);
	// 828DEA74: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DEA78: 3D608294  lis r11, -0x7d6c
	ctx.r[11].s64 = -2104229888;
	// 828DEA7C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DEA80: 388BE810  addi r4, r11, -0x17f0
	ctx.r[4].s64 = ctx.r[11].s64 + -6128;
	// 828DEA84: 4BF8A625  bl 0x828690a8
	ctx.lr = 0x828DEA88;
	sub_828690A8(ctx, base);
	// 828DEA88: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DEA8C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DEA90: 3B410060  addi r26, r1, 0x60
	ctx.r[26].s64 = ctx.r[1].s64 + 96;
	// 828DEA94: 808B0BE8  lwz r4, 0xbe8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3048 as u32) ) } as u64;
	// 828DEA98: 48514F71  bl 0x82df3a08
	ctx.lr = 0x828DEA9C;
	sub_82DF3A08(ctx, base);
	// 828DEA9C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DEAA0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DEAA4: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 828DEAA8: 4857D6B1  bl 0x82e5c158
	ctx.lr = 0x828DEAAC;
	sub_82E5C158(ctx, base);
	// 828DEAAC: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DEAB0: 3D608294  lis r11, -0x7d6c
	ctx.r[11].s64 = -2104229888;
	// 828DEAB4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DEAB8: 388BE378  addi r4, r11, -0x1c88
	ctx.r[4].s64 = ctx.r[11].s64 + -7304;
	// 828DEABC: 4BF8A5ED  bl 0x828690a8
	ctx.lr = 0x828DEAC0;
	sub_828690A8(ctx, base);
	// 828DEAC0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DEAC4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DEAC8: 3B410060  addi r26, r1, 0x60
	ctx.r[26].s64 = ctx.r[1].s64 + 96;
	// 828DEACC: 808B0BF4  lwz r4, 0xbf4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3060 as u32) ) } as u64;
	// 828DEAD0: 48514F39  bl 0x82df3a08
	ctx.lr = 0x828DEAD4;
	sub_82DF3A08(ctx, base);
	// 828DEAD4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DEAD8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DEADC: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 828DEAE0: 4857D679  bl 0x82e5c158
	ctx.lr = 0x828DEAE4;
	sub_82E5C158(ctx, base);
	// 828DEAE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DEAE8: 809B0BD8  lwz r4, 0xbd8(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(3032 as u32) ) } as u64;
	// 828DEAEC: 48514F1D  bl 0x82df3a08
	ctx.lr = 0x828DEAF0;
	sub_82DF3A08(ctx, base);
	// 828DEAF0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828DEAF4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DEAF8: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828DEAFC: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 828DEB00: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828DEB04: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828DEB08: 4857FE59  bl 0x82e5e960
	ctx.lr = 0x828DEB0C;
	sub_82E5E960(ctx, base);
	// 828DEB0C: 8061010C  lwz r3, 0x10c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(268 as u32) ) } as u64;
	// 828DEB10: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DEB14: 419A0008  beq cr6, 0x828deb1c
	if ctx.cr[6].eq {
	pc = 0x828DEB1C; continue 'dispatch;
	}
	// 828DEB18: 4B9E1D79  bl 0x822c0890
	ctx.lr = 0x828DEB1C;
	sub_822C0890(ctx, base);
	// 828DEB1C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828DEB20: 4802A2C9  bl 0x82908de8
	ctx.lr = 0x828DEB24;
	sub_82908DE8(ctx, base);
	// 828DEB24: 2F03000E  cmpwi cr6, r3, 0xe
	ctx.cr[6].compare_i32(ctx.r[3].s32, 14, &mut ctx.xer);
	// 828DEB28: 409A0034  bne cr6, 0x828deb5c
	if !ctx.cr[6].eq {
	pc = 0x828DEB5C; continue 'dispatch;
	}
	// 828DEB2C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 828DEB30: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828DEB34: 38A001A8  li r5, 0x1a8
	ctx.r[5].s64 = 424;
	// 828DEB38: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 828DEB3C: 4B9E189D  bl 0x822c03d8
	ctx.lr = 0x828DEB40;
	sub_822C03D8(ctx, base);
	// 828DEB40: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828DEB44: 41820064  beq 0x828deba8
	if ctx.cr[0].eq {
	pc = 0x828DEBA8; continue 'dispatch;
	}
	// 828DEB48: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828DEB4C: 4BF0D615  bl 0x827ec160
	ctx.lr = 0x828DEB50;
	sub_827EC160(ctx, base);
	// 828DEB50: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828DEB54: 38ABF918  addi r5, r11, -0x6e8
	ctx.r[5].s64 = ctx.r[11].s64 + -1768;
	// 828DEB58: 48000038  b 0x828deb90
	pc = 0x828DEB90; continue 'dispatch;
	// 828DEB5C: 2F03000F  cmpwi cr6, r3, 0xf
	ctx.cr[6].compare_i32(ctx.r[3].s32, 15, &mut ctx.xer);
	// 828DEB60: 409A0054  bne cr6, 0x828debb4
	if !ctx.cr[6].eq {
	pc = 0x828DEBB4; continue 'dispatch;
	}
	// 828DEB64: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 828DEB68: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828DEB6C: 38A001AC  li r5, 0x1ac
	ctx.r[5].s64 = 428;
	// 828DEB70: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 828DEB74: 4B9E1865  bl 0x822c03d8
	ctx.lr = 0x828DEB78;
	sub_822C03D8(ctx, base);
	// 828DEB78: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828DEB7C: 4182002C  beq 0x828deba8
	if ctx.cr[0].eq {
	pc = 0x828DEBA8; continue 'dispatch;
	}
	// 828DEB80: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828DEB84: 4BF0D5DD  bl 0x827ec160
	ctx.lr = 0x828DEB88;
	sub_827EC160(ctx, base);
	// 828DEB88: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828DEB8C: 38ABF934  addi r5, r11, -0x6cc
	ctx.r[5].s64 = ctx.r[11].s64 + -1740;
	// 828DEB90: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828DEB94: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 828DEB98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DEB9C: 48043C25  bl 0x829227c0
	ctx.lr = 0x828DEBA0;
	sub_829227C0(ctx, base);
	// 828DEBA0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DEBA4: 48000008  b 0x828debac
	pc = 0x828DEBAC; continue 'dispatch;
	// 828DEBA8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DEBAC: 387D036C  addi r3, r29, 0x36c
	ctx.r[3].s64 = ctx.r[29].s64 + 876;
	// 828DEBB0: 4BF8A409  bl 0x82868fb8
	ctx.lr = 0x828DEBB4;
	sub_82868FB8(ctx, base);
	// 828DEBB4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828DEBB8: 4BC33EE1  bl 0x82512a98
	ctx.lr = 0x828DEBBC;
	sub_82512A98(ctx, base);
	// 828DEBBC: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 828DEBC0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828DEBC4: 38A001B4  li r5, 0x1b4
	ctx.r[5].s64 = 436;
	// 828DEBC8: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 828DEBCC: 4B9E180D  bl 0x822c03d8
	ctx.lr = 0x828DEBD0;
	sub_822C03D8(ctx, base);
	// 828DEBD0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828DEBD4: 41820014  beq 0x828debe8
	if ctx.cr[0].eq {
	pc = 0x828DEBE8; continue 'dispatch;
	}
	// 828DEBD8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828DEBDC: 48000365  bl 0x828def40
	ctx.lr = 0x828DEBE0;
	sub_828DEF40(ctx, base);
	// 828DEBE0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DEBE4: 48000008  b 0x828debec
	pc = 0x828DEBEC; continue 'dispatch;
	// 828DEBE8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DEBEC: 387D0364  addi r3, r29, 0x364
	ctx.r[3].s64 = ctx.r[29].s64 + 868;
	// 828DEBF0: 4BFFCF91  bl 0x828dbb80
	ctx.lr = 0x828DEBF4;
	sub_828DBB80(ctx, base);
	// 828DEBF4: 807D0364  lwz r3, 0x364(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(868 as u32) ) } as u64;
	// 828DEBF8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DEBFC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DEC00: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828DEC04: 4E800421  bctrl
	ctx.lr = 0x828DEC08;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DEC08: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 828DEC0C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828DEC10: 4802F3F1  bl 0x8290e000
	ctx.lr = 0x828DEC14;
	sub_8290E000(ctx, base);
	// 828DEC14: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 828DEC18: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828DEC1C: 38A001BC  li r5, 0x1bc
	ctx.r[5].s64 = 444;
	// 828DEC20: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 828DEC24: 4B9E17B5  bl 0x822c03d8
	ctx.lr = 0x828DEC28;
	sub_822C03D8(ctx, base);
	// 828DEC28: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828DEC2C: 41820030  beq 0x828dec5c
	if ctx.cr[0].eq {
	pc = 0x828DEC5C; continue 'dispatch;
	}
	// 828DEC30: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DEC34: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828DEC38: 816B01A4  lwz r11, 0x1a4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(420 as u32) ) } as u64;
	// 828DEC3C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828DEC40: 4E800421  bctrl
	ctx.lr = 0x828DEC44;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DEC44: 38A30034  addi r5, r3, 0x34
	ctx.r[5].s64 = ctx.r[3].s64 + 52;
	// 828DEC48: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828DEC4C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DEC50: 48064FD1  bl 0x82943c20
	ctx.lr = 0x828DEC54;
	sub_82943C20(ctx, base);
	// 828DEC54: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828DEC58: 48000008  b 0x828dec60
	pc = 0x828DEC60; continue 'dispatch;
	// 828DEC5C: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 828DEC60: 93C100E0  stw r30, 0xe0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[30].u32 ) };
	// 828DEC64: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DEC68: 386100E4  addi r3, r1, 0xe4
	ctx.r[3].s64 = ctx.r[1].s64 + 228;
	// 828DEC6C: 4BF87D1D  bl 0x82866988
	ctx.lr = 0x828DEC70;
	sub_82866988(ctx, base);
	// 828DEC70: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828DEC74: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828DEC78: 386100E4  addi r3, r1, 0xe4
	ctx.r[3].s64 = ctx.r[1].s64 + 228;
	// 828DEC7C: 4B9E1385  bl 0x822c0000
	ctx.lr = 0x828DEC80;
	sub_822C0000(ctx, base);
	// 828DEC80: 388100E0  addi r4, r1, 0xe0
	ctx.r[4].s64 = ctx.r[1].s64 + 224;
	// 828DEC84: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 828DEC88: 4BF89749  bl 0x828683d0
	ctx.lr = 0x828DEC8C;
	sub_828683D0(ctx, base);
	// 828DEC8C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DEC90: 91610090  stw r11, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 828DEC94: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DEC98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DEC9C: 91610094  stw r11, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 828DECA0: 419A0024  beq cr6, 0x828decc4
	if ctx.cr[6].eq {
	pc = 0x828DECC4; continue 'dispatch;
	}
	// 828DECA4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828DECA8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828DECAC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DECB0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828DECB4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828DECB8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828DECBC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DECC0: 4082FFE8  bne 0x828deca8
	if !ctx.cr[0].eq {
	pc = 0x828DECA8; continue 'dispatch;
	}
	// 828DECC4: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 828DECC8: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828DECCC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828DECD0: 4802C819  bl 0x8290b4e8
	ctx.lr = 0x828DECD4;
	sub_8290B4E8(ctx, base);
	// 828DECD4: 8061011C  lwz r3, 0x11c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(284 as u32) ) } as u64;
	// 828DECD8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DECDC: 419A0008  beq cr6, 0x828dece4
	if ctx.cr[6].eq {
	pc = 0x828DECE4; continue 'dispatch;
	}
	// 828DECE0: 4B9E1BB1  bl 0x822c0890
	ctx.lr = 0x828DECE4;
	sub_822C0890(ctx, base);
	// 828DECE4: 806100E4  lwz r3, 0xe4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(228 as u32) ) } as u64;
	// 828DECE8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DECEC: 419A0008  beq cr6, 0x828decf4
	if ctx.cr[6].eq {
	pc = 0x828DECF4; continue 'dispatch;
	}
	// 828DECF0: 4B9E1BA1  bl 0x822c0890
	ctx.lr = 0x828DECF4;
	sub_822C0890(ctx, base);
	// 828DECF4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DECF8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828DECFC: 816B01A4  lwz r11, 0x1a4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(420 as u32) ) } as u64;
	// 828DED00: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828DED04: 4E800421  bctrl
	ctx.lr = 0x828DED08;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DED08: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828DED0C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828DED10: C03E0000  lfs f1, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828DED14: 4802F73D  bl 0x8290e450
	ctx.lr = 0x828DED18;
	sub_8290E450(ctx, base);
	// 828DED18: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828DED1C: 4BF0D445  bl 0x827ec160
	ctx.lr = 0x828DED20;
	sub_827EC160(ctx, base);
	// 828DED20: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DED24: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 828DED28: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828DED2C: 4E800421  bctrl
	ctx.lr = 0x828DED30;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DED30: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828DED34: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828DED38: C0360000  lfs f1, 0(r22)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828DED3C: C09E00D4  lfs f4, 0xd4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(212 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 828DED40: C07E00D0  lfs f3, 0xd0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(208 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 828DED44: C05E00CC  lfs f2, 0xcc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(204 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 828DED48: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828DED4C: ECA0F82A  fadds f5, f0, f31
	ctx.f[5].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 828DED50: 48031559  bl 0x829102a8
	ctx.lr = 0x828DED54;
	sub_829102A8(ctx, base);
	// 828DED54: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DED58: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828DED5C: 816B01A4  lwz r11, 0x1a4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(420 as u32) ) } as u64;
	// 828DED60: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828DED64: 4E800421  bctrl
	ctx.lr = 0x828DED68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DED68: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828DED6C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 828DED70: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828DED74: 38A001CC  li r5, 0x1cc
	ctx.r[5].s64 = 460;
	// 828DED78: 386000A0  li r3, 0xa0
	ctx.r[3].s64 = 160;
	// 828DED7C: 4B9E165D  bl 0x822c03d8
	ctx.lr = 0x828DED80;
	sub_822C03D8(ctx, base);
	// 828DED80: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828DED84: 41820018  beq 0x828ded9c
	if ctx.cr[0].eq {
	pc = 0x828DED9C; continue 'dispatch;
	}
	// 828DED88: 38BE0124  addi r5, r30, 0x124
	ctx.r[5].s64 = ctx.r[30].s64 + 292;
	// 828DED8C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828DED90: 48061341  bl 0x829400d0
	ctx.lr = 0x828DED94;
	sub_829400D0(ctx, base);
	// 828DED94: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DED98: 48000008  b 0x828deda0
	pc = 0x828DEDA0; continue 'dispatch;
	// 828DED9C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DEDA0: 387D0374  addi r3, r29, 0x374
	ctx.r[3].s64 = ctx.r[29].s64 + 884;
	// 828DEDA4: 4BF896A5  bl 0x82868448
	ctx.lr = 0x828DEDA8;
	sub_82868448(ctx, base);
	// 828DEDA8: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 828DEDAC: 48274625  bl 0x82b533d0
	ctx.lr = 0x828DEDB0;
	sub_82B533D0(ctx, base);
	// 828DEDB0: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 828DEDB4: 3940001E  li r10, 0x1e
	ctx.r[10].s64 = 30;
	// 828DEDB8: D3C100DC  stfs f30, 0xdc(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 828DEDBC: 938100B0  stw r28, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[28].u32 ) };
	// 828DEDC0: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 828DEDC4: 914100B4  stw r10, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[10].u32 ) };
	// 828DEDC8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DEDCC: 938100D8  stw r28, 0xd8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[28].u32 ) };
	// 828DEDD0: 38891EDC  addi r4, r9, 0x1edc
	ctx.r[4].s64 = ctx.r[9].s64 + 7900;
	// 828DEDD4: C00B8CF0  lfs f0, -0x7310(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-29456 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828DEDD8: D00100D4  stfs f0, 0xd4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 828DEDDC: 83DD0260  lwz r30, 0x260(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(608 as u32) ) } as u64;
	// 828DEDE0: 48514C29  bl 0x82df3a08
	ctx.lr = 0x828DEDE4;
	sub_82DF3A08(ctx, base);
	// 828DEDE4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DEDE8: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828DEDEC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828DEDF0: 480333C9  bl 0x829121b8
	ctx.lr = 0x828DEDF4;
	sub_829121B8(ctx, base);
	// 828DEDF4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DEDF8: 48514631  bl 0x82df3428
	ctx.lr = 0x828DEDFC;
	sub_82DF3428(ctx, base);
	// 828DEDFC: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828DEE00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DEE04: 808B7304  lwz r4, 0x7304(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(29444 as u32) ) } as u64;
	// 828DEE08: 48514C01  bl 0x82df3a08
	ctx.lr = 0x828DEE0C;
	sub_82DF3A08(ctx, base);
	// 828DEE0C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DEE10: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828DEE14: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 828DEE18: 38E100B0  addi r7, r1, 0xb0
	ctx.r[7].s64 = ctx.r[1].s64 + 176;
	// 828DEE1C: 7EA6AB78  mr r6, r21
	ctx.r[6].u64 = ctx.r[21].u64;
	// 828DEE20: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 828DEE24: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 828DEE28: 48034E21  bl 0x82913c48
	ctx.lr = 0x828DEE2C;
	sub_82913C48(ctx, base);
	// 828DEE2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DEE30: 485145F9  bl 0x82df3428
	ctx.lr = 0x828DEE34;
	sub_82DF3428(ctx, base);
	// 828DEE34: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828DEE38: 93A10088  stw r29, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[29].u32 ) };
	// 828DEE3C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DEE40: 396B4320  addi r11, r11, 0x4320
	ctx.r[11].s64 = ctx.r[11].s64 + 17184;
	// 828DEE44: 93E10094  stw r31, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[31].u32 ) };
	// 828DEE48: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828DEE4C: 91610090  stw r11, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 828DEE50: E8A10088  ld r5, 0x88(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	// 828DEE54: E8810090  ld r4, 0x90(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 828DEE58: 4BFFDC79  bl 0x828dcad0
	ctx.lr = 0x828DEE5C;
	sub_828DCAD0(ctx, base);
	// 828DEE5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DEE60: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828DEE64: 48033AB5  bl 0x82912918
	ctx.lr = 0x828DEE68;
	sub_82912918(ctx, base);
	// 828DEE68: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DEE6C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828DEE70: 816B01A0  lwz r11, 0x1a0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(416 as u32) ) } as u64;
	// 828DEE74: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828DEE78: 4E800421  bctrl
	ctx.lr = 0x828DEE7C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DEE7C: 38830088  addi r4, r3, 0x88
	ctx.r[4].s64 = ctx.r[3].s64 + 136;
	// 828DEE80: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DEE84: 4803332D  bl 0x829121b0
	ctx.lr = 0x828DEE88;
	sub_829121B0(ctx, base);
	// 828DEE88: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828DEE8C: 4BFFBA15  bl 0x828da8a0
	ctx.lr = 0x828DEE90;
	sub_828DA8A0(ctx, base);
	// 828DEE90: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 828DEE94: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 828DEE98: 4BC297E9  bl 0x82508680
	ctx.lr = 0x828DEE9C;
	sub_82508680(ctx, base);
	// 828DEE9C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828DEEA0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DEEA4: 388BF8FC  addi r4, r11, -0x704
	ctx.r[4].s64 = ctx.r[11].s64 + -1796;
	// 828DEEA8: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 828DEEAC: 4BFC6D15  bl 0x828a5bc0
	ctx.lr = 0x828DEEB0;
	sub_828A5BC0(ctx, base);
	// 828DEEB0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DEEB4: 916100E8  stw r11, 0xe8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 828DEEB8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DEEBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DEEC0: 916100EC  stw r11, 0xec(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 828DEEC4: 419A0024  beq cr6, 0x828deee8
	if ctx.cr[6].eq {
	pc = 0x828DEEE8; continue 'dispatch;
	}
	// 828DEEC8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828DEECC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828DEED0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DEED4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828DEED8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828DEEDC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828DEEE0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DEEE4: 4082FFE8  bne 0x828deecc
	if !ctx.cr[0].eq {
	pc = 0x828DEECC; continue 'dispatch;
	}
	// 828DEEE8: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 828DEEEC: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828DEEF0: 38E100E8  addi r7, r1, 0xe8
	ctx.r[7].s64 = ctx.r[1].s64 + 232;
	// 828DEEF4: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 828DEEF8: 38A001ED  li r5, 0x1ed
	ctx.r[5].s64 = 493;
	// 828DEEFC: 387D0028  addi r3, r29, 0x28
	ctx.r[3].s64 = ctx.r[29].s64 + 40;
	// 828DEF00: 48579B41  bl 0x82e58a40
	ctx.lr = 0x828DEF04;
	sub_82E58A40(ctx, base);
	// 828DEF04: 806100EC  lwz r3, 0xec(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(236 as u32) ) } as u64;
	// 828DEF08: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DEF0C: 419A0008  beq cr6, 0x828def14
	if ctx.cr[6].eq {
	pc = 0x828DEF14; continue 'dispatch;
	}
	// 828DEF10: 4B9E1981  bl 0x822c0890
	ctx.lr = 0x828DEF14;
	sub_822C0890(ctx, base);
	// 828DEF14: 80610104  lwz r3, 0x104(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 828DEF18: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DEF1C: 419A0008  beq cr6, 0x828def24
	if ctx.cr[6].eq {
	pc = 0x828DEF24; continue 'dispatch;
	}
	// 828DEF20: 4B9E1971  bl 0x822c0890
	ctx.lr = 0x828DEF24;
	sub_822C0890(ctx, base);
	// 828DEF24: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828DEF28: 480319A9  bl 0x829108d0
	ctx.lr = 0x828DEF2C;
	sub_829108D0(ctx, base);
	// 828DEF2C: 382101B0  addi r1, r1, 0x1b0
	ctx.r[1].s64 = ctx.r[1].s64 + 432;
	// 828DEF30: CBA1FF78  lfd f29, -0x88(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-136 as u32) ) };
	// 828DEF34: CBC1FF80  lfd f30, -0x80(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-128 as u32) ) };
	// 828DEF38: CBE1FF88  lfd f31, -0x78(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-120 as u32) ) };
	// 828DEF3C: 488C9258  b 0x831a8194
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DEF40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DEF40 size=60
    let mut pc: u32 = 0x828DEF40;
    'dispatch: loop {
        match pc {
            0x828DEF40 => {
    //   block [0x828DEF40..0x828DEF7C)
	// 828DEF40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DEF44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DEF48: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828DEF4C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DEF50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DEF54: 4803664D  bl 0x829155a0
	ctx.lr = 0x828DEF58;
	sub_829155A0(ctx, base);
	// 828DEF58: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828DEF5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DEF60: 396B01C8  addi r11, r11, 0x1c8
	ctx.r[11].s64 = ctx.r[11].s64 + 456;
	// 828DEF64: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828DEF68: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828DEF6C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DEF70: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DEF74: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828DEF78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DEF80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DEF80 size=88
    let mut pc: u32 = 0x828DEF80;
    'dispatch: loop {
        match pc {
            0x828DEF80 => {
    //   block [0x828DEF80..0x828DEFD8)
	// 828DEF80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DEF84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DEF88: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828DEF8C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828DEF90: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DEF94: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DEF98: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828DEF9C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828DEFA0: 396B01C8  addi r11, r11, 0x1c8
	ctx.r[11].s64 = ctx.r[11].s64 + 456;
	// 828DEFA4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828DEFA8: 480365E1  bl 0x82915588
	ctx.lr = 0x828DEFAC;
	sub_82915588(ctx, base);
	// 828DEFAC: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DEFB0: 4182000C  beq 0x828defbc
	if ctx.cr[0].eq {
	pc = 0x828DEFBC; continue 'dispatch;
	}
	// 828DEFB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DEFB8: 4B9E12B1  bl 0x822c0268
	ctx.lr = 0x828DEFBC;
	sub_822C0268(ctx, base);
	// 828DEFBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DEFC0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828DEFC4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DEFC8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DEFCC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828DEFD0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828DEFD4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DEFD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828DEFD8 size=432
    let mut pc: u32 = 0x828DEFD8;
    'dispatch: loop {
        match pc {
            0x828DEFD8 => {
    //   block [0x828DEFD8..0x828DF188)
	// 828DEFD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DEFDC: 488C9179  bl 0x831a8154
	ctx.lr = 0x828DEFE0;
	sub_831A8130(ctx, base);
	// 828DEFE0: DBE1FFA8  stfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 828DEFE4: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DEFE8: 832D0000  lwz r25, 0(r13)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DEFEC: 3B000014  li r24, 0x14
	ctx.r[24].s64 = 20;
	// 828DEFF0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828DEFF4: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828DEFF8: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 828DEFFC: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 828DF000: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828DF004: 7C78C82E  lwzx r3, r24, r25
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[24].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 828DF008: 485C1729  bl 0x82ea0730
	ctx.lr = 0x828DF00C;
	sub_82EA0730(ctx, base);
	// 828DF00C: 3AE00020  li r23, 0x20
	ctx.r[23].s64 = 32;
	// 828DF010: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828DF014: B2E30004  sth r23, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[23].u16 ) };
	// 828DF018: C3EB9450  lfs f31, -0x6bb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828DF01C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828DF020: 4863B1D1  bl 0x82f1a1f0
	ctx.lr = 0x828DF024;
	sub_82F1A1F0(ctx, base);
	// 828DF024: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 828DF028: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 828DF02C: 4182000C  beq 0x828df038
	if ctx.cr[0].eq {
	pc = 0x828DF038; continue 'dispatch;
	}
	// 828DF030: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828DF034: 4BA09215  bl 0x822e8248
	ctx.lr = 0x828DF038;
	sub_822E8248(ctx, base);
	// 828DF038: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828DF03C: 839E0000  lwz r28, 0(r30)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DF040: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DF044: 809A0000  lwz r4, 0(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DF048: 3BEB3C48  addi r31, r11, 0x3c48
	ctx.r[31].s64 = ctx.r[11].s64 + 15432;
	// 828DF04C: 38BF0004  addi r5, r31, 4
	ctx.r[5].s64 = ctx.r[31].s64 + 4;
	// 828DF050: 48535FE1  bl 0x82e15030
	ctx.lr = 0x828DF054;
	sub_82E15030(ctx, base);
	// 828DF054: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 828DF058: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 828DF05C: 815C00C8  lwz r10, 0xc8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(200 as u32) ) } as u64;
	// 828DF060: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DF064: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828DF068: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DF06C: 80CB6820  lwz r6, 0x6820(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26656 as u32) ) } as u64;
	// 828DF070: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828DF074: 4E800421  bctrl
	ctx.lr = 0x828DF078;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DF078: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828DF07C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828DF080: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DF084: 419A000C  beq cr6, 0x828df090
	if ctx.cr[6].eq {
	pc = 0x828DF090; continue 'dispatch;
	}
	// 828DF088: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828DF08C: 4BA091DD  bl 0x822e8268
	ctx.lr = 0x828DF090;
	sub_822E8268(ctx, base);
	// 828DF090: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DF094: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 828DF098: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 828DF09C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828DF0A0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828DF0A4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DF0A8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828DF0AC: 4BF8C075  bl 0x8286b120
	ctx.lr = 0x828DF0B0;
	sub_8286B120(ctx, base);
	// 828DF0B0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828DF0B4: 419A000C  beq cr6, 0x828df0c0
	if ctx.cr[6].eq {
	pc = 0x828DF0C0; continue 'dispatch;
	}
	// 828DF0B8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828DF0BC: 4BA091AD  bl 0x822e8268
	ctx.lr = 0x828DF0C0;
	sub_822E8268(ctx, base);
	// 828DF0C0: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 828DF0C4: 7C78C82E  lwzx r3, r24, r25
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[24].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 828DF0C8: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 828DF0CC: 485C1665  bl 0x82ea0730
	ctx.lr = 0x828DF0D0;
	sub_82EA0730(ctx, base);
	// 828DF0D0: B2E30004  sth r23, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[23].u16 ) };
	// 828DF0D4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828DF0D8: 4863B119  bl 0x82f1a1f0
	ctx.lr = 0x828DF0DC;
	sub_82F1A1F0(ctx, base);
	// 828DF0DC: 7C7C1B79  or. r28, r3, r3
	ctx.r[28].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 828DF0E0: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 828DF0E4: 4182000C  beq 0x828df0f0
	if ctx.cr[0].eq {
	pc = 0x828DF0F0; continue 'dispatch;
	}
	// 828DF0E8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828DF0EC: 4BA0915D  bl 0x822e8248
	ctx.lr = 0x828DF0F0;
	sub_822E8248(ctx, base);
	// 828DF0F0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DF0F4: 83BE0000  lwz r29, 0(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DF0F8: 38BF000C  addi r5, r31, 0xc
	ctx.r[5].s64 = ctx.r[31].s64 + 12;
	// 828DF0FC: 809A0000  lwz r4, 0(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DF100: 48535F31  bl 0x82e15030
	ctx.lr = 0x828DF104;
	sub_82E15030(ctx, base);
	// 828DF104: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 828DF108: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 828DF10C: 815D00C8  lwz r10, 0xc8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(200 as u32) ) } as u64;
	// 828DF110: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 828DF114: 389F0008  addi r4, r31, 8
	ctx.r[4].s64 = ctx.r[31].s64 + 8;
	// 828DF118: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DF11C: 80CB681C  lwz r6, 0x681c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26652 as u32) ) } as u64;
	// 828DF120: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828DF124: 4E800421  bctrl
	ctx.lr = 0x828DF128;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DF128: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828DF12C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828DF130: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DF134: 419A000C  beq cr6, 0x828df140
	if ctx.cr[6].eq {
	pc = 0x828DF140; continue 'dispatch;
	}
	// 828DF138: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828DF13C: 4BA0912D  bl 0x822e8268
	ctx.lr = 0x828DF140;
	sub_822E8268(ctx, base);
	// 828DF140: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828DF144: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828DF148: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 828DF14C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828DF150: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DF154: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828DF158: 4BF8BFC9  bl 0x8286b120
	ctx.lr = 0x828DF15C;
	sub_8286B120(ctx, base);
	// 828DF15C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828DF160: 419A000C  beq cr6, 0x828df16c
	if ctx.cr[6].eq {
	pc = 0x828DF16C; continue 'dispatch;
	}
	// 828DF164: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828DF168: 4BA09101  bl 0x822e8268
	ctx.lr = 0x828DF16C;
	sub_822E8268(ctx, base);
	// 828DF16C: 807A0004  lwz r3, 4(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DF170: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DF174: 419A0008  beq cr6, 0x828df17c
	if ctx.cr[6].eq {
	pc = 0x828DF17C; continue 'dispatch;
	}
	// 828DF178: 4B9E1719  bl 0x822c0890
	ctx.lr = 0x828DF17C;
	sub_822C0890(ctx, base);
	// 828DF17C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828DF180: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 828DF184: 488C9020  b 0x831a81a4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DF188(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DF188 size=60
    let mut pc: u32 = 0x828DF188;
    'dispatch: loop {
        match pc {
            0x828DF188 => {
    //   block [0x828DF188..0x828DF1C4)
	// 828DF188: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DF18C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DF190: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828DF194: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DF198: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DF19C: 48037D3D  bl 0x82916ed8
	ctx.lr = 0x828DF1A0;
	sub_82916ED8(ctx, base);
	// 828DF1A0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828DF1A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DF1A8: 396B020C  addi r11, r11, 0x20c
	ctx.r[11].s64 = ctx.r[11].s64 + 524;
	// 828DF1AC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828DF1B0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828DF1B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DF1B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DF1BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828DF1C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DF1C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DF1C8 size=88
    let mut pc: u32 = 0x828DF1C8;
    'dispatch: loop {
        match pc {
            0x828DF1C8 => {
    //   block [0x828DF1C8..0x828DF220)
	// 828DF1C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DF1CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DF1D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828DF1D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828DF1D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DF1DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DF1E0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828DF1E4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828DF1E8: 396B020C  addi r11, r11, 0x20c
	ctx.r[11].s64 = ctx.r[11].s64 + 524;
	// 828DF1EC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828DF1F0: 48037979  bl 0x82916b68
	ctx.lr = 0x828DF1F4;
	sub_82916B68(ctx, base);
	// 828DF1F4: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DF1F8: 4182000C  beq 0x828df204
	if ctx.cr[0].eq {
	pc = 0x828DF204; continue 'dispatch;
	}
	// 828DF1FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DF200: 4B9E1069  bl 0x822c0268
	ctx.lr = 0x828DF204;
	sub_822C0268(ctx, base);
	// 828DF204: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DF208: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828DF20C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DF210: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DF214: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828DF218: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828DF21C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DF220(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DF220 size=96
    let mut pc: u32 = 0x828DF220;
    'dispatch: loop {
        match pc {
            0x828DF220 => {
    //   block [0x828DF220..0x828DF280)
	// 828DF220: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DF224: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DF228: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828DF22C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DF230: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DF234: 480792AD  bl 0x829584e0
	ctx.lr = 0x828DF238;
	sub_829584E0(ctx, base);
	// 828DF238: 387F0170  addi r3, r31, 0x170
	ctx.r[3].s64 = ctx.r[31].s64 + 368;
	// 828DF23C: 480789BD  bl 0x82957bf8
	ctx.lr = 0x828DF240;
	sub_82957BF8(ctx, base);
	// 828DF240: 387F0180  addi r3, r31, 0x180
	ctx.r[3].s64 = ctx.r[31].s64 + 384;
	// 828DF244: 480789B5  bl 0x82957bf8
	ctx.lr = 0x828DF248;
	sub_82957BF8(ctx, base);
	// 828DF248: 387F0190  addi r3, r31, 0x190
	ctx.r[3].s64 = ctx.r[31].s64 + 400;
	// 828DF24C: 480789AD  bl 0x82957bf8
	ctx.lr = 0x828DF250;
	sub_82957BF8(ctx, base);
	// 828DF250: 387F01A0  addi r3, r31, 0x1a0
	ctx.r[3].s64 = ctx.r[31].s64 + 416;
	// 828DF254: 4807656D  bl 0x829557c0
	ctx.lr = 0x828DF258;
	sub_829557C0(ctx, base);
	// 828DF258: 387F01BC  addi r3, r31, 0x1bc
	ctx.r[3].s64 = ctx.r[31].s64 + 444;
	// 828DF25C: 48076565  bl 0x829557c0
	ctx.lr = 0x828DF260;
	sub_829557C0(ctx, base);
	// 828DF260: 387F01D8  addi r3, r31, 0x1d8
	ctx.r[3].s64 = ctx.r[31].s64 + 472;
	// 828DF264: 4807655D  bl 0x829557c0
	ctx.lr = 0x828DF268;
	sub_829557C0(ctx, base);
	// 828DF268: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DF26C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828DF270: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DF274: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DF278: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828DF27C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DF280(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DF280 size=48
    let mut pc: u32 = 0x828DF280;
    'dispatch: loop {
        match pc {
            0x828DF280 => {
    //   block [0x828DF280..0x828DF2B0)
	// 828DF280: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DF284: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DF288: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828DF28C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DF290: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DF294: 480794B5  bl 0x82958748
	ctx.lr = 0x828DF298;
	sub_82958748(ctx, base);
	// 828DF298: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DF29C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828DF2A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DF2A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DF2A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828DF2AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DF2B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DF2B0 size=860
    let mut pc: u32 = 0x828DF2B0;
    'dispatch: loop {
        match pc {
            0x828DF2B0 => {
    //   block [0x828DF2B0..0x828DF60C)
	// 828DF2B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DF2B4: 488C8EB9  bl 0x831a816c
	ctx.lr = 0x828DF2B8;
	sub_831A8130(ctx, base);
	// 828DF2B8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DF2BC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828DF2C0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828DF2C4: 3BFE0004  addi r31, r30, 4
	ctx.r[31].s64 = ctx.r[30].s64 + 4;
	// 828DF2C8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DF2CC: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DF2D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DF2D4: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828DF2D8: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828DF2DC: 419A0024  beq cr6, 0x828df300
	if ctx.cr[6].eq {
	pc = 0x828DF300; continue 'dispatch;
	}
	// 828DF2E0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828DF2E4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828DF2E8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DF2EC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828DF2F0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828DF2F4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828DF2F8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DF2FC: 4082FFE8  bne 0x828df2e4
	if !ctx.cr[0].eq {
	pc = 0x828DF2E4; continue 'dispatch;
	}
	// 828DF300: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828DF304: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828DF308: 48079511  bl 0x82958818
	ctx.lr = 0x828DF30C;
	sub_82958818(ctx, base);
	// 828DF30C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828DF310: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DF314: 388B3C98  addi r4, r11, 0x3c98
	ctx.r[4].s64 = ctx.r[11].s64 + 15512;
	// 828DF318: 485146F1  bl 0x82df3a08
	ctx.lr = 0x828DF31C;
	sub_82DF3A08(ctx, base);
	// 828DF31C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828DF320: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DF324: 388B5D2C  addi r4, r11, 0x5d2c
	ctx.r[4].s64 = ctx.r[11].s64 + 23852;
	// 828DF328: 485146E1  bl 0x82df3a08
	ctx.lr = 0x828DF32C;
	sub_82DF3A08(ctx, base);
	// 828DF32C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DF330: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DF334: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DF338: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828DF33C: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 828DF340: 419A0024  beq cr6, 0x828df364
	if ctx.cr[6].eq {
	pc = 0x828DF364; continue 'dispatch;
	}
	// 828DF344: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828DF348: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828DF34C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DF350: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828DF354: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828DF358: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828DF35C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DF360: 4082FFE8  bne 0x828df348
	if !ctx.cr[0].eq {
	pc = 0x828DF348; continue 'dispatch;
	}
	// 828DF364: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 828DF368: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828DF36C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828DF370: 387D0170  addi r3, r29, 0x170
	ctx.r[3].s64 = ctx.r[29].s64 + 368;
	// 828DF374: 4807889D  bl 0x82957c10
	ctx.lr = 0x828DF378;
	sub_82957C10(ctx, base);
	// 828DF378: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DF37C: 485140AD  bl 0x82df3428
	ctx.lr = 0x828DF380;
	sub_82DF3428(ctx, base);
	// 828DF380: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DF384: 485140A5  bl 0x82df3428
	ctx.lr = 0x828DF388;
	sub_82DF3428(ctx, base);
	// 828DF388: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828DF38C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DF390: 388B8218  addi r4, r11, -0x7de8
	ctx.r[4].s64 = ctx.r[11].s64 + -32232;
	// 828DF394: 48514675  bl 0x82df3a08
	ctx.lr = 0x828DF398;
	sub_82DF3A08(ctx, base);
	// 828DF398: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828DF39C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DF3A0: 388B7C94  addi r4, r11, 0x7c94
	ctx.r[4].s64 = ctx.r[11].s64 + 31892;
	// 828DF3A4: 48514665  bl 0x82df3a08
	ctx.lr = 0x828DF3A8;
	sub_82DF3A08(ctx, base);
	// 828DF3A8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DF3AC: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DF3B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DF3B4: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828DF3B8: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 828DF3BC: 419A0024  beq cr6, 0x828df3e0
	if ctx.cr[6].eq {
	pc = 0x828DF3E0; continue 'dispatch;
	}
	// 828DF3C0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828DF3C4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828DF3C8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DF3CC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828DF3D0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828DF3D4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828DF3D8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DF3DC: 4082FFE8  bne 0x828df3c4
	if !ctx.cr[0].eq {
	pc = 0x828DF3C4; continue 'dispatch;
	}
	// 828DF3E0: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828DF3E4: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828DF3E8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828DF3EC: 387D0180  addi r3, r29, 0x180
	ctx.r[3].s64 = ctx.r[29].s64 + 384;
	// 828DF3F0: 48078821  bl 0x82957c10
	ctx.lr = 0x828DF3F4;
	sub_82957C10(ctx, base);
	// 828DF3F4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DF3F8: 48514031  bl 0x82df3428
	ctx.lr = 0x828DF3FC;
	sub_82DF3428(ctx, base);
	// 828DF3FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DF400: 48514029  bl 0x82df3428
	ctx.lr = 0x828DF404;
	sub_82DF3428(ctx, base);
	// 828DF404: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828DF408: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DF40C: 388B3C80  addi r4, r11, 0x3c80
	ctx.r[4].s64 = ctx.r[11].s64 + 15488;
	// 828DF410: 485145F9  bl 0x82df3a08
	ctx.lr = 0x828DF414;
	sub_82DF3A08(ctx, base);
	// 828DF414: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828DF418: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DF41C: 388B3C74  addi r4, r11, 0x3c74
	ctx.r[4].s64 = ctx.r[11].s64 + 15476;
	// 828DF420: 485145E9  bl 0x82df3a08
	ctx.lr = 0x828DF424;
	sub_82DF3A08(ctx, base);
	// 828DF424: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DF428: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DF42C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DF430: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828DF434: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 828DF438: 419A0024  beq cr6, 0x828df45c
	if ctx.cr[6].eq {
	pc = 0x828DF45C; continue 'dispatch;
	}
	// 828DF43C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828DF440: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828DF444: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DF448: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828DF44C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828DF450: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828DF454: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DF458: 4082FFE8  bne 0x828df440
	if !ctx.cr[0].eq {
	pc = 0x828DF440; continue 'dispatch;
	}
	// 828DF45C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828DF460: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828DF464: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828DF468: 387D0190  addi r3, r29, 0x190
	ctx.r[3].s64 = ctx.r[29].s64 + 400;
	// 828DF46C: 480787A5  bl 0x82957c10
	ctx.lr = 0x828DF470;
	sub_82957C10(ctx, base);
	// 828DF470: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DF474: 48513FB5  bl 0x82df3428
	ctx.lr = 0x828DF478;
	sub_82DF3428(ctx, base);
	// 828DF478: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DF47C: 48513FAD  bl 0x82df3428
	ctx.lr = 0x828DF480;
	sub_82DF3428(ctx, base);
	// 828DF480: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828DF484: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DF488: 388B81F4  addi r4, r11, -0x7e0c
	ctx.r[4].s64 = ctx.r[11].s64 + -32268;
	// 828DF48C: 4851457D  bl 0x82df3a08
	ctx.lr = 0x828DF490;
	sub_82DF3A08(ctx, base);
	// 828DF490: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828DF494: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DF498: 388BA2C4  addi r4, r11, -0x5d3c
	ctx.r[4].s64 = ctx.r[11].s64 + -23868;
	// 828DF49C: 4851456D  bl 0x82df3a08
	ctx.lr = 0x828DF4A0;
	sub_82DF3A08(ctx, base);
	// 828DF4A0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DF4A4: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DF4A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DF4AC: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828DF4B0: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 828DF4B4: 419A0024  beq cr6, 0x828df4d8
	if ctx.cr[6].eq {
	pc = 0x828DF4D8; continue 'dispatch;
	}
	// 828DF4B8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828DF4BC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828DF4C0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DF4C4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828DF4C8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828DF4CC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828DF4D0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DF4D4: 4082FFE8  bne 0x828df4bc
	if !ctx.cr[0].eq {
	pc = 0x828DF4BC; continue 'dispatch;
	}
	// 828DF4D8: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828DF4DC: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828DF4E0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828DF4E4: 387D01A0  addi r3, r29, 0x1a0
	ctx.r[3].s64 = ctx.r[29].s64 + 416;
	// 828DF4E8: 48076391  bl 0x82955878
	ctx.lr = 0x828DF4EC;
	sub_82955878(ctx, base);
	// 828DF4EC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DF4F0: 48513F39  bl 0x82df3428
	ctx.lr = 0x828DF4F4;
	sub_82DF3428(ctx, base);
	// 828DF4F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DF4F8: 48513F31  bl 0x82df3428
	ctx.lr = 0x828DF4FC;
	sub_82DF3428(ctx, base);
	// 828DF4FC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828DF500: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DF504: 388B81DC  addi r4, r11, -0x7e24
	ctx.r[4].s64 = ctx.r[11].s64 + -32292;
	// 828DF508: 48514501  bl 0x82df3a08
	ctx.lr = 0x828DF50C;
	sub_82DF3A08(ctx, base);
	// 828DF50C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828DF510: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DF514: 388B3B6C  addi r4, r11, 0x3b6c
	ctx.r[4].s64 = ctx.r[11].s64 + 15212;
	// 828DF518: 485144F1  bl 0x82df3a08
	ctx.lr = 0x828DF51C;
	sub_82DF3A08(ctx, base);
	// 828DF51C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DF520: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DF524: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DF528: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828DF52C: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 828DF530: 419A0024  beq cr6, 0x828df554
	if ctx.cr[6].eq {
	pc = 0x828DF554; continue 'dispatch;
	}
	// 828DF534: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828DF538: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828DF53C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DF540: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828DF544: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828DF548: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828DF54C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DF550: 4082FFE8  bne 0x828df538
	if !ctx.cr[0].eq {
	pc = 0x828DF538; continue 'dispatch;
	}
	// 828DF554: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828DF558: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828DF55C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828DF560: 387D01BC  addi r3, r29, 0x1bc
	ctx.r[3].s64 = ctx.r[29].s64 + 444;
	// 828DF564: 48076315  bl 0x82955878
	ctx.lr = 0x828DF568;
	sub_82955878(ctx, base);
	// 828DF568: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DF56C: 48513EBD  bl 0x82df3428
	ctx.lr = 0x828DF570;
	sub_82DF3428(ctx, base);
	// 828DF570: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DF574: 48513EB5  bl 0x82df3428
	ctx.lr = 0x828DF578;
	sub_82DF3428(ctx, base);
	// 828DF578: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828DF57C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DF580: 388B0710  addi r4, r11, 0x710
	ctx.r[4].s64 = ctx.r[11].s64 + 1808;
	// 828DF584: 48514485  bl 0x82df3a08
	ctx.lr = 0x828DF588;
	sub_82DF3A08(ctx, base);
	// 828DF588: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828DF58C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DF590: 388B3F6C  addi r4, r11, 0x3f6c
	ctx.r[4].s64 = ctx.r[11].s64 + 16236;
	// 828DF594: 48514475  bl 0x82df3a08
	ctx.lr = 0x828DF598;
	sub_82DF3A08(ctx, base);
	// 828DF598: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DF59C: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DF5A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DF5A4: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828DF5A8: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 828DF5AC: 419A0024  beq cr6, 0x828df5d0
	if ctx.cr[6].eq {
	pc = 0x828DF5D0; continue 'dispatch;
	}
	// 828DF5B0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828DF5B4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828DF5B8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DF5BC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828DF5C0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828DF5C4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828DF5C8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DF5CC: 4082FFE8  bne 0x828df5b4
	if !ctx.cr[0].eq {
	pc = 0x828DF5B4; continue 'dispatch;
	}
	// 828DF5D0: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828DF5D4: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828DF5D8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828DF5DC: 387D01D8  addi r3, r29, 0x1d8
	ctx.r[3].s64 = ctx.r[29].s64 + 472;
	// 828DF5E0: 48076299  bl 0x82955878
	ctx.lr = 0x828DF5E4;
	sub_82955878(ctx, base);
	// 828DF5E4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DF5E8: 48513E41  bl 0x82df3428
	ctx.lr = 0x828DF5EC;
	sub_82DF3428(ctx, base);
	// 828DF5EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DF5F0: 48513E39  bl 0x82df3428
	ctx.lr = 0x828DF5F4;
	sub_82DF3428(ctx, base);
	// 828DF5F4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DF5F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DF5FC: 419A0008  beq cr6, 0x828df604
	if ctx.cr[6].eq {
	pc = 0x828DF604; continue 'dispatch;
	}
	// 828DF600: 4B9E1291  bl 0x822c0890
	ctx.lr = 0x828DF604;
	sub_822C0890(ctx, base);
	// 828DF604: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828DF608: 488C8BB4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DF610(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DF610 size=120
    let mut pc: u32 = 0x828DF610;
    'dispatch: loop {
        match pc {
            0x828DF610 => {
    //   block [0x828DF610..0x828DF688)
	// 828DF610: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DF614: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DF618: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828DF61C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DF620: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DF624: 3BE40004  addi r31, r4, 4
	ctx.r[31].s64 = ctx.r[4].s64 + 4;
	// 828DF628: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DF62C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DF630: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828DF634: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828DF638: 419A0024  beq cr6, 0x828df65c
	if ctx.cr[6].eq {
	pc = 0x828DF65C; continue 'dispatch;
	}
	// 828DF63C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828DF640: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828DF644: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DF648: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828DF64C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828DF650: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828DF654: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DF658: 4082FFE8  bne 0x828df640
	if !ctx.cr[0].eq {
	pc = 0x828DF640; continue 'dispatch;
	}
	// 828DF65C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DF660: 48079F21  bl 0x82959580
	ctx.lr = 0x828DF664;
	sub_82959580(ctx, base);
	// 828DF664: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DF668: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828DF66C: 419A0008  beq cr6, 0x828df674
	if ctx.cr[6].eq {
	pc = 0x828DF674; continue 'dispatch;
	}
	// 828DF670: 4B9E1221  bl 0x822c0890
	ctx.lr = 0x828DF674;
	sub_822C0890(ctx, base);
	// 828DF674: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828DF678: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DF67C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DF680: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828DF684: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DF688(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DF688 size=696
    let mut pc: u32 = 0x828DF688;
    'dispatch: loop {
        match pc {
            0x828DF688 => {
    //   block [0x828DF688..0x828DF940)
	// 828DF688: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DF68C: 488C8ADD  bl 0x831a8168
	ctx.lr = 0x828DF690;
	sub_831A8130(ctx, base);
	// 828DF690: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DF694: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828DF698: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828DF69C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828DF6A0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828DF6A4: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828DF6A8: 419A0290  beq cr6, 0x828df938
	if ctx.cr[6].eq {
	pc = 0x828DF938; continue 'dispatch;
	}
	// 828DF6AC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828DF6B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DF6B4: 388B12B0  addi r4, r11, 0x12b0
	ctx.r[4].s64 = ctx.r[11].s64 + 4784;
	// 828DF6B8: 48514351  bl 0x82df3a08
	ctx.lr = 0x828DF6BC;
	sub_82DF3A08(ctx, base);
	// 828DF6BC: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 828DF6C0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DF6C4: 388BBE80  addi r4, r11, -0x4180
	ctx.r[4].s64 = ctx.r[11].s64 + -16768;
	// 828DF6C8: 48514341  bl 0x82df3a08
	ctx.lr = 0x828DF6CC;
	sub_82DF3A08(ctx, base);
	// 828DF6CC: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 828DF6D0: 38E00009  li r7, 9
	ctx.r[7].s64 = 9;
	// 828DF6D4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828DF6D8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828DF6DC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DF6E0: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 828DF6E4: 4BCCE4AD  bl 0x825adb90
	ctx.lr = 0x828DF6E8;
	sub_825ADB90(ctx, base);
	// 828DF6E8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828DF6EC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828DF6F0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828DF6F4: 4BCC26C5  bl 0x825a1db8
	ctx.lr = 0x828DF6F8;
	sub_825A1DB8(ctx, base);
	// 828DF6F8: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 828DF6FC: 48513D2D  bl 0x82df3428
	ctx.lr = 0x828DF700;
	sub_82DF3428(ctx, base);
	// 828DF700: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 828DF704: 4B9E95B5  bl 0x822c8cb8
	ctx.lr = 0x828DF708;
	sub_822C8CB8(ctx, base);
	// 828DF708: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DF70C: 48513D1D  bl 0x82df3428
	ctx.lr = 0x828DF710;
	sub_82DF3428(ctx, base);
	// 828DF710: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DF714: 48513D15  bl 0x82df3428
	ctx.lr = 0x828DF718;
	sub_82DF3428(ctx, base);
	// 828DF718: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 828DF71C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DF720: 388BBE9C  addi r4, r11, -0x4164
	ctx.r[4].s64 = ctx.r[11].s64 + -16740;
	// 828DF724: 485142E5  bl 0x82df3a08
	ctx.lr = 0x828DF728;
	sub_82DF3A08(ctx, base);
	// 828DF728: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 828DF72C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DF730: 388B4858  addi r4, r11, 0x4858
	ctx.r[4].s64 = ctx.r[11].s64 + 18520;
	// 828DF734: 485142D5  bl 0x82df3a08
	ctx.lr = 0x828DF738;
	sub_82DF3A08(ctx, base);
	// 828DF738: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828DF73C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828DF740: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828DF744: 38BE0004  addi r5, r30, 4
	ctx.r[5].s64 = ctx.r[30].s64 + 4;
	// 828DF748: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828DF74C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828DF750: 4BCCE441  bl 0x825adb90
	ctx.lr = 0x828DF754;
	sub_825ADB90(ctx, base);
	// 828DF754: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828DF758: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DF75C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828DF760: 4BCC2659  bl 0x825a1db8
	ctx.lr = 0x828DF764;
	sub_825A1DB8(ctx, base);
	// 828DF764: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 828DF768: 48513CC1  bl 0x82df3428
	ctx.lr = 0x828DF76C;
	sub_82DF3428(ctx, base);
	// 828DF76C: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 828DF770: 4B9E9549  bl 0x822c8cb8
	ctx.lr = 0x828DF774;
	sub_822C8CB8(ctx, base);
	// 828DF774: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DF778: 48513CB1  bl 0x82df3428
	ctx.lr = 0x828DF77C;
	sub_82DF3428(ctx, base);
	// 828DF77C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DF780: 48513CA9  bl 0x82df3428
	ctx.lr = 0x828DF784;
	sub_82DF3428(ctx, base);
	// 828DF784: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828DF788: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828DF78C: 388B0720  addi r4, r11, 0x720
	ctx.r[4].s64 = ctx.r[11].s64 + 1824;
	// 828DF790: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 828DF794: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828DF798: 4B9E0C41  bl 0x822c03d8
	ctx.lr = 0x828DF79C;
	sub_822C03D8(ctx, base);
	// 828DF79C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 828DF7A0: 41820034  beq 0x828df7d4
	if ctx.cr[0].eq {
	pc = 0x828DF7D4; continue 'dispatch;
	}
	// 828DF7A4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828DF7A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DF7AC: 388B3DD4  addi r4, r11, 0x3dd4
	ctx.r[4].s64 = ctx.r[11].s64 + 15828;
	// 828DF7B0: 48514259  bl 0x82df3a08
	ctx.lr = 0x828DF7B4;
	sub_82DF3A08(ctx, base);
	// 828DF7B4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828DF7B8: 38BE0008  addi r5, r30, 8
	ctx.r[5].s64 = ctx.r[30].s64 + 8;
	// 828DF7BC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DF7C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DF7C4: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 828DF7C8: 4BCCCC49  bl 0x825ac410
	ctx.lr = 0x828DF7CC;
	sub_825AC410(ctx, base);
	// 828DF7CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DF7D0: 48000008  b 0x828df7d8
	pc = 0x828DF7D8; continue 'dispatch;
	// 828DF7D4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828DF7D8: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 828DF7DC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DF7E0: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828DF7E4: 4BC13BD5  bl 0x824f33b8
	ctx.lr = 0x828DF7E8;
	sub_824F33B8(ctx, base);
	// 828DF7E8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828DF7EC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DF7F0: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828DF7F4: 4B9E080D  bl 0x822c0000
	ctx.lr = 0x828DF7F8;
	sub_822C0000(ctx, base);
	// 828DF7F8: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DF7FC: 4182000C  beq 0x828df808
	if ctx.cr[0].eq {
	pc = 0x828DF808; continue 'dispatch;
	}
	// 828DF800: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DF804: 48513C25  bl 0x82df3428
	ctx.lr = 0x828DF808;
	sub_82DF3428(ctx, base);
	// 828DF808: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828DF80C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DF810: 388B3DCC  addi r4, r11, 0x3dcc
	ctx.r[4].s64 = ctx.r[11].s64 + 15820;
	// 828DF814: 485141F5  bl 0x82df3a08
	ctx.lr = 0x828DF818;
	sub_82DF3A08(ctx, base);
	// 828DF818: 83810058  lwz r28, 0x58(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828DF81C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828DF820: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828DF824: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828DF828: 4BCCC599  bl 0x825abdc0
	ctx.lr = 0x828DF82C;
	sub_825ABDC0(ctx, base);
	// 828DF82C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DF830: 48513BF9  bl 0x82df3428
	ctx.lr = 0x828DF834;
	sub_82DF3428(ctx, base);
	// 828DF834: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828DF838: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DF83C: 388B3DC4  addi r4, r11, 0x3dc4
	ctx.r[4].s64 = ctx.r[11].s64 + 15812;
	// 828DF840: 485141C9  bl 0x82df3a08
	ctx.lr = 0x828DF844;
	sub_82DF3A08(ctx, base);
	// 828DF844: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828DF848: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828DF84C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828DF850: 4BCCC571  bl 0x825abdc0
	ctx.lr = 0x828DF854;
	sub_825ABDC0(ctx, base);
	// 828DF854: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DF858: 48513BD1  bl 0x82df3428
	ctx.lr = 0x828DF85C;
	sub_82DF3428(ctx, base);
	// 828DF85C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828DF860: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DF864: 388B3D98  addi r4, r11, 0x3d98
	ctx.r[4].s64 = ctx.r[11].s64 + 15768;
	// 828DF868: 485141A1  bl 0x82df3a08
	ctx.lr = 0x828DF86C;
	sub_82DF3A08(ctx, base);
	// 828DF86C: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828DF870: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 828DF874: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828DF878: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 828DF87C: 419A0024  beq cr6, 0x828df8a0
	if ctx.cr[6].eq {
	pc = 0x828DF8A0; continue 'dispatch;
	}
	// 828DF880: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 828DF884: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828DF888: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DF88C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828DF890: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828DF894: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828DF898: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828DF89C: 4082FFE8  bne 0x828df884
	if !ctx.cr[0].eq {
	pc = 0x828DF884; continue 'dispatch;
	}
	// 828DF8A0: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828DF8A4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DF8A8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828DF8AC: 4BCC2865  bl 0x825a2110
	ctx.lr = 0x828DF8B0;
	sub_825A2110(ctx, base);
	// 828DF8B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DF8B4: 48513B75  bl 0x82df3428
	ctx.lr = 0x828DF8B8;
	sub_82DF3428(ctx, base);
	// 828DF8B8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828DF8BC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DF8C0: 388B9D24  addi r4, r11, -0x62dc
	ctx.r[4].s64 = ctx.r[11].s64 + -25308;
	// 828DF8C4: 48514145  bl 0x82df3a08
	ctx.lr = 0x828DF8C8;
	sub_82DF3A08(ctx, base);
	// 828DF8C8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828DF8CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DF8D0: 388B9B58  addi r4, r11, -0x64a8
	ctx.r[4].s64 = ctx.r[11].s64 + -25768;
	// 828DF8D4: 48514135  bl 0x82df3a08
	ctx.lr = 0x828DF8D8;
	sub_82DF3A08(ctx, base);
	// 828DF8D8: 3CE00001  lis r7, 1
	ctx.r[7].s64 = 65536;
	// 828DF8DC: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 828DF8E0: 60E7869F  ori r7, r7, 0x869f
	ctx.r[7].u64 = ctx.r[7].u64 | 34463;
	// 828DF8E4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828DF8E8: 38BE000C  addi r5, r30, 0xc
	ctx.r[5].s64 = ctx.r[30].s64 + 12;
	// 828DF8EC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828DF8F0: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 828DF8F4: 4BCCE29D  bl 0x825adb90
	ctx.lr = 0x828DF8F8;
	sub_825ADB90(ctx, base);
	// 828DF8F8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828DF8FC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DF900: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828DF904: 4BCC24B5  bl 0x825a1db8
	ctx.lr = 0x828DF908;
	sub_825A1DB8(ctx, base);
	// 828DF908: 38610128  addi r3, r1, 0x128
	ctx.r[3].s64 = ctx.r[1].s64 + 296;
	// 828DF90C: 48513B1D  bl 0x82df3428
	ctx.lr = 0x828DF910;
	sub_82DF3428(ctx, base);
	// 828DF910: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 828DF914: 4B9E93A5  bl 0x822c8cb8
	ctx.lr = 0x828DF918;
	sub_822C8CB8(ctx, base);
	// 828DF918: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DF91C: 48513B0D  bl 0x82df3428
	ctx.lr = 0x828DF920;
	sub_82DF3428(ctx, base);
	// 828DF920: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828DF924: 48513B05  bl 0x82df3428
	ctx.lr = 0x828DF928;
	sub_82DF3428(ctx, base);
	// 828DF928: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828DF92C: 419A000C  beq cr6, 0x828df938
	if ctx.cr[6].eq {
	pc = 0x828DF938; continue 'dispatch;
	}
	// 828DF930: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DF934: 4B9E0F5D  bl 0x822c0890
	ctx.lr = 0x828DF938;
	sub_822C0890(ctx, base);
	// 828DF938: 38210160  addi r1, r1, 0x160
	ctx.r[1].s64 = ctx.r[1].s64 + 352;
	// 828DF93C: 488C887C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DF940(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828DF940 size=72
    let mut pc: u32 = 0x828DF940;
    'dispatch: loop {
        match pc {
            0x828DF940 => {
    //   block [0x828DF940..0x828DF988)
	// 828DF940: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DF944: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DF948: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828DF94C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DF950: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DF954: 4857CFD5  bl 0x82e5c928
	ctx.lr = 0x828DF958;
	sub_82E5C928(ctx, base);
	// 828DF958: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828DF95C: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828DF960: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DF964: 394A0798  addi r10, r10, 0x798
	ctx.r[10].s64 = ctx.r[10].s64 + 1944;
	// 828DF968: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828DF96C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828DF970: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828DF974: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828DF978: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DF97C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DF980: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828DF984: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DF988(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DF988 size=96
    let mut pc: u32 = 0x828DF988;
    'dispatch: loop {
        match pc {
            0x828DF988 => {
    //   block [0x828DF988..0x828DF9E8)
	// 828DF988: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DF98C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DF990: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828DF994: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DF998: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DF99C: 4BFFFFA5  bl 0x828df940
	ctx.lr = 0x828DF9A0;
	sub_828DF940(ctx, base);
	// 828DF9A0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828DF9A4: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 828DF9A8: 396B07C0  addi r11, r11, 0x7c0
	ctx.r[11].s64 = ctx.r[11].s64 + 1984;
	// 828DF9AC: 388A40A4  addi r4, r10, 0x40a4
	ctx.r[4].s64 = ctx.r[10].s64 + 16548;
	// 828DF9B0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828DF9B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DF9B8: 48514051  bl 0x82df3a08
	ctx.lr = 0x828DF9BC;
	sub_82DF3A08(ctx, base);
	// 828DF9BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DF9C0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DF9C4: 48579D25  bl 0x82e596e8
	ctx.lr = 0x828DF9C8;
	sub_82E596E8(ctx, base);
	// 828DF9C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DF9CC: 48513A5D  bl 0x82df3428
	ctx.lr = 0x828DF9D0;
	sub_82DF3428(ctx, base);
	// 828DF9D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DF9D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828DF9D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DF9DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DF9E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828DF9E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DF9E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DF9E8 size=84
    let mut pc: u32 = 0x828DF9E8;
    'dispatch: loop {
        match pc {
            0x828DF9E8 => {
    //   block [0x828DF9E8..0x828DFA3C)
	// 828DF9E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DF9EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DF9F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828DF9F4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DF9F8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DF9FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DFA00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DFA04: 808B0AF4  lwz r4, 0xaf4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2804 as u32) ) } as u64;
	// 828DFA08: 48514001  bl 0x82df3a08
	ctx.lr = 0x828DFA0C;
	sub_82DF3A08(ctx, base);
	// 828DFA0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DFA10: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 828DFA14: 48874BED  bl 0x83154600
	ctx.lr = 0x828DFA18;
	sub_83154600(ctx, base);
	// 828DFA18: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DFA1C: 4BF0FD25  bl 0x827ef740
	ctx.lr = 0x828DFA20;
	sub_827EF740(ctx, base);
	// 828DFA20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DFA24: 48513A05  bl 0x82df3428
	ctx.lr = 0x828DFA28;
	sub_82DF3428(ctx, base);
	// 828DFA28: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828DFA2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DFA30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DFA34: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828DFA38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DFA40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DFA40 size=196
    let mut pc: u32 = 0x828DFA40;
    'dispatch: loop {
        match pc {
            0x828DFA40 => {
    //   block [0x828DFA40..0x828DFB04)
	// 828DFA40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DFA44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DFA48: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828DFA4C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828DFA50: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DFA54: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828DFA58: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DFA5C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828DFA60: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828DFA64: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828DFA68: 4B9E0ED1  bl 0x822c0938
	ctx.lr = 0x828DFA6C;
	sub_822C0938(ctx, base);
	// 828DFA6C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828DFA70: 41820028  beq 0x828dfa98
	if ctx.cr[0].eq {
	pc = 0x828DFA98; continue 'dispatch;
	}
	// 828DFA74: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828DFA78: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828DFA7C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828DFA80: 392B07EC  addi r9, r11, 0x7ec
	ctx.r[9].s64 = ctx.r[11].s64 + 2028;
	// 828DFA84: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828DFA88: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828DFA8C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828DFA90: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828DFA94: 48000008  b 0x828dfa9c
	pc = 0x828DFA9C; continue 'dispatch;
	// 828DFA98: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DFA9C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828DFAA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828DFAA4: 409A0044  bne cr6, 0x828dfae8
	if !ctx.cr[6].eq {
	pc = 0x828DFAE8; continue 'dispatch;
	}
	// 828DFAA8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828DFAAC: 419A001C  beq cr6, 0x828dfac8
	if ctx.cr[6].eq {
	pc = 0x828DFAC8; continue 'dispatch;
	}
	// 828DFAB0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DFAB4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828DFAB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DFABC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828DFAC0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828DFAC4: 4E800421  bctrl
	ctx.lr = 0x828DFAC8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DFAC8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DFACC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828DFAD0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DFAD4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828DFAD8: 816B8180  lwz r11, -0x7e80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-32384 as u32) ) } as u64;
	// 828DFADC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828DFAE0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828DFAE4: 4B9E051D  bl 0x822c0000
	ctx.lr = 0x828DFAE8;
	sub_822C0000(ctx, base);
	// 828DFAE8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DFAEC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828DFAF0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DFAF4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DFAF8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828DFAFC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828DFB00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DFB08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DFB08 size=108
    let mut pc: u32 = 0x828DFB08;
    'dispatch: loop {
        match pc {
            0x828DFB08 => {
    //   block [0x828DFB08..0x828DFB74)
	// 828DFB08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DFB0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DFB10: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828DFB14: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DFB18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DFB1C: 4BFFFE25  bl 0x828df940
	ctx.lr = 0x828DFB20;
	sub_828DF940(ctx, base);
	// 828DFB20: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828DFB24: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DFB28: 394A0800  addi r10, r10, 0x800
	ctx.r[10].s64 = ctx.r[10].s64 + 2048;
	// 828DFB2C: 3D20832D  lis r9, -0x7cd3
	ctx.r[9].s64 = -2094202880;
	// 828DFB30: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828DFB34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DFB38: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828DFB3C: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 828DFB40: 80890AF0  lwz r4, 0xaf0(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2800 as u32) ) } as u64;
	// 828DFB44: 48513EC5  bl 0x82df3a08
	ctx.lr = 0x828DFB48;
	sub_82DF3A08(ctx, base);
	// 828DFB48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DFB4C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DFB50: 48579B99  bl 0x82e596e8
	ctx.lr = 0x828DFB54;
	sub_82E596E8(ctx, base);
	// 828DFB54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DFB58: 485138D1  bl 0x82df3428
	ctx.lr = 0x828DFB5C;
	sub_82DF3428(ctx, base);
	// 828DFB5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DFB60: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828DFB64: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DFB68: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DFB6C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828DFB70: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DFB78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DFB78 size=112
    let mut pc: u32 = 0x828DFB78;
    'dispatch: loop {
        match pc {
            0x828DFB78 => {
    //   block [0x828DFB78..0x828DFBE8)
	// 828DFB78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DFB7C: 488C85F1  bl 0x831a816c
	ctx.lr = 0x828DFB80;
	sub_831A8130(ctx, base);
	// 828DFB80: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DFB84: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828DFB88: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828DFB8C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828DFB90: 388B0828  addi r4, r11, 0x828
	ctx.r[4].s64 = ctx.r[11].s64 + 2088;
	// 828DFB94: 38A00054  li r5, 0x54
	ctx.r[5].s64 = 84;
	// 828DFB98: 3860006C  li r3, 0x6c
	ctx.r[3].s64 = 108;
	// 828DFB9C: 4851284D  bl 0x82df23e8
	ctx.lr = 0x828DFBA0;
	sub_82DF23E8(ctx, base);
	// 828DFBA0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828DFBA4: 41820010  beq 0x828dfbb4
	if ctx.cr[0].eq {
	pc = 0x828DFBB4; continue 'dispatch;
	}
	// 828DFBA8: 4BFFFF61  bl 0x828dfb08
	ctx.lr = 0x828DFBAC;
	sub_828DFB08(ctx, base);
	// 828DFBAC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DFBB0: 48000008  b 0x828dfbb8
	pc = 0x828DFBB8; continue 'dispatch;
	// 828DFBB4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828DFBB8: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828DFBBC: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828DFBC0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DFBC4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DFBC8: 4BFFFE79  bl 0x828dfa40
	ctx.lr = 0x828DFBCC;
	sub_828DFA40(ctx, base);
	// 828DFBCC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828DFBD0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DFBD4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DFBD8: 4B9E0429  bl 0x822c0000
	ctx.lr = 0x828DFBDC;
	sub_822C0000(ctx, base);
	// 828DFBDC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828DFBE0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828DFBE4: 488C85D8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DFBE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828DFBE8 size=192
    let mut pc: u32 = 0x828DFBE8;
    'dispatch: loop {
        match pc {
            0x828DFBE8 => {
    //   block [0x828DFBE8..0x828DFCA8)
	// 828DFBE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DFBEC: 488C857D  bl 0x831a8168
	ctx.lr = 0x828DFBF0;
	sub_831A8130(ctx, base);
	// 828DFBF0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DFBF4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828DFBF8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828DFBFC: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 828DFC00: 48874A01  bl 0x83154600
	ctx.lr = 0x828DFC04;
	sub_83154600(ctx, base);
	// 828DFC04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DFC08: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828DFC0C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DFC10: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DFC14: 4BF0FC3D  bl 0x827ef850
	ctx.lr = 0x828DFC18;
	sub_827EF850(ctx, base);
	// 828DFC18: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 828DFC1C: 815E0034  lwz r10, 0x34(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) } as u64;
	// 828DFC20: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DFC24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DFC28: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828DFC2C: C02B029C  lfs f1, 0x29c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(668 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828DFC30: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828DFC34: 4E800421  bctrl
	ctx.lr = 0x828DFC38;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DFC38: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828DFC3C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828DFC40: 388B0828  addi r4, r11, 0x828
	ctx.r[4].s64 = ctx.r[11].s64 + 2088;
	// 828DFC44: 38A00028  li r5, 0x28
	ctx.r[5].s64 = 40;
	// 828DFC48: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 828DFC4C: 4B9E078D  bl 0x822c03d8
	ctx.lr = 0x828DFC50;
	sub_822C03D8(ctx, base);
	// 828DFC50: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828DFC54: 41820030  beq 0x828dfc84
	if ctx.cr[0].eq {
	pc = 0x828DFC84; continue 'dispatch;
	}
	// 828DFC58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DFC5C: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 828DFC60: 48036B09  bl 0x82916768
	ctx.lr = 0x828DFC64;
	sub_82916768(ctx, base);
	// 828DFC64: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DFC68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DFC6C: 4BC2F8AD  bl 0x8250f518
	ctx.lr = 0x828DFC70;
	sub_8250F518(ctx, base);
	// 828DFC70: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DFC74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DFC78: 4BBB1479  bl 0x824910f0
	ctx.lr = 0x828DFC7C;
	sub_824910F0(ctx, base);
	// 828DFC7C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828DFC80: 48000008  b 0x828dfc88
	pc = 0x828DFC88; continue 'dispatch;
	// 828DFC84: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828DFC88: 387C0064  addi r3, r28, 0x64
	ctx.r[3].s64 = ctx.r[28].s64 + 100;
	// 828DFC8C: 4BA2AA55  bl 0x8230a6e0
	ctx.lr = 0x828DFC90;
	sub_8230A6E0(ctx, base);
	// 828DFC90: 57AB07FF  clrlwi. r11, r29, 0x1f
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DFC94: 4182000C  beq 0x828dfca0
	if ctx.cr[0].eq {
	pc = 0x828DFCA0; continue 'dispatch;
	}
	// 828DFC98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DFC9C: 48511FF5  bl 0x82df1c90
	ctx.lr = 0x828DFCA0;
	sub_82DF1C90(ctx, base);
	// 828DFCA0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828DFCA4: 488C8514  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DFCA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DFCA8 size=96
    let mut pc: u32 = 0x828DFCA8;
    'dispatch: loop {
        match pc {
            0x828DFCA8 => {
    //   block [0x828DFCA8..0x828DFD08)
	// 828DFCA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DFCAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DFCB0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828DFCB4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DFCB8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DFCBC: 4BFFFC85  bl 0x828df940
	ctx.lr = 0x828DFCC0;
	sub_828DF940(ctx, base);
	// 828DFCC0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828DFCC4: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828DFCC8: 396B08FC  addi r11, r11, 0x8fc
	ctx.r[11].s64 = ctx.r[11].s64 + 2300;
	// 828DFCCC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DFCD0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828DFCD4: 808A80A4  lwz r4, -0x7f5c(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-32604 as u32) ) } as u64;
	// 828DFCD8: 48513D31  bl 0x82df3a08
	ctx.lr = 0x828DFCDC;
	sub_82DF3A08(ctx, base);
	// 828DFCDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DFCE0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DFCE4: 48579A05  bl 0x82e596e8
	ctx.lr = 0x828DFCE8;
	sub_82E596E8(ctx, base);
	// 828DFCE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DFCEC: 4851373D  bl 0x82df3428
	ctx.lr = 0x828DFCF0;
	sub_82DF3428(ctx, base);
	// 828DFCF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DFCF4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828DFCF8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DFCFC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DFD00: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828DFD04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DFD08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DFD08 size=220
    let mut pc: u32 = 0x828DFD08;
    'dispatch: loop {
        match pc {
            0x828DFD08 => {
    //   block [0x828DFD08..0x828DFDE4)
	// 828DFD08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DFD0C: 488C8461  bl 0x831a816c
	ctx.lr = 0x828DFD10;
	sub_831A8130(ctx, base);
	// 828DFD10: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DFD14: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828DFD18: 488748E9  bl 0x83154600
	ctx.lr = 0x828DFD1C;
	sub_83154600(ctx, base);
	// 828DFD1C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DFD20: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828DFD24: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828DFD28: 4E800421  bctrl
	ctx.lr = 0x828DFD2C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DFD2C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DFD30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DFD34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DFD38: 808B8040  lwz r4, -0x7fc0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-32704 as u32) ) } as u64;
	// 828DFD3C: 48513CCD  bl 0x82df3a08
	ctx.lr = 0x828DFD40;
	sub_82DF3A08(ctx, base);
	// 828DFD40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DFD44: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 828DFD48: 4BF0A561  bl 0x827ea2a8
	ctx.lr = 0x828DFD4C;
	sub_827EA2A8(ctx, base);
	// 828DFD4C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828DFD50: 485135B9  bl 0x82df3308
	ctx.lr = 0x828DFD54;
	sub_82DF3308(ctx, base);
	// 828DFD54: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828DFD58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DFD5C: 485136CD  bl 0x82df3428
	ctx.lr = 0x828DFD60;
	sub_82DF3428(ctx, base);
	// 828DFD60: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DFD64: 4082003C  bne 0x828dfda0
	if !ctx.cr[0].eq {
	pc = 0x828DFDA0; continue 'dispatch;
	}
	// 828DFD68: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DFD6C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DFD70: 808B8044  lwz r4, -0x7fbc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-32700 as u32) ) } as u64;
	// 828DFD74: 48513C95  bl 0x82df3a08
	ctx.lr = 0x828DFD78;
	sub_82DF3A08(ctx, base);
	// 828DFD78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DFD7C: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 828DFD80: 4BF0A529  bl 0x827ea2a8
	ctx.lr = 0x828DFD84;
	sub_827EA2A8(ctx, base);
	// 828DFD84: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828DFD88: 48513581  bl 0x82df3308
	ctx.lr = 0x828DFD8C;
	sub_82DF3308(ctx, base);
	// 828DFD8C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828DFD90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DFD94: 48513695  bl 0x82df3428
	ctx.lr = 0x828DFD98;
	sub_82DF3428(ctx, base);
	// 828DFD98: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DFD9C: 41820040  beq 0x828dfddc
	if ctx.cr[0].eq {
	pc = 0x828DFDDC; continue 'dispatch;
	}
	// 828DFDA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DFDA4: 4BF0A56D  bl 0x827ea310
	ctx.lr = 0x828DFDA8;
	sub_827EA310(ctx, base);
	// 828DFDA8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828DFDAC: 41820030  beq 0x828dfddc
	if ctx.cr[0].eq {
	pc = 0x828DFDDC; continue 'dispatch;
	}
	// 828DFDB0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DFDB4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DFDB8: 808B0B24  lwz r4, 0xb24(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2852 as u32) ) } as u64;
	// 828DFDBC: 48513C4D  bl 0x82df3a08
	ctx.lr = 0x828DFDC0;
	sub_82DF3A08(ctx, base);
	// 828DFDC0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828DFDC4: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 828DFDC8: 48874839  bl 0x83154600
	ctx.lr = 0x828DFDCC;
	sub_83154600(ctx, base);
	// 828DFDCC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828DFDD0: 4BF0F971  bl 0x827ef740
	ctx.lr = 0x828DFDD4;
	sub_827EF740(ctx, base);
	// 828DFDD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DFDD8: 48513651  bl 0x82df3428
	ctx.lr = 0x828DFDDC;
	sub_82DF3428(ctx, base);
	// 828DFDDC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828DFDE0: 488C83DC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DFDE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828DFDE8 size=160
    let mut pc: u32 = 0x828DFDE8;
    'dispatch: loop {
        match pc {
            0x828DFDE8 => {
    //   block [0x828DFDE8..0x828DFE88)
	// 828DFDE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DFDEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DFDF0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828DFDF4: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 828DFDF8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DFDFC: 48874805  bl 0x83154600
	ctx.lr = 0x828DFE00;
	sub_83154600(ctx, base);
	// 828DFE00: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DFE04: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DFE08: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828DFE0C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828DFE10: 4E800421  bctrl
	ctx.lr = 0x828DFE14;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DFE14: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828DFE18: C3EB08A8  lfs f31, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828DFE1C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828DFE20: 4BF0A549  bl 0x827ea368
	ctx.lr = 0x828DFE24;
	sub_827EA368(ctx, base);
	// 828DFE24: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828DFE28: D3E10050  stfs f31, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 828DFE2C: D3E10054  stfs f31, 0x54(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 828DFE30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DFE34: D3E10058  stfs f31, 0x58(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 828DFE38: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DFE3C: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828DFE40: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 828DFE44: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DFE48: 816B005C  lwz r11, 0x5c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 828DFE4C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828DFE50: 4E800421  bctrl
	ctx.lr = 0x828DFE54;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DFE54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DFE58: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828DFE5C: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 828DFE60: 480371C1  bl 0x82917020
	ctx.lr = 0x828DFE64;
	sub_82917020(ctx, base);
	// 828DFE64: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828DFE68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DFE6C: 4BFB2735  bl 0x828925a0
	ctx.lr = 0x828DFE70;
	sub_828925A0(ctx, base);
	// 828DFE70: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828DFE74: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DFE78: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DFE7C: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828DFE80: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828DFE84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DFE88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DFE88 size=96
    let mut pc: u32 = 0x828DFE88;
    'dispatch: loop {
        match pc {
            0x828DFE88 => {
    //   block [0x828DFE88..0x828DFEE8)
	// 828DFE88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DFE8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DFE90: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828DFE94: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DFE98: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DFE9C: 4BFFFAA5  bl 0x828df940
	ctx.lr = 0x828DFEA0;
	sub_828DF940(ctx, base);
	// 828DFEA0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828DFEA4: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828DFEA8: 396B0924  addi r11, r11, 0x924
	ctx.r[11].s64 = ctx.r[11].s64 + 2340;
	// 828DFEAC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DFEB0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828DFEB4: 808A80A8  lwz r4, -0x7f58(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-32600 as u32) ) } as u64;
	// 828DFEB8: 48513B51  bl 0x82df3a08
	ctx.lr = 0x828DFEBC;
	sub_82DF3A08(ctx, base);
	// 828DFEBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DFEC0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DFEC4: 48579825  bl 0x82e596e8
	ctx.lr = 0x828DFEC8;
	sub_82E596E8(ctx, base);
	// 828DFEC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DFECC: 4851355D  bl 0x82df3428
	ctx.lr = 0x828DFED0;
	sub_82DF3428(ctx, base);
	// 828DFED0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DFED4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828DFED8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DFEDC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DFEE0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828DFEE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DFEE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828DFEE8 size=104
    let mut pc: u32 = 0x828DFEE8;
    'dispatch: loop {
        match pc {
            0x828DFEE8 => {
    //   block [0x828DFEE8..0x828DFF50)
	// 828DFEE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DFEEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DFEF0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828DFEF4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DFEF8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DFEFC: 4BFFFA45  bl 0x828df940
	ctx.lr = 0x828DFF00;
	sub_828DF940(ctx, base);
	// 828DFF00: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828DFF04: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828DFF08: 396B094C  addi r11, r11, 0x94c
	ctx.r[11].s64 = ctx.r[11].s64 + 2380;
	// 828DFF0C: 915F0064  stw r10, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 828DFF10: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828DFF14: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828DFF18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DFF1C: 808A0B28  lwz r4, 0xb28(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2856 as u32) ) } as u64;
	// 828DFF20: 48513AE9  bl 0x82df3a08
	ctx.lr = 0x828DFF24;
	sub_82DF3A08(ctx, base);
	// 828DFF24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DFF28: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DFF2C: 485797BD  bl 0x82e596e8
	ctx.lr = 0x828DFF30;
	sub_82E596E8(ctx, base);
	// 828DFF30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DFF34: 485134F5  bl 0x82df3428
	ctx.lr = 0x828DFF38;
	sub_82DF3428(ctx, base);
	// 828DFF38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DFF3C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828DFF40: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828DFF44: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828DFF48: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828DFF4C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828DFF50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828DFF50 size=332
    let mut pc: u32 = 0x828DFF50;
    'dispatch: loop {
        match pc {
            0x828DFF50 => {
    //   block [0x828DFF50..0x828E009C)
	// 828DFF50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828DFF54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828DFF58: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828DFF5C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828DFF60: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 828DFF64: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828DFF68: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828DFF6C: 48874695  bl 0x83154600
	ctx.lr = 0x828DFF70;
	sub_83154600(ctx, base);
	// 828DFF70: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828DFF74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828DFF78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DFF7C: 808B805C  lwz r4, -0x7fa4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-32676 as u32) ) } as u64;
	// 828DFF80: 48513A89  bl 0x82df3a08
	ctx.lr = 0x828DFF84;
	sub_82DF3A08(ctx, base);
	// 828DFF84: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DFF88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DFF8C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828DFF90: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828DFF94: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828DFF98: 4E800421  bctrl
	ctx.lr = 0x828DFF9C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DFF9C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828DFFA0: 48513489  bl 0x82df3428
	ctx.lr = 0x828DFFA4;
	sub_82DF3428(ctx, base);
	// 828DFFA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DFFA8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828DFFAC: 4BFB25DD  bl 0x82892588
	ctx.lr = 0x828DFFB0;
	sub_82892588(ctx, base);
	// 828DFFB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DFFB4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828DFFB8: 4BFB25E9  bl 0x828925a0
	ctx.lr = 0x828DFFBC;
	sub_828925A0(ctx, base);
	// 828DFFBC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828DFFC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DFFC4: 917E0064  stw r11, 0x64(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828DFFC8: 4BF9B879  bl 0x8287b840
	ctx.lr = 0x828DFFCC;
	sub_8287B840(ctx, base);
	// 828DFFCC: C0030088  lfs f0, 0x88(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(136 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828DFFD0: D01E0060  stfs f0, 0x60(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828DFFD4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828DFFD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DFFDC: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828DFFE0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828DFFE4: 4E800421  bctrl
	ctx.lr = 0x828DFFE8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828DFFE8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828DFFEC: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 828DFFF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828DFFF4: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828DFFF8: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 828DFFFC: 40990014  ble cr6, 0x828e0010
	if !ctx.cr[6].gt {
	pc = 0x828E0010; continue 'dispatch;
	}
	// 828E0000: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828E0004: 4803701D  bl 0x82917020
	ctx.lr = 0x828E0008;
	sub_82917020(ctx, base);
	// 828E0008: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 828E000C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E0010: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828E0014: 4803700D  bl 0x82917020
	ctx.lr = 0x828E0018;
	sub_82917020(ctx, base);
	// 828E0018: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E001C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828E0020: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E0024: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E0028: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E002C: 4E800421  bctrl
	ctx.lr = 0x828E0030;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E0030: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E0034: 48036735  bl 0x82916768
	ctx.lr = 0x828E0038;
	sub_82916768(ctx, base);
	// 828E0038: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E003C: 816B0154  lwz r11, 0x154(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(340 as u32) ) } as u64;
	// 828E0040: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E0044: 4E800421  bctrl
	ctx.lr = 0x828E0048;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E0048: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828E004C: 41820024  beq 0x828e0070
	if ctx.cr[0].eq {
	pc = 0x828E0070; continue 'dispatch;
	}
	// 828E0050: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E0054: C3E30054  lfs f31, 0x54(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(84 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828E0058: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E005C: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828E0060: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E0064: 4E800421  bctrl
	ctx.lr = 0x828E0068;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E0068: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828E006C: 4BF0A2FD  bl 0x827ea368
	ctx.lr = 0x828E0070;
	sub_827EA368(ctx, base);
	// 828E0070: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E0074: 4BF0D7A5  bl 0x827ed818
	ctx.lr = 0x828E0078;
	sub_827ED818(ctx, base);
	// 828E0078: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828E007C: 4BFFA68D  bl 0x828da708
	ctx.lr = 0x828E0080;
	sub_828DA708(ctx, base);
	// 828E0080: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828E0084: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E0088: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E008C: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 828E0090: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E0094: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E0098: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E00A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E00A0 size=388
    let mut pc: u32 = 0x828E00A0;
    'dispatch: loop {
        match pc {
            0x828E00A0 => {
    //   block [0x828E00A0..0x828E0224)
	// 828E00A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E00A4: 488C80C9  bl 0x831a816c
	ctx.lr = 0x828E00A8;
	sub_831A8130(ctx, base);
	// 828E00A8: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 828E00AC: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E00B0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E00B4: 4887454D  bl 0x83154600
	ctx.lr = 0x828E00B8;
	sub_83154600(ctx, base);
	// 828E00B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E00BC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E00C0: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828E00C4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E00C8: 4E800421  bctrl
	ctx.lr = 0x828E00CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E00CC: 817E0064  lwz r11, 0x64(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 828E00D0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828E00D4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 828E00D8: 419800F0  blt cr6, 0x828e01c8
	if ctx.cr[6].lt {
	pc = 0x828E01C8; continue 'dispatch;
	}
	// 828E00DC: 419A0048  beq cr6, 0x828e0124
	if ctx.cr[6].eq {
	pc = 0x828E0124; continue 'dispatch;
	}
	// 828E00E0: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 828E00E4: 40980134  bge cr6, 0x828e0218
	if !ctx.cr[6].lt {
	pc = 0x828E0218; continue 'dispatch;
	}
	// 828E00E8: 4BF0A229  bl 0x827ea310
	ctx.lr = 0x828E00EC;
	sub_827EA310(ctx, base);
	// 828E00EC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E00F0: 41820128  beq 0x828e0218
	if ctx.cr[0].eq {
	pc = 0x828E0218; continue 'dispatch;
	}
	// 828E00F4: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828E00F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E00FC: 808B0B24  lwz r4, 0xb24(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2852 as u32) ) } as u64;
	// 828E0100: 48513909  bl 0x82df3a08
	ctx.lr = 0x828E0104;
	sub_82DF3A08(ctx, base);
	// 828E0104: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E0108: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 828E010C: 488744F5  bl 0x83154600
	ctx.lr = 0x828E0110;
	sub_83154600(ctx, base);
	// 828E0110: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E0114: 4BF0F62D  bl 0x827ef740
	ctx.lr = 0x828E0118;
	sub_827EF740(ctx, base);
	// 828E0118: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E011C: 4851330D  bl 0x82df3428
	ctx.lr = 0x828E0120;
	sub_82DF3428(ctx, base);
	// 828E0120: 480000F8  b 0x828e0218
	pc = 0x828E0218; continue 'dispatch;
	// 828E0124: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E0128: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E012C: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828E0130: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E0134: 4E800421  bctrl
	ctx.lr = 0x828E0138;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E0138: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828E013C: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828E0140: FF01F800  fcmpu cr6, f1, f31
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 828E0144: 41990030  bgt cr6, 0x828e0174
	if ctx.cr[6].gt {
	pc = 0x828E0174; continue 'dispatch;
	}
	// 828E0148: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828E014C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828E0150: 808B0B2C  lwz r4, 0xb2c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2860 as u32) ) } as u64;
	// 828E0154: 485138B5  bl 0x82df3a08
	ctx.lr = 0x828E0158;
	sub_82DF3A08(ctx, base);
	// 828E0158: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E015C: 3BE10054  addi r31, r1, 0x54
	ctx.r[31].s64 = ctx.r[1].s64 + 84;
	// 828E0160: 488744A1  bl 0x83154600
	ctx.lr = 0x828E0164;
	sub_83154600(ctx, base);
	// 828E0164: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E0168: 4BF0F5D9  bl 0x827ef740
	ctx.lr = 0x828E016C;
	sub_827EF740(ctx, base);
	// 828E016C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828E0170: 4BFFFFAC  b 0x828e011c
	pc = 0x828E011C; continue 'dispatch;
	// 828E0174: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E0178: 48579601  bl 0x82e59778
	ctx.lr = 0x828E017C;
	sub_82E59778(ctx, base);
	// 828E017C: C01E0060  lfs f0, 0x60(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828E0180: EC000828  fsubs f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 828E0184: D01E0060  stfs f0, 0x60(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828E0188: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 828E018C: 4098008C  bge cr6, 0x828e0218
	if !ctx.cr[6].lt {
	pc = 0x828E0218; continue 'dispatch;
	}
	// 828E0190: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828E0194: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E0198: 808BF460  lwz r4, -0xba0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2976 as u32) ) } as u64;
	// 828E019C: 4851386D  bl 0x82df3a08
	ctx.lr = 0x828E01A0;
	sub_82DF3A08(ctx, base);
	// 828E01A0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E01A4: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828E01A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E01AC: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828E01B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E01B4: 4E800421  bctrl
	ctx.lr = 0x828E01B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E01B8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E01BC: 4851326D  bl 0x82df3428
	ctx.lr = 0x828E01C0;
	sub_82DF3428(ctx, base);
	// 828E01C0: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 828E01C4: 48000050  b 0x828e0214
	pc = 0x828E0214; continue 'dispatch;
	// 828E01C8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828E01CC: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828E01D0: 808B805C  lwz r4, -0x7fa4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-32676 as u32) ) } as u64;
	// 828E01D4: 48513835  bl 0x82df3a08
	ctx.lr = 0x828E01D8;
	sub_82DF3A08(ctx, base);
	// 828E01D8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828E01DC: 3BE1005C  addi r31, r1, 0x5c
	ctx.r[31].s64 = ctx.r[1].s64 + 92;
	// 828E01E0: 4BF0A0C9  bl 0x827ea2a8
	ctx.lr = 0x828E01E4;
	sub_827EA2A8(ctx, base);
	// 828E01E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E01E8: 48513121  bl 0x82df3308
	ctx.lr = 0x828E01EC;
	sub_82DF3308(ctx, base);
	// 828E01EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E01F0: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828E01F4: 48513235  bl 0x82df3428
	ctx.lr = 0x828E01F8;
	sub_82DF3428(ctx, base);
	// 828E01F8: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E01FC: 4182001C  beq 0x828e0218
	if ctx.cr[0].eq {
	pc = 0x828E0218; continue 'dispatch;
	}
	// 828E0200: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828E0204: 4BF0A10D  bl 0x827ea310
	ctx.lr = 0x828E0208;
	sub_827EA310(ctx, base);
	// 828E0208: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E020C: 4182000C  beq 0x828e0218
	if ctx.cr[0].eq {
	pc = 0x828E0218; continue 'dispatch;
	}
	// 828E0210: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E0214: 917E0064  stw r11, 0x64(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828E0218: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828E021C: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 828E0220: 488C7F9C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E0228(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E0228 size=188
    let mut pc: u32 = 0x828E0228;
    'dispatch: loop {
        match pc {
            0x828E0228 => {
    //   block [0x828E0228..0x828E02E4)
	// 828E0228: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E022C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E0230: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E0234: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E0238: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E023C: 488743C5  bl 0x83154600
	ctx.lr = 0x828E0240;
	sub_83154600(ctx, base);
	// 828E0240: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E0244: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E0248: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828E024C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E0250: 4E800421  bctrl
	ctx.lr = 0x828E0254;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E0254: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828E0258: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828E025C: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 828E0260: 40990014  ble cr6, 0x828e0274
	if !ctx.cr[6].gt {
	pc = 0x828E0274; continue 'dispatch;
	}
	// 828E0264: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828E0268: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 828E026C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E0270: 48036DB1  bl 0x82917020
	ctx.lr = 0x828E0274;
	sub_82917020(ctx, base);
	// 828E0274: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828E0278: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 828E027C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E0280: 48036DA1  bl 0x82917020
	ctx.lr = 0x828E0284;
	sub_82917020(ctx, base);
	// 828E0284: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E0288: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E028C: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828E0290: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E0294: 4E800421  bctrl
	ctx.lr = 0x828E0298;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E0298: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828E029C: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828E02A0: 4BF0A0C9  bl 0x827ea368
	ctx.lr = 0x828E02A4;
	sub_827EA368(ctx, base);
	// 828E02A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E02A8: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E02AC: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 828E02B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E02B4: 4E800421  bctrl
	ctx.lr = 0x828E02B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E02B8: 88830010  lbz r4, 0x10(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 828E02BC: 817E0048  lwz r11, 0x48(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 828E02C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E02C4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E02C8: 4E800421  bctrl
	ctx.lr = 0x828E02CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E02CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E02D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E02D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E02D8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E02DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E02E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E02E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E02E8 size=96
    let mut pc: u32 = 0x828E02E8;
    'dispatch: loop {
        match pc {
            0x828E02E8 => {
    //   block [0x828E02E8..0x828E0348)
	// 828E02E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E02EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E02F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E02F4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E02F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E02FC: 4BFFF645  bl 0x828df940
	ctx.lr = 0x828E0300;
	sub_828DF940(ctx, base);
	// 828E0300: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E0304: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828E0308: 396B0974  addi r11, r11, 0x974
	ctx.r[11].s64 = ctx.r[11].s64 + 2420;
	// 828E030C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E0310: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E0314: 808A0B34  lwz r4, 0xb34(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2868 as u32) ) } as u64;
	// 828E0318: 485136F1  bl 0x82df3a08
	ctx.lr = 0x828E031C;
	sub_82DF3A08(ctx, base);
	// 828E031C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E0320: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E0324: 485793C5  bl 0x82e596e8
	ctx.lr = 0x828E0328;
	sub_82E596E8(ctx, base);
	// 828E0328: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E032C: 485130FD  bl 0x82df3428
	ctx.lr = 0x828E0330;
	sub_82DF3428(ctx, base);
	// 828E0330: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E0334: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E0338: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E033C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E0340: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E0344: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E0348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E0348 size=96
    let mut pc: u32 = 0x828E0348;
    'dispatch: loop {
        match pc {
            0x828E0348 => {
    //   block [0x828E0348..0x828E03A8)
	// 828E0348: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E034C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E0350: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E0354: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E0358: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E035C: 4BFFF5E5  bl 0x828df940
	ctx.lr = 0x828E0360;
	sub_828DF940(ctx, base);
	// 828E0360: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E0364: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828E0368: 396B099C  addi r11, r11, 0x99c
	ctx.r[11].s64 = ctx.r[11].s64 + 2460;
	// 828E036C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E0370: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E0374: 808A80A0  lwz r4, -0x7f60(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-32608 as u32) ) } as u64;
	// 828E0378: 48513691  bl 0x82df3a08
	ctx.lr = 0x828E037C;
	sub_82DF3A08(ctx, base);
	// 828E037C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E0380: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E0384: 48579365  bl 0x82e596e8
	ctx.lr = 0x828E0388;
	sub_82E596E8(ctx, base);
	// 828E0388: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E038C: 4851309D  bl 0x82df3428
	ctx.lr = 0x828E0390;
	sub_82DF3428(ctx, base);
	// 828E0390: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E0394: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E0398: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E039C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E03A0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E03A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E03A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E03A8 size=280
    let mut pc: u32 = 0x828E03A8;
    'dispatch: loop {
        match pc {
            0x828E03A8 => {
    //   block [0x828E03A8..0x828E04C0)
	// 828E03A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E03AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E03B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E03B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E03B8: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 828E03BC: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E03C0: 48874241  bl 0x83154600
	ctx.lr = 0x828E03C4;
	sub_83154600(ctx, base);
	// 828E03C4: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828E03C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E03CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E03D0: 808B8060  lwz r4, -0x7fa0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-32672 as u32) ) } as u64;
	// 828E03D4: 48513635  bl 0x82df3a08
	ctx.lr = 0x828E03D8;
	sub_82DF3A08(ctx, base);
	// 828E03D8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E03DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E03E0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E03E4: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828E03E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E03EC: 4E800421  bctrl
	ctx.lr = 0x828E03F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E03F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E03F4: 48513035  bl 0x82df3428
	ctx.lr = 0x828E03F8;
	sub_82DF3428(ctx, base);
	// 828E03F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E03FC: 4803636D  bl 0x82916768
	ctx.lr = 0x828E0400;
	sub_82916768(ctx, base);
	// 828E0400: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E0404: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828E0408: 816B00D0  lwz r11, 0xd0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(208 as u32) ) } as u64;
	// 828E040C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E0410: 4E800421  bctrl
	ctx.lr = 0x828E0414;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E0414: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E0418: 48036351  bl 0x82916768
	ctx.lr = 0x828E041C;
	sub_82916768(ctx, base);
	// 828E041C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E0420: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828E0424: 816B00D4  lwz r11, 0xd4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(212 as u32) ) } as u64;
	// 828E0428: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E042C: 4E800421  bctrl
	ctx.lr = 0x828E0430;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E0430: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E0434: 4BF9B40D  bl 0x8287b840
	ctx.lr = 0x828E0438;
	sub_8287B840(ctx, base);
	// 828E0438: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E043C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E0440: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E0444: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828E0448: C3FE01D8  lfs f31, 0x1d8(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(472 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828E044C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E0450: 4E800421  bctrl
	ctx.lr = 0x828E0454;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E0454: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828E0458: 4BF09F11  bl 0x827ea368
	ctx.lr = 0x828E045C;
	sub_827EA368(ctx, base);
	// 828E045C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828E0460: C1BE01EC  lfs f13, 0x1ec(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(492 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828E0464: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E0468: C19E01F0  lfs f12, 0x1f0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(496 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828E046C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828E0470: D1A10060  stfs f13, 0x60(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828E0474: D1810064  stfs f12, 0x64(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 828E0478: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828E047C: D1A10068  stfs f13, 0x68(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 828E0480: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 828E0484: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E0488: 816B005C  lwz r11, 0x5c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 828E048C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E0490: 4E800421  bctrl
	ctx.lr = 0x828E0494;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E0494: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E0498: 4BF0D381  bl 0x827ed818
	ctx.lr = 0x828E049C;
	sub_827ED818(ctx, base);
	// 828E049C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828E04A0: 4BFFA269  bl 0x828da708
	ctx.lr = 0x828E04A4;
	sub_828DA708(ctx, base);
	// 828E04A4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828E04A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E04AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E04B0: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 828E04B4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E04B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E04BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E04C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E04C0 size=108
    let mut pc: u32 = 0x828E04C0;
    'dispatch: loop {
        match pc {
            0x828E04C0 => {
    //   block [0x828E04C0..0x828E052C)
	// 828E04C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E04C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E04C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E04CC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E04D0: 48874131  bl 0x83154600
	ctx.lr = 0x828E04D4;
	sub_83154600(ctx, base);
	// 828E04D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E04D8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E04DC: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828E04E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E04E4: 4E800421  bctrl
	ctx.lr = 0x828E04E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E04E8: 4BF09E29  bl 0x827ea310
	ctx.lr = 0x828E04EC;
	sub_827EA310(ctx, base);
	// 828E04EC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E04F0: 41820028  beq 0x828e0518
	if ctx.cr[0].eq {
	pc = 0x828E0518; continue 'dispatch;
	}
	// 828E04F4: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828E04F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E04FC: 808B0B24  lwz r4, 0xb24(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2852 as u32) ) } as u64;
	// 828E0500: 48513509  bl 0x82df3a08
	ctx.lr = 0x828E0504;
	sub_82DF3A08(ctx, base);
	// 828E0504: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E0508: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E050C: 4BF0F235  bl 0x827ef740
	ctx.lr = 0x828E0510;
	sub_827EF740(ctx, base);
	// 828E0510: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E0514: 48512F15  bl 0x82df3428
	ctx.lr = 0x828E0518;
	sub_82DF3428(ctx, base);
	// 828E0518: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E051C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E0520: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E0524: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E0528: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E0530(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E0530 size=132
    let mut pc: u32 = 0x828E0530;
    'dispatch: loop {
        match pc {
            0x828E0530 => {
    //   block [0x828E0530..0x828E05B4)
	// 828E0530: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E0534: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E0538: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E053C: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 828E0540: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E0544: 488740BD  bl 0x83154600
	ctx.lr = 0x828E0548;
	sub_83154600(ctx, base);
	// 828E0548: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E054C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E0550: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828E0554: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E0558: 4E800421  bctrl
	ctx.lr = 0x828E055C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E055C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828E0560: C3EB08A8  lfs f31, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828E0564: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828E0568: 4BF09E01  bl 0x827ea368
	ctx.lr = 0x828E056C;
	sub_827EA368(ctx, base);
	// 828E056C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828E0570: D3E10050  stfs f31, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 828E0574: D3E10054  stfs f31, 0x54(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 828E0578: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E057C: D3E10058  stfs f31, 0x58(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 828E0580: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E0584: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828E0588: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 828E058C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E0590: 816B005C  lwz r11, 0x5c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 828E0594: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E0598: 4E800421  bctrl
	ctx.lr = 0x828E059C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E059C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828E05A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E05A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E05A8: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E05AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E05B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E05B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E05B8 size=196
    let mut pc: u32 = 0x828E05B8;
    'dispatch: loop {
        match pc {
            0x828E05B8 => {
    //   block [0x828E05B8..0x828E067C)
	// 828E05B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E05BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E05C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E05C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E05C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E05CC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E05D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E05D4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828E05D8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828E05DC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E05E0: 4B9E0359  bl 0x822c0938
	ctx.lr = 0x828E05E4;
	sub_822C0938(ctx, base);
	// 828E05E4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828E05E8: 41820028  beq 0x828e0610
	if ctx.cr[0].eq {
	pc = 0x828E0610; continue 'dispatch;
	}
	// 828E05EC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E05F0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828E05F4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E05F8: 392B08AC  addi r9, r11, 0x8ac
	ctx.r[9].s64 = ctx.r[11].s64 + 2220;
	// 828E05FC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828E0600: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828E0604: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828E0608: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828E060C: 48000008  b 0x828e0614
	pc = 0x828E0614; continue 'dispatch;
	// 828E0610: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E0614: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E0618: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E061C: 409A0044  bne cr6, 0x828e0660
	if !ctx.cr[6].eq {
	pc = 0x828E0660; continue 'dispatch;
	}
	// 828E0620: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828E0624: 419A001C  beq cr6, 0x828e0640
	if ctx.cr[6].eq {
	pc = 0x828E0640; continue 'dispatch;
	}
	// 828E0628: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E062C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828E0630: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E0634: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E0638: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E063C: 4E800421  bctrl
	ctx.lr = 0x828E0640;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E0640: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828E0644: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828E0648: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E064C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828E0650: 816B8214  lwz r11, -0x7dec(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-32236 as u32) ) } as u64;
	// 828E0654: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828E0658: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828E065C: 4B9DF9A5  bl 0x822c0000
	ctx.lr = 0x828E0660;
	sub_822C0000(ctx, base);
	// 828E0660: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E0664: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E0668: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E066C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E0670: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E0674: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E0678: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E0680(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E0680 size=196
    let mut pc: u32 = 0x828E0680;
    'dispatch: loop {
        match pc {
            0x828E0680 => {
    //   block [0x828E0680..0x828E0744)
	// 828E0680: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E0684: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E0688: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E068C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E0690: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E0694: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E0698: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E069C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828E06A0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828E06A4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E06A8: 4B9E0291  bl 0x822c0938
	ctx.lr = 0x828E06AC;
	sub_822C0938(ctx, base);
	// 828E06AC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828E06B0: 41820028  beq 0x828e06d8
	if ctx.cr[0].eq {
	pc = 0x828E06D8; continue 'dispatch;
	}
	// 828E06B4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E06B8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828E06BC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E06C0: 392B08C0  addi r9, r11, 0x8c0
	ctx.r[9].s64 = ctx.r[11].s64 + 2240;
	// 828E06C4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828E06C8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828E06CC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828E06D0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828E06D4: 48000008  b 0x828e06dc
	pc = 0x828E06DC; continue 'dispatch;
	// 828E06D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E06DC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E06E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E06E4: 409A0044  bne cr6, 0x828e0728
	if !ctx.cr[6].eq {
	pc = 0x828E0728; continue 'dispatch;
	}
	// 828E06E8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828E06EC: 419A001C  beq cr6, 0x828e0708
	if ctx.cr[6].eq {
	pc = 0x828E0708; continue 'dispatch;
	}
	// 828E06F0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E06F4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828E06F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E06FC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E0700: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E0704: 4E800421  bctrl
	ctx.lr = 0x828E0708;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E0708: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828E070C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828E0710: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E0714: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828E0718: 816B8214  lwz r11, -0x7dec(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-32236 as u32) ) } as u64;
	// 828E071C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828E0720: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828E0724: 4B9DF8DD  bl 0x822c0000
	ctx.lr = 0x828E0728;
	sub_822C0000(ctx, base);
	// 828E0728: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E072C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E0730: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E0734: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E0738: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E073C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E0740: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E0748(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E0748 size=196
    let mut pc: u32 = 0x828E0748;
    'dispatch: loop {
        match pc {
            0x828E0748 => {
    //   block [0x828E0748..0x828E080C)
	// 828E0748: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E074C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E0750: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E0754: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E0758: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E075C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E0760: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E0764: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828E0768: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828E076C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E0770: 4B9E01C9  bl 0x822c0938
	ctx.lr = 0x828E0774;
	sub_822C0938(ctx, base);
	// 828E0774: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828E0778: 41820028  beq 0x828e07a0
	if ctx.cr[0].eq {
	pc = 0x828E07A0; continue 'dispatch;
	}
	// 828E077C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E0780: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828E0784: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E0788: 392B08D4  addi r9, r11, 0x8d4
	ctx.r[9].s64 = ctx.r[11].s64 + 2260;
	// 828E078C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828E0790: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828E0794: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828E0798: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828E079C: 48000008  b 0x828e07a4
	pc = 0x828E07A4; continue 'dispatch;
	// 828E07A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E07A4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E07A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E07AC: 409A0044  bne cr6, 0x828e07f0
	if !ctx.cr[6].eq {
	pc = 0x828E07F0; continue 'dispatch;
	}
	// 828E07B0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828E07B4: 419A001C  beq cr6, 0x828e07d0
	if ctx.cr[6].eq {
	pc = 0x828E07D0; continue 'dispatch;
	}
	// 828E07B8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E07BC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828E07C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E07C4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E07C8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E07CC: 4E800421  bctrl
	ctx.lr = 0x828E07D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E07D0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828E07D4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828E07D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E07DC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828E07E0: 816B8214  lwz r11, -0x7dec(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-32236 as u32) ) } as u64;
	// 828E07E4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828E07E8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828E07EC: 4B9DF815  bl 0x822c0000
	ctx.lr = 0x828E07F0;
	sub_822C0000(ctx, base);
	// 828E07F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E07F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E07F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E07FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E0800: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E0804: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E0808: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E0810(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E0810 size=196
    let mut pc: u32 = 0x828E0810;
    'dispatch: loop {
        match pc {
            0x828E0810 => {
    //   block [0x828E0810..0x828E08D4)
	// 828E0810: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E0814: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E0818: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E081C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E0820: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E0824: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E0828: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E082C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828E0830: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828E0834: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E0838: 4B9E0101  bl 0x822c0938
	ctx.lr = 0x828E083C;
	sub_822C0938(ctx, base);
	// 828E083C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828E0840: 41820028  beq 0x828e0868
	if ctx.cr[0].eq {
	pc = 0x828E0868; continue 'dispatch;
	}
	// 828E0844: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E0848: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828E084C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E0850: 392B08E8  addi r9, r11, 0x8e8
	ctx.r[9].s64 = ctx.r[11].s64 + 2280;
	// 828E0854: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828E0858: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828E085C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828E0860: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828E0864: 48000008  b 0x828e086c
	pc = 0x828E086C; continue 'dispatch;
	// 828E0868: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E086C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E0870: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E0874: 409A0044  bne cr6, 0x828e08b8
	if !ctx.cr[6].eq {
	pc = 0x828E08B8; continue 'dispatch;
	}
	// 828E0878: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828E087C: 419A001C  beq cr6, 0x828e0898
	if ctx.cr[6].eq {
	pc = 0x828E0898; continue 'dispatch;
	}
	// 828E0880: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E0884: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828E0888: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E088C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E0890: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E0894: 4E800421  bctrl
	ctx.lr = 0x828E0898;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E0898: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828E089C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828E08A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E08A4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828E08A8: 816B8214  lwz r11, -0x7dec(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-32236 as u32) ) } as u64;
	// 828E08AC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828E08B0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828E08B4: 4B9DF74D  bl 0x822c0000
	ctx.lr = 0x828E08B8;
	sub_822C0000(ctx, base);
	// 828E08B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E08BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E08C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E08C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E08C8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E08CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E08D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E08D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E08D8 size=96
    let mut pc: u32 = 0x828E08D8;
    'dispatch: loop {
        match pc {
            0x828E08D8 => {
    //   block [0x828E08D8..0x828E0938)
	// 828E08D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E08DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E08E0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E08E4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E08E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E08EC: 4BFFF055  bl 0x828df940
	ctx.lr = 0x828E08F0;
	sub_828DF940(ctx, base);
	// 828E08F0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E08F4: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828E08F8: 396B09EC  addi r11, r11, 0x9ec
	ctx.r[11].s64 = ctx.r[11].s64 + 2540;
	// 828E08FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E0900: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E0904: 808A0B30  lwz r4, 0xb30(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2864 as u32) ) } as u64;
	// 828E0908: 48513101  bl 0x82df3a08
	ctx.lr = 0x828E090C;
	sub_82DF3A08(ctx, base);
	// 828E090C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E0910: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E0914: 48578DD5  bl 0x82e596e8
	ctx.lr = 0x828E0918;
	sub_82E596E8(ctx, base);
	// 828E0918: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E091C: 48512B0D  bl 0x82df3428
	ctx.lr = 0x828E0920;
	sub_82DF3428(ctx, base);
	// 828E0920: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E0924: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E0928: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E092C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E0930: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E0934: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E0938(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E0938 size=592
    let mut pc: u32 = 0x828E0938;
    'dispatch: loop {
        match pc {
            0x828E0938 => {
    //   block [0x828E0938..0x828E0B88)
	// 828E0938: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E093C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E0940: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E0944: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E0948: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 828E094C: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E0950: 48873CB1  bl 0x83154600
	ctx.lr = 0x828E0954;
	sub_83154600(ctx, base);
	// 828E0954: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E0958: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828E095C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E0960: 4BF9AEF9  bl 0x8287b858
	ctx.lr = 0x828E0964;
	sub_8287B858(ctx, base);
	// 828E0964: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E0968: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E096C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E0970: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E0974: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E0978: 4E800421  bctrl
	ctx.lr = 0x828E097C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E097C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828E0980: 13E0F0C7  vcmpequd (lvx128) v31, v0, v30
	tmp.u32 = ctx.r[30].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E0B88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E0B88 size=196
    let mut pc: u32 = 0x828E0B88;
    'dispatch: loop {
        match pc {
            0x828E0B88 => {
    //   block [0x828E0B88..0x828E0C4C)
	// 828E0B88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E0B8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E0B90: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E0B94: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E0B98: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E0B9C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E0BA0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E0BA4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828E0BA8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828E0BAC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E0BB0: 4B9DFD89  bl 0x822c0938
	ctx.lr = 0x828E0BB4;
	sub_822C0938(ctx, base);
	// 828E0BB4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828E0BB8: 41820028  beq 0x828e0be0
	if ctx.cr[0].eq {
	pc = 0x828E0BE0; continue 'dispatch;
	}
	// 828E0BBC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E0BC0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828E0BC4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E0BC8: 392B09C4  addi r9, r11, 0x9c4
	ctx.r[9].s64 = ctx.r[11].s64 + 2500;
	// 828E0BCC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828E0BD0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828E0BD4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828E0BD8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828E0BDC: 48000008  b 0x828e0be4
	pc = 0x828E0BE4; continue 'dispatch;
	// 828E0BE0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E0BE4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E0BE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E0BEC: 409A0044  bne cr6, 0x828e0c30
	if !ctx.cr[6].eq {
	pc = 0x828E0C30; continue 'dispatch;
	}
	// 828E0BF0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828E0BF4: 419A001C  beq cr6, 0x828e0c10
	if ctx.cr[6].eq {
	pc = 0x828E0C10; continue 'dispatch;
	}
	// 828E0BF8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E0BFC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828E0C00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E0C04: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E0C08: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E0C0C: 4E800421  bctrl
	ctx.lr = 0x828E0C10;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E0C10: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828E0C14: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828E0C18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E0C1C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828E0C20: 816B8214  lwz r11, -0x7dec(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-32236 as u32) ) } as u64;
	// 828E0C24: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828E0C28: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828E0C2C: 4B9DF3D5  bl 0x822c0000
	ctx.lr = 0x828E0C30;
	sub_822C0000(ctx, base);
	// 828E0C30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E0C34: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E0C38: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E0C3C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E0C40: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E0C44: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E0C48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E0C50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E0C50 size=196
    let mut pc: u32 = 0x828E0C50;
    'dispatch: loop {
        match pc {
            0x828E0C50 => {
    //   block [0x828E0C50..0x828E0D14)
	// 828E0C50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E0C54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E0C58: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E0C5C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E0C60: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E0C64: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E0C68: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E0C6C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828E0C70: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828E0C74: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E0C78: 4B9DFCC1  bl 0x822c0938
	ctx.lr = 0x828E0C7C;
	sub_822C0938(ctx, base);
	// 828E0C7C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828E0C80: 41820028  beq 0x828e0ca8
	if ctx.cr[0].eq {
	pc = 0x828E0CA8; continue 'dispatch;
	}
	// 828E0C84: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E0C88: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828E0C8C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E0C90: 392B09D8  addi r9, r11, 0x9d8
	ctx.r[9].s64 = ctx.r[11].s64 + 2520;
	// 828E0C94: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828E0C98: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828E0C9C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828E0CA0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828E0CA4: 48000008  b 0x828e0cac
	pc = 0x828E0CAC; continue 'dispatch;
	// 828E0CA8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E0CAC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E0CB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E0CB4: 409A0044  bne cr6, 0x828e0cf8
	if !ctx.cr[6].eq {
	pc = 0x828E0CF8; continue 'dispatch;
	}
	// 828E0CB8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828E0CBC: 419A001C  beq cr6, 0x828e0cd8
	if ctx.cr[6].eq {
	pc = 0x828E0CD8; continue 'dispatch;
	}
	// 828E0CC0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E0CC4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828E0CC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E0CCC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E0CD0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E0CD4: 4E800421  bctrl
	ctx.lr = 0x828E0CD8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E0CD8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828E0CDC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828E0CE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E0CE4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828E0CE8: 816B8214  lwz r11, -0x7dec(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-32236 as u32) ) } as u64;
	// 828E0CEC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828E0CF0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828E0CF4: 4B9DF30D  bl 0x822c0000
	ctx.lr = 0x828E0CF8;
	sub_822C0000(ctx, base);
	// 828E0CF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E0CFC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E0D00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E0D04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E0D08: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E0D0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E0D10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E0D18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E0D18 size=692
    let mut pc: u32 = 0x828E0D18;
    'dispatch: loop {
        match pc {
            0x828E0D18 => {
    //   block [0x828E0D18..0x828E0FCC)
	// 828E0D18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E0D1C: 488C744D  bl 0x831a8168
	ctx.lr = 0x828E0D20;
	sub_831A8130(ctx, base);
	// 828E0D20: DBC1FFC8  stfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 828E0D24: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 828E0D28: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E0D2C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E0D30: 488738D1  bl 0x83154600
	ctx.lr = 0x828E0D34;
	sub_83154600(ctx, base);
	// 828E0D34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E0D38: 48035A31  bl 0x82916768
	ctx.lr = 0x828E0D3C;
	sub_82916768(ctx, base);
	// 828E0D3C: 4802884D  bl 0x82909588
	ctx.lr = 0x828E0D40;
	sub_82909588(ctx, base);
	// 828E0D40: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 828E0D44: 4805F70D  bl 0x82940450
	ctx.lr = 0x828E0D48;
	sub_82940450(ctx, base);
	// 828E0D48: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828E0D4C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E0D50: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828E0D54: 4806197D  bl 0x829426d0
	ctx.lr = 0x828E0D58;
	sub_829426D0(ctx, base);
	// 828E0D58: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E0D5C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E0D60: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 828E0D64: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E0D68: 4E800421  bctrl
	ctx.lr = 0x828E0D6C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E0D6C: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828E0D70: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828E0D74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E0D78: 419A000C  beq cr6, 0x828e0d84
	if ctx.cr[6].eq {
	pc = 0x828E0D84; continue 'dispatch;
	}
	// 828E0D7C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828E0D80: 4B9DFB11  bl 0x822c0890
	ctx.lr = 0x828E0D84;
	sub_822C0890(ctx, base);
	// 828E0D84: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E0D88: 4182002C  beq 0x828e0db4
	if ctx.cr[0].eq {
	pc = 0x828E0DB4; continue 'dispatch;
	}
	// 828E0D8C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828E0D90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E0D94: 808B0B24  lwz r4, 0xb24(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2852 as u32) ) } as u64;
	// 828E0D98: 48512C71  bl 0x82df3a08
	ctx.lr = 0x828E0D9C;
	sub_82DF3A08(ctx, base);
	// 828E0D9C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E0DA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E0DA4: 4BF0E99D  bl 0x827ef740
	ctx.lr = 0x828E0DA8;
	sub_827EF740(ctx, base);
	// 828E0DA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E0DAC: 4851267D  bl 0x82df3428
	ctx.lr = 0x828E0DB0;
	sub_82DF3428(ctx, base);
	// 828E0DB0: 4800020C  b 0x828e0fbc
	pc = 0x828E0FBC; continue 'dispatch;
	// 828E0DB4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828E0DB8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828E0DBC: 48061915  bl 0x829426d0
	ctx.lr = 0x828E0DC0;
	sub_829426D0(ctx, base);
	// 828E0DC0: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E0DC4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E0DC8: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828E0DCC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E0DD0: 4E800421  bctrl
	ctx.lr = 0x828E0DD4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E0DD4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828E0DD8: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828E0DDC: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 828E0DE0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E0DE4: 557DDFFE  rlwinm r29, r11, 0x1b, 0x1f, 0x1f
	ctx.r[29].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 828E0DE8: 419A0008  beq cr6, 0x828e0df0
	if ctx.cr[6].eq {
	pc = 0x828E0DF0; continue 'dispatch;
	}
	// 828E0DEC: 4B9DFAA5  bl 0x822c0890
	ctx.lr = 0x828E0DF0;
	sub_822C0890(ctx, base);
	// 828E0DF0: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E0DF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E0DF8: 41820050  beq 0x828e0e48
	if ctx.cr[0].eq {
	pc = 0x828E0E48; continue 'dispatch;
	}
	// 828E0DFC: 4803596D  bl 0x82916768
	ctx.lr = 0x828E0E00;
	sub_82916768(ctx, base);
	// 828E0E00: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828E0E04: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 828E0E08: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828E0E0C: 4802DF6D  bl 0x8290ed78
	ctx.lr = 0x828E0E10;
	sub_8290ED78(ctx, base);
	// 828E0E10: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828E0E14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E0E18: 808B0B10  lwz r4, 0xb10(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2832 as u32) ) } as u64;
	// 828E0E1C: 48512BED  bl 0x82df3a08
	ctx.lr = 0x828E0E20;
	sub_82DF3A08(ctx, base);
	// 828E0E20: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E0E24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E0E28: 4BF0E919  bl 0x827ef740
	ctx.lr = 0x828E0E2C;
	sub_827EF740(ctx, base);
	// 828E0E2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E0E30: 485125F9  bl 0x82df3428
	ctx.lr = 0x828E0E34;
	sub_82DF3428(ctx, base);
	// 828E0E34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E0E38: 4BF0C9E1  bl 0x827ed818
	ctx.lr = 0x828E0E3C;
	sub_827ED818(ctx, base);
	// 828E0E3C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828E0E40: 4BFF98C9  bl 0x828da708
	ctx.lr = 0x828E0E44;
	sub_828DA708(ctx, base);
	// 828E0E44: 48000178  b 0x828e0fbc
	pc = 0x828E0FBC; continue 'dispatch;
	// 828E0E48: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E0E4C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E0E50: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E0E54: 4E800421  bctrl
	ctx.lr = 0x828E0E58;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E0E58: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828E0E5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E0E60: 48035909  bl 0x82916768
	ctx.lr = 0x828E0E64;
	sub_82916768(ctx, base);
	// 828E0E64: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828E0E68: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828E0E6C: 480287ED  bl 0x82909658
	ctx.lr = 0x828E0E70;
	sub_82909658(ctx, base);
	// 828E0E70: 13C018C7  vcmpequd (lvx128) v30, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828E0E74: 13E0E8C7  vcmpequd (lvx128) v31, v0, v29
	tmp.u32 = ctx.r[29].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828E0E78: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E0FD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E0FD0 size=112
    let mut pc: u32 = 0x828E0FD0;
    'dispatch: loop {
        match pc {
            0x828E0FD0 => {
    //   block [0x828E0FD0..0x828E1040)
	// 828E0FD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E0FD4: 488C7199  bl 0x831a816c
	ctx.lr = 0x828E0FD8;
	sub_831A8130(ctx, base);
	// 828E0FD8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E0FDC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E0FE0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828E0FE4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828E0FE8: 388B0A10  addi r4, r11, 0xa10
	ctx.r[4].s64 = ctx.r[11].s64 + 2576;
	// 828E0FEC: 38A00186  li r5, 0x186
	ctx.r[5].s64 = 390;
	// 828E0FF0: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 828E0FF4: 485113F5  bl 0x82df23e8
	ctx.lr = 0x828E0FF8;
	sub_82DF23E8(ctx, base);
	// 828E0FF8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828E0FFC: 41820010  beq 0x828e100c
	if ctx.cr[0].eq {
	pc = 0x828E100C; continue 'dispatch;
	}
	// 828E1000: 4BFFEE89  bl 0x828dfe88
	ctx.lr = 0x828E1004;
	sub_828DFE88(ctx, base);
	// 828E1004: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E1008: 48000008  b 0x828e1010
	pc = 0x828E1010; continue 'dispatch;
	// 828E100C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828E1010: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828E1014: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828E1018: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E101C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E1020: 4BFFF599  bl 0x828e05b8
	ctx.lr = 0x828E1024;
	sub_828E05B8(ctx, base);
	// 828E1024: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828E1028: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E102C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E1030: 4B9DEFD1  bl 0x822c0000
	ctx.lr = 0x828E1034;
	sub_822C0000(ctx, base);
	// 828E1034: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828E1038: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E103C: 488C7180  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E1040(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E1040 size=112
    let mut pc: u32 = 0x828E1040;
    'dispatch: loop {
        match pc {
            0x828E1040 => {
    //   block [0x828E1040..0x828E10B0)
	// 828E1040: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E1044: 488C7129  bl 0x831a816c
	ctx.lr = 0x828E1048;
	sub_831A8130(ctx, base);
	// 828E1048: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E104C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E1050: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828E1054: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828E1058: 388B0A10  addi r4, r11, 0xa10
	ctx.r[4].s64 = ctx.r[11].s64 + 2576;
	// 828E105C: 38A00206  li r5, 0x206
	ctx.r[5].s64 = 518;
	// 828E1060: 38600068  li r3, 0x68
	ctx.r[3].s64 = 104;
	// 828E1064: 48511385  bl 0x82df23e8
	ctx.lr = 0x828E1068;
	sub_82DF23E8(ctx, base);
	// 828E1068: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828E106C: 41820010  beq 0x828e107c
	if ctx.cr[0].eq {
	pc = 0x828E107C; continue 'dispatch;
	}
	// 828E1070: 4BFFEE79  bl 0x828dfee8
	ctx.lr = 0x828E1074;
	sub_828DFEE8(ctx, base);
	// 828E1074: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E1078: 48000008  b 0x828e1080
	pc = 0x828E1080; continue 'dispatch;
	// 828E107C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828E1080: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828E1084: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828E1088: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E108C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E1090: 4BFFF5F1  bl 0x828e0680
	ctx.lr = 0x828E1094;
	sub_828E0680(ctx, base);
	// 828E1094: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828E1098: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E109C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E10A0: 4B9DEF61  bl 0x822c0000
	ctx.lr = 0x828E10A4;
	sub_822C0000(ctx, base);
	// 828E10A4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828E10A8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E10AC: 488C7110  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E10B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828E10B0 size=276
    let mut pc: u32 = 0x828E10B0;
    'dispatch: loop {
        match pc {
            0x828E10B0 => {
    //   block [0x828E10B0..0x828E11C4)
	// 828E10B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E10B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E10B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E10BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E10C0: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E11C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E11C8 size=112
    let mut pc: u32 = 0x828E11C8;
    'dispatch: loop {
        match pc {
            0x828E11C8 => {
    //   block [0x828E11C8..0x828E1238)
	// 828E11C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E11CC: 488C6FA1  bl 0x831a816c
	ctx.lr = 0x828E11D0;
	sub_831A8130(ctx, base);
	// 828E11D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E11D4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E11D8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828E11DC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828E11E0: 388B0A10  addi r4, r11, 0xa10
	ctx.r[4].s64 = ctx.r[11].s64 + 2576;
	// 828E11E4: 38A00252  li r5, 0x252
	ctx.r[5].s64 = 594;
	// 828E11E8: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 828E11EC: 485111FD  bl 0x82df23e8
	ctx.lr = 0x828E11F0;
	sub_82DF23E8(ctx, base);
	// 828E11F0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828E11F4: 41820010  beq 0x828e1204
	if ctx.cr[0].eq {
	pc = 0x828E1204; continue 'dispatch;
	}
	// 828E11F8: 4BFFF0F1  bl 0x828e02e8
	ctx.lr = 0x828E11FC;
	sub_828E02E8(ctx, base);
	// 828E11FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E1200: 48000008  b 0x828e1208
	pc = 0x828E1208; continue 'dispatch;
	// 828E1204: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828E1208: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828E120C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828E1210: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E1214: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E1218: 4BFFF531  bl 0x828e0748
	ctx.lr = 0x828E121C;
	sub_828E0748(ctx, base);
	// 828E121C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828E1220: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E1224: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E1228: 4B9DEDD9  bl 0x822c0000
	ctx.lr = 0x828E122C;
	sub_822C0000(ctx, base);
	// 828E122C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828E1230: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E1234: 488C6F88  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E1238(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E1238 size=112
    let mut pc: u32 = 0x828E1238;
    'dispatch: loop {
        match pc {
            0x828E1238 => {
    //   block [0x828E1238..0x828E12A8)
	// 828E1238: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E123C: 488C6F31  bl 0x831a816c
	ctx.lr = 0x828E1240;
	sub_831A8130(ctx, base);
	// 828E1240: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E1244: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E1248: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828E124C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828E1250: 388B0A10  addi r4, r11, 0xa10
	ctx.r[4].s64 = ctx.r[11].s64 + 2576;
	// 828E1254: 38A00291  li r5, 0x291
	ctx.r[5].s64 = 657;
	// 828E1258: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 828E125C: 4851118D  bl 0x82df23e8
	ctx.lr = 0x828E1260;
	sub_82DF23E8(ctx, base);
	// 828E1260: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828E1264: 41820010  beq 0x828e1274
	if ctx.cr[0].eq {
	pc = 0x828E1274; continue 'dispatch;
	}
	// 828E1268: 4BFFF0E1  bl 0x828e0348
	ctx.lr = 0x828E126C;
	sub_828E0348(ctx, base);
	// 828E126C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E1270: 48000008  b 0x828e1278
	pc = 0x828E1278; continue 'dispatch;
	// 828E1274: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828E1278: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828E127C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828E1280: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E1284: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E1288: 4BFFF589  bl 0x828e0810
	ctx.lr = 0x828E128C;
	sub_828E0810(ctx, base);
	// 828E128C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828E1290: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E1294: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E1298: 4B9DED69  bl 0x822c0000
	ctx.lr = 0x828E129C;
	sub_822C0000(ctx, base);
	// 828E129C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828E12A0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E12A4: 488C6F18  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E12A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E12A8 size=348
    let mut pc: u32 = 0x828E12A8;
    'dispatch: loop {
        match pc {
            0x828E12A8 => {
    //   block [0x828E12A8..0x828E1404)
	// 828E12A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E12AC: 488C6EBD  bl 0x831a8168
	ctx.lr = 0x828E12B0;
	sub_831A8130(ctx, base);
	// 828E12B0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E12B4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828E12B8: 48873349  bl 0x83154600
	ctx.lr = 0x828E12BC;
	sub_83154600(ctx, base);
	// 828E12BC: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828E12C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E12C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E12C8: 808B808C  lwz r4, -0x7f74(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-32628 as u32) ) } as u64;
	// 828E12CC: 4851273D  bl 0x82df3a08
	ctx.lr = 0x828E12D0;
	sub_82DF3A08(ctx, base);
	// 828E12D0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E12D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E12D8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E12DC: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828E12E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E12E4: 4E800421  bctrl
	ctx.lr = 0x828E12E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E12E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E12EC: 4851213D  bl 0x82df3428
	ctx.lr = 0x828E12F0;
	sub_82DF3428(ctx, base);
	// 828E12F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E12F4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828E12F8: 4BFB1291  bl 0x82892588
	ctx.lr = 0x828E12FC;
	sub_82892588(ctx, base);
	// 828E12FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E1300: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828E1304: 4BFB129D  bl 0x828925a0
	ctx.lr = 0x828E1308;
	sub_828925A0(ctx, base);
	// 828E1308: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E130C: 4803545D  bl 0x82916768
	ctx.lr = 0x828E1310;
	sub_82916768(ctx, base);
	// 828E1310: 48028279  bl 0x82909588
	ctx.lr = 0x828E1314;
	sub_82909588(ctx, base);
	// 828E1314: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828E1318: 4805F191  bl 0x829404a8
	ctx.lr = 0x828E131C;
	sub_829404A8(ctx, base);
	// 828E131C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E1320: 48060CC9  bl 0x82941fe8
	ctx.lr = 0x828E1324;
	sub_82941FE8(ctx, base);
	// 828E1324: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828E1328: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828E132C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828E1330: 388A0A10  addi r4, r10, 0xa10
	ctx.r[4].s64 = ctx.r[10].s64 + 2576;
	// 828E1334: 38A00060  li r5, 0x60
	ctx.r[5].s64 = 96;
	// 828E1338: C00B08A8  lfs f0, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828E133C: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 828E1340: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 828E1344: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 828E1348: 4B9DF091  bl 0x822c03d8
	ctx.lr = 0x828E134C;
	sub_822C03D8(ctx, base);
	// 828E134C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828E1350: 41820018  beq 0x828e1368
	if ctx.cr[0].eq {
	pc = 0x828E1368; continue 'dispatch;
	}
	// 828E1354: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828E1358: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828E135C: 48060CAD  bl 0x82942008
	ctx.lr = 0x828E1360;
	sub_82942008(ctx, base);
	// 828E1360: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E1364: 48000008  b 0x828e136c
	pc = 0x828E136C; continue 'dispatch;
	// 828E1368: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828E136C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828E1370: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E1374: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828E1378: 4BF8CAB9  bl 0x8286de30
	ctx.lr = 0x828E137C;
	sub_8286DE30(ctx, base);
	// 828E137C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828E1380: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E1384: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828E1388: 4B9DEC79  bl 0x822c0000
	ctx.lr = 0x828E138C;
	sub_822C0000(ctx, base);
	// 828E138C: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828E1390: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828E1394: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828E1398: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 828E139C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828E13A0: 419A0024  beq cr6, 0x828e13c4
	if ctx.cr[6].eq {
	pc = 0x828E13C4; continue 'dispatch;
	}
	// 828E13A4: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 828E13A8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E13AC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E13B0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E13B4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828E13B8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E13BC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E13C0: 4082FFE8  bne 0x828e13a8
	if !ctx.cr[0].eq {
	pc = 0x828E13A8; continue 'dispatch;
	}
	// 828E13C4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E13C8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828E13CC: 4805F0E5  bl 0x829404b0
	ctx.lr = 0x828E13D0;
	sub_829404B0(ctx, base);
	// 828E13D0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828E13D4: 419A000C  beq cr6, 0x828e13e0
	if ctx.cr[6].eq {
	pc = 0x828E13E0; continue 'dispatch;
	}
	// 828E13D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E13DC: 4B9DF4B5  bl 0x822c0890
	ctx.lr = 0x828E13E0;
	sub_822C0890(ctx, base);
	// 828E13E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E13E4: 4BF0C435  bl 0x827ed818
	ctx.lr = 0x828E13E8;
	sub_827ED818(ctx, base);
	// 828E13E8: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 828E13EC: 4BFF931D  bl 0x828da708
	ctx.lr = 0x828E13F0;
	sub_828DA708(ctx, base);
	// 828E13F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E13F4: 4803570D  bl 0x82916b00
	ctx.lr = 0x828E13F8;
	sub_82916B00(ctx, base);
	// 828E13F8: 987C0064  stb r3, 0x64(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(100 as u32), ctx.r[3].u8 ) };
	// 828E13FC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828E1400: 488C6DB8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E1408(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E1408 size=112
    let mut pc: u32 = 0x828E1408;
    'dispatch: loop {
        match pc {
            0x828E1408 => {
    //   block [0x828E1408..0x828E1478)
	// 828E1408: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E140C: 488C6D61  bl 0x831a816c
	ctx.lr = 0x828E1410;
	sub_831A8130(ctx, base);
	// 828E1410: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E1414: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E1418: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828E141C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828E1420: 388B0A10  addi r4, r11, 0xa10
	ctx.r[4].s64 = ctx.r[11].s64 + 2576;
	// 828E1424: 38A000E5  li r5, 0xe5
	ctx.r[5].s64 = 229;
	// 828E1428: 38600068  li r3, 0x68
	ctx.r[3].s64 = 104;
	// 828E142C: 48510FBD  bl 0x82df23e8
	ctx.lr = 0x828E1430;
	sub_82DF23E8(ctx, base);
	// 828E1430: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828E1434: 41820010  beq 0x828e1444
	if ctx.cr[0].eq {
	pc = 0x828E1444; continue 'dispatch;
	}
	// 828E1438: 4BFFF4A1  bl 0x828e08d8
	ctx.lr = 0x828E143C;
	sub_828E08D8(ctx, base);
	// 828E143C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E1440: 48000008  b 0x828e1448
	pc = 0x828E1448; continue 'dispatch;
	// 828E1444: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828E1448: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828E144C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828E1450: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E1454: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E1458: 4BFFF731  bl 0x828e0b88
	ctx.lr = 0x828E145C;
	sub_828E0B88(ctx, base);
	// 828E145C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828E1460: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E1464: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E1468: 4B9DEB99  bl 0x822c0000
	ctx.lr = 0x828E146C;
	sub_822C0000(ctx, base);
	// 828E146C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828E1470: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E1474: 488C6D48  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E1478(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E1478 size=112
    let mut pc: u32 = 0x828E1478;
    'dispatch: loop {
        match pc {
            0x828E1478 => {
    //   block [0x828E1478..0x828E14E8)
	// 828E1478: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E147C: 488C6CF1  bl 0x831a816c
	ctx.lr = 0x828E1480;
	sub_831A8130(ctx, base);
	// 828E1480: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E1484: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E1488: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828E148C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828E1490: 388B0A10  addi r4, r11, 0xa10
	ctx.r[4].s64 = ctx.r[11].s64 + 2576;
	// 828E1494: 38A00143  li r5, 0x143
	ctx.r[5].s64 = 323;
	// 828E1498: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 828E149C: 48510F4D  bl 0x82df23e8
	ctx.lr = 0x828E14A0;
	sub_82DF23E8(ctx, base);
	// 828E14A0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828E14A4: 41820010  beq 0x828e14b4
	if ctx.cr[0].eq {
	pc = 0x828E14B4; continue 'dispatch;
	}
	// 828E14A8: 4BFFE801  bl 0x828dfca8
	ctx.lr = 0x828E14AC;
	sub_828DFCA8(ctx, base);
	// 828E14AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E14B0: 48000008  b 0x828e14b8
	pc = 0x828E14B8; continue 'dispatch;
	// 828E14B4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828E14B8: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828E14BC: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828E14C0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E14C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E14C8: 4BFFF789  bl 0x828e0c50
	ctx.lr = 0x828E14CC;
	sub_828E0C50(ctx, base);
	// 828E14CC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828E14D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E14D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E14D8: 4B9DEB29  bl 0x822c0000
	ctx.lr = 0x828E14DC;
	sub_822C0000(ctx, base);
	// 828E14DC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828E14E0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E14E4: 488C6CD8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E14E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E14E8 size=348
    let mut pc: u32 = 0x828E14E8;
    'dispatch: loop {
        match pc {
            0x828E14E8 => {
    //   block [0x828E14E8..0x828E1644)
	// 828E14E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E14EC: 488C6C7D  bl 0x831a8168
	ctx.lr = 0x828E14F0;
	sub_831A8130(ctx, base);
	// 828E14F0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E14F4: 4887310D  bl 0x83154600
	ctx.lr = 0x828E14F8;
	sub_83154600(ctx, base);
	// 828E14F8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828E14FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E1500: 388B7C94  addi r4, r11, 0x7c94
	ctx.r[4].s64 = ctx.r[11].s64 + 31892;
	// 828E1504: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E1508: 48512501  bl 0x82df3a08
	ctx.lr = 0x828E150C;
	sub_82DF3A08(ctx, base);
	// 828E150C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E1510: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E1514: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E1518: 816B0098  lwz r11, 0x98(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(152 as u32) ) } as u64;
	// 828E151C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E1520: 4E800421  bctrl
	ctx.lr = 0x828E1524;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E1524: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E1528: 48511F01  bl 0x82df3428
	ctx.lr = 0x828E152C;
	sub_82DF3428(ctx, base);
	// 828E152C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828E1530: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E1534: 808B8048  lwz r4, -0x7fb8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-32696 as u32) ) } as u64;
	// 828E1538: 485124D1  bl 0x82df3a08
	ctx.lr = 0x828E153C;
	sub_82DF3A08(ctx, base);
	// 828E153C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E1540: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E1544: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E1548: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828E154C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E1550: 4E800421  bctrl
	ctx.lr = 0x828E1554;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E1554: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E1558: 48511ED1  bl 0x82df3428
	ctx.lr = 0x828E155C;
	sub_82DF3428(ctx, base);
	// 828E155C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E1560: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828E1564: 4BFB1025  bl 0x82892588
	ctx.lr = 0x828E1568;
	sub_82892588(ctx, base);
	// 828E1568: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828E156C: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 828E1570: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E1574: 48035AAD  bl 0x82917020
	ctx.lr = 0x828E1578;
	sub_82917020(ctx, base);
	// 828E1578: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 828E157C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E1580: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828E1584: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828E1588: 4BF9F2E9  bl 0x82880870
	ctx.lr = 0x828E158C;
	sub_82880870(ctx, base);
	// 828E158C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E1590: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828E1594: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E1598: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E159C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828E15A0: 419A0024  beq cr6, 0x828e15c4
	if ctx.cr[6].eq {
	pc = 0x828E15C4; continue 'dispatch;
	}
	// 828E15A4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828E15A8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E15AC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E15B0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E15B4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828E15B8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E15BC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E15C0: 4082FFE8  bne 0x828e15a8
	if !ctx.cr[0].eq {
	pc = 0x828E15A8; continue 'dispatch;
	}
	// 828E15C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E15C8: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 828E15CC: 4803519D  bl 0x82916768
	ctx.lr = 0x828E15D0;
	sub_82916768(ctx, base);
	// 828E15D0: 38630028  addi r3, r3, 0x28
	ctx.r[3].s64 = ctx.r[3].s64 + 40;
	// 828E15D4: 487279E5  bl 0x83008fb8
	ctx.lr = 0x828E15D8;
	sub_83008FB8(ctx, base);
	// 828E15D8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828E15DC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E15E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E15E4: 3B8B0A10  addi r28, r11, 0xa10
	ctx.r[28].s64 = ctx.r[11].s64 + 2576;
	// 828E15E8: 48035181  bl 0x82916768
	ctx.lr = 0x828E15EC;
	sub_82916768(ctx, base);
	// 828E15EC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828E15F0: 38630028  addi r3, r3, 0x28
	ctx.r[3].s64 = ctx.r[3].s64 + 40;
	// 828E15F4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828E15F8: 38A0015F  li r5, 0x15f
	ctx.r[5].s64 = 351;
	// 828E15FC: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 828E1600: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 828E1604: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828E1608: 48577439  bl 0x82e58a40
	ctx.lr = 0x828E160C;
	sub_82E58A40(ctx, base);
	// 828E160C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828E1610: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E1614: 419A0008  beq cr6, 0x828e161c
	if ctx.cr[6].eq {
	pc = 0x828E161C; continue 'dispatch;
	}
	// 828E1618: 4B9DF279  bl 0x822c0890
	ctx.lr = 0x828E161C;
	sub_822C0890(ctx, base);
	// 828E161C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828E1620: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E1624: 419A0008  beq cr6, 0x828e162c
	if ctx.cr[6].eq {
	pc = 0x828E162C; continue 'dispatch;
	}
	// 828E1628: 4B9DF269  bl 0x822c0890
	ctx.lr = 0x828E162C;
	sub_822C0890(ctx, base);
	// 828E162C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E1630: 4BF0C1E9  bl 0x827ed818
	ctx.lr = 0x828E1634;
	sub_827ED818(ctx, base);
	// 828E1634: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828E1638: 4BFF90D1  bl 0x828da708
	ctx.lr = 0x828E163C;
	sub_828DA708(ctx, base);
	// 828E163C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828E1640: 488C6B78  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E1648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E1648 size=232
    let mut pc: u32 = 0x828E1648;
    'dispatch: loop {
        match pc {
            0x828E1648 => {
    //   block [0x828E1648..0x828E1730)
	// 828E1648: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E164C: 488C6B1D  bl 0x831a8168
	ctx.lr = 0x828E1650;
	sub_831A8130(ctx, base);
	// 828E1650: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E1654: 48872FAD  bl 0x83154600
	ctx.lr = 0x828E1658;
	sub_83154600(ctx, base);
	// 828E1658: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828E165C: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 828E1660: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E1664: 480359BD  bl 0x82917020
	ctx.lr = 0x828E1668;
	sub_82917020(ctx, base);
	// 828E1668: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 828E166C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E1670: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828E1674: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828E1678: 4BF9F1F9  bl 0x82880870
	ctx.lr = 0x828E167C;
	sub_82880870(ctx, base);
	// 828E167C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E1680: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828E1684: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E1688: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E168C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828E1690: 419A0024  beq cr6, 0x828e16b4
	if ctx.cr[6].eq {
	pc = 0x828E16B4; continue 'dispatch;
	}
	// 828E1694: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828E1698: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E169C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E16A0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E16A4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828E16A8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E16AC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E16B0: 4082FFE8  bne 0x828e1698
	if !ctx.cr[0].eq {
	pc = 0x828E1698; continue 'dispatch;
	}
	// 828E16B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E16B8: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 828E16BC: 480350AD  bl 0x82916768
	ctx.lr = 0x828E16C0;
	sub_82916768(ctx, base);
	// 828E16C0: 38630028  addi r3, r3, 0x28
	ctx.r[3].s64 = ctx.r[3].s64 + 40;
	// 828E16C4: 487278F5  bl 0x83008fb8
	ctx.lr = 0x828E16C8;
	sub_83008FB8(ctx, base);
	// 828E16C8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828E16CC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E16D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E16D4: 3B8B0A10  addi r28, r11, 0xa10
	ctx.r[28].s64 = ctx.r[11].s64 + 2576;
	// 828E16D8: 48035091  bl 0x82916768
	ctx.lr = 0x828E16DC;
	sub_82916768(ctx, base);
	// 828E16DC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828E16E0: 38630028  addi r3, r3, 0x28
	ctx.r[3].s64 = ctx.r[3].s64 + 40;
	// 828E16E4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828E16E8: 38A0017C  li r5, 0x17c
	ctx.r[5].s64 = 380;
	// 828E16EC: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 828E16F0: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 828E16F4: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828E16F8: 48577349  bl 0x82e58a40
	ctx.lr = 0x828E16FC;
	sub_82E58A40(ctx, base);
	// 828E16FC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828E1700: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E1704: 419A0008  beq cr6, 0x828e170c
	if ctx.cr[6].eq {
	pc = 0x828E170C; continue 'dispatch;
	}
	// 828E1708: 4B9DF189  bl 0x822c0890
	ctx.lr = 0x828E170C;
	sub_822C0890(ctx, base);
	// 828E170C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828E1710: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E1714: 419A0008  beq cr6, 0x828e171c
	if ctx.cr[6].eq {
	pc = 0x828E171C; continue 'dispatch;
	}
	// 828E1718: 4B9DF179  bl 0x822c0890
	ctx.lr = 0x828E171C;
	sub_822C0890(ctx, base);
	// 828E171C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828E1720: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E1724: 4BFB0E7D  bl 0x828925a0
	ctx.lr = 0x828E1728;
	sub_828925A0(ctx, base);
	// 828E1728: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828E172C: 488C6A8C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E1730(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E1730 size=44
    let mut pc: u32 = 0x828E1730;
    'dispatch: loop {
        match pc {
            0x828E1730 => {
    //   block [0x828E1730..0x828E175C)
	// 828E1730: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E1734: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E1738: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E173C: 48872EC5  bl 0x83154600
	ctx.lr = 0x828E1740;
	sub_83154600(ctx, base);
	// 828E1740: 4BF0C0D9  bl 0x827ed818
	ctx.lr = 0x828E1744;
	sub_827ED818(ctx, base);
	// 828E1744: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828E1748: 4BFF8FC1  bl 0x828da708
	ctx.lr = 0x828E174C;
	sub_828DA708(ctx, base);
	// 828E174C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828E1750: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E1754: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E1758: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E1760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E1760 size=196
    let mut pc: u32 = 0x828E1760;
    'dispatch: loop {
        match pc {
            0x828E1760 => {
    //   block [0x828E1760..0x828E1824)
	// 828E1760: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E1764: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E1768: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E176C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E1770: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E1774: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E1778: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E177C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828E1780: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828E1784: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E1788: 4B9DF1B1  bl 0x822c0938
	ctx.lr = 0x828E178C;
	sub_822C0938(ctx, base);
	// 828E178C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828E1790: 41820028  beq 0x828e17b8
	if ctx.cr[0].eq {
	pc = 0x828E17B8; continue 'dispatch;
	}
	// 828E1794: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E1798: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828E179C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E17A0: 392B0A90  addi r9, r11, 0xa90
	ctx.r[9].s64 = ctx.r[11].s64 + 2704;
	// 828E17A4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828E17A8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828E17AC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828E17B0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828E17B4: 48000008  b 0x828e17bc
	pc = 0x828E17BC; continue 'dispatch;
	// 828E17B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E17BC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E17C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E17C4: 409A0044  bne cr6, 0x828e1808
	if !ctx.cr[6].eq {
	pc = 0x828E1808; continue 'dispatch;
	}
	// 828E17C8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828E17CC: 419A001C  beq cr6, 0x828e17e8
	if ctx.cr[6].eq {
	pc = 0x828E17E8; continue 'dispatch;
	}
	// 828E17D0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E17D4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828E17D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E17DC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E17E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E17E4: 4E800421  bctrl
	ctx.lr = 0x828E17E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E17E8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828E17EC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828E17F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E17F4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828E17F8: 816B8574  lwz r11, -0x7a8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-31372 as u32) ) } as u64;
	// 828E17FC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828E1800: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828E1804: 4B9DE7FD  bl 0x822c0000
	ctx.lr = 0x828E1808;
	sub_822C0000(ctx, base);
	// 828E1808: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E180C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E1810: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E1814: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E1818: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E181C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E1820: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E1828(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E1828 size=96
    let mut pc: u32 = 0x828E1828;
    'dispatch: loop {
        match pc {
            0x828E1828 => {
    //   block [0x828E1828..0x828E1888)
	// 828E1828: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E182C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E1830: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E1834: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E1838: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E183C: 4BFFE14D  bl 0x828df988
	ctx.lr = 0x828E1840;
	sub_828DF988(ctx, base);
	// 828E1840: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E1844: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828E1848: 396B0AA4  addi r11, r11, 0xaa4
	ctx.r[11].s64 = ctx.r[11].s64 + 2724;
	// 828E184C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E1850: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E1854: 808A0AF4  lwz r4, 0xaf4(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2804 as u32) ) } as u64;
	// 828E1858: 485121B1  bl 0x82df3a08
	ctx.lr = 0x828E185C;
	sub_82DF3A08(ctx, base);
	// 828E185C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E1860: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E1864: 48577E85  bl 0x82e596e8
	ctx.lr = 0x828E1868;
	sub_82E596E8(ctx, base);
	// 828E1868: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E186C: 48511BBD  bl 0x82df3428
	ctx.lr = 0x828E1870;
	sub_82DF3428(ctx, base);
	// 828E1870: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E1874: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E1878: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E187C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E1880: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E1884: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E1888(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E1888 size=348
    let mut pc: u32 = 0x828E1888;
    'dispatch: loop {
        match pc {
            0x828E1888 => {
    //   block [0x828E1888..0x828E19E4)
	// 828E1888: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E188C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E1890: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E1894: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E1898: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 828E189C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E18A0: 48872D61  bl 0x83154600
	ctx.lr = 0x828E18A4;
	sub_83154600(ctx, base);
	// 828E18A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E18A8: 4BF0BF71  bl 0x827ed818
	ctx.lr = 0x828E18AC;
	sub_827ED818(ctx, base);
	// 828E18AC: 4BFD059D  bl 0x828b1e48
	ctx.lr = 0x828E18B0;
	sub_828B1E48(ctx, base);
	// 828E18B0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E18B4: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E18B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E18BC: 409A00B8  bne cr6, 0x828e1974
	if !ctx.cr[6].eq {
	pc = 0x828E1974; continue 'dispatch;
	}
	// 828E18C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E18C4: 48034EA5  bl 0x82916768
	ctx.lr = 0x828E18C8;
	sub_82916768(ctx, base);
	// 828E18C8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E18CC: 816B0158  lwz r11, 0x158(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(344 as u32) ) } as u64;
	// 828E18D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E18D4: 4E800421  bctrl
	ctx.lr = 0x828E18D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E18D8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E18DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E18E0: C1BE007C  lfs f13, 0x7c(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(124 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828E18E4: C01E0080  lfs f0, 0x80(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828E18E8: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 828E18EC: C1BE0078  lfs f13, 0x78(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(120 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828E18F0: EFE0682A  fadds f31, f0, f13
	ctx.f[31].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 828E18F4: 48034E75  bl 0x82916768
	ctx.lr = 0x828E18F8;
	sub_82916768(ctx, base);
	// 828E18F8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E18FC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828E1900: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828E1904: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E1908: 4E800421  bctrl
	ctx.lr = 0x828E190C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E190C: C01E0078  lfs f0, 0x78(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(120 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828E1910: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 828E1914: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E1918: 40980028  bge cr6, 0x828e1940
	if !ctx.cr[6].lt {
	pc = 0x828E1940; continue 'dispatch;
	}
	// 828E191C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828E1920: 808B0AFC  lwz r4, 0xafc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2812 as u32) ) } as u64;
	// 828E1924: 485120E5  bl 0x82df3a08
	ctx.lr = 0x828E1928;
	sub_82DF3A08(ctx, base);
	// 828E1928: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E192C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E1930: 4BF0DE11  bl 0x827ef740
	ctx.lr = 0x828E1934;
	sub_827EF740(ctx, base);
	// 828E1934: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E1938: 48511AF1  bl 0x82df3428
	ctx.lr = 0x828E193C;
	sub_82DF3428(ctx, base);
	// 828E193C: 4800008C  b 0x828e19c8
	pc = 0x828E19C8; continue 'dispatch;
	// 828E1940: EC010028  fsubs f0, f1, f0
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 828E1944: C1BE007C  lfs f13, 0x7c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(124 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828E1948: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 828E194C: 40980010  bge cr6, 0x828e195c
	if !ctx.cr[6].lt {
	pc = 0x828E195C; continue 'dispatch;
	}
	// 828E1950: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828E1954: 808B0AF8  lwz r4, 0xaf8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2808 as u32) ) } as u64;
	// 828E1958: 4BFFFFCC  b 0x828e1924
	pc = 0x828E1924; continue 'dispatch;
	// 828E195C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 828E1960: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828E1964: C1BE0080  lfs f13, 0x80(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(128 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828E1968: 808B0B18  lwz r4, 0xb18(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2840 as u32) ) } as u64;
	// 828E196C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 828E1970: 4BFFFFB4  b 0x828e1924
	pc = 0x828E1924; continue 'dispatch;
	// 828E1974: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 828E1978: 409A0050  bne cr6, 0x828e19c8
	if !ctx.cr[6].eq {
	pc = 0x828E19C8; continue 'dispatch;
	}
	// 828E197C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E1980: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E1984: 48035415  bl 0x82916d98
	ctx.lr = 0x828E1988;
	sub_82916D98(ctx, base);
	// 828E1988: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 828E198C: 81210058  lwz r9, 0x58(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828E1990: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828E1994: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E1998: 9149007C  stw r10, 0x7c(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(124 as u32), ctx.r[10].u32 ) };
	// 828E199C: 808B0B00  lwz r4, 0xb00(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2816 as u32) ) } as u64;
	// 828E19A0: 48512069  bl 0x82df3a08
	ctx.lr = 0x828E19A4;
	sub_82DF3A08(ctx, base);
	// 828E19A4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E19A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E19AC: 4BF0DD95  bl 0x827ef740
	ctx.lr = 0x828E19B0;
	sub_827EF740(ctx, base);
	// 828E19B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E19B4: 48511A75  bl 0x82df3428
	ctx.lr = 0x828E19B8;
	sub_82DF3428(ctx, base);
	// 828E19B8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828E19BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E19C0: 419A0008  beq cr6, 0x828e19c8
	if ctx.cr[6].eq {
	pc = 0x828E19C8; continue 'dispatch;
	}
	// 828E19C4: 4B9DEECD  bl 0x822c0890
	ctx.lr = 0x828E19C8;
	sub_822C0890(ctx, base);
	// 828E19C8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828E19CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E19D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E19D4: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 828E19D8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E19DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E19E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E19E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E19E8 size=112
    let mut pc: u32 = 0x828E19E8;
    'dispatch: loop {
        match pc {
            0x828E19E8 => {
    //   block [0x828E19E8..0x828E1A58)
	// 828E19E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E19EC: 488C6781  bl 0x831a816c
	ctx.lr = 0x828E19F0;
	sub_831A8130(ctx, base);
	// 828E19F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E19F4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E19F8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828E19FC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828E1A00: 388B0AD0  addi r4, r11, 0xad0
	ctx.r[4].s64 = ctx.r[11].s64 + 2768;
	// 828E1A04: 38A00074  li r5, 0x74
	ctx.r[5].s64 = 116;
	// 828E1A08: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 828E1A0C: 485109DD  bl 0x82df23e8
	ctx.lr = 0x828E1A10;
	sub_82DF23E8(ctx, base);
	// 828E1A10: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828E1A14: 41820010  beq 0x828e1a24
	if ctx.cr[0].eq {
	pc = 0x828E1A24; continue 'dispatch;
	}
	// 828E1A18: 4BFFFE11  bl 0x828e1828
	ctx.lr = 0x828E1A1C;
	sub_828E1828(ctx, base);
	// 828E1A1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E1A20: 48000008  b 0x828e1a28
	pc = 0x828E1A28; continue 'dispatch;
	// 828E1A24: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828E1A28: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828E1A2C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828E1A30: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E1A34: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E1A38: 4BFFFD29  bl 0x828e1760
	ctx.lr = 0x828E1A3C;
	sub_828E1760(ctx, base);
	// 828E1A3C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828E1A40: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E1A44: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E1A48: 4B9DE5B9  bl 0x822c0000
	ctx.lr = 0x828E1A4C;
	sub_822C0000(ctx, base);
	// 828E1A4C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828E1A50: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E1A54: 488C6768  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E1A58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E1A58 size=52
    let mut pc: u32 = 0x828E1A58;
    'dispatch: loop {
        match pc {
            0x828E1A58 => {
    //   block [0x828E1A58..0x828E1A8C)
	// 828E1A58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E1A5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E1A60: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E1A64: 48872B9D  bl 0x83154600
	ctx.lr = 0x828E1A68;
	sub_83154600(ctx, base);
	// 828E1A68: 48034D01  bl 0x82916768
	ctx.lr = 0x828E1A6C;
	sub_82916768(ctx, base);
	// 828E1A6C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828E1A70: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 828E1A74: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828E1A78: 4802D301  bl 0x8290ed78
	ctx.lr = 0x828E1A7C;
	sub_8290ED78(ctx, base);
	// 828E1A7C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828E1A80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E1A84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E1A88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E1A90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E1A90 size=140
    let mut pc: u32 = 0x828E1A90;
    'dispatch: loop {
        match pc {
            0x828E1A90 => {
    //   block [0x828E1A90..0x828E1B1C)
	// 828E1A90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E1A94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E1A98: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E1A9C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E1AA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E1AA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E1AA8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828E1AAC: 897F006C  lbz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 828E1AB0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828E1AB4: 41820018  beq 0x828e1acc
	if ctx.cr[0].eq {
	pc = 0x828E1ACC; continue 'dispatch;
	}
	// 828E1AB8: 48577CA9  bl 0x82e59760
	ctx.lr = 0x828E1ABC;
	sub_82E59760(ctx, base);
	// 828E1ABC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828E1AC0: C00B9524  lfs f0, -0x6adc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828E1AC4: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 828E1AC8: 4099003C  ble cr6, 0x828e1b04
	if !ctx.cr[6].gt {
	pc = 0x828E1B04; continue 'dispatch;
	}
	// 828E1ACC: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 828E1AD0: 2F0B000B  cmpwi cr6, r11, 0xb
	ctx.cr[6].compare_i32(ctx.r[11].s32, 11, &mut ctx.xer);
	// 828E1AD4: 409A0030  bne cr6, 0x828e1b04
	if !ctx.cr[6].eq {
	pc = 0x828E1B04; continue 'dispatch;
	}
	// 828E1AD8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828E1ADC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E1AE0: 808B0B10  lwz r4, 0xb10(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2832 as u32) ) } as u64;
	// 828E1AE4: 48511F25  bl 0x82df3a08
	ctx.lr = 0x828E1AE8;
	sub_82DF3A08(ctx, base);
	// 828E1AE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E1AEC: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 828E1AF0: 48872B11  bl 0x83154600
	ctx.lr = 0x828E1AF4;
	sub_83154600(ctx, base);
	// 828E1AF4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E1AF8: 4BF0DC49  bl 0x827ef740
	ctx.lr = 0x828E1AFC;
	sub_827EF740(ctx, base);
	// 828E1AFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E1B00: 48511929  bl 0x82df3428
	ctx.lr = 0x828E1B04;
	sub_82DF3428(ctx, base);
	// 828E1B04: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E1B08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E1B0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E1B10: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E1B14: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E1B18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E1B20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E1B20 size=108
    let mut pc: u32 = 0x828E1B20;
    'dispatch: loop {
        match pc {
            0x828E1B20 => {
    //   block [0x828E1B20..0x828E1B8C)
	// 828E1B20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E1B24: 488C6649  bl 0x831a816c
	ctx.lr = 0x828E1B28;
	sub_831A8130(ctx, base);
	// 828E1B28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E1B2C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828E1B30: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828E1B34: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828E1B38: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E1B3C: 41820038  beq 0x828e1b74
	if ctx.cr[0].eq {
	pc = 0x828E1B74; continue 'dispatch;
	}
	// 828E1B40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E1B44: 488C7E45  bl 0x831a9988
	ctx.lr = 0x828E1B48;
	sub_831A9988(ctx, base);
	// 828E1B48: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 828E1B4C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828E1B50: 386B6BDC  addi r3, r11, 0x6bdc
	ctx.r[3].s64 = ctx.r[11].s64 + 27612;
	// 828E1B54: 488C65A5  bl 0x831a80f8
	ctx.lr = 0x828E1B58;
	sub_831A80F8(ctx, base);
	// 828E1B58: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E1B5C: 41820018  beq 0x828e1b74
	if ctx.cr[0].eq {
	pc = 0x828E1B74; continue 'dispatch;
	}
	// 828E1B60: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E1B64: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828E1B68: 4BFFFF29  bl 0x828e1a90
	ctx.lr = 0x828E1B6C;
	sub_828E1A90(ctx, base);
	// 828E1B6C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828E1B70: 48000014  b 0x828e1b84
	pc = 0x828E1B84; continue 'dispatch;
	// 828E1B74: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828E1B78: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E1B7C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828E1B80: 4889C909  bl 0x8317e488
	ctx.lr = 0x828E1B84;
	sub_8317E488(ctx, base);
	// 828E1B84: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E1B88: 488C6634  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E1B90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E1B90 size=196
    let mut pc: u32 = 0x828E1B90;
    'dispatch: loop {
        match pc {
            0x828E1B90 => {
    //   block [0x828E1B90..0x828E1C54)
	// 828E1B90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E1B94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E1B98: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E1B9C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E1BA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E1BA4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E1BA8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E1BAC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828E1BB0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828E1BB4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E1BB8: 4B9DED81  bl 0x822c0938
	ctx.lr = 0x828E1BBC;
	sub_822C0938(ctx, base);
	// 828E1BBC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828E1BC0: 41820028  beq 0x828e1be8
	if ctx.cr[0].eq {
	pc = 0x828E1BE8; continue 'dispatch;
	}
	// 828E1BC4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E1BC8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828E1BCC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E1BD0: 392B0B54  addi r9, r11, 0xb54
	ctx.r[9].s64 = ctx.r[11].s64 + 2900;
	// 828E1BD4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828E1BD8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828E1BDC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828E1BE0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828E1BE4: 48000008  b 0x828e1bec
	pc = 0x828E1BEC; continue 'dispatch;
	// 828E1BE8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E1BEC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E1BF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E1BF4: 409A0044  bne cr6, 0x828e1c38
	if !ctx.cr[6].eq {
	pc = 0x828E1C38; continue 'dispatch;
	}
	// 828E1BF8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828E1BFC: 419A001C  beq cr6, 0x828e1c18
	if ctx.cr[6].eq {
	pc = 0x828E1C18; continue 'dispatch;
	}
	// 828E1C00: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E1C04: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828E1C08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E1C0C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E1C10: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E1C14: 4E800421  bctrl
	ctx.lr = 0x828E1C18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E1C18: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828E1C1C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828E1C20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E1C24: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828E1C28: 816B8604  lwz r11, -0x79fc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-31228 as u32) ) } as u64;
	// 828E1C2C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828E1C30: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828E1C34: 4B9DE3CD  bl 0x822c0000
	ctx.lr = 0x828E1C38;
	sub_822C0000(ctx, base);
	// 828E1C38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E1C3C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E1C40: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E1C44: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E1C48: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E1C4C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E1C50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E1C58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E1C58 size=108
    let mut pc: u32 = 0x828E1C58;
    'dispatch: loop {
        match pc {
            0x828E1C58 => {
    //   block [0x828E1C58..0x828E1CC4)
	// 828E1C58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E1C5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E1C60: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E1C64: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E1C68: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E1C6C: 4BFFDCD5  bl 0x828df940
	ctx.lr = 0x828E1C70;
	sub_828DF940(ctx, base);
	// 828E1C70: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828E1C74: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E1C78: 394A0B68  addi r10, r10, 0xb68
	ctx.r[10].s64 = ctx.r[10].s64 + 2920;
	// 828E1C7C: 3D20832D  lis r9, -0x7cd3
	ctx.r[9].s64 = -2094202880;
	// 828E1C80: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828E1C84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E1C88: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828E1C8C: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 828E1C90: 80890B24  lwz r4, 0xb24(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2852 as u32) ) } as u64;
	// 828E1C94: 48511D75  bl 0x82df3a08
	ctx.lr = 0x828E1C98;
	sub_82DF3A08(ctx, base);
	// 828E1C98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E1C9C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E1CA0: 48577A49  bl 0x82e596e8
	ctx.lr = 0x828E1CA4;
	sub_82E596E8(ctx, base);
	// 828E1CA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E1CA8: 48511781  bl 0x82df3428
	ctx.lr = 0x828E1CAC;
	sub_82DF3428(ctx, base);
	// 828E1CAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E1CB0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E1CB4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E1CB8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E1CBC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E1CC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E1CC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E1CC8 size=640
    let mut pc: u32 = 0x828E1CC8;
    'dispatch: loop {
        match pc {
            0x828E1CC8 => {
    //   block [0x828E1CC8..0x828E1F48)
	// 828E1CC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E1CCC: 488C6491  bl 0x831a815c
	ctx.lr = 0x828E1CD0;
	sub_831A8130(ctx, base);
	// 828E1CD0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E1CD4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828E1CD8: 48872929  bl 0x83154600
	ctx.lr = 0x828E1CDC;
	sub_83154600(ctx, base);
	// 828E1CDC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E1CE0: 48034A89  bl 0x82916768
	ctx.lr = 0x828E1CE4;
	sub_82916768(ctx, base);
	// 828E1CE4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828E1CE8: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 828E1CEC: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828E1CF0: 4802D089  bl 0x8290ed78
	ctx.lr = 0x828E1CF4;
	sub_8290ED78(ctx, base);
	// 828E1CF4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E1CF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E1CFC: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828E1D00: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E1D04: 4E800421  bctrl
	ctx.lr = 0x828E1D08;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E1D08: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828E1D0C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E1D10: 808B8064  lwz r4, -0x7f9c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-32668 as u32) ) } as u64;
	// 828E1D14: 48511CF5  bl 0x82df3a08
	ctx.lr = 0x828E1D18;
	sub_82DF3A08(ctx, base);
	// 828E1D18: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E1D1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E1D20: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E1D24: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828E1D28: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E1D2C: 4E800421  bctrl
	ctx.lr = 0x828E1D30;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E1D30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E1D34: 485116F5  bl 0x82df3428
	ctx.lr = 0x828E1D38;
	sub_82DF3428(ctx, base);
	// 828E1D38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E1D3C: 4BF99B55  bl 0x8287b890
	ctx.lr = 0x828E1D40;
	sub_8287B890(ctx, base);
	// 828E1D40: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 828E1D44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E1D48: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828E1D4C: C00B7BC4  lfs f0, 0x7bc4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31684 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828E1D50: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 828E1D54: D01B0060  stfs f0, 0x60(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828E1D58: 4BFB0831  bl 0x82892588
	ctx.lr = 0x828E1D5C;
	sub_82892588(ctx, base);
	// 828E1D5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E1D60: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828E1D64: 4BFB083D  bl 0x828925a0
	ctx.lr = 0x828E1D68;
	sub_828925A0(ctx, base);
	// 828E1D68: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828E1D6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E1D70: 93BB0064  stw r29, 0x64(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 828E1D74: 93BB0068  stw r29, 0x68(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 828E1D78: 480349F1  bl 0x82916768
	ctx.lr = 0x828E1D7C;
	sub_82916768(ctx, base);
	// 828E1D7C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E1D80: 816B006C  lwz r11, 0x6c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 828E1D84: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E1D88: 4E800421  bctrl
	ctx.lr = 0x828E1D8C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E1D8C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E1D90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E1D94: 4BF99AAD  bl 0x8287b840
	ctx.lr = 0x828E1D98;
	sub_8287B840(ctx, base);
	// 828E1D98: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828E1D9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E1DA0: 4805DFF1  bl 0x8293fd90
	ctx.lr = 0x828E1DA4;
	sub_8293FD90(ctx, base);
	// 828E1DA4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E1DA8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828E1DAC: 3B4B0B90  addi r26, r11, 0xb90
	ctx.r[26].s64 = ctx.r[11].s64 + 2960;
	// 828E1DB0: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 828E1DB4: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828E1DB8: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 828E1DBC: 4B9DE61D  bl 0x822c03d8
	ctx.lr = 0x828E1DC0;
	sub_822C03D8(ctx, base);
	// 828E1DC0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828E1DC4: 41820018  beq 0x828e1ddc
	if ctx.cr[0].eq {
	pc = 0x828E1DDC; continue 'dispatch;
	}
	// 828E1DC8: 38B9013C  addi r5, r25, 0x13c
	ctx.r[5].s64 = ctx.r[25].s64 + 316;
	// 828E1DCC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E1DD0: 4805F231  bl 0x82941000
	ctx.lr = 0x828E1DD4;
	sub_82941000(ctx, base);
	// 828E1DD4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828E1DD8: 48000008  b 0x828e1de0
	pc = 0x828E1DE0; continue 'dispatch;
	// 828E1DDC: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 828E1DE0: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828E1DE4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828E1DE8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828E1DEC: 4BF8FF3D  bl 0x82871d28
	ctx.lr = 0x828E1DF0;
	sub_82871D28(ctx, base);
	// 828E1DF0: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828E1DF4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828E1DF8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828E1DFC: 4B9DE205  bl 0x822c0000
	ctx.lr = 0x828E1E00;
	sub_822C0000(ctx, base);
	// 828E1E00: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E1E04: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E1E08: 4805E099  bl 0x8293fea0
	ctx.lr = 0x828E1E0C;
	sub_8293FEA0(ctx, base);
	// 828E1E0C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828E1E10: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828E1E14: 38A00069  li r5, 0x69
	ctx.r[5].s64 = 105;
	// 828E1E18: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828E1E1C: 4B9DE5BD  bl 0x822c03d8
	ctx.lr = 0x828E1E20;
	sub_822C03D8(ctx, base);
	// 828E1E20: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828E1E24: 41820018  beq 0x828e1e3c
	if ctx.cr[0].eq {
	pc = 0x828E1E3C; continue 'dispatch;
	}
	// 828E1E28: 38B90148  addi r5, r25, 0x148
	ctx.r[5].s64 = ctx.r[25].s64 + 328;
	// 828E1E2C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E1E30: 48061141  bl 0x82942f70
	ctx.lr = 0x828E1E34;
	sub_82942F70(ctx, base);
	// 828E1E34: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828E1E38: 48000008  b 0x828e1e40
	pc = 0x828E1E40; continue 'dispatch;
	// 828E1E3C: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 828E1E40: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828E1E44: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828E1E48: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828E1E4C: 4BF8FFA5  bl 0x82871df0
	ctx.lr = 0x828E1E50;
	sub_82871DF0(ctx, base);
	// 828E1E50: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828E1E54: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828E1E58: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828E1E5C: 4B9DE1A5  bl 0x822c0000
	ctx.lr = 0x828E1E60;
	sub_822C0000(ctx, base);
	// 828E1E60: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E1E64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E1E68: 4805E039  bl 0x8293fea0
	ctx.lr = 0x828E1E6C;
	sub_8293FEA0(ctx, base);
	// 828E1E6C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828E1E70: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828E1E74: 38A0006B  li r5, 0x6b
	ctx.r[5].s64 = 107;
	// 828E1E78: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 828E1E7C: 4B9DE55D  bl 0x822c03d8
	ctx.lr = 0x828E1E80;
	sub_822C03D8(ctx, base);
	// 828E1E80: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828E1E84: 41820018  beq 0x828e1e9c
	if ctx.cr[0].eq {
	pc = 0x828E1E9C; continue 'dispatch;
	}
	// 828E1E88: 38B90150  addi r5, r25, 0x150
	ctx.r[5].s64 = ctx.r[25].s64 + 336;
	// 828E1E8C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E1E90: 480614F9  bl 0x82943388
	ctx.lr = 0x828E1E94;
	sub_82943388(ctx, base);
	// 828E1E94: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828E1E98: 48000008  b 0x828e1ea0
	pc = 0x828E1EA0; continue 'dispatch;
	// 828E1E9C: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 828E1EA0: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828E1EA4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828E1EA8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828E1EAC: 4BF9000D  bl 0x82871eb8
	ctx.lr = 0x828E1EB0;
	sub_82871EB8(ctx, base);
	// 828E1EB0: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828E1EB4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828E1EB8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828E1EBC: 4B9DE145  bl 0x822c0000
	ctx.lr = 0x828E1EC0;
	sub_822C0000(ctx, base);
	// 828E1EC0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E1EC4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E1EC8: 4805DFD9  bl 0x8293fea0
	ctx.lr = 0x828E1ECC;
	sub_8293FEA0(ctx, base);
	// 828E1ECC: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828E1ED0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828E1ED4: 38A0006D  li r5, 0x6d
	ctx.r[5].s64 = 109;
	// 828E1ED8: 38600040  li r3, 0x40
	ctx.r[3].s64 = 64;
	// 828E1EDC: 4B9DE4FD  bl 0x822c03d8
	ctx.lr = 0x828E1EE0;
	sub_822C03D8(ctx, base);
	// 828E1EE0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828E1EE4: 41820014  beq 0x828e1ef8
	if ctx.cr[0].eq {
	pc = 0x828E1EF8; continue 'dispatch;
	}
	// 828E1EE8: 38B90160  addi r5, r25, 0x160
	ctx.r[5].s64 = ctx.r[25].s64 + 352;
	// 828E1EEC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E1EF0: 48060A31  bl 0x82942920
	ctx.lr = 0x828E1EF4;
	sub_82942920(ctx, base);
	// 828E1EF4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828E1EF8: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 828E1EFC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828E1F00: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828E1F04: 4BF9007D  bl 0x82871f80
	ctx.lr = 0x828E1F08;
	sub_82871F80(ctx, base);
	// 828E1F08: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828E1F0C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828E1F10: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828E1F14: 4B9DE0ED  bl 0x822c0000
	ctx.lr = 0x828E1F18;
	sub_822C0000(ctx, base);
	// 828E1F18: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E1F1C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E1F20: 4805DF81  bl 0x8293fea0
	ctx.lr = 0x828E1F24;
	sub_8293FEA0(ctx, base);
	// 828E1F24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E1F28: 4BF0B8F1  bl 0x827ed818
	ctx.lr = 0x828E1F2C;
	sub_827ED818(ctx, base);
	// 828E1F2C: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 828E1F30: 4BFF87D9  bl 0x828da708
	ctx.lr = 0x828E1F34;
	sub_828DA708(ctx, base);
	// 828E1F34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E1F38: 48034BC9  bl 0x82916b00
	ctx.lr = 0x828E1F3C;
	sub_82916B00(ctx, base);
	// 828E1F3C: 987B006C  stb r3, 0x6c(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(108 as u32), ctx.r[3].u8 ) };
	// 828E1F40: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828E1F44: 488C6268  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E1F48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E1F48 size=112
    let mut pc: u32 = 0x828E1F48;
    'dispatch: loop {
        match pc {
            0x828E1F48 => {
    //   block [0x828E1F48..0x828E1FB8)
	// 828E1F48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E1F4C: 488C6221  bl 0x831a816c
	ctx.lr = 0x828E1F50;
	sub_831A8130(ctx, base);
	// 828E1F50: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E1F54: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E1F58: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828E1F5C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828E1F60: 388B0B90  addi r4, r11, 0xb90
	ctx.r[4].s64 = ctx.r[11].s64 + 2960;
	// 828E1F64: 38A0011C  li r5, 0x11c
	ctx.r[5].s64 = 284;
	// 828E1F68: 38600070  li r3, 0x70
	ctx.r[3].s64 = 112;
	// 828E1F6C: 4851047D  bl 0x82df23e8
	ctx.lr = 0x828E1F70;
	sub_82DF23E8(ctx, base);
	// 828E1F70: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828E1F74: 41820010  beq 0x828e1f84
	if ctx.cr[0].eq {
	pc = 0x828E1F84; continue 'dispatch;
	}
	// 828E1F78: 4BFFFCE1  bl 0x828e1c58
	ctx.lr = 0x828E1F7C;
	sub_828E1C58(ctx, base);
	// 828E1F7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E1F80: 48000008  b 0x828e1f88
	pc = 0x828E1F88; continue 'dispatch;
	// 828E1F84: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828E1F88: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828E1F8C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828E1F90: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E1F94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E1F98: 4BFFFBF9  bl 0x828e1b90
	ctx.lr = 0x828E1F9C;
	sub_828E1B90(ctx, base);
	// 828E1F9C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828E1FA0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E1FA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E1FA8: 4B9DE059  bl 0x822c0000
	ctx.lr = 0x828E1FAC;
	sub_822C0000(ctx, base);
	// 828E1FAC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828E1FB0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E1FB4: 488C6208  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E1FB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E1FB8 size=332
    let mut pc: u32 = 0x828E1FB8;
    'dispatch: loop {
        match pc {
            0x828E1FB8 => {
    //   block [0x828E1FB8..0x828E2104)
	// 828E1FB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E1FBC: 488C61AD  bl 0x831a8168
	ctx.lr = 0x828E1FC0;
	sub_831A8130(ctx, base);
	// 828E1FC0: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 828E1FC4: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E1FC8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E1FCC: 48872635  bl 0x83154600
	ctx.lr = 0x828E1FD0;
	sub_83154600(ctx, base);
	// 828E1FD0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E1FD4: 48034795  bl 0x82916768
	ctx.lr = 0x828E1FD8;
	sub_82916768(ctx, base);
	// 828E1FD8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828E1FDC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E1FE0: 48577799  bl 0x82e59778
	ctx.lr = 0x828E1FE4;
	sub_82E59778(ctx, base);
	// 828E1FE4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E1FE8: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 828E1FEC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828E1FF0: 816B006C  lwz r11, 0x6c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 828E1FF4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E1FF8: 4E800421  bctrl
	ctx.lr = 0x828E1FFC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E1FFC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828E2000: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E2004: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828E2008: 4805DC29  bl 0x8293fc30
	ctx.lr = 0x828E200C;
	sub_8293FC30(ctx, base);
	// 828E200C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E2010: 4BF99831  bl 0x8287b840
	ctx.lr = 0x828E2014;
	sub_8287B840(ctx, base);
	// 828E2014: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828E2018: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E201C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E2020: 4BF99839  bl 0x8287b858
	ctx.lr = 0x828E2024;
	sub_8287B858(ctx, base);
	// 828E2024: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E2028: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828E202C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E2030: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E2034: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E2038: 4E800421  bctrl
	ctx.lr = 0x828E203C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E203C: 13C018C7  vcmpequd (lvx128) v30, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828E2040: 13E0E0C7  vcmpequd (lvx128) v31, v0, v28
	tmp.u32 = ctx.r[28].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828E2044: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E2108(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E2108 size=476
    let mut pc: u32 = 0x828E2108;
    'dispatch: loop {
        match pc {
            0x828E2108 => {
    //   block [0x828E2108..0x828E22E4)
	// 828E2108: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E210C: 488C605D  bl 0x831a8168
	ctx.lr = 0x828E2110;
	sub_831A8130(ctx, base);
	// 828E2110: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E2114: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E2118: 488724E9  bl 0x83154600
	ctx.lr = 0x828E211C;
	sub_83154600(ctx, base);
	// 828E211C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828E2120: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E2124: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828E2128: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E212C: 4E800421  bctrl
	ctx.lr = 0x828E2130;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E2130: 817E0068  lwz r11, 0x68(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(104 as u32) ) } as u64;
	// 828E2134: 3BFE0068  addi r31, r30, 0x68
	ctx.r[31].s64 = ctx.r[30].s64 + 104;
	// 828E2138: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E213C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828E2140: 41820010  beq 0x828e2150
	if ctx.cr[0].eq {
	pc = 0x828E2150; continue 'dispatch;
	}
	// 828E2144: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E2148: 917E0064  stw r11, 0x64(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828E214C: 48000138  b 0x828e2284
	pc = 0x828E2284; continue 'dispatch;
	// 828E2150: 817E0064  lwz r11, 0x64(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 828E2154: 556AD7FF  rlwinm. r10, r11, 0x1a, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828E2158: 4182001C  beq 0x828e2174
	if ctx.cr[0].eq {
	pc = 0x828E2174; continue 'dispatch;
	}
	// 828E215C: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828E2160: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828E2164: 556B06B0  rlwinm r11, r11, 0, 0x1a, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828E2168: 917E0064  stw r11, 0x64(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828E216C: 808A806C  lwz r4, -0x7f94(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-32660 as u32) ) } as u64;
	// 828E2170: 480000E0  b 0x828e2250
	pc = 0x828E2250; continue 'dispatch;
	// 828E2174: 556ADFFF  rlwinm. r10, r11, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828E2178: 4182001C  beq 0x828e2194
	if ctx.cr[0].eq {
	pc = 0x828E2194; continue 'dispatch;
	}
	// 828E217C: 817E0064  lwz r11, 0x64(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 828E2180: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828E2184: 556B06F2  rlwinm r11, r11, 0, 0x1b, 0x19
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828E2188: 917E0064  stw r11, 0x64(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828E218C: 808A8074  lwz r4, -0x7f8c(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-32652 as u32) ) } as u64;
	// 828E2190: 480000C0  b 0x828e2250
	pc = 0x828E2250; continue 'dispatch;
	// 828E2194: 556AF7FF  rlwinm. r10, r11, 0x1e, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828E2198: 4182001C  beq 0x828e21b4
	if ctx.cr[0].eq {
	pc = 0x828E21B4; continue 'dispatch;
	}
	// 828E219C: 817E0064  lwz r11, 0x64(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 828E21A0: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828E21A4: 556B07B8  rlwinm r11, r11, 0, 0x1e, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828E21A8: 917E0064  stw r11, 0x64(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828E21AC: 808A8070  lwz r4, -0x7f90(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-32656 as u32) ) } as u64;
	// 828E21B0: 480000A0  b 0x828e2250
	pc = 0x828E2250; continue 'dispatch;
	// 828E21B4: 556AFFFF  rlwinm. r10, r11, 0x1f, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828E21B8: 4182001C  beq 0x828e21d4
	if ctx.cr[0].eq {
	pc = 0x828E21D4; continue 'dispatch;
	}
	// 828E21BC: 817E0064  lwz r11, 0x64(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 828E21C0: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828E21C4: 556B07FA  rlwinm r11, r11, 0, 0x1f, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828E21C8: 917E0064  stw r11, 0x64(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828E21CC: 808A8078  lwz r4, -0x7f88(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-32648 as u32) ) } as u64;
	// 828E21D0: 48000080  b 0x828e2250
	pc = 0x828E2250; continue 'dispatch;
	// 828E21D4: 556AC7FF  rlwinm. r10, r11, 0x18, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828E21D8: 4182001C  beq 0x828e21f4
	if ctx.cr[0].eq {
	pc = 0x828E21F4; continue 'dispatch;
	}
	// 828E21DC: 817E0064  lwz r11, 0x64(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 828E21E0: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828E21E4: 556B062C  rlwinm r11, r11, 0, 0x18, 0x16
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828E21E8: 917E0064  stw r11, 0x64(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828E21EC: 808A807C  lwz r4, -0x7f84(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-32644 as u32) ) } as u64;
	// 828E21F0: 48000060  b 0x828e2250
	pc = 0x828E2250; continue 'dispatch;
	// 828E21F4: 556AE7FF  rlwinm. r10, r11, 0x1c, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828E21F8: 4182001C  beq 0x828e2214
	if ctx.cr[0].eq {
	pc = 0x828E2214; continue 'dispatch;
	}
	// 828E21FC: 817E0064  lwz r11, 0x64(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 828E2200: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828E2204: 556B0734  rlwinm r11, r11, 0, 0x1c, 0x1a
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828E2208: 917E0064  stw r11, 0x64(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828E220C: 808A8080  lwz r4, -0x7f80(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-32640 as u32) ) } as u64;
	// 828E2210: 48000040  b 0x828e2250
	pc = 0x828E2250; continue 'dispatch;
	// 828E2214: 556ACFFF  rlwinm. r10, r11, 0x19, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000007Fu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828E2218: 4182001C  beq 0x828e2234
	if ctx.cr[0].eq {
	pc = 0x828E2234; continue 'dispatch;
	}
	// 828E221C: 817E0064  lwz r11, 0x64(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 828E2220: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828E2224: 556B066E  rlwinm r11, r11, 0, 0x19, 0x17
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828E2228: 917E0064  stw r11, 0x64(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828E222C: 808A8084  lwz r4, -0x7f7c(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-32636 as u32) ) } as u64;
	// 828E2230: 48000020  b 0x828e2250
	pc = 0x828E2250; continue 'dispatch;
	// 828E2234: 556BEFFF  rlwinm. r11, r11, 0x1d, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000007u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E2238: 4182004C  beq 0x828e2284
	if ctx.cr[0].eq {
	pc = 0x828E2284; continue 'dispatch;
	}
	// 828E223C: 817E0064  lwz r11, 0x64(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 828E2240: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828E2244: 556B0776  rlwinm r11, r11, 0, 0x1d, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828E2248: 917E0064  stw r11, 0x64(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828E224C: 808A8088  lwz r4, -0x7f78(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-32632 as u32) ) } as u64;
	// 828E2250: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E2254: 485117B5  bl 0x82df3a08
	ctx.lr = 0x828E2258;
	sub_82DF3A08(ctx, base);
	// 828E2258: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E225C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828E2260: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E2264: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828E2268: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E226C: 4E800421  bctrl
	ctx.lr = 0x828E2270;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E2270: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E2274: 485111B5  bl 0x82df3428
	ctx.lr = 0x828E2278;
	sub_82DF3428(ctx, base);
	// 828E2278: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E227C: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828E2280: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E2284: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E2288: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E228C: 41820050  beq 0x828e22dc
	if ctx.cr[0].eq {
	pc = 0x828E22DC; continue 'dispatch;
	}
	// 828E2290: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828E2294: 4BF0807D  bl 0x827ea310
	ctx.lr = 0x828E2298;
	sub_827EA310(ctx, base);
	// 828E2298: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E229C: 41820040  beq 0x828e22dc
	if ctx.cr[0].eq {
	pc = 0x828E22DC; continue 'dispatch;
	}
	// 828E22A0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828E22A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E22A8: 808B8064  lwz r4, -0x7f9c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-32668 as u32) ) } as u64;
	// 828E22AC: 4851175D  bl 0x82df3a08
	ctx.lr = 0x828E22B0;
	sub_82DF3A08(ctx, base);
	// 828E22B0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E22B4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E22B8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828E22BC: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828E22C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E22C4: 4E800421  bctrl
	ctx.lr = 0x828E22C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E22C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E22CC: 4851115D  bl 0x82df3428
	ctx.lr = 0x828E22D0;
	sub_82DF3428(ctx, base);
	// 828E22D0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E22D4: 556B003C  rlwinm r11, r11, 0, 0, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828E22D8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E22DC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828E22E0: 488C5ED8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E22E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E22E8 size=220
    let mut pc: u32 = 0x828E22E8;
    'dispatch: loop {
        match pc {
            0x828E22E8 => {
    //   block [0x828E22E8..0x828E23C4)
	// 828E22E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E22EC: 488C5E81  bl 0x831a816c
	ctx.lr = 0x828E22F0;
	sub_831A8130(ctx, base);
	// 828E22F0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E22F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E22F8: 48872309  bl 0x83154600
	ctx.lr = 0x828E22FC;
	sub_83154600(ctx, base);
	// 828E22FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E2300: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E2304: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E2308: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E230C: 4E800421  bctrl
	ctx.lr = 0x828E2310;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E2310: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828E2314: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E2318: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828E231C: 4BF9953D  bl 0x8287b858
	ctx.lr = 0x828E2320;
	sub_8287B858(ctx, base);
	// 828E2320: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828E2324: 13E0E8C7  vcmpequd (lvx128) v31, v0, v29
	tmp.u32 = ctx.r[29].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828E2328: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 828E232C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 828E2330: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828E2334: 13C058C7  vcmpequd (lvx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E23C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E23C8 size=148
    let mut pc: u32 = 0x828E23C8;
    'dispatch: loop {
        match pc {
            0x828E23C8 => {
    //   block [0x828E23C8..0x828E245C)
	// 828E23C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E23CC: 488C5DA1  bl 0x831a816c
	ctx.lr = 0x828E23D0;
	sub_831A8130(ctx, base);
	// 828E23D0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E23D4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E23D8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828E23DC: 816B01B0  lwz r11, 0x1b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(432 as u32) ) } as u64;
	// 828E23E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E23E4: 4E800421  bctrl
	ctx.lr = 0x828E23E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E23E8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828E23EC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E23F0: 388B5D2C  addi r4, r11, 0x5d2c
	ctx.r[4].s64 = ctx.r[11].s64 + 23852;
	// 828E23F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E23F8: 48511611  bl 0x82df3a08
	ctx.lr = 0x828E23FC;
	sub_82DF3A08(ctx, base);
	// 828E23FC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E2400: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E2404: 48510F05  bl 0x82df3308
	ctx.lr = 0x828E2408;
	sub_82DF3308(ctx, base);
	// 828E2408: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828E240C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E2410: 48511019  bl 0x82df3428
	ctx.lr = 0x828E2414;
	sub_82DF3428(ctx, base);
	// 828E2414: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E2418: 40820038  bne 0x828e2450
	if !ctx.cr[0].eq {
	pc = 0x828E2450; continue 'dispatch;
	}
	// 828E241C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828E2420: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E2424: 388B7C94  addi r4, r11, 0x7c94
	ctx.r[4].s64 = ctx.r[11].s64 + 31892;
	// 828E2428: 485115E1  bl 0x82df3a08
	ctx.lr = 0x828E242C;
	sub_82DF3A08(ctx, base);
	// 828E242C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E2430: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E2434: 48510ED5  bl 0x82df3308
	ctx.lr = 0x828E2438;
	sub_82DF3308(ctx, base);
	// 828E2438: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E243C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E2440: 48510FE9  bl 0x82df3428
	ctx.lr = 0x828E2444;
	sub_82DF3428(ctx, base);
	// 828E2444: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E2448: 387E0184  addi r3, r30, 0x184
	ctx.r[3].s64 = ctx.r[30].s64 + 388;
	// 828E244C: 40820008  bne 0x828e2454
	if !ctx.cr[0].eq {
	pc = 0x828E2454; continue 'dispatch;
	}
	// 828E2450: 387E0174  addi r3, r30, 0x174
	ctx.r[3].s64 = ctx.r[30].s64 + 372;
	// 828E2454: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828E2458: 488C5D64  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E2460(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828E2460 size=16
    let mut pc: u32 = 0x828E2460;
    'dispatch: loop {
        match pc {
            0x828E2460 => {
    //   block [0x828E2460..0x828E2470)
	// 828E2460: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E2464: 816B01B0  lwz r11, 0x1b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(432 as u32) ) } as u64;
	// 828E2468: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E246C: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E2470(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E2470 size=48
    let mut pc: u32 = 0x828E2470;
    'dispatch: loop {
        match pc {
            0x828E2470 => {
    //   block [0x828E2470..0x828E24A0)
	// 828E2470: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E2474: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E2478: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E247C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E2480: 816B01B0  lwz r11, 0x1b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(432 as u32) ) } as u64;
	// 828E2484: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E2488: 4E800421  bctrl
	ctx.lr = 0x828E248C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E248C: 386300AC  addi r3, r3, 0xac
	ctx.r[3].s64 = ctx.r[3].s64 + 172;
	// 828E2490: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828E2494: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E2498: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E249C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E24A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828E24A0 size=12
    let mut pc: u32 = 0x828E24A0;
    'dispatch: loop {
        match pc {
            0x828E24A0 => {
    //   block [0x828E24A0..0x828E24AC)
	// 828E24A0: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828E24A4: 386B3CBC  addi r3, r11, 0x3cbc
	ctx.r[3].s64 = ctx.r[11].s64 + 15548;
	// 828E24A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E24B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828E24B0 size=16
    let mut pc: u32 = 0x828E24B0;
    'dispatch: loop {
        match pc {
            0x828E24B0 => {
    //   block [0x828E24B0..0x828E24C0)
	// 828E24B0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E24B4: 816B01AC  lwz r11, 0x1ac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(428 as u32) ) } as u64;
	// 828E24B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E24BC: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E24C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E24C0 size=88
    let mut pc: u32 = 0x828E24C0;
    'dispatch: loop {
        match pc {
            0x828E24C0 => {
    //   block [0x828E24C0..0x828E2518)
	// 828E24C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E24C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E24C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E24CC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E24D0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E24D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E24D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E24DC: 388B8A1C  addi r4, r11, -0x75e4
	ctx.r[4].s64 = ctx.r[11].s64 + -30180;
	// 828E24E0: 48511529  bl 0x82df3a08
	ctx.lr = 0x828E24E4;
	sub_82DF3A08(ctx, base);
	// 828E24E4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828E24E8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828E24EC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E24F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E24F4: C02BA1C4  lfs f1, -0x5e3c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828E24F8: 4802A189  bl 0x8290c680
	ctx.lr = 0x828E24FC;
	sub_8290C680(ctx, base);
	// 828E24FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E2500: 48510F29  bl 0x82df3428
	ctx.lr = 0x828E2504;
	sub_82DF3428(ctx, base);
	// 828E2504: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E2508: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E250C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E2510: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E2514: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E2518(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E2518 size=88
    let mut pc: u32 = 0x828E2518;
    'dispatch: loop {
        match pc {
            0x828E2518 => {
    //   block [0x828E2518..0x828E2570)
	// 828E2518: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E251C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E2520: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E2524: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E2528: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E252C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E2530: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E2534: 388B8A1C  addi r4, r11, -0x75e4
	ctx.r[4].s64 = ctx.r[11].s64 + -30180;
	// 828E2538: 485114D1  bl 0x82df3a08
	ctx.lr = 0x828E253C;
	sub_82DF3A08(ctx, base);
	// 828E253C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828E2540: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 828E2544: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E2548: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E254C: C02BA1C4  lfs f1, -0x5e3c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828E2550: 4802A131  bl 0x8290c680
	ctx.lr = 0x828E2554;
	sub_8290C680(ctx, base);
	// 828E2554: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E2558: 48510ED1  bl 0x82df3428
	ctx.lr = 0x828E255C;
	sub_82DF3428(ctx, base);
	// 828E255C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E2560: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E2564: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E2568: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E256C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E2570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E2570 size=88
    let mut pc: u32 = 0x828E2570;
    'dispatch: loop {
        match pc {
            0x828E2570 => {
    //   block [0x828E2570..0x828E25C8)
	// 828E2570: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E2574: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E2578: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E257C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E2580: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E2584: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E2588: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E258C: 388B8A1C  addi r4, r11, -0x75e4
	ctx.r[4].s64 = ctx.r[11].s64 + -30180;
	// 828E2590: 48511479  bl 0x82df3a08
	ctx.lr = 0x828E2594;
	sub_82DF3A08(ctx, base);
	// 828E2594: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828E2598: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828E259C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E25A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E25A4: C02BA1C4  lfs f1, -0x5e3c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828E25A8: 4802A179  bl 0x8290c720
	ctx.lr = 0x828E25AC;
	sub_8290C720(ctx, base);
	// 828E25AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E25B0: 48510E79  bl 0x82df3428
	ctx.lr = 0x828E25B4;
	sub_82DF3428(ctx, base);
	// 828E25B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E25B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E25BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E25C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E25C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E25C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E25C8 size=88
    let mut pc: u32 = 0x828E25C8;
    'dispatch: loop {
        match pc {
            0x828E25C8 => {
    //   block [0x828E25C8..0x828E2620)
	// 828E25C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E25CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E25D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E25D4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E25D8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E25DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E25E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E25E4: 388B8A1C  addi r4, r11, -0x75e4
	ctx.r[4].s64 = ctx.r[11].s64 + -30180;
	// 828E25E8: 48511421  bl 0x82df3a08
	ctx.lr = 0x828E25EC;
	sub_82DF3A08(ctx, base);
	// 828E25EC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828E25F0: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 828E25F4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E25F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E25FC: C02BA1C4  lfs f1, -0x5e3c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828E2600: 4802A121  bl 0x8290c720
	ctx.lr = 0x828E2604;
	sub_8290C720(ctx, base);
	// 828E2604: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E2608: 48510E21  bl 0x82df3428
	ctx.lr = 0x828E260C;
	sub_82DF3428(ctx, base);
	// 828E260C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E2610: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E2614: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E2618: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E261C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E2620(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828E2620 size=8
    let mut pc: u32 = 0x828E2620;
    'dispatch: loop {
        match pc {
            0x828E2620 => {
    //   block [0x828E2620..0x828E2628)
	// 828E2620: 806303E0  lwz r3, 0x3e0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(992 as u32) ) } as u64;
	// 828E2624: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E2628(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828E2628 size=28
    let mut pc: u32 = 0x828E2628;
    'dispatch: loop {
        match pc {
            0x828E2628 => {
    //   block [0x828E2628..0x828E2644)
	// 828E2628: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E262C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828E2630: 816B00D4  lwz r11, 0xd4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(212 as u32) ) } as u64;
	// 828E2634: 409A0010  bne cr6, 0x828e2644
	if !ctx.cr[6].eq {
		sub_828E2644(ctx, base);
		return;
	}
	// 828E2638: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828E263C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E2640: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E2644(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828E2644 size=12
    let mut pc: u32 = 0x828E2644;
    'dispatch: loop {
        match pc {
            0x828E2644 => {
    //   block [0x828E2644..0x828E2650)
	// 828E2644: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828E2648: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E264C: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E2650(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E2650 size=136
    let mut pc: u32 = 0x828E2650;
    'dispatch: loop {
        match pc {
            0x828E2650 => {
    //   block [0x828E2650..0x828E26D8)
	// 828E2650: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E2654: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E2658: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E265C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E2660: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E2664: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E2668: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E266C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828E2670: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E2674: 388B0C34  addi r4, r11, 0xc34
	ctx.r[4].s64 = ctx.r[11].s64 + 3124;
	// 828E2678: 48511391  bl 0x82df3a08
	ctx.lr = 0x828E267C;
	sub_82DF3A08(ctx, base);
	// 828E267C: 3BFFFCA0  addi r31, r31, -0x360
	ctx.r[31].s64 = ctx.r[31].s64 + -864;
	// 828E2680: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E2684: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E2688: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828E268C: 4802B7C5  bl 0x8290de50
	ctx.lr = 0x828E2690;
	sub_8290DE50(ctx, base);
	// 828E2690: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E2694: 48510D95  bl 0x82df3428
	ctx.lr = 0x828E2698;
	sub_82DF3428(ctx, base);
	// 828E2698: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E269C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E26A0: 388B0C1C  addi r4, r11, 0xc1c
	ctx.r[4].s64 = ctx.r[11].s64 + 3100;
	// 828E26A4: 48511365  bl 0x82df3a08
	ctx.lr = 0x828E26A8;
	sub_82DF3A08(ctx, base);
	// 828E26A8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828E26AC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E26B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E26B4: 4802B875  bl 0x8290df28
	ctx.lr = 0x828E26B8;
	sub_8290DF28(ctx, base);
	// 828E26B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E26BC: 48510D6D  bl 0x82df3428
	ctx.lr = 0x828E26C0;
	sub_82DF3428(ctx, base);
	// 828E26C0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E26C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E26C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E26CC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E26D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E26D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E26D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828E26D8 size=12
    let mut pc: u32 = 0x828E26D8;
    'dispatch: loop {
        match pc {
            0x828E26D8 => {
    //   block [0x828E26D8..0x828E26E4)
	// 828E26D8: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828E26DC: 386B3CC8  addi r3, r11, 0x3cc8
	ctx.r[3].s64 = ctx.r[11].s64 + 15560;
	// 828E26E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E26E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828E26E8 size=24
    let mut pc: u32 = 0x828E26E8;
    'dispatch: loop {
        match pc {
            0x828E26E8 => {
    //   block [0x828E26E8..0x828E2700)
	// 828E26E8: 814303E8  lwz r10, 0x3e8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1000 as u32) ) } as u64;
	// 828E26EC: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828E26F0: 396B3DA0  addi r11, r11, 0x3da0
	ctx.r[11].s64 = ctx.r[11].s64 + 15776;
	// 828E26F4: 1D4A021C  mulli r10, r10, 0x21c
	ctx.r[10].s64 = ctx.r[10].s64 * 540;
	// 828E26F8: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828E26FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E2700(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E2700 size=136
    let mut pc: u32 = 0x828E2700;
    'dispatch: loop {
        match pc {
            0x828E2700 => {
    //   block [0x828E2700..0x828E2788)
	// 828E2700: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E2704: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E2708: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E270C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E2710: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E2714: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E2718: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E271C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828E2720: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E2724: 388B0C50  addi r4, r11, 0xc50
	ctx.r[4].s64 = ctx.r[11].s64 + 3152;
	// 828E2728: 485112E1  bl 0x82df3a08
	ctx.lr = 0x828E272C;
	sub_82DF3A08(ctx, base);
	// 828E272C: 3BFFFCA0  addi r31, r31, -0x360
	ctx.r[31].s64 = ctx.r[31].s64 + -864;
	// 828E2730: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E2734: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E2738: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828E273C: 4802B715  bl 0x8290de50
	ctx.lr = 0x828E2740;
	sub_8290DE50(ctx, base);
	// 828E2740: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E2744: 48510CE5  bl 0x82df3428
	ctx.lr = 0x828E2748;
	sub_82DF3428(ctx, base);
	// 828E2748: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E274C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E2750: 388B0C1C  addi r4, r11, 0xc1c
	ctx.r[4].s64 = ctx.r[11].s64 + 3100;
	// 828E2754: 485112B5  bl 0x82df3a08
	ctx.lr = 0x828E2758;
	sub_82DF3A08(ctx, base);
	// 828E2758: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828E275C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E2760: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E2764: 4802B7C5  bl 0x8290df28
	ctx.lr = 0x828E2768;
	sub_8290DF28(ctx, base);
	// 828E2768: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E276C: 48510CBD  bl 0x82df3428
	ctx.lr = 0x828E2770;
	sub_82DF3428(ctx, base);
	// 828E2770: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E2774: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E2778: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E277C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E2780: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E2784: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E2788(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828E2788 size=12
    let mut pc: u32 = 0x828E2788;
    'dispatch: loop {
        match pc {
            0x828E2788 => {
    //   block [0x828E2788..0x828E2794)
	// 828E2788: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828E278C: 386B52B8  addi r3, r11, 0x52b8
	ctx.r[3].s64 = ctx.r[11].s64 + 21176;
	// 828E2790: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E2798(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828E2798 size=24
    let mut pc: u32 = 0x828E2798;
    'dispatch: loop {
        match pc {
            0x828E2798 => {
    //   block [0x828E2798..0x828E27B0)
	// 828E2798: 814303E8  lwz r10, 0x3e8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1000 as u32) ) } as u64;
	// 828E279C: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828E27A0: 396B5390  addi r11, r11, 0x5390
	ctx.r[11].s64 = ctx.r[11].s64 + 21392;
	// 828E27A4: 1D4A021C  mulli r10, r10, 0x21c
	ctx.r[10].s64 = ctx.r[10].s64 * 540;
	// 828E27A8: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828E27AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E27B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E27B0 size=136
    let mut pc: u32 = 0x828E27B0;
    'dispatch: loop {
        match pc {
            0x828E27B0 => {
    //   block [0x828E27B0..0x828E2838)
	// 828E27B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E27B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E27B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E27BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E27C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E27C4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E27C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E27CC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828E27D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E27D4: 388B0C70  addi r4, r11, 0xc70
	ctx.r[4].s64 = ctx.r[11].s64 + 3184;
	// 828E27D8: 48511231  bl 0x82df3a08
	ctx.lr = 0x828E27DC;
	sub_82DF3A08(ctx, base);
	// 828E27DC: 3BFFFCA0  addi r31, r31, -0x360
	ctx.r[31].s64 = ctx.r[31].s64 + -864;
	// 828E27E0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E27E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E27E8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828E27EC: 4802B665  bl 0x8290de50
	ctx.lr = 0x828E27F0;
	sub_8290DE50(ctx, base);
	// 828E27F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E27F4: 48510C35  bl 0x82df3428
	ctx.lr = 0x828E27F8;
	sub_82DF3428(ctx, base);
	// 828E27F8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E27FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E2800: 388B0C1C  addi r4, r11, 0xc1c
	ctx.r[4].s64 = ctx.r[11].s64 + 3100;
	// 828E2804: 48511205  bl 0x82df3a08
	ctx.lr = 0x828E2808;
	sub_82DF3A08(ctx, base);
	// 828E2808: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828E280C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E2810: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E2814: 4802B715  bl 0x8290df28
	ctx.lr = 0x828E2818;
	sub_8290DF28(ctx, base);
	// 828E2818: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E281C: 48510C0D  bl 0x82df3428
	ctx.lr = 0x828E2820;
	sub_82DF3428(ctx, base);
	// 828E2820: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E2824: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E2828: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E282C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E2830: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E2834: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E2838(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828E2838 size=12
    let mut pc: u32 = 0x828E2838;
    'dispatch: loop {
        match pc {
            0x828E2838 => {
    //   block [0x828E2838..0x828E2844)
	// 828E2838: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828E283C: 386B68A8  addi r3, r11, 0x68a8
	ctx.r[3].s64 = ctx.r[11].s64 + 26792;
	// 828E2840: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E2848(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828E2848 size=24
    let mut pc: u32 = 0x828E2848;
    'dispatch: loop {
        match pc {
            0x828E2848 => {
    //   block [0x828E2848..0x828E2860)
	// 828E2848: 814303E8  lwz r10, 0x3e8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1000 as u32) ) } as u64;
	// 828E284C: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828E2850: 396B6980  addi r11, r11, 0x6980
	ctx.r[11].s64 = ctx.r[11].s64 + 27008;
	// 828E2854: 1D4A021C  mulli r10, r10, 0x21c
	ctx.r[10].s64 = ctx.r[10].s64 * 540;
	// 828E2858: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828E285C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E2860(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E2860 size=136
    let mut pc: u32 = 0x828E2860;
    'dispatch: loop {
        match pc {
            0x828E2860 => {
    //   block [0x828E2860..0x828E28E8)
	// 828E2860: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E2864: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E2868: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E286C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E2870: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E2874: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E2878: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E287C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828E2880: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E2884: 388B0C90  addi r4, r11, 0xc90
	ctx.r[4].s64 = ctx.r[11].s64 + 3216;
	// 828E2888: 48511181  bl 0x82df3a08
	ctx.lr = 0x828E288C;
	sub_82DF3A08(ctx, base);
	// 828E288C: 3BFFFCA0  addi r31, r31, -0x360
	ctx.r[31].s64 = ctx.r[31].s64 + -864;
	// 828E2890: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E2894: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E2898: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828E289C: 4802B5B5  bl 0x8290de50
	ctx.lr = 0x828E28A0;
	sub_8290DE50(ctx, base);
	// 828E28A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E28A4: 48510B85  bl 0x82df3428
	ctx.lr = 0x828E28A8;
	sub_82DF3428(ctx, base);
	// 828E28A8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E28AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E28B0: 388B0C1C  addi r4, r11, 0xc1c
	ctx.r[4].s64 = ctx.r[11].s64 + 3100;
	// 828E28B4: 48511155  bl 0x82df3a08
	ctx.lr = 0x828E28B8;
	sub_82DF3A08(ctx, base);
	// 828E28B8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828E28BC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E28C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E28C4: 4802B665  bl 0x8290df28
	ctx.lr = 0x828E28C8;
	sub_8290DF28(ctx, base);
	// 828E28C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E28CC: 48510B5D  bl 0x82df3428
	ctx.lr = 0x828E28D0;
	sub_82DF3428(ctx, base);
	// 828E28D0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E28D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E28D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E28DC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E28E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E28E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E28E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828E28E8 size=12
    let mut pc: u32 = 0x828E28E8;
    'dispatch: loop {
        match pc {
            0x828E28E8 => {
    //   block [0x828E28E8..0x828E28F4)
	// 828E28E8: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828E28EC: 386B7E98  addi r3, r11, 0x7e98
	ctx.r[3].s64 = ctx.r[11].s64 + 32408;
	// 828E28F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E28F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828E28F8 size=24
    let mut pc: u32 = 0x828E28F8;
    'dispatch: loop {
        match pc {
            0x828E28F8 => {
    //   block [0x828E28F8..0x828E2910)
	// 828E28F8: 814303E8  lwz r10, 0x3e8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1000 as u32) ) } as u64;
	// 828E28FC: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828E2900: 396B7F70  addi r11, r11, 0x7f70
	ctx.r[11].s64 = ctx.r[11].s64 + 32624;
	// 828E2904: 1D4A021C  mulli r10, r10, 0x21c
	ctx.r[10].s64 = ctx.r[10].s64 * 540;
	// 828E2908: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828E290C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E2910(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E2910 size=136
    let mut pc: u32 = 0x828E2910;
    'dispatch: loop {
        match pc {
            0x828E2910 => {
    //   block [0x828E2910..0x828E2998)
	// 828E2910: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E2914: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E2918: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E291C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E2920: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E2924: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E2928: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E292C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828E2930: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E2934: 388B0CAC  addi r4, r11, 0xcac
	ctx.r[4].s64 = ctx.r[11].s64 + 3244;
	// 828E2938: 485110D1  bl 0x82df3a08
	ctx.lr = 0x828E293C;
	sub_82DF3A08(ctx, base);
	// 828E293C: 3BFFFCA0  addi r31, r31, -0x360
	ctx.r[31].s64 = ctx.r[31].s64 + -864;
	// 828E2940: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E2944: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E2948: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828E294C: 4802B505  bl 0x8290de50
	ctx.lr = 0x828E2950;
	sub_8290DE50(ctx, base);
	// 828E2950: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E2954: 48510AD5  bl 0x82df3428
	ctx.lr = 0x828E2958;
	sub_82DF3428(ctx, base);
	// 828E2958: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E295C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E2960: 388B0C1C  addi r4, r11, 0xc1c
	ctx.r[4].s64 = ctx.r[11].s64 + 3100;
	// 828E2964: 485110A5  bl 0x82df3a08
	ctx.lr = 0x828E2968;
	sub_82DF3A08(ctx, base);
	// 828E2968: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828E296C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E2970: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E2974: 4802B5B5  bl 0x8290df28
	ctx.lr = 0x828E2978;
	sub_8290DF28(ctx, base);
	// 828E2978: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E297C: 48510AAD  bl 0x82df3428
	ctx.lr = 0x828E2980;
	sub_82DF3428(ctx, base);
	// 828E2980: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E2984: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E2988: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E298C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E2990: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E2994: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E2998(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828E2998 size=12
    let mut pc: u32 = 0x828E2998;
    'dispatch: loop {
        match pc {
            0x828E2998 => {
    //   block [0x828E2998..0x828E29A4)
	// 828E2998: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828E299C: 386B9488  addi r3, r11, -0x6b78
	ctx.r[3].s64 = ctx.r[11].s64 + -27512;
	// 828E29A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E29A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828E29A8 size=24
    let mut pc: u32 = 0x828E29A8;
    'dispatch: loop {
        match pc {
            0x828E29A8 => {
    //   block [0x828E29A8..0x828E29C0)
	// 828E29A8: 814303E8  lwz r10, 0x3e8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1000 as u32) ) } as u64;
	// 828E29AC: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828E29B0: 396B9560  addi r11, r11, -0x6aa0
	ctx.r[11].s64 = ctx.r[11].s64 + -27296;
	// 828E29B4: 1D4A021C  mulli r10, r10, 0x21c
	ctx.r[10].s64 = ctx.r[10].s64 * 540;
	// 828E29B8: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828E29BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E29C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E29C0 size=116
    let mut pc: u32 = 0x828E29C0;
    'dispatch: loop {
        match pc {
            0x828E29C0 => {
    //   block [0x828E29C0..0x828E2A34)
	// 828E29C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E29C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E29C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E29CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E29D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E29D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E29D8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828E29DC: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 828E29E0: 409A000C  bne cr6, 0x828e29ec
	if !ctx.cr[6].eq {
	pc = 0x828E29EC; continue 'dispatch;
	}
	// 828E29E4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E29E8: 48000030  b 0x828e2a18
	pc = 0x828E2A18; continue 'dispatch;
	// 828E29EC: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 828E29F0: 419A0024  beq cr6, 0x828e2a14
	if ctx.cr[6].eq {
	pc = 0x828E2A14; continue 'dispatch;
	}
	// 828E29F4: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828E29F8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E29FC: 388B8B98  addi r4, r11, -0x7468
	ctx.r[4].s64 = ctx.r[11].s64 + -29800;
	// 828E2A00: 488C56F9  bl 0x831a80f8
	ctx.lr = 0x828E2A04;
	sub_831A80F8(ctx, base);
	// 828E2A04: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E2A08: 4182000C  beq 0x828e2a14
	if ctx.cr[0].eq {
	pc = 0x828E2A14; continue 'dispatch;
	}
	// 828E2A0C: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828E2A10: 4800000C  b 0x828e2a1c
	pc = 0x828E2A1C; continue 'dispatch;
	// 828E2A14: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E2A18: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E2A1C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E2A20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E2A24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E2A28: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E2A2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E2A30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E2A38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E2A38 size=136
    let mut pc: u32 = 0x828E2A38;
    'dispatch: loop {
        match pc {
            0x828E2A38 => {
    //   block [0x828E2A38..0x828E2AC0)
	// 828E2A38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E2A3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E2A40: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E2A44: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E2A48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E2A4C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E2A50: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828E2A54: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 828E2A58: 409A0020  bne cr6, 0x828e2a78
	if !ctx.cr[6].eq {
	pc = 0x828E2A78; continue 'dispatch;
	}
	// 828E2A5C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828E2A60: 419A0048  beq cr6, 0x828e2aa8
	if ctx.cr[6].eq {
	pc = 0x828E2AA8; continue 'dispatch;
	}
	// 828E2A64: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 828E2A68: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 828E2A6C: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 828E2A70: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 828E2A74: 48000034  b 0x828e2aa8
	pc = 0x828E2AA8; continue 'dispatch;
	// 828E2A78: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 828E2A7C: 419A002C  beq cr6, 0x828e2aa8
	if ctx.cr[6].eq {
	pc = 0x828E2AA8; continue 'dispatch;
	}
	// 828E2A80: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828E2A84: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E2A88: 388B8BE8  addi r4, r11, -0x7418
	ctx.r[4].s64 = ctx.r[11].s64 + -29720;
	// 828E2A8C: 488C566D  bl 0x831a80f8
	ctx.lr = 0x828E2A90;
	sub_831A80F8(ctx, base);
	// 828E2A90: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E2A94: 4182000C  beq 0x828e2aa0
	if ctx.cr[0].eq {
	pc = 0x828E2AA0; continue 'dispatch;
	}
	// 828E2A98: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828E2A9C: 4800000C  b 0x828e2aa8
	pc = 0x828E2AA8; continue 'dispatch;
	// 828E2AA0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E2AA4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E2AA8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E2AAC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E2AB0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E2AB4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E2AB8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E2ABC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E2AC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E2AC0 size=136
    let mut pc: u32 = 0x828E2AC0;
    'dispatch: loop {
        match pc {
            0x828E2AC0 => {
    //   block [0x828E2AC0..0x828E2B48)
	// 828E2AC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E2AC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E2AC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E2ACC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E2AD0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E2AD4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E2AD8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828E2ADC: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 828E2AE0: 409A0020  bne cr6, 0x828e2b00
	if !ctx.cr[6].eq {
	pc = 0x828E2B00; continue 'dispatch;
	}
	// 828E2AE4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828E2AE8: 419A0048  beq cr6, 0x828e2b30
	if ctx.cr[6].eq {
	pc = 0x828E2B30; continue 'dispatch;
	}
	// 828E2AEC: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 828E2AF0: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 828E2AF4: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 828E2AF8: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 828E2AFC: 48000034  b 0x828e2b30
	pc = 0x828E2B30; continue 'dispatch;
	// 828E2B00: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 828E2B04: 419A002C  beq cr6, 0x828e2b30
	if ctx.cr[6].eq {
	pc = 0x828E2B30; continue 'dispatch;
	}
	// 828E2B08: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828E2B0C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E2B10: 388B8C88  addi r4, r11, -0x7378
	ctx.r[4].s64 = ctx.r[11].s64 + -29560;
	// 828E2B14: 488C55E5  bl 0x831a80f8
	ctx.lr = 0x828E2B18;
	sub_831A80F8(ctx, base);
	// 828E2B18: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E2B1C: 4182000C  beq 0x828e2b28
	if ctx.cr[0].eq {
	pc = 0x828E2B28; continue 'dispatch;
	}
	// 828E2B20: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828E2B24: 4800000C  b 0x828e2b30
	pc = 0x828E2B30; continue 'dispatch;
	// 828E2B28: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E2B2C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E2B30: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E2B34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E2B38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E2B3C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E2B40: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E2B44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E2B48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E2B48 size=136
    let mut pc: u32 = 0x828E2B48;
    'dispatch: loop {
        match pc {
            0x828E2B48 => {
    //   block [0x828E2B48..0x828E2BD0)
	// 828E2B48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E2B4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E2B50: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E2B54: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E2B58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E2B5C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E2B60: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828E2B64: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 828E2B68: 409A0020  bne cr6, 0x828e2b88
	if !ctx.cr[6].eq {
	pc = 0x828E2B88; continue 'dispatch;
	}
	// 828E2B6C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828E2B70: 419A0048  beq cr6, 0x828e2bb8
	if ctx.cr[6].eq {
	pc = 0x828E2BB8; continue 'dispatch;
	}
	// 828E2B74: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 828E2B78: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 828E2B7C: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 828E2B80: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 828E2B84: 48000034  b 0x828e2bb8
	pc = 0x828E2BB8; continue 'dispatch;
	// 828E2B88: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 828E2B8C: 419A002C  beq cr6, 0x828e2bb8
	if ctx.cr[6].eq {
	pc = 0x828E2BB8; continue 'dispatch;
	}
	// 828E2B90: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828E2B94: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E2B98: 388B8D60  addi r4, r11, -0x72a0
	ctx.r[4].s64 = ctx.r[11].s64 + -29344;
	// 828E2B9C: 488C555D  bl 0x831a80f8
	ctx.lr = 0x828E2BA0;
	sub_831A80F8(ctx, base);
	// 828E2BA0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E2BA4: 4182000C  beq 0x828e2bb0
	if ctx.cr[0].eq {
	pc = 0x828E2BB0; continue 'dispatch;
	}
	// 828E2BA8: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828E2BAC: 4800000C  b 0x828e2bb8
	pc = 0x828E2BB8; continue 'dispatch;
	// 828E2BB0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E2BB4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E2BB8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E2BBC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E2BC0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E2BC4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E2BC8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E2BCC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E2BD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E2BD0 size=136
    let mut pc: u32 = 0x828E2BD0;
    'dispatch: loop {
        match pc {
            0x828E2BD0 => {
    //   block [0x828E2BD0..0x828E2C58)
	// 828E2BD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E2BD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E2BD8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E2BDC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E2BE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E2BE4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E2BE8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828E2BEC: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 828E2BF0: 409A0020  bne cr6, 0x828e2c10
	if !ctx.cr[6].eq {
	pc = 0x828E2C10; continue 'dispatch;
	}
	// 828E2BF4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828E2BF8: 419A0048  beq cr6, 0x828e2c40
	if ctx.cr[6].eq {
	pc = 0x828E2C40; continue 'dispatch;
	}
	// 828E2BFC: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 828E2C00: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 828E2C04: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 828E2C08: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 828E2C0C: 48000034  b 0x828e2c40
	pc = 0x828E2C40; continue 'dispatch;
	// 828E2C10: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 828E2C14: 419A002C  beq cr6, 0x828e2c40
	if ctx.cr[6].eq {
	pc = 0x828E2C40; continue 'dispatch;
	}
	// 828E2C18: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828E2C1C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E2C20: 388B8E10  addi r4, r11, -0x71f0
	ctx.r[4].s64 = ctx.r[11].s64 + -29168;
	// 828E2C24: 488C54D5  bl 0x831a80f8
	ctx.lr = 0x828E2C28;
	sub_831A80F8(ctx, base);
	// 828E2C28: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E2C2C: 4182000C  beq 0x828e2c38
	if ctx.cr[0].eq {
	pc = 0x828E2C38; continue 'dispatch;
	}
	// 828E2C30: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828E2C34: 4800000C  b 0x828e2c40
	pc = 0x828E2C40; continue 'dispatch;
	// 828E2C38: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E2C3C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E2C40: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E2C44: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E2C48: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E2C4C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E2C50: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E2C54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E2C58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E2C58 size=144
    let mut pc: u32 = 0x828E2C58;
    'dispatch: loop {
        match pc {
            0x828E2C58 => {
    //   block [0x828E2C58..0x828E2CE8)
	// 828E2C58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E2C5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E2C60: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E2C64: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E2C68: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E2C6C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E2C70: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828E2C74: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 828E2C78: 409A0028  bne cr6, 0x828e2ca0
	if !ctx.cr[6].eq {
	pc = 0x828E2CA0; continue 'dispatch;
	}
	// 828E2C7C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828E2C80: 419A0050  beq cr6, 0x828e2cd0
	if ctx.cr[6].eq {
	pc = 0x828E2CD0; continue 'dispatch;
	}
	// 828E2C84: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 828E2C88: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 828E2C8C: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 828E2C90: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 828E2C94: E97E0010  ld r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	// 828E2C98: F97F0010  std r11, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 828E2C9C: 48000034  b 0x828e2cd0
	pc = 0x828E2CD0; continue 'dispatch;
	// 828E2CA0: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 828E2CA4: 419A002C  beq cr6, 0x828e2cd0
	if ctx.cr[6].eq {
	pc = 0x828E2CD0; continue 'dispatch;
	}
	// 828E2CA8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828E2CAC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E2CB0: 388B8EC0  addi r4, r11, -0x7140
	ctx.r[4].s64 = ctx.r[11].s64 + -28992;
	// 828E2CB4: 488C5445  bl 0x831a80f8
	ctx.lr = 0x828E2CB8;
	sub_831A80F8(ctx, base);
	// 828E2CB8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E2CBC: 4182000C  beq 0x828e2cc8
	if ctx.cr[0].eq {
	pc = 0x828E2CC8; continue 'dispatch;
	}
	// 828E2CC0: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828E2CC4: 4800000C  b 0x828e2cd0
	pc = 0x828E2CD0; continue 'dispatch;
	// 828E2CC8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E2CCC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E2CD0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E2CD4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E2CD8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E2CDC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E2CE0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E2CE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E2CE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E2CE8 size=136
    let mut pc: u32 = 0x828E2CE8;
    'dispatch: loop {
        match pc {
            0x828E2CE8 => {
    //   block [0x828E2CE8..0x828E2D70)
	// 828E2CE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E2CEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E2CF0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E2CF4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E2CF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E2CFC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E2D00: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828E2D04: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 828E2D08: 409A0020  bne cr6, 0x828e2d28
	if !ctx.cr[6].eq {
	pc = 0x828E2D28; continue 'dispatch;
	}
	// 828E2D0C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828E2D10: 419A0048  beq cr6, 0x828e2d58
	if ctx.cr[6].eq {
	pc = 0x828E2D58; continue 'dispatch;
	}
	// 828E2D14: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 828E2D18: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 828E2D1C: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 828E2D20: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 828E2D24: 48000034  b 0x828e2d58
	pc = 0x828E2D58; continue 'dispatch;
	// 828E2D28: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 828E2D2C: 419A002C  beq cr6, 0x828e2d58
	if ctx.cr[6].eq {
	pc = 0x828E2D58; continue 'dispatch;
	}
	// 828E2D30: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828E2D34: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E2D38: 388B8F80  addi r4, r11, -0x7080
	ctx.r[4].s64 = ctx.r[11].s64 + -28800;
	// 828E2D3C: 488C53BD  bl 0x831a80f8
	ctx.lr = 0x828E2D40;
	sub_831A80F8(ctx, base);
	// 828E2D40: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E2D44: 4182000C  beq 0x828e2d50
	if ctx.cr[0].eq {
	pc = 0x828E2D50; continue 'dispatch;
	}
	// 828E2D48: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828E2D4C: 4800000C  b 0x828e2d58
	pc = 0x828E2D58; continue 'dispatch;
	// 828E2D50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E2D54: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E2D58: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E2D5C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E2D60: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E2D64: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E2D68: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E2D6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E2D70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828E2D70 size=16
    let mut pc: u32 = 0x828E2D70;
    'dispatch: loop {
        match pc {
            0x828E2D70 => {
    //   block [0x828E2D70..0x828E2D80)
	// 828E2D70: 81830000  lwz r12, 0(r3)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E2D74: 816C01BC  lwz r11, 0x1bc(r12)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[12].u32.wrapping_add(444 as u32) ) } as u64;
	// 828E2D78: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E2D7C: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E2D80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828E2D80 size=16
    let mut pc: u32 = 0x828E2D80;
    'dispatch: loop {
        match pc {
            0x828E2D80 => {
    //   block [0x828E2D80..0x828E2D90)
	// 828E2D80: 81830000  lwz r12, 0(r3)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E2D84: 816C01C0  lwz r11, 0x1c0(r12)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[12].u32.wrapping_add(448 as u32) ) } as u64;
	// 828E2D88: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E2D8C: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E2D90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828E2D90 size=16
    let mut pc: u32 = 0x828E2D90;
    'dispatch: loop {
        match pc {
            0x828E2D90 => {
    //   block [0x828E2D90..0x828E2DA0)
	// 828E2D90: 81830000  lwz r12, 0(r3)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E2D94: 816C01C4  lwz r11, 0x1c4(r12)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[12].u32.wrapping_add(452 as u32) ) } as u64;
	// 828E2D98: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E2D9C: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E2DA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828E2DA0 size=16
    let mut pc: u32 = 0x828E2DA0;
    'dispatch: loop {
        match pc {
            0x828E2DA0 => {
    //   block [0x828E2DA0..0x828E2DB0)
	// 828E2DA0: 81830000  lwz r12, 0(r3)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E2DA4: 816C01B8  lwz r11, 0x1b8(r12)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[12].u32.wrapping_add(440 as u32) ) } as u64;
	// 828E2DA8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E2DAC: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E2DB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E2DB0 size=100
    let mut pc: u32 = 0x828E2DB0;
    'dispatch: loop {
        match pc {
            0x828E2DB0 => {
    //   block [0x828E2DB0..0x828E2E14)
	// 828E2DB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E2DB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E2DB8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E2DBC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E2DC0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E2DC4: 807F03D4  lwz r3, 0x3d4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(980 as u32) ) } as u64;
	// 828E2DC8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E2DCC: 419A0034  beq cr6, 0x828e2e00
	if ctx.cr[6].eq {
	pc = 0x828E2E00; continue 'dispatch;
	}
	// 828E2DD0: 548B063F  clrlwi. r11, r4, 0x18
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E2DD4: 41820018  beq 0x828e2dec
	if ctx.cr[0].eq {
	pc = 0x828E2DEC; continue 'dispatch;
	}
	// 828E2DD8: 4BEE79C1  bl 0x827ca798
	ctx.lr = 0x828E2DDC;
	sub_827CA798(ctx, base);
	// 828E2DDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E2DE0: 809F03F0  lwz r4, 0x3f0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1008 as u32) ) } as u64;
	// 828E2DE4: 4BF09495  bl 0x827ec278
	ctx.lr = 0x828E2DE8;
	sub_827EC278(ctx, base);
	// 828E2DE8: 48000018  b 0x828e2e00
	pc = 0x828E2E00; continue 'dispatch;
	// 828E2DEC: 4BEE7A4D  bl 0x827ca838
	ctx.lr = 0x828E2DF0;
	sub_827CA838(ctx, base);
	// 828E2DF0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828E2DF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E2DF8: 809F03F0  lwz r4, 0x3f0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1008 as u32) ) } as u64;
	// 828E2DFC: 4BF0946D  bl 0x827ec268
	ctx.lr = 0x828E2E00;
	sub_827EC268(ctx, base);
	// 828E2E00: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828E2E04: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E2E08: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E2E0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E2E10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E2E18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E2E18 size=196
    let mut pc: u32 = 0x828E2E18;
    'dispatch: loop {
        match pc {
            0x828E2E18 => {
    //   block [0x828E2E18..0x828E2EDC)
	// 828E2E18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E2E1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E2E20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E2E24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E2E28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E2E2C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E2E30: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E2E34: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828E2E38: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828E2E3C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E2E40: 4B9DDAF9  bl 0x822c0938
	ctx.lr = 0x828E2E44;
	sub_822C0938(ctx, base);
	// 828E2E44: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828E2E48: 41820028  beq 0x828e2e70
	if ctx.cr[0].eq {
	pc = 0x828E2E70; continue 'dispatch;
	}
	// 828E2E4C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E2E50: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828E2E54: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E2E58: 392B0CD4  addi r9, r11, 0xcd4
	ctx.r[9].s64 = ctx.r[11].s64 + 3284;
	// 828E2E5C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828E2E60: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828E2E64: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828E2E68: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828E2E6C: 48000008  b 0x828e2e74
	pc = 0x828E2E74; continue 'dispatch;
	// 828E2E70: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E2E74: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E2E78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E2E7C: 409A0044  bne cr6, 0x828e2ec0
	if !ctx.cr[6].eq {
	pc = 0x828E2EC0; continue 'dispatch;
	}
	// 828E2E80: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828E2E84: 419A001C  beq cr6, 0x828e2ea0
	if ctx.cr[6].eq {
	pc = 0x828E2EA0; continue 'dispatch;
	}
	// 828E2E88: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E2E8C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828E2E90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E2E94: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E2E98: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E2E9C: 4E800421  bctrl
	ctx.lr = 0x828E2EA0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E2EA0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828E2EA4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828E2EA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E2EAC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828E2EB0: 816B8694  lwz r11, -0x796c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-31084 as u32) ) } as u64;
	// 828E2EB4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828E2EB8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828E2EBC: 4B9DD145  bl 0x822c0000
	ctx.lr = 0x828E2EC0;
	sub_822C0000(ctx, base);
	// 828E2EC0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E2EC4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E2EC8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E2ECC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E2ED0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E2ED4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E2ED8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E2EE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E2EE0 size=196
    let mut pc: u32 = 0x828E2EE0;
    'dispatch: loop {
        match pc {
            0x828E2EE0 => {
    //   block [0x828E2EE0..0x828E2FA4)
	// 828E2EE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E2EE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E2EE8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E2EEC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E2EF0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E2EF4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E2EF8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E2EFC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828E2F00: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828E2F04: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E2F08: 4B9DDA31  bl 0x822c0938
	ctx.lr = 0x828E2F0C;
	sub_822C0938(ctx, base);
	// 828E2F0C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828E2F10: 41820028  beq 0x828e2f38
	if ctx.cr[0].eq {
	pc = 0x828E2F38; continue 'dispatch;
	}
	// 828E2F14: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E2F18: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828E2F1C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E2F20: 392B0CE8  addi r9, r11, 0xce8
	ctx.r[9].s64 = ctx.r[11].s64 + 3304;
	// 828E2F24: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828E2F28: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828E2F2C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828E2F30: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828E2F34: 48000008  b 0x828e2f3c
	pc = 0x828E2F3C; continue 'dispatch;
	// 828E2F38: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E2F3C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E2F40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E2F44: 409A0044  bne cr6, 0x828e2f88
	if !ctx.cr[6].eq {
	pc = 0x828E2F88; continue 'dispatch;
	}
	// 828E2F48: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828E2F4C: 419A001C  beq cr6, 0x828e2f68
	if ctx.cr[6].eq {
	pc = 0x828E2F68; continue 'dispatch;
	}
	// 828E2F50: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E2F54: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828E2F58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E2F5C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E2F60: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E2F64: 4E800421  bctrl
	ctx.lr = 0x828E2F68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E2F68: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828E2F6C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828E2F70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E2F74: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828E2F78: 816B8694  lwz r11, -0x796c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-31084 as u32) ) } as u64;
	// 828E2F7C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828E2F80: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828E2F84: 4B9DD07D  bl 0x822c0000
	ctx.lr = 0x828E2F88;
	sub_822C0000(ctx, base);
	// 828E2F88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E2F8C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E2F90: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E2F94: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E2F98: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E2F9C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E2FA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E2FA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E2FA8 size=196
    let mut pc: u32 = 0x828E2FA8;
    'dispatch: loop {
        match pc {
            0x828E2FA8 => {
    //   block [0x828E2FA8..0x828E306C)
	// 828E2FA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E2FAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E2FB0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E2FB4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E2FB8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E2FBC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E2FC0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E2FC4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828E2FC8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828E2FCC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E2FD0: 4B9DD969  bl 0x822c0938
	ctx.lr = 0x828E2FD4;
	sub_822C0938(ctx, base);
	// 828E2FD4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828E2FD8: 41820028  beq 0x828e3000
	if ctx.cr[0].eq {
	pc = 0x828E3000; continue 'dispatch;
	}
	// 828E2FDC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E2FE0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828E2FE4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E2FE8: 392B0CFC  addi r9, r11, 0xcfc
	ctx.r[9].s64 = ctx.r[11].s64 + 3324;
	// 828E2FEC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828E2FF0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828E2FF4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828E2FF8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828E2FFC: 48000008  b 0x828e3004
	pc = 0x828E3004; continue 'dispatch;
	// 828E3000: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E3004: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E3008: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E300C: 409A0044  bne cr6, 0x828e3050
	if !ctx.cr[6].eq {
	pc = 0x828E3050; continue 'dispatch;
	}
	// 828E3010: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828E3014: 419A001C  beq cr6, 0x828e3030
	if ctx.cr[6].eq {
	pc = 0x828E3030; continue 'dispatch;
	}
	// 828E3018: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E301C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828E3020: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E3024: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E3028: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E302C: 4E800421  bctrl
	ctx.lr = 0x828E3030;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E3030: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828E3034: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828E3038: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E303C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828E3040: 816B8694  lwz r11, -0x796c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-31084 as u32) ) } as u64;
	// 828E3044: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828E3048: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828E304C: 4B9DCFB5  bl 0x822c0000
	ctx.lr = 0x828E3050;
	sub_822C0000(ctx, base);
	// 828E3050: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E3054: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E3058: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E305C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E3060: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E3064: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E3068: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E3070(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E3070 size=196
    let mut pc: u32 = 0x828E3070;
    'dispatch: loop {
        match pc {
            0x828E3070 => {
    //   block [0x828E3070..0x828E3134)
	// 828E3070: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E3074: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E3078: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E307C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E3080: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E3084: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E3088: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E308C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828E3090: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828E3094: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E3098: 4B9DD8A1  bl 0x822c0938
	ctx.lr = 0x828E309C;
	sub_822C0938(ctx, base);
	// 828E309C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828E30A0: 41820028  beq 0x828e30c8
	if ctx.cr[0].eq {
	pc = 0x828E30C8; continue 'dispatch;
	}
	// 828E30A4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E30A8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828E30AC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E30B0: 392B0D10  addi r9, r11, 0xd10
	ctx.r[9].s64 = ctx.r[11].s64 + 3344;
	// 828E30B4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828E30B8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828E30BC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828E30C0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828E30C4: 48000008  b 0x828e30cc
	pc = 0x828E30CC; continue 'dispatch;
	// 828E30C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E30CC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E30D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E30D4: 409A0044  bne cr6, 0x828e3118
	if !ctx.cr[6].eq {
	pc = 0x828E3118; continue 'dispatch;
	}
	// 828E30D8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828E30DC: 419A001C  beq cr6, 0x828e30f8
	if ctx.cr[6].eq {
	pc = 0x828E30F8; continue 'dispatch;
	}
	// 828E30E0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E30E4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828E30E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E30EC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E30F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E30F4: 4E800421  bctrl
	ctx.lr = 0x828E30F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E30F8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828E30FC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828E3100: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E3104: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828E3108: 816B8694  lwz r11, -0x796c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-31084 as u32) ) } as u64;
	// 828E310C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828E3110: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828E3114: 4B9DCEED  bl 0x822c0000
	ctx.lr = 0x828E3118;
	sub_822C0000(ctx, base);
	// 828E3118: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E311C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E3120: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E3124: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E3128: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E312C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E3130: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E3138(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E3138 size=196
    let mut pc: u32 = 0x828E3138;
    'dispatch: loop {
        match pc {
            0x828E3138 => {
    //   block [0x828E3138..0x828E31FC)
	// 828E3138: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E313C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E3140: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E3144: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E3148: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E314C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E3150: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E3154: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828E3158: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828E315C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E3160: 4B9DD7D9  bl 0x822c0938
	ctx.lr = 0x828E3164;
	sub_822C0938(ctx, base);
	// 828E3164: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828E3168: 41820028  beq 0x828e3190
	if ctx.cr[0].eq {
	pc = 0x828E3190; continue 'dispatch;
	}
	// 828E316C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E3170: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828E3174: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E3178: 392B0D24  addi r9, r11, 0xd24
	ctx.r[9].s64 = ctx.r[11].s64 + 3364;
	// 828E317C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828E3180: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828E3184: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828E3188: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828E318C: 48000008  b 0x828e3194
	pc = 0x828E3194; continue 'dispatch;
	// 828E3190: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E3194: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E3198: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E319C: 409A0044  bne cr6, 0x828e31e0
	if !ctx.cr[6].eq {
	pc = 0x828E31E0; continue 'dispatch;
	}
	// 828E31A0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828E31A4: 419A001C  beq cr6, 0x828e31c0
	if ctx.cr[6].eq {
	pc = 0x828E31C0; continue 'dispatch;
	}
	// 828E31A8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E31AC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828E31B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E31B4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E31B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E31BC: 4E800421  bctrl
	ctx.lr = 0x828E31C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E31C0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828E31C4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828E31C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E31CC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828E31D0: 816B8694  lwz r11, -0x796c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-31084 as u32) ) } as u64;
	// 828E31D4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828E31D8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828E31DC: 4B9DCE25  bl 0x822c0000
	ctx.lr = 0x828E31E0;
	sub_822C0000(ctx, base);
	// 828E31E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E31E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E31E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E31EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E31F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E31F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E31F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E3200(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E3200 size=196
    let mut pc: u32 = 0x828E3200;
    'dispatch: loop {
        match pc {
            0x828E3200 => {
    //   block [0x828E3200..0x828E32C4)
	// 828E3200: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E3204: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E3208: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E320C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E3210: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E3214: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E3218: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E321C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828E3220: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828E3224: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E3228: 4B9DD711  bl 0x822c0938
	ctx.lr = 0x828E322C;
	sub_822C0938(ctx, base);
	// 828E322C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828E3230: 41820028  beq 0x828e3258
	if ctx.cr[0].eq {
	pc = 0x828E3258; continue 'dispatch;
	}
	// 828E3234: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E3238: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828E323C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E3240: 392B0D38  addi r9, r11, 0xd38
	ctx.r[9].s64 = ctx.r[11].s64 + 3384;
	// 828E3244: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828E3248: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828E324C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828E3250: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828E3254: 48000008  b 0x828e325c
	pc = 0x828E325C; continue 'dispatch;
	// 828E3258: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E325C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E3260: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E3264: 409A0044  bne cr6, 0x828e32a8
	if !ctx.cr[6].eq {
	pc = 0x828E32A8; continue 'dispatch;
	}
	// 828E3268: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828E326C: 419A001C  beq cr6, 0x828e3288
	if ctx.cr[6].eq {
	pc = 0x828E3288; continue 'dispatch;
	}
	// 828E3270: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E3274: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828E3278: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E327C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E3280: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E3284: 4E800421  bctrl
	ctx.lr = 0x828E3288;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E3288: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828E328C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828E3290: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E3294: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828E3298: 816B8694  lwz r11, -0x796c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-31084 as u32) ) } as u64;
	// 828E329C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828E32A0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828E32A4: 4B9DCD5D  bl 0x822c0000
	ctx.lr = 0x828E32A8;
	sub_822C0000(ctx, base);
	// 828E32A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E32AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E32B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E32B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E32B8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E32BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E32C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E32C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E32C8 size=196
    let mut pc: u32 = 0x828E32C8;
    'dispatch: loop {
        match pc {
            0x828E32C8 => {
    //   block [0x828E32C8..0x828E338C)
	// 828E32C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E32CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E32D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E32D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E32D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E32DC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E32E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E32E4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828E32E8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828E32EC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E32F0: 4B9DD649  bl 0x822c0938
	ctx.lr = 0x828E32F4;
	sub_822C0938(ctx, base);
	// 828E32F4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828E32F8: 41820028  beq 0x828e3320
	if ctx.cr[0].eq {
	pc = 0x828E3320; continue 'dispatch;
	}
	// 828E32FC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E3300: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828E3304: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E3308: 392B0D4C  addi r9, r11, 0xd4c
	ctx.r[9].s64 = ctx.r[11].s64 + 3404;
	// 828E330C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828E3310: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828E3314: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828E3318: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828E331C: 48000008  b 0x828e3324
	pc = 0x828E3324; continue 'dispatch;
	// 828E3320: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E3324: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E3328: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E332C: 409A0044  bne cr6, 0x828e3370
	if !ctx.cr[6].eq {
	pc = 0x828E3370; continue 'dispatch;
	}
	// 828E3330: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828E3334: 419A001C  beq cr6, 0x828e3350
	if ctx.cr[6].eq {
	pc = 0x828E3350; continue 'dispatch;
	}
	// 828E3338: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E333C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828E3340: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E3344: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E3348: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E334C: 4E800421  bctrl
	ctx.lr = 0x828E3350;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E3350: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828E3354: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828E3358: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E335C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828E3360: 816B8694  lwz r11, -0x796c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-31084 as u32) ) } as u64;
	// 828E3364: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828E3368: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828E336C: 4B9DCC95  bl 0x822c0000
	ctx.lr = 0x828E3370;
	sub_822C0000(ctx, base);
	// 828E3370: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E3374: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E3378: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E337C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E3380: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E3384: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E3388: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E3390(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E3390 size=196
    let mut pc: u32 = 0x828E3390;
    'dispatch: loop {
        match pc {
            0x828E3390 => {
    //   block [0x828E3390..0x828E3454)
	// 828E3390: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E3394: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E3398: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E339C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E33A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E33A4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E33A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E33AC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828E33B0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828E33B4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E33B8: 4B9DD581  bl 0x822c0938
	ctx.lr = 0x828E33BC;
	sub_822C0938(ctx, base);
	// 828E33BC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828E33C0: 41820028  beq 0x828e33e8
	if ctx.cr[0].eq {
	pc = 0x828E33E8; continue 'dispatch;
	}
	// 828E33C4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E33C8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828E33CC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E33D0: 392B0D60  addi r9, r11, 0xd60
	ctx.r[9].s64 = ctx.r[11].s64 + 3424;
	// 828E33D4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828E33D8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828E33DC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828E33E0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828E33E4: 48000008  b 0x828e33ec
	pc = 0x828E33EC; continue 'dispatch;
	// 828E33E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E33EC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E33F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E33F4: 409A0044  bne cr6, 0x828e3438
	if !ctx.cr[6].eq {
	pc = 0x828E3438; continue 'dispatch;
	}
	// 828E33F8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828E33FC: 419A001C  beq cr6, 0x828e3418
	if ctx.cr[6].eq {
	pc = 0x828E3418; continue 'dispatch;
	}
	// 828E3400: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E3404: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828E3408: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E340C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E3410: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E3414: 4E800421  bctrl
	ctx.lr = 0x828E3418;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E3418: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828E341C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828E3420: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E3424: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828E3428: 816B8694  lwz r11, -0x796c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-31084 as u32) ) } as u64;
	// 828E342C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828E3430: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828E3434: 4B9DCBCD  bl 0x822c0000
	ctx.lr = 0x828E3438;
	sub_822C0000(ctx, base);
	// 828E3438: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E343C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E3440: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E3444: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E3448: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E344C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E3450: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E3458(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E3458 size=196
    let mut pc: u32 = 0x828E3458;
    'dispatch: loop {
        match pc {
            0x828E3458 => {
    //   block [0x828E3458..0x828E351C)
	// 828E3458: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E345C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E3460: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E3464: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E3468: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E346C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E3470: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E3474: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828E3478: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828E347C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E3480: 4B9DD4B9  bl 0x822c0938
	ctx.lr = 0x828E3484;
	sub_822C0938(ctx, base);
	// 828E3484: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828E3488: 41820028  beq 0x828e34b0
	if ctx.cr[0].eq {
	pc = 0x828E34B0; continue 'dispatch;
	}
	// 828E348C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E3490: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828E3494: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E3498: 392B0D74  addi r9, r11, 0xd74
	ctx.r[9].s64 = ctx.r[11].s64 + 3444;
	// 828E349C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828E34A0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828E34A4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828E34A8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828E34AC: 48000008  b 0x828e34b4
	pc = 0x828E34B4; continue 'dispatch;
	// 828E34B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E34B4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E34B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E34BC: 409A0044  bne cr6, 0x828e3500
	if !ctx.cr[6].eq {
	pc = 0x828E3500; continue 'dispatch;
	}
	// 828E34C0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828E34C4: 419A001C  beq cr6, 0x828e34e0
	if ctx.cr[6].eq {
	pc = 0x828E34E0; continue 'dispatch;
	}
	// 828E34C8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E34CC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828E34D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E34D4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E34D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E34DC: 4E800421  bctrl
	ctx.lr = 0x828E34E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E34E0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828E34E4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828E34E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E34EC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828E34F0: 816B8694  lwz r11, -0x796c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-31084 as u32) ) } as u64;
	// 828E34F4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828E34F8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828E34FC: 4B9DCB05  bl 0x822c0000
	ctx.lr = 0x828E3500;
	sub_822C0000(ctx, base);
	// 828E3500: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E3504: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E3508: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E350C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E3510: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E3514: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E3518: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E3520(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E3520 size=196
    let mut pc: u32 = 0x828E3520;
    'dispatch: loop {
        match pc {
            0x828E3520 => {
    //   block [0x828E3520..0x828E35E4)
	// 828E3520: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E3524: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E3528: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E352C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E3530: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E3534: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E3538: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E353C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828E3540: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828E3544: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E3548: 4B9DD3F1  bl 0x822c0938
	ctx.lr = 0x828E354C;
	sub_822C0938(ctx, base);
	// 828E354C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828E3550: 41820028  beq 0x828e3578
	if ctx.cr[0].eq {
	pc = 0x828E3578; continue 'dispatch;
	}
	// 828E3554: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E3558: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828E355C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E3560: 392B0D88  addi r9, r11, 0xd88
	ctx.r[9].s64 = ctx.r[11].s64 + 3464;
	// 828E3564: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828E3568: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828E356C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828E3570: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828E3574: 48000008  b 0x828e357c
	pc = 0x828E357C; continue 'dispatch;
	// 828E3578: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E357C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E3580: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E3584: 409A0044  bne cr6, 0x828e35c8
	if !ctx.cr[6].eq {
	pc = 0x828E35C8; continue 'dispatch;
	}
	// 828E3588: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828E358C: 419A001C  beq cr6, 0x828e35a8
	if ctx.cr[6].eq {
	pc = 0x828E35A8; continue 'dispatch;
	}
	// 828E3590: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E3594: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828E3598: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E359C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E35A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E35A4: 4E800421  bctrl
	ctx.lr = 0x828E35A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E35A8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828E35AC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828E35B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E35B4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828E35B8: 816B8694  lwz r11, -0x796c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-31084 as u32) ) } as u64;
	// 828E35BC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828E35C0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828E35C4: 4B9DCA3D  bl 0x822c0000
	ctx.lr = 0x828E35C8;
	sub_822C0000(ctx, base);
	// 828E35C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E35CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E35D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E35D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E35D8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E35DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E35E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E35E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E35E8 size=196
    let mut pc: u32 = 0x828E35E8;
    'dispatch: loop {
        match pc {
            0x828E35E8 => {
    //   block [0x828E35E8..0x828E36AC)
	// 828E35E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E35EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E35F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E35F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E35F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E35FC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E3600: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E3604: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828E3608: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828E360C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E3610: 4B9DD329  bl 0x822c0938
	ctx.lr = 0x828E3614;
	sub_822C0938(ctx, base);
	// 828E3614: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828E3618: 41820028  beq 0x828e3640
	if ctx.cr[0].eq {
	pc = 0x828E3640; continue 'dispatch;
	}
	// 828E361C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E3620: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828E3624: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E3628: 392B0D9C  addi r9, r11, 0xd9c
	ctx.r[9].s64 = ctx.r[11].s64 + 3484;
	// 828E362C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828E3630: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828E3634: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828E3638: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828E363C: 48000008  b 0x828e3644
	pc = 0x828E3644; continue 'dispatch;
	// 828E3640: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E3644: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E3648: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E364C: 409A0044  bne cr6, 0x828e3690
	if !ctx.cr[6].eq {
	pc = 0x828E3690; continue 'dispatch;
	}
	// 828E3650: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828E3654: 419A001C  beq cr6, 0x828e3670
	if ctx.cr[6].eq {
	pc = 0x828E3670; continue 'dispatch;
	}
	// 828E3658: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E365C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828E3660: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E3664: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E3668: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E366C: 4E800421  bctrl
	ctx.lr = 0x828E3670;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E3670: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828E3674: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828E3678: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E367C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828E3680: 816B8694  lwz r11, -0x796c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-31084 as u32) ) } as u64;
	// 828E3684: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828E3688: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828E368C: 4B9DC975  bl 0x822c0000
	ctx.lr = 0x828E3690;
	sub_822C0000(ctx, base);
	// 828E3690: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E3694: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E3698: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E369C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E36A0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E36A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E36A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E36B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E36B0 size=196
    let mut pc: u32 = 0x828E36B0;
    'dispatch: loop {
        match pc {
            0x828E36B0 => {
    //   block [0x828E36B0..0x828E3774)
	// 828E36B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E36B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E36B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E36BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E36C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E36C4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E36C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E36CC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828E36D0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828E36D4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E36D8: 4B9DD261  bl 0x822c0938
	ctx.lr = 0x828E36DC;
	sub_822C0938(ctx, base);
	// 828E36DC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828E36E0: 41820028  beq 0x828e3708
	if ctx.cr[0].eq {
	pc = 0x828E3708; continue 'dispatch;
	}
	// 828E36E4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E36E8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828E36EC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E36F0: 392B0DB0  addi r9, r11, 0xdb0
	ctx.r[9].s64 = ctx.r[11].s64 + 3504;
	// 828E36F4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828E36F8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828E36FC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828E3700: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828E3704: 48000008  b 0x828e370c
	pc = 0x828E370C; continue 'dispatch;
	// 828E3708: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E370C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E3710: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E3714: 409A0044  bne cr6, 0x828e3758
	if !ctx.cr[6].eq {
	pc = 0x828E3758; continue 'dispatch;
	}
	// 828E3718: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828E371C: 419A001C  beq cr6, 0x828e3738
	if ctx.cr[6].eq {
	pc = 0x828E3738; continue 'dispatch;
	}
	// 828E3720: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E3724: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828E3728: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E372C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E3730: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E3734: 4E800421  bctrl
	ctx.lr = 0x828E3738;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E3738: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828E373C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828E3740: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E3744: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828E3748: 816B8694  lwz r11, -0x796c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-31084 as u32) ) } as u64;
	// 828E374C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828E3750: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828E3754: 4B9DC8AD  bl 0x822c0000
	ctx.lr = 0x828E3758;
	sub_822C0000(ctx, base);
	// 828E3758: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E375C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E3760: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E3764: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E3768: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E376C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E3770: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E3778(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E3778 size=196
    let mut pc: u32 = 0x828E3778;
    'dispatch: loop {
        match pc {
            0x828E3778 => {
    //   block [0x828E3778..0x828E383C)
	// 828E3778: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E377C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E3780: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E3784: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E3788: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E378C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E3790: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E3794: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828E3798: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828E379C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E37A0: 4B9DD199  bl 0x822c0938
	ctx.lr = 0x828E37A4;
	sub_822C0938(ctx, base);
	// 828E37A4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828E37A8: 41820028  beq 0x828e37d0
	if ctx.cr[0].eq {
	pc = 0x828E37D0; continue 'dispatch;
	}
	// 828E37AC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E37B0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828E37B4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E37B8: 392B0DC4  addi r9, r11, 0xdc4
	ctx.r[9].s64 = ctx.r[11].s64 + 3524;
	// 828E37BC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828E37C0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828E37C4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828E37C8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828E37CC: 48000008  b 0x828e37d4
	pc = 0x828E37D4; continue 'dispatch;
	// 828E37D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E37D4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E37D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E37DC: 409A0044  bne cr6, 0x828e3820
	if !ctx.cr[6].eq {
	pc = 0x828E3820; continue 'dispatch;
	}
	// 828E37E0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828E37E4: 419A001C  beq cr6, 0x828e3800
	if ctx.cr[6].eq {
	pc = 0x828E3800; continue 'dispatch;
	}
	// 828E37E8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E37EC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828E37F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E37F4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E37F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E37FC: 4E800421  bctrl
	ctx.lr = 0x828E3800;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E3800: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828E3804: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828E3808: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E380C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828E3810: 816B8694  lwz r11, -0x796c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-31084 as u32) ) } as u64;
	// 828E3814: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828E3818: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828E381C: 4B9DC7E5  bl 0x822c0000
	ctx.lr = 0x828E3820;
	sub_822C0000(ctx, base);
	// 828E3820: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E3824: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E3828: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E382C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E3830: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E3834: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E3838: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E3840(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E3840 size=196
    let mut pc: u32 = 0x828E3840;
    'dispatch: loop {
        match pc {
            0x828E3840 => {
    //   block [0x828E3840..0x828E3904)
	// 828E3840: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E3844: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E3848: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E384C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E3850: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E3854: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E3858: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E385C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828E3860: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828E3864: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E3868: 4B9DD0D1  bl 0x822c0938
	ctx.lr = 0x828E386C;
	sub_822C0938(ctx, base);
	// 828E386C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828E3870: 41820028  beq 0x828e3898
	if ctx.cr[0].eq {
	pc = 0x828E3898; continue 'dispatch;
	}
	// 828E3874: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E3878: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828E387C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E3880: 392B0DD8  addi r9, r11, 0xdd8
	ctx.r[9].s64 = ctx.r[11].s64 + 3544;
	// 828E3884: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828E3888: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828E388C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828E3890: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828E3894: 48000008  b 0x828e389c
	pc = 0x828E389C; continue 'dispatch;
	// 828E3898: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E389C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E38A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E38A4: 409A0044  bne cr6, 0x828e38e8
	if !ctx.cr[6].eq {
	pc = 0x828E38E8; continue 'dispatch;
	}
	// 828E38A8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828E38AC: 419A001C  beq cr6, 0x828e38c8
	if ctx.cr[6].eq {
	pc = 0x828E38C8; continue 'dispatch;
	}
	// 828E38B0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E38B4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828E38B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E38BC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E38C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E38C4: 4E800421  bctrl
	ctx.lr = 0x828E38C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E38C8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828E38CC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828E38D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E38D4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828E38D8: 816B8694  lwz r11, -0x796c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-31084 as u32) ) } as u64;
	// 828E38DC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828E38E0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828E38E4: 4B9DC71D  bl 0x822c0000
	ctx.lr = 0x828E38E8;
	sub_822C0000(ctx, base);
	// 828E38E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E38EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E38F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E38F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E38F8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E38FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E3900: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E3908(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E3908 size=196
    let mut pc: u32 = 0x828E3908;
    'dispatch: loop {
        match pc {
            0x828E3908 => {
    //   block [0x828E3908..0x828E39CC)
	// 828E3908: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E390C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E3910: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E3914: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E3918: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E391C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E3920: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E3924: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828E3928: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828E392C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E3930: 4B9DD009  bl 0x822c0938
	ctx.lr = 0x828E3934;
	sub_822C0938(ctx, base);
	// 828E3934: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828E3938: 41820028  beq 0x828e3960
	if ctx.cr[0].eq {
	pc = 0x828E3960; continue 'dispatch;
	}
	// 828E393C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E3940: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828E3944: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828E3948: 392B0DEC  addi r9, r11, 0xdec
	ctx.r[9].s64 = ctx.r[11].s64 + 3564;
	// 828E394C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828E3950: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828E3954: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828E3958: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828E395C: 48000008  b 0x828e3964
	pc = 0x828E3964; continue 'dispatch;
	// 828E3960: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E3964: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E3968: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E396C: 409A0044  bne cr6, 0x828e39b0
	if !ctx.cr[6].eq {
	pc = 0x828E39B0; continue 'dispatch;
	}
	// 828E3970: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828E3974: 419A001C  beq cr6, 0x828e3990
	if ctx.cr[6].eq {
	pc = 0x828E3990; continue 'dispatch;
	}
	// 828E3978: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E397C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828E3980: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E3984: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E3988: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E398C: 4E800421  bctrl
	ctx.lr = 0x828E3990;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E3990: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828E3994: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828E3998: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E399C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828E39A0: 816B8694  lwz r11, -0x796c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-31084 as u32) ) } as u64;
	// 828E39A4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828E39A8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828E39AC: 4B9DC655  bl 0x822c0000
	ctx.lr = 0x828E39B0;
	sub_822C0000(ctx, base);
	// 828E39B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E39B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E39B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E39BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E39C0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E39C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E39C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E39D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E39D0 size=116
    let mut pc: u32 = 0x828E39D0;
    'dispatch: loop {
        match pc {
            0x828E39D0 => {
    //   block [0x828E39D0..0x828E3A44)
	// 828E39D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E39D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E39D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E39DC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E39E0: F8810080  std r4, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[4].u64 ) };
	// 828E39E4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828E39E8: F8A10088  std r5, 0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[5].u64 ) };
	// 828E39EC: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 828E39F0: F8C10090  std r6, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[6].u64 ) };
	// 828E39F4: 4BEEB7E5  bl 0x827cf1d8
	ctx.lr = 0x828E39F8;
	sub_827CF1D8(ctx, base);
	// 828E39F8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E39FC: 40820030  bne 0x828e3a2c
	if !ctx.cr[0].eq {
	pc = 0x828E3A2C; continue 'dispatch;
	}
	// 828E3A00: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828E3A04: 419A0020  beq cr6, 0x828e3a24
	if ctx.cr[6].eq {
	pc = 0x828E3A24; continue 'dispatch;
	}
	// 828E3A08: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 828E3A0C: E94B0000  ld r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 828E3A10: E92B0008  ld r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 828E3A14: E96B0010  ld r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 828E3A18: F95F0000  std r10, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 828E3A1C: F93F0008  std r9, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u64 ) };
	// 828E3A20: F97F0010  std r11, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 828E3A24: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828E3A28: 48000008  b 0x828e3a30
	pc = 0x828E3A30; continue 'dispatch;
	// 828E3A2C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828E3A30: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828E3A34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E3A38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E3A3C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E3A40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E3A48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E3A48 size=72
    let mut pc: u32 = 0x828E3A48;
    'dispatch: loop {
        match pc {
            0x828E3A48 => {
    //   block [0x828E3A48..0x828E3A90)
	// 828E3A48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E3A4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E3A50: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E3A54: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 828E3A58: 419A001C  beq cr6, 0x828e3a74
	if ctx.cr[6].eq {
	pc = 0x828E3A74; continue 'dispatch;
	}
	// 828E3A5C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828E3A60: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828E3A64: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 828E3A68: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828E3A6C: 4BFFEF55  bl 0x828e29c0
	ctx.lr = 0x828E3A70;
	sub_828E29C0(ctx, base);
	// 828E3A70: 48000010  b 0x828e3a80
	pc = 0x828E3A80; continue 'dispatch;
	// 828E3A74: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828E3A78: 396B8B98  addi r11, r11, -0x7468
	ctx.r[11].s64 = ctx.r[11].s64 + -29800;
	// 828E3A7C: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E3A80: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828E3A84: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E3A88: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E3A8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E3A90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E3A90 size=176
    let mut pc: u32 = 0x828E3A90;
    'dispatch: loop {
        match pc {
            0x828E3A90 => {
    //   block [0x828E3A90..0x828E3B40)
	// 828E3A90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E3A94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E3A98: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E3A9C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E3AA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E3AA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E3AA8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828E3AAC: 2F050005  cmpwi cr6, r5, 5
	ctx.cr[6].compare_i32(ctx.r[5].s32, 5, &mut ctx.xer);
	// 828E3AB0: 419A0028  beq cr6, 0x828e3ad8
	if ctx.cr[6].eq {
	pc = 0x828E3AD8; continue 'dispatch;
	}
	// 828E3AB4: 2F050009  cmpwi cr6, r5, 9
	ctx.cr[6].compare_i32(ctx.r[5].s32, 9, &mut ctx.xer);
	// 828E3AB8: 419A0014  beq cr6, 0x828e3acc
	if ctx.cr[6].eq {
	pc = 0x828E3ACC; continue 'dispatch;
	}
	// 828E3ABC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E3AC0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E3AC4: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828E3AC8: 48000060  b 0x828e3b28
	pc = 0x828E3B28; continue 'dispatch;
	// 828E3ACC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E3AD0: 38AB0E24  addi r5, r11, 0xe24
	ctx.r[5].s64 = ctx.r[11].s64 + 3620;
	// 828E3AD4: 48000048  b 0x828e3b1c
	pc = 0x828E3B1C; continue 'dispatch;
	// 828E3AD8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828E3ADC: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E3AE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E3AE4: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828E3AE8: 816A0080  lwz r11, 0x80(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(128 as u32) ) } as u64;
	// 828E3AEC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E3AF0: 4E800421  bctrl
	ctx.lr = 0x828E3AF4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E3AF4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828E3AF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E3AFC: C00B9450  lfs f0, -0x6bb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828E3B00: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 828E3B04: 40980010  bge cr6, 0x828e3b14
	if !ctx.cr[6].lt {
	pc = 0x828E3B14; continue 'dispatch;
	}
	// 828E3B08: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E3B0C: 38AB0E10  addi r5, r11, 0xe10
	ctx.r[5].s64 = ctx.r[11].s64 + 3600;
	// 828E3B10: 4800000C  b 0x828e3b1c
	pc = 0x828E3B1C; continue 'dispatch;
	// 828E3B14: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E3B18: 38AB0DFC  addi r5, r11, 0xdfc
	ctx.r[5].s64 = ctx.r[11].s64 + 3580;
	// 828E3B1C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E3B20: 4BC2E659  bl 0x82512178
	ctx.lr = 0x828E3B24;
	sub_82512178(ctx, base);
	// 828E3B24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E3B28: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E3B2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E3B30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E3B34: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E3B38: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E3B3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E3B40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E3B40 size=100
    let mut pc: u32 = 0x828E3B40;
    'dispatch: loop {
        match pc {
            0x828E3B40 => {
    //   block [0x828E3B40..0x828E3BA4)
	// 828E3B40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E3B44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E3B48: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E3B4C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E3B50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E3B54: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 828E3B58: 419A0028  beq cr6, 0x828e3b80
	if ctx.cr[6].eq {
	pc = 0x828E3B80; continue 'dispatch;
	}
	// 828E3B5C: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 828E3B60: 419A0014  beq cr6, 0x828e3b74
	if ctx.cr[6].eq {
	pc = 0x828E3B74; continue 'dispatch;
	}
	// 828E3B64: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E3B68: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E3B6C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828E3B70: 48000020  b 0x828e3b90
	pc = 0x828E3B90; continue 'dispatch;
	// 828E3B74: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E3B78: 38AB0E4C  addi r5, r11, 0xe4c
	ctx.r[5].s64 = ctx.r[11].s64 + 3660;
	// 828E3B7C: 4800000C  b 0x828e3b88
	pc = 0x828E3B88; continue 'dispatch;
	// 828E3B80: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E3B84: 38AB0E38  addi r5, r11, 0xe38
	ctx.r[5].s64 = ctx.r[11].s64 + 3640;
	// 828E3B88: 4BC2E3B1  bl 0x82511f38
	ctx.lr = 0x828E3B8C;
	sub_82511F38(ctx, base);
	// 828E3B8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E3B90: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828E3B94: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E3B98: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E3B9C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E3BA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E3BA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E3BA8 size=260
    let mut pc: u32 = 0x828E3BA8;
    'dispatch: loop {
        match pc {
            0x828E3BA8 => {
    //   block [0x828E3BA8..0x828E3CAC)
	// 828E3BA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E3BAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E3BB0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E3BB4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E3BB8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E3BBC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828E3BC0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E3BC4: 807E03CC  lwz r3, 0x3cc(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(972 as u32) ) } as u64;
	// 828E3BC8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E3BCC: 419A0028  beq cr6, 0x828e3bf4
	if ctx.cr[6].eq {
	pc = 0x828E3BF4; continue 'dispatch;
	}
	// 828E3BD0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E3BD4: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 828E3BD8: 3BCA6910  addi r30, r10, 0x6910
	ctx.r[30].s64 = ctx.r[10].s64 + 26896;
	// 828E3BDC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828E3BE0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E3BE4: 4E800421  bctrl
	ctx.lr = 0x828E3BE8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E3BE8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828E3BEC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828E3BF0: 48000098  b 0x828e3c88
	pc = 0x828E3C88; continue 'dispatch;
	// 828E3BF4: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828E3BF8: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 828E3BFC: 396B6880  addi r11, r11, 0x6880
	ctx.r[11].s64 = ctx.r[11].s64 + 26752;
	// 828E3C00: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 828E3C04: 39000030  li r8, 0x30
	ctx.r[8].s64 = 48;
	// 828E3C08: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 828E3C0C: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 828E3C10: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 828E3C14: 13E05C07  vcmpneb. (lvlx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828E3C18: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 828E3C1C: 13CA5C07  vcmpneb. (lvlx128) v30, v10, v11
	tmp.u32 = ctx.r[10].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828E3C20: 13A95C07  vcmpneb. (lvlx128) v29, v9, v11
	tmp.u32 = ctx.r[9].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828E3C24: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E3C28: 13885C07  vcmpneb. (lvlx128) v28, v8, v11
	tmp.u32 = ctx.r[8].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E3CB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828E3CB0 size=24
    let mut pc: u32 = 0x828E3CB0;
    'dispatch: loop {
        match pc {
            0x828E3CB0 => {
    //   block [0x828E3CB0..0x828E3CC8)
	// 828E3CB0: 8164037C  lwz r11, 0x37c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(892 as u32) ) } as u64;
	// 828E3CB4: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E3CB8: 81640380  lwz r11, 0x380(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(896 as u32) ) } as u64;
	// 828E3CBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E3CC0: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828E3CC4: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E3CC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828E3CC8 size=36
    let mut pc: u32 = 0x828E3CC8;
    'dispatch: loop {
        match pc {
            0x828E3CC8 => {
    //   block [0x828E3CC8..0x828E3CEC)
	// 828E3CC8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828E3CCC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E3CD0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E3CD4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E3CD8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828E3CDC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E3CE0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E3CE4: 4082FFE8  bne 0x828e3ccc
	if !ctx.cr[0].eq {
	pc = 0x828E3CCC; continue 'dispatch;
	}
	// 828E3CE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E3CF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E3CF0 size=520
    let mut pc: u32 = 0x828E3CF0;
    'dispatch: loop {
        match pc {
            0x828E3CF0 => {
    //   block [0x828E3CF0..0x828E3EF8)
	// 828E3CF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E3CF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E3CF8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E3CFC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E3D00: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E3D04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E3D08: 480250E1  bl 0x82908de8
	ctx.lr = 0x828E3D0C;
	sub_82908DE8(ctx, base);
	// 828E3D0C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828E3D10: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E3D14: 388B3568  addi r4, r11, 0x3568
	ctx.r[4].s64 = ctx.r[11].s64 + 13672;
	// 828E3D18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E3D1C: 4850FCED  bl 0x82df3a08
	ctx.lr = 0x828E3D20;
	sub_82DF3A08(ctx, base);
	// 828E3D20: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E3D24: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828E3D28: 4BF088A1  bl 0x827ec5c8
	ctx.lr = 0x828E3D2C;
	sub_827EC5C8(ctx, base);
	// 828E3D2C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828E3D30: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828E3D34: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828E3D38: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E3D3C: 485312F5  bl 0x82e15030
	ctx.lr = 0x828E3D40;
	sub_82E15030(ctx, base);
	// 828E3D40: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828E3D44: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E3D48: 419A0008  beq cr6, 0x828e3d50
	if ctx.cr[6].eq {
	pc = 0x828E3D50; continue 'dispatch;
	}
	// 828E3D4C: 4B9DCB45  bl 0x822c0890
	ctx.lr = 0x828E3D50;
	sub_822C0890(ctx, base);
	// 828E3D50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E3D54: 4850F6D5  bl 0x82df3428
	ctx.lr = 0x828E3D58;
	sub_82DF3428(ctx, base);
	// 828E3D58: 2F1E0010  cmpwi cr6, r30, 0x10
	ctx.cr[6].compare_i32(ctx.r[30].s32, 16, &mut ctx.xer);
	// 828E3D5C: 419A00F4  beq cr6, 0x828e3e50
	if ctx.cr[6].eq {
	pc = 0x828E3E50; continue 'dispatch;
	}
	// 828E3D60: 2F1E0011  cmpwi cr6, r30, 0x11
	ctx.cr[6].compare_i32(ctx.r[30].s32, 17, &mut ctx.xer);
	// 828E3D64: 419A00B8  beq cr6, 0x828e3e1c
	if ctx.cr[6].eq {
	pc = 0x828E3E1C; continue 'dispatch;
	}
	// 828E3D68: 2F1E0012  cmpwi cr6, r30, 0x12
	ctx.cr[6].compare_i32(ctx.r[30].s32, 18, &mut ctx.xer);
	// 828E3D6C: 419A007C  beq cr6, 0x828e3de8
	if ctx.cr[6].eq {
	pc = 0x828E3DE8; continue 'dispatch;
	}
	// 828E3D70: 2F1E0013  cmpwi cr6, r30, 0x13
	ctx.cr[6].compare_i32(ctx.r[30].s32, 19, &mut ctx.xer);
	// 828E3D74: 419A0040  beq cr6, 0x828e3db4
	if ctx.cr[6].eq {
	pc = 0x828E3DB4; continue 'dispatch;
	}
	// 828E3D78: 2F1E0014  cmpwi cr6, r30, 0x14
	ctx.cr[6].compare_i32(ctx.r[30].s32, 20, &mut ctx.xer);
	// 828E3D7C: 409A0108  bne cr6, 0x828e3e84
	if !ctx.cr[6].eq {
	pc = 0x828E3E84; continue 'dispatch;
	}
	// 828E3D80: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E3D84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E3D88: 388B0EE0  addi r4, r11, 0xee0
	ctx.r[4].s64 = ctx.r[11].s64 + 3808;
	// 828E3D8C: 4850FC7D  bl 0x82df3a08
	ctx.lr = 0x828E3D90;
	sub_82DF3A08(ctx, base);
	// 828E3D90: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828E3D94: 38E00007  li r7, 7
	ctx.r[7].s64 = 7;
	// 828E3D98: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828E3D9C: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 828E3DA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E3DA4: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828E3DA8: 4BF08451  bl 0x827ec1f8
	ctx.lr = 0x828E3DAC;
	sub_827EC1F8(ctx, base);
	// 828E3DAC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E3DB0: 480000D0  b 0x828e3e80
	pc = 0x828E3E80; continue 'dispatch;
	// 828E3DB4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E3DB8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828E3DBC: 388B0EC4  addi r4, r11, 0xec4
	ctx.r[4].s64 = ctx.r[11].s64 + 3780;
	// 828E3DC0: 4850FC49  bl 0x82df3a08
	ctx.lr = 0x828E3DC4;
	sub_82DF3A08(ctx, base);
	// 828E3DC4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828E3DC8: 38E00007  li r7, 7
	ctx.r[7].s64 = 7;
	// 828E3DCC: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 828E3DD0: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 828E3DD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E3DD8: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828E3DDC: 4BF0841D  bl 0x827ec1f8
	ctx.lr = 0x828E3DE0;
	sub_827EC1F8(ctx, base);
	// 828E3DE0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828E3DE4: 4800009C  b 0x828e3e80
	pc = 0x828E3E80; continue 'dispatch;
	// 828E3DE8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E3DEC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E3DF0: 388B0EA8  addi r4, r11, 0xea8
	ctx.r[4].s64 = ctx.r[11].s64 + 3752;
	// 828E3DF4: 4850FC15  bl 0x82df3a08
	ctx.lr = 0x828E3DF8;
	sub_82DF3A08(ctx, base);
	// 828E3DF8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828E3DFC: 38E00007  li r7, 7
	ctx.r[7].s64 = 7;
	// 828E3E00: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828E3E04: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 828E3E08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E3E0C: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828E3E10: 4BF083E9  bl 0x827ec1f8
	ctx.lr = 0x828E3E14;
	sub_827EC1F8(ctx, base);
	// 828E3E14: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E3E18: 48000068  b 0x828e3e80
	pc = 0x828E3E80; continue 'dispatch;
	// 828E3E1C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E3E20: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828E3E24: 388B0E8C  addi r4, r11, 0xe8c
	ctx.r[4].s64 = ctx.r[11].s64 + 3724;
	// 828E3E28: 4850FBE1  bl 0x82df3a08
	ctx.lr = 0x828E3E2C;
	sub_82DF3A08(ctx, base);
	// 828E3E2C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828E3E30: 38E00007  li r7, 7
	ctx.r[7].s64 = 7;
	// 828E3E34: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 828E3E38: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 828E3E3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E3E40: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828E3E44: 4BF083B5  bl 0x827ec1f8
	ctx.lr = 0x828E3E48;
	sub_827EC1F8(ctx, base);
	// 828E3E48: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828E3E4C: 48000034  b 0x828e3e80
	pc = 0x828E3E80; continue 'dispatch;
	// 828E3E50: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E3E54: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828E3E58: 388B0E70  addi r4, r11, 0xe70
	ctx.r[4].s64 = ctx.r[11].s64 + 3696;
	// 828E3E5C: 4850FBAD  bl 0x82df3a08
	ctx.lr = 0x828E3E60;
	sub_82DF3A08(ctx, base);
	// 828E3E60: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828E3E64: 38E00007  li r7, 7
	ctx.r[7].s64 = 7;
	// 828E3E68: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828E3E6C: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 828E3E70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E3E74: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828E3E78: 4BF08381  bl 0x827ec1f8
	ctx.lr = 0x828E3E7C;
	sub_827EC1F8(ctx, base);
	// 828E3E7C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828E3E80: 4850F5A9  bl 0x82df3428
	ctx.lr = 0x828E3E84;
	sub_82DF3428(ctx, base);
	// 828E3E84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E3E88: 4BF082D9  bl 0x827ec160
	ctx.lr = 0x828E3E8C;
	sub_827EC160(ctx, base);
	// 828E3E8C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E3E90: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E3E94: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E3E98: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E3E9C: 4E800421  bctrl
	ctx.lr = 0x828E3EA0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E3EA0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E3EA4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828E3EA8: 815E002C  lwz r10, 0x2c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 828E3EAC: 38AB0E60  addi r5, r11, 0xe60
	ctx.r[5].s64 = ctx.r[11].s64 + 3680;
	// 828E3EB0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E3EB4: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 828E3EB8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828E3EBC: 4E800421  bctrl
	ctx.lr = 0x828E3EC0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E3EC0: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 828E3EC4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E3EC8: 419A0008  beq cr6, 0x828e3ed0
	if ctx.cr[6].eq {
	pc = 0x828E3ED0; continue 'dispatch;
	}
	// 828E3ECC: 4B9DC9C5  bl 0x822c0890
	ctx.lr = 0x828E3ED0;
	sub_822C0890(ctx, base);
	// 828E3ED0: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828E3ED4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E3ED8: 419A0008  beq cr6, 0x828e3ee0
	if ctx.cr[6].eq {
	pc = 0x828E3EE0; continue 'dispatch;
	}
	// 828E3EDC: 4B9DC9B5  bl 0x822c0890
	ctx.lr = 0x828E3EE0;
	sub_822C0890(ctx, base);
	// 828E3EE0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828E3EE4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E3EE8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E3EEC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E3EF0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E3EF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E3EF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E3EF8 size=388
    let mut pc: u32 = 0x828E3EF8;
    'dispatch: loop {
        match pc {
            0x828E3EF8 => {
    //   block [0x828E3EF8..0x828E407C)
	// 828E3EF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E3EFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E3F00: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E3F04: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E3F08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E3F0C: 548B063F  clrlwi. r11, r4, 0x18
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E3F10: 41820110  beq 0x828e4020
	if ctx.cr[0].eq {
	pc = 0x828E4020; continue 'dispatch;
	}
	// 828E3F14: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 828E3F18: 409A0074  bne cr6, 0x828e3f8c
	if !ctx.cr[6].eq {
	pc = 0x828E3F8C; continue 'dispatch;
	}
	// 828E3F1C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E3F20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E3F24: 388B0F20  addi r4, r11, 0xf20
	ctx.r[4].s64 = ctx.r[11].s64 + 3872;
	// 828E3F28: 4850FAE1  bl 0x82df3a08
	ctx.lr = 0x828E3F2C;
	sub_82DF3A08(ctx, base);
	// 828E3F2C: 817F03D0  lwz r11, 0x3d0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(976 as u32) ) } as u64;
	// 828E3F30: 815F03CC  lwz r10, 0x3cc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(972 as u32) ) } as u64;
	// 828E3F34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E3F38: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828E3F3C: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828E3F40: 419A0024  beq cr6, 0x828e3f64
	if ctx.cr[6].eq {
	pc = 0x828E3F64; continue 'dispatch;
	}
	// 828E3F44: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828E3F48: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E3F4C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E3F50: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E3F54: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828E3F58: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E3F5C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E3F60: 4082FFE8  bne 0x828e3f48
	if !ctx.cr[0].eq {
	pc = 0x828E3F48; continue 'dispatch;
	}
	// 828E3F64: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828E3F68: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828E3F6C: 38E00007  li r7, 7
	ctx.r[7].s64 = 7;
	// 828E3F70: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828E3F74: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828E3F78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E3F7C: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828E3F80: 4BF08289  bl 0x827ec208
	ctx.lr = 0x828E3F84;
	sub_827EC208(ctx, base);
	// 828E3F84: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828E3F88: 48000078  b 0x828e4000
	pc = 0x828E4000; continue 'dispatch;
	// 828E3F8C: 2B050001  cmplwi cr6, r5, 1
	ctx.cr[6].compare_u32(ctx.r[5].u32, 1 as u32, &mut ctx.xer);
	// 828E3F90: 409A00D8  bne cr6, 0x828e4068
	if !ctx.cr[6].eq {
	pc = 0x828E4068; continue 'dispatch;
	}
	// 828E3F94: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E3F98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E3F9C: 388B0F00  addi r4, r11, 0xf00
	ctx.r[4].s64 = ctx.r[11].s64 + 3840;
	// 828E3FA0: 4850FA69  bl 0x82df3a08
	ctx.lr = 0x828E3FA4;
	sub_82DF3A08(ctx, base);
	// 828E3FA4: 817F03D0  lwz r11, 0x3d0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(976 as u32) ) } as u64;
	// 828E3FA8: 815F03CC  lwz r10, 0x3cc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(972 as u32) ) } as u64;
	// 828E3FAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E3FB0: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828E3FB4: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 828E3FB8: 419A0024  beq cr6, 0x828e3fdc
	if ctx.cr[6].eq {
	pc = 0x828E3FDC; continue 'dispatch;
	}
	// 828E3FBC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828E3FC0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E3FC4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E3FC8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E3FCC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828E3FD0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E3FD4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E3FD8: 4082FFE8  bne 0x828e3fc0
	if !ctx.cr[0].eq {
	pc = 0x828E3FC0; continue 'dispatch;
	}
	// 828E3FDC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828E3FE0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828E3FE4: 38E00007  li r7, 7
	ctx.r[7].s64 = 7;
	// 828E3FE8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828E3FEC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828E3FF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E3FF4: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828E3FF8: 4BF08211  bl 0x827ec208
	ctx.lr = 0x828E3FFC;
	sub_827EC208(ctx, base);
	// 828E3FFC: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828E4000: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E4004: 907F03FC  stw r3, 0x3fc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1020 as u32), ctx.r[3].u32 ) };
	// 828E4008: 419A000C  beq cr6, 0x828e4014
	if ctx.cr[6].eq {
	pc = 0x828E4014; continue 'dispatch;
	}
	// 828E400C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828E4010: 4B9DC881  bl 0x822c0890
	ctx.lr = 0x828E4014;
	sub_822C0890(ctx, base);
	// 828E4014: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E4018: 4850F411  bl 0x82df3428
	ctx.lr = 0x828E401C;
	sub_82DF3428(ctx, base);
	// 828E401C: 4800004C  b 0x828e4068
	pc = 0x828E4068; continue 'dispatch;
	// 828E4020: 817F03FC  lwz r11, 0x3fc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1020 as u32) ) } as u64;
	// 828E4024: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E4028: 419A0040  beq cr6, 0x828e4068
	if ctx.cr[6].eq {
	pc = 0x828E4068; continue 'dispatch;
	}
	// 828E402C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E4030: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828E4034: 4BC2B495  bl 0x8250f4c8
	ctx.lr = 0x828E4038;
	sub_8250F4C8(ctx, base);
	// 828E4038: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E403C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E4040: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 828E4044: 409A0008  bne cr6, 0x828e404c
	if !ctx.cr[6].eq {
	pc = 0x828E404C; continue 'dispatch;
	}
	// 828E4048: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828E404C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E4050: 80BF03FC  lwz r5, 0x3fc(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1020 as u32) ) } as u64;
	// 828E4054: 4BF0823D  bl 0x827ec290
	ctx.lr = 0x828E4058;
	sub_827EC290(ctx, base);
	// 828E4058: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828E405C: 4850DC35  bl 0x82df1c90
	ctx.lr = 0x828E4060;
	sub_82DF1C90(ctx, base);
	// 828E4060: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E4064: 917F03FC  stw r11, 0x3fc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1020 as u32), ctx.r[11].u32 ) };
	// 828E4068: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828E406C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E4070: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E4074: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E4078: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E4080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E4080 size=268
    let mut pc: u32 = 0x828E4080;
    'dispatch: loop {
        match pc {
            0x828E4080 => {
    //   block [0x828E4080..0x828E418C)
	// 828E4080: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E4084: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E4088: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E408C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E4090: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E4094: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828E4098: 409A0078  bne cr6, 0x828e4110
	if !ctx.cr[6].eq {
	pc = 0x828E4110; continue 'dispatch;
	}
	// 828E409C: 48024D4D  bl 0x82908de8
	ctx.lr = 0x828E40A0;
	sub_82908DE8(ctx, base);
	// 828E40A0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E40A4: 2F030013  cmpwi cr6, r3, 0x13
	ctx.cr[6].compare_i32(ctx.r[3].s32, 19, &mut ctx.xer);
	// 828E40A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E40AC: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 828E40B0: 409A0020  bne cr6, 0x828e40d0
	if !ctx.cr[6].eq {
	pc = 0x828E40D0; continue 'dispatch;
	}
	// 828E40B4: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828E40B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E40BC: 38AA0F94  addi r5, r10, 0xf94
	ctx.r[5].s64 = ctx.r[10].s64 + 3988;
	// 828E40C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E40C4: 4E800421  bctrl
	ctx.lr = 0x828E40C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E40C8: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828E40CC: 480000A0  b 0x828e416c
	pc = 0x828E416C; continue 'dispatch;
	// 828E40D0: 2F030014  cmpwi cr6, r3, 0x14
	ctx.cr[6].compare_i32(ctx.r[3].s32, 20, &mut ctx.xer);
	// 828E40D4: 409A0020  bne cr6, 0x828e40f4
	if !ctx.cr[6].eq {
	pc = 0x828E40F4; continue 'dispatch;
	}
	// 828E40D8: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828E40DC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E40E0: 38AA0F7C  addi r5, r10, 0xf7c
	ctx.r[5].s64 = ctx.r[10].s64 + 3964;
	// 828E40E4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E40E8: 4E800421  bctrl
	ctx.lr = 0x828E40EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E40EC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828E40F0: 4800007C  b 0x828e416c
	pc = 0x828E416C; continue 'dispatch;
	// 828E40F4: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828E40F8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828E40FC: 38AA0F68  addi r5, r10, 0xf68
	ctx.r[5].s64 = ctx.r[10].s64 + 3944;
	// 828E4100: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E4104: 4E800421  bctrl
	ctx.lr = 0x828E4108;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E4108: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828E410C: 48000060  b 0x828e416c
	pc = 0x828E416C; continue 'dispatch;
	// 828E4110: 2B040001  cmplwi cr6, r4, 1
	ctx.cr[6].compare_u32(ctx.r[4].u32, 1 as u32, &mut ctx.xer);
	// 828E4114: 409A002C  bne cr6, 0x828e4140
	if !ctx.cr[6].eq {
	pc = 0x828E4140; continue 'dispatch;
	}
	// 828E4118: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E411C: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828E4120: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E4124: 38AA0F54  addi r5, r10, 0xf54
	ctx.r[5].s64 = ctx.r[10].s64 + 3924;
	// 828E4128: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828E412C: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 828E4130: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E4134: 4E800421  bctrl
	ctx.lr = 0x828E4138;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E4138: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828E413C: 48000030  b 0x828e416c
	pc = 0x828E416C; continue 'dispatch;
	// 828E4140: 2B040002  cmplwi cr6, r4, 2
	ctx.cr[6].compare_u32(ctx.r[4].u32, 2 as u32, &mut ctx.xer);
	// 828E4144: 409A0034  bne cr6, 0x828e4178
	if !ctx.cr[6].eq {
	pc = 0x828E4178; continue 'dispatch;
	}
	// 828E4148: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E414C: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828E4150: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E4154: 38AA0F3C  addi r5, r10, 0xf3c
	ctx.r[5].s64 = ctx.r[10].s64 + 3900;
	// 828E4158: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828E415C: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 828E4160: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E4164: 4E800421  bctrl
	ctx.lr = 0x828E4168;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E4168: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828E416C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E4170: 419A0008  beq cr6, 0x828e4178
	if ctx.cr[6].eq {
	pc = 0x828E4178; continue 'dispatch;
	}
	// 828E4174: 4B9DC71D  bl 0x822c0890
	ctx.lr = 0x828E4178;
	sub_822C0890(ctx, base);
	// 828E4178: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828E417C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E4180: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E4184: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E4188: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E4190(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828E4190 size=292
    let mut pc: u32 = 0x828E4190;
    'dispatch: loop {
        match pc {
            0x828E4190 => {
    //   block [0x828E4190..0x828E42B4)
	// 828E4190: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E4194: 488C3FD9  bl 0x831a816c
	ctx.lr = 0x828E4198;
	sub_831A8130(ctx, base);
	// 828E4198: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E42B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828E42B8 size=104
    let mut pc: u32 = 0x828E42B8;
    'dispatch: loop {
        match pc {
            0x828E42B8 => {
    //   block [0x828E42B8..0x828E4320)
	// 828E42B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E42BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E42C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E42C4: 3980FFE0  li r12, -0x20
	ctx.r[12].s64 = -32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E4320(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E4320 size=216
    let mut pc: u32 = 0x828E4320;
    'dispatch: loop {
        match pc {
            0x828E4320 => {
    //   block [0x828E4320..0x828E43F8)
	// 828E4320: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E4324: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E4328: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E432C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E4330: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E4334: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E4338: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828E433C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E4340: C03F000C  lfs f1, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828E4344: 816B0064  lwz r11, 0x64(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 828E4348: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E434C: 4E800421  bctrl
	ctx.lr = 0x828E4350;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E4350: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828E4354: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 828E4358: 396B6880  addi r11, r11, 0x6880
	ctx.r[11].s64 = ctx.r[11].s64 + 26752;
	// 828E435C: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 828E4360: 39000030  li r8, 0x30
	ctx.r[8].s64 = 48;
	// 828E4364: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 828E4368: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828E436C: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 828E4370: 13E05C07  vcmpneb. (lvlx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828E4374: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 828E4378: 13CA5C07  vcmpneb. (lvlx128) v30, v10, v11
	tmp.u32 = ctx.r[10].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828E437C: 13A95C07  vcmpneb. (lvlx128) v29, v9, v11
	tmp.u32 = ctx.r[9].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828E4380: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E4384: 13885C07  vcmpneb. (lvlx128) v28, v8, v11
	tmp.u32 = ctx.r[8].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E43F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E43F8 size=232
    let mut pc: u32 = 0x828E43F8;
    'dispatch: loop {
        match pc {
            0x828E43F8 => {
    //   block [0x828E43F8..0x828E44E0)
	// 828E43F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E43FC: 488C3D69  bl 0x831a8164
	ctx.lr = 0x828E4400;
	sub_831A8130(ctx, base);
	// 828E4400: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E4404: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828E4408: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828E440C: 3BAB3DA0  addi r29, r11, 0x3da0
	ctx.r[29].s64 = ctx.r[11].s64 + 15776;
	// 828E4410: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828E4414: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828E4418: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 828E441C: 3B6B0F7C  addi r27, r11, 0xf7c
	ctx.r[27].s64 = ctx.r[11].s64 + 3964;
	// 828E4420: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828E4424: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828E4428: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828E442C: 488C46AD  bl 0x831a8ad8
	ctx.lr = 0x828E4430;
	sub_831A8AD8(ctx, base);
	// 828E4430: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 828E4434: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E4438: 4850F5D1  bl 0x82df3a08
	ctx.lr = 0x828E443C;
	sub_82DF3A08(ctx, base);
	// 828E443C: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E4440: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828E4444: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E4448: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E444C: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 828E4450: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E4454: 4E800421  bctrl
	ctx.lr = 0x828E4458;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E4458: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E445C: 4850EFCD  bl 0x82df3428
	ctx.lr = 0x828E4460;
	sub_82DF3428(ctx, base);
	// 828E4460: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828E4464: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828E4468: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E446C: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828E4470: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 828E4474: 419A0024  beq cr6, 0x828e4498
	if ctx.cr[6].eq {
	pc = 0x828E4498; continue 'dispatch;
	}
	// 828E4478: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828E447C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E4480: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E4484: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E4488: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828E448C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E4490: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E4494: 4082FFE8  bne 0x828e447c
	if !ctx.cr[0].eq {
	pc = 0x828E447C; continue 'dispatch;
	}
	// 828E4498: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828E449C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E44A0: 4800A629  bl 0x828eeac8
	ctx.lr = 0x828E44A4;
	sub_828EEAC8(ctx, base);
	// 828E44A4: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828E44A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E44AC: 419A0008  beq cr6, 0x828e44b4
	if ctx.cr[6].eq {
	pc = 0x828E44B4; continue 'dispatch;
	}
	// 828E44B0: 4B9DC3E1  bl 0x822c0890
	ctx.lr = 0x828E44B4;
	sub_822C0890(ctx, base);
	// 828E44B4: 3BDE021C  addi r30, r30, 0x21c
	ctx.r[30].s64 = ctx.r[30].s64 + 540;
	// 828E44B8: 397D1518  addi r11, r29, 0x1518
	ctx.r[11].s64 = ctx.r[29].s64 + 5400;
	// 828E44BC: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 828E44C0: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 828E44C4: 4198FF5C  blt cr6, 0x828e4420
	if ctx.cr[6].lt {
	pc = 0x828E4420; continue 'dispatch;
	}
	// 828E44C8: 807C0004  lwz r3, 4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E44CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E44D0: 419A0008  beq cr6, 0x828e44d8
	if ctx.cr[6].eq {
	pc = 0x828E44D8; continue 'dispatch;
	}
	// 828E44D4: 4B9DC3BD  bl 0x822c0890
	ctx.lr = 0x828E44D8;
	sub_822C0890(ctx, base);
	// 828E44D8: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828E44DC: 488C3CD8  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E44E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E44E0 size=128
    let mut pc: u32 = 0x828E44E0;
    'dispatch: loop {
        match pc {
            0x828E44E0 => {
    //   block [0x828E44E0..0x828E4560)
	// 828E44E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E44E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E44E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E44EC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E44F0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E44F4: 3BE30004  addi r31, r3, 4
	ctx.r[31].s64 = ctx.r[3].s64 + 4;
	// 828E44F8: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E44FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E4500: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828E4504: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828E4508: 419A0024  beq cr6, 0x828e452c
	if ctx.cr[6].eq {
	pc = 0x828E452C; continue 'dispatch;
	}
	// 828E450C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828E4510: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E4514: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E4518: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E451C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828E4520: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E4524: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E4528: 4082FFE8  bne 0x828e4510
	if !ctx.cr[0].eq {
	pc = 0x828E4510; continue 'dispatch;
	}
	// 828E452C: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828E4530: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E4534: 386B3CC8  addi r3, r11, 0x3cc8
	ctx.r[3].s64 = ctx.r[11].s64 + 15560;
	// 828E4538: 4800AE29  bl 0x828ef360
	ctx.lr = 0x828E453C;
	sub_828EF360(ctx, base);
	// 828E453C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E4540: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E4544: 419A0008  beq cr6, 0x828e454c
	if ctx.cr[6].eq {
	pc = 0x828E454C; continue 'dispatch;
	}
	// 828E4548: 4B9DC349  bl 0x822c0890
	ctx.lr = 0x828E454C;
	sub_822C0890(ctx, base);
	// 828E454C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E4550: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E4554: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E4558: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E455C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E4560(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E4560 size=232
    let mut pc: u32 = 0x828E4560;
    'dispatch: loop {
        match pc {
            0x828E4560 => {
    //   block [0x828E4560..0x828E4648)
	// 828E4560: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E4564: 488C3C01  bl 0x831a8164
	ctx.lr = 0x828E4568;
	sub_831A8130(ctx, base);
	// 828E4568: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E456C: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828E4570: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828E4574: 3BAB5390  addi r29, r11, 0x5390
	ctx.r[29].s64 = ctx.r[11].s64 + 21392;
	// 828E4578: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828E457C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828E4580: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 828E4584: 3B6B0F7C  addi r27, r11, 0xf7c
	ctx.r[27].s64 = ctx.r[11].s64 + 3964;
	// 828E4588: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828E458C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828E4590: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828E4594: 488C4545  bl 0x831a8ad8
	ctx.lr = 0x828E4598;
	sub_831A8AD8(ctx, base);
	// 828E4598: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 828E459C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E45A0: 4850F469  bl 0x82df3a08
	ctx.lr = 0x828E45A4;
	sub_82DF3A08(ctx, base);
	// 828E45A4: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E45A8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828E45AC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E45B0: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E45B4: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 828E45B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E45BC: 4E800421  bctrl
	ctx.lr = 0x828E45C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E45C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E45C4: 4850EE65  bl 0x82df3428
	ctx.lr = 0x828E45C8;
	sub_82DF3428(ctx, base);
	// 828E45C8: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828E45CC: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828E45D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E45D4: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828E45D8: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 828E45DC: 419A0024  beq cr6, 0x828e4600
	if ctx.cr[6].eq {
	pc = 0x828E4600; continue 'dispatch;
	}
	// 828E45E0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828E45E4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E45E8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E45EC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E45F0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828E45F4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E45F8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E45FC: 4082FFE8  bne 0x828e45e4
	if !ctx.cr[0].eq {
	pc = 0x828E45E4; continue 'dispatch;
	}
	// 828E4600: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828E4604: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E4608: 4800A4C1  bl 0x828eeac8
	ctx.lr = 0x828E460C;
	sub_828EEAC8(ctx, base);
	// 828E460C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828E4610: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E4614: 419A0008  beq cr6, 0x828e461c
	if ctx.cr[6].eq {
	pc = 0x828E461C; continue 'dispatch;
	}
	// 828E4618: 4B9DC279  bl 0x822c0890
	ctx.lr = 0x828E461C;
	sub_822C0890(ctx, base);
	// 828E461C: 3BDE021C  addi r30, r30, 0x21c
	ctx.r[30].s64 = ctx.r[30].s64 + 540;
	// 828E4620: 397D1518  addi r11, r29, 0x1518
	ctx.r[11].s64 = ctx.r[29].s64 + 5400;
	// 828E4624: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 828E4628: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 828E462C: 4198FF5C  blt cr6, 0x828e4588
	if ctx.cr[6].lt {
	pc = 0x828E4588; continue 'dispatch;
	}
	// 828E4630: 807C0004  lwz r3, 4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E4634: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E4638: 419A0008  beq cr6, 0x828e4640
	if ctx.cr[6].eq {
	pc = 0x828E4640; continue 'dispatch;
	}
	// 828E463C: 4B9DC255  bl 0x822c0890
	ctx.lr = 0x828E4640;
	sub_822C0890(ctx, base);
	// 828E4640: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828E4644: 488C3B70  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E4648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E4648 size=128
    let mut pc: u32 = 0x828E4648;
    'dispatch: loop {
        match pc {
            0x828E4648 => {
    //   block [0x828E4648..0x828E46C8)
	// 828E4648: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E464C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E4650: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E4654: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E4658: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E465C: 3BE30004  addi r31, r3, 4
	ctx.r[31].s64 = ctx.r[3].s64 + 4;
	// 828E4660: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E4664: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E4668: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828E466C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828E4670: 419A0024  beq cr6, 0x828e4694
	if ctx.cr[6].eq {
	pc = 0x828E4694; continue 'dispatch;
	}
	// 828E4674: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828E4678: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E467C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E4680: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E4684: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828E4688: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E468C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E4690: 4082FFE8  bne 0x828e4678
	if !ctx.cr[0].eq {
	pc = 0x828E4678; continue 'dispatch;
	}
	// 828E4694: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828E4698: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E469C: 386B52B8  addi r3, r11, 0x52b8
	ctx.r[3].s64 = ctx.r[11].s64 + 21176;
	// 828E46A0: 4800ACC1  bl 0x828ef360
	ctx.lr = 0x828E46A4;
	sub_828EF360(ctx, base);
	// 828E46A4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E46A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E46AC: 419A0008  beq cr6, 0x828e46b4
	if ctx.cr[6].eq {
	pc = 0x828E46B4; continue 'dispatch;
	}
	// 828E46B0: 4B9DC1E1  bl 0x822c0890
	ctx.lr = 0x828E46B4;
	sub_822C0890(ctx, base);
	// 828E46B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E46B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E46BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E46C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E46C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E46C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E46C8 size=232
    let mut pc: u32 = 0x828E46C8;
    'dispatch: loop {
        match pc {
            0x828E46C8 => {
    //   block [0x828E46C8..0x828E47B0)
	// 828E46C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E46CC: 488C3A99  bl 0x831a8164
	ctx.lr = 0x828E46D0;
	sub_831A8130(ctx, base);
	// 828E46D0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E46D4: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828E46D8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828E46DC: 3BAB6980  addi r29, r11, 0x6980
	ctx.r[29].s64 = ctx.r[11].s64 + 27008;
	// 828E46E0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828E46E4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828E46E8: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 828E46EC: 3B6B0F7C  addi r27, r11, 0xf7c
	ctx.r[27].s64 = ctx.r[11].s64 + 3964;
	// 828E46F0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828E46F4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828E46F8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828E46FC: 488C43DD  bl 0x831a8ad8
	ctx.lr = 0x828E4700;
	sub_831A8AD8(ctx, base);
	// 828E4700: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 828E4704: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E4708: 4850F301  bl 0x82df3a08
	ctx.lr = 0x828E470C;
	sub_82DF3A08(ctx, base);
	// 828E470C: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E4710: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828E4714: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E4718: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E471C: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 828E4720: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E4724: 4E800421  bctrl
	ctx.lr = 0x828E4728;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E4728: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E472C: 4850ECFD  bl 0x82df3428
	ctx.lr = 0x828E4730;
	sub_82DF3428(ctx, base);
	// 828E4730: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828E4734: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828E4738: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E473C: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828E4740: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 828E4744: 419A0024  beq cr6, 0x828e4768
	if ctx.cr[6].eq {
	pc = 0x828E4768; continue 'dispatch;
	}
	// 828E4748: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828E474C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E4750: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E4754: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E4758: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828E475C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E4760: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E4764: 4082FFE8  bne 0x828e474c
	if !ctx.cr[0].eq {
	pc = 0x828E474C; continue 'dispatch;
	}
	// 828E4768: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828E476C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E4770: 4800A359  bl 0x828eeac8
	ctx.lr = 0x828E4774;
	sub_828EEAC8(ctx, base);
	// 828E4774: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828E4778: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E477C: 419A0008  beq cr6, 0x828e4784
	if ctx.cr[6].eq {
	pc = 0x828E4784; continue 'dispatch;
	}
	// 828E4780: 4B9DC111  bl 0x822c0890
	ctx.lr = 0x828E4784;
	sub_822C0890(ctx, base);
	// 828E4784: 3BDE021C  addi r30, r30, 0x21c
	ctx.r[30].s64 = ctx.r[30].s64 + 540;
	// 828E4788: 397D1518  addi r11, r29, 0x1518
	ctx.r[11].s64 = ctx.r[29].s64 + 5400;
	// 828E478C: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 828E4790: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 828E4794: 4198FF5C  blt cr6, 0x828e46f0
	if ctx.cr[6].lt {
	pc = 0x828E46F0; continue 'dispatch;
	}
	// 828E4798: 807C0004  lwz r3, 4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E479C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E47A0: 419A0008  beq cr6, 0x828e47a8
	if ctx.cr[6].eq {
	pc = 0x828E47A8; continue 'dispatch;
	}
	// 828E47A4: 4B9DC0ED  bl 0x822c0890
	ctx.lr = 0x828E47A8;
	sub_822C0890(ctx, base);
	// 828E47A8: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828E47AC: 488C3A08  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E47B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E47B0 size=128
    let mut pc: u32 = 0x828E47B0;
    'dispatch: loop {
        match pc {
            0x828E47B0 => {
    //   block [0x828E47B0..0x828E4830)
	// 828E47B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E47B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E47B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E47BC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E47C0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E47C4: 3BE30004  addi r31, r3, 4
	ctx.r[31].s64 = ctx.r[3].s64 + 4;
	// 828E47C8: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E47CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E47D0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828E47D4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828E47D8: 419A0024  beq cr6, 0x828e47fc
	if ctx.cr[6].eq {
	pc = 0x828E47FC; continue 'dispatch;
	}
	// 828E47DC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828E47E0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E47E4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E47E8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E47EC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828E47F0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E47F4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E47F8: 4082FFE8  bne 0x828e47e0
	if !ctx.cr[0].eq {
	pc = 0x828E47E0; continue 'dispatch;
	}
	// 828E47FC: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828E4800: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E4804: 386B68A8  addi r3, r11, 0x68a8
	ctx.r[3].s64 = ctx.r[11].s64 + 26792;
	// 828E4808: 4800AB59  bl 0x828ef360
	ctx.lr = 0x828E480C;
	sub_828EF360(ctx, base);
	// 828E480C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E4810: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E4814: 419A0008  beq cr6, 0x828e481c
	if ctx.cr[6].eq {
	pc = 0x828E481C; continue 'dispatch;
	}
	// 828E4818: 4B9DC079  bl 0x822c0890
	ctx.lr = 0x828E481C;
	sub_822C0890(ctx, base);
	// 828E481C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E4820: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E4824: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E4828: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E482C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E4830(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E4830 size=232
    let mut pc: u32 = 0x828E4830;
    'dispatch: loop {
        match pc {
            0x828E4830 => {
    //   block [0x828E4830..0x828E4918)
	// 828E4830: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E4834: 488C3931  bl 0x831a8164
	ctx.lr = 0x828E4838;
	sub_831A8130(ctx, base);
	// 828E4838: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E483C: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828E4840: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828E4844: 3BAB7F70  addi r29, r11, 0x7f70
	ctx.r[29].s64 = ctx.r[11].s64 + 32624;
	// 828E4848: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828E484C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828E4850: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 828E4854: 3B6B0F7C  addi r27, r11, 0xf7c
	ctx.r[27].s64 = ctx.r[11].s64 + 3964;
	// 828E4858: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828E485C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828E4860: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828E4864: 488C4275  bl 0x831a8ad8
	ctx.lr = 0x828E4868;
	sub_831A8AD8(ctx, base);
	// 828E4868: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 828E486C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E4870: 4850F199  bl 0x82df3a08
	ctx.lr = 0x828E4874;
	sub_82DF3A08(ctx, base);
	// 828E4874: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E4878: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828E487C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E4880: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E4884: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 828E4888: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E488C: 4E800421  bctrl
	ctx.lr = 0x828E4890;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E4890: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E4894: 4850EB95  bl 0x82df3428
	ctx.lr = 0x828E4898;
	sub_82DF3428(ctx, base);
	// 828E4898: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828E489C: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828E48A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E48A4: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828E48A8: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 828E48AC: 419A0024  beq cr6, 0x828e48d0
	if ctx.cr[6].eq {
	pc = 0x828E48D0; continue 'dispatch;
	}
	// 828E48B0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828E48B4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E48B8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E48BC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E48C0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828E48C4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E48C8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E48CC: 4082FFE8  bne 0x828e48b4
	if !ctx.cr[0].eq {
	pc = 0x828E48B4; continue 'dispatch;
	}
	// 828E48D0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828E48D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E48D8: 4800A1F1  bl 0x828eeac8
	ctx.lr = 0x828E48DC;
	sub_828EEAC8(ctx, base);
	// 828E48DC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828E48E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E48E4: 419A0008  beq cr6, 0x828e48ec
	if ctx.cr[6].eq {
	pc = 0x828E48EC; continue 'dispatch;
	}
	// 828E48E8: 4B9DBFA9  bl 0x822c0890
	ctx.lr = 0x828E48EC;
	sub_822C0890(ctx, base);
	// 828E48EC: 3BDE021C  addi r30, r30, 0x21c
	ctx.r[30].s64 = ctx.r[30].s64 + 540;
	// 828E48F0: 397D1518  addi r11, r29, 0x1518
	ctx.r[11].s64 = ctx.r[29].s64 + 5400;
	// 828E48F4: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 828E48F8: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 828E48FC: 4198FF5C  blt cr6, 0x828e4858
	if ctx.cr[6].lt {
	pc = 0x828E4858; continue 'dispatch;
	}
	// 828E4900: 807C0004  lwz r3, 4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E4904: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E4908: 419A0008  beq cr6, 0x828e4910
	if ctx.cr[6].eq {
	pc = 0x828E4910; continue 'dispatch;
	}
	// 828E490C: 4B9DBF85  bl 0x822c0890
	ctx.lr = 0x828E4910;
	sub_822C0890(ctx, base);
	// 828E4910: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828E4914: 488C38A0  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E4918(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E4918 size=128
    let mut pc: u32 = 0x828E4918;
    'dispatch: loop {
        match pc {
            0x828E4918 => {
    //   block [0x828E4918..0x828E4998)
	// 828E4918: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E491C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E4920: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E4924: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E4928: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E492C: 3BE30004  addi r31, r3, 4
	ctx.r[31].s64 = ctx.r[3].s64 + 4;
	// 828E4930: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E4934: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E4938: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828E493C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828E4940: 419A0024  beq cr6, 0x828e4964
	if ctx.cr[6].eq {
	pc = 0x828E4964; continue 'dispatch;
	}
	// 828E4944: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828E4948: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E494C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E4950: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E4954: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828E4958: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E495C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E4960: 4082FFE8  bne 0x828e4948
	if !ctx.cr[0].eq {
	pc = 0x828E4948; continue 'dispatch;
	}
	// 828E4964: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828E4968: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E496C: 386B7E98  addi r3, r11, 0x7e98
	ctx.r[3].s64 = ctx.r[11].s64 + 32408;
	// 828E4970: 4800A9F1  bl 0x828ef360
	ctx.lr = 0x828E4974;
	sub_828EF360(ctx, base);
	// 828E4974: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E4978: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E497C: 419A0008  beq cr6, 0x828e4984
	if ctx.cr[6].eq {
	pc = 0x828E4984; continue 'dispatch;
	}
	// 828E4980: 4B9DBF11  bl 0x822c0890
	ctx.lr = 0x828E4984;
	sub_822C0890(ctx, base);
	// 828E4984: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E4988: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E498C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E4990: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E4994: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E4998(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E4998 size=232
    let mut pc: u32 = 0x828E4998;
    'dispatch: loop {
        match pc {
            0x828E4998 => {
    //   block [0x828E4998..0x828E4A80)
	// 828E4998: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E499C: 488C37C9  bl 0x831a8164
	ctx.lr = 0x828E49A0;
	sub_831A8130(ctx, base);
	// 828E49A0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E49A4: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828E49A8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828E49AC: 3BAB9560  addi r29, r11, -0x6aa0
	ctx.r[29].s64 = ctx.r[11].s64 + -27296;
	// 828E49B0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828E49B4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828E49B8: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 828E49BC: 3B6B0F7C  addi r27, r11, 0xf7c
	ctx.r[27].s64 = ctx.r[11].s64 + 3964;
	// 828E49C0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828E49C4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828E49C8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828E49CC: 488C410D  bl 0x831a8ad8
	ctx.lr = 0x828E49D0;
	sub_831A8AD8(ctx, base);
	// 828E49D0: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 828E49D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E49D8: 4850F031  bl 0x82df3a08
	ctx.lr = 0x828E49DC;
	sub_82DF3A08(ctx, base);
	// 828E49DC: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E49E0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828E49E4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E49E8: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E49EC: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 828E49F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E49F4: 4E800421  bctrl
	ctx.lr = 0x828E49F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E49F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E49FC: 4850EA2D  bl 0x82df3428
	ctx.lr = 0x828E4A00;
	sub_82DF3428(ctx, base);
	// 828E4A00: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828E4A04: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828E4A08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E4A0C: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828E4A10: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 828E4A14: 419A0024  beq cr6, 0x828e4a38
	if ctx.cr[6].eq {
	pc = 0x828E4A38; continue 'dispatch;
	}
	// 828E4A18: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828E4A1C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E4A20: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E4A24: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E4A28: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828E4A2C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E4A30: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E4A34: 4082FFE8  bne 0x828e4a1c
	if !ctx.cr[0].eq {
	pc = 0x828E4A1C; continue 'dispatch;
	}
	// 828E4A38: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828E4A3C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E4A40: 4800A089  bl 0x828eeac8
	ctx.lr = 0x828E4A44;
	sub_828EEAC8(ctx, base);
	// 828E4A44: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828E4A48: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E4A4C: 419A0008  beq cr6, 0x828e4a54
	if ctx.cr[6].eq {
	pc = 0x828E4A54; continue 'dispatch;
	}
	// 828E4A50: 4B9DBE41  bl 0x822c0890
	ctx.lr = 0x828E4A54;
	sub_822C0890(ctx, base);
	// 828E4A54: 3BDE021C  addi r30, r30, 0x21c
	ctx.r[30].s64 = ctx.r[30].s64 + 540;
	// 828E4A58: 397D1518  addi r11, r29, 0x1518
	ctx.r[11].s64 = ctx.r[29].s64 + 5400;
	// 828E4A5C: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 828E4A60: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 828E4A64: 4198FF5C  blt cr6, 0x828e49c0
	if ctx.cr[6].lt {
	pc = 0x828E49C0; continue 'dispatch;
	}
	// 828E4A68: 807C0004  lwz r3, 4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E4A6C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E4A70: 419A0008  beq cr6, 0x828e4a78
	if ctx.cr[6].eq {
	pc = 0x828E4A78; continue 'dispatch;
	}
	// 828E4A74: 4B9DBE1D  bl 0x822c0890
	ctx.lr = 0x828E4A78;
	sub_822C0890(ctx, base);
	// 828E4A78: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828E4A7C: 488C3738  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E4A80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E4A80 size=128
    let mut pc: u32 = 0x828E4A80;
    'dispatch: loop {
        match pc {
            0x828E4A80 => {
    //   block [0x828E4A80..0x828E4B00)
	// 828E4A80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E4A84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E4A88: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E4A8C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E4A90: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E4A94: 3BE30004  addi r31, r3, 4
	ctx.r[31].s64 = ctx.r[3].s64 + 4;
	// 828E4A98: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E4A9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E4AA0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828E4AA4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828E4AA8: 419A0024  beq cr6, 0x828e4acc
	if ctx.cr[6].eq {
	pc = 0x828E4ACC; continue 'dispatch;
	}
	// 828E4AAC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828E4AB0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E4AB4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E4AB8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E4ABC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828E4AC0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E4AC4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E4AC8: 4082FFE8  bne 0x828e4ab0
	if !ctx.cr[0].eq {
	pc = 0x828E4AB0; continue 'dispatch;
	}
	// 828E4ACC: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828E4AD0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E4AD4: 386B9488  addi r3, r11, -0x6b78
	ctx.r[3].s64 = ctx.r[11].s64 + -27512;
	// 828E4AD8: 4800A889  bl 0x828ef360
	ctx.lr = 0x828E4ADC;
	sub_828EF360(ctx, base);
	// 828E4ADC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E4AE0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E4AE4: 419A0008  beq cr6, 0x828e4aec
	if ctx.cr[6].eq {
	pc = 0x828E4AEC; continue 'dispatch;
	}
	// 828E4AE8: 4B9DBDA9  bl 0x822c0890
	ctx.lr = 0x828E4AEC;
	sub_822C0890(ctx, base);
	// 828E4AEC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E4AF0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E4AF4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E4AF8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E4AFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E4B00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E4B00 size=72
    let mut pc: u32 = 0x828E4B00;
    'dispatch: loop {
        match pc {
            0x828E4B00 => {
    //   block [0x828E4B00..0x828E4B48)
	// 828E4B00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E4B04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E4B08: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E4B0C: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 828E4B10: 419A001C  beq cr6, 0x828e4b2c
	if ctx.cr[6].eq {
	pc = 0x828E4B2C; continue 'dispatch;
	}
	// 828E4B14: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828E4B18: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828E4B1C: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 828E4B20: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828E4B24: 4BFFDF15  bl 0x828e2a38
	ctx.lr = 0x828E4B28;
	sub_828E2A38(ctx, base);
	// 828E4B28: 48000010  b 0x828e4b38
	pc = 0x828E4B38; continue 'dispatch;
	// 828E4B2C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828E4B30: 396B8BE8  addi r11, r11, -0x7418
	ctx.r[11].s64 = ctx.r[11].s64 + -29720;
	// 828E4B34: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E4B38: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828E4B3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E4B40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E4B44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E4B48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E4B48 size=72
    let mut pc: u32 = 0x828E4B48;
    'dispatch: loop {
        match pc {
            0x828E4B48 => {
    //   block [0x828E4B48..0x828E4B90)
	// 828E4B48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E4B4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E4B50: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E4B54: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 828E4B58: 419A001C  beq cr6, 0x828e4b74
	if ctx.cr[6].eq {
	pc = 0x828E4B74; continue 'dispatch;
	}
	// 828E4B5C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828E4B60: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828E4B64: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 828E4B68: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828E4B6C: 4BFFDF55  bl 0x828e2ac0
	ctx.lr = 0x828E4B70;
	sub_828E2AC0(ctx, base);
	// 828E4B70: 48000010  b 0x828e4b80
	pc = 0x828E4B80; continue 'dispatch;
	// 828E4B74: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828E4B78: 396B8C88  addi r11, r11, -0x7378
	ctx.r[11].s64 = ctx.r[11].s64 + -29560;
	// 828E4B7C: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E4B80: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828E4B84: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E4B88: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E4B8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E4B90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E4B90 size=72
    let mut pc: u32 = 0x828E4B90;
    'dispatch: loop {
        match pc {
            0x828E4B90 => {
    //   block [0x828E4B90..0x828E4BD8)
	// 828E4B90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E4B94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E4B98: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E4B9C: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 828E4BA0: 419A001C  beq cr6, 0x828e4bbc
	if ctx.cr[6].eq {
	pc = 0x828E4BBC; continue 'dispatch;
	}
	// 828E4BA4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828E4BA8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828E4BAC: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 828E4BB0: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828E4BB4: 4BFFDF95  bl 0x828e2b48
	ctx.lr = 0x828E4BB8;
	sub_828E2B48(ctx, base);
	// 828E4BB8: 48000010  b 0x828e4bc8
	pc = 0x828E4BC8; continue 'dispatch;
	// 828E4BBC: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828E4BC0: 396B8D60  addi r11, r11, -0x72a0
	ctx.r[11].s64 = ctx.r[11].s64 + -29344;
	// 828E4BC4: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E4BC8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828E4BCC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E4BD0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E4BD4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E4BD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E4BD8 size=72
    let mut pc: u32 = 0x828E4BD8;
    'dispatch: loop {
        match pc {
            0x828E4BD8 => {
    //   block [0x828E4BD8..0x828E4C20)
	// 828E4BD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E4BDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E4BE0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E4BE4: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 828E4BE8: 419A001C  beq cr6, 0x828e4c04
	if ctx.cr[6].eq {
	pc = 0x828E4C04; continue 'dispatch;
	}
	// 828E4BEC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828E4BF0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828E4BF4: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 828E4BF8: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828E4BFC: 4BFFDFD5  bl 0x828e2bd0
	ctx.lr = 0x828E4C00;
	sub_828E2BD0(ctx, base);
	// 828E4C00: 48000010  b 0x828e4c10
	pc = 0x828E4C10; continue 'dispatch;
	// 828E4C04: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828E4C08: 396B8E10  addi r11, r11, -0x71f0
	ctx.r[11].s64 = ctx.r[11].s64 + -29168;
	// 828E4C0C: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E4C10: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828E4C14: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E4C18: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E4C1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E4C20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E4C20 size=72
    let mut pc: u32 = 0x828E4C20;
    'dispatch: loop {
        match pc {
            0x828E4C20 => {
    //   block [0x828E4C20..0x828E4C68)
	// 828E4C20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E4C24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E4C28: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E4C2C: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 828E4C30: 419A001C  beq cr6, 0x828e4c4c
	if ctx.cr[6].eq {
	pc = 0x828E4C4C; continue 'dispatch;
	}
	// 828E4C34: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828E4C38: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828E4C3C: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 828E4C40: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828E4C44: 4BFFE015  bl 0x828e2c58
	ctx.lr = 0x828E4C48;
	sub_828E2C58(ctx, base);
	// 828E4C48: 48000010  b 0x828e4c58
	pc = 0x828E4C58; continue 'dispatch;
	// 828E4C4C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828E4C50: 396B8EC0  addi r11, r11, -0x7140
	ctx.r[11].s64 = ctx.r[11].s64 + -28992;
	// 828E4C54: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E4C58: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828E4C5C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E4C60: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E4C64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E4C68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E4C68 size=72
    let mut pc: u32 = 0x828E4C68;
    'dispatch: loop {
        match pc {
            0x828E4C68 => {
    //   block [0x828E4C68..0x828E4CB0)
	// 828E4C68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E4C6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E4C70: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E4C74: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 828E4C78: 419A001C  beq cr6, 0x828e4c94
	if ctx.cr[6].eq {
	pc = 0x828E4C94; continue 'dispatch;
	}
	// 828E4C7C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828E4C80: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828E4C84: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 828E4C88: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828E4C8C: 4BFFE05D  bl 0x828e2ce8
	ctx.lr = 0x828E4C90;
	sub_828E2CE8(ctx, base);
	// 828E4C90: 48000010  b 0x828e4ca0
	pc = 0x828E4CA0; continue 'dispatch;
	// 828E4C94: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828E4C98: 396B8F80  addi r11, r11, -0x7080
	ctx.r[11].s64 = ctx.r[11].s64 + -28800;
	// 828E4C9C: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E4CA0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828E4CA4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E4CA8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E4CAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E4CB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E4CB0 size=1872
    let mut pc: u32 = 0x828E4CB0;
    'dispatch: loop {
        match pc {
            0x828E4CB0 => {
    //   block [0x828E4CB0..0x828E5400)
	// 828E4CB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E4CB4: 488C34B1  bl 0x831a8164
	ctx.lr = 0x828E4CB8;
	sub_831A8130(ctx, base);
	// 828E4CB8: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E4CBC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E4CC0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828E4CC4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E4CC8: 388B0FE4  addi r4, r11, 0xfe4
	ctx.r[4].s64 = ctx.r[11].s64 + 4068;
	// 828E4CCC: 4850ED3D  bl 0x82df3a08
	ctx.lr = 0x828E4CD0;
	sub_82DF3A08(ctx, base);
	// 828E4CD0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828E4CD4: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 828E4CD8: 3BEB32AC  addi r31, r11, 0x32ac
	ctx.r[31].s64 = ctx.r[11].s64 + 12972;
	// 828E4CDC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E4CE0: 4850ED29  bl 0x82df3a08
	ctx.lr = 0x828E4CE4;
	sub_82DF3A08(ctx, base);
	// 828E4CE4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828E4CE8: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 828E4CEC: 3BCB32A0  addi r30, r11, 0x32a0
	ctx.r[30].s64 = ctx.r[11].s64 + 12960;
	// 828E4CF0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E4CF4: 4850ED15  bl 0x82df3a08
	ctx.lr = 0x828E4CF8;
	sub_82DF3A08(ctx, base);
	// 828E4CF8: 38C10064  addi r6, r1, 0x64
	ctx.r[6].s64 = ctx.r[1].s64 + 100;
	// 828E4CFC: 38A1006C  addi r5, r1, 0x6c
	ctx.r[5].s64 = ctx.r[1].s64 + 108;
	// 828E4D00: 809B0000  lwz r4, 0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E4D04: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 828E4D08: 4BCE3E91  bl 0x825c8b98
	ctx.lr = 0x828E4D0C;
	sub_825C8B98(ctx, base);
	// 828E4D0C: 808100D8  lwz r4, 0xd8(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(216 as u32) ) } as u64;
	// 828E4D10: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828E4D14: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828E4D18: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E4D1C: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 828E4D20: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E4D24: 4E800421  bctrl
	ctx.lr = 0x828E4D28;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E4D28: 806100DC  lwz r3, 0xdc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) } as u64;
	// 828E4D2C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E4D30: 419A0008  beq cr6, 0x828e4d38
	if ctx.cr[6].eq {
	pc = 0x828E4D38; continue 'dispatch;
	}
	// 828E4D34: 4B9DBB5D  bl 0x822c0890
	ctx.lr = 0x828E4D38;
	sub_822C0890(ctx, base);
	// 828E4D38: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 828E4D3C: 4850E6ED  bl 0x82df3428
	ctx.lr = 0x828E4D40;
	sub_82DF3428(ctx, base);
	// 828E4D40: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 828E4D44: 4850E6E5  bl 0x82df3428
	ctx.lr = 0x828E4D48;
	sub_82DF3428(ctx, base);
	// 828E4D48: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E4D4C: 4850E6DD  bl 0x82df3428
	ctx.lr = 0x828E4D50;
	sub_82DF3428(ctx, base);
	// 828E4D50: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828E4D54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E4D58: 3BAB3290  addi r29, r11, 0x3290
	ctx.r[29].s64 = ctx.r[11].s64 + 12944;
	// 828E4D5C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828E4D60: 4850ECA9  bl 0x82df3a08
	ctx.lr = 0x828E4D64;
	sub_82DF3A08(ctx, base);
	// 828E4D64: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 828E4D68: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E4D6C: 3B8B89A8  addi r28, r11, -0x7658
	ctx.r[28].s64 = ctx.r[11].s64 + -30296;
	// 828E4D70: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828E4D74: 4850EC95  bl 0x82df3a08
	ctx.lr = 0x828E4D78;
	sub_82DF3A08(ctx, base);
	// 828E4D78: 808100A0  lwz r4, 0xa0(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) } as u64;
	// 828E4D7C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828E4D80: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828E4D84: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 828E4D88: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E4D8C: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 828E4D90: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E4D94: 4E800421  bctrl
	ctx.lr = 0x828E4D98;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E4D98: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E4D9C: 4850E68D  bl 0x82df3428
	ctx.lr = 0x828E4DA0;
	sub_82DF3428(ctx, base);
	// 828E4DA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E4DA4: 4850E685  bl 0x82df3428
	ctx.lr = 0x828E4DA8;
	sub_82DF3428(ctx, base);
	// 828E4DA8: 816100BC  lwz r11, 0xbc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 828E4DAC: 814100B8  lwz r10, 0xb8(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) } as u64;
	// 828E4DB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E4DB4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828E4DB8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828E4DBC: 419A0024  beq cr6, 0x828e4de0
	if ctx.cr[6].eq {
	pc = 0x828E4DE0; continue 'dispatch;
	}
	// 828E4DC0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828E4DC4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E4DC8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E4DCC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E4DD0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828E4DD4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E4DD8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E4DDC: 4082FFE8  bne 0x828e4dc4
	if !ctx.cr[0].eq {
	pc = 0x828E4DC4; continue 'dispatch;
	}
	// 828E4DE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E4DE4: 4BFFF6FD  bl 0x828e44e0
	ctx.lr = 0x828E4DE8;
	sub_828E44E0(ctx, base);
	// 828E4DE8: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 828E4DEC: 814100A0  lwz r10, 0xa0(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) } as u64;
	// 828E4DF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E4DF4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828E4DF8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828E4DFC: 419A0024  beq cr6, 0x828e4e20
	if ctx.cr[6].eq {
	pc = 0x828E4E20; continue 'dispatch;
	}
	// 828E4E00: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828E4E04: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E4E08: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E4E0C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E4E10: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828E4E14: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E4E18: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E4E1C: 4082FFE8  bne 0x828e4e04
	if !ctx.cr[0].eq {
	pc = 0x828E4E04; continue 'dispatch;
	}
	// 828E4E20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E4E24: 4BFFF5D5  bl 0x828e43f8
	ctx.lr = 0x828E4E28;
	sub_828E43F8(ctx, base);
	// 828E4E28: 806100BC  lwz r3, 0xbc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 828E4E2C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E4E30: 419A0008  beq cr6, 0x828e4e38
	if ctx.cr[6].eq {
	pc = 0x828E4E38; continue 'dispatch;
	}
	// 828E4E34: 4B9DBA5D  bl 0x822c0890
	ctx.lr = 0x828E4E38;
	sub_822C0890(ctx, base);
	// 828E4E38: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 828E4E3C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E4E40: 419A0008  beq cr6, 0x828e4e48
	if ctx.cr[6].eq {
	pc = 0x828E4E48; continue 'dispatch;
	}
	// 828E4E44: 4B9DBA4D  bl 0x822c0890
	ctx.lr = 0x828E4E48;
	sub_822C0890(ctx, base);
	// 828E4E48: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E4E4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E4E50: 388B0FD8  addi r4, r11, 0xfd8
	ctx.r[4].s64 = ctx.r[11].s64 + 4056;
	// 828E4E54: 4850EBB5  bl 0x82df3a08
	ctx.lr = 0x828E4E58;
	sub_82DF3A08(ctx, base);
	// 828E4E58: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E4E5C: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828E4E60: 4850EBA9  bl 0x82df3a08
	ctx.lr = 0x828E4E64;
	sub_82DF3A08(ctx, base);
	// 828E4E64: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E4E68: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 828E4E6C: 4850EB9D  bl 0x82df3a08
	ctx.lr = 0x828E4E70;
	sub_82DF3A08(ctx, base);
	// 828E4E70: 38C1005C  addi r6, r1, 0x5c
	ctx.r[6].s64 = ctx.r[1].s64 + 92;
	// 828E4E74: 38A10074  addi r5, r1, 0x74
	ctx.r[5].s64 = ctx.r[1].s64 + 116;
	// 828E4E78: 809B0000  lwz r4, 0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E4E7C: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 828E4E80: 4BCE3D19  bl 0x825c8b98
	ctx.lr = 0x828E4E84;
	sub_825C8B98(ctx, base);
	// 828E4E84: 808100F0  lwz r4, 0xf0(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(240 as u32) ) } as u64;
	// 828E4E88: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828E4E8C: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 828E4E90: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E4E94: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 828E4E98: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E4E9C: 4E800421  bctrl
	ctx.lr = 0x828E4EA0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E4EA0: 806100F4  lwz r3, 0xf4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 828E4EA4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E4EA8: 419A0008  beq cr6, 0x828e4eb0
	if ctx.cr[6].eq {
	pc = 0x828E4EB0; continue 'dispatch;
	}
	// 828E4EAC: 4B9DB9E5  bl 0x822c0890
	ctx.lr = 0x828E4EB0;
	sub_822C0890(ctx, base);
	// 828E4EB0: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 828E4EB4: 4850E575  bl 0x82df3428
	ctx.lr = 0x828E4EB8;
	sub_82DF3428(ctx, base);
	// 828E4EB8: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828E4EBC: 4850E56D  bl 0x82df3428
	ctx.lr = 0x828E4EC0;
	sub_82DF3428(ctx, base);
	// 828E4EC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E4EC4: 4850E565  bl 0x82df3428
	ctx.lr = 0x828E4EC8;
	sub_82DF3428(ctx, base);
	// 828E4EC8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828E4ECC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E4ED0: 4850EB39  bl 0x82df3a08
	ctx.lr = 0x828E4ED4;
	sub_82DF3A08(ctx, base);
	// 828E4ED4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828E4ED8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E4EDC: 4850EB2D  bl 0x82df3a08
	ctx.lr = 0x828E4EE0;
	sub_82DF3A08(ctx, base);
	// 828E4EE0: 80810088  lwz r4, 0x88(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 828E4EE4: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 828E4EE8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828E4EEC: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 828E4EF0: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E4EF4: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 828E4EF8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E4EFC: 4E800421  bctrl
	ctx.lr = 0x828E4F00;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E4F00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E4F04: 4850E525  bl 0x82df3428
	ctx.lr = 0x828E4F08;
	sub_82DF3428(ctx, base);
	// 828E4F08: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E4F0C: 4850E51D  bl 0x82df3428
	ctx.lr = 0x828E4F10;
	sub_82DF3428(ctx, base);
	// 828E4F10: 816100CC  lwz r11, 0xcc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 828E4F14: 814100C8  lwz r10, 0xc8(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) } as u64;
	// 828E4F18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E4F1C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828E4F20: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828E4F24: 419A0024  beq cr6, 0x828e4f48
	if ctx.cr[6].eq {
	pc = 0x828E4F48; continue 'dispatch;
	}
	// 828E4F28: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828E4F2C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E4F30: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E4F34: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E4F38: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828E4F3C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E4F40: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E4F44: 4082FFE8  bne 0x828e4f2c
	if !ctx.cr[0].eq {
	pc = 0x828E4F2C; continue 'dispatch;
	}
	// 828E4F48: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E4F4C: 4BFFF6FD  bl 0x828e4648
	ctx.lr = 0x828E4F50;
	sub_828E4648(ctx, base);
	// 828E4F50: 8161008C  lwz r11, 0x8c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 828E4F54: 81410088  lwz r10, 0x88(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 828E4F58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E4F5C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828E4F60: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828E4F64: 419A0024  beq cr6, 0x828e4f88
	if ctx.cr[6].eq {
	pc = 0x828E4F88; continue 'dispatch;
	}
	// 828E4F68: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828E4F6C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E4F70: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E4F74: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E4F78: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828E4F7C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E4F80: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E4F84: 4082FFE8  bne 0x828e4f6c
	if !ctx.cr[0].eq {
	pc = 0x828E4F6C; continue 'dispatch;
	}
	// 828E4F88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E4F8C: 4BFFF5D5  bl 0x828e4560
	ctx.lr = 0x828E4F90;
	sub_828E4560(ctx, base);
	// 828E4F90: 806100CC  lwz r3, 0xcc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 828E4F94: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E4F98: 419A0008  beq cr6, 0x828e4fa0
	if ctx.cr[6].eq {
	pc = 0x828E4FA0; continue 'dispatch;
	}
	// 828E4F9C: 4B9DB8F5  bl 0x822c0890
	ctx.lr = 0x828E4FA0;
	sub_822C0890(ctx, base);
	// 828E4FA0: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 828E4FA4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E4FA8: 419A0008  beq cr6, 0x828e4fb0
	if ctx.cr[6].eq {
	pc = 0x828E4FB0; continue 'dispatch;
	}
	// 828E4FAC: 4B9DB8E5  bl 0x822c0890
	ctx.lr = 0x828E4FB0;
	sub_822C0890(ctx, base);
	// 828E4FB0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E4FB4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E4FB8: 388B0FC8  addi r4, r11, 0xfc8
	ctx.r[4].s64 = ctx.r[11].s64 + 4040;
	// 828E4FBC: 4850EA4D  bl 0x82df3a08
	ctx.lr = 0x828E4FC0;
	sub_82DF3A08(ctx, base);
	// 828E4FC0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E4FC4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828E4FC8: 4850EA41  bl 0x82df3a08
	ctx.lr = 0x828E4FCC;
	sub_82DF3A08(ctx, base);
	// 828E4FCC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E4FD0: 3861007C  addi r3, r1, 0x7c
	ctx.r[3].s64 = ctx.r[1].s64 + 124;
	// 828E4FD4: 4850EA35  bl 0x82df3a08
	ctx.lr = 0x828E4FD8;
	sub_82DF3A08(ctx, base);
	// 828E4FD8: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828E4FDC: 38A1007C  addi r5, r1, 0x7c
	ctx.r[5].s64 = ctx.r[1].s64 + 124;
	// 828E4FE0: 809B0000  lwz r4, 0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E4FE4: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 828E4FE8: 4BCE3BB1  bl 0x825c8b98
	ctx.lr = 0x828E4FEC;
	sub_825C8B98(ctx, base);
	// 828E4FEC: 808100E0  lwz r4, 0xe0(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(224 as u32) ) } as u64;
	// 828E4FF0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828E4FF4: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 828E4FF8: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E4FFC: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 828E5000: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E5004: 4E800421  bctrl
	ctx.lr = 0x828E5008;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E5008: 806100E4  lwz r3, 0xe4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(228 as u32) ) } as u64;
	// 828E500C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E5010: 419A0008  beq cr6, 0x828e5018
	if ctx.cr[6].eq {
	pc = 0x828E5018; continue 'dispatch;
	}
	// 828E5014: 4B9DB87D  bl 0x822c0890
	ctx.lr = 0x828E5018;
	sub_822C0890(ctx, base);
	// 828E5018: 3861007C  addi r3, r1, 0x7c
	ctx.r[3].s64 = ctx.r[1].s64 + 124;
	// 828E501C: 4850E40D  bl 0x82df3428
	ctx.lr = 0x828E5020;
	sub_82DF3428(ctx, base);
	// 828E5020: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828E5024: 4850E405  bl 0x82df3428
	ctx.lr = 0x828E5028;
	sub_82DF3428(ctx, base);
	// 828E5028: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E502C: 4850E3FD  bl 0x82df3428
	ctx.lr = 0x828E5030;
	sub_82DF3428(ctx, base);
	// 828E5030: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828E5034: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E5038: 4850E9D1  bl 0x82df3a08
	ctx.lr = 0x828E503C;
	sub_82DF3A08(ctx, base);
	// 828E503C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828E5040: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E5044: 4850E9C5  bl 0x82df3a08
	ctx.lr = 0x828E5048;
	sub_82DF3A08(ctx, base);
	// 828E5048: 80810090  lwz r4, 0x90(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 828E504C: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 828E5050: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828E5054: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 828E5058: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E505C: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 828E5060: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E5064: 4E800421  bctrl
	ctx.lr = 0x828E5068;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E5068: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E506C: 4850E3BD  bl 0x82df3428
	ctx.lr = 0x828E5070;
	sub_82DF3428(ctx, base);
	// 828E5070: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E5074: 4850E3B5  bl 0x82df3428
	ctx.lr = 0x828E5078;
	sub_82DF3428(ctx, base);
	// 828E5078: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 828E507C: 814100B0  lwz r10, 0xb0(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 828E5080: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E5084: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828E5088: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828E508C: 419A0024  beq cr6, 0x828e50b0
	if ctx.cr[6].eq {
	pc = 0x828E50B0; continue 'dispatch;
	}
	// 828E5090: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828E5094: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E5098: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E509C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E50A0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828E50A4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E50A8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E50AC: 4082FFE8  bne 0x828e5094
	if !ctx.cr[0].eq {
	pc = 0x828E5094; continue 'dispatch;
	}
	// 828E50B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E50B4: 4BFFF6FD  bl 0x828e47b0
	ctx.lr = 0x828E50B8;
	sub_828E47B0(ctx, base);
	// 828E50B8: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 828E50BC: 81410090  lwz r10, 0x90(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 828E50C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E50C4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828E50C8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828E50CC: 419A0024  beq cr6, 0x828e50f0
	if ctx.cr[6].eq {
	pc = 0x828E50F0; continue 'dispatch;
	}
	// 828E50D0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828E50D4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E50D8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E50DC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E50E0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828E50E4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E50E8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E50EC: 4082FFE8  bne 0x828e50d4
	if !ctx.cr[0].eq {
	pc = 0x828E50D4; continue 'dispatch;
	}
	// 828E50F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E50F4: 4BFFF5D5  bl 0x828e46c8
	ctx.lr = 0x828E50F8;
	sub_828E46C8(ctx, base);
	// 828E50F8: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 828E50FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E5100: 419A0008  beq cr6, 0x828e5108
	if ctx.cr[6].eq {
	pc = 0x828E5108; continue 'dispatch;
	}
	// 828E5104: 4B9DB78D  bl 0x822c0890
	ctx.lr = 0x828E5108;
	sub_822C0890(ctx, base);
	// 828E5108: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 828E510C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E5110: 419A0008  beq cr6, 0x828e5118
	if ctx.cr[6].eq {
	pc = 0x828E5118; continue 'dispatch;
	}
	// 828E5114: 4B9DB77D  bl 0x822c0890
	ctx.lr = 0x828E5118;
	sub_822C0890(ctx, base);
	// 828E5118: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E511C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E5120: 388B0FBC  addi r4, r11, 0xfbc
	ctx.r[4].s64 = ctx.r[11].s64 + 4028;
	// 828E5124: 4850E8E5  bl 0x82df3a08
	ctx.lr = 0x828E5128;
	sub_82DF3A08(ctx, base);
	// 828E5128: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E512C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828E5130: 4850E8D9  bl 0x82df3a08
	ctx.lr = 0x828E5134;
	sub_82DF3A08(ctx, base);
	// 828E5134: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E5138: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828E513C: 4850E8CD  bl 0x82df3a08
	ctx.lr = 0x828E5140;
	sub_82DF3A08(ctx, base);
	// 828E5140: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 828E5144: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 828E5148: 809B0000  lwz r4, 0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E514C: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 828E5150: 4BCE3A49  bl 0x825c8b98
	ctx.lr = 0x828E5154;
	sub_825C8B98(ctx, base);
	// 828E5154: 808100E8  lwz r4, 0xe8(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(232 as u32) ) } as u64;
	// 828E5158: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828E515C: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 828E5160: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E5164: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 828E5168: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E516C: 4E800421  bctrl
	ctx.lr = 0x828E5170;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E5170: 806100EC  lwz r3, 0xec(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(236 as u32) ) } as u64;
	// 828E5174: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E5178: 419A0008  beq cr6, 0x828e5180
	if ctx.cr[6].eq {
	pc = 0x828E5180; continue 'dispatch;
	}
	// 828E517C: 4B9DB715  bl 0x822c0890
	ctx.lr = 0x828E5180;
	sub_822C0890(ctx, base);
	// 828E5180: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828E5184: 4850E2A5  bl 0x82df3428
	ctx.lr = 0x828E5188;
	sub_82DF3428(ctx, base);
	// 828E5188: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828E518C: 4850E29D  bl 0x82df3428
	ctx.lr = 0x828E5190;
	sub_82DF3428(ctx, base);
	// 828E5190: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E5194: 4850E295  bl 0x82df3428
	ctx.lr = 0x828E5198;
	sub_82DF3428(ctx, base);
	// 828E5198: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828E519C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E51A0: 4850E869  bl 0x82df3a08
	ctx.lr = 0x828E51A4;
	sub_82DF3A08(ctx, base);
	// 828E51A4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828E51A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E51AC: 4850E85D  bl 0x82df3a08
	ctx.lr = 0x828E51B0;
	sub_82DF3A08(ctx, base);
	// 828E51B0: 80810098  lwz r4, 0x98(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 828E51B4: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 828E51B8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828E51BC: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 828E51C0: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E51C4: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 828E51C8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E51CC: 4E800421  bctrl
	ctx.lr = 0x828E51D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E51D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E51D4: 4850E255  bl 0x82df3428
	ctx.lr = 0x828E51D8;
	sub_82DF3428(ctx, base);
	// 828E51D8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E51DC: 4850E24D  bl 0x82df3428
	ctx.lr = 0x828E51E0;
	sub_82DF3428(ctx, base);
	// 828E51E0: 816100C4  lwz r11, 0xc4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 828E51E4: 814100C0  lwz r10, 0xc0(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) } as u64;
	// 828E51E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E51EC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828E51F0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828E51F4: 419A0024  beq cr6, 0x828e5218
	if ctx.cr[6].eq {
	pc = 0x828E5218; continue 'dispatch;
	}
	// 828E51F8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828E51FC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E5200: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E5204: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E5208: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828E520C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E5210: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E5214: 4082FFE8  bne 0x828e51fc
	if !ctx.cr[0].eq {
	pc = 0x828E51FC; continue 'dispatch;
	}
	// 828E5218: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E521C: 4BFFF6FD  bl 0x828e4918
	ctx.lr = 0x828E5220;
	sub_828E4918(ctx, base);
	// 828E5220: 8161009C  lwz r11, 0x9c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 828E5224: 81410098  lwz r10, 0x98(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 828E5228: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E522C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828E5230: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828E5234: 419A0024  beq cr6, 0x828e5258
	if ctx.cr[6].eq {
	pc = 0x828E5258; continue 'dispatch;
	}
	// 828E5238: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828E523C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E5240: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E5244: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E5248: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828E524C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E5250: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E5254: 4082FFE8  bne 0x828e523c
	if !ctx.cr[0].eq {
	pc = 0x828E523C; continue 'dispatch;
	}
	// 828E5258: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E525C: 4BFFF5D5  bl 0x828e4830
	ctx.lr = 0x828E5260;
	sub_828E4830(ctx, base);
	// 828E5260: 806100C4  lwz r3, 0xc4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 828E5264: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E5268: 419A0008  beq cr6, 0x828e5270
	if ctx.cr[6].eq {
	pc = 0x828E5270; continue 'dispatch;
	}
	// 828E526C: 4B9DB625  bl 0x822c0890
	ctx.lr = 0x828E5270;
	sub_822C0890(ctx, base);
	// 828E5270: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 828E5274: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E5278: 419A0008  beq cr6, 0x828e5280
	if ctx.cr[6].eq {
	pc = 0x828E5280; continue 'dispatch;
	}
	// 828E527C: 4B9DB615  bl 0x822c0890
	ctx.lr = 0x828E5280;
	sub_822C0890(ctx, base);
	// 828E5280: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E5284: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E5288: 388B0FAC  addi r4, r11, 0xfac
	ctx.r[4].s64 = ctx.r[11].s64 + 4012;
	// 828E528C: 4850E77D  bl 0x82df3a08
	ctx.lr = 0x828E5290;
	sub_82DF3A08(ctx, base);
	// 828E5290: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E5294: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828E5298: 4850E771  bl 0x82df3a08
	ctx.lr = 0x828E529C;
	sub_82DF3A08(ctx, base);
	// 828E529C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E52A0: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 828E52A4: 4850E765  bl 0x82df3a08
	ctx.lr = 0x828E52A8;
	sub_82DF3A08(ctx, base);
	// 828E52A8: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 828E52AC: 38A10078  addi r5, r1, 0x78
	ctx.r[5].s64 = ctx.r[1].s64 + 120;
	// 828E52B0: 809B0000  lwz r4, 0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E52B4: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 828E52B8: 4BCE38E1  bl 0x825c8b98
	ctx.lr = 0x828E52BC;
	sub_825C8B98(ctx, base);
	// 828E52BC: 808100F8  lwz r4, 0xf8(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(248 as u32) ) } as u64;
	// 828E52C0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828E52C4: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 828E52C8: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E52CC: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 828E52D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E52D4: 4E800421  bctrl
	ctx.lr = 0x828E52D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E52D8: 806100FC  lwz r3, 0xfc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(252 as u32) ) } as u64;
	// 828E52DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E52E0: 419A0008  beq cr6, 0x828e52e8
	if ctx.cr[6].eq {
	pc = 0x828E52E8; continue 'dispatch;
	}
	// 828E52E4: 4B9DB5AD  bl 0x822c0890
	ctx.lr = 0x828E52E8;
	sub_822C0890(ctx, base);
	// 828E52E8: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 828E52EC: 4850E13D  bl 0x82df3428
	ctx.lr = 0x828E52F0;
	sub_82DF3428(ctx, base);
	// 828E52F0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828E52F4: 4850E135  bl 0x82df3428
	ctx.lr = 0x828E52F8;
	sub_82DF3428(ctx, base);
	// 828E52F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E52FC: 4850E12D  bl 0x82df3428
	ctx.lr = 0x828E5300;
	sub_82DF3428(ctx, base);
	// 828E5300: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828E5304: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E5308: 4850E701  bl 0x82df3a08
	ctx.lr = 0x828E530C;
	sub_82DF3A08(ctx, base);
	// 828E530C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828E5310: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E5314: 4850E6F5  bl 0x82df3a08
	ctx.lr = 0x828E5318;
	sub_82DF3A08(ctx, base);
	// 828E5318: 808100A8  lwz r4, 0xa8(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) } as u64;
	// 828E531C: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 828E5320: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828E5324: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 828E5328: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E532C: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 828E5330: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E5334: 4E800421  bctrl
	ctx.lr = 0x828E5338;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E5338: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E533C: 4850E0ED  bl 0x82df3428
	ctx.lr = 0x828E5340;
	sub_82DF3428(ctx, base);
	// 828E5340: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E5344: 4850E0E5  bl 0x82df3428
	ctx.lr = 0x828E5348;
	sub_82DF3428(ctx, base);
	// 828E5348: 816100D4  lwz r11, 0xd4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 828E534C: 814100D0  lwz r10, 0xd0(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(208 as u32) ) } as u64;
	// 828E5350: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E5354: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828E5358: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828E535C: 419A0024  beq cr6, 0x828e5380
	if ctx.cr[6].eq {
	pc = 0x828E5380; continue 'dispatch;
	}
	// 828E5360: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828E5364: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E5368: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E536C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E5370: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828E5374: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E5378: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E537C: 4082FFE8  bne 0x828e5364
	if !ctx.cr[0].eq {
	pc = 0x828E5364; continue 'dispatch;
	}
	// 828E5380: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E5384: 4BFFF6FD  bl 0x828e4a80
	ctx.lr = 0x828E5388;
	sub_828E4A80(ctx, base);
	// 828E5388: 816100AC  lwz r11, 0xac(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 828E538C: 814100A8  lwz r10, 0xa8(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) } as u64;
	// 828E5390: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E5394: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828E5398: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828E539C: 419A0024  beq cr6, 0x828e53c0
	if ctx.cr[6].eq {
	pc = 0x828E53C0; continue 'dispatch;
	}
	// 828E53A0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828E53A4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E53A8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E53AC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E53B0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828E53B4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E53B8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E53BC: 4082FFE8  bne 0x828e53a4
	if !ctx.cr[0].eq {
	pc = 0x828E53A4; continue 'dispatch;
	}
	// 828E53C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E53C4: 4BFFF5D5  bl 0x828e4998
	ctx.lr = 0x828E53C8;
	sub_828E4998(ctx, base);
	// 828E53C8: 806100D4  lwz r3, 0xd4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 828E53CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E53D0: 419A0008  beq cr6, 0x828e53d8
	if ctx.cr[6].eq {
	pc = 0x828E53D8; continue 'dispatch;
	}
	// 828E53D4: 4B9DB4BD  bl 0x822c0890
	ctx.lr = 0x828E53D8;
	sub_822C0890(ctx, base);
	// 828E53D8: 806100AC  lwz r3, 0xac(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 828E53DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E53E0: 419A0008  beq cr6, 0x828e53e8
	if ctx.cr[6].eq {
	pc = 0x828E53E8; continue 'dispatch;
	}
	// 828E53E4: 4B9DB4AD  bl 0x822c0890
	ctx.lr = 0x828E53E8;
	sub_822C0890(ctx, base);
	// 828E53E8: 807B0004  lwz r3, 4(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E53EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E53F0: 419A0008  beq cr6, 0x828e53f8
	if ctx.cr[6].eq {
	pc = 0x828E53F8; continue 'dispatch;
	}
	// 828E53F4: 4B9DB49D  bl 0x822c0890
	ctx.lr = 0x828E53F8;
	sub_822C0890(ctx, base);
	// 828E53F8: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 828E53FC: 488C2DB8  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E5400(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E5400 size=644
    let mut pc: u32 = 0x828E5400;
    'dispatch: loop {
        match pc {
            0x828E5400 => {
    //   block [0x828E5400..0x828E5684)
	// 828E5400: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E5404: 488C2D5D  bl 0x831a8160
	ctx.lr = 0x828E5408;
	sub_831A8130(ctx, base);
	// 828E5408: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E540C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828E5410: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828E5414: 4805DF45  bl 0x82943358
	ctx.lr = 0x828E5418;
	sub_82943358(ctx, base);
	// 828E5418: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 828E541C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E5420: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828E5424: 3B8B0FF0  addi r28, r11, 0xff0
	ctx.r[28].s64 = ctx.r[11].s64 + 4080;
	// 828E5428: 38A00318  li r5, 0x318
	ctx.r[5].s64 = 792;
	// 828E542C: C00A4C5C  lfs f0, 0x4c5c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(19548 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828E5430: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828E5434: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 828E5438: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 828E543C: 4B9DAF9D  bl 0x822c03d8
	ctx.lr = 0x828E5440;
	sub_822C03D8(ctx, base);
	// 828E5440: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828E5444: 41820018  beq 0x828e545c
	if ctx.cr[0].eq {
	pc = 0x828E545C; continue 'dispatch;
	}
	// 828E5448: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 828E544C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E5450: 4805DF39  bl 0x82943388
	ctx.lr = 0x828E5454;
	sub_82943388(ctx, base);
	// 828E5454: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E5458: 48000008  b 0x828e5460
	pc = 0x828E5460; continue 'dispatch;
	// 828E545C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828E5460: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828E5464: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E5468: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828E546C: 4BF8CA4D  bl 0x82871eb8
	ctx.lr = 0x828E5470;
	sub_82871EB8(ctx, base);
	// 828E5470: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828E5474: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E5478: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828E547C: 4B9DAB85  bl 0x822c0000
	ctx.lr = 0x828E5480;
	sub_822C0000(ctx, base);
	// 828E5480: 83410054  lwz r26, 0x54(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828E5484: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828E5488: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 828E548C: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	// 828E5490: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828E5494: 419A0024  beq cr6, 0x828e54b8
	if ctx.cr[6].eq {
	pc = 0x828E54B8; continue 'dispatch;
	}
	// 828E5498: 397A0004  addi r11, r26, 4
	ctx.r[11].s64 = ctx.r[26].s64 + 4;
	// 828E549C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E54A0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E54A4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E54A8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828E54AC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E54B0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E54B4: 4082FFE8  bne 0x828e549c
	if !ctx.cr[0].eq {
	pc = 0x828E549C; continue 'dispatch;
	}
	// 828E54B8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E54BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E54C0: 4805AFF1  bl 0x829404b0
	ctx.lr = 0x828E54C4;
	sub_829404B0(ctx, base);
	// 828E54C4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828E54C8: 4805BF69  bl 0x82941430
	ctx.lr = 0x828E54CC;
	sub_82941430(ctx, base);
	// 828E54CC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828E54D0: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 828E54D4: 3FA08208  lis r29, -0x7df8
	ctx.r[29].s64 = -2113404928;
	// 828E54D8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828E54DC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828E54E0: C1AB6154  lfs f13, 0x6154(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24916 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828E54E4: 38A00320  li r5, 0x320
	ctx.r[5].s64 = 800;
	// 828E54E8: C18A6150  lfs f12, 0x6150(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24912 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828E54EC: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 828E54F0: C01D614C  lfs f0, 0x614c(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24908 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828E54F4: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 828E54F8: D1A10084  stfs f13, 0x84(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 828E54FC: D1810088  stfs f12, 0x88(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 828E5500: 4B9DAED9  bl 0x822c03d8
	ctx.lr = 0x828E5504;
	sub_822C03D8(ctx, base);
	// 828E5504: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828E5508: 41820018  beq 0x828e5520
	if ctx.cr[0].eq {
	pc = 0x828E5520; continue 'dispatch;
	}
	// 828E550C: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 828E5510: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E5514: 4805C9F5  bl 0x82941f08
	ctx.lr = 0x828E5518;
	sub_82941F08(ctx, base);
	// 828E5518: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E551C: 48000008  b 0x828e5524
	pc = 0x828E5524; continue 'dispatch;
	// 828E5520: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828E5524: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828E5528: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E552C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828E5530: 4BF8D879  bl 0x82872da8
	ctx.lr = 0x828E5534;
	sub_82872DA8(ctx, base);
	// 828E5534: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828E5538: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E553C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828E5540: 4B9DAAC1  bl 0x822c0000
	ctx.lr = 0x828E5544;
	sub_822C0000(ctx, base);
	// 828E5544: 83610054  lwz r27, 0x54(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828E5548: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828E554C: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 828E5550: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 828E5554: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828E5558: 419A0024  beq cr6, 0x828e557c
	if ctx.cr[6].eq {
	pc = 0x828E557C; continue 'dispatch;
	}
	// 828E555C: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 828E5560: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E5564: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E5568: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E556C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828E5570: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E5574: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E5578: 4082FFE8  bne 0x828e5560
	if !ctx.cr[0].eq {
	pc = 0x828E5560; continue 'dispatch;
	}
	// 828E557C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E5580: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E5584: 4805AF2D  bl 0x829404b0
	ctx.lr = 0x828E5588;
	sub_829404B0(ctx, base);
	// 828E5588: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828E558C: 4805D365  bl 0x829428f0
	ctx.lr = 0x828E5590;
	sub_829428F0(ctx, base);
	// 828E5590: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828E5594: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 828E5598: C01D614C  lfs f0, 0x614c(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24908 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828E559C: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828E55A0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828E55A4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828E55A8: 38A00329  li r5, 0x329
	ctx.r[5].s64 = 809;
	// 828E55AC: C1ABC664  lfs f13, -0x399c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-14748 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828E55B0: 38600040  li r3, 0x40
	ctx.r[3].s64 = 64;
	// 828E55B4: C00A9524  lfs f0, -0x6adc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828E55B8: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 828E55BC: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 828E55C0: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 828E55C4: 4B9DAE15  bl 0x822c03d8
	ctx.lr = 0x828E55C8;
	sub_822C03D8(ctx, base);
	// 828E55C8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828E55CC: 41820018  beq 0x828e55e4
	if ctx.cr[0].eq {
	pc = 0x828E55E4; continue 'dispatch;
	}
	// 828E55D0: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828E55D4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E55D8: 4805D349  bl 0x82942920
	ctx.lr = 0x828E55DC;
	sub_82942920(ctx, base);
	// 828E55DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E55E0: 48000008  b 0x828e55e8
	pc = 0x828E55E8; continue 'dispatch;
	// 828E55E4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828E55E8: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828E55EC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E55F0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828E55F4: 4BF8C98D  bl 0x82871f80
	ctx.lr = 0x828E55F8;
	sub_82871F80(ctx, base);
	// 828E55F8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828E55FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E5600: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828E5604: 4B9DA9FD  bl 0x822c0000
	ctx.lr = 0x828E5608;
	sub_822C0000(ctx, base);
	// 828E5608: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828E560C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828E5610: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828E5614: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 828E5618: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828E561C: 419A0024  beq cr6, 0x828e5640
	if ctx.cr[6].eq {
	pc = 0x828E5640; continue 'dispatch;
	}
	// 828E5620: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 828E5624: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E5628: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E562C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E5630: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828E5634: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E5638: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E563C: 4082FFE8  bne 0x828e5624
	if !ctx.cr[0].eq {
	pc = 0x828E5624; continue 'dispatch;
	}
	// 828E5640: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E5644: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E5648: 4805AE69  bl 0x829404b0
	ctx.lr = 0x828E564C;
	sub_829404B0(ctx, base);
	// 828E564C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828E5650: 419A000C  beq cr6, 0x828e565c
	if ctx.cr[6].eq {
	pc = 0x828E565C; continue 'dispatch;
	}
	// 828E5654: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E5658: 4B9DB239  bl 0x822c0890
	ctx.lr = 0x828E565C;
	sub_822C0890(ctx, base);
	// 828E565C: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 828E5660: 419A000C  beq cr6, 0x828e566c
	if ctx.cr[6].eq {
	pc = 0x828E566C; continue 'dispatch;
	}
	// 828E5664: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828E5668: 4B9DB229  bl 0x822c0890
	ctx.lr = 0x828E566C;
	sub_822C0890(ctx, base);
	// 828E566C: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 828E5670: 419A000C  beq cr6, 0x828e567c
	if ctx.cr[6].eq {
	pc = 0x828E567C; continue 'dispatch;
	}
	// 828E5674: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828E5678: 4B9DB219  bl 0x822c0890
	ctx.lr = 0x828E567C;
	sub_822C0890(ctx, base);
	// 828E567C: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 828E5680: 488C2B30  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E5688(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E5688 size=272
    let mut pc: u32 = 0x828E5688;
    'dispatch: loop {
        match pc {
            0x828E5688 => {
    //   block [0x828E5688..0x828E5798)
	// 828E5688: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E568C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E5690: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E5694: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E5698: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E569C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E56A0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828E56A4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828E56A8: 4805CC69  bl 0x82942310
	ctx.lr = 0x828E56AC;
	sub_82942310(ctx, base);
	// 828E56AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E56B0: 4BF06AB1  bl 0x827ec160
	ctx.lr = 0x828E56B4;
	sub_827EC160(ctx, base);
	// 828E56B4: 4BF0A085  bl 0x827ef738
	ctx.lr = 0x828E56B8;
	sub_827EF738(ctx, base);
	// 828E56B8: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 828E56BC: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 828E56C0: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 828E56C4: 3D008209  lis r8, -0x7df7
	ctx.r[8].s64 = -2113339392;
	// 828E56C8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828E56CC: 13E358C7  vcmpequd (lvx128) v31, v3, v11
	tmp.u32 = ctx.r[3].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828E56D0: 38880FF0  addi r4, r8, 0xff0
	ctx.r[4].s64 = ctx.r[8].s64 + 4080;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E5798(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E5798 size=108
    let mut pc: u32 = 0x828E5798;
    'dispatch: loop {
        match pc {
            0x828E5798 => {
    //   block [0x828E5798..0x828E5804)
	// 828E5798: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E579C: 488C29D1  bl 0x831a816c
	ctx.lr = 0x828E57A0;
	sub_831A8130(ctx, base);
	// 828E57A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E57A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E57A8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828E57AC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828E57B0: 80BF03F0  lwz r5, 0x3f0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1008 as u32) ) } as u64;
	// 828E57B4: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 828E57B8: 419A000C  beq cr6, 0x828e57c4
	if ctx.cr[6].eq {
	pc = 0x828E57C4; continue 'dispatch;
	}
	// 828E57BC: 4BF06AD5  bl 0x827ec290
	ctx.lr = 0x828E57C0;
	sub_827EC290(ctx, base);
	// 828E57C0: 93DF03F0  stw r30, 0x3f0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1008 as u32), ctx.r[30].u32 ) };
	// 828E57C4: 807F03D4  lwz r3, 0x3d4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(980 as u32) ) } as u64;
	// 828E57C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E57CC: 419A0030  beq cr6, 0x828e57fc
	if ctx.cr[6].eq {
	pc = 0x828E57FC; continue 'dispatch;
	}
	// 828E57D0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E57D4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828E57D8: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 828E57DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E57E0: 4E800421  bctrl
	ctx.lr = 0x828E57E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E57E4: 93DF03D4  stw r30, 0x3d4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(980 as u32), ctx.r[30].u32 ) };
	// 828E57E8: 807F03D8  lwz r3, 0x3d8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(984 as u32) ) } as u64;
	// 828E57EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E57F0: 93DF03D8  stw r30, 0x3d8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(984 as u32), ctx.r[30].u32 ) };
	// 828E57F4: 419A0008  beq cr6, 0x828e57fc
	if ctx.cr[6].eq {
	pc = 0x828E57FC; continue 'dispatch;
	}
	// 828E57F8: 4B9DB099  bl 0x822c0890
	ctx.lr = 0x828E57FC;
	sub_822C0890(ctx, base);
	// 828E57FC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E5800: 488C29BC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E5808(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E5808 size=204
    let mut pc: u32 = 0x828E5808;
    'dispatch: loop {
        match pc {
            0x828E5808 => {
    //   block [0x828E5808..0x828E58D4)
	// 828E5808: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E580C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E5810: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E5814: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E5818: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E581C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E5820: 54AB063F  clrlwi. r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E5824: 807E0400  lwz r3, 0x400(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1024 as u32) ) } as u64;
	// 828E5828: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E582C: 4182006C  beq 0x828e5898
	if ctx.cr[0].eq {
	pc = 0x828E5898; continue 'dispatch;
	}
	// 828E5830: 3BFE0400  addi r31, r30, 0x400
	ctx.r[31].s64 = ctx.r[30].s64 + 1024;
	// 828E5834: 419A0024  beq cr6, 0x828e5858
	if ctx.cr[6].eq {
	pc = 0x828E5858; continue 'dispatch;
	}
	// 828E5838: 48260E91  bl 0x82b466c8
	ctx.lr = 0x828E583C;
	sub_82B466C8(ctx, base);
	// 828E583C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E5840: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E5844: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E5848: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E584C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828E5850: 419A0008  beq cr6, 0x828e5858
	if ctx.cr[6].eq {
	pc = 0x828E5858; continue 'dispatch;
	}
	// 828E5854: 4B9DB03D  bl 0x822c0890
	ctx.lr = 0x828E5858;
	sub_822C0890(ctx, base);
	// 828E5858: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E585C: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828E5860: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E5864: 38AA1054  addi r5, r10, 0x1054
	ctx.r[5].s64 = ctx.r[10].s64 + 4180;
	// 828E5868: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E586C: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 828E5870: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E5874: 4E800421  bctrl
	ctx.lr = 0x828E5878;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E5878: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828E587C: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 828E5880: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 828E5884: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E5888: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E588C: 4B9DEBD5  bl 0x822c4460
	ctx.lr = 0x828E5890;
	sub_822C4460(ctx, base);
	// 828E5890: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828E5894: 4800001C  b 0x828e58b0
	pc = 0x828E58B0; continue 'dispatch;
	// 828E5898: 419A0024  beq cr6, 0x828e58bc
	if ctx.cr[6].eq {
	pc = 0x828E58BC; continue 'dispatch;
	}
	// 828E589C: 48260E2D  bl 0x82b466c8
	ctx.lr = 0x828E58A0;
	sub_82B466C8(ctx, base);
	// 828E58A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E58A4: 917E0400  stw r11, 0x400(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(1024 as u32), ctx.r[11].u32 ) };
	// 828E58A8: 807E0404  lwz r3, 0x404(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1028 as u32) ) } as u64;
	// 828E58AC: 917E0404  stw r11, 0x404(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(1028 as u32), ctx.r[11].u32 ) };
	// 828E58B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E58B4: 419A0008  beq cr6, 0x828e58bc
	if ctx.cr[6].eq {
	pc = 0x828E58BC; continue 'dispatch;
	}
	// 828E58B8: 4B9DAFD9  bl 0x822c0890
	ctx.lr = 0x828E58BC;
	sub_822C0890(ctx, base);
	// 828E58BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E58C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E58C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E58C8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E58CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E58D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E58D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E58D8 size=628
    let mut pc: u32 = 0x828E58D8;
    'dispatch: loop {
        match pc {
            0x828E58D8 => {
    //   block [0x828E58D8..0x828E5B4C)
	// 828E58D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E58DC: 488C2889  bl 0x831a8164
	ctx.lr = 0x828E58E0;
	sub_831A8130(ctx, base);
	// 828E58E0: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 828E58E4: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E58E8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828E58EC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828E58F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E58F4: 4BFFE605  bl 0x828e3ef8
	ctx.lr = 0x828E58F8;
	sub_828E3EF8(ctx, base);
	// 828E58F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E58FC: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828E5900: 4BFFE2A9  bl 0x828e3ba8
	ctx.lr = 0x828E5904;
	sub_828E3BA8(ctx, base);
	// 828E5904: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828E5908: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 828E590C: 396B6880  addi r11, r11, 0x6880
	ctx.r[11].s64 = ctx.r[11].s64 + 26752;
	// 828E5910: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 828E5914: 39000030  li r8, 0x30
	ctx.r[8].s64 = 48;
	// 828E5918: 38E100D0  addi r7, r1, 0xd0
	ctx.r[7].s64 = ctx.r[1].s64 + 208;
	// 828E591C: 38C100E0  addi r6, r1, 0xe0
	ctx.r[6].s64 = ctx.r[1].s64 + 224;
	// 828E5920: 38A100F0  addi r5, r1, 0xf0
	ctx.r[5].s64 = ctx.r[1].s64 + 240;
	// 828E5924: 13E05C07  vcmpneb. (lvlx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828E5928: 3BC10100  addi r30, r1, 0x100
	ctx.r[30].s64 = ctx.r[1].s64 + 256;
	// 828E592C: 13CA5C07  vcmpneb. (lvlx128) v30, v10, v11
	tmp.u32 = ctx.r[10].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828E5930: 13A95C07  vcmpneb. (lvlx128) v29, v9, v11
	tmp.u32 = ctx.r[9].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828E5934: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 828E5938: 13885C07  vcmpneb. (lvlx128) v28, v8, v11
	tmp.u32 = ctx.r[8].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828E593C: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E5B50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E5B50 size=628
    let mut pc: u32 = 0x828E5B50;
    'dispatch: loop {
        match pc {
            0x828E5B50 => {
    //   block [0x828E5B50..0x828E5DC4)
	// 828E5B50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E5B54: 488C2611  bl 0x831a8164
	ctx.lr = 0x828E5B58;
	sub_831A8130(ctx, base);
	// 828E5B58: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 828E5B5C: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E5B60: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828E5B64: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828E5B68: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E5B6C: 4BFFE38D  bl 0x828e3ef8
	ctx.lr = 0x828E5B70;
	sub_828E3EF8(ctx, base);
	// 828E5B70: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E5B74: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828E5B78: 4BFFE031  bl 0x828e3ba8
	ctx.lr = 0x828E5B7C;
	sub_828E3BA8(ctx, base);
	// 828E5B7C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828E5B80: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 828E5B84: 396B6880  addi r11, r11, 0x6880
	ctx.r[11].s64 = ctx.r[11].s64 + 26752;
	// 828E5B88: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 828E5B8C: 39000030  li r8, 0x30
	ctx.r[8].s64 = 48;
	// 828E5B90: 38E100D0  addi r7, r1, 0xd0
	ctx.r[7].s64 = ctx.r[1].s64 + 208;
	// 828E5B94: 38C100E0  addi r6, r1, 0xe0
	ctx.r[6].s64 = ctx.r[1].s64 + 224;
	// 828E5B98: 38A100F0  addi r5, r1, 0xf0
	ctx.r[5].s64 = ctx.r[1].s64 + 240;
	// 828E5B9C: 13E05C07  vcmpneb. (lvlx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828E5BA0: 3BC10100  addi r30, r1, 0x100
	ctx.r[30].s64 = ctx.r[1].s64 + 256;
	// 828E5BA4: 13CA5C07  vcmpneb. (lvlx128) v30, v10, v11
	tmp.u32 = ctx.r[10].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828E5BA8: 13A95C07  vcmpneb. (lvlx128) v29, v9, v11
	tmp.u32 = ctx.r[9].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828E5BAC: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 828E5BB0: 13885C07  vcmpneb. (lvlx128) v28, v8, v11
	tmp.u32 = ctx.r[8].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828E5BB4: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E5DC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E5DC8 size=128
    let mut pc: u32 = 0x828E5DC8;
    'dispatch: loop {
        match pc {
            0x828E5DC8 => {
    //   block [0x828E5DC8..0x828E5E48)
	// 828E5DC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E5DCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E5DD0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E5DD4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E5DD8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E5DDC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828E5DE0: 38800013  li r4, 0x13
	ctx.r[4].s64 = 19;
	// 828E5DE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E5DE8: 48023009  bl 0x82908df0
	ctx.lr = 0x828E5DEC;
	sub_82908DF0(ctx, base);
	// 828E5DEC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E5DF0: 41820040  beq 0x828e5e30
	if ctx.cr[0].eq {
	pc = 0x828E5E30; continue 'dispatch;
	}
	// 828E5DF4: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 828E5DF8: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 828E5DFC: 409A0034  bne cr6, 0x828e5e30
	if !ctx.cr[6].eq {
	pc = 0x828E5E30; continue 'dispatch;
	}
	// 828E5E00: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E5E04: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E5E08: 4BC296C1  bl 0x8250f4c8
	ctx.lr = 0x828E5E0C;
	sub_8250F4C8(ctx, base);
	// 828E5E0C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E5E10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E5E14: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 828E5E18: 409A0008  bne cr6, 0x828e5e20
	if !ctx.cr[6].eq {
	pc = 0x828E5E20; continue 'dispatch;
	}
	// 828E5E1C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828E5E20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E5E24: 4BFFF975  bl 0x828e5798
	ctx.lr = 0x828E5E28;
	sub_828E5798(ctx, base);
	// 828E5E28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E5E2C: 4850BE65  bl 0x82df1c90
	ctx.lr = 0x828E5E30;
	sub_82DF1C90(ctx, base);
	// 828E5E30: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E5E34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E5E38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E5E3C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E5E40: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E5E44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E5E48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E5E48 size=112
    let mut pc: u32 = 0x828E5E48;
    'dispatch: loop {
        match pc {
            0x828E5E48 => {
    //   block [0x828E5E48..0x828E5EB8)
	// 828E5E48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E5E4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E5E50: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E5E54: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E5E58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E5E5C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828E5E60: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E5E64: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828E5E68: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828E5E6C: 4BFFD45D  bl 0x828e32c8
	ctx.lr = 0x828E5E70;
	sub_828E32C8(ctx, base);
	// 828E5E70: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828E5E74: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E5E78: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828E5E7C: 4B9DA185  bl 0x822c0000
	ctx.lr = 0x828E5E80;
	sub_822C0000(ctx, base);
	// 828E5E80: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828E5E84: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828E5E88: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E5E8C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E5E90: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E5E94: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828E5E98: 419A0008  beq cr6, 0x828e5ea0
	if ctx.cr[6].eq {
	pc = 0x828E5EA0; continue 'dispatch;
	}
	// 828E5E9C: 4B9DA9F5  bl 0x822c0890
	ctx.lr = 0x828E5EA0;
	sub_822C0890(ctx, base);
	// 828E5EA0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E5EA4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E5EA8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E5EAC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E5EB0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E5EB4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E5EB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E5EB8 size=112
    let mut pc: u32 = 0x828E5EB8;
    'dispatch: loop {
        match pc {
            0x828E5EB8 => {
    //   block [0x828E5EB8..0x828E5F28)
	// 828E5EB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E5EBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E5EC0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E5EC4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E5EC8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E5ECC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828E5ED0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E5ED4: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828E5ED8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828E5EDC: 4BFFD4B5  bl 0x828e3390
	ctx.lr = 0x828E5EE0;
	sub_828E3390(ctx, base);
	// 828E5EE0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828E5EE4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E5EE8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828E5EEC: 4B9DA115  bl 0x822c0000
	ctx.lr = 0x828E5EF0;
	sub_822C0000(ctx, base);
	// 828E5EF0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828E5EF4: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828E5EF8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E5EFC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E5F00: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E5F04: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828E5F08: 419A0008  beq cr6, 0x828e5f10
	if ctx.cr[6].eq {
	pc = 0x828E5F10; continue 'dispatch;
	}
	// 828E5F0C: 4B9DA985  bl 0x822c0890
	ctx.lr = 0x828E5F10;
	sub_822C0890(ctx, base);
	// 828E5F10: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E5F14: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E5F18: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E5F1C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E5F20: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E5F24: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E5F28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E5F28 size=128
    let mut pc: u32 = 0x828E5F28;
    'dispatch: loop {
        match pc {
            0x828E5F28 => {
    //   block [0x828E5F28..0x828E5FA8)
	// 828E5F28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E5F2C: 488C2241  bl 0x831a816c
	ctx.lr = 0x828E5F30;
	sub_831A8130(ctx, base);
	// 828E5F30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E5F34: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828E5F38: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828E5F3C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828E5F40: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828E5F44: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828E5F48: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 828E5F4C: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 828E5F50: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 828E5F54: 4850C495  bl 0x82df23e8
	ctx.lr = 0x828E5F58;
	sub_82DF23E8(ctx, base);
	// 828E5F58: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828E5F5C: 41820018  beq 0x828e5f74
	if ctx.cr[0].eq {
	pc = 0x828E5F74; continue 'dispatch;
	}
	// 828E5F60: 80BE0000  lwz r5, 0(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E5F64: 889F0000  lbz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E5F68: 4BF1F179  bl 0x828050e0
	ctx.lr = 0x828E5F6C;
	sub_828050E0(ctx, base);
	// 828E5F6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E5F70: 48000008  b 0x828e5f78
	pc = 0x828E5F78; continue 'dispatch;
	// 828E5F74: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828E5F78: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828E5F7C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828E5F80: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E5F84: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E5F88: 4BFFD4D1  bl 0x828e3458
	ctx.lr = 0x828E5F8C;
	sub_828E3458(ctx, base);
	// 828E5F8C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828E5F90: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E5F94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E5F98: 4B9DA069  bl 0x822c0000
	ctx.lr = 0x828E5F9C;
	sub_822C0000(ctx, base);
	// 828E5F9C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828E5FA0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E5FA4: 488C2218  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E5FA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E5FA8 size=112
    let mut pc: u32 = 0x828E5FA8;
    'dispatch: loop {
        match pc {
            0x828E5FA8 => {
    //   block [0x828E5FA8..0x828E6018)
	// 828E5FA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E5FAC: 488C21C1  bl 0x831a816c
	ctx.lr = 0x828E5FB0;
	sub_831A8130(ctx, base);
	// 828E5FB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E5FB4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828E5FB8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828E5FBC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828E5FC0: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 828E5FC4: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 828E5FC8: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 828E5FCC: 4850C41D  bl 0x82df23e8
	ctx.lr = 0x828E5FD0;
	sub_82DF23E8(ctx, base);
	// 828E5FD0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828E5FD4: 41820010  beq 0x828e5fe4
	if ctx.cr[0].eq {
	pc = 0x828E5FE4; continue 'dispatch;
	}
	// 828E5FD8: 4802FA41  bl 0x82915a18
	ctx.lr = 0x828E5FDC;
	sub_82915A18(ctx, base);
	// 828E5FDC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E5FE0: 48000008  b 0x828e5fe8
	pc = 0x828E5FE8; continue 'dispatch;
	// 828E5FE4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828E5FE8: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828E5FEC: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828E5FF0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E5FF4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E5FF8: 4BFFD529  bl 0x828e3520
	ctx.lr = 0x828E5FFC;
	sub_828E3520(ctx, base);
	// 828E5FFC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828E6000: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E6004: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E6008: 4B9D9FF9  bl 0x822c0000
	ctx.lr = 0x828E600C;
	sub_822C0000(ctx, base);
	// 828E600C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828E6010: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E6014: 488C21A8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E6018(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E6018 size=128
    let mut pc: u32 = 0x828E6018;
    'dispatch: loop {
        match pc {
            0x828E6018 => {
    //   block [0x828E6018..0x828E6098)
	// 828E6018: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E601C: 488C2151  bl 0x831a816c
	ctx.lr = 0x828E6020;
	sub_831A8130(ctx, base);
	// 828E6020: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E6024: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828E6028: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828E602C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828E6030: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828E6034: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828E6038: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 828E603C: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 828E6040: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 828E6044: 4850C3A5  bl 0x82df23e8
	ctx.lr = 0x828E6048;
	sub_82DF23E8(ctx, base);
	// 828E6048: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828E604C: 41820018  beq 0x828e6064
	if ctx.cr[0].eq {
	pc = 0x828E6064; continue 'dispatch;
	}
	// 828E6050: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E6054: C03E0000  lfs f1, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828E6058: 4826D209  bl 0x82b53260
	ctx.lr = 0x828E605C;
	sub_82B53260(ctx, base);
	// 828E605C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E6060: 48000008  b 0x828e6068
	pc = 0x828E6068; continue 'dispatch;
	// 828E6064: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828E6068: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828E606C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828E6070: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E6074: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E6078: 4BFFD571  bl 0x828e35e8
	ctx.lr = 0x828E607C;
	sub_828E35E8(ctx, base);
	// 828E607C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828E6080: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E6084: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E6088: 4B9D9F79  bl 0x822c0000
	ctx.lr = 0x828E608C;
	sub_822C0000(ctx, base);
	// 828E608C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828E6090: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E6094: 488C2128  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E6098(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E6098 size=136
    let mut pc: u32 = 0x828E6098;
    'dispatch: loop {
        match pc {
            0x828E6098 => {
    //   block [0x828E6098..0x828E6120)
	// 828E6098: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E609C: 488C20CD  bl 0x831a8168
	ctx.lr = 0x828E60A0;
	sub_831A8130(ctx, base);
	// 828E60A0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E60A4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828E60A8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828E60AC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828E60B0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828E60B4: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 828E60B8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828E60BC: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 828E60C0: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 828E60C4: 38600050  li r3, 0x50
	ctx.r[3].s64 = 80;
	// 828E60C8: 4850C321  bl 0x82df23e8
	ctx.lr = 0x828E60CC;
	sub_82DF23E8(ctx, base);
	// 828E60CC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828E60D0: 4182001C  beq 0x828e60ec
	if ctx.cr[0].eq {
	pc = 0x828E60EC; continue 'dispatch;
	}
	// 828E60D4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828E60D8: C03D0000  lfs f1, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828E60DC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E60E0: 48030191  bl 0x82916270
	ctx.lr = 0x828E60E4;
	sub_82916270(ctx, base);
	// 828E60E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E60E8: 48000008  b 0x828e60f0
	pc = 0x828E60F0; continue 'dispatch;
	// 828E60EC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828E60F0: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828E60F4: 3BDC0004  addi r30, r28, 4
	ctx.r[30].s64 = ctx.r[28].s64 + 4;
	// 828E60F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E60FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E6100: 4BFFD5B1  bl 0x828e36b0
	ctx.lr = 0x828E6104;
	sub_828E36B0(ctx, base);
	// 828E6104: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828E6108: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E610C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E6110: 4B9D9EF1  bl 0x822c0000
	ctx.lr = 0x828E6114;
	sub_822C0000(ctx, base);
	// 828E6114: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828E6118: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828E611C: 488C209C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E6120(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E6120 size=144
    let mut pc: u32 = 0x828E6120;
    'dispatch: loop {
        match pc {
            0x828E6120 => {
    //   block [0x828E6120..0x828E61B0)
	// 828E6120: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E6124: 488C2041  bl 0x831a8164
	ctx.lr = 0x828E6128;
	sub_831A8130(ctx, base);
	// 828E6128: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E612C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828E6130: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828E6134: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828E6138: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828E613C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 828E6140: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828E6144: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 828E6148: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 828E614C: 38600050  li r3, 0x50
	ctx.r[3].s64 = 80;
	// 828E6150: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 828E6154: 4850C295  bl 0x82df23e8
	ctx.lr = 0x828E6158;
	sub_82DF23E8(ctx, base);
	// 828E6158: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828E615C: 41820020  beq 0x828e617c
	if ctx.cr[0].eq {
	pc = 0x828E617C; continue 'dispatch;
	}
	// 828E6160: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828E6164: 88FC0000  lbz r7, 0(r28)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E6168: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E616C: 80DD0000  lwz r6, 0(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E6170: 48030171  bl 0x829162e0
	ctx.lr = 0x828E6174;
	sub_829162E0(ctx, base);
	// 828E6174: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E6178: 48000008  b 0x828e6180
	pc = 0x828E6180; continue 'dispatch;
	// 828E617C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828E6180: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828E6184: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 828E6188: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E618C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E6190: 4BFFD5E9  bl 0x828e3778
	ctx.lr = 0x828E6194;
	sub_828E3778(ctx, base);
	// 828E6194: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828E6198: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E619C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E61A0: 4B9D9E61  bl 0x822c0000
	ctx.lr = 0x828E61A4;
	sub_822C0000(ctx, base);
	// 828E61A4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828E61A8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828E61AC: 488C2008  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E61B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E61B0 size=128
    let mut pc: u32 = 0x828E61B0;
    'dispatch: loop {
        match pc {
            0x828E61B0 => {
    //   block [0x828E61B0..0x828E6230)
	// 828E61B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E61B4: 488C1FB9  bl 0x831a816c
	ctx.lr = 0x828E61B8;
	sub_831A8130(ctx, base);
	// 828E61B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E61BC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828E61C0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828E61C4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828E61C8: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828E61CC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828E61D0: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 828E61D4: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 828E61D8: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 828E61DC: 4850C20D  bl 0x82df23e8
	ctx.lr = 0x828E61E0;
	sub_82DF23E8(ctx, base);
	// 828E61E0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828E61E4: 41820018  beq 0x828e61fc
	if ctx.cr[0].eq {
	pc = 0x828E61FC; continue 'dispatch;
	}
	// 828E61E8: C05E0000  lfs f2, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 828E61EC: C03F0000  lfs f1, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828E61F0: 4826D439  bl 0x82b53628
	ctx.lr = 0x828E61F4;
	sub_82B53628(ctx, base);
	// 828E61F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E61F8: 48000008  b 0x828e6200
	pc = 0x828E6200; continue 'dispatch;
	// 828E61FC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828E6200: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828E6204: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828E6208: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E620C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E6210: 4BFFD631  bl 0x828e3840
	ctx.lr = 0x828E6214;
	sub_828E3840(ctx, base);
	// 828E6214: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828E6218: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E621C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E6220: 4B9D9DE1  bl 0x822c0000
	ctx.lr = 0x828E6224;
	sub_822C0000(ctx, base);
	// 828E6224: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828E6228: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E622C: 488C1F90  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E6230(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E6230 size=136
    let mut pc: u32 = 0x828E6230;
    'dispatch: loop {
        match pc {
            0x828E6230 => {
    //   block [0x828E6230..0x828E62B8)
	// 828E6230: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E6234: 488C1F35  bl 0x831a8168
	ctx.lr = 0x828E6238;
	sub_831A8130(ctx, base);
	// 828E6238: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E623C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828E6240: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828E6244: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828E6248: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828E624C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 828E6250: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828E6254: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 828E6258: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 828E625C: 38600040  li r3, 0x40
	ctx.r[3].s64 = 64;
	// 828E6260: 4850C189  bl 0x82df23e8
	ctx.lr = 0x828E6264;
	sub_82DF23E8(ctx, base);
	// 828E6264: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828E6268: 4182001C  beq 0x828e6284
	if ctx.cr[0].eq {
	pc = 0x828E6284; continue 'dispatch;
	}
	// 828E626C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E6270: 80DD0000  lwz r6, 0(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E6274: C03E0000  lfs f1, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828E6278: 480300D9  bl 0x82916350
	ctx.lr = 0x828E627C;
	sub_82916350(ctx, base);
	// 828E627C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E6280: 48000008  b 0x828e6288
	pc = 0x828E6288; continue 'dispatch;
	// 828E6284: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828E6288: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828E628C: 3BDC0004  addi r30, r28, 4
	ctx.r[30].s64 = ctx.r[28].s64 + 4;
	// 828E6290: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E6294: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E6298: 4BFFD671  bl 0x828e3908
	ctx.lr = 0x828E629C;
	sub_828E3908(ctx, base);
	// 828E629C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828E62A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E62A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E62A8: 4B9D9D59  bl 0x822c0000
	ctx.lr = 0x828E62AC;
	sub_822C0000(ctx, base);
	// 828E62AC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828E62B0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828E62B4: 488C1F04  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E62B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E62B8 size=668
    let mut pc: u32 = 0x828E62B8;
    'dispatch: loop {
        match pc {
            0x828E62B8 => {
    //   block [0x828E62B8..0x828E6554)
	// 828E62B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E62BC: 488C1EAD  bl 0x831a8168
	ctx.lr = 0x828E62C0;
	sub_831A8130(ctx, base);
	// 828E62C0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E62C4: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 828E62C8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E62CC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828E62D0: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 828E62D4: 41820038  beq 0x828e630c
	if ctx.cr[0].eq {
	pc = 0x828E630C; continue 'dispatch;
	}
	// 828E62D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E62DC: 488C36AD  bl 0x831a9988
	ctx.lr = 0x828E62E0;
	sub_831A9988(ctx, base);
	// 828E62E0: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 828E62E4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828E62E8: 386B3984  addi r3, r11, 0x3984
	ctx.r[3].s64 = ctx.r[11].s64 + 14724;
	// 828E62EC: 488C1E0D  bl 0x831a80f8
	ctx.lr = 0x828E62F0;
	sub_831A80F8(ctx, base);
	// 828E62F0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E62F4: 41820018  beq 0x828e630c
	if ctx.cr[0].eq {
	pc = 0x828E630C; continue 'dispatch;
	}
	// 828E62F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E62FC: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 828E6300: 4BFF3C01  bl 0x828d9f00
	ctx.lr = 0x828E6304;
	sub_828D9F00(ctx, base);
	// 828E6304: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828E6308: 48000244  b 0x828e654c
	pc = 0x828E654C; continue 'dispatch;
	// 828E630C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828E6310: 419A022C  beq cr6, 0x828e653c
	if ctx.cr[6].eq {
	pc = 0x828E653C; continue 'dispatch;
	}
	// 828E6314: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E6318: 488C3671  bl 0x831a9988
	ctx.lr = 0x828E631C;
	sub_831A9988(ctx, base);
	// 828E631C: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 828E6320: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828E6324: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 828E6328: 488C1DD1  bl 0x831a80f8
	ctx.lr = 0x828E632C;
	sub_831A80F8(ctx, base);
	// 828E632C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E6330: 41820014  beq 0x828e6344
	if ctx.cr[0].eq {
	pc = 0x828E6344; continue 'dispatch;
	}
	// 828E6334: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E6338: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 828E633C: 4BFF3BA5  bl 0x828d9ee0
	ctx.lr = 0x828E6340;
	sub_828D9EE0(ctx, base);
	// 828E6340: 4BFFFFC4  b 0x828e6304
	pc = 0x828E6304; continue 'dispatch;
	// 828E6344: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828E6348: 419A01F4  beq cr6, 0x828e653c
	if ctx.cr[6].eq {
	pc = 0x828E653C; continue 'dispatch;
	}
	// 828E634C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E6350: 488C3639  bl 0x831a9988
	ctx.lr = 0x828E6354;
	sub_831A9988(ctx, base);
	// 828E6354: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 828E6358: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828E635C: 386B6C0C  addi r3, r11, 0x6c0c
	ctx.r[3].s64 = ctx.r[11].s64 + 27660;
	// 828E6360: 488C1D99  bl 0x831a80f8
	ctx.lr = 0x828E6364;
	sub_831A80F8(ctx, base);
	// 828E6364: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E6368: 41820014  beq 0x828e637c
	if ctx.cr[0].eq {
	pc = 0x828E637C; continue 'dispatch;
	}
	// 828E636C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E6370: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 828E6374: 4BFFCA2D  bl 0x828e2da0
	ctx.lr = 0x828E6378;
	sub_828E2DA0(ctx, base);
	// 828E6378: 4BFFFF8C  b 0x828e6304
	pc = 0x828E6304; continue 'dispatch;
	// 828E637C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828E6380: 419A01BC  beq cr6, 0x828e653c
	if ctx.cr[6].eq {
	pc = 0x828E653C; continue 'dispatch;
	}
	// 828E6384: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E6388: 488C3601  bl 0x831a9988
	ctx.lr = 0x828E638C;
	sub_831A9988(ctx, base);
	// 828E638C: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 828E6390: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828E6394: 386B6BDC  addi r3, r11, 0x6bdc
	ctx.r[3].s64 = ctx.r[11].s64 + 27612;
	// 828E6398: 488C1D61  bl 0x831a80f8
	ctx.lr = 0x828E639C;
	sub_831A80F8(ctx, base);
	// 828E639C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E63A0: 41820014  beq 0x828e63b4
	if ctx.cr[0].eq {
	pc = 0x828E63B4; continue 'dispatch;
	}
	// 828E63A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E63A8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 828E63AC: 4BFFC9C5  bl 0x828e2d70
	ctx.lr = 0x828E63B0;
	sub_828E2D70(ctx, base);
	// 828E63B0: 4BFFFF54  b 0x828e6304
	pc = 0x828E6304; continue 'dispatch;
	// 828E63B4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828E63B8: 419A0184  beq cr6, 0x828e653c
	if ctx.cr[6].eq {
	pc = 0x828E653C; continue 'dispatch;
	}
	// 828E63BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E63C0: 488C35C9  bl 0x831a9988
	ctx.lr = 0x828E63C4;
	sub_831A9988(ctx, base);
	// 828E63C4: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 828E63C8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828E63CC: 386B5CEC  addi r3, r11, 0x5cec
	ctx.r[3].s64 = ctx.r[11].s64 + 23788;
	// 828E63D0: 488C1D29  bl 0x831a80f8
	ctx.lr = 0x828E63D4;
	sub_831A80F8(ctx, base);
	// 828E63D4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E63D8: 41820014  beq 0x828e63ec
	if ctx.cr[0].eq {
	pc = 0x828E63EC; continue 'dispatch;
	}
	// 828E63DC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E63E0: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 828E63E4: 4BFFC99D  bl 0x828e2d80
	ctx.lr = 0x828E63E8;
	sub_828E2D80(ctx, base);
	// 828E63E8: 4BFFFF1C  b 0x828e6304
	pc = 0x828E6304; continue 'dispatch;
	// 828E63EC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828E63F0: 419A014C  beq cr6, 0x828e653c
	if ctx.cr[6].eq {
	pc = 0x828E653C; continue 'dispatch;
	}
	// 828E63F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E63F8: 488C3591  bl 0x831a9988
	ctx.lr = 0x828E63FC;
	sub_831A9988(ctx, base);
	// 828E63FC: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828E6400: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828E6404: 386B9048  addi r3, r11, -0x6fb8
	ctx.r[3].s64 = ctx.r[11].s64 + -28600;
	// 828E6408: 488C1CF1  bl 0x831a80f8
	ctx.lr = 0x828E640C;
	sub_831A80F8(ctx, base);
	// 828E640C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E6410: 41820014  beq 0x828e6424
	if ctx.cr[0].eq {
	pc = 0x828E6424; continue 'dispatch;
	}
	// 828E6414: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E6418: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 828E641C: 4BFFC975  bl 0x828e2d90
	ctx.lr = 0x828E6420;
	sub_828E2D90(ctx, base);
	// 828E6420: 4BFFFEE4  b 0x828e6304
	pc = 0x828E6304; continue 'dispatch;
	// 828E6424: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828E6428: 419A0114  beq cr6, 0x828e653c
	if ctx.cr[6].eq {
	pc = 0x828E653C; continue 'dispatch;
	}
	// 828E642C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E6430: 488C3559  bl 0x831a9988
	ctx.lr = 0x828E6434;
	sub_831A9988(ctx, base);
	// 828E6434: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 828E6438: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828E643C: 386B3A44  addi r3, r11, 0x3a44
	ctx.r[3].s64 = ctx.r[11].s64 + 14916;
	// 828E6440: 488C1CB9  bl 0x831a80f8
	ctx.lr = 0x828E6444;
	sub_831A80F8(ctx, base);
	// 828E6444: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E6448: 41820014  beq 0x828e645c
	if ctx.cr[0].eq {
	pc = 0x828E645C; continue 'dispatch;
	}
	// 828E644C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E6450: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 828E6454: 4BFFDD3D  bl 0x828e4190
	ctx.lr = 0x828E6458;
	sub_828E4190(ctx, base);
	// 828E6458: 4BFFFEAC  b 0x828e6304
	pc = 0x828E6304; continue 'dispatch;
	// 828E645C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828E6460: 419A00DC  beq cr6, 0x828e653c
	if ctx.cr[6].eq {
	pc = 0x828E653C; continue 'dispatch;
	}
	// 828E6464: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E6468: 488C3521  bl 0x831a9988
	ctx.lr = 0x828E646C;
	sub_831A9988(ctx, base);
	// 828E646C: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 828E6470: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828E6474: 386B1FA4  addi r3, r11, 0x1fa4
	ctx.r[3].s64 = ctx.r[11].s64 + 8100;
	// 828E6478: 488C1C81  bl 0x831a80f8
	ctx.lr = 0x828E647C;
	sub_831A80F8(ctx, base);
	// 828E647C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E6480: 41820014  beq 0x828e6494
	if ctx.cr[0].eq {
	pc = 0x828E6494; continue 'dispatch;
	}
	// 828E6484: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E6488: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 828E648C: 4BF8F0A5  bl 0x82875530
	ctx.lr = 0x828E6490;
	sub_82875530(ctx, base);
	// 828E6490: 4BFFFE74  b 0x828e6304
	pc = 0x828E6304; continue 'dispatch;
	// 828E6494: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828E6498: 419A00A4  beq cr6, 0x828e653c
	if ctx.cr[6].eq {
	pc = 0x828E653C; continue 'dispatch;
	}
	// 828E649C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E64A0: 488C34E9  bl 0x831a9988
	ctx.lr = 0x828E64A4;
	sub_831A9988(ctx, base);
	// 828E64A4: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 828E64A8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828E64AC: 386B5CC4  addi r3, r11, 0x5cc4
	ctx.r[3].s64 = ctx.r[11].s64 + 23748;
	// 828E64B0: 488C1C49  bl 0x831a80f8
	ctx.lr = 0x828E64B4;
	sub_831A80F8(ctx, base);
	// 828E64B4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E64B8: 41820014  beq 0x828e64cc
	if ctx.cr[0].eq {
	pc = 0x828E64CC; continue 'dispatch;
	}
	// 828E64BC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E64C0: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 828E64C4: 4BFF355D  bl 0x828d9a20
	ctx.lr = 0x828E64C8;
	sub_828D9A20(ctx, base);
	// 828E64C8: 4BFFFE3C  b 0x828e6304
	pc = 0x828E6304; continue 'dispatch;
	// 828E64CC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828E64D0: 419A006C  beq cr6, 0x828e653c
	if ctx.cr[6].eq {
	pc = 0x828E653C; continue 'dispatch;
	}
	// 828E64D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E64D8: 488C34B1  bl 0x831a9988
	ctx.lr = 0x828E64DC;
	sub_831A9988(ctx, base);
	// 828E64DC: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 828E64E0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828E64E4: 386B2380  addi r3, r11, 0x2380
	ctx.r[3].s64 = ctx.r[11].s64 + 9088;
	// 828E64E8: 488C1C11  bl 0x831a80f8
	ctx.lr = 0x828E64EC;
	sub_831A80F8(ctx, base);
	// 828E64EC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E64F0: 41820014  beq 0x828e6504
	if ctx.cr[0].eq {
	pc = 0x828E6504; continue 'dispatch;
	}
	// 828E64F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E64F8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 828E64FC: 4BFFDDBD  bl 0x828e42b8
	ctx.lr = 0x828E6500;
	sub_828E42B8(ctx, base);
	// 828E6500: 4BFFFE04  b 0x828e6304
	pc = 0x828E6304; continue 'dispatch;
	// 828E6504: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828E6508: 419A0034  beq cr6, 0x828e653c
	if ctx.cr[6].eq {
	pc = 0x828E653C; continue 'dispatch;
	}
	// 828E650C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E6510: 488C3479  bl 0x831a9988
	ctx.lr = 0x828E6514;
	sub_831A9988(ctx, base);
	// 828E6514: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 828E6518: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828E651C: 386BFBC0  addi r3, r11, -0x440
	ctx.r[3].s64 = ctx.r[11].s64 + -1088;
	// 828E6520: 488C1BD9  bl 0x831a80f8
	ctx.lr = 0x828E6524;
	sub_831A80F8(ctx, base);
	// 828E6524: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E6528: 41820014  beq 0x828e653c
	if ctx.cr[0].eq {
	pc = 0x828E653C; continue 'dispatch;
	}
	// 828E652C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E6530: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 828E6534: 4BFFF895  bl 0x828e5dc8
	ctx.lr = 0x828E6538;
	sub_828E5DC8(ctx, base);
	// 828E6538: 4BFFFDCC  b 0x828e6304
	pc = 0x828E6304; continue 'dispatch;
	// 828E653C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828E6540: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E6544: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E6548: 48029549  bl 0x8290fa90
	ctx.lr = 0x828E654C;
	sub_8290FA90(ctx, base);
	// 828E654C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828E6550: 488C1C68  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E6558(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E6558 size=268
    let mut pc: u32 = 0x828E6558;
    'dispatch: loop {
        match pc {
            0x828E6558 => {
    //   block [0x828E6558..0x828E6664)
	// 828E6558: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E655C: 488C1C11  bl 0x831a816c
	ctx.lr = 0x828E6560;
	sub_831A8130(ctx, base);
	// 828E6560: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E6564: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E6568: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828E656C: 4802A355  bl 0x829108c0
	ctx.lr = 0x828E6570;
	sub_829108C0(ctx, base);
	// 828E6570: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E6574: 408200DC  bne 0x828e6650
	if !ctx.cr[0].eq {
	pc = 0x828E6650; continue 'dispatch;
	}
	// 828E6578: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 828E657C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828E6580: 4BC22101  bl 0x82508680
	ctx.lr = 0x828E6584;
	sub_82508680(ctx, base);
	// 828E6584: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E6588: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E658C: 4BF9019D  bl 0x82876728
	ctx.lr = 0x828E6590;
	sub_82876728(ctx, base);
	// 828E6590: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E6594: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828E6598: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E659C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E65A0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828E65A4: 419A0024  beq cr6, 0x828e65c8
	if ctx.cr[6].eq {
	pc = 0x828E65C8; continue 'dispatch;
	}
	// 828E65A8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828E65AC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E65B0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E65B4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E65B8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828E65BC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E65C0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E65C4: 4082FFE8  bne 0x828e65ac
	if !ctx.cr[0].eq {
	pc = 0x828E65AC; continue 'dispatch;
	}
	// 828E65C8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828E65CC: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828E65D0: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 828E65D4: 388A0FF0  addi r4, r10, 0xff0
	ctx.r[4].s64 = ctx.r[10].s64 + 4080;
	// 828E65D8: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 828E65DC: 38A0028E  li r5, 0x28e
	ctx.r[5].s64 = 654;
	// 828E65E0: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828E65E4: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 828E65E8: 48572459  bl 0x82e58a40
	ctx.lr = 0x828E65EC;
	sub_82E58A40(ctx, base);
	// 828E65EC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828E65F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E65F4: 419A0008  beq cr6, 0x828e65fc
	if ctx.cr[6].eq {
	pc = 0x828E65FC; continue 'dispatch;
	}
	// 828E65F8: 4B9DA299  bl 0x822c0890
	ctx.lr = 0x828E65FC;
	sub_822C0890(ctx, base);
	// 828E65FC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828E6600: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E6604: 419A0008  beq cr6, 0x828e660c
	if ctx.cr[6].eq {
	pc = 0x828E660C; continue 'dispatch;
	}
	// 828E6608: 4B9DA289  bl 0x822c0890
	ctx.lr = 0x828E660C;
	sub_822C0890(ctx, base);
	// 828E660C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E6610: 4BF05B11  bl 0x827ec120
	ctx.lr = 0x828E6614;
	sub_827EC120(ctx, base);
	// 828E6614: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E6618: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E661C: 816B01A4  lwz r11, 0x1a4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(420 as u32) ) } as u64;
	// 828E6620: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E6624: 4E800421  bctrl
	ctx.lr = 0x828E6628;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E6628: 807F0364  lwz r3, 0x364(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(868 as u32) ) } as u64;
	// 828E662C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E6630: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828E6634: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E6638: 4E800421  bctrl
	ctx.lr = 0x828E663C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E663C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828E6640: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E6644: 48027AED  bl 0x8290e130
	ctx.lr = 0x828E6648;
	sub_8290E130(ctx, base);
	// 828E6648: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E664C: 480265FD  bl 0x8290cc48
	ctx.lr = 0x828E6650;
	sub_8290CC48(ctx, base);
	// 828E6650: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828E6654: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E6658: 4802AB29  bl 0x82911180
	ctx.lr = 0x828E665C;
	sub_82911180(ctx, base);
	// 828E665C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828E6660: 488C1B5C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E6668(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E6668 size=256
    let mut pc: u32 = 0x828E6668;
    'dispatch: loop {
        match pc {
            0x828E6668 => {
    //   block [0x828E6668..0x828E6768)
	// 828E6668: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E666C: 488C1AFD  bl 0x831a8168
	ctx.lr = 0x828E6670;
	sub_831A8130(ctx, base);
	// 828E6670: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E6674: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E6678: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828E667C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828E6680: 807F0080  lwz r3, 0x80(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 828E6684: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828E6688: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E668C: 419A0008  beq cr6, 0x828e6694
	if ctx.cr[6].eq {
	pc = 0x828E6694; continue 'dispatch;
	}
	// 828E6690: 48008A19  bl 0x828ef0a8
	ctx.lr = 0x828E6694;
	sub_828EF0A8(ctx, base);
	// 828E6694: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E6698: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828E669C: 388B0FF0  addi r4, r11, 0xff0
	ctx.r[4].s64 = ctx.r[11].s64 + 4080;
	// 828E66A0: 38A002EB  li r5, 0x2eb
	ctx.r[5].s64 = 747;
	// 828E66A4: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 828E66A8: 4B9D9D31  bl 0x822c03d8
	ctx.lr = 0x828E66AC;
	sub_822C03D8(ctx, base);
	// 828E66AC: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 828E66B0: 41820030  beq 0x828e66e0
	if ctx.cr[0].eq {
	pc = 0x828E66E0; continue 'dispatch;
	}
	// 828E66B4: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 828E66B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E66BC: 388BB1B8  addi r4, r11, -0x4e48
	ctx.r[4].s64 = ctx.r[11].s64 + -20040;
	// 828E66C0: 4850D349  bl 0x82df3a08
	ctx.lr = 0x828E66C4;
	sub_82DF3A08(ctx, base);
	// 828E66C4: 38BF002C  addi r5, r31, 0x2c
	ctx.r[5].s64 = ctx.r[31].s64 + 44;
	// 828E66C8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E66CC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828E66D0: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 828E66D4: 4BCC1D85  bl 0x825a8458
	ctx.lr = 0x828E66D8;
	sub_825A8458(ctx, base);
	// 828E66D8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828E66DC: 48000008  b 0x828e66e4
	pc = 0x828E66E4; continue 'dispatch;
	// 828E66E0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828E66E4: 3BFF0024  addi r31, r31, 0x24
	ctx.r[31].s64 = ctx.r[31].s64 + 36;
	// 828E66E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E66EC: 4BE3FA1D  bl 0x82726108
	ctx.lr = 0x828E66F0;
	sub_82726108(ctx, base);
	// 828E66F0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E66F4: 4182000C  beq 0x828e6700
	if ctx.cr[0].eq {
	pc = 0x828E6700; continue 'dispatch;
	}
	// 828E66F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E66FC: 4850CD2D  bl 0x82df3428
	ctx.lr = 0x828E6700;
	sub_82DF3428(ctx, base);
	// 828E6700: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 828E6704: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E6708: 388B1BC4  addi r4, r11, 0x1bc4
	ctx.r[4].s64 = ctx.r[11].s64 + 7108;
	// 828E670C: 4850D2FD  bl 0x82df3a08
	ctx.lr = 0x828E6710;
	sub_82DF3A08(ctx, base);
	// 828E6710: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E6714: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E6718: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E671C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828E6720: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828E6724: 419A0024  beq cr6, 0x828e6748
	if ctx.cr[6].eq {
	pc = 0x828E6748; continue 'dispatch;
	}
	// 828E6728: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828E672C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E6730: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E6734: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E6738: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828E673C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E6740: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E6744: 4082FFE8  bne 0x828e672c
	if !ctx.cr[0].eq {
	pc = 0x828E672C; continue 'dispatch;
	}
	// 828E6748: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828E674C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E6750: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828E6754: 4BCBB9BD  bl 0x825a2110
	ctx.lr = 0x828E6758;
	sub_825A2110(ctx, base);
	// 828E6758: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E675C: 4850CCCD  bl 0x82df3428
	ctx.lr = 0x828E6760;
	sub_82DF3428(ctx, base);
	// 828E6760: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828E6764: 488C1A54  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E6768(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E6768 size=344
    let mut pc: u32 = 0x828E6768;
    'dispatch: loop {
        match pc {
            0x828E6768 => {
    //   block [0x828E6768..0x828E68C0)
	// 828E6768: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E676C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E6770: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E6774: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E6778: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E677C: 988100AF  stb r4, 0xaf(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(175 as u32), ctx.r[4].u8 ) };
	// 828E6780: 807F0364  lwz r3, 0x364(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(868 as u32) ) } as u64;
	// 828E6784: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E6788: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 828E678C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E6790: 4E800421  bctrl
	ctx.lr = 0x828E6794;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E6794: 817F037C  lwz r11, 0x37c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(892 as u32) ) } as u64;
	// 828E6798: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E679C: 419A0110  beq cr6, 0x828e68ac
	if ctx.cr[6].eq {
	pc = 0x828E68AC; continue 'dispatch;
	}
	// 828E67A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E67A4: 4BF059BD  bl 0x827ec160
	ctx.lr = 0x828E67A8;
	sub_827EC160(ctx, base);
	// 828E67A8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828E67AC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828E67B0: 480305E9  bl 0x82916d98
	ctx.lr = 0x828E67B4;
	sub_82916D98(ctx, base);
	// 828E67B4: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828E67B8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828E67BC: 38AB00F8  addi r5, r11, 0xf8
	ctx.r[5].s64 = ctx.r[11].s64 + 248;
	// 828E67C0: 388B00F4  addi r4, r11, 0xf4
	ctx.r[4].s64 = ctx.r[11].s64 + 244;
	// 828E67C4: 4BFBF545  bl 0x828a5d08
	ctx.lr = 0x828E67C8;
	sub_828A5D08(ctx, base);
	// 828E67C8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E67CC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828E67D0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E67D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E67D8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828E67DC: 419A0024  beq cr6, 0x828e6800
	if ctx.cr[6].eq {
	pc = 0x828E6800; continue 'dispatch;
	}
	// 828E67E0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828E67E4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E67E8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E67EC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E67F0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828E67F4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E67F8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E67FC: 4082FFE8  bne 0x828e67e4
	if !ctx.cr[0].eq {
	pc = 0x828E67E4; continue 'dispatch;
	}
	// 828E6800: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E6804: 807F037C  lwz r3, 0x37c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(892 as u32) ) } as u64;
	// 828E6808: 4BF11871  bl 0x827f8078
	ctx.lr = 0x828E680C;
	sub_827F8078(ctx, base);
	// 828E680C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828E6810: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E6814: 419A0008  beq cr6, 0x828e681c
	if ctx.cr[6].eq {
	pc = 0x828E681C; continue 'dispatch;
	}
	// 828E6818: 4B9DA079  bl 0x822c0890
	ctx.lr = 0x828E681C;
	sub_822C0890(ctx, base);
	// 828E681C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828E6820: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E6824: 419A0008  beq cr6, 0x828e682c
	if ctx.cr[6].eq {
	pc = 0x828E682C; continue 'dispatch;
	}
	// 828E6828: 4B9DA069  bl 0x822c0890
	ctx.lr = 0x828E682C;
	sub_822C0890(ctx, base);
	// 828E682C: 388100AF  addi r4, r1, 0xaf
	ctx.r[4].s64 = ctx.r[1].s64 + 175;
	// 828E6830: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828E6834: 4BFBF555  bl 0x828a5d88
	ctx.lr = 0x828E6838;
	sub_828A5D88(ctx, base);
	// 828E6838: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E683C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828E6840: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E6844: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E6848: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828E684C: 419A0024  beq cr6, 0x828e6870
	if ctx.cr[6].eq {
	pc = 0x828E6870; continue 'dispatch;
	}
	// 828E6850: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828E6854: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E6858: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E685C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E6860: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828E6864: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E6868: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E686C: 4082FFE8  bne 0x828e6854
	if !ctx.cr[0].eq {
	pc = 0x828E6854; continue 'dispatch;
	}
	// 828E6870: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828E6874: 807F037C  lwz r3, 0x37c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(892 as u32) ) } as u64;
	// 828E6878: 4BF11801  bl 0x827f8078
	ctx.lr = 0x828E687C;
	sub_827F8078(ctx, base);
	// 828E687C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828E6880: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E6884: 419A0008  beq cr6, 0x828e688c
	if ctx.cr[6].eq {
	pc = 0x828E688C; continue 'dispatch;
	}
	// 828E6888: 4B9DA009  bl 0x822c0890
	ctx.lr = 0x828E688C;
	sub_822C0890(ctx, base);
	// 828E688C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828E6890: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E6894: 419A0008  beq cr6, 0x828e689c
	if ctx.cr[6].eq {
	pc = 0x828E689C; continue 'dispatch;
	}
	// 828E6898: 4B9D9FF9  bl 0x822c0890
	ctx.lr = 0x828E689C;
	sub_822C0890(ctx, base);
	// 828E689C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828E68A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E68A4: 419A0008  beq cr6, 0x828e68ac
	if ctx.cr[6].eq {
	pc = 0x828E68AC; continue 'dispatch;
	}
	// 828E68A8: 4B9D9FE9  bl 0x822c0890
	ctx.lr = 0x828E68AC;
	sub_822C0890(ctx, base);
	// 828E68AC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828E68B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E68B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E68B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E68BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E68C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E68C0 size=196
    let mut pc: u32 = 0x828E68C0;
    'dispatch: loop {
        match pc {
            0x828E68C0 => {
    //   block [0x828E68C0..0x828E6984)
	// 828E68C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E68C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E68C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E68CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E68D0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E68D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E68D8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828E68DC: 48022B35  bl 0x82909410
	ctx.lr = 0x828E68E0;
	sub_82909410(ctx, base);
	// 828E68E0: 817E037C  lwz r11, 0x37c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(892 as u32) ) } as u64;
	// 828E68E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E68E8: 419A0084  beq cr6, 0x828e696c
	if ctx.cr[6].eq {
	pc = 0x828E696C; continue 'dispatch;
	}
	// 828E68EC: 57EB063E  clrlwi r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 828E68F0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E68F4: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 828E68F8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828E68FC: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 828E6900: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 828E6904: 4BC91FCD  bl 0x825788d0
	ctx.lr = 0x828E6908;
	sub_825788D0(ctx, base);
	// 828E6908: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E690C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828E6910: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E6914: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E6918: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828E691C: 419A0024  beq cr6, 0x828e6940
	if ctx.cr[6].eq {
	pc = 0x828E6940; continue 'dispatch;
	}
	// 828E6920: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828E6924: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E6928: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E692C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E6930: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828E6934: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E6938: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E693C: 4082FFE8  bne 0x828e6924
	if !ctx.cr[0].eq {
	pc = 0x828E6924; continue 'dispatch;
	}
	// 828E6940: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828E6944: 807E037C  lwz r3, 0x37c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(892 as u32) ) } as u64;
	// 828E6948: 4BF11731  bl 0x827f8078
	ctx.lr = 0x828E694C;
	sub_827F8078(ctx, base);
	// 828E694C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828E6950: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E6954: 419A0008  beq cr6, 0x828e695c
	if ctx.cr[6].eq {
	pc = 0x828E695C; continue 'dispatch;
	}
	// 828E6958: 4B9D9F39  bl 0x822c0890
	ctx.lr = 0x828E695C;
	sub_822C0890(ctx, base);
	// 828E695C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828E6960: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E6964: 419A0008  beq cr6, 0x828e696c
	if ctx.cr[6].eq {
	pc = 0x828E696C; continue 'dispatch;
	}
	// 828E6968: 4B9D9F29  bl 0x822c0890
	ctx.lr = 0x828E696C;
	sub_822C0890(ctx, base);
	// 828E696C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828E6970: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E6974: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E6978: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E697C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E6980: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E6988(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E6988 size=176
    let mut pc: u32 = 0x828E6988;
    'dispatch: loop {
        match pc {
            0x828E6988 => {
    //   block [0x828E6988..0x828E6A38)
	// 828E6988: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E698C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E6990: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E6994: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E6998: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E699C: 9881008F  stb r4, 0x8f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(143 as u32), ctx.r[4].u8 ) };
	// 828E69A0: 90A10094  stw r5, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[5].u32 ) };
	// 828E69A4: 817F037C  lwz r11, 0x37c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(892 as u32) ) } as u64;
	// 828E69A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E69AC: 419A0078  beq cr6, 0x828e6a24
	if ctx.cr[6].eq {
	pc = 0x828E6A24; continue 'dispatch;
	}
	// 828E69B0: 38A10094  addi r5, r1, 0x94
	ctx.r[5].s64 = ctx.r[1].s64 + 148;
	// 828E69B4: 3881008F  addi r4, r1, 0x8f
	ctx.r[4].s64 = ctx.r[1].s64 + 143;
	// 828E69B8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E69BC: 4BFFF56D  bl 0x828e5f28
	ctx.lr = 0x828E69C0;
	sub_828E5F28(ctx, base);
	// 828E69C0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E69C4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828E69C8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E69CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E69D0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828E69D4: 419A0024  beq cr6, 0x828e69f8
	if ctx.cr[6].eq {
	pc = 0x828E69F8; continue 'dispatch;
	}
	// 828E69D8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828E69DC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E69E0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E69E4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E69E8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828E69EC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E69F0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E69F4: 4082FFE8  bne 0x828e69dc
	if !ctx.cr[0].eq {
	pc = 0x828E69DC; continue 'dispatch;
	}
	// 828E69F8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E69FC: 807F037C  lwz r3, 0x37c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(892 as u32) ) } as u64;
	// 828E6A00: 4BF11679  bl 0x827f8078
	ctx.lr = 0x828E6A04;
	sub_827F8078(ctx, base);
	// 828E6A04: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828E6A08: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E6A0C: 419A0008  beq cr6, 0x828e6a14
	if ctx.cr[6].eq {
	pc = 0x828E6A14; continue 'dispatch;
	}
	// 828E6A10: 4B9D9E81  bl 0x822c0890
	ctx.lr = 0x828E6A14;
	sub_822C0890(ctx, base);
	// 828E6A14: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828E6A18: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E6A1C: 419A0008  beq cr6, 0x828e6a24
	if ctx.cr[6].eq {
	pc = 0x828E6A24; continue 'dispatch;
	}
	// 828E6A20: 4B9D9E71  bl 0x822c0890
	ctx.lr = 0x828E6A24;
	sub_822C0890(ctx, base);
	// 828E6A24: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E6A28: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E6A2C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E6A30: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E6A34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E6A38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E6A38 size=1592
    let mut pc: u32 = 0x828E6A38;
    'dispatch: loop {
        match pc {
            0x828E6A38 => {
    //   block [0x828E6A38..0x828E7070)
	// 828E6A38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E6A3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E6A40: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E6A44: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E6A48: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 828E6A4C: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E6A50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E6A54: 548B063F  clrlwi. r11, r4, 0x18
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E6A58: 41820584  beq 0x828e6fdc
	if ctx.cr[0].eq {
	pc = 0x828E6FDC; continue 'dispatch;
	}
	// 828E6A5C: 4802238D  bl 0x82908de8
	ctx.lr = 0x828E6A60;
	sub_82908DE8(ctx, base);
	// 828E6A60: 2F030010  cmpwi cr6, r3, 0x10
	ctx.cr[6].compare_i32(ctx.r[3].s32, 16, &mut ctx.xer);
	// 828E6A64: 419A0464  beq cr6, 0x828e6ec8
	if ctx.cr[6].eq {
	pc = 0x828E6EC8; continue 'dispatch;
	}
	// 828E6A68: 2F030011  cmpwi cr6, r3, 0x11
	ctx.cr[6].compare_i32(ctx.r[3].s32, 17, &mut ctx.xer);
	// 828E6A6C: 419A034C  beq cr6, 0x828e6db8
	if ctx.cr[6].eq {
	pc = 0x828E6DB8; continue 'dispatch;
	}
	// 828E6A70: 2F030012  cmpwi cr6, r3, 0x12
	ctx.cr[6].compare_i32(ctx.r[3].s32, 18, &mut ctx.xer);
	// 828E6A74: 419A0234  beq cr6, 0x828e6ca8
	if ctx.cr[6].eq {
	pc = 0x828E6CA8; continue 'dispatch;
	}
	// 828E6A78: 2F030013  cmpwi cr6, r3, 0x13
	ctx.cr[6].compare_i32(ctx.r[3].s32, 19, &mut ctx.xer);
	// 828E6A7C: 419A011C  beq cr6, 0x828e6b98
	if ctx.cr[6].eq {
	pc = 0x828E6B98; continue 'dispatch;
	}
	// 828E6A80: 2F030014  cmpwi cr6, r3, 0x14
	ctx.cr[6].compare_i32(ctx.r[3].s32, 20, &mut ctx.xer);
	// 828E6A84: 409A05D0  bne cr6, 0x828e7054
	if !ctx.cr[6].eq {
	pc = 0x828E7054; continue 'dispatch;
	}
	// 828E6A88: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E6A8C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828E6A90: 3BCB1114  addi r30, r11, 0x1114
	ctx.r[30].s64 = ctx.r[11].s64 + 4372;
	// 828E6A94: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E6A98: 4850CF71  bl 0x82df3a08
	ctx.lr = 0x828E6A9C;
	sub_82DF3A08(ctx, base);
	// 828E6A9C: 817F03C0  lwz r11, 0x3c0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(960 as u32) ) } as u64;
	// 828E6AA0: 815F03BC  lwz r10, 0x3bc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(956 as u32) ) } as u64;
	// 828E6AA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E6AA8: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 828E6AAC: 91410078  stw r10, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 828E6AB0: 419A0024  beq cr6, 0x828e6ad4
	if ctx.cr[6].eq {
	pc = 0x828E6AD4; continue 'dispatch;
	}
	// 828E6AB4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828E6AB8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E6ABC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E6AC0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E6AC4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828E6AC8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E6ACC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E6AD0: 4082FFE8  bne 0x828e6ab8
	if !ctx.cr[0].eq {
	pc = 0x828E6AB8; continue 'dispatch;
	}
	// 828E6AD4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828E6AD8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828E6ADC: 38E00007  li r7, 7
	ctx.r[7].s64 = 7;
	// 828E6AE0: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 828E6AE4: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 828E6AE8: C3EB08A8  lfs f31, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828E6AEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E6AF0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828E6AF4: 4BF05715  bl 0x827ec208
	ctx.lr = 0x828E6AF8;
	sub_827EC208(ctx, base);
	// 828E6AF8: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 828E6AFC: 907F03F4  stw r3, 0x3f4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1012 as u32), ctx.r[3].u32 ) };
	// 828E6B00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E6B04: 419A000C  beq cr6, 0x828e6b10
	if ctx.cr[6].eq {
	pc = 0x828E6B10; continue 'dispatch;
	}
	// 828E6B08: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828E6B0C: 4B9D9D85  bl 0x822c0890
	ctx.lr = 0x828E6B10;
	sub_822C0890(ctx, base);
	// 828E6B10: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828E6B14: 4850C915  bl 0x82df3428
	ctx.lr = 0x828E6B18;
	sub_82DF3428(ctx, base);
	// 828E6B18: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E6B1C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E6B20: 4850CEE9  bl 0x82df3a08
	ctx.lr = 0x828E6B24;
	sub_82DF3A08(ctx, base);
	// 828E6B24: 817F03C8  lwz r11, 0x3c8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(968 as u32) ) } as u64;
	// 828E6B28: 815F03C4  lwz r10, 0x3c4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(964 as u32) ) } as u64;
	// 828E6B2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E6B30: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 828E6B34: 91410088  stw r10, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[10].u32 ) };
	// 828E6B38: 419A0024  beq cr6, 0x828e6b5c
	if ctx.cr[6].eq {
	pc = 0x828E6B5C; continue 'dispatch;
	}
	// 828E6B3C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828E6B40: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E6B44: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E6B48: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E6B4C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828E6B50: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E6B54: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E6B58: 4082FFE8  bne 0x828e6b40
	if !ctx.cr[0].eq {
	pc = 0x828E6B40; continue 'dispatch;
	}
	// 828E6B5C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828E6B60: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828E6B64: 38E00007  li r7, 7
	ctx.r[7].s64 = 7;
	// 828E6B68: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828E6B6C: 38810088  addi r4, r1, 0x88
	ctx.r[4].s64 = ctx.r[1].s64 + 136;
	// 828E6B70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E6B74: 4BF05695  bl 0x827ec208
	ctx.lr = 0x828E6B78;
	sub_827EC208(ctx, base);
	// 828E6B78: 8161008C  lwz r11, 0x8c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 828E6B7C: 907F03F8  stw r3, 0x3f8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1016 as u32), ctx.r[3].u32 ) };
	// 828E6B80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E6B84: 419A000C  beq cr6, 0x828e6b90
	if ctx.cr[6].eq {
	pc = 0x828E6B90; continue 'dispatch;
	}
	// 828E6B88: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828E6B8C: 4B9D9D05  bl 0x822c0890
	ctx.lr = 0x828E6B90;
	sub_822C0890(ctx, base);
	// 828E6B90: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E6B94: 48000440  b 0x828e6fd4
	pc = 0x828E6FD4; continue 'dispatch;
	// 828E6B98: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E6B9C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828E6BA0: 3BCB10F8  addi r30, r11, 0x10f8
	ctx.r[30].s64 = ctx.r[11].s64 + 4344;
	// 828E6BA4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E6BA8: 4850CE61  bl 0x82df3a08
	ctx.lr = 0x828E6BAC;
	sub_82DF3A08(ctx, base);
	// 828E6BAC: 817F03C0  lwz r11, 0x3c0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(960 as u32) ) } as u64;
	// 828E6BB0: 815F03BC  lwz r10, 0x3bc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(956 as u32) ) } as u64;
	// 828E6BB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E6BB8: 916100C4  stw r11, 0xc4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 828E6BBC: 914100C0  stw r10, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[10].u32 ) };
	// 828E6BC0: 419A0024  beq cr6, 0x828e6be4
	if ctx.cr[6].eq {
	pc = 0x828E6BE4; continue 'dispatch;
	}
	// 828E6BC4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828E6BC8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E6BCC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E6BD0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E6BD4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828E6BD8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E6BDC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E6BE0: 4082FFE8  bne 0x828e6bc8
	if !ctx.cr[0].eq {
	pc = 0x828E6BC8; continue 'dispatch;
	}
	// 828E6BE4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828E6BE8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828E6BEC: 38E00007  li r7, 7
	ctx.r[7].s64 = 7;
	// 828E6BF0: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 828E6BF4: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 828E6BF8: C3EB08A8  lfs f31, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828E6BFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E6C00: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828E6C04: 4BF05605  bl 0x827ec208
	ctx.lr = 0x828E6C08;
	sub_827EC208(ctx, base);
	// 828E6C08: 816100C4  lwz r11, 0xc4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 828E6C0C: 907F03F4  stw r3, 0x3f4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1012 as u32), ctx.r[3].u32 ) };
	// 828E6C10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E6C14: 419A000C  beq cr6, 0x828e6c20
	if ctx.cr[6].eq {
	pc = 0x828E6C20; continue 'dispatch;
	}
	// 828E6C18: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828E6C1C: 4B9D9C75  bl 0x822c0890
	ctx.lr = 0x828E6C20;
	sub_822C0890(ctx, base);
	// 828E6C20: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828E6C24: 4850C805  bl 0x82df3428
	ctx.lr = 0x828E6C28;
	sub_82DF3428(ctx, base);
	// 828E6C28: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E6C2C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828E6C30: 4850CDD9  bl 0x82df3a08
	ctx.lr = 0x828E6C34;
	sub_82DF3A08(ctx, base);
	// 828E6C34: 817F03C8  lwz r11, 0x3c8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(968 as u32) ) } as u64;
	// 828E6C38: 815F03C4  lwz r10, 0x3c4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(964 as u32) ) } as u64;
	// 828E6C3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E6C40: 9161009C  stw r11, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	// 828E6C44: 91410098  stw r10, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[10].u32 ) };
	// 828E6C48: 419A0024  beq cr6, 0x828e6c6c
	if ctx.cr[6].eq {
	pc = 0x828E6C6C; continue 'dispatch;
	}
	// 828E6C4C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828E6C50: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E6C54: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E6C58: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E6C5C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828E6C60: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E6C64: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E6C68: 4082FFE8  bne 0x828e6c50
	if !ctx.cr[0].eq {
	pc = 0x828E6C50; continue 'dispatch;
	}
	// 828E6C6C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828E6C70: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828E6C74: 38E00007  li r7, 7
	ctx.r[7].s64 = 7;
	// 828E6C78: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828E6C7C: 38810098  addi r4, r1, 0x98
	ctx.r[4].s64 = ctx.r[1].s64 + 152;
	// 828E6C80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E6C84: 4BF05585  bl 0x827ec208
	ctx.lr = 0x828E6C88;
	sub_827EC208(ctx, base);
	// 828E6C88: 8161009C  lwz r11, 0x9c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 828E6C8C: 907F03F8  stw r3, 0x3f8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1016 as u32), ctx.r[3].u32 ) };
	// 828E6C90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E6C94: 419A000C  beq cr6, 0x828e6ca0
	if ctx.cr[6].eq {
	pc = 0x828E6CA0; continue 'dispatch;
	}
	// 828E6C98: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828E6C9C: 4B9D9BF5  bl 0x822c0890
	ctx.lr = 0x828E6CA0;
	sub_822C0890(ctx, base);
	// 828E6CA0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828E6CA4: 48000330  b 0x828e6fd4
	pc = 0x828E6FD4; continue 'dispatch;
	// 828E6CA8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E6CAC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E6CB0: 3BCB10DC  addi r30, r11, 0x10dc
	ctx.r[30].s64 = ctx.r[11].s64 + 4316;
	// 828E6CB4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E6CB8: 4850CD51  bl 0x82df3a08
	ctx.lr = 0x828E6CBC;
	sub_82DF3A08(ctx, base);
	// 828E6CBC: 817F03C0  lwz r11, 0x3c0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(960 as u32) ) } as u64;
	// 828E6CC0: 815F03BC  lwz r10, 0x3bc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(956 as u32) ) } as u64;
	// 828E6CC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E6CC8: 916100BC  stw r11, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[11].u32 ) };
	// 828E6CCC: 914100B8  stw r10, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[10].u32 ) };
	// 828E6CD0: 419A0024  beq cr6, 0x828e6cf4
	if ctx.cr[6].eq {
	pc = 0x828E6CF4; continue 'dispatch;
	}
	// 828E6CD4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828E6CD8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E6CDC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E6CE0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E6CE4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828E6CE8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E6CEC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E6CF0: 4082FFE8  bne 0x828e6cd8
	if !ctx.cr[0].eq {
	pc = 0x828E6CD8; continue 'dispatch;
	}
	// 828E6CF4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828E6CF8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828E6CFC: 38E00007  li r7, 7
	ctx.r[7].s64 = 7;
	// 828E6D00: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828E6D04: 388100B8  addi r4, r1, 0xb8
	ctx.r[4].s64 = ctx.r[1].s64 + 184;
	// 828E6D08: C3EB08A8  lfs f31, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828E6D0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E6D10: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828E6D14: 4BF054F5  bl 0x827ec208
	ctx.lr = 0x828E6D18;
	sub_827EC208(ctx, base);
	// 828E6D18: 816100BC  lwz r11, 0xbc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 828E6D1C: 907F03F4  stw r3, 0x3f4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1012 as u32), ctx.r[3].u32 ) };
	// 828E6D20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E6D24: 419A000C  beq cr6, 0x828e6d30
	if ctx.cr[6].eq {
	pc = 0x828E6D30; continue 'dispatch;
	}
	// 828E6D28: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828E6D2C: 4B9D9B65  bl 0x822c0890
	ctx.lr = 0x828E6D30;
	sub_822C0890(ctx, base);
	// 828E6D30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E6D34: 4850C6F5  bl 0x82df3428
	ctx.lr = 0x828E6D38;
	sub_82DF3428(ctx, base);
	// 828E6D38: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E6D3C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828E6D40: 4850CCC9  bl 0x82df3a08
	ctx.lr = 0x828E6D44;
	sub_82DF3A08(ctx, base);
	// 828E6D44: 817F03C8  lwz r11, 0x3c8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(968 as u32) ) } as u64;
	// 828E6D48: 815F03C4  lwz r10, 0x3c4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(964 as u32) ) } as u64;
	// 828E6D4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E6D50: 916100AC  stw r11, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[11].u32 ) };
	// 828E6D54: 914100A8  stw r10, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[10].u32 ) };
	// 828E6D58: 419A0024  beq cr6, 0x828e6d7c
	if ctx.cr[6].eq {
	pc = 0x828E6D7C; continue 'dispatch;
	}
	// 828E6D5C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828E6D60: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E6D64: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E6D68: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E6D6C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828E6D70: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E6D74: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E6D78: 4082FFE8  bne 0x828e6d60
	if !ctx.cr[0].eq {
	pc = 0x828E6D60; continue 'dispatch;
	}
	// 828E6D7C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828E6D80: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828E6D84: 38E00007  li r7, 7
	ctx.r[7].s64 = 7;
	// 828E6D88: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 828E6D8C: 388100A8  addi r4, r1, 0xa8
	ctx.r[4].s64 = ctx.r[1].s64 + 168;
	// 828E6D90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E6D94: 4BF05475  bl 0x827ec208
	ctx.lr = 0x828E6D98;
	sub_827EC208(ctx, base);
	// 828E6D98: 816100AC  lwz r11, 0xac(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 828E6D9C: 907F03F8  stw r3, 0x3f8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1016 as u32), ctx.r[3].u32 ) };
	// 828E6DA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E6DA4: 419A000C  beq cr6, 0x828e6db0
	if ctx.cr[6].eq {
	pc = 0x828E6DB0; continue 'dispatch;
	}
	// 828E6DA8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828E6DAC: 4B9D9AE5  bl 0x822c0890
	ctx.lr = 0x828E6DB0;
	sub_822C0890(ctx, base);
	// 828E6DB0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828E6DB4: 48000220  b 0x828e6fd4
	pc = 0x828E6FD4; continue 'dispatch;
	// 828E6DB8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E6DBC: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828E6DC0: 3BCB10C0  addi r30, r11, 0x10c0
	ctx.r[30].s64 = ctx.r[11].s64 + 4288;
	// 828E6DC4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E6DC8: 4850CC41  bl 0x82df3a08
	ctx.lr = 0x828E6DCC;
	sub_82DF3A08(ctx, base);
	// 828E6DCC: 817F03C0  lwz r11, 0x3c0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(960 as u32) ) } as u64;
	// 828E6DD0: 815F03BC  lwz r10, 0x3bc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(956 as u32) ) } as u64;
	// 828E6DD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E6DD8: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 828E6DDC: 91410080  stw r10, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 828E6DE0: 419A0024  beq cr6, 0x828e6e04
	if ctx.cr[6].eq {
	pc = 0x828E6E04; continue 'dispatch;
	}
	// 828E6DE4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828E6DE8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E6DEC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E6DF0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E6DF4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828E6DF8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E6DFC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E6E00: 4082FFE8  bne 0x828e6de8
	if !ctx.cr[0].eq {
	pc = 0x828E6DE8; continue 'dispatch;
	}
	// 828E6E04: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828E6E08: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828E6E0C: 38E00007  li r7, 7
	ctx.r[7].s64 = 7;
	// 828E6E10: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 828E6E14: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 828E6E18: C3EB08A8  lfs f31, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828E6E1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E6E20: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828E6E24: 4BF053E5  bl 0x827ec208
	ctx.lr = 0x828E6E28;
	sub_827EC208(ctx, base);
	// 828E6E28: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 828E6E2C: 907F03F4  stw r3, 0x3f4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1012 as u32), ctx.r[3].u32 ) };
	// 828E6E30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E6E34: 419A000C  beq cr6, 0x828e6e40
	if ctx.cr[6].eq {
	pc = 0x828E6E40; continue 'dispatch;
	}
	// 828E6E38: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828E6E3C: 4B9D9A55  bl 0x822c0890
	ctx.lr = 0x828E6E40;
	sub_822C0890(ctx, base);
	// 828E6E40: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828E6E44: 4850C5E5  bl 0x82df3428
	ctx.lr = 0x828E6E48;
	sub_82DF3428(ctx, base);
	// 828E6E48: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E6E4C: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 828E6E50: 4850CBB9  bl 0x82df3a08
	ctx.lr = 0x828E6E54;
	sub_82DF3A08(ctx, base);
	// 828E6E54: 817F03C8  lwz r11, 0x3c8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(968 as u32) ) } as u64;
	// 828E6E58: 815F03C4  lwz r10, 0x3c4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(964 as u32) ) } as u64;
	// 828E6E5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E6E60: 91610094  stw r11, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 828E6E64: 91410090  stw r10, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[10].u32 ) };
	// 828E6E68: 419A0024  beq cr6, 0x828e6e8c
	if ctx.cr[6].eq {
	pc = 0x828E6E8C; continue 'dispatch;
	}
	// 828E6E6C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828E6E70: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E6E74: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E6E78: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E6E7C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828E6E80: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E6E84: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E6E88: 4082FFE8  bne 0x828e6e70
	if !ctx.cr[0].eq {
	pc = 0x828E6E70; continue 'dispatch;
	}
	// 828E6E8C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828E6E90: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828E6E94: 38E00007  li r7, 7
	ctx.r[7].s64 = 7;
	// 828E6E98: 38A10064  addi r5, r1, 0x64
	ctx.r[5].s64 = ctx.r[1].s64 + 100;
	// 828E6E9C: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 828E6EA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E6EA4: 4BF05365  bl 0x827ec208
	ctx.lr = 0x828E6EA8;
	sub_827EC208(ctx, base);
	// 828E6EA8: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 828E6EAC: 907F03F8  stw r3, 0x3f8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1016 as u32), ctx.r[3].u32 ) };
	// 828E6EB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E6EB4: 419A000C  beq cr6, 0x828e6ec0
	if ctx.cr[6].eq {
	pc = 0x828E6EC0; continue 'dispatch;
	}
	// 828E6EB8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828E6EBC: 4B9D99D5  bl 0x822c0890
	ctx.lr = 0x828E6EC0;
	sub_822C0890(ctx, base);
	// 828E6EC0: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 828E6EC4: 48000110  b 0x828e6fd4
	pc = 0x828E6FD4; continue 'dispatch;
	// 828E6EC8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E6ECC: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 828E6ED0: 3BCB10A4  addi r30, r11, 0x10a4
	ctx.r[30].s64 = ctx.r[11].s64 + 4260;
	// 828E6ED4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E6ED8: 4850CB31  bl 0x82df3a08
	ctx.lr = 0x828E6EDC;
	sub_82DF3A08(ctx, base);
	// 828E6EDC: 817F03C0  lwz r11, 0x3c0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(960 as u32) ) } as u64;
	// 828E6EE0: 815F03BC  lwz r10, 0x3bc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(956 as u32) ) } as u64;
	// 828E6EE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E6EE8: 916100A4  stw r11, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 828E6EEC: 914100A0  stw r10, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[10].u32 ) };
	// 828E6EF0: 419A0024  beq cr6, 0x828e6f14
	if ctx.cr[6].eq {
	pc = 0x828E6F14; continue 'dispatch;
	}
	// 828E6EF4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828E6EF8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E6EFC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E6F00: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E6F04: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828E6F08: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E6F0C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E6F10: 4082FFE8  bne 0x828e6ef8
	if !ctx.cr[0].eq {
	pc = 0x828E6EF8; continue 'dispatch;
	}
	// 828E6F14: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828E6F18: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828E6F1C: 38E00007  li r7, 7
	ctx.r[7].s64 = 7;
	// 828E6F20: 38A1006C  addi r5, r1, 0x6c
	ctx.r[5].s64 = ctx.r[1].s64 + 108;
	// 828E6F24: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 828E6F28: C3EB08A8  lfs f31, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828E6F2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E6F30: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828E6F34: 4BF052D5  bl 0x827ec208
	ctx.lr = 0x828E6F38;
	sub_827EC208(ctx, base);
	// 828E6F38: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 828E6F3C: 907F03F4  stw r3, 0x3f4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1012 as u32), ctx.r[3].u32 ) };
	// 828E6F40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E6F44: 419A000C  beq cr6, 0x828e6f50
	if ctx.cr[6].eq {
	pc = 0x828E6F50; continue 'dispatch;
	}
	// 828E6F48: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828E6F4C: 4B9D9945  bl 0x822c0890
	ctx.lr = 0x828E6F50;
	sub_822C0890(ctx, base);
	// 828E6F50: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 828E6F54: 4850C4D5  bl 0x82df3428
	ctx.lr = 0x828E6F58;
	sub_82DF3428(ctx, base);
	// 828E6F58: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E6F5C: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 828E6F60: 4850CAA9  bl 0x82df3a08
	ctx.lr = 0x828E6F64;
	sub_82DF3A08(ctx, base);
	// 828E6F64: 817F03C8  lwz r11, 0x3c8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(968 as u32) ) } as u64;
	// 828E6F68: 815F03C4  lwz r10, 0x3c4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(964 as u32) ) } as u64;
	// 828E6F6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E6F70: 916100B4  stw r11, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[11].u32 ) };
	// 828E6F74: 914100B0  stw r10, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[10].u32 ) };
	// 828E6F78: 419A0024  beq cr6, 0x828e6f9c
	if ctx.cr[6].eq {
	pc = 0x828E6F9C; continue 'dispatch;
	}
	// 828E6F7C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828E6F80: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E6F84: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E6F88: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E6F8C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828E6F90: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E6F94: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E6F98: 4082FFE8  bne 0x828e6f80
	if !ctx.cr[0].eq {
	pc = 0x828E6F80; continue 'dispatch;
	}
	// 828E6F9C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828E6FA0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828E6FA4: 38E00007  li r7, 7
	ctx.r[7].s64 = 7;
	// 828E6FA8: 38A10074  addi r5, r1, 0x74
	ctx.r[5].s64 = ctx.r[1].s64 + 116;
	// 828E6FAC: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 828E6FB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E6FB4: 4BF05255  bl 0x827ec208
	ctx.lr = 0x828E6FB8;
	sub_827EC208(ctx, base);
	// 828E6FB8: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 828E6FBC: 907F03F8  stw r3, 0x3f8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1016 as u32), ctx.r[3].u32 ) };
	// 828E6FC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E6FC4: 419A000C  beq cr6, 0x828e6fd0
	if ctx.cr[6].eq {
	pc = 0x828E6FD0; continue 'dispatch;
	}
	// 828E6FC8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828E6FCC: 4B9D98C5  bl 0x822c0890
	ctx.lr = 0x828E6FD0;
	sub_822C0890(ctx, base);
	// 828E6FD0: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 828E6FD4: 4850C455  bl 0x82df3428
	ctx.lr = 0x828E6FD8;
	sub_82DF3428(ctx, base);
	// 828E6FD8: 4800007C  b 0x828e7054
	pc = 0x828E7054; continue 'dispatch;
	// 828E6FDC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E6FE0: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 828E6FE4: 4BC284E5  bl 0x8250f4c8
	ctx.lr = 0x828E6FE8;
	sub_8250F4C8(ctx, base);
	// 828E6FE8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E6FEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E6FF0: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 828E6FF4: 409A0008  bne cr6, 0x828e6ffc
	if !ctx.cr[6].eq {
	pc = 0x828E6FFC; continue 'dispatch;
	}
	// 828E6FF8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828E6FFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E7000: 80BF03F4  lwz r5, 0x3f4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1012 as u32) ) } as u64;
	// 828E7004: 4BF0528D  bl 0x827ec290
	ctx.lr = 0x828E7008;
	sub_827EC290(ctx, base);
	// 828E7008: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 828E700C: 4850AC85  bl 0x82df1c90
	ctx.lr = 0x828E7010;
	sub_82DF1C90(ctx, base);
	// 828E7010: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E7014: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 828E7018: 4BC284B1  bl 0x8250f4c8
	ctx.lr = 0x828E701C;
	sub_8250F4C8(ctx, base);
	// 828E701C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E7020: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E7024: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 828E7028: 409A0008  bne cr6, 0x828e7030
	if !ctx.cr[6].eq {
	pc = 0x828E7030; continue 'dispatch;
	}
	// 828E702C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828E7030: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E7034: 80BF03F8  lwz r5, 0x3f8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1016 as u32) ) } as u64;
	// 828E7038: 4BF05259  bl 0x827ec290
	ctx.lr = 0x828E703C;
	sub_827EC290(ctx, base);
	// 828E703C: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 828E7040: 4850AC51  bl 0x82df1c90
	ctx.lr = 0x828E7044;
	sub_82DF1C90(ctx, base);
	// 828E7044: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828E7048: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828E704C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E7050: 4BFFE7B9  bl 0x828e5808
	ctx.lr = 0x828E7054;
	sub_828E5808(ctx, base);
	// 828E7054: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 828E7058: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E705C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E7060: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 828E7064: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E7068: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E706C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E7070(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E7070 size=620
    let mut pc: u32 = 0x828E7070;
    'dispatch: loop {
        match pc {
            0x828E7070 => {
    //   block [0x828E7070..0x828E72DC)
	// 828E7070: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E7074: 488C10E9  bl 0x831a815c
	ctx.lr = 0x828E7078;
	sub_831A8130(ctx, base);
	// 828E7078: DBA1FFA8  stfd f29, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[29].u64 ) };
	// 828E707C: DBC1FFB0  stfd f30, -0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 828E7080: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 828E7084: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E7088: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E708C: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 828E7090: 3B9F03B4  addi r28, r31, 0x3b4
	ctx.r[28].s64 = ctx.r[31].s64 + 948;
	// 828E7094: 817F03B4  lwz r11, 0x3b4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(948 as u32) ) } as u64;
	// 828E7098: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E709C: 419A0114  beq cr6, 0x828e71b0
	if ctx.cr[6].eq {
	pc = 0x828E71B0; continue 'dispatch;
	}
	// 828E70A0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E70A4: 816B01B0  lwz r11, 0x1b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(432 as u32) ) } as u64;
	// 828E70A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E70AC: 4E800421  bctrl
	ctx.lr = 0x828E70B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E70B0: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E70B4: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 828E70B8: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 828E70BC: 38800060  li r4, 0x60
	ctx.r[4].s64 = 96;
	// 828E70C0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E70C4: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828E70C8: 485B9669  bl 0x82ea0730
	ctx.lr = 0x828E70CC;
	sub_82EA0730(ctx, base);
	// 828E70CC: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 828E70D0: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 828E70D4: 396BB070  addi r11, r11, -0x4f90
	ctx.r[11].s64 = ctx.r[11].s64 + -20368;
	// 828E70D8: 394ABC40  addi r10, r10, -0x43c0
	ctx.r[10].s64 = ctx.r[10].s64 + -17344;
	// 828E70DC: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 828E70E0: 39010080  addi r8, r1, 0x80
	ctx.r[8].s64 = ctx.r[1].s64 + 128;
	// 828E70E4: 38E00060  li r7, 0x60
	ctx.r[7].s64 = 96;
	// 828E70E8: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828E70EC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828E70F0: 13C050C7  vcmpequd (lvx128) v30, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828E70F4: B0E30004  sth r7, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[7].u16 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E72E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E72E0 size=376
    let mut pc: u32 = 0x828E72E0;
    'dispatch: loop {
        match pc {
            0x828E72E0 => {
    //   block [0x828E72E0..0x828E7458)
	// 828E72E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E72E4: 488C0E75  bl 0x831a8158
	ctx.lr = 0x828E72E8;
	sub_831A8130(ctx, base);
	// 828E72E8: DBE1FFB0  stfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 828E72EC: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E72F0: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E72F4: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 828E72F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E72FC: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 828E7300: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E7304: 386BFF6C  addi r3, r11, -0x94
	ctx.r[3].s64 = ctx.r[11].s64 + -148;
	// 828E7308: 409A0008  bne cr6, 0x828e7310
	if !ctx.cr[6].eq {
	pc = 0x828E7310; continue 'dispatch;
	}
	// 828E730C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828E7310: 4BC40D79  bl 0x82528088
	ctx.lr = 0x828E7314;
	sub_82528088(ctx, base);
	// 828E7314: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828E7318: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E731C: 4BF04E45  bl 0x827ec160
	ctx.lr = 0x828E7320;
	sub_827EC160(ctx, base);
	// 828E7320: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E7324: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 828E7328: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E732C: 4E800421  bctrl
	ctx.lr = 0x828E7330;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E7330: 3FA08335  lis r29, -0x7ccb
	ctx.r[29].s64 = -2093678592;
	// 828E7334: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 828E7338: C3E30000  lfs f31, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828E733C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 828E7340: 3D008209  lis r8, -0x7df7
	ctx.r[8].s64 = -2113339392;
	// 828E7344: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828E7348: 817D6810  lwz r11, 0x6810(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(26640 as u32) ) } as u64;
	// 828E734C: 38880FF0  addi r4, r8, 0xff0
	ctx.r[4].s64 = ctx.r[8].s64 + 4080;
	// 828E7350: C00A964C  lfs f0, -0x69b4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828E7354: 38A004E2  li r5, 0x4e2
	ctx.r[5].s64 = 1250;
	// 828E7358: EDBF002A  fadds f13, f31, f0
	ctx.f[13].f64 = ((ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64;
	// 828E735C: C00908A4  lfs f0, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828E7360: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828E7364: 38600200  li r3, 0x200
	ctx.r[3].s64 = 512;
	// 828E7368: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 828E736C: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 828E7370: 917F0248  stw r11, 0x248(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(584 as u32), ctx.r[11].u32 ) };
	// 828E7374: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 828E7378: 4850B071  bl 0x82df23e8
	ctx.lr = 0x828E737C;
	sub_82DF23E8(ctx, base);
	// 828E737C: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828E7380: 41820080  beq 0x828e7400
	if ctx.cr[0].eq {
	pc = 0x828E7400; continue 'dispatch;
	}
	// 828E7384: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E7388: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 828E738C: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 828E7390: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 828E7394: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828E7398: 485B9399  bl 0x82ea0730
	ctx.lr = 0x828E739C;
	sub_82EA0730(ctx, base);
	// 828E739C: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 828E73A0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828E73A4: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 828E73A8: 48632E49  bl 0x82f1a1f0
	ctx.lr = 0x828E73AC;
	sub_82F1A1F0(ctx, base);
	// 828E73AC: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 828E73B0: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 828E73B4: 83BD6810  lwz r29, 0x6810(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(26640 as u32) ) } as u64;
	// 828E73B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E73BC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E73C0: 3B4BBA80  addi r26, r11, -0x4580
	ctx.r[26].s64 = ctx.r[11].s64 + -17792;
	// 828E73C4: 3B600003  li r27, 3
	ctx.r[27].s64 = 3;
	// 828E73C8: 3B210060  addi r25, r1, 0x60
	ctx.r[25].s64 = ctx.r[1].s64 + 96;
	// 828E73CC: 3B010050  addi r24, r1, 0x50
	ctx.r[24].s64 = ctx.r[1].s64 + 80;
	// 828E73D0: 4BC28149  bl 0x8250f518
	ctx.lr = 0x828E73D4;
	sub_8250F518(ctx, base);
	// 828E73D4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828E73D8: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 828E73DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E73E0: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 828E73E4: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 828E73E8: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 828E73EC: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 828E73F0: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 828E73F4: 481FFEED  bl 0x82ae72e0
	ctx.lr = 0x828E73F8;
	sub_82AE72E0(ctx, base);
	// 828E73F8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828E73FC: 48000008  b 0x828e7404
	pc = 0x828E7404; continue 'dispatch;
	// 828E7400: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828E7404: 3BFF01D4  addi r31, r31, 0x1d4
	ctx.r[31].s64 = ctx.r[31].s64 + 468;
	// 828E7408: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E740C: 4BA8CE4D  bl 0x82374258
	ctx.lr = 0x828E7410;
	sub_82374258(ctx, base);
	// 828E7410: 576B07BD  rlwinm. r11, r27, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E7414: 41820010  beq 0x828e7424
	if ctx.cr[0].eq {
	pc = 0x828E7424; continue 'dispatch;
	}
	// 828E7418: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E741C: 577B07FA  rlwinm r27, r27, 0, 0x1f, 0x1d
	ctx.r[27].u64 = ctx.r[27].u32 as u64 & 0xFFFFFFFFu64;
	// 828E7420: 4850A871  bl 0x82df1c90
	ctx.lr = 0x828E7424;
	sub_82DF1C90(ctx, base);
	// 828E7424: 576B07FF  clrlwi. r11, r27, 0x1f
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E7428: 41820014  beq 0x828e743c
	if ctx.cr[0].eq {
	pc = 0x828E743C; continue 'dispatch;
	}
	// 828E742C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828E7430: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E7434: 419A0008  beq cr6, 0x828e743c
	if ctx.cr[6].eq {
	pc = 0x828E743C; continue 'dispatch;
	}
	// 828E7438: 4BA00E31  bl 0x822e8268
	ctx.lr = 0x828E743C;
	sub_822E8268(ctx, base);
	// 828E743C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828E7440: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E7444: C02BEE80  lfs f1, -0x1180(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4480 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828E7448: 481FBF09  bl 0x82ae3350
	ctx.lr = 0x828E744C;
	sub_82AE3350(ctx, base);
	// 828E744C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828E7450: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 828E7454: 488C0D54  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E7458(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E7458 size=208
    let mut pc: u32 = 0x828E7458;
    'dispatch: loop {
        match pc {
            0x828E7458 => {
    //   block [0x828E7458..0x828E7528)
	// 828E7458: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E745C: 488C0D0D  bl 0x831a8168
	ctx.lr = 0x828E7460;
	sub_831A8130(ctx, base);
	// 828E7460: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 828E7464: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E7468: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828E746C: 83FD03A0  lwz r31, 0x3a0(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(928 as u32) ) } as u64;
	// 828E7470: 817D03A4  lwz r11, 0x3a4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(932 as u32) ) } as u64;
	// 828E7474: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828E7478: 419A00A4  beq cr6, 0x828e751c
	if ctx.cr[6].eq {
	pc = 0x828E751C; continue 'dispatch;
	}
	// 828E747C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828E7480: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E7484: 3B9D0028  addi r28, r29, 0x28
	ctx.r[28].s64 = ctx.r[29].s64 + 40;
	// 828E7488: 3BCB0FF0  addi r30, r11, 0xff0
	ctx.r[30].s64 = ctx.r[11].s64 + 4080;
	// 828E748C: C3EA08A4  lfs f31, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828E7490: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E7494: 4BFFEB15  bl 0x828e5fa8
	ctx.lr = 0x828E7498;
	sub_828E5FA8(ctx, base);
	// 828E7498: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E749C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828E74A0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E74A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E74A8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828E74AC: 419A0024  beq cr6, 0x828e74d0
	if ctx.cr[6].eq {
	pc = 0x828E74D0; continue 'dispatch;
	}
	// 828E74B0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828E74B4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E74B8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E74BC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E74C0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828E74C4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E74C8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E74CC: 4082FFE8  bne 0x828e74b4
	if !ctx.cr[0].eq {
	pc = 0x828E74B4; continue 'dispatch;
	}
	// 828E74D0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E74D4: 80DF0000  lwz r6, 0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E74D8: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 828E74DC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828E74E0: 38A004F2  li r5, 0x4f2
	ctx.r[5].s64 = 1266;
	// 828E74E4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828E74E8: 48571559  bl 0x82e58a40
	ctx.lr = 0x828E74EC;
	sub_82E58A40(ctx, base);
	// 828E74EC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828E74F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E74F4: 419A0008  beq cr6, 0x828e74fc
	if ctx.cr[6].eq {
	pc = 0x828E74FC; continue 'dispatch;
	}
	// 828E74F8: 4B9D9399  bl 0x822c0890
	ctx.lr = 0x828E74FC;
	sub_822C0890(ctx, base);
	// 828E74FC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828E7500: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E7504: 419A0008  beq cr6, 0x828e750c
	if ctx.cr[6].eq {
	pc = 0x828E750C; continue 'dispatch;
	}
	// 828E7508: 4B9D9389  bl 0x822c0890
	ctx.lr = 0x828E750C;
	sub_822C0890(ctx, base);
	// 828E750C: 817D03A4  lwz r11, 0x3a4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(932 as u32) ) } as u64;
	// 828E7510: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 828E7514: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828E7518: 409AFF78  bne cr6, 0x828e7490
	if !ctx.cr[6].eq {
	pc = 0x828E7490; continue 'dispatch;
	}
	// 828E751C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828E7520: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 828E7524: 488C0C94  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E7528(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E7528 size=200
    let mut pc: u32 = 0x828E7528;
    'dispatch: loop {
        match pc {
            0x828E7528 => {
    //   block [0x828E7528..0x828E75F0)
	// 828E7528: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E752C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E7530: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E7534: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E7538: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E753C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E7540: D021009C  stfs f1, 0x9c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 828E7544: 807F01CC  lwz r3, 0x1cc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(460 as u32) ) } as u64;
	// 828E7548: 4BF02E21  bl 0x827ea368
	ctx.lr = 0x828E754C;
	sub_827EA368(ctx, base);
	// 828E754C: 817F037C  lwz r11, 0x37c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(892 as u32) ) } as u64;
	// 828E7550: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E7554: 419A0084  beq cr6, 0x828e75d8
	if ctx.cr[6].eq {
	pc = 0x828E75D8; continue 'dispatch;
	}
	// 828E7558: 807F01CC  lwz r3, 0x1cc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(460 as u32) ) } as u64;
	// 828E755C: 3BC1009C  addi r30, r1, 0x9c
	ctx.r[30].s64 = ctx.r[1].s64 + 156;
	// 828E7560: 4BF02D49  bl 0x827ea2a8
	ctx.lr = 0x828E7564;
	sub_827EA2A8(ctx, base);
	// 828E7564: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828E7568: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E756C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828E7570: 4BFFEAA9  bl 0x828e6018
	ctx.lr = 0x828E7574;
	sub_828E6018(ctx, base);
	// 828E7574: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E7578: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828E757C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E7580: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E7584: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828E7588: 419A0024  beq cr6, 0x828e75ac
	if ctx.cr[6].eq {
	pc = 0x828E75AC; continue 'dispatch;
	}
	// 828E758C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828E7590: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E7594: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E7598: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E759C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828E75A0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E75A4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E75A8: 4082FFE8  bne 0x828e7590
	if !ctx.cr[0].eq {
	pc = 0x828E7590; continue 'dispatch;
	}
	// 828E75AC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E75B0: 807F037C  lwz r3, 0x37c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(892 as u32) ) } as u64;
	// 828E75B4: 4BF10AC5  bl 0x827f8078
	ctx.lr = 0x828E75B8;
	sub_827F8078(ctx, base);
	// 828E75B8: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828E75BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E75C0: 419A0008  beq cr6, 0x828e75c8
	if ctx.cr[6].eq {
	pc = 0x828E75C8; continue 'dispatch;
	}
	// 828E75C4: 4B9D92CD  bl 0x822c0890
	ctx.lr = 0x828E75C8;
	sub_822C0890(ctx, base);
	// 828E75C8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828E75CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E75D0: 419A0008  beq cr6, 0x828e75d8
	if ctx.cr[6].eq {
	pc = 0x828E75D8; continue 'dispatch;
	}
	// 828E75D4: 4B9D92BD  bl 0x822c0890
	ctx.lr = 0x828E75D8;
	sub_822C0890(ctx, base);
	// 828E75D8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828E75DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E75E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E75E4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E75E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E75EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E75F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E75F0 size=236
    let mut pc: u32 = 0x828E75F0;
    'dispatch: loop {
        match pc {
            0x828E75F0 => {
    //   block [0x828E75F0..0x828E76DC)
	// 828E75F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E75F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E75F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E75FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E7600: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 828E7604: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E7608: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E760C: 48021EDD  bl 0x829094e8
	ctx.lr = 0x828E7610;
	sub_829094E8(ctx, base);
	// 828E7610: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E7614: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E7618: 816B01B0  lwz r11, 0x1b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(432 as u32) ) } as u64;
	// 828E761C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E7620: 4E800421  bctrl
	ctx.lr = 0x828E7624;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E7624: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828E7628: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E762C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828E7630: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828E7634: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828E7638: C03E01B4  lfs f1, 0x1b4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(436 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828E763C: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 828E7640: 48036FF9  bl 0x8291e638
	ctx.lr = 0x828E7644;
	sub_8291E638(ctx, base);
	// 828E7644: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E7648: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828E764C: 3BDE01B0  addi r30, r30, 0x1b0
	ctx.r[30].s64 = ctx.r[30].s64 + 432;
	// 828E7650: 4BFFC559  bl 0x828e3ba8
	ctx.lr = 0x828E7654;
	sub_828E3BA8(ctx, base);
	// 828E7654: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828E7658: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828E765C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E7660: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 828E7664: 4BFFEA35  bl 0x828e6098
	ctx.lr = 0x828E7668;
	sub_828E6098(ctx, base);
	// 828E7668: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E766C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828E7670: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E7674: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E7678: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828E767C: 419A0024  beq cr6, 0x828e76a0
	if ctx.cr[6].eq {
	pc = 0x828E76A0; continue 'dispatch;
	}
	// 828E7680: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828E7684: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E7688: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E768C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E7690: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828E7694: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E7698: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E769C: 4082FFE8  bne 0x828e7684
	if !ctx.cr[0].eq {
	pc = 0x828E7684; continue 'dispatch;
	}
	// 828E76A0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E76A4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828E76A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E76AC: 48023DE5  bl 0x8290b490
	ctx.lr = 0x828E76B0;
	sub_8290B490(ctx, base);
	// 828E76B0: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828E76B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E76B8: 419A0008  beq cr6, 0x828e76c0
	if ctx.cr[6].eq {
	pc = 0x828E76C0; continue 'dispatch;
	}
	// 828E76BC: 4B9D91D5  bl 0x822c0890
	ctx.lr = 0x828E76C0;
	sub_822C0890(ctx, base);
	// 828E76C0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828E76C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E76C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E76CC: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 828E76D0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E76D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E76D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E76E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E76E0 size=236
    let mut pc: u32 = 0x828E76E0;
    'dispatch: loop {
        match pc {
            0x828E76E0 => {
    //   block [0x828E76E0..0x828E77CC)
	// 828E76E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E76E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E76E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E76EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E76F0: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 828E76F4: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E76F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E76FC: 48021DED  bl 0x829094e8
	ctx.lr = 0x828E7700;
	sub_829094E8(ctx, base);
	// 828E7700: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E7704: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E7708: 816B01B0  lwz r11, 0x1b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(432 as u32) ) } as u64;
	// 828E770C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E7710: 4E800421  bctrl
	ctx.lr = 0x828E7714;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E7714: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828E7718: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E771C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828E7720: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828E7724: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828E7728: C05E01BC  lfs f2, 0x1bc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(444 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 828E772C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828E7730: 48036F09  bl 0x8291e638
	ctx.lr = 0x828E7734;
	sub_8291E638(ctx, base);
	// 828E7734: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E7738: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828E773C: 3BDE01B8  addi r30, r30, 0x1b8
	ctx.r[30].s64 = ctx.r[30].s64 + 440;
	// 828E7740: 4BFFC469  bl 0x828e3ba8
	ctx.lr = 0x828E7744;
	sub_828E3BA8(ctx, base);
	// 828E7744: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828E7748: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828E774C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E7750: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 828E7754: 4BFFE945  bl 0x828e6098
	ctx.lr = 0x828E7758;
	sub_828E6098(ctx, base);
	// 828E7758: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E775C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828E7760: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E7764: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E7768: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828E776C: 419A0024  beq cr6, 0x828e7790
	if ctx.cr[6].eq {
	pc = 0x828E7790; continue 'dispatch;
	}
	// 828E7770: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828E7774: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E7778: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E777C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E7780: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828E7784: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E7788: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E778C: 4082FFE8  bne 0x828e7774
	if !ctx.cr[0].eq {
	pc = 0x828E7774; continue 'dispatch;
	}
	// 828E7790: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E7794: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828E7798: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E779C: 48023CF5  bl 0x8290b490
	ctx.lr = 0x828E77A0;
	sub_8290B490(ctx, base);
	// 828E77A0: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828E77A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E77A8: 419A0008  beq cr6, 0x828e77b0
	if ctx.cr[6].eq {
	pc = 0x828E77B0; continue 'dispatch;
	}
	// 828E77AC: 4B9D90E5  bl 0x822c0890
	ctx.lr = 0x828E77B0;
	sub_822C0890(ctx, base);
	// 828E77B0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828E77B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E77B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E77BC: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 828E77C0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E77C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E77C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E77D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E77D0 size=968
    let mut pc: u32 = 0x828E77D0;
    'dispatch: loop {
        match pc {
            0x828E77D0 => {
    //   block [0x828E77D0..0x828E7B98)
	// 828E77D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E77D4: 488C0991  bl 0x831a8164
	ctx.lr = 0x828E77D8;
	sub_831A8130(ctx, base);
	// 828E77D8: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 828E77DC: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E77E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E77E4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828E77E8: 807F0364  lwz r3, 0x364(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(868 as u32) ) } as u64;
	// 828E77EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E77F0: 419A039C  beq cr6, 0x828e7b8c
	if ctx.cr[6].eq {
	pc = 0x828E7B8C; continue 'dispatch;
	}
	// 828E77F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E77F8: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 828E77FC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828E7800: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E7804: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 828E7808: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E780C: 4E800421  bctrl
	ctx.lr = 0x828E7810;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E7810: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E7814: 41820378  beq 0x828e7b8c
	if ctx.cr[0].eq {
	pc = 0x828E7B8C; continue 'dispatch;
	}
	// 828E7818: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828E781C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E7820: 808B0B2C  lwz r4, 0xb2c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2860 as u32) ) } as u64;
	// 828E7824: 4850C1E5  bl 0x82df3a08
	ctx.lr = 0x828E7828;
	sub_82DF3A08(ctx, base);
	// 828E7828: 3B9F00FC  addi r28, r31, 0xfc
	ctx.r[28].s64 = ctx.r[31].s64 + 252;
	// 828E782C: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 828E7830: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828E7834: 48572E9D  bl 0x82e5a6d0
	ctx.lr = 0x828E7838;
	sub_82E5A6D0(ctx, base);
	// 828E7838: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E783C: 4850BA65  bl 0x82df32a0
	ctx.lr = 0x828E7840;
	sub_82DF32A0(ctx, base);
	// 828E7840: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E7844: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E7848: 4850BBE1  bl 0x82df3428
	ctx.lr = 0x828E784C;
	sub_82DF3428(ctx, base);
	// 828E784C: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E7850: 4182033C  beq 0x828e7b8c
	if ctx.cr[0].eq {
	pc = 0x828E7B8C; continue 'dispatch;
	}
	// 828E7854: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828E7858: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E785C: 808B0B40  lwz r4, 0xb40(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2880 as u32) ) } as u64;
	// 828E7860: 4850C1A9  bl 0x82df3a08
	ctx.lr = 0x828E7864;
	sub_82DF3A08(ctx, base);
	// 828E7864: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828E7868: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 828E786C: 48572E65  bl 0x82e5a6d0
	ctx.lr = 0x828E7870;
	sub_82E5A6D0(ctx, base);
	// 828E7870: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E7874: 4850BA95  bl 0x82df3308
	ctx.lr = 0x828E7878;
	sub_82DF3308(ctx, base);
	// 828E7878: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E787C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E7880: 4850BBA9  bl 0x82df3428
	ctx.lr = 0x828E7884;
	sub_82DF3428(ctx, base);
	// 828E7884: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E7888: 40820304  bne 0x828e7b8c
	if !ctx.cr[0].eq {
	pc = 0x828E7B8C; continue 'dispatch;
	}
	// 828E788C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828E7890: 83DF036C  lwz r30, 0x36c(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(876 as u32) ) } as u64;
	// 828E7894: 48572E3D  bl 0x82e5a6d0
	ctx.lr = 0x828E7898;
	sub_82E5A6D0(ctx, base);
	// 828E7898: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828E789C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E78A0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828E78A4: 4803A7ED  bl 0x82922090
	ctx.lr = 0x828E78A8;
	sub_82922090(ctx, base);
	// 828E78A8: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828E78AC: 418202E0  beq 0x828e7b8c
	if ctx.cr[0].eq {
	pc = 0x828E7B8C; continue 'dispatch;
	}
	// 828E78B0: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828E78B4: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828E78B8: 814A0BD4  lwz r10, 0xbd4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3028 as u32) ) } as u64;
	// 828E78BC: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E78C0: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E78C4: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 828E78C8: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 828E78CC: 41820014  beq 0x828e78e0
	if ctx.cr[0].eq {
	pc = 0x828E78E0; continue 'dispatch;
	}
	// 828E78D0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828E78D4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828E78D8: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828E78DC: 419AFFE0  beq cr6, 0x828e78bc
	if ctx.cr[6].eq {
	pc = 0x828E78BC; continue 'dispatch;
	}
	// 828E78E0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E78E4: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 828E78E8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828E78EC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828E78F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E78F4: 816B0068  lwz r11, 0x68(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 828E78F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E78FC: 40820058  bne 0x828e7954
	if !ctx.cr[0].eq {
	pc = 0x828E7954; continue 'dispatch;
	}
	// 828E7900: 4E800421  bctrl
	ctx.lr = 0x828E7904;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E7904: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E7908: 48021551  bl 0x82908e58
	ctx.lr = 0x828E790C;
	sub_82908E58(ctx, base);
	// 828E790C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828E7910: 396B08A4  addi r11, r11, 0x8a4
	ctx.r[11].s64 = ctx.r[11].s64 + 2212;
	// 828E7914: C3EB0000  lfs f31, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828E7918: FF01F800  fcmpu cr6, f1, f31
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 828E791C: 419900CC  bgt cr6, 0x828e79e8
	if ctx.cr[6].gt {
	pc = 0x828E79E8; continue 'dispatch;
	}
	// 828E7920: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828E7924: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E7928: 808B0B34  lwz r4, 0xb34(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2868 as u32) ) } as u64;
	// 828E792C: 4850C0DD  bl 0x82df3a08
	ctx.lr = 0x828E7930;
	sub_82DF3A08(ctx, base);
	// 828E7930: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828E7934: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828E7938: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828E793C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828E7940: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828E7944: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828E7948: 48577019  bl 0x82e5e960
	ctx.lr = 0x828E794C;
	sub_82E5E960(ctx, base);
	// 828E794C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828E7950: 4800008C  b 0x828e79dc
	pc = 0x828E79DC; continue 'dispatch;
	// 828E7954: 4E800421  bctrl
	ctx.lr = 0x828E7958;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E7958: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E795C: 4BF04805  bl 0x827ec160
	ctx.lr = 0x828E7960;
	sub_827EC160(ctx, base);
	// 828E7960: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828E7964: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E7968: 4802F431  bl 0x82916d98
	ctx.lr = 0x828E796C;
	sub_82916D98(ctx, base);
	// 828E796C: 39600050  li r11, 0x50
	ctx.r[11].s64 = 80;
	// 828E7970: 80E10058  lwz r7, 0x58(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828E7974: 394000D0  li r10, 0xd0
	ctx.r[10].s64 = 208;
	// 828E7978: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 828E797C: 390000E0  li r8, 0xe0
	ctx.r[8].s64 = 224;
	// 828E7980: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E7984: 13FD58C7  vcmpequd (lvx128) v31, v29, v11
	tmp.u32 = ctx.r[29].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828E7988: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E7B98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E7B98 size=420
    let mut pc: u32 = 0x828E7B98;
    'dispatch: loop {
        match pc {
            0x828E7B98 => {
    //   block [0x828E7B98..0x828E7D3C)
	// 828E7B98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E7B9C: 488C05C9  bl 0x831a8164
	ctx.lr = 0x828E7BA0;
	sub_831A8130(ctx, base);
	// 828E7BA0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E7BA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E7BA8: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828E7BAC: 48022695  bl 0x8290a240
	ctx.lr = 0x828E7BB0;
	sub_8290A240(ctx, base);
	// 828E7BB0: 807F0364  lwz r3, 0x364(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(868 as u32) ) } as u64;
	// 828E7BB4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E7BB8: 419A017C  beq cr6, 0x828e7d34
	if ctx.cr[6].eq {
	pc = 0x828E7D34; continue 'dispatch;
	}
	// 828E7BBC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E7BC0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828E7BC4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828E7BC8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828E7BCC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E7BD0: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 828E7BD4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E7BD8: 4E800421  bctrl
	ctx.lr = 0x828E7BDC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E7BDC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E7BE0: 41820154  beq 0x828e7d34
	if ctx.cr[0].eq {
	pc = 0x828E7D34; continue 'dispatch;
	}
	// 828E7BE4: 897C001C  lbz r11, 0x1c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) } as u64;
	// 828E7BE8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828E7BEC: 41820018  beq 0x828e7c04
	if ctx.cr[0].eq {
	pc = 0x828E7C04; continue 'dispatch;
	}
	// 828E7BF0: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 828E7BF4: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 828E7BF8: 13FC58C7  vcmpequd (lvx128) v31, v28, v11
	tmp.u32 = ctx.r[28].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E7D40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E7D40 size=180
    let mut pc: u32 = 0x828E7D40;
    'dispatch: loop {
        match pc {
            0x828E7D40 => {
    //   block [0x828E7D40..0x828E7DF4)
	// 828E7D40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E7D44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E7D48: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E7D4C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E7D50: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E7D54: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E7D58: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828E7D5C: 48022255  bl 0x82909fb0
	ctx.lr = 0x828E7D60;
	sub_82909FB0(ctx, base);
	// 828E7D60: 817E037C  lwz r11, 0x37c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(892 as u32) ) } as u64;
	// 828E7D64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E7D68: 419A0074  beq cr6, 0x828e7ddc
	if ctx.cr[6].eq {
	pc = 0x828E7DDC; continue 'dispatch;
	}
	// 828E7D6C: 389F0018  addi r4, r31, 0x18
	ctx.r[4].s64 = ctx.r[31].s64 + 24;
	// 828E7D70: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828E7D74: 4BC90B5D  bl 0x825788d0
	ctx.lr = 0x828E7D78;
	sub_825788D0(ctx, base);
	// 828E7D78: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E7D7C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828E7D80: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E7D84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E7D88: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828E7D8C: 419A0024  beq cr6, 0x828e7db0
	if ctx.cr[6].eq {
	pc = 0x828E7DB0; continue 'dispatch;
	}
	// 828E7D90: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828E7D94: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E7D98: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E7D9C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E7DA0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828E7DA4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E7DA8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E7DAC: 4082FFE8  bne 0x828e7d94
	if !ctx.cr[0].eq {
	pc = 0x828E7D94; continue 'dispatch;
	}
	// 828E7DB0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E7DB4: 807E037C  lwz r3, 0x37c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(892 as u32) ) } as u64;
	// 828E7DB8: 4BF102C1  bl 0x827f8078
	ctx.lr = 0x828E7DBC;
	sub_827F8078(ctx, base);
	// 828E7DBC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828E7DC0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E7DC4: 419A0008  beq cr6, 0x828e7dcc
	if ctx.cr[6].eq {
	pc = 0x828E7DCC; continue 'dispatch;
	}
	// 828E7DC8: 4B9D8AC9  bl 0x822c0890
	ctx.lr = 0x828E7DCC;
	sub_822C0890(ctx, base);
	// 828E7DCC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828E7DD0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E7DD4: 419A0008  beq cr6, 0x828e7ddc
	if ctx.cr[6].eq {
	pc = 0x828E7DDC; continue 'dispatch;
	}
	// 828E7DD8: 4B9D8AB9  bl 0x822c0890
	ctx.lr = 0x828E7DDC;
	sub_822C0890(ctx, base);
	// 828E7DDC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828E7DE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E7DE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E7DE8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E7DEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E7DF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E7DF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E7DF8 size=964
    let mut pc: u32 = 0x828E7DF8;
    'dispatch: loop {
        match pc {
            0x828E7DF8 => {
    //   block [0x828E7DF8..0x828E81BC)
	// 828E7DF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E7DFC: 488C0361  bl 0x831a815c
	ctx.lr = 0x828E7E00;
	sub_831A8130(ctx, base);
	// 828E7E00: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 828E7E04: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E7E08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E7E0C: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 828E7E10: 4BF04351  bl 0x827ec160
	ctx.lr = 0x828E7E14;
	sub_827EC160(ctx, base);
	// 828E7E14: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 828E7E18: 4802F219  bl 0x82917030
	ctx.lr = 0x828E7E1C;
	sub_82917030(ctx, base);
	// 828E7E1C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E7E20: 41820098  beq 0x828e7eb8
	if ctx.cr[0].eq {
	pc = 0x828E7EB8; continue 'dispatch;
	}
	// 828E7E24: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E7E28: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E7E2C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828E7E30: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828E7E34: 4BF80685  bl 0x828684b8
	ctx.lr = 0x828E7E38;
	sub_828684B8(ctx, base);
	// 828E7E38: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E7E3C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828E7E40: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E7E44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E7E48: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828E7E4C: 419A0024  beq cr6, 0x828e7e70
	if ctx.cr[6].eq {
	pc = 0x828E7E70; continue 'dispatch;
	}
	// 828E7E50: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828E7E54: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E7E58: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E7E5C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E7E60: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828E7E64: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E7E68: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E7E6C: 4082FFE8  bne 0x828e7e54
	if !ctx.cr[0].eq {
	pc = 0x828E7E54; continue 'dispatch;
	}
	// 828E7E70: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 828E7E74: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 828E7E78: 487202B1  bl 0x83008128
	ctx.lr = 0x828E7E7C;
	sub_83008128(ctx, base);
	// 828E7E7C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828E7E80: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828E7E84: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828E7E88: 388A0FF0  addi r4, r10, 0xff0
	ctx.r[4].s64 = ctx.r[10].s64 + 4080;
	// 828E7E8C: 38A006AE  li r5, 0x6ae
	ctx.r[5].s64 = 1710;
	// 828E7E90: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 828E7E94: C02BA1C4  lfs f1, -0x5e3c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828E7E98: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 828E7E9C: 48570BA5  bl 0x82e58a40
	ctx.lr = 0x828E7EA0;
	sub_82E58A40(ctx, base);
	// 828E7EA0: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828E7EA4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E7EA8: 419A0008  beq cr6, 0x828e7eb0
	if ctx.cr[6].eq {
	pc = 0x828E7EB0; continue 'dispatch;
	}
	// 828E7EAC: 4B9D89E5  bl 0x822c0890
	ctx.lr = 0x828E7EB0;
	sub_822C0890(ctx, base);
	// 828E7EB0: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 828E7EB4: 480002F0  b 0x828e81a4
	pc = 0x828E81A4; continue 'dispatch;
	// 828E7EB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E7EBC: 48020F9D  bl 0x82908e58
	ctx.lr = 0x828E7EC0;
	sub_82908E58(ctx, base);
	// 828E7EC0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828E7EC4: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828E7EC8: FF01F800  fcmpu cr6, f1, f31
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 828E7ECC: 409902E4  ble cr6, 0x828e81b0
	if !ctx.cr[6].gt {
	pc = 0x828E81B0; continue 'dispatch;
	}
	// 828E7ED0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E7ED4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E7ED8: 816B01AC  lwz r11, 0x1ac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(428 as u32) ) } as u64;
	// 828E7EDC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E7EE0: 4E800421  bctrl
	ctx.lr = 0x828E7EE4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E7EE4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E7EE8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E7EEC: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 828E7EF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E7EF4: 816B0190  lwz r11, 0x190(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(400 as u32) ) } as u64;
	// 828E7EF8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E7EFC: 4E800421  bctrl
	ctx.lr = 0x828E7F00;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E7F00: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E7F04: 546A063F  clrlwi. r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828E7F08: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 828E7F0C: 3B6B0FF0  addi r27, r11, 0xff0
	ctx.r[27].s64 = ctx.r[11].s64 + 4080;
	// 828E7F10: 41820040  beq 0x828e7f50
	if ctx.cr[0].eq {
	pc = 0x828E7F50; continue 'dispatch;
	}
	// 828E7F14: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828E7F18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E7F1C: 808BA090  lwz r4, -0x5f70(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24432 as u32) ) } as u64;
	// 828E7F20: 4850BAE9  bl 0x82df3a08
	ctx.lr = 0x828E7F24;
	sub_82DF3A08(ctx, base);
	// 828E7F24: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828E7F28: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828E7F2C: 389F00FC  addi r4, r31, 0xfc
	ctx.r[4].s64 = ctx.r[31].s64 + 252;
	// 828E7F30: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 828E7F34: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828E7F38: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828E7F3C: 48576A25  bl 0x82e5e960
	ctx.lr = 0x828E7F40;
	sub_82E5E960(ctx, base);
	// 828E7F40: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 828E7F44: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E7F48: 419A01D4  beq cr6, 0x828e811c
	if ctx.cr[6].eq {
	pc = 0x828E811C; continue 'dispatch;
	}
	// 828E7F4C: 480001CC  b 0x828e8118
	pc = 0x828E8118; continue 'dispatch;
	// 828E7F50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E7F54: 4812B72D  bl 0x82a13680
	ctx.lr = 0x828E7F58;
	sub_82A13680(ctx, base);
	// 828E7F58: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828E7F5C: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 828E7F60: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E7F64: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 828E7F68: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E81C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E81C0 size=968
    let mut pc: u32 = 0x828E81C0;
    'dispatch: loop {
        match pc {
            0x828E81C0 => {
    //   block [0x828E81C0..0x828E8588)
	// 828E81C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E81C4: 488BFF9D  bl 0x831a8160
	ctx.lr = 0x828E81C8;
	sub_831A8130(ctx, base);
	// 828E81C8: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 828E81CC: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E81D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E81D4: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 828E81D8: 4BF03F89  bl 0x827ec160
	ctx.lr = 0x828E81DC;
	sub_827EC160(ctx, base);
	// 828E81DC: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 828E81E0: 4802EE51  bl 0x82917030
	ctx.lr = 0x828E81E4;
	sub_82917030(ctx, base);
	// 828E81E4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E81E8: 41820098  beq 0x828e8280
	if ctx.cr[0].eq {
	pc = 0x828E8280; continue 'dispatch;
	}
	// 828E81EC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E81F0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E81F4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828E81F8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828E81FC: 4BF802BD  bl 0x828684b8
	ctx.lr = 0x828E8200;
	sub_828684B8(ctx, base);
	// 828E8200: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E8204: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828E8208: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E820C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E8210: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828E8214: 419A0024  beq cr6, 0x828e8238
	if ctx.cr[6].eq {
	pc = 0x828E8238; continue 'dispatch;
	}
	// 828E8218: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828E821C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E8220: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E8224: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E8228: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828E822C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E8230: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E8234: 4082FFE8  bne 0x828e821c
	if !ctx.cr[0].eq {
	pc = 0x828E821C; continue 'dispatch;
	}
	// 828E8238: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828E823C: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 828E8240: 4871FEE9  bl 0x83008128
	ctx.lr = 0x828E8244;
	sub_83008128(ctx, base);
	// 828E8244: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828E8248: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828E824C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828E8250: 388A0FF0  addi r4, r10, 0xff0
	ctx.r[4].s64 = ctx.r[10].s64 + 4080;
	// 828E8254: 38A0073C  li r5, 0x73c
	ctx.r[5].s64 = 1852;
	// 828E8258: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 828E825C: C02BA1C4  lfs f1, -0x5e3c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828E8260: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 828E8264: 485707DD  bl 0x82e58a40
	ctx.lr = 0x828E8268;
	sub_82E58A40(ctx, base);
	// 828E8268: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828E826C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E8270: 419A0008  beq cr6, 0x828e8278
	if ctx.cr[6].eq {
	pc = 0x828E8278; continue 'dispatch;
	}
	// 828E8274: 4B9D861D  bl 0x822c0890
	ctx.lr = 0x828E8278;
	sub_822C0890(ctx, base);
	// 828E8278: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 828E827C: 480002F4  b 0x828e8570
	pc = 0x828E8570; continue 'dispatch;
	// 828E8280: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E8284: 48020BD5  bl 0x82908e58
	ctx.lr = 0x828E8288;
	sub_82908E58(ctx, base);
	// 828E8288: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828E828C: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828E8290: FF01F800  fcmpu cr6, f1, f31
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 828E8294: 409902E8  ble cr6, 0x828e857c
	if !ctx.cr[6].gt {
	pc = 0x828E857C; continue 'dispatch;
	}
	// 828E8298: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E829C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E82A0: 816B01AC  lwz r11, 0x1ac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(428 as u32) ) } as u64;
	// 828E82A4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E82A8: 4E800421  bctrl
	ctx.lr = 0x828E82AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E82AC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E82B0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E82B4: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828E82B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E82BC: 816B0190  lwz r11, 0x190(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(400 as u32) ) } as u64;
	// 828E82C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E82C4: 4E800421  bctrl
	ctx.lr = 0x828E82C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E82C8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E82CC: 546A063F  clrlwi. r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828E82D0: 3B6B0FF0  addi r27, r11, 0xff0
	ctx.r[27].s64 = ctx.r[11].s64 + 4080;
	// 828E82D4: 41820040  beq 0x828e8314
	if ctx.cr[0].eq {
	pc = 0x828E8314; continue 'dispatch;
	}
	// 828E82D8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828E82DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E82E0: 808BA090  lwz r4, -0x5f70(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24432 as u32) ) } as u64;
	// 828E82E4: 4850B725  bl 0x82df3a08
	ctx.lr = 0x828E82E8;
	sub_82DF3A08(ctx, base);
	// 828E82E8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828E82EC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828E82F0: 389F00FC  addi r4, r31, 0xfc
	ctx.r[4].s64 = ctx.r[31].s64 + 252;
	// 828E82F4: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 828E82F8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828E82FC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828E8300: 48576661  bl 0x82e5e960
	ctx.lr = 0x828E8304;
	sub_82E5E960(ctx, base);
	// 828E8304: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 828E8308: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E830C: 419A01D8  beq cr6, 0x828e84e4
	if ctx.cr[6].eq {
	pc = 0x828E84E4; continue 'dispatch;
	}
	// 828E8310: 480001D0  b 0x828e84e0
	pc = 0x828E84E0; continue 'dispatch;
	// 828E8314: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E8318: 4812B369  bl 0x82a13680
	ctx.lr = 0x828E831C;
	sub_82A13680(ctx, base);
	// 828E831C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828E8320: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 828E8324: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E8328: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 828E832C: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E8588(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E8588 size=692
    let mut pc: u32 = 0x828E8588;
    'dispatch: loop {
        match pc {
            0x828E8588 => {
    //   block [0x828E8588..0x828E883C)
	// 828E8588: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E858C: 488BFBE1  bl 0x831a816c
	ctx.lr = 0x828E8590;
	sub_831A8130(ctx, base);
	// 828E8590: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 828E8594: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E8598: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E859C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828E85A0: 4BF03BC1  bl 0x827ec160
	ctx.lr = 0x828E85A4;
	sub_827EC160(ctx, base);
	// 828E85A4: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 828E85A8: 4802EA89  bl 0x82917030
	ctx.lr = 0x828E85AC;
	sub_82917030(ctx, base);
	// 828E85AC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E85B0: 41820098  beq 0x828e8648
	if ctx.cr[0].eq {
	pc = 0x828E8648; continue 'dispatch;
	}
	// 828E85B4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E85B8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E85BC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828E85C0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828E85C4: 4BF7FEF5  bl 0x828684b8
	ctx.lr = 0x828E85C8;
	sub_828684B8(ctx, base);
	// 828E85C8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E85CC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828E85D0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E85D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E85D8: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828E85DC: 419A0024  beq cr6, 0x828e8600
	if ctx.cr[6].eq {
	pc = 0x828E8600; continue 'dispatch;
	}
	// 828E85E0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828E85E4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E85E8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E85EC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E85F0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828E85F4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E85F8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E85FC: 4082FFE8  bne 0x828e85e4
	if !ctx.cr[0].eq {
	pc = 0x828E85E4; continue 'dispatch;
	}
	// 828E8600: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828E8604: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 828E8608: 4871FB21  bl 0x83008128
	ctx.lr = 0x828E860C;
	sub_83008128(ctx, base);
	// 828E860C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828E8610: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828E8614: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828E8618: 388A0FF0  addi r4, r10, 0xff0
	ctx.r[4].s64 = ctx.r[10].s64 + 4080;
	// 828E861C: 38A007CA  li r5, 0x7ca
	ctx.r[5].s64 = 1994;
	// 828E8620: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 828E8624: C02BA1C4  lfs f1, -0x5e3c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828E8628: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 828E862C: 48570415  bl 0x82e58a40
	ctx.lr = 0x828E8630;
	sub_82E58A40(ctx, base);
	// 828E8630: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828E8634: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E8638: 419A0008  beq cr6, 0x828e8640
	if ctx.cr[6].eq {
	pc = 0x828E8640; continue 'dispatch;
	}
	// 828E863C: 4B9D8255  bl 0x822c0890
	ctx.lr = 0x828E8640;
	sub_822C0890(ctx, base);
	// 828E8640: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828E8644: 480001E0  b 0x828e8824
	pc = 0x828E8824; continue 'dispatch;
	// 828E8648: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E864C: 4802080D  bl 0x82908e58
	ctx.lr = 0x828E8650;
	sub_82908E58(ctx, base);
	// 828E8650: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828E8654: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828E8658: FF01F800  fcmpu cr6, f1, f31
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 828E865C: 409901D4  ble cr6, 0x828e8830
	if !ctx.cr[6].gt {
	pc = 0x828E8830; continue 'dispatch;
	}
	// 828E8660: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E8664: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E8668: 816B01AC  lwz r11, 0x1ac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(428 as u32) ) } as u64;
	// 828E866C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E8670: 4E800421  bctrl
	ctx.lr = 0x828E8674;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E8674: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E8678: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E867C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828E8680: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E8684: 816B0190  lwz r11, 0x190(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(400 as u32) ) } as u64;
	// 828E8688: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E868C: 4E800421  bctrl
	ctx.lr = 0x828E8690;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E8690: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E8694: 41820038  beq 0x828e86cc
	if ctx.cr[0].eq {
	pc = 0x828E86CC; continue 'dispatch;
	}
	// 828E8698: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828E869C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E86A0: 808BA090  lwz r4, -0x5f70(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24432 as u32) ) } as u64;
	// 828E86A4: 4850B365  bl 0x82df3a08
	ctx.lr = 0x828E86A8;
	sub_82DF3A08(ctx, base);
	// 828E86A8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828E86AC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828E86B0: 389F00FC  addi r4, r31, 0xfc
	ctx.r[4].s64 = ctx.r[31].s64 + 252;
	// 828E86B4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828E86B8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828E86BC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828E86C0: 485762A1  bl 0x82e5e960
	ctx.lr = 0x828E86C4;
	sub_82E5E960(ctx, base);
	// 828E86C4: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828E86C8: 480000C0  b 0x828e8788
	pc = 0x828E8788; continue 'dispatch;
	// 828E86CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E86D0: 4812AFB1  bl 0x82a13680
	ctx.lr = 0x828E86D4;
	sub_82A13680(ctx, base);
	// 828E86D4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828E86D8: 394100A0  addi r10, r1, 0xa0
	ctx.r[10].s64 = ctx.r[1].s64 + 160;
	// 828E86DC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E86E0: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 828E86E4: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E8840(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E8840 size=68
    let mut pc: u32 = 0x828E8840;
    'dispatch: loop {
        match pc {
            0x828E8840 => {
    //   block [0x828E8840..0x828E8884)
	// 828E8840: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E8844: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E8848: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E884C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E8850: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E8854: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E8858: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828E885C: 4BFFCF3D  bl 0x828e5798
	ctx.lr = 0x828E8860;
	sub_828E5798(ctx, base);
	// 828E8860: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E8864: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E8868: 4BFFDCF1  bl 0x828e6558
	ctx.lr = 0x828E886C;
	sub_828E6558(ctx, base);
	// 828E886C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E8870: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E8874: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E8878: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E887C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E8880: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E8888(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E8888 size=692
    let mut pc: u32 = 0x828E8888;
    'dispatch: loop {
        match pc {
            0x828E8888 => {
    //   block [0x828E8888..0x828E8B3C)
	// 828E8888: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E888C: 488BF8E1  bl 0x831a816c
	ctx.lr = 0x828E8890;
	sub_831A8130(ctx, base);
	// 828E8890: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 828E8894: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E8898: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E889C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828E88A0: 4BF038C1  bl 0x827ec160
	ctx.lr = 0x828E88A4;
	sub_827EC160(ctx, base);
	// 828E88A4: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 828E88A8: 4802E789  bl 0x82917030
	ctx.lr = 0x828E88AC;
	sub_82917030(ctx, base);
	// 828E88AC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E88B0: 41820098  beq 0x828e8948
	if ctx.cr[0].eq {
	pc = 0x828E8948; continue 'dispatch;
	}
	// 828E88B4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E88B8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E88BC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828E88C0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828E88C4: 4BF7FBF5  bl 0x828684b8
	ctx.lr = 0x828E88C8;
	sub_828684B8(ctx, base);
	// 828E88C8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E88CC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828E88D0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E88D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E88D8: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828E88DC: 419A0024  beq cr6, 0x828e8900
	if ctx.cr[6].eq {
	pc = 0x828E8900; continue 'dispatch;
	}
	// 828E88E0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828E88E4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E88E8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E88EC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E88F0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828E88F4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E88F8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E88FC: 4082FFE8  bne 0x828e88e4
	if !ctx.cr[0].eq {
	pc = 0x828E88E4; continue 'dispatch;
	}
	// 828E8900: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828E8904: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 828E8908: 4871F821  bl 0x83008128
	ctx.lr = 0x828E890C;
	sub_83008128(ctx, base);
	// 828E890C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828E8910: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828E8914: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828E8918: 388A0FF0  addi r4, r10, 0xff0
	ctx.r[4].s64 = ctx.r[10].s64 + 4080;
	// 828E891C: 38A0085E  li r5, 0x85e
	ctx.r[5].s64 = 2142;
	// 828E8920: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 828E8924: C02BA1C4  lfs f1, -0x5e3c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828E8928: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 828E892C: 48570115  bl 0x82e58a40
	ctx.lr = 0x828E8930;
	sub_82E58A40(ctx, base);
	// 828E8930: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828E8934: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E8938: 419A0008  beq cr6, 0x828e8940
	if ctx.cr[6].eq {
	pc = 0x828E8940; continue 'dispatch;
	}
	// 828E893C: 4B9D7F55  bl 0x822c0890
	ctx.lr = 0x828E8940;
	sub_822C0890(ctx, base);
	// 828E8940: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828E8944: 480001E0  b 0x828e8b24
	pc = 0x828E8B24; continue 'dispatch;
	// 828E8948: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E894C: 4802050D  bl 0x82908e58
	ctx.lr = 0x828E8950;
	sub_82908E58(ctx, base);
	// 828E8950: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828E8954: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828E8958: FF01F800  fcmpu cr6, f1, f31
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 828E895C: 409901D4  ble cr6, 0x828e8b30
	if !ctx.cr[6].gt {
	pc = 0x828E8B30; continue 'dispatch;
	}
	// 828E8960: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E8964: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E8968: 816B01AC  lwz r11, 0x1ac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(428 as u32) ) } as u64;
	// 828E896C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E8970: 4E800421  bctrl
	ctx.lr = 0x828E8974;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E8974: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E8978: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E897C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828E8980: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E8984: 816B0190  lwz r11, 0x190(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(400 as u32) ) } as u64;
	// 828E8988: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E898C: 4E800421  bctrl
	ctx.lr = 0x828E8990;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E8990: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E8994: 41820038  beq 0x828e89cc
	if ctx.cr[0].eq {
	pc = 0x828E89CC; continue 'dispatch;
	}
	// 828E8998: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828E899C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E89A0: 808BA090  lwz r4, -0x5f70(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24432 as u32) ) } as u64;
	// 828E89A4: 4850B065  bl 0x82df3a08
	ctx.lr = 0x828E89A8;
	sub_82DF3A08(ctx, base);
	// 828E89A8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828E89AC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828E89B0: 389F00FC  addi r4, r31, 0xfc
	ctx.r[4].s64 = ctx.r[31].s64 + 252;
	// 828E89B4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828E89B8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828E89BC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828E89C0: 48575FA1  bl 0x82e5e960
	ctx.lr = 0x828E89C4;
	sub_82E5E960(ctx, base);
	// 828E89C4: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828E89C8: 480000C0  b 0x828e8a88
	pc = 0x828E8A88; continue 'dispatch;
	// 828E89CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E89D0: 4812ACB1  bl 0x82a13680
	ctx.lr = 0x828E89D4;
	sub_82A13680(ctx, base);
	// 828E89D4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828E89D8: 394100A0  addi r10, r1, 0xa0
	ctx.r[10].s64 = ctx.r[1].s64 + 160;
	// 828E89DC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E89E0: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 828E89E4: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E8B40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E8B40 size=692
    let mut pc: u32 = 0x828E8B40;
    'dispatch: loop {
        match pc {
            0x828E8B40 => {
    //   block [0x828E8B40..0x828E8DF4)
	// 828E8B40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E8B44: 488BF629  bl 0x831a816c
	ctx.lr = 0x828E8B48;
	sub_831A8130(ctx, base);
	// 828E8B48: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 828E8B4C: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E8B50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E8B54: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828E8B58: 4BF03609  bl 0x827ec160
	ctx.lr = 0x828E8B5C;
	sub_827EC160(ctx, base);
	// 828E8B5C: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 828E8B60: 4802E4D1  bl 0x82917030
	ctx.lr = 0x828E8B64;
	sub_82917030(ctx, base);
	// 828E8B64: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E8B68: 41820098  beq 0x828e8c00
	if ctx.cr[0].eq {
	pc = 0x828E8C00; continue 'dispatch;
	}
	// 828E8B6C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E8B70: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E8B74: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828E8B78: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828E8B7C: 4BF7F93D  bl 0x828684b8
	ctx.lr = 0x828E8B80;
	sub_828684B8(ctx, base);
	// 828E8B80: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E8B84: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828E8B88: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E8B8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E8B90: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828E8B94: 419A0024  beq cr6, 0x828e8bb8
	if ctx.cr[6].eq {
	pc = 0x828E8BB8; continue 'dispatch;
	}
	// 828E8B98: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828E8B9C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E8BA0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E8BA4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E8BA8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828E8BAC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E8BB0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E8BB4: 4082FFE8  bne 0x828e8b9c
	if !ctx.cr[0].eq {
	pc = 0x828E8B9C; continue 'dispatch;
	}
	// 828E8BB8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828E8BBC: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 828E8BC0: 4871F569  bl 0x83008128
	ctx.lr = 0x828E8BC4;
	sub_83008128(ctx, base);
	// 828E8BC4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828E8BC8: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828E8BCC: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828E8BD0: 388A0FF0  addi r4, r10, 0xff0
	ctx.r[4].s64 = ctx.r[10].s64 + 4080;
	// 828E8BD4: 38A008D8  li r5, 0x8d8
	ctx.r[5].s64 = 2264;
	// 828E8BD8: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 828E8BDC: C02BA1C4  lfs f1, -0x5e3c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828E8BE0: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 828E8BE4: 4856FE5D  bl 0x82e58a40
	ctx.lr = 0x828E8BE8;
	sub_82E58A40(ctx, base);
	// 828E8BE8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828E8BEC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E8BF0: 419A0008  beq cr6, 0x828e8bf8
	if ctx.cr[6].eq {
	pc = 0x828E8BF8; continue 'dispatch;
	}
	// 828E8BF4: 4B9D7C9D  bl 0x822c0890
	ctx.lr = 0x828E8BF8;
	sub_822C0890(ctx, base);
	// 828E8BF8: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828E8BFC: 480001E0  b 0x828e8ddc
	pc = 0x828E8DDC; continue 'dispatch;
	// 828E8C00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E8C04: 48020255  bl 0x82908e58
	ctx.lr = 0x828E8C08;
	sub_82908E58(ctx, base);
	// 828E8C08: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828E8C0C: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828E8C10: FF01F800  fcmpu cr6, f1, f31
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 828E8C14: 409901D4  ble cr6, 0x828e8de8
	if !ctx.cr[6].gt {
	pc = 0x828E8DE8; continue 'dispatch;
	}
	// 828E8C18: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E8C1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E8C20: 816B01AC  lwz r11, 0x1ac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(428 as u32) ) } as u64;
	// 828E8C24: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E8C28: 4E800421  bctrl
	ctx.lr = 0x828E8C2C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E8C2C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E8C30: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E8C34: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828E8C38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E8C3C: 816B0190  lwz r11, 0x190(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(400 as u32) ) } as u64;
	// 828E8C40: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E8C44: 4E800421  bctrl
	ctx.lr = 0x828E8C48;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E8C48: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E8C4C: 41820038  beq 0x828e8c84
	if ctx.cr[0].eq {
	pc = 0x828E8C84; continue 'dispatch;
	}
	// 828E8C50: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828E8C54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E8C58: 808BA090  lwz r4, -0x5f70(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24432 as u32) ) } as u64;
	// 828E8C5C: 4850ADAD  bl 0x82df3a08
	ctx.lr = 0x828E8C60;
	sub_82DF3A08(ctx, base);
	// 828E8C60: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828E8C64: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828E8C68: 389F00FC  addi r4, r31, 0xfc
	ctx.r[4].s64 = ctx.r[31].s64 + 252;
	// 828E8C6C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828E8C70: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828E8C74: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828E8C78: 48575CE9  bl 0x82e5e960
	ctx.lr = 0x828E8C7C;
	sub_82E5E960(ctx, base);
	// 828E8C7C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828E8C80: 480000C0  b 0x828e8d40
	pc = 0x828E8D40; continue 'dispatch;
	// 828E8C84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E8C88: 4812A9F9  bl 0x82a13680
	ctx.lr = 0x828E8C8C;
	sub_82A13680(ctx, base);
	// 828E8C8C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828E8C90: 394100A0  addi r10, r1, 0xa0
	ctx.r[10].s64 = ctx.r[1].s64 + 160;
	// 828E8C94: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E8C98: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 828E8C9C: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E8DF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828E8DF8 size=36
    let mut pc: u32 = 0x828E8DF8;
    'dispatch: loop {
        match pc {
            0x828E8DF8 => {
    //   block [0x828E8DF8..0x828E8E1C)
	// 828E8DF8: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 828E8DFC: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E8E00: 81490008  lwz r10, 8(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 828E8E04: 88A90010  lbz r5, 0x10(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 828E8E08: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828E8E0C: 8089000C  lwz r4, 0xc(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 828E8E10: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E8E14: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E8E18: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E8E20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E8E20 size=92
    let mut pc: u32 = 0x828E8E20;
    'dispatch: loop {
        match pc {
            0x828E8E20 => {
    //   block [0x828E8E20..0x828E8E7C)
	// 828E8E20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E8E24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E8E28: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E8E2C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E8E30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E8E34: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 828E8E38: 409A001C  bne cr6, 0x828e8e54
	if !ctx.cr[6].eq {
	pc = 0x828E8E54; continue 'dispatch;
	}
	// 828E8E3C: 4801FEED  bl 0x82908d28
	ctx.lr = 0x828E8E40;
	sub_82908D28(ctx, base);
	// 828E8E40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E8E44: 4BFFE615  bl 0x828e7458
	ctx.lr = 0x828E8E48;
	sub_828E7458(ctx, base);
	// 828E8E48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E8E4C: 4BC27785  bl 0x825105d0
	ctx.lr = 0x828E8E50;
	sub_825105D0(ctx, base);
	// 828E8E50: 48000018  b 0x828e8e68
	pc = 0x828E8E68; continue 'dispatch;
	// 828E8E54: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E8E58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E8E5C: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 828E8E60: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828E8E64: 4E800421  bctrl
	ctx.lr = 0x828E8E68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828E8E68: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828E8E6C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E8E70: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E8E74: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E8E78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E8E80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E8E80 size=568
    let mut pc: u32 = 0x828E8E80;
    'dispatch: loop {
        match pc {
            0x828E8E80 => {
    //   block [0x828E8E80..0x828E90B8)
	// 828E8E80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E8E84: 488BF2DD  bl 0x831a8160
	ctx.lr = 0x828E8E88;
	sub_831A8130(ctx, base);
	// 828E8E88: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 828E8E8C: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E8E90: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E8E94: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 828E8E98: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E8E9C: 4BFFAD0D  bl 0x828e3ba8
	ctx.lr = 0x828E8EA0;
	sub_828E3BA8(ctx, base);
	// 828E8EA0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828E8EA4: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828E8EA8: 817E0384  lwz r11, 0x384(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(900 as u32) ) } as u64;
	// 828E8EAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E8EB0: 419A0148  beq cr6, 0x828e8ff8
	if ctx.cr[6].eq {
	pc = 0x828E8FF8; continue 'dispatch;
	}
	// 828E8EB4: 839E0390  lwz r28, 0x390(r30)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(912 as u32) ) } as u64;
	// 828E8EB8: 48000134  b 0x828e8fec
	pc = 0x828E8FEC; continue 'dispatch;
	// 828E8EBC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828E8EC0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828E8EC4: 4BC26605  bl 0x8250f4c8
	ctx.lr = 0x828E8EC8;
	sub_8250F4C8(ctx, base);
	// 828E8EC8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E8ECC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E8ED0: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 828E8ED4: 409A0008  bne cr6, 0x828e8edc
	if !ctx.cr[6].eq {
	pc = 0x828E8EDC; continue 'dispatch;
	}
	// 828E8ED8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828E8EDC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828E8EE0: 4BC216E9  bl 0x8250a5c8
	ctx.lr = 0x828E8EE4;
	sub_8250A5C8(ctx, base);
	// 828E8EE4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E8EE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E8EEC: 388BFF40  addi r4, r11, -0xc0
	ctx.r[4].s64 = ctx.r[11].s64 + -192;
	// 828E8EF0: 409A0008  bne cr6, 0x828e8ef8
	if !ctx.cr[6].eq {
	pc = 0x828E8EF8; continue 'dispatch;
	}
	// 828E8EF4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828E8EF8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828E8EFC: 80BC0000  lwz r5, 0(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E8F00: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828E8F04: 4BEC354D  bl 0x827ac450
	ctx.lr = 0x828E8F08;
	sub_827AC450(ctx, base);
	// 828E8F08: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828E8F0C: 48508D85  bl 0x82df1c90
	ctx.lr = 0x828E8F10;
	sub_82DF1C90(ctx, base);
	// 828E8F10: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828E8F14: 48508D7D  bl 0x82df1c90
	ctx.lr = 0x828E8F18;
	sub_82DF1C90(ctx, base);
	// 828E8F18: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 828E8F1C: 81410088  lwz r10, 0x88(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 828E8F20: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828E8F24: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828E8F28: 419A00B8  beq cr6, 0x828e8fe0
	if ctx.cr[6].eq {
	pc = 0x828E8FE0; continue 'dispatch;
	}
	// 828E8F2C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828E8F30: 3BBE0028  addi r29, r30, 0x28
	ctx.r[29].s64 = ctx.r[30].s64 + 40;
	// 828E8F34: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 828E8F38: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828E8F3C: 3B610050  addi r27, r1, 0x50
	ctx.r[27].s64 = ctx.r[1].s64 + 80;
	// 828E8F40: 3B410090  addi r26, r1, 0x90
	ctx.r[26].s64 = ctx.r[1].s64 + 144;
	// 828E8F44: 48720075  bl 0x83008fb8
	ctx.lr = 0x828E8F48;
	sub_83008FB8(ctx, base);
	// 828E8F48: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828E8F4C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828E8F50: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828E8F54: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 828E8F58: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 828E8F5C: 480356F5  bl 0x8291e650
	ctx.lr = 0x828E8F60;
	sub_8291E650(ctx, base);
	// 828E8F60: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828E8F64: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828E8F68: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 828E8F6C: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 828E8F70: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 828E8F74: 4BFFD1AD  bl 0x828e6120
	ctx.lr = 0x828E8F78;
	sub_828E6120(ctx, base);
	// 828E8F78: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E8F7C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828E8F80: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E8F84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E8F88: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828E8F8C: 419A0024  beq cr6, 0x828e8fb0
	if ctx.cr[6].eq {
	pc = 0x828E8FB0; continue 'dispatch;
	}
	// 828E8F90: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828E8F94: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E8F98: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E8F9C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E8FA0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828E8FA4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E8FA8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E8FAC: 4082FFE8  bne 0x828e8f94
	if !ctx.cr[0].eq {
	pc = 0x828E8F94; continue 'dispatch;
	}
	// 828E8FB0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828E8FB4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828E8FB8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E8FBC: 480224D5  bl 0x8290b490
	ctx.lr = 0x828E8FC0;
	sub_8290B490(ctx, base);
	// 828E8FC0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828E8FC4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E8FC8: 419A0008  beq cr6, 0x828e8fd0
	if ctx.cr[6].eq {
	pc = 0x828E8FD0; continue 'dispatch;
	}
	// 828E8FCC: 4B9D78C5  bl 0x822c0890
	ctx.lr = 0x828E8FD0;
	sub_822C0890(ctx, base);
	// 828E8FD0: 81610088  lwz r11, 0x88(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 828E8FD4: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 828E8FD8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828E8FDC: 409AFF5C  bne cr6, 0x828e8f38
	if !ctx.cr[6].eq {
	pc = 0x828E8F38; continue 'dispatch;
	}
	// 828E8FE0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828E8FE4: 4BB8101D  bl 0x8246a000
	ctx.lr = 0x828E8FE8;
	sub_8246A000(ctx, base);
	// 828E8FE8: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 828E8FEC: 817E0394  lwz r11, 0x394(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(916 as u32) ) } as u64;
	// 828E8FF0: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828E8FF4: 409AFEC8  bne cr6, 0x828e8ebc
	if !ctx.cr[6].eq {
	pc = 0x828E8EBC; continue 'dispatch;
	}
	// 828E8FF8: 83FE03A0  lwz r31, 0x3a0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(928 as u32) ) } as u64;
	// 828E8FFC: 817E03A4  lwz r11, 0x3a4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(932 as u32) ) } as u64;
	// 828E9000: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828E9004: 419A00A8  beq cr6, 0x828e90ac
	if ctx.cr[6].eq {
	pc = 0x828E90AC; continue 'dispatch;
	}
	// 828E9008: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828E900C: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 828E9010: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 828E9014: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 828E9018: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828E901C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828E9020: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 828E9024: 3B810090  addi r28, r1, 0x90
	ctx.r[28].s64 = ctx.r[1].s64 + 144;
	// 828E9028: 48035611  bl 0x8291e638
	ctx.lr = 0x828E902C;
	sub_8291E638(ctx, base);
	// 828E902C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828E9030: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 828E9034: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828E9038: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 828E903C: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 828E9040: 4BFFD0E1  bl 0x828e6120
	ctx.lr = 0x828E9044;
	sub_828E6120(ctx, base);
	// 828E9044: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E9048: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828E904C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E9050: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E9054: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828E9058: 419A0024  beq cr6, 0x828e907c
	if ctx.cr[6].eq {
	pc = 0x828E907C; continue 'dispatch;
	}
	// 828E905C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828E9060: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E9064: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E9068: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E906C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828E9070: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E9074: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E9078: 4082FFE8  bne 0x828e9060
	if !ctx.cr[0].eq {
	pc = 0x828E9060; continue 'dispatch;
	}
	// 828E907C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828E9080: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828E9084: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E9088: 48022409  bl 0x8290b490
	ctx.lr = 0x828E908C;
	sub_8290B490(ctx, base);
	// 828E908C: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 828E9090: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E9094: 419A0008  beq cr6, 0x828e909c
	if ctx.cr[6].eq {
	pc = 0x828E909C; continue 'dispatch;
	}
	// 828E9098: 4B9D77F9  bl 0x822c0890
	ctx.lr = 0x828E909C;
	sub_822C0890(ctx, base);
	// 828E909C: 817E03A4  lwz r11, 0x3a4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(932 as u32) ) } as u64;
	// 828E90A0: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 828E90A4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828E90A8: 409AFF68  bne cr6, 0x828e9010
	if !ctx.cr[6].eq {
	pc = 0x828E9010; continue 'dispatch;
	}
	// 828E90AC: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 828E90B0: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 828E90B4: 488BF0FC  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E90B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E90B8 size=348
    let mut pc: u32 = 0x828E90B8;
    'dispatch: loop {
        match pc {
            0x828E90B8 => {
    //   block [0x828E90B8..0x828E9214)
	// 828E90B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E90BC: 488BF0AD  bl 0x831a8168
	ctx.lr = 0x828E90C0;
	sub_831A8130(ctx, base);
	// 828E90C0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E90C4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E90C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E90CC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828E90D0: 388B0FF0  addi r4, r11, 0xff0
	ctx.r[4].s64 = ctx.r[11].s64 + 4080;
	// 828E90D4: 38A00694  li r5, 0x694
	ctx.r[5].s64 = 1684;
	// 828E90D8: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828E90DC: 4B9D72FD  bl 0x822c03d8
	ctx.lr = 0x828E90E0;
	sub_822C03D8(ctx, base);
	// 828E90E0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828E90E4: 41820014  beq 0x828e90f8
	if ctx.cr[0].eq {
	pc = 0x828E90F8; continue 'dispatch;
	}
	// 828E90E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E90EC: 4BF0F445  bl 0x827f8530
	ctx.lr = 0x828E90F0;
	sub_827F8530(ctx, base);
	// 828E90F0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828E90F4: 48000008  b 0x828e90fc
	pc = 0x828E90FC; continue 'dispatch;
	// 828E90F8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828E90FC: 3BDF037C  addi r30, r31, 0x37c
	ctx.r[30].s64 = ctx.r[31].s64 + 892;
	// 828E9100: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E9104: 4BF9FF55  bl 0x82889058
	ctx.lr = 0x828E9108;
	sub_82889058(ctx, base);
	// 828E9108: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 828E910C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E9110: 388BF818  addi r4, r11, -0x7e8
	ctx.r[4].s64 = ctx.r[11].s64 + -2024;
	// 828E9114: 4850A8F5  bl 0x82df3a08
	ctx.lr = 0x828E9118;
	sub_82DF3A08(ctx, base);
	// 828E9118: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E911C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828E9120: 4BF034A9  bl 0x827ec5c8
	ctx.lr = 0x828E9124;
	sub_827EC5C8(ctx, base);
	// 828E9124: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828E9128: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 828E912C: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E9130: 4871FE89  bl 0x83008fb8
	ctx.lr = 0x828E9134;
	sub_83008FB8(ctx, base);
	// 828E9134: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828E9138: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828E913C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828E9140: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828E9144: 4852BEED  bl 0x82e15030
	ctx.lr = 0x828E9148;
	sub_82E15030(ctx, base);
	// 828E9148: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828E914C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828E9150: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828E9154: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828E9158: 4BF259D1  bl 0x8280eb28
	ctx.lr = 0x828E915C;
	sub_8280EB28(ctx, base);
	// 828E915C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E9160: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828E9164: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E9168: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E916C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828E9170: 419A0024  beq cr6, 0x828e9194
	if ctx.cr[6].eq {
	pc = 0x828E9194; continue 'dispatch;
	}
	// 828E9174: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828E9178: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E917C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E9180: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E9184: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828E9188: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E918C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E9190: 4082FFE8  bne 0x828e9178
	if !ctx.cr[0].eq {
	pc = 0x828E9178; continue 'dispatch;
	}
	// 828E9194: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828E9198: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E919C: 419A0008  beq cr6, 0x828e91a4
	if ctx.cr[6].eq {
	pc = 0x828E91A4; continue 'dispatch;
	}
	// 828E91A0: 4B9D76F1  bl 0x822c0890
	ctx.lr = 0x828E91A4;
	sub_822C0890(ctx, base);
	// 828E91A4: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828E91A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E91AC: 419A0008  beq cr6, 0x828e91b4
	if ctx.cr[6].eq {
	pc = 0x828E91B4; continue 'dispatch;
	}
	// 828E91B0: 4B9D76E1  bl 0x822c0890
	ctx.lr = 0x828E91B4;
	sub_822C0890(ctx, base);
	// 828E91B4: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828E91B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E91BC: 419A0008  beq cr6, 0x828e91c4
	if ctx.cr[6].eq {
	pc = 0x828E91C4; continue 'dispatch;
	}
	// 828E91C0: 4B9D76D1  bl 0x822c0890
	ctx.lr = 0x828E91C4;
	sub_822C0890(ctx, base);
	// 828E91C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E91C8: 4850A261  bl 0x82df3428
	ctx.lr = 0x828E91CC;
	sub_82DF3428(ctx, base);
	// 828E91CC: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828E91D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E91D4: 419A0028  beq cr6, 0x828e91fc
	if ctx.cr[6].eq {
	pc = 0x828E91FC; continue 'dispatch;
	}
	// 828E91D8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828E91DC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828E91E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E91E4: 4BF03E8D  bl 0x827ed070
	ctx.lr = 0x828E91E8;
	sub_827ED070(ctx, base);
	// 828E91E8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E91EC: 80A10058  lwz r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828E91F0: 388B1148  addi r4, r11, 0x1148
	ctx.r[4].s64 = ctx.r[11].s64 + 4424;
	// 828E91F4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E91F8: 4BF0F211  bl 0x827f8408
	ctx.lr = 0x828E91FC;
	sub_827F8408(ctx, base);
	// 828E91FC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828E9200: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E9204: 419A0008  beq cr6, 0x828e920c
	if ctx.cr[6].eq {
	pc = 0x828E920C; continue 'dispatch;
	}
	// 828E9208: 4B9D7689  bl 0x822c0890
	ctx.lr = 0x828E920C;
	sub_822C0890(ctx, base);
	// 828E920C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828E9210: 488BEFA8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E9218(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E9218 size=348
    let mut pc: u32 = 0x828E9218;
    'dispatch: loop {
        match pc {
            0x828E9218 => {
    //   block [0x828E9218..0x828E9374)
	// 828E9218: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E921C: 488BEF4D  bl 0x831a8168
	ctx.lr = 0x828E9220;
	sub_831A8130(ctx, base);
	// 828E9220: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E9224: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E9228: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E922C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828E9230: 388B0FF0  addi r4, r11, 0xff0
	ctx.r[4].s64 = ctx.r[11].s64 + 4080;
	// 828E9234: 38A00722  li r5, 0x722
	ctx.r[5].s64 = 1826;
	// 828E9238: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828E923C: 4B9D719D  bl 0x822c03d8
	ctx.lr = 0x828E9240;
	sub_822C03D8(ctx, base);
	// 828E9240: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828E9244: 41820014  beq 0x828e9258
	if ctx.cr[0].eq {
	pc = 0x828E9258; continue 'dispatch;
	}
	// 828E9248: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E924C: 4BF0F2E5  bl 0x827f8530
	ctx.lr = 0x828E9250;
	sub_827F8530(ctx, base);
	// 828E9250: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828E9254: 48000008  b 0x828e925c
	pc = 0x828E925C; continue 'dispatch;
	// 828E9258: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828E925C: 3BDF037C  addi r30, r31, 0x37c
	ctx.r[30].s64 = ctx.r[31].s64 + 892;
	// 828E9260: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E9264: 4BF9FDF5  bl 0x82889058
	ctx.lr = 0x828E9268;
	sub_82889058(ctx, base);
	// 828E9268: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 828E926C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E9270: 388BF818  addi r4, r11, -0x7e8
	ctx.r[4].s64 = ctx.r[11].s64 + -2024;
	// 828E9274: 4850A795  bl 0x82df3a08
	ctx.lr = 0x828E9278;
	sub_82DF3A08(ctx, base);
	// 828E9278: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E927C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828E9280: 4BF03349  bl 0x827ec5c8
	ctx.lr = 0x828E9284;
	sub_827EC5C8(ctx, base);
	// 828E9284: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828E9288: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 828E928C: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E9290: 4871FD29  bl 0x83008fb8
	ctx.lr = 0x828E9294;
	sub_83008FB8(ctx, base);
	// 828E9294: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828E9298: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828E929C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828E92A0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828E92A4: 4852BD8D  bl 0x82e15030
	ctx.lr = 0x828E92A8;
	sub_82E15030(ctx, base);
	// 828E92A8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828E92AC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828E92B0: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828E92B4: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 828E92B8: 4BF25871  bl 0x8280eb28
	ctx.lr = 0x828E92BC;
	sub_8280EB28(ctx, base);
	// 828E92BC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E92C0: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828E92C4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E92C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E92CC: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828E92D0: 419A0024  beq cr6, 0x828e92f4
	if ctx.cr[6].eq {
	pc = 0x828E92F4; continue 'dispatch;
	}
	// 828E92D4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828E92D8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E92DC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E92E0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E92E4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828E92E8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E92EC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E92F0: 4082FFE8  bne 0x828e92d8
	if !ctx.cr[0].eq {
	pc = 0x828E92D8; continue 'dispatch;
	}
	// 828E92F4: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828E92F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E92FC: 419A0008  beq cr6, 0x828e9304
	if ctx.cr[6].eq {
	pc = 0x828E9304; continue 'dispatch;
	}
	// 828E9300: 4B9D7591  bl 0x822c0890
	ctx.lr = 0x828E9304;
	sub_822C0890(ctx, base);
	// 828E9304: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828E9308: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E930C: 419A0008  beq cr6, 0x828e9314
	if ctx.cr[6].eq {
	pc = 0x828E9314; continue 'dispatch;
	}
	// 828E9310: 4B9D7581  bl 0x822c0890
	ctx.lr = 0x828E9314;
	sub_822C0890(ctx, base);
	// 828E9314: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828E9318: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E931C: 419A0008  beq cr6, 0x828e9324
	if ctx.cr[6].eq {
	pc = 0x828E9324; continue 'dispatch;
	}
	// 828E9320: 4B9D7571  bl 0x822c0890
	ctx.lr = 0x828E9324;
	sub_822C0890(ctx, base);
	// 828E9324: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E9328: 4850A101  bl 0x82df3428
	ctx.lr = 0x828E932C;
	sub_82DF3428(ctx, base);
	// 828E932C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828E9330: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E9334: 419A0028  beq cr6, 0x828e935c
	if ctx.cr[6].eq {
	pc = 0x828E935C; continue 'dispatch;
	}
	// 828E9338: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828E933C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828E9340: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E9344: 4BF03D2D  bl 0x827ed070
	ctx.lr = 0x828E9348;
	sub_827ED070(ctx, base);
	// 828E9348: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E934C: 80A10058  lwz r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828E9350: 388B1148  addi r4, r11, 0x1148
	ctx.r[4].s64 = ctx.r[11].s64 + 4424;
	// 828E9354: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E9358: 4BF0F0B1  bl 0x827f8408
	ctx.lr = 0x828E935C;
	sub_827F8408(ctx, base);
	// 828E935C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828E9360: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E9364: 419A0008  beq cr6, 0x828e936c
	if ctx.cr[6].eq {
	pc = 0x828E936C; continue 'dispatch;
	}
	// 828E9368: 4B9D7529  bl 0x822c0890
	ctx.lr = 0x828E936C;
	sub_822C0890(ctx, base);
	// 828E936C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828E9370: 488BEE48  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E9378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E9378 size=348
    let mut pc: u32 = 0x828E9378;
    'dispatch: loop {
        match pc {
            0x828E9378 => {
    //   block [0x828E9378..0x828E94D4)
	// 828E9378: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E937C: 488BEDED  bl 0x831a8168
	ctx.lr = 0x828E9380;
	sub_831A8130(ctx, base);
	// 828E9380: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E9384: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E9388: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E938C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828E9390: 388B0FF0  addi r4, r11, 0xff0
	ctx.r[4].s64 = ctx.r[11].s64 + 4080;
	// 828E9394: 38A007B0  li r5, 0x7b0
	ctx.r[5].s64 = 1968;
	// 828E9398: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828E939C: 4B9D703D  bl 0x822c03d8
	ctx.lr = 0x828E93A0;
	sub_822C03D8(ctx, base);
	// 828E93A0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828E93A4: 41820014  beq 0x828e93b8
	if ctx.cr[0].eq {
	pc = 0x828E93B8; continue 'dispatch;
	}
	// 828E93A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E93AC: 4BF0F185  bl 0x827f8530
	ctx.lr = 0x828E93B0;
	sub_827F8530(ctx, base);
	// 828E93B0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828E93B4: 48000008  b 0x828e93bc
	pc = 0x828E93BC; continue 'dispatch;
	// 828E93B8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828E93BC: 3BDF037C  addi r30, r31, 0x37c
	ctx.r[30].s64 = ctx.r[31].s64 + 892;
	// 828E93C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E93C4: 4BF9FC95  bl 0x82889058
	ctx.lr = 0x828E93C8;
	sub_82889058(ctx, base);
	// 828E93C8: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 828E93CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E93D0: 388BF818  addi r4, r11, -0x7e8
	ctx.r[4].s64 = ctx.r[11].s64 + -2024;
	// 828E93D4: 4850A635  bl 0x82df3a08
	ctx.lr = 0x828E93D8;
	sub_82DF3A08(ctx, base);
	// 828E93D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E93DC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828E93E0: 4BF031E9  bl 0x827ec5c8
	ctx.lr = 0x828E93E4;
	sub_827EC5C8(ctx, base);
	// 828E93E4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828E93E8: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 828E93EC: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E93F0: 4871FBC9  bl 0x83008fb8
	ctx.lr = 0x828E93F4;
	sub_83008FB8(ctx, base);
	// 828E93F4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828E93F8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828E93FC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828E9400: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828E9404: 4852BC2D  bl 0x82e15030
	ctx.lr = 0x828E9408;
	sub_82E15030(ctx, base);
	// 828E9408: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828E940C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828E9410: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828E9414: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 828E9418: 4BF25711  bl 0x8280eb28
	ctx.lr = 0x828E941C;
	sub_8280EB28(ctx, base);
	// 828E941C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E9420: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828E9424: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E9428: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E942C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828E9430: 419A0024  beq cr6, 0x828e9454
	if ctx.cr[6].eq {
	pc = 0x828E9454; continue 'dispatch;
	}
	// 828E9434: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828E9438: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E943C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E9440: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E9444: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828E9448: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E944C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E9450: 4082FFE8  bne 0x828e9438
	if !ctx.cr[0].eq {
	pc = 0x828E9438; continue 'dispatch;
	}
	// 828E9454: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828E9458: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E945C: 419A0008  beq cr6, 0x828e9464
	if ctx.cr[6].eq {
	pc = 0x828E9464; continue 'dispatch;
	}
	// 828E9460: 4B9D7431  bl 0x822c0890
	ctx.lr = 0x828E9464;
	sub_822C0890(ctx, base);
	// 828E9464: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828E9468: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E946C: 419A0008  beq cr6, 0x828e9474
	if ctx.cr[6].eq {
	pc = 0x828E9474; continue 'dispatch;
	}
	// 828E9470: 4B9D7421  bl 0x822c0890
	ctx.lr = 0x828E9474;
	sub_822C0890(ctx, base);
	// 828E9474: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828E9478: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E947C: 419A0008  beq cr6, 0x828e9484
	if ctx.cr[6].eq {
	pc = 0x828E9484; continue 'dispatch;
	}
	// 828E9480: 4B9D7411  bl 0x822c0890
	ctx.lr = 0x828E9484;
	sub_822C0890(ctx, base);
	// 828E9484: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E9488: 48509FA1  bl 0x82df3428
	ctx.lr = 0x828E948C;
	sub_82DF3428(ctx, base);
	// 828E948C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828E9490: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E9494: 419A0028  beq cr6, 0x828e94bc
	if ctx.cr[6].eq {
	pc = 0x828E94BC; continue 'dispatch;
	}
	// 828E9498: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828E949C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828E94A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E94A4: 4BF03BCD  bl 0x827ed070
	ctx.lr = 0x828E94A8;
	sub_827ED070(ctx, base);
	// 828E94A8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E94AC: 80A10058  lwz r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828E94B0: 388B1148  addi r4, r11, 0x1148
	ctx.r[4].s64 = ctx.r[11].s64 + 4424;
	// 828E94B4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E94B8: 4BF0EF51  bl 0x827f8408
	ctx.lr = 0x828E94BC;
	sub_827F8408(ctx, base);
	// 828E94BC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828E94C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E94C4: 419A0008  beq cr6, 0x828e94cc
	if ctx.cr[6].eq {
	pc = 0x828E94CC; continue 'dispatch;
	}
	// 828E94C8: 4B9D73C9  bl 0x822c0890
	ctx.lr = 0x828E94CC;
	sub_822C0890(ctx, base);
	// 828E94CC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828E94D0: 488BECE8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E94D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E94D8 size=348
    let mut pc: u32 = 0x828E94D8;
    'dispatch: loop {
        match pc {
            0x828E94D8 => {
    //   block [0x828E94D8..0x828E9634)
	// 828E94D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E94DC: 488BEC8D  bl 0x831a8168
	ctx.lr = 0x828E94E0;
	sub_831A8130(ctx, base);
	// 828E94E0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E94E4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E94E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E94EC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828E94F0: 388B0FF0  addi r4, r11, 0xff0
	ctx.r[4].s64 = ctx.r[11].s64 + 4080;
	// 828E94F4: 38A00844  li r5, 0x844
	ctx.r[5].s64 = 2116;
	// 828E94F8: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828E94FC: 4B9D6EDD  bl 0x822c03d8
	ctx.lr = 0x828E9500;
	sub_822C03D8(ctx, base);
	// 828E9500: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828E9504: 41820014  beq 0x828e9518
	if ctx.cr[0].eq {
	pc = 0x828E9518; continue 'dispatch;
	}
	// 828E9508: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E950C: 4BF0F025  bl 0x827f8530
	ctx.lr = 0x828E9510;
	sub_827F8530(ctx, base);
	// 828E9510: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828E9514: 48000008  b 0x828e951c
	pc = 0x828E951C; continue 'dispatch;
	// 828E9518: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828E951C: 3BDF037C  addi r30, r31, 0x37c
	ctx.r[30].s64 = ctx.r[31].s64 + 892;
	// 828E9520: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E9524: 4BF9FB35  bl 0x82889058
	ctx.lr = 0x828E9528;
	sub_82889058(ctx, base);
	// 828E9528: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 828E952C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E9530: 388BF818  addi r4, r11, -0x7e8
	ctx.r[4].s64 = ctx.r[11].s64 + -2024;
	// 828E9534: 4850A4D5  bl 0x82df3a08
	ctx.lr = 0x828E9538;
	sub_82DF3A08(ctx, base);
	// 828E9538: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E953C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828E9540: 4BF03089  bl 0x827ec5c8
	ctx.lr = 0x828E9544;
	sub_827EC5C8(ctx, base);
	// 828E9544: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828E9548: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 828E954C: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E9550: 4871FA69  bl 0x83008fb8
	ctx.lr = 0x828E9554;
	sub_83008FB8(ctx, base);
	// 828E9554: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828E9558: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828E955C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828E9560: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828E9564: 4852BACD  bl 0x82e15030
	ctx.lr = 0x828E9568;
	sub_82E15030(ctx, base);
	// 828E9568: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828E956C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828E9570: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828E9574: 38C00003  li r6, 3
	ctx.r[6].s64 = 3;
	// 828E9578: 4BF255B1  bl 0x8280eb28
	ctx.lr = 0x828E957C;
	sub_8280EB28(ctx, base);
	// 828E957C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E9580: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828E9584: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E9588: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E958C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828E9590: 419A0024  beq cr6, 0x828e95b4
	if ctx.cr[6].eq {
	pc = 0x828E95B4; continue 'dispatch;
	}
	// 828E9594: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828E9598: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E959C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E95A0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E95A4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828E95A8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E95AC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E95B0: 4082FFE8  bne 0x828e9598
	if !ctx.cr[0].eq {
	pc = 0x828E9598; continue 'dispatch;
	}
	// 828E95B4: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828E95B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E95BC: 419A0008  beq cr6, 0x828e95c4
	if ctx.cr[6].eq {
	pc = 0x828E95C4; continue 'dispatch;
	}
	// 828E95C0: 4B9D72D1  bl 0x822c0890
	ctx.lr = 0x828E95C4;
	sub_822C0890(ctx, base);
	// 828E95C4: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828E95C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E95CC: 419A0008  beq cr6, 0x828e95d4
	if ctx.cr[6].eq {
	pc = 0x828E95D4; continue 'dispatch;
	}
	// 828E95D0: 4B9D72C1  bl 0x822c0890
	ctx.lr = 0x828E95D4;
	sub_822C0890(ctx, base);
	// 828E95D4: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828E95D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E95DC: 419A0008  beq cr6, 0x828e95e4
	if ctx.cr[6].eq {
	pc = 0x828E95E4; continue 'dispatch;
	}
	// 828E95E0: 4B9D72B1  bl 0x822c0890
	ctx.lr = 0x828E95E4;
	sub_822C0890(ctx, base);
	// 828E95E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E95E8: 48509E41  bl 0x82df3428
	ctx.lr = 0x828E95EC;
	sub_82DF3428(ctx, base);
	// 828E95EC: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828E95F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E95F4: 419A0028  beq cr6, 0x828e961c
	if ctx.cr[6].eq {
	pc = 0x828E961C; continue 'dispatch;
	}
	// 828E95F8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828E95FC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828E9600: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E9604: 4BF03A6D  bl 0x827ed070
	ctx.lr = 0x828E9608;
	sub_827ED070(ctx, base);
	// 828E9608: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E960C: 80A10058  lwz r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828E9610: 388B1148  addi r4, r11, 0x1148
	ctx.r[4].s64 = ctx.r[11].s64 + 4424;
	// 828E9614: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E9618: 4BF0EDF1  bl 0x827f8408
	ctx.lr = 0x828E961C;
	sub_827F8408(ctx, base);
	// 828E961C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828E9620: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E9624: 419A0008  beq cr6, 0x828e962c
	if ctx.cr[6].eq {
	pc = 0x828E962C; continue 'dispatch;
	}
	// 828E9628: 4B9D7269  bl 0x822c0890
	ctx.lr = 0x828E962C;
	sub_822C0890(ctx, base);
	// 828E962C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828E9630: 488BEB88  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E9638(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E9638 size=348
    let mut pc: u32 = 0x828E9638;
    'dispatch: loop {
        match pc {
            0x828E9638 => {
    //   block [0x828E9638..0x828E9794)
	// 828E9638: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E963C: 488BEB2D  bl 0x831a8168
	ctx.lr = 0x828E9640;
	sub_831A8130(ctx, base);
	// 828E9640: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E9644: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E9648: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E964C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828E9650: 388B0FF0  addi r4, r11, 0xff0
	ctx.r[4].s64 = ctx.r[11].s64 + 4080;
	// 828E9654: 38A008BE  li r5, 0x8be
	ctx.r[5].s64 = 2238;
	// 828E9658: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828E965C: 4B9D6D7D  bl 0x822c03d8
	ctx.lr = 0x828E9660;
	sub_822C03D8(ctx, base);
	// 828E9660: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828E9664: 41820014  beq 0x828e9678
	if ctx.cr[0].eq {
	pc = 0x828E9678; continue 'dispatch;
	}
	// 828E9668: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E966C: 4BF0EEC5  bl 0x827f8530
	ctx.lr = 0x828E9670;
	sub_827F8530(ctx, base);
	// 828E9670: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828E9674: 48000008  b 0x828e967c
	pc = 0x828E967C; continue 'dispatch;
	// 828E9678: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828E967C: 3BDF037C  addi r30, r31, 0x37c
	ctx.r[30].s64 = ctx.r[31].s64 + 892;
	// 828E9680: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E9684: 4BF9F9D5  bl 0x82889058
	ctx.lr = 0x828E9688;
	sub_82889058(ctx, base);
	// 828E9688: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 828E968C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E9690: 388BF818  addi r4, r11, -0x7e8
	ctx.r[4].s64 = ctx.r[11].s64 + -2024;
	// 828E9694: 4850A375  bl 0x82df3a08
	ctx.lr = 0x828E9698;
	sub_82DF3A08(ctx, base);
	// 828E9698: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828E969C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828E96A0: 4BF02F29  bl 0x827ec5c8
	ctx.lr = 0x828E96A4;
	sub_827EC5C8(ctx, base);
	// 828E96A4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828E96A8: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 828E96AC: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E96B0: 4871F909  bl 0x83008fb8
	ctx.lr = 0x828E96B4;
	sub_83008FB8(ctx, base);
	// 828E96B4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828E96B8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828E96BC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828E96C0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828E96C4: 4852B96D  bl 0x82e15030
	ctx.lr = 0x828E96C8;
	sub_82E15030(ctx, base);
	// 828E96C8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828E96CC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828E96D0: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828E96D4: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 828E96D8: 4BF25451  bl 0x8280eb28
	ctx.lr = 0x828E96DC;
	sub_8280EB28(ctx, base);
	// 828E96DC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E96E0: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828E96E4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828E96E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E96EC: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828E96F0: 419A0024  beq cr6, 0x828e9714
	if ctx.cr[6].eq {
	pc = 0x828E9714; continue 'dispatch;
	}
	// 828E96F4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828E96F8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828E96FC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E9700: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828E9704: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828E9708: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828E970C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828E9710: 4082FFE8  bne 0x828e96f8
	if !ctx.cr[0].eq {
	pc = 0x828E96F8; continue 'dispatch;
	}
	// 828E9714: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828E9718: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E971C: 419A0008  beq cr6, 0x828e9724
	if ctx.cr[6].eq {
	pc = 0x828E9724; continue 'dispatch;
	}
	// 828E9720: 4B9D7171  bl 0x822c0890
	ctx.lr = 0x828E9724;
	sub_822C0890(ctx, base);
	// 828E9724: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828E9728: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E972C: 419A0008  beq cr6, 0x828e9734
	if ctx.cr[6].eq {
	pc = 0x828E9734; continue 'dispatch;
	}
	// 828E9730: 4B9D7161  bl 0x822c0890
	ctx.lr = 0x828E9734;
	sub_822C0890(ctx, base);
	// 828E9734: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828E9738: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E973C: 419A0008  beq cr6, 0x828e9744
	if ctx.cr[6].eq {
	pc = 0x828E9744; continue 'dispatch;
	}
	// 828E9740: 4B9D7151  bl 0x822c0890
	ctx.lr = 0x828E9744;
	sub_822C0890(ctx, base);
	// 828E9744: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E9748: 48509CE1  bl 0x82df3428
	ctx.lr = 0x828E974C;
	sub_82DF3428(ctx, base);
	// 828E974C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828E9750: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828E9754: 419A0028  beq cr6, 0x828e977c
	if ctx.cr[6].eq {
	pc = 0x828E977C; continue 'dispatch;
	}
	// 828E9758: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828E975C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828E9760: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E9764: 4BF0390D  bl 0x827ed070
	ctx.lr = 0x828E9768;
	sub_827ED070(ctx, base);
	// 828E9768: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E976C: 80A10058  lwz r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828E9770: 388B1148  addi r4, r11, 0x1148
	ctx.r[4].s64 = ctx.r[11].s64 + 4424;
	// 828E9774: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828E9778: 4BF0EC91  bl 0x827f8408
	ctx.lr = 0x828E977C;
	sub_827F8408(ctx, base);
	// 828E977C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828E9780: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E9784: 419A0008  beq cr6, 0x828e978c
	if ctx.cr[6].eq {
	pc = 0x828E978C; continue 'dispatch;
	}
	// 828E9788: 4B9D7109  bl 0x822c0890
	ctx.lr = 0x828E978C;
	sub_822C0890(ctx, base);
	// 828E978C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828E9790: 488BEA28  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E9798(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E9798 size=128
    let mut pc: u32 = 0x828E9798;
    'dispatch: loop {
        match pc {
            0x828E9798 => {
    //   block [0x828E9798..0x828E9818)
	// 828E9798: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E979C: 488BE9D1  bl 0x831a816c
	ctx.lr = 0x828E97A0;
	sub_831A8130(ctx, base);
	// 828E97A0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E97A4: 3D408337  lis r10, -0x7cc9
	ctx.r[10].s64 = -2093547520;
	// 828E97A8: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828E97AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E97B0: 3BEB3C60  addi r31, r11, 0x3c60
	ctx.r[31].s64 = ctx.r[11].s64 + 15456;
	// 828E97B4: 816A3C68  lwz r11, 0x3c68(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(15464 as u32) ) } as u64;
	// 828E97B8: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828E97BC: 40820024  bne 0x828e97e0
	if !ctx.cr[0].eq {
	pc = 0x828E97E0; continue 'dispatch;
	}
	// 828E97C0: 3D208236  lis r9, -0x7dca
	ctx.r[9].s64 = -2110390272;
	// 828E97C4: 3D00828E  lis r8, -0x7d72
	ctx.r[8].s64 = -2104623104;
	// 828E97C8: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828E97CC: 3929A778  addi r9, r9, -0x5888
	ctx.r[9].s64 = ctx.r[9].s64 + -22664;
	// 828E97D0: 39083A48  addi r8, r8, 0x3a48
	ctx.r[8].s64 = ctx.r[8].s64 + 14920;
	// 828E97D4: 916A3C68  stw r11, 0x3c68(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(15464 as u32), ctx.r[11].u32 ) };
	// 828E97D8: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828E97DC: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828E97E0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828E97E4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828E97E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E97EC: 38BE0008  addi r5, r30, 8
	ctx.r[5].s64 = ctx.r[30].s64 + 8;
	// 828E97F0: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 828E97F4: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828E97F8: 4BFDE0E1  bl 0x828c78d8
	ctx.lr = 0x828E97FC;
	sub_828C78D8(ctx, base);
	// 828E97FC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E9800: 4182000C  beq 0x828e980c
	if ctx.cr[0].eq {
	pc = 0x828E980C; continue 'dispatch;
	}
	// 828E9804: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828E9808: 48000008  b 0x828e9810
	pc = 0x828E9810; continue 'dispatch;
	// 828E980C: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828E9810: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828E9814: 488BE9A8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E9818(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E9818 size=340
    let mut pc: u32 = 0x828E9818;
    'dispatch: loop {
        match pc {
            0x828E9818 => {
    //   block [0x828E9818..0x828E996C)
	// 828E9818: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E981C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E9820: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E9824: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E9828: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E982C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E9830: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E9834: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828E9838: 396B11D4  addi r11, r11, 0x11d4
	ctx.r[11].s64 = ctx.r[11].s64 + 4564;
	// 828E983C: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828E9840: 3D008209  lis r8, -0x7df7
	ctx.r[8].s64 = -2113339392;
	// 828E9844: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E9848: 807F03E0  lwz r3, 0x3e0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(992 as u32) ) } as u64;
	// 828E984C: 394A11BC  addi r10, r10, 0x11bc
	ctx.r[10].s64 = ctx.r[10].s64 + 4540;
	// 828E9850: 392911A0  addi r9, r9, 0x11a0
	ctx.r[9].s64 = ctx.r[9].s64 + 4512;
	// 828E9854: 39681154  addi r11, r8, 0x1154
	ctx.r[11].s64 = ctx.r[8].s64 + 4436;
	// 828E9858: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 828E985C: 3BDF0360  addi r30, r31, 0x360
	ctx.r[30].s64 = ctx.r[31].s64 + 864;
	// 828E9860: 913F0208  stw r9, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[9].u32 ) };
	// 828E9864: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E9868: 917F0360  stw r11, 0x360(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(864 as u32), ctx.r[11].u32 ) };
	// 828E986C: 419A0008  beq cr6, 0x828e9874
	if ctx.cr[6].eq {
	pc = 0x828E9874; continue 'dispatch;
	}
	// 828E9870: 4B9D69F9  bl 0x822c0268
	ctx.lr = 0x828E9874;
	sub_822C0268(ctx, base);
	// 828E9874: 807F0404  lwz r3, 0x404(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1028 as u32) ) } as u64;
	// 828E9878: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E987C: 419A0008  beq cr6, 0x828e9884
	if ctx.cr[6].eq {
	pc = 0x828E9884; continue 'dispatch;
	}
	// 828E9880: 4B9D7011  bl 0x822c0890
	ctx.lr = 0x828E9884;
	sub_822C0890(ctx, base);
	// 828E9884: 807F03D8  lwz r3, 0x3d8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(984 as u32) ) } as u64;
	// 828E9888: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E988C: 419A0008  beq cr6, 0x828e9894
	if ctx.cr[6].eq {
	pc = 0x828E9894; continue 'dispatch;
	}
	// 828E9890: 4B9D7001  bl 0x822c0890
	ctx.lr = 0x828E9894;
	sub_822C0890(ctx, base);
	// 828E9894: 807F03D0  lwz r3, 0x3d0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(976 as u32) ) } as u64;
	// 828E9898: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E989C: 419A0008  beq cr6, 0x828e98a4
	if ctx.cr[6].eq {
	pc = 0x828E98A4; continue 'dispatch;
	}
	// 828E98A0: 4B9D6FF1  bl 0x822c0890
	ctx.lr = 0x828E98A4;
	sub_822C0890(ctx, base);
	// 828E98A4: 807F03C8  lwz r3, 0x3c8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(968 as u32) ) } as u64;
	// 828E98A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E98AC: 419A0008  beq cr6, 0x828e98b4
	if ctx.cr[6].eq {
	pc = 0x828E98B4; continue 'dispatch;
	}
	// 828E98B0: 4B9D6FE1  bl 0x822c0890
	ctx.lr = 0x828E98B4;
	sub_822C0890(ctx, base);
	// 828E98B4: 807F03C0  lwz r3, 0x3c0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(960 as u32) ) } as u64;
	// 828E98B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E98BC: 419A0008  beq cr6, 0x828e98c4
	if ctx.cr[6].eq {
	pc = 0x828E98C4; continue 'dispatch;
	}
	// 828E98C0: 4B9D6FD1  bl 0x822c0890
	ctx.lr = 0x828E98C4;
	sub_822C0890(ctx, base);
	// 828E98C4: 807F03B8  lwz r3, 0x3b8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(952 as u32) ) } as u64;
	// 828E98C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E98CC: 419A0008  beq cr6, 0x828e98d4
	if ctx.cr[6].eq {
	pc = 0x828E98D4; continue 'dispatch;
	}
	// 828E98D0: 4B9D6FC1  bl 0x822c0890
	ctx.lr = 0x828E98D4;
	sub_822C0890(ctx, base);
	// 828E98D4: 807F03B0  lwz r3, 0x3b0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(944 as u32) ) } as u64;
	// 828E98D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E98DC: 419A0008  beq cr6, 0x828e98e4
	if ctx.cr[6].eq {
	pc = 0x828E98E4; continue 'dispatch;
	}
	// 828E98E0: 4B9D6FB1  bl 0x822c0890
	ctx.lr = 0x828E98E4;
	sub_822C0890(ctx, base);
	// 828E98E4: 387F039C  addi r3, r31, 0x39c
	ctx.r[3].s64 = ctx.r[31].s64 + 924;
	// 828E98E8: 4BB80719  bl 0x8246a000
	ctx.lr = 0x828E98EC;
	sub_8246A000(ctx, base);
	// 828E98EC: 387F038C  addi r3, r31, 0x38c
	ctx.r[3].s64 = ctx.r[31].s64 + 908;
	// 828E98F0: 4BB80711  bl 0x8246a000
	ctx.lr = 0x828E98F4;
	sub_8246A000(ctx, base);
	// 828E98F4: 807F0388  lwz r3, 0x388(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(904 as u32) ) } as u64;
	// 828E98F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E98FC: 419A0008  beq cr6, 0x828e9904
	if ctx.cr[6].eq {
	pc = 0x828E9904; continue 'dispatch;
	}
	// 828E9900: 4B9D6F91  bl 0x822c0890
	ctx.lr = 0x828E9904;
	sub_822C0890(ctx, base);
	// 828E9904: 807F0380  lwz r3, 0x380(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(896 as u32) ) } as u64;
	// 828E9908: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E990C: 419A0008  beq cr6, 0x828e9914
	if ctx.cr[6].eq {
	pc = 0x828E9914; continue 'dispatch;
	}
	// 828E9910: 4B9D6F81  bl 0x822c0890
	ctx.lr = 0x828E9914;
	sub_822C0890(ctx, base);
	// 828E9914: 807F0378  lwz r3, 0x378(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(888 as u32) ) } as u64;
	// 828E9918: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E991C: 419A0008  beq cr6, 0x828e9924
	if ctx.cr[6].eq {
	pc = 0x828E9924; continue 'dispatch;
	}
	// 828E9920: 4B9D6F71  bl 0x822c0890
	ctx.lr = 0x828E9924;
	sub_822C0890(ctx, base);
	// 828E9924: 807F0370  lwz r3, 0x370(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(880 as u32) ) } as u64;
	// 828E9928: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E992C: 419A0008  beq cr6, 0x828e9934
	if ctx.cr[6].eq {
	pc = 0x828E9934; continue 'dispatch;
	}
	// 828E9930: 4B9D6F61  bl 0x822c0890
	ctx.lr = 0x828E9934;
	sub_822C0890(ctx, base);
	// 828E9934: 807F0368  lwz r3, 0x368(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(872 as u32) ) } as u64;
	// 828E9938: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828E993C: 419A0008  beq cr6, 0x828e9944
	if ctx.cr[6].eq {
	pc = 0x828E9944; continue 'dispatch;
	}
	// 828E9940: 4B9D6F51  bl 0x822c0890
	ctx.lr = 0x828E9944;
	sub_822C0890(ctx, base);
	// 828E9944: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828E9948: 4BEBDD11  bl 0x827a7658
	ctx.lr = 0x828E994C;
	sub_827A7658(ctx, base);
	// 828E994C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E9950: 48027341  bl 0x82910c90
	ctx.lr = 0x828E9954;
	sub_82910C90(ctx, base);
	// 828E9954: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E9958: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E995C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E9960: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E9964: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E9968: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E9970(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828E9970 size=8
    let mut pc: u32 = 0x828E9970;
    'dispatch: loop {
        match pc {
            0x828E9970 => {
    //   block [0x828E9970..0x828E9978)
	// 828E9970: 3863FDF8  addi r3, r3, -0x208
	ctx.r[3].s64 = ctx.r[3].s64 + -520;
	// 828E9974: 4800010C  b 0x828e9a80
	sub_828E9A80(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


