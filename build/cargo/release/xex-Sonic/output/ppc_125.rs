pub fn sub_829F7708(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F7708 size=196
    let mut pc: u32 = 0x829F7708;
    'dispatch: loop {
        match pc {
            0x829F7708 => {
    //   block [0x829F7708..0x829F77CC)
	// 829F7708: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F770C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829F7710: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829F7714: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829F7718: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F771C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829F7720: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829F7724: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829F7728: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829F772C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829F7730: 4B8C9209  bl 0x822c0938
	ctx.lr = 0x829F7734;
	sub_822C0938(ctx, base);
	// 829F7734: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829F7738: 41820028  beq 0x829f7760
	if ctx.cr[0].eq {
	pc = 0x829F7760; continue 'dispatch;
	}
	// 829F773C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829F7740: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829F7744: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829F7748: 392B7084  addi r9, r11, 0x7084
	ctx.r[9].s64 = ctx.r[11].s64 + 28804;
	// 829F774C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829F7750: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829F7754: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829F7758: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829F775C: 48000008  b 0x829f7764
	pc = 0x829F7764; continue 'dispatch;
	// 829F7760: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829F7764: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829F7768: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F776C: 409A0044  bne cr6, 0x829f77b0
	if !ctx.cr[6].eq {
	pc = 0x829F77B0; continue 'dispatch;
	}
	// 829F7770: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829F7774: 419A001C  beq cr6, 0x829f7790
	if ctx.cr[6].eq {
	pc = 0x829F7790; continue 'dispatch;
	}
	// 829F7778: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F777C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829F7780: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F7784: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F7788: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829F778C: 4E800421  bctrl
	ctx.lr = 0x829F7790;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829F7790: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829F7794: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829F7798: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F779C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829F77A0: 816BE058  lwz r11, -0x1fa8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8104 as u32) ) } as u64;
	// 829F77A4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829F77A8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829F77AC: 4B8C8855  bl 0x822c0000
	ctx.lr = 0x829F77B0;
	sub_822C0000(ctx, base);
	// 829F77B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F77B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829F77B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829F77BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829F77C0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829F77C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829F77C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F77D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F77D0 size=196
    let mut pc: u32 = 0x829F77D0;
    'dispatch: loop {
        match pc {
            0x829F77D0 => {
    //   block [0x829F77D0..0x829F7894)
	// 829F77D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F77D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829F77D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829F77DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829F77E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F77E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829F77E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829F77EC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829F77F0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829F77F4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829F77F8: 4B8C9141  bl 0x822c0938
	ctx.lr = 0x829F77FC;
	sub_822C0938(ctx, base);
	// 829F77FC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829F7800: 41820028  beq 0x829f7828
	if ctx.cr[0].eq {
	pc = 0x829F7828; continue 'dispatch;
	}
	// 829F7804: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829F7808: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829F780C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829F7810: 392B7098  addi r9, r11, 0x7098
	ctx.r[9].s64 = ctx.r[11].s64 + 28824;
	// 829F7814: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829F7818: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829F781C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829F7820: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829F7824: 48000008  b 0x829f782c
	pc = 0x829F782C; continue 'dispatch;
	// 829F7828: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829F782C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829F7830: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F7834: 409A0044  bne cr6, 0x829f7878
	if !ctx.cr[6].eq {
	pc = 0x829F7878; continue 'dispatch;
	}
	// 829F7838: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829F783C: 419A001C  beq cr6, 0x829f7858
	if ctx.cr[6].eq {
	pc = 0x829F7858; continue 'dispatch;
	}
	// 829F7840: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F7844: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829F7848: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F784C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F7850: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829F7854: 4E800421  bctrl
	ctx.lr = 0x829F7858;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829F7858: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829F785C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829F7860: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F7864: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829F7868: 816BE058  lwz r11, -0x1fa8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8104 as u32) ) } as u64;
	// 829F786C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829F7870: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829F7874: 4B8C878D  bl 0x822c0000
	ctx.lr = 0x829F7878;
	sub_822C0000(ctx, base);
	// 829F7878: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F787C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829F7880: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829F7884: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829F7888: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829F788C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829F7890: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F7898(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829F7898 size=92
    let mut pc: u32 = 0x829F7898;
    'dispatch: loop {
        match pc {
            0x829F7898 => {
    //   block [0x829F7898..0x829F78F4)
	// 829F7898: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F789C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829F78A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829F78A4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F78A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F78AC: 4BB1A9B5  bl 0x82512260
	ctx.lr = 0x829F78B0;
	sub_82512260(ctx, base);
	// 829F78B0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829F78B4: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829F78B8: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 829F78BC: 394A70C4  addi r10, r10, 0x70c4
	ctx.r[10].s64 = ctx.r[10].s64 + 28868;
	// 829F78C0: 392970AC  addi r9, r9, 0x70ac
	ctx.r[9].s64 = ctx.r[9].s64 + 28844;
	// 829F78C4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 829F78C8: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F78CC: D01F0100  stfs f0, 0x100(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 829F78D0: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 829F78D4: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 829F78D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F78DC: 991F0104  stb r8, 0x104(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[8].u8 ) };
	// 829F78E0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829F78E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829F78E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829F78EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829F78F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F78F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829F78F8 size=8
    let mut pc: u32 = 0x829F78F8;
    'dispatch: loop {
        match pc {
            0x829F78F8 => {
    //   block [0x829F78F8..0x829F7900)
	// 829F78F8: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 829F78FC: 4800025C  b 0x829f7b58
	sub_829F7B58(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F7900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829F7900 size=316
    let mut pc: u32 = 0x829F7900;
    'dispatch: loop {
        match pc {
            0x829F7900 => {
    //   block [0x829F7900..0x829F7A3C)
	// 829F7900: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F7904: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829F7908: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829F790C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F7910: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F7914: 48465015  bl 0x82e5c928
	ctx.lr = 0x829F7918;
	sub_82E5C928(ctx, base);
	// 829F7918: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829F791C: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 829F7920: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 829F7924: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 829F7928: 38CB7104  addi r6, r11, 0x7104
	ctx.r[6].s64 = ctx.r[11].s64 + 28932;
	// 829F792C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 829F7930: C189C660  lfs f12, -0x39a0(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-14752 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829F7934: 90DF0000  stw r6, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 829F7938: C168D0AC  lfs f11, -0x2f54(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-12116 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829F793C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829F7940: C1A708A8  lfs f13, 0x8a8(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829F7944: 3D208202  lis r9, -0x7dfe
	ctx.r[9].s64 = -2113798144;
	// 829F7948: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 829F794C: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 829F7950: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 829F7954: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 829F7958: 3CC08209  lis r6, -0x7df7
	ctx.r[6].s64 = -2113339392;
	// 829F795C: C00A9450  lfs f0, -0x6bb0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F7960: D01F006C  stfs f0, 0x6c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 829F7964: 397F00A8  addi r11, r31, 0xa8
	ctx.r[11].s64 = ctx.r[31].s64 + 168;
	// 829F7968: D01F0070  stfs f0, 0x70(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 829F796C: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 829F7970: D01F0074  stfs f0, 0x74(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 829F7974: D19F0078  stfs f12, 0x78(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 829F7978: D01F007C  stfs f0, 0x7c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 829F797C: D17F0080  stfs f11, 0x80(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 829F7980: D01F0090  stfs f0, 0x90(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 829F7984: D01F0094  stfs f0, 0x94(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 829F7988: D01F0098  stfs f0, 0x98(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 829F798C: C1492F20  lfs f10, 0x2f20(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12064 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 829F7990: C1687DF0  lfs f11, 0x7df0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(32240 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829F7994: C187D1B8  lfs f12, -0x2e48(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-11848 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829F7998: C006ACFC  lfs f0, -0x5304(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-21252 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F799C: D1BF0084  stfs f13, 0x84(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 829F79A0: D1BF0088  stfs f13, 0x88(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 829F79A4: D1BF008C  stfs f13, 0x8c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 829F79A8: D1BF009C  stfs f13, 0x9c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 829F79AC: D1BF00A0  stfs f13, 0xa0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 829F79B0: D1BF00A4  stfs f13, 0xa4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 829F79B4: C12BFFC4  lfs f9, -0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-60 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 829F79B8: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 829F79BC: C10BFFD0  lfs f8, -0x30(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-48 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 829F79C0: ED204824  fdivs f9, f0, f9
	ctx.f[9].f64 = ((ctx.f[0].f64 / ctx.f[9].f64) as f32) as f64;
	// 829F79C4: C0EBFFE8  lfs f7, -0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 829F79C8: ED0C4024  fdivs f8, f12, f8
	ctx.f[8].f64 = ((ctx.f[12].f64 / ctx.f[8].f64) as f32) as f64;
	// 829F79CC: C0CBFFF4  lfs f6, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 829F79D0: ECEB3824  fdivs f7, f11, f7
	ctx.f[7].f64 = ((ctx.f[11].f64 / ctx.f[7].f64) as f32) as f64;
	// 829F79D4: ECCA3024  fdivs f6, f10, f6
	ctx.f[6].f64 = ((ctx.f[10].f64 / ctx.f[6].f64) as f32) as f64;
	// 829F79D8: D12B0000  stfs f9, 0(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829F79DC: D10B000C  stfs f8, 0xc(r11)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829F79E0: D0EB0024  stfs f7, 0x24(r11)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 829F79E4: D0CB0030  stfs f6, 0x30(r11)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 829F79E8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829F79EC: 4082FFC8  bne 0x829f79b4
	if !ctx.cr[0].eq {
	pc = 0x829F79B4; continue 'dispatch;
	}
	// 829F79F0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829F79F4: D1BF00C8  stfs f13, 0xc8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 829F79F8: 3D408203  lis r10, -0x7dfd
	ctx.r[10].s64 = -2113732608;
	// 829F79FC: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	// 829F7A00: 39000004  li r8, 4
	ctx.r[8].s64 = 4;
	// 829F7A04: 38E00003  li r7, 3
	ctx.r[7].s64 = 3;
	// 829F7A08: 993F00E4  stb r9, 0xe4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u8 ) };
	// 829F7A0C: C00B9524  lfs f0, -0x6adc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F7A10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F7A14: C1AA84B0  lfs f13, -0x7b50(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-31568 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829F7A18: 98FF00E5  stb r7, 0xe5(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(229 as u32), ctx.r[7].u8 ) };
	// 829F7A1C: D01F00C0  stfs f0, 0xc0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 829F7A20: 991F00E6  stb r8, 0xe6(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(230 as u32), ctx.r[8].u8 ) };
	// 829F7A24: D1BF00C4  stfs f13, 0xc4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 829F7A28: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829F7A2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829F7A30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829F7A34: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829F7A38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F7A40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F7A40 size=136
    let mut pc: u32 = 0x829F7A40;
    'dispatch: loop {
        match pc {
            0x829F7A40 => {
    //   block [0x829F7A40..0x829F7AC8)
	// 829F7A40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F7A44: 487B0729  bl 0x831a816c
	ctx.lr = 0x829F7A48;
	sub_831A8130(ctx, base);
	// 829F7A48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F7A4C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829F7A50: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829F7A54: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829F7A58: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829F7A5C: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 829F7A60: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 829F7A64: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 829F7A68: 483FA981  bl 0x82df23e8
	ctx.lr = 0x829F7A6C;
	sub_82DF23E8(ctx, base);
	// 829F7A6C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 829F7A70: 41820024  beq 0x829f7a94
	if ctx.cr[0].eq {
	pc = 0x829F7A94; continue 'dispatch;
	}
	// 829F7A74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F7A78: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F7A7C: 48461C05  bl 0x82e59680
	ctx.lr = 0x829F7A80;
	sub_82E59680(ctx, base);
	// 829F7A80: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829F7A84: 9BDF0018  stb r30, 0x18(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u8 ) };
	// 829F7A88: 396B7068  addi r11, r11, 0x7068
	ctx.r[11].s64 = ctx.r[11].s64 + 28776;
	// 829F7A8C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829F7A90: 48000008  b 0x829f7a98
	pc = 0x829F7A98; continue 'dispatch;
	// 829F7A94: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829F7A98: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 829F7A9C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 829F7AA0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F7AA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F7AA8: 4BFFFC61  bl 0x829f7708
	ctx.lr = 0x829F7AAC;
	sub_829F7708(ctx, base);
	// 829F7AAC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829F7AB0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F7AB4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F7AB8: 4B8C8549  bl 0x822c0000
	ctx.lr = 0x829F7ABC;
	sub_822C0000(ctx, base);
	// 829F7ABC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F7AC0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829F7AC4: 487B06F8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F7AC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829F7AC8 size=144
    let mut pc: u32 = 0x829F7AC8;
    'dispatch: loop {
        match pc {
            0x829F7AC8 => {
    //   block [0x829F7AC8..0x829F7B58)
	// 829F7AC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F7ACC: 487B0699  bl 0x831a8164
	ctx.lr = 0x829F7AD0;
	sub_831A8130(ctx, base);
	// 829F7AD0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F7AD4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829F7AD8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 829F7ADC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829F7AE0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 829F7AE4: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 829F7AE8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829F7AEC: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 829F7AF0: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 829F7AF4: 38600070  li r3, 0x70
	ctx.r[3].s64 = 112;
	// 829F7AF8: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 829F7AFC: 483FA8ED  bl 0x82df23e8
	ctx.lr = 0x829F7B00;
	sub_82DF23E8(ctx, base);
	// 829F7B00: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829F7B04: 41820020  beq 0x829f7b24
	if ctx.cr[0].eq {
	pc = 0x829F7B24; continue 'dispatch;
	}
	// 829F7B08: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 829F7B0C: C07D0000  lfs f3, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 829F7B10: C05E0000  lfs f2, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 829F7B14: C03F0000  lfs f1, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829F7B18: 48161BE1  bl 0x82b596f8
	ctx.lr = 0x829F7B1C;
	sub_82B596F8(ctx, base);
	// 829F7B1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F7B20: 48000008  b 0x829f7b28
	pc = 0x829F7B28; continue 'dispatch;
	// 829F7B24: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829F7B28: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 829F7B2C: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 829F7B30: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F7B34: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F7B38: 4BFFFC99  bl 0x829f77d0
	ctx.lr = 0x829F7B3C;
	sub_829F77D0(ctx, base);
	// 829F7B3C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829F7B40: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F7B44: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F7B48: 4B8C84B9  bl 0x822c0000
	ctx.lr = 0x829F7B4C;
	sub_822C0000(ctx, base);
	// 829F7B4C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829F7B50: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829F7B54: 487B0660  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F7B58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F7B58 size=100
    let mut pc: u32 = 0x829F7B58;
    'dispatch: loop {
        match pc {
            0x829F7B58 => {
    //   block [0x829F7B58..0x829F7BBC)
	// 829F7B58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F7B5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829F7B60: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829F7B64: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829F7B68: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F7B6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F7B70: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829F7B74: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829F7B78: 396B70C4  addi r11, r11, 0x70c4
	ctx.r[11].s64 = ctx.r[11].s64 + 28868;
	// 829F7B7C: 394A70AC  addi r10, r10, 0x70ac
	ctx.r[10].s64 = ctx.r[10].s64 + 28844;
	// 829F7B80: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829F7B84: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829F7B88: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 829F7B8C: 4B9577C5  bl 0x8234f350
	ctx.lr = 0x829F7B90;
	sub_8234F350(ctx, base);
	// 829F7B90: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F7B94: 4182000C  beq 0x829f7ba0
	if ctx.cr[0].eq {
	pc = 0x829F7BA0; continue 'dispatch;
	}
	// 829F7B98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F7B9C: 483FA83D  bl 0x82df23d8
	ctx.lr = 0x829F7BA0;
	sub_82DF23D8(ctx, base);
	// 829F7BA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F7BA4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829F7BA8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829F7BAC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829F7BB0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829F7BB4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829F7BB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F7BC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829F7BC0 size=520
    let mut pc: u32 = 0x829F7BC0;
    'dispatch: loop {
        match pc {
            0x829F7BC0 => {
    //   block [0x829F7BC0..0x829F7DC8)
	// 829F7BC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F7BC4: 487B05A9  bl 0x831a816c
	ctx.lr = 0x829F7BC8;
	sub_831A8130(ctx, base);
	// 829F7BC8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F7BCC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F7BD0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 829F7BD4: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 829F7BD8: 4BB19E01  bl 0x825119d8
	ctx.lr = 0x829F7BDC;
	sub_825119D8(ctx, base);
	// 829F7BDC: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 829F7BE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F7BE4: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 829F7BE8: 483FBE21  bl 0x82df3a08
	ctx.lr = 0x829F7BEC;
	sub_82DF3A08(ctx, base);
	// 829F7BEC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829F7BF0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829F7BF4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F7BF8: 4BB10B89  bl 0x82508780
	ctx.lr = 0x829F7BFC;
	sub_82508780(ctx, base);
	// 829F7BFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F7C00: 483FB829  bl 0x82df3428
	ctx.lr = 0x829F7C04;
	sub_82DF3428(ctx, base);
	// 829F7C04: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829F7C08: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 829F7C0C: 409A0008  bne cr6, 0x829f7c14
	if !ctx.cr[6].eq {
	pc = 0x829F7C14; continue 'dispatch;
	}
	// 829F7C10: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829F7C14: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F7C18: 4BB10B89  bl 0x825087a0
	ctx.lr = 0x829F7C1C;
	sub_825087A0(ctx, base);
	// 829F7C1C: 397F00F0  addi r11, r31, 0xf0
	ctx.r[11].s64 = ctx.r[31].s64 + 240;
	// 829F7C20: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829F7C24: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 829F7C28: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829F7C2C: 4B9255A5  bl 0x8231d1d0
	ctx.lr = 0x829F7C30;
	sub_8231D1D0(ctx, base);
	// 829F7C30: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F7C34: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829F7C38: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F7C3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F7C40: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 829F7C44: 419A0024  beq cr6, 0x829f7c68
	if ctx.cr[6].eq {
	pc = 0x829F7C68; continue 'dispatch;
	}
	// 829F7C48: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829F7C4C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829F7C50: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F7C54: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829F7C58: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829F7C5C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829F7C60: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F7C64: 4082FFE8  bne 0x829f7c4c
	if !ctx.cr[0].eq {
	pc = 0x829F7C4C; continue 'dispatch;
	}
	// 829F7C68: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F7C6C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829F7C70: 4BB17859  bl 0x8250f4c8
	ctx.lr = 0x829F7C74;
	sub_8250F4C8(ctx, base);
	// 829F7C74: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F7C78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F7C7C: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 829F7C80: 409A0008  bne cr6, 0x829f7c88
	if !ctx.cr[6].eq {
	pc = 0x829F7C88; continue 'dispatch;
	}
	// 829F7C84: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 829F7C88: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829F7C8C: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 829F7C90: 4BB10D89  bl 0x82508a18
	ctx.lr = 0x829F7C94;
	sub_82508A18(ctx, base);
	// 829F7C94: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829F7C98: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829F7C9C: 388B7160  addi r4, r11, 0x7160
	ctx.r[4].s64 = ctx.r[11].s64 + 29024;
	// 829F7CA0: 38A0009A  li r5, 0x9a
	ctx.r[5].s64 = 154;
	// 829F7CA4: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 829F7CA8: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 829F7CAC: 4845F33D  bl 0x82e56fe8
	ctx.lr = 0x829F7CB0;
	sub_82E56FE8(ctx, base);
	// 829F7CB0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829F7CB4: 483F9FDD  bl 0x82df1c90
	ctx.lr = 0x829F7CB8;
	sub_82DF1C90(ctx, base);
	// 829F7CB8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829F7CBC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F7CC0: 419A0008  beq cr6, 0x829f7cc8
	if ctx.cr[6].eq {
	pc = 0x829F7CC8; continue 'dispatch;
	}
	// 829F7CC4: 4B8C8BCD  bl 0x822c0890
	ctx.lr = 0x829F7CC8;
	sub_822C0890(ctx, base);
	// 829F7CC8: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 829F7CCC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F7CD0: 419A0008  beq cr6, 0x829f7cd8
	if ctx.cr[6].eq {
	pc = 0x829F7CD8; continue 'dispatch;
	}
	// 829F7CD4: 4B8C8BBD  bl 0x822c0890
	ctx.lr = 0x829F7CD8;
	sub_822C0890(ctx, base);
	// 829F7CD8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829F7CDC: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F7CE0: 48432E09  bl 0x82e2aae8
	ctx.lr = 0x829F7CE4;
	sub_82E2AAE8(ctx, base);
	// 829F7CE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F7CE8: 4BB1ADB1  bl 0x82512a98
	ctx.lr = 0x829F7CEC;
	sub_82512A98(ctx, base);
	// 829F7CEC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829F7CF0: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829F7CF4: 812D0000  lwz r9, 0(r13)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F7CF8: 396B7150  addi r11, r11, 0x7150
	ctx.r[11].s64 = ctx.r[11].s64 + 29008;
	// 829F7CFC: 394A7140  addi r10, r10, 0x7140
	ctx.r[10].s64 = ctx.r[10].s64 + 28992;
	// 829F7D00: 39010090  addi r8, r1, 0x90
	ctx.r[8].s64 = ctx.r[1].s64 + 144;
	// 829F7D04: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
	// 829F7D08: 38C00014  li r6, 0x14
	ctx.r[6].s64 = 20;
	// 829F7D0C: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829F7D10: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 829F7D14: 13C050C7  vcmpequd (lvx128) v30, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829F7D18: 38800040  li r4, 0x40
	ctx.r[4].s64 = 64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F7DC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829F7DC8 size=448
    let mut pc: u32 = 0x829F7DC8;
    'dispatch: loop {
        match pc {
            0x829F7DC8 => {
    //   block [0x829F7DC8..0x829F7F88)
	// 829F7DC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F7DCC: 487B03A1  bl 0x831a816c
	ctx.lr = 0x829F7DD0;
	sub_831A8130(ctx, base);
	// 829F7DD0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F7DD4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829F7DD8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829F7DDC: 4BB1892D  bl 0x82510708
	ctx.lr = 0x829F7DE0;
	sub_82510708(ctx, base);
	// 829F7DE0: 397E00F0  addi r11, r30, 0xf0
	ctx.r[11].s64 = ctx.r[30].s64 + 240;
	// 829F7DE4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829F7DE8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 829F7DEC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829F7DF0: 4B9253E1  bl 0x8231d1d0
	ctx.lr = 0x829F7DF4;
	sub_8231D1D0(ctx, base);
	// 829F7DF4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F7DF8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829F7DFC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F7E00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F7E04: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 829F7E08: 419A0024  beq cr6, 0x829f7e2c
	if ctx.cr[6].eq {
	pc = 0x829F7E2C; continue 'dispatch;
	}
	// 829F7E0C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829F7E10: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829F7E14: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F7E18: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829F7E1C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829F7E20: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829F7E24: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F7E28: 4082FFE8  bne 0x829f7e10
	if !ctx.cr[0].eq {
	pc = 0x829F7E10; continue 'dispatch;
	}
	// 829F7E2C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829F7E30: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829F7E34: 4BB17695  bl 0x8250f4c8
	ctx.lr = 0x829F7E38;
	sub_8250F4C8(ctx, base);
	// 829F7E38: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F7E3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F7E40: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 829F7E44: 409A0008  bne cr6, 0x829f7e4c
	if !ctx.cr[6].eq {
	pc = 0x829F7E4C; continue 'dispatch;
	}
	// 829F7E48: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 829F7E4C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829F7E50: 3BA10058  addi r29, r1, 0x58
	ctx.r[29].s64 = ctx.r[1].s64 + 88;
	// 829F7E54: 4BB10BC5  bl 0x82508a18
	ctx.lr = 0x829F7E58;
	sub_82508A18(ctx, base);
	// 829F7E58: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829F7E5C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829F7E60: 388B7160  addi r4, r11, 0x7160
	ctx.r[4].s64 = ctx.r[11].s64 + 29024;
	// 829F7E64: 38A000D4  li r5, 0xd4
	ctx.r[5].s64 = 212;
	// 829F7E68: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 829F7E6C: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 829F7E70: 4845F179  bl 0x82e56fe8
	ctx.lr = 0x829F7E74;
	sub_82E56FE8(ctx, base);
	// 829F7E74: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829F7E78: 483F9E19  bl 0x82df1c90
	ctx.lr = 0x829F7E7C;
	sub_82DF1C90(ctx, base);
	// 829F7E7C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829F7E80: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F7E84: 419A0008  beq cr6, 0x829f7e8c
	if ctx.cr[6].eq {
	pc = 0x829F7E8C; continue 'dispatch;
	}
	// 829F7E88: 4B8C8A09  bl 0x822c0890
	ctx.lr = 0x829F7E8C;
	sub_822C0890(ctx, base);
	// 829F7E8C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 829F7E90: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F7E94: 419A0008  beq cr6, 0x829f7e9c
	if ctx.cr[6].eq {
	pc = 0x829F7E9C; continue 'dispatch;
	}
	// 829F7E98: 4B8C89F9  bl 0x822c0890
	ctx.lr = 0x829F7E9C;
	sub_822C0890(ctx, base);
	// 829F7E9C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 829F7EA0: C19E0100  lfs f12, 0x100(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(256 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829F7EA4: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F7EA8: EC00602A  fadds f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 829F7EAC: D01E0100  stfs f0, 0x100(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 829F7EB0: C1AB6150  lfs f13, 0x6150(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829F7EB4: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 829F7EB8: 409800AC  bge cr6, 0x829f7f64
	if !ctx.cr[6].lt {
	pc = 0x829F7F64; continue 'dispatch;
	}
	// 829F7EBC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 829F7EC0: 419800A4  blt cr6, 0x829f7f64
	if ctx.cr[6].lt {
	pc = 0x829F7F64; continue 'dispatch;
	}
	// 829F7EC4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829F7EC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F7ECC: 388B71AC  addi r4, r11, 0x71ac
	ctx.r[4].s64 = ctx.r[11].s64 + 29100;
	// 829F7ED0: 483FBB39  bl 0x82df3a08
	ctx.lr = 0x829F7ED4;
	sub_82DF3A08(ctx, base);
	// 829F7ED4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829F7ED8: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 829F7EDC: 4BB175ED  bl 0x8250f4c8
	ctx.lr = 0x829F7EE0;
	sub_8250F4C8(ctx, base);
	// 829F7EE0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F7EE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F7EE8: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 829F7EEC: 409A0008  bne cr6, 0x829f7ef4
	if !ctx.cr[6].eq {
	pc = 0x829F7EF4; continue 'dispatch;
	}
	// 829F7EF0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829F7EF4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829F7EF8: 4BB12A59  bl 0x8250a950
	ctx.lr = 0x829F7EFC;
	sub_8250A950(ctx, base);
	// 829F7EFC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F7F00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F7F04: 3BEBFF40  addi r31, r11, -0xc0
	ctx.r[31].s64 = ctx.r[11].s64 + -192;
	// 829F7F08: 409A0008  bne cr6, 0x829f7f10
	if !ctx.cr[6].eq {
	pc = 0x829F7F10; continue 'dispatch;
	}
	// 829F7F0C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829F7F10: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829F7F14: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 829F7F18: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 829F7F1C: 4BB1A1FD  bl 0x82512118
	ctx.lr = 0x829F7F20;
	sub_82512118(ctx, base);
	// 829F7F20: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829F7F24: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829F7F28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F7F2C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 829F7F30: 38C0000A  li r6, 0xa
	ctx.r[6].s64 = 10;
	// 829F7F34: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829F7F38: 4BDDC269  bl 0x827d41a0
	ctx.lr = 0x829F7F3C;
	sub_827D41A0(ctx, base);
	// 829F7F3C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829F7F40: 483F9D51  bl 0x82df1c90
	ctx.lr = 0x829F7F44;
	sub_82DF1C90(ctx, base);
	// 829F7F44: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 829F7F48: 483F9D49  bl 0x82df1c90
	ctx.lr = 0x829F7F4C;
	sub_82DF1C90(ctx, base);
	// 829F7F4C: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 829F7F50: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F7F54: 419A0008  beq cr6, 0x829f7f5c
	if ctx.cr[6].eq {
	pc = 0x829F7F5C; continue 'dispatch;
	}
	// 829F7F58: 4B8C8939  bl 0x822c0890
	ctx.lr = 0x829F7F5C;
	sub_822C0890(ctx, base);
	// 829F7F5C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F7F60: 483FB4C9  bl 0x82df3428
	ctx.lr = 0x829F7F64;
	sub_82DF3428(ctx, base);
	// 829F7F64: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829F7F68: C1BE0100  lfs f13, 0x100(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(256 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829F7F6C: C00B0A90  lfs f0, 0xa90(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2704 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F7F70: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 829F7F74: 4099000C  ble cr6, 0x829f7f80
	if !ctx.cr[6].gt {
	pc = 0x829F7F80; continue 'dispatch;
	}
	// 829F7F78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F7F7C: 4BB18655  bl 0x825105d0
	ctx.lr = 0x829F7F80;
	sub_825105D0(ctx, base);
	// 829F7F80: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 829F7F84: 487B0238  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F7F88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829F7F88 size=1212
    let mut pc: u32 = 0x829F7F88;
    'dispatch: loop {
        match pc {
            0x829F7F88 => {
    //   block [0x829F7F88..0x829F8444)
	// 829F7F88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F7F8C: 487B01DD  bl 0x831a8168
	ctx.lr = 0x829F7F90;
	sub_831A8130(ctx, base);
	// 829F7F90: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 829F7F94: 9421FEC0  stwu r1, -0x140(r1)
	ea = ctx.r[1].u32.wrapping_add(-320 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F7F98: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F7F9C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829F7FA0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F7FA4: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 829F7FA8: 4BB17521  bl 0x8250f4c8
	ctx.lr = 0x829F7FAC;
	sub_8250F4C8(ctx, base);
	// 829F7FAC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F7FB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F7FB4: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 829F7FB8: 409A0008  bne cr6, 0x829f7fc0
	if !ctx.cr[6].eq {
	pc = 0x829F7FC0; continue 'dispatch;
	}
	// 829F7FBC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 829F7FC0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829F7FC4: 4BB10A55  bl 0x82508a18
	ctx.lr = 0x829F7FC8;
	sub_82508A18(ctx, base);
	// 829F7FC8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829F7FCC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F7FD0: 48610159  bl 0x83008128
	ctx.lr = 0x829F7FD4;
	sub_83008128(ctx, base);
	// 829F7FD4: 7D7D1850  subf r11, r29, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[29].s64;
	// 829F7FD8: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 829F7FDC: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 829F7FE0: 557DDFFE  rlwinm r29, r11, 0x1b, 0x1f, 0x1f
	ctx.r[29].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 829F7FE4: 483F9CAD  bl 0x82df1c90
	ctx.lr = 0x829F7FE8;
	sub_82DF1C90(ctx, base);
	// 829F7FE8: 281D0000  cmplwi r29, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829F7FEC: 41820390  beq 0x829f837c
	if ctx.cr[0].eq {
	pc = 0x829F837C; continue 'dispatch;
	}
	// 829F7FF0: 897F0104  lbz r11, 0x104(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) } as u64;
	// 829F7FF4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829F7FF8: 40820440  bne 0x829f8438
	if !ctx.cr[0].eq {
	pc = 0x829F8438; continue 'dispatch;
	}
	// 829F7FFC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F8000: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 829F8004: 997F0104  stb r11, 0x104(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[11].u8 ) };
	// 829F8008: 39600064  li r11, 0x64
	ctx.r[11].s64 = 100;
	// 829F800C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F8010: 3BAA6910  addi r29, r10, 0x6910
	ctx.r[29].s64 = ctx.r[10].s64 + 26896;
	// 829F8014: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 829F8018: 4BB19AD1  bl 0x82511ae8
	ctx.lr = 0x829F801C;
	sub_82511AE8(ctx, base);
	// 829F801C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 829F8020: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829F8024: 388B8614  addi r4, r11, -0x79ec
	ctx.r[4].s64 = ctx.r[11].s64 + -31212;
	// 829F8028: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829F802C: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 829F8030: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 829F8034: 4BA1F38D  bl 0x824173c0
	ctx.lr = 0x829F8038;
	sub_824173C0(ctx, base);
	// 829F8038: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F803C: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 829F8040: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F8044: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F8048: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 829F804C: 419A0024  beq cr6, 0x829f8070
	if ctx.cr[6].eq {
	pc = 0x829F8070; continue 'dispatch;
	}
	// 829F8050: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829F8054: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829F8058: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F805C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829F8060: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829F8064: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829F8068: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F806C: 4082FFE8  bne 0x829f8054
	if !ctx.cr[0].eq {
	pc = 0x829F8054; continue 'dispatch;
	}
	// 829F8070: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F8074: 3BDF0028  addi r30, r31, 0x28
	ctx.r[30].s64 = ctx.r[31].s64 + 40;
	// 829F8078: 3B810068  addi r28, r1, 0x68
	ctx.r[28].s64 = ctx.r[1].s64 + 104;
	// 829F807C: 486100AD  bl 0x83008128
	ctx.lr = 0x829F8080;
	sub_83008128(ctx, base);
	// 829F8080: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829F8084: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829F8088: 3BAB7160  addi r29, r11, 0x7160
	ctx.r[29].s64 = ctx.r[11].s64 + 29024;
	// 829F808C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829F8090: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829F8094: 38A000F3  li r5, 0xf3
	ctx.r[5].s64 = 243;
	// 829F8098: C3EA08A4  lfs f31, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829F809C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F80A0: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 829F80A4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829F80A8: 48460999  bl 0x82e58a40
	ctx.lr = 0x829F80AC;
	sub_82E58A40(ctx, base);
	// 829F80AC: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 829F80B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F80B4: 419A0008  beq cr6, 0x829f80bc
	if ctx.cr[6].eq {
	pc = 0x829F80BC; continue 'dispatch;
	}
	// 829F80B8: 4B8C87D9  bl 0x822c0890
	ctx.lr = 0x829F80BC;
	sub_822C0890(ctx, base);
	// 829F80BC: 806100BC  lwz r3, 0xbc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 829F80C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F80C4: 419A0008  beq cr6, 0x829f80cc
	if ctx.cr[6].eq {
	pc = 0x829F80CC; continue 'dispatch;
	}
	// 829F80C8: 4B8C87C9  bl 0x822c0890
	ctx.lr = 0x829F80CC;
	sub_822C0890(ctx, base);
	// 829F80CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F80D0: 4BB19A19  bl 0x82511ae8
	ctx.lr = 0x829F80D4;
	sub_82511AE8(ctx, base);
	// 829F80D4: 396000F0  li r11, 0xf0
	ctx.r[11].s64 = 240;
	// 829F80D8: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 829F80DC: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829F80E0: 394100F0  addi r10, r1, 0xf0
	ctx.r[10].s64 = ctx.r[1].s64 + 240;
	// 829F80E4: D3E10094  stfs f31, 0x94(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 829F80E8: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F8448(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829F8448 size=1344
    let mut pc: u32 = 0x829F8448;
    'dispatch: loop {
        match pc {
            0x829F8448 => {
    //   block [0x829F8448..0x829F8988)
	// 829F8448: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F844C: 487AFD15  bl 0x831a8160
	ctx.lr = 0x829F8450;
	sub_831A8130(ctx, base);
	// 829F8450: DBA1FFB0  stfd f29, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[29].u64 ) };
	// 829F8454: DBC1FFB8  stfd f30, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[30].u64 ) };
	// 829F8458: DBE1FFC0  stfd f31, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 829F845C: 9421FE70  stwu r1, -0x190(r1)
	ea = ctx.r[1].u32.wrapping_add(-400 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F8460: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829F8464: 4875C19D  bl 0x83154600
	ctx.lr = 0x829F8468;
	sub_83154600(ctx, base);
	// 829F8468: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 829F846C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 829F8470: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F8474: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 829F8478: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 829F847C: C00BDFAC  lfs f0, -0x2054(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F8480: C1AA959C  lfs f13, -0x6a64(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27236 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829F8484: C19F0390  lfs f12, 0x390(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(912 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829F8488: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 829F848C: D01F0398  stfs f0, 0x398(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(920 as u32), tmp.u32 ) };
	// 829F8490: D19F0394  stfs f12, 0x394(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(916 as u32), tmp.u32 ) };
	// 829F8494: 9B7D0060  stb r27, 0x60(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(96 as u32), ctx.r[27].u8 ) };
	// 829F8498: 4BAF25F1  bl 0x824eaa88
	ctx.lr = 0x829F849C;
	sub_824EAA88(ctx, base);
	// 829F849C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F84A0: 4BAF13B1  bl 0x824e9850
	ctx.lr = 0x829F84A4;
	sub_824E9850(ctx, base);
	// 829F84A4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829F84A8: C3CB9450  lfs f30, -0x6bb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 829F84AC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F84B0: FF01F000  fcmpu cr6, f1, f30
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[30].f64);
	// 829F84B4: 41980008  blt cr6, 0x829f84bc
	if ctx.cr[6].lt {
	pc = 0x829F84BC; continue 'dispatch;
	}
	// 829F84B8: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 829F84BC: 997D00E7  stb r11, 0xe7(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(231 as u32), ctx.r[11].u8 ) };
	// 829F84C0: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 829F84C4: 483F97CD  bl 0x82df1c90
	ctx.lr = 0x829F84C8;
	sub_82DF1C90(ctx, base);
	// 829F84C8: C01F0390  lfs f0, 0x390(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(912 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F84CC: D01D00E8  stfs f0, 0xe8(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 829F84D0: 9B7D00EC  stb r27, 0xec(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(236 as u32), ctx.r[27].u8 ) };
	// 829F84D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F84D8: 4BB19611  bl 0x82511ae8
	ctx.lr = 0x829F84DC;
	sub_82511AE8(ctx, base);
	// 829F84DC: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 829F84E0: 392000F0  li r9, 0xf0
	ctx.r[9].s64 = 240;
	// 829F84E4: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 829F84E8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829F84EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F84F0: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829F84F4: 3BCB6F1C  addi r30, r11, 0x6f1c
	ctx.r[30].s64 = ctx.r[11].s64 + 28444;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F8988(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829F8988 size=504
    let mut pc: u32 = 0x829F8988;
    'dispatch: loop {
        match pc {
            0x829F8988 => {
    //   block [0x829F8988..0x829F8B80)
	// 829F8988: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F898C: 487AF7E1  bl 0x831a816c
	ctx.lr = 0x829F8990;
	sub_831A8130(ctx, base);
	// 829F8990: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 829F8994: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F8998: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F899C: 4875BC65  bl 0x83154600
	ctx.lr = 0x829F89A0;
	sub_83154600(ctx, base);
	// 829F89A0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829F89A4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829F89A8: 388B6F4C  addi r4, r11, 0x6f4c
	ctx.r[4].s64 = ctx.r[11].s64 + 28492;
	// 829F89AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F89B0: 483FB059  bl 0x82df3a08
	ctx.lr = 0x829F89B4;
	sub_82DF3A08(ctx, base);
	// 829F89B4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 829F89B8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829F89BC: 809E0160  lwz r4, 0x160(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(352 as u32) ) } as u64;
	// 829F89C0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829F89C4: C3EB6150  lfs f31, 0x6150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829F89C8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829F89CC: 481BA2ED  bl 0x82bb2cb8
	ctx.lr = 0x829F89D0;
	sub_82BB2CB8(ctx, base);
	// 829F89D0: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 829F89D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F89D8: 419A0008  beq cr6, 0x829f89e0
	if ctx.cr[6].eq {
	pc = 0x829F89E0; continue 'dispatch;
	}
	// 829F89DC: 4B8C7EB5  bl 0x822c0890
	ctx.lr = 0x829F89E0;
	sub_822C0890(ctx, base);
	// 829F89E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F89E4: 483FAA45  bl 0x82df3428
	ctx.lr = 0x829F89E8;
	sub_82DF3428(ctx, base);
	// 829F89E8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829F89EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F89F0: 388B6EE8  addi r4, r11, 0x6ee8
	ctx.r[4].s64 = ctx.r[11].s64 + 28392;
	// 829F89F4: 483FB015  bl 0x82df3a08
	ctx.lr = 0x829F89F8;
	sub_82DF3A08(ctx, base);
	// 829F89F8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829F89FC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829F8A00: 809E0160  lwz r4, 0x160(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(352 as u32) ) } as u64;
	// 829F8A04: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829F8A08: 481BA2B1  bl 0x82bb2cb8
	ctx.lr = 0x829F8A0C;
	sub_82BB2CB8(ctx, base);
	// 829F8A0C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 829F8A10: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F8A14: 419A0008  beq cr6, 0x829f8a1c
	if ctx.cr[6].eq {
	pc = 0x829F8A1C; continue 'dispatch;
	}
	// 829F8A18: 4B8C7E79  bl 0x822c0890
	ctx.lr = 0x829F8A1C;
	sub_822C0890(ctx, base);
	// 829F8A1C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F8A20: 483FAA09  bl 0x82df3428
	ctx.lr = 0x829F8A24;
	sub_82DF3428(ctx, base);
	// 829F8A24: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 829F8A28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F8A2C: 4BFF5355  bl 0x829edd80
	ctx.lr = 0x829F8A30;
	sub_829EDD80(ctx, base);
	// 829F8A30: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 829F8A34: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F8A38: 4BFF5349  bl 0x829edd80
	ctx.lr = 0x829F8A3C;
	sub_829EDD80(ctx, base);
	// 829F8A3C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829F8A40: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 829F8A44: 4BB16A85  bl 0x8250f4c8
	ctx.lr = 0x829F8A48;
	sub_8250F4C8(ctx, base);
	// 829F8A48: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F8A4C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 829F8A50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F8A54: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 829F8A58: 409A0008  bne cr6, 0x829f8a60
	if !ctx.cr[6].eq {
	pc = 0x829F8A60; continue 'dispatch;
	}
	// 829F8A5C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829F8A60: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829F8A64: 4BB11EED  bl 0x8250a950
	ctx.lr = 0x829F8A68;
	sub_8250A950(ctx, base);
	// 829F8A68: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 829F8A6C: 483F9225  bl 0x82df1c90
	ctx.lr = 0x829F8A70;
	sub_82DF1C90(ctx, base);
	// 829F8A70: 3BFF0064  addi r31, r31, 0x64
	ctx.r[31].s64 = ctx.r[31].s64 + 100;
	// 829F8A74: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F8A78: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F8A7C: 419A0040  beq cr6, 0x829f8abc
	if ctx.cr[6].eq {
	pc = 0x829F8ABC; continue 'dispatch;
	}
	// 829F8A80: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829F8A84: 48488CBD  bl 0x82e81740
	ctx.lr = 0x829F8A88;
	sub_82E81740(ctx, base);
	// 829F8A88: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 829F8A8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F8A90: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 829F8A94: 409A0008  bne cr6, 0x829f8a9c
	if !ctx.cr[6].eq {
	pc = 0x829F8A9C; continue 'dispatch;
	}
	// 829F8A98: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F8A9C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F8AA0: 4BDDAED1  bl 0x827d3970
	ctx.lr = 0x829F8AA4;
	sub_827D3970(ctx, base);
	// 829F8AA4: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 829F8AA8: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F8AAC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F8AB0: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 829F8AB4: 419A0008  beq cr6, 0x829f8abc
	if ctx.cr[6].eq {
	pc = 0x829F8ABC; continue 'dispatch;
	}
	// 829F8AB8: 4B8C7DD9  bl 0x822c0890
	ctx.lr = 0x829F8ABC;
	sub_822C0890(ctx, base);
	// 829F8ABC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829F8AC0: 483F91D1  bl 0x82df1c90
	ctx.lr = 0x829F8AC4;
	sub_82DF1C90(ctx, base);
	// 829F8AC4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829F8AC8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829F8ACC: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 829F8AD0: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829F8AD4: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 829F8AD8: 4BFF7439  bl 0x829eff10
	ctx.lr = 0x829F8ADC;
	sub_829EFF10(ctx, base);
	// 829F8ADC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F8AE0: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829F8AE4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F8AE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F8AEC: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 829F8AF0: 419A0024  beq cr6, 0x829f8b14
	if ctx.cr[6].eq {
	pc = 0x829F8B14; continue 'dispatch;
	}
	// 829F8AF4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829F8AF8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829F8AFC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F8B00: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829F8B04: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829F8B08: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829F8B0C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F8B10: 4082FFE8  bne 0x829f8af8
	if !ctx.cr[0].eq {
	pc = 0x829F8AF8; continue 'dispatch;
	}
	// 829F8B14: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829F8B18: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 829F8B1C: 4BB16815  bl 0x8250f330
	ctx.lr = 0x829F8B20;
	sub_8250F330(ctx, base);
	// 829F8B20: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F8B24: 3BE10058  addi r31, r1, 0x58
	ctx.r[31].s64 = ctx.r[1].s64 + 88;
	// 829F8B28: 4BAF0D49  bl 0x824e9870
	ctx.lr = 0x829F8B2C;
	sub_824E9870(ctx, base);
	// 829F8B2C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829F8B30: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829F8B34: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829F8B38: 388B7160  addi r4, r11, 0x7160
	ctx.r[4].s64 = ctx.r[11].s64 + 29024;
	// 829F8B3C: 38A001C3  li r5, 0x1c3
	ctx.r[5].s64 = 451;
	// 829F8B40: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 829F8B44: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 829F8B48: 4845FEF9  bl 0x82e58a40
	ctx.lr = 0x829F8B4C;
	sub_82E58A40(ctx, base);
	// 829F8B4C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 829F8B50: 483F9141  bl 0x82df1c90
	ctx.lr = 0x829F8B54;
	sub_82DF1C90(ctx, base);
	// 829F8B54: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829F8B58: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F8B5C: 419A0008  beq cr6, 0x829f8b64
	if ctx.cr[6].eq {
	pc = 0x829F8B64; continue 'dispatch;
	}
	// 829F8B60: 4B8C7D31  bl 0x822c0890
	ctx.lr = 0x829F8B64;
	sub_822C0890(ctx, base);
	// 829F8B64: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 829F8B68: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F8B6C: 419A0008  beq cr6, 0x829f8b74
	if ctx.cr[6].eq {
	pc = 0x829F8B74; continue 'dispatch;
	}
	// 829F8B70: 4B8C7D21  bl 0x822c0890
	ctx.lr = 0x829F8B74;
	sub_822C0890(ctx, base);
	// 829F8B74: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 829F8B78: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 829F8B7C: 487AF640  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F8B80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829F8B80 size=5036
    let mut pc: u32 = 0x829F8B80;
    'dispatch: loop {
        match pc {
            0x829F8B80 => {
    //   block [0x829F8B80..0x829F9F2C)
	// 829F8B80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F8B84: 487AF5DD  bl 0x831a8160
	ctx.lr = 0x829F8B88;
	sub_831A8130(ctx, base);
	// 829F8B88: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 829F8B8C: 487AFEE5  bl 0x831a8a70
	ctx.lr = 0x829F8B90;
	sub_831A8A40(ctx, base);
	// 829F8B90: 9421FCE0  stwu r1, -0x320(r1)
	ea = ctx.r[1].u32.wrapping_add(-800 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F8B94: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829F8B98: 4875BA69  bl 0x83154600
	ctx.lr = 0x829F8B9C;
	sub_83154600(ctx, base);
	// 829F8B9C: 897E0060  lbz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 829F8BA0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F8BA4: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829F8BA8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829F8BAC: 41980CCC  blt cr6, 0x829f9878
	if ctx.cr[6].lt {
	pc = 0x829F9878; continue 'dispatch;
	}
	// 829F8BB0: 419A0AB0  beq cr6, 0x829f9660
	if ctx.cr[6].eq {
	pc = 0x829F9660; continue 'dispatch;
	}
	// 829F8BB4: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 829F8BB8: 4198057C  blt cr6, 0x829f9134
	if ctx.cr[6].lt {
	pc = 0x829F9134; continue 'dispatch;
	}
	// 829F8BBC: 419A00DC  beq cr6, 0x829f8c98
	if ctx.cr[6].eq {
	pc = 0x829F8C98; continue 'dispatch;
	}
	// 829F8BC0: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 829F8BC4: 40981348  bge cr6, 0x829f9f0c
	if !ctx.cr[6].lt {
	pc = 0x829F9F0C; continue 'dispatch;
	}
	// 829F8BC8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F8BCC: 48460B95  bl 0x82e59760
	ctx.lr = 0x829F8BD0;
	sub_82E59760(ctx, base);
	// 829F8BD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F8BD4: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 829F8BD8: 4BFF5391  bl 0x829edf68
	ctx.lr = 0x829F8BDC;
	sub_829EDF68(ctx, base);
	// 829F8BDC: 897E0060  lbz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 829F8BE0: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829F8BE4: 396B000E  addi r11, r11, 0xe
	ctx.r[11].s64 = ctx.r[11].s64 + 14;
	// 829F8BE8: 1D6B0003  mulli r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 * 3;
	// 829F8BEC: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 829F8BF0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829F8BF4: 7C0BF42E  lfsx f0, r11, r30
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F8BF8: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 829F8BFC: 41981310  blt cr6, 0x829f9f0c
	if ctx.cr[6].lt {
	pc = 0x829F9F0C; continue 'dispatch;
	}
	// 829F8C00: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F8C04: 38610150  addi r3, r1, 0x150
	ctx.r[3].s64 = ctx.r[1].s64 + 336;
	// 829F8C08: 4BFF6AB1  bl 0x829ef6b8
	ctx.lr = 0x829F8C0C;
	sub_829EF6B8(ctx, base);
	// 829F8C0C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F8C10: 916100D0  stw r11, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[11].u32 ) };
	// 829F8C14: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F8C18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F8C1C: 916100D4  stw r11, 0xd4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), ctx.r[11].u32 ) };
	// 829F8C20: 419A0024  beq cr6, 0x829f8c44
	if ctx.cr[6].eq {
	pc = 0x829F8C44; continue 'dispatch;
	}
	// 829F8C24: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829F8C28: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829F8C2C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F8C30: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829F8C34: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829F8C38: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829F8C3C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F8C40: 4082FFE8  bne 0x829f8c28
	if !ctx.cr[0].eq {
	pc = 0x829F8C28; continue 'dispatch;
	}
	// 829F8C44: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829F8C48: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 829F8C4C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829F8C50: 38A100D0  addi r5, r1, 0xd0
	ctx.r[5].s64 = ctx.r[1].s64 + 208;
	// 829F8C54: 389F00E8  addi r4, r31, 0xe8
	ctx.r[4].s64 = ctx.r[31].s64 + 232;
	// 829F8C58: 38610210  addi r3, r1, 0x210
	ctx.r[3].s64 = ctx.r[1].s64 + 528;
	// 829F8C5C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829F8C60: 48465A49  bl 0x82e5e6a8
	ctx.lr = 0x829F8C64;
	sub_82E5E6A8(ctx, base);
	// 829F8C64: 80610214  lwz r3, 0x214(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(532 as u32) ) } as u64;
	// 829F8C68: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F8C6C: 419A0008  beq cr6, 0x829f8c74
	if ctx.cr[6].eq {
	pc = 0x829F8C74; continue 'dispatch;
	}
	// 829F8C70: 4B8C7C21  bl 0x822c0890
	ctx.lr = 0x829F8C74;
	sub_822C0890(ctx, base);
	// 829F8C74: 806100D4  lwz r3, 0xd4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 829F8C78: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F8C7C: 419A0008  beq cr6, 0x829f8c84
	if ctx.cr[6].eq {
	pc = 0x829F8C84; continue 'dispatch;
	}
	// 829F8C80: 4B8C7C11  bl 0x822c0890
	ctx.lr = 0x829F8C84;
	sub_822C0890(ctx, base);
	// 829F8C84: 80610154  lwz r3, 0x154(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(340 as u32) ) } as u64;
	// 829F8C88: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F8C8C: 419A1280  beq cr6, 0x829f9f0c
	if ctx.cr[6].eq {
	pc = 0x829F9F0C; continue 'dispatch;
	}
	// 829F8C90: 4B8C7C01  bl 0x822c0890
	ctx.lr = 0x829F8C94;
	sub_822C0890(ctx, base);
	// 829F8C94: 48001278  b 0x829f9f0c
	pc = 0x829F9F0C; continue 'dispatch;
	// 829F8C98: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 829F8C9C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 829F8CA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F8CA4: C00BDFAC  lfs f0, -0x2054(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F8CA8: C1AA9524  lfs f13, -0x6adc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829F8CAC: EFE00372  fmuls f31, f0, f13
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 829F8CB0: 4BFF52B9  bl 0x829edf68
	ctx.lr = 0x829F8CB4;
	sub_829EDF68(ctx, base);
	// 829F8CB4: 39630030  addi r11, r3, 0x30
	ctx.r[11].s64 = ctx.r[3].s64 + 48;
	// 829F8CB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F8CBC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829F8CC0: 7C0BF42E  lfsx f0, r11, r30
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F8CC4: EF7F0024  fdivs f27, f31, f0
	ctx.f[27].f64 = ((ctx.f[31].f64 / ctx.f[0].f64) as f32) as f64;
	// 829F8CC8: 4BFF52A1  bl 0x829edf68
	ctx.lr = 0x829F8CCC;
	sub_829EDF68(ctx, base);
	// 829F8CCC: 897E0060  lbz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 829F8CD0: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 829F8CD4: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 829F8CD8: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829F8CDC: 396B000E  addi r11, r11, 0xe
	ctx.r[11].s64 = ctx.r[11].s64 + 14;
	// 829F8CE0: C00AD5B8  lfs f0, -0x2a48(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10824 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F8CE4: 1D6B0003  mulli r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 * 3;
	// 829F8CE8: C1A99450  lfs f13, -0x6bb0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829F8CEC: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 829F8CF0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F8CF4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829F8CF8: 7FEBF42E  lfsx f31, r11, r30
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829F8CFC: EFBF0032  fmuls f29, f31, f0
	ctx.f[29].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 829F8D00: EFDF0372  fmuls f30, f31, f13
	ctx.f[30].f64 = (((ctx.f[31].f64 * ctx.f[13].f64) as f32) as f64);
	// 829F8D04: 48460A5D  bl 0x82e59760
	ctx.lr = 0x829F8D08;
	sub_82E59760(ctx, base);
	// 829F8D08: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829F8D0C: FF01F000  fcmpu cr6, f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[30].f64);
	// 829F8D10: C38B08A8  lfs f28, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 829F8D14: 40980028  bge cr6, 0x829f8d3c
	if !ctx.cr[6].lt {
	pc = 0x829F8D3C; continue 'dispatch;
	}
	// 829F8D18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F8D1C: 48460A45  bl 0x82e59760
	ctx.lr = 0x829F8D20;
	sub_82E59760(ctx, base);
	// 829F8D20: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F8D24: EF41F028  fsubs f26, f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[26].f64 = (((ctx.f[1].f64 - ctx.f[30].f64) as f32) as f64);
	// 829F8D28: 48460A39  bl 0x82e59760
	ctx.lr = 0x829F8D2C;
	sub_82E59760(ctx, base);
	// 829F8D2C: EC01F028  fsubs f0, f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[1].f64 - ctx.f[30].f64) as f32) as f64);
	// 829F8D30: EDBCF824  fdivs f13, f28, f31
	ctx.f[13].f64 = ((ctx.f[28].f64 / ctx.f[31].f64) as f32) as f64;
	// 829F8D34: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 829F8D38: EFA0EEBC  fnmsubs f29, f0, f26, f29
	ctx.f[29].f64 = -(((ctx.f[0].f64 * ctx.f[26].f64 - ctx.f[29].f64) as f32) as f64);
	// 829F8D3C: 897E00E7  lbz r11, 0xe7(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(231 as u32) ) } as u64;
	// 829F8D40: C01E00E8  lfs f0, 0xe8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(232 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F8D44: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829F8D48: 4182000C  beq 0x829f8d54
	if ctx.cr[0].eq {
	pc = 0x829F8D54; continue 'dispatch;
	}
	// 829F8D4C: EC1D06FC  fnmsubs f0, f29, f27, f0
	ctx.f[0].f64 = -(((ctx.f[29].f64 * ctx.f[27].f64 - ctx.f[0].f64) as f32) as f64);
	// 829F8D50: 48000008  b 0x829f8d58
	pc = 0x829F8D58; continue 'dispatch;
	// 829F8D54: EC1D06FA  fmadds f0, f29, f27, f0
	ctx.f[0].f64 = (((ctx.f[29].f64 * ctx.f[27].f64 + ctx.f[0].f64) as f32) as f64);
	// 829F8D58: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829F8D5C: D01F0390  stfs f0, 0x390(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(912 as u32), tmp.u32 ) };
	// 829F8D60: D01F0394  stfs f0, 0x394(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(916 as u32), tmp.u32 ) };
	// 829F8D64: 38810130  addi r4, r1, 0x130
	ctx.r[4].s64 = ctx.r[1].s64 + 304;
	// 829F8D68: D3810134  stfs f28, 0x134(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(308 as u32), tmp.u32 ) };
	// 829F8D6C: 38610290  addi r3, r1, 0x290
	ctx.r[3].s64 = ctx.r[1].s64 + 656;
	// 829F8D70: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829F8D74: D3E10130  stfs f31, 0x130(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(304 as u32), tmp.u32 ) };
	// 829F8D78: D3E10138  stfs f31, 0x138(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(312 as u32), tmp.u32 ) };
	// 829F8D7C: D3E1013C  stfs f31, 0x13c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(316 as u32), tmp.u32 ) };
	// 829F8D80: C03F0390  lfs f1, 0x390(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(912 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829F8D84: 48483EBD  bl 0x82e7cc40
	ctx.lr = 0x829F8D88;
	sub_82E7CC40(ctx, base);
	// 829F8D88: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829F8D8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F8D90: 4BB18D61  bl 0x82511af0
	ctx.lr = 0x829F8D94;
	sub_82511AF0(ctx, base);
	// 829F8D94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F8D98: 484609E1  bl 0x82e59778
	ctx.lr = 0x829F8D9C;
	sub_82E59778(ctx, base);
	// 829F8D9C: C01E0100  lfs f0, 0x100(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(256 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F8DA0: EC000828  fsubs f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 829F8DA4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 829F8DA8: D01E0100  stfs f0, 0x100(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 829F8DAC: C3AB6150  lfs f29, 0x6150(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 829F8DB0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 829F8DB4: 41990188  bgt cr6, 0x829f8f3c
	if ctx.cr[6].gt {
	pc = 0x829F8F3C; continue 'dispatch;
	}
	// 829F8DB8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F8DBC: 484609A5  bl 0x82e59760
	ctx.lr = 0x829F8DC0;
	sub_82E59760(ctx, base);
	// 829F8DC0: FF01E000  fcmpu cr6, f1, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[28].f64);
	// 829F8DC4: 41990178  bgt cr6, 0x829f8f3c
	if ctx.cr[6].gt {
	pc = 0x829F8F3C; continue 'dispatch;
	}
	// 829F8DC8: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 829F8DCC: C01E0100  lfs f0, 0x100(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(256 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F8DD0: D3E10110  stfs f31, 0x110(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 829F8DD4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829F8DD8: D3810114  stfs f28, 0x114(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 829F8DDC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829F8DE0: D3E10118  stfs f31, 0x118(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(280 as u32), tmp.u32 ) };
	// 829F8DE4: 3B8B7160  addi r28, r11, 0x7160
	ctx.r[28].s64 = ctx.r[11].s64 + 29024;
	// 829F8DE8: D3E1011C  stfs f31, 0x11c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(284 as u32), tmp.u32 ) };
	// 829F8DEC: 38A002A6  li r5, 0x2a6
	ctx.r[5].s64 = 678;
	// 829F8DF0: C3CA964C  lfs f30, -0x69b4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 829F8DF4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 829F8DF8: EC00F02A  fadds f0, f0, f30
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64;
	// 829F8DFC: D01E0100  stfs f0, 0x100(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 829F8E00: 38600050  li r3, 0x50
	ctx.r[3].s64 = 80;
	// 829F8E04: 483F95E5  bl 0x82df23e8
	ctx.lr = 0x829F8E08;
	sub_82DF23E8(ctx, base);
	// 829F8E08: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829F8E0C: 41820024  beq 0x829f8e30
	if ctx.cr[0].eq {
	pc = 0x829F8E30; continue 'dispatch;
	}
	// 829F8E10: 38E10110  addi r7, r1, 0x110
	ctx.r[7].s64 = ctx.r[1].s64 + 272;
	// 829F8E14: FC60E890  fmr f3, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[29].f64;
	// 829F8E18: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 829F8E1C: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 829F8E20: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 829F8E24: 48158665  bl 0x82b51488
	ctx.lr = 0x829F8E28;
	sub_82B51488(ctx, base);
	// 829F8E28: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829F8E2C: 48000008  b 0x829f8e34
	pc = 0x829F8E34; continue 'dispatch;
	// 829F8E30: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 829F8E34: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 829F8E38: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829F8E3C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829F8E40: 4B976CD9  bl 0x8236fb18
	ctx.lr = 0x829F8E44;
	sub_8236FB18(ctx, base);
	// 829F8E44: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 829F8E48: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829F8E4C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829F8E50: 4B8C71B1  bl 0x822c0000
	ctx.lr = 0x829F8E54;
	sub_822C0000(ctx, base);
	// 829F8E54: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829F8E58: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829F8E5C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829F8E60: 93A100C4  stw r29, 0xc4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[29].u32 ) };
	// 829F8E64: 916100C0  stw r11, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 829F8E68: 419A0024  beq cr6, 0x829f8e8c
	if ctx.cr[6].eq {
	pc = 0x829F8E8C; continue 'dispatch;
	}
	// 829F8E6C: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 829F8E70: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829F8E74: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F8E78: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829F8E7C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829F8E80: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829F8E84: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F8E88: 4082FFE8  bne 0x829f8e70
	if !ctx.cr[0].eq {
	pc = 0x829F8E70; continue 'dispatch;
	}
	// 829F8E8C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F8E90: 38610230  addi r3, r1, 0x230
	ctx.r[3].s64 = ctx.r[1].s64 + 560;
	// 829F8E94: 4BB16685  bl 0x8250f518
	ctx.lr = 0x829F8E98;
	sub_8250F518(ctx, base);
	// 829F8E98: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F8E9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F8EA0: 386BFF6C  addi r3, r11, -0x94
	ctx.r[3].s64 = ctx.r[11].s64 + -148;
	// 829F8EA4: 409A0008  bne cr6, 0x829f8eac
	if !ctx.cr[6].eq {
	pc = 0x829F8EAC; continue 'dispatch;
	}
	// 829F8EA8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 829F8EAC: 3B6100C0  addi r27, r1, 0xc0
	ctx.r[27].s64 = ctx.r[1].s64 + 192;
	// 829F8EB0: 4BB2F1A1  bl 0x82528050
	ctx.lr = 0x829F8EB4;
	sub_82528050(ctx, base);
	// 829F8EB4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829F8EB8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829F8EBC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 829F8EC0: 38A002AD  li r5, 0x2ad
	ctx.r[5].s64 = 685;
	// 829F8EC4: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 829F8EC8: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 829F8ECC: 4845FB75  bl 0x82e58a40
	ctx.lr = 0x829F8ED0;
	sub_82E58A40(ctx, base);
	// 829F8ED0: 38610230  addi r3, r1, 0x230
	ctx.r[3].s64 = ctx.r[1].s64 + 560;
	// 829F8ED4: 483F8DBD  bl 0x82df1c90
	ctx.lr = 0x829F8ED8;
	sub_82DF1C90(ctx, base);
	// 829F8ED8: 806100C4  lwz r3, 0xc4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 829F8EDC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F8EE0: 419A0008  beq cr6, 0x829f8ee8
	if ctx.cr[6].eq {
	pc = 0x829F8EE8; continue 'dispatch;
	}
	// 829F8EE4: 4B8C79AD  bl 0x822c0890
	ctx.lr = 0x829F8EE8;
	sub_822C0890(ctx, base);
	// 829F8EE8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829F8EEC: 419A000C  beq cr6, 0x829f8ef8
	if ctx.cr[6].eq {
	pc = 0x829F8EF8; continue 'dispatch;
	}
	// 829F8EF0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F8EF4: 4B8C799D  bl 0x822c0890
	ctx.lr = 0x829F8EF8;
	sub_822C0890(ctx, base);
	// 829F8EF8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 829F8EFC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829F8F00: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 829F8F04: 808B1674  lwz r4, 0x1674(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5748 as u32) ) } as u64;
	// 829F8F08: 483F8CF1  bl 0x82df1bf8
	ctx.lr = 0x829F8F0C;
	sub_82DF1BF8(ctx, base);
	// 829F8F0C: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 829F8F10: 38610200  addi r3, r1, 0x200
	ctx.r[3].s64 = ctx.r[1].s64 + 512;
	// 829F8F14: 388BAC8C  addi r4, r11, -0x5374
	ctx.r[4].s64 = ctx.r[11].s64 + -21364;
	// 829F8F18: 83A100E0  lwz r29, 0xe0(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(224 as u32) ) } as u64;
	// 829F8F1C: 48400615  bl 0x82df9530
	ctx.lr = 0x829F8F20;
	sub_82DF9530(ctx, base);
	// 829F8F20: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829F8F24: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 829F8F28: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F8F2C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F8F30: 4BB2D521  bl 0x82526450
	ctx.lr = 0x829F8F34;
	sub_82526450(ctx, base);
	// 829F8F34: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 829F8F38: 483F8D59  bl 0x82df1c90
	ctx.lr = 0x829F8F3C;
	sub_82DF1C90(ctx, base);
	// 829F8F3C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F8F40: 48460821  bl 0x82e59760
	ctx.lr = 0x829F8F44;
	sub_82E59760(ctx, base);
	// 829F8F44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F8F48: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 829F8F4C: 4BFF501D  bl 0x829edf68
	ctx.lr = 0x829F8F50;
	sub_829EDF68(ctx, base);
	// 829F8F50: 897E0060  lbz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 829F8F54: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829F8F58: 396B000E  addi r11, r11, 0xe
	ctx.r[11].s64 = ctx.r[11].s64 + 14;
	// 829F8F5C: 1D6B0003  mulli r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 * 3;
	// 829F8F60: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 829F8F64: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829F8F68: 7C0BF42E  lfsx f0, r11, r30
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F8F6C: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 829F8F70: 41980F9C  blt cr6, 0x829f9f0c
	if ctx.cr[6].lt {
	pc = 0x829F9F0C; continue 'dispatch;
	}
	// 829F8F74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F8F78: 484607E9  bl 0x82e59760
	ctx.lr = 0x829F8F7C;
	sub_82E59760(ctx, base);
	// 829F8F7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F8F80: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 829F8F84: 4BFF4FE5  bl 0x829edf68
	ctx.lr = 0x829F8F88;
	sub_829EDF68(ctx, base);
	// 829F8F88: 897E0060  lbz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 829F8F8C: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829F8F90: 396B000E  addi r11, r11, 0xe
	ctx.r[11].s64 = ctx.r[11].s64 + 14;
	// 829F8F94: 1D6B0003  mulli r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 * 3;
	// 829F8F98: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 829F8F9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F8FA0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829F8FA4: 7C0BF42E  lfsx f0, r11, r30
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F8FA8: EC3F0028  fsubs f1, f31, f0
	ctx.f[1].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 829F8FAC: 48428F7D  bl 0x82e21f28
	ctx.lr = 0x829F8FB0;
	sub_82E21F28(ctx, base);
	// 829F8FB0: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 829F8FB4: 997E0060  stb r11, 0x60(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(96 as u32), ctx.r[11].u8 ) };
	// 829F8FB8: 897E00E7  lbz r11, 0xe7(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(231 as u32) ) } as u64;
	// 829F8FBC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829F8FC0: 418200B0  beq 0x829f9070
	if ctx.cr[0].eq {
	pc = 0x829F9070; continue 'dispatch;
	}
	// 829F8FC4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829F8FC8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829F8FCC: 3BAB6E4C  addi r29, r11, 0x6e4c
	ctx.r[29].s64 = ctx.r[11].s64 + 28236;
	// 829F8FD0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829F8FD4: 483FAA35  bl 0x82df3a08
	ctx.lr = 0x829F8FD8;
	sub_82DF3A08(ctx, base);
	// 829F8FD8: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 829F8FDC: 38610240  addi r3, r1, 0x240
	ctx.r[3].s64 = ctx.r[1].s64 + 576;
	// 829F8FE0: 809F0160  lwz r4, 0x160(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 829F8FE4: FC40E890  fmr f2, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[29].f64;
	// 829F8FE8: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 829F8FEC: 481BA38D  bl 0x82bb3378
	ctx.lr = 0x829F8FF0;
	sub_82BB3378(ctx, base);
	// 829F8FF0: 80610244  lwz r3, 0x244(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(580 as u32) ) } as u64;
	// 829F8FF4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F8FF8: 419A0008  beq cr6, 0x829f9000
	if ctx.cr[6].eq {
	pc = 0x829F9000; continue 'dispatch;
	}
	// 829F8FFC: 4B8C7895  bl 0x822c0890
	ctx.lr = 0x829F9000;
	sub_822C0890(ctx, base);
	// 829F9000: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829F9004: 483FA425  bl 0x82df3428
	ctx.lr = 0x829F9008;
	sub_82DF3428(ctx, base);
	// 829F9008: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829F900C: 3861009C  addi r3, r1, 0x9c
	ctx.r[3].s64 = ctx.r[1].s64 + 156;
	// 829F9010: 483FA9F9  bl 0x82df3a08
	ctx.lr = 0x829F9014;
	sub_82DF3A08(ctx, base);
	// 829F9014: 38A1009C  addi r5, r1, 0x9c
	ctx.r[5].s64 = ctx.r[1].s64 + 156;
	// 829F9018: 38610168  addi r3, r1, 0x168
	ctx.r[3].s64 = ctx.r[1].s64 + 360;
	// 829F901C: 809F0160  lwz r4, 0x160(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 829F9020: 481B9BA9  bl 0x82bb2bc8
	ctx.lr = 0x829F9024;
	sub_82BB2BC8(ctx, base);
	// 829F9024: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829F9028: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F902C: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F9030: 4BFF4F39  bl 0x829edf68
	ctx.lr = 0x829F9034;
	sub_829EDF68(ctx, base);
	// 829F9034: 897E0060  lbz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 829F9038: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829F903C: 396B0009  addi r11, r11, 9
	ctx.r[11].s64 = ctx.r[11].s64 + 9;
	// 829F9040: 1D6B0003  mulli r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 * 3;
	// 829F9044: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 829F9048: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F904C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829F9050: 7C2BF42E  lfsx f1, r11, r30
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829F9054: 481BFA1D  bl 0x82bb8a70
	ctx.lr = 0x829F9058;
	sub_82BB8A70(ctx, base);
	// 829F9058: 8061016C  lwz r3, 0x16c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(364 as u32) ) } as u64;
	// 829F905C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F9060: 419A0008  beq cr6, 0x829f9068
	if ctx.cr[6].eq {
	pc = 0x829F9068; continue 'dispatch;
	}
	// 829F9064: 4B8C782D  bl 0x822c0890
	ctx.lr = 0x829F9068;
	sub_822C0890(ctx, base);
	// 829F9068: 3861009C  addi r3, r1, 0x9c
	ctx.r[3].s64 = ctx.r[1].s64 + 156;
	// 829F906C: 480000AC  b 0x829f9118
	pc = 0x829F9118; continue 'dispatch;
	// 829F9070: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829F9074: 38610094  addi r3, r1, 0x94
	ctx.r[3].s64 = ctx.r[1].s64 + 148;
	// 829F9078: 3BAB6EA8  addi r29, r11, 0x6ea8
	ctx.r[29].s64 = ctx.r[11].s64 + 28328;
	// 829F907C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829F9080: 483FA989  bl 0x82df3a08
	ctx.lr = 0x829F9084;
	sub_82DF3A08(ctx, base);
	// 829F9084: 38A10094  addi r5, r1, 0x94
	ctx.r[5].s64 = ctx.r[1].s64 + 148;
	// 829F9088: 386101E8  addi r3, r1, 0x1e8
	ctx.r[3].s64 = ctx.r[1].s64 + 488;
	// 829F908C: 809F0160  lwz r4, 0x160(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 829F9090: FC40E890  fmr f2, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[29].f64;
	// 829F9094: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 829F9098: 481BA2E1  bl 0x82bb3378
	ctx.lr = 0x829F909C;
	sub_82BB3378(ctx, base);
	// 829F909C: 806101EC  lwz r3, 0x1ec(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(492 as u32) ) } as u64;
	// 829F90A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F90A4: 419A0008  beq cr6, 0x829f90ac
	if ctx.cr[6].eq {
	pc = 0x829F90AC; continue 'dispatch;
	}
	// 829F90A8: 4B8C77E9  bl 0x822c0890
	ctx.lr = 0x829F90AC;
	sub_822C0890(ctx, base);
	// 829F90AC: 38610094  addi r3, r1, 0x94
	ctx.r[3].s64 = ctx.r[1].s64 + 148;
	// 829F90B0: 483FA379  bl 0x82df3428
	ctx.lr = 0x829F90B4;
	sub_82DF3428(ctx, base);
	// 829F90B4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829F90B8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 829F90BC: 483FA94D  bl 0x82df3a08
	ctx.lr = 0x829F90C0;
	sub_82DF3A08(ctx, base);
	// 829F90C0: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 829F90C4: 38610178  addi r3, r1, 0x178
	ctx.r[3].s64 = ctx.r[1].s64 + 376;
	// 829F90C8: 809F0160  lwz r4, 0x160(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 829F90CC: 481B9AFD  bl 0x82bb2bc8
	ctx.lr = 0x829F90D0;
	sub_82BB2BC8(ctx, base);
	// 829F90D0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829F90D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F90D8: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F90DC: 4BFF4E8D  bl 0x829edf68
	ctx.lr = 0x829F90E0;
	sub_829EDF68(ctx, base);
	// 829F90E0: 897E0060  lbz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 829F90E4: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829F90E8: 396B0009  addi r11, r11, 9
	ctx.r[11].s64 = ctx.r[11].s64 + 9;
	// 829F90EC: 1D6B0003  mulli r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 * 3;
	// 829F90F0: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 829F90F4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F90F8: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829F90FC: 7C2BF42E  lfsx f1, r11, r30
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829F9100: 481BF971  bl 0x82bb8a70
	ctx.lr = 0x829F9104;
	sub_82BB8A70(ctx, base);
	// 829F9104: 8061017C  lwz r3, 0x17c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(380 as u32) ) } as u64;
	// 829F9108: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F910C: 419A0008  beq cr6, 0x829f9114
	if ctx.cr[6].eq {
	pc = 0x829F9114; continue 'dispatch;
	}
	// 829F9110: 4B8C7781  bl 0x822c0890
	ctx.lr = 0x829F9114;
	sub_822C0890(ctx, base);
	// 829F9114: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 829F9118: 483FA311  bl 0x82df3428
	ctx.lr = 0x829F911C;
	sub_82DF3428(ctx, base);
	// 829F911C: C01F0390  lfs f0, 0x390(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(912 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F9120: D01F0394  stfs f0, 0x394(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(916 as u32), tmp.u32 ) };
	// 829F9124: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 829F9128: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F912C: 4BFF4C75  bl 0x829edda0
	ctx.lr = 0x829F9130;
	sub_829EDDA0(ctx, base);
	// 829F9130: 48000DDC  b 0x829f9f0c
	pc = 0x829F9F0C; continue 'dispatch;
	// 829F9134: 897E00E7  lbz r11, 0xe7(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(231 as u32) ) } as u64;
	// 829F9138: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F913C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829F9140: 41820054  beq 0x829f9194
	if ctx.cr[0].eq {
	pc = 0x829F9194; continue 'dispatch;
	}
	// 829F9144: 4846061D  bl 0x82e59760
	ctx.lr = 0x829F9148;
	sub_82E59760(ctx, base);
	// 829F9148: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 829F914C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 829F9150: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F9154: C00BDFAC  lfs f0, -0x2054(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F9158: EDA10032  fmuls f13, f1, f0
	ctx.f[13].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 829F915C: C00A9524  lfs f0, -0x6adc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F9160: EFED0032  fmuls f31, f13, f0
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 829F9164: 4BFF4E05  bl 0x829edf68
	ctx.lr = 0x829F9168;
	sub_829EDF68(ctx, base);
	// 829F9168: 897E0060  lbz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 829F916C: C01E00E8  lfs f0, 0xe8(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(232 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F9170: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829F9174: 396B000E  addi r11, r11, 0xe
	ctx.r[11].s64 = ctx.r[11].s64 + 14;
	// 829F9178: 1D6B0003  mulli r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 * 3;
	// 829F917C: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 829F9180: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829F9184: 7DABF42E  lfsx f13, r11, r30
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829F9188: EDBF6824  fdivs f13, f31, f13
	ctx.f[13].f64 = ((ctx.f[31].f64 / ctx.f[13].f64) as f32) as f64;
	// 829F918C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 829F9190: 48000050  b 0x829f91e0
	pc = 0x829F91E0; continue 'dispatch;
	// 829F9194: 484605CD  bl 0x82e59760
	ctx.lr = 0x829F9198;
	sub_82E59760(ctx, base);
	// 829F9198: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 829F919C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 829F91A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F91A4: C00BDFAC  lfs f0, -0x2054(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F91A8: EDA10032  fmuls f13, f1, f0
	ctx.f[13].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 829F91AC: C00A9524  lfs f0, -0x6adc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F91B0: EFED0032  fmuls f31, f13, f0
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 829F91B4: 4BFF4DB5  bl 0x829edf68
	ctx.lr = 0x829F91B8;
	sub_829EDF68(ctx, base);
	// 829F91B8: 897E0060  lbz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 829F91BC: C01E00E8  lfs f0, 0xe8(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(232 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F91C0: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829F91C4: 396B000E  addi r11, r11, 0xe
	ctx.r[11].s64 = ctx.r[11].s64 + 14;
	// 829F91C8: 1D6B0003  mulli r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 * 3;
	// 829F91CC: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 829F91D0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829F91D4: 7DABF42E  lfsx f13, r11, r30
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829F91D8: EDBF6824  fdivs f13, f31, f13
	ctx.f[13].f64 = ((ctx.f[31].f64 / ctx.f[13].f64) as f32) as f64;
	// 829F91DC: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 829F91E0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829F91E4: D01F0390  stfs f0, 0x390(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(912 as u32), tmp.u32 ) };
	// 829F91E8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829F91EC: D01F0394  stfs f0, 0x394(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(916 as u32), tmp.u32 ) };
	// 829F91F0: 38810120  addi r4, r1, 0x120
	ctx.r[4].s64 = ctx.r[1].s64 + 288;
	// 829F91F4: 386102A0  addi r3, r1, 0x2a0
	ctx.r[3].s64 = ctx.r[1].s64 + 672;
	// 829F91F8: C3CA08A8  lfs f30, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 829F91FC: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829F9200: D3C10124  stfs f30, 0x124(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(292 as u32), tmp.u32 ) };
	// 829F9204: D3E1012C  stfs f31, 0x12c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(300 as u32), tmp.u32 ) };
	// 829F9208: D3E10120  stfs f31, 0x120(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(288 as u32), tmp.u32 ) };
	// 829F920C: D3E10128  stfs f31, 0x128(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(296 as u32), tmp.u32 ) };
	// 829F9210: C03F0390  lfs f1, 0x390(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(912 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829F9214: 48483A2D  bl 0x82e7cc40
	ctx.lr = 0x829F9218;
	sub_82E7CC40(ctx, base);
	// 829F9218: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829F921C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F9220: 4BB188D1  bl 0x82511af0
	ctx.lr = 0x829F9224;
	sub_82511AF0(ctx, base);
	// 829F9224: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F9228: 48460551  bl 0x82e59778
	ctx.lr = 0x829F922C;
	sub_82E59778(ctx, base);
	// 829F922C: C01E0100  lfs f0, 0x100(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(256 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F9230: EC000828  fsubs f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 829F9234: D01E0100  stfs f0, 0x100(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 829F9238: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 829F923C: 41990178  bgt cr6, 0x829f93b4
	if ctx.cr[6].gt {
	pc = 0x829F93B4; continue 'dispatch;
	}
	// 829F9240: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 829F9244: D3C10144  stfs f30, 0x144(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(324 as u32), tmp.u32 ) };
	// 829F9248: D3E10140  stfs f31, 0x140(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(320 as u32), tmp.u32 ) };
	// 829F924C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829F9250: D3E10148  stfs f31, 0x148(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(328 as u32), tmp.u32 ) };
	// 829F9254: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829F9258: D3E1014C  stfs f31, 0x14c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(332 as u32), tmp.u32 ) };
	// 829F925C: 3B8B7160  addi r28, r11, 0x7160
	ctx.r[28].s64 = ctx.r[11].s64 + 29024;
	// 829F9260: 38A00254  li r5, 0x254
	ctx.r[5].s64 = 596;
	// 829F9264: C3CA964C  lfs f30, -0x69b4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 829F9268: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 829F926C: EC00F02A  fadds f0, f0, f30
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64;
	// 829F9270: D01E0100  stfs f0, 0x100(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 829F9274: 38600050  li r3, 0x50
	ctx.r[3].s64 = 80;
	// 829F9278: 483F9171  bl 0x82df23e8
	ctx.lr = 0x829F927C;
	sub_82DF23E8(ctx, base);
	// 829F927C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829F9280: 41820028  beq 0x829f92a8
	if ctx.cr[0].eq {
	pc = 0x829F92A8; continue 'dispatch;
	}
	// 829F9284: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 829F9288: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 829F928C: 38E10140  addi r7, r1, 0x140
	ctx.r[7].s64 = ctx.r[1].s64 + 320;
	// 829F9290: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 829F9294: C06B7BC8  lfs f3, 0x7bc8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31688 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 829F9298: FC201890  fmr f1, f3
	ctx.f[1].f64 = ctx.f[3].f64;
	// 829F929C: 481581ED  bl 0x82b51488
	ctx.lr = 0x829F92A0;
	sub_82B51488(ctx, base);
	// 829F92A0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829F92A4: 48000008  b 0x829f92ac
	pc = 0x829F92AC; continue 'dispatch;
	// 829F92A8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 829F92AC: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 829F92B0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829F92B4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829F92B8: 4B976861  bl 0x8236fb18
	ctx.lr = 0x829F92BC;
	sub_8236FB18(ctx, base);
	// 829F92BC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 829F92C0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829F92C4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829F92C8: 4B8C6D39  bl 0x822c0000
	ctx.lr = 0x829F92CC;
	sub_822C0000(ctx, base);
	// 829F92CC: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829F92D0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829F92D4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829F92D8: 93A100AC  stw r29, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[29].u32 ) };
	// 829F92DC: 916100A8  stw r11, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[11].u32 ) };
	// 829F92E0: 419A0024  beq cr6, 0x829f9304
	if ctx.cr[6].eq {
	pc = 0x829F9304; continue 'dispatch;
	}
	// 829F92E4: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 829F92E8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829F92EC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F92F0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829F92F4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829F92F8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829F92FC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F9300: 4082FFE8  bne 0x829f92e8
	if !ctx.cr[0].eq {
	pc = 0x829F92E8; continue 'dispatch;
	}
	// 829F9304: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F9308: 38610228  addi r3, r1, 0x228
	ctx.r[3].s64 = ctx.r[1].s64 + 552;
	// 829F930C: 4BB1620D  bl 0x8250f518
	ctx.lr = 0x829F9310;
	sub_8250F518(ctx, base);
	// 829F9310: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F9314: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F9318: 386BFF6C  addi r3, r11, -0x94
	ctx.r[3].s64 = ctx.r[11].s64 + -148;
	// 829F931C: 409A0008  bne cr6, 0x829f9324
	if !ctx.cr[6].eq {
	pc = 0x829F9324; continue 'dispatch;
	}
	// 829F9320: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 829F9324: 3B6100A8  addi r27, r1, 0xa8
	ctx.r[27].s64 = ctx.r[1].s64 + 168;
	// 829F9328: 4BB2ED29  bl 0x82528050
	ctx.lr = 0x829F932C;
	sub_82528050(ctx, base);
	// 829F932C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829F9330: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829F9334: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 829F9338: 38A0025B  li r5, 0x25b
	ctx.r[5].s64 = 603;
	// 829F933C: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 829F9340: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 829F9344: 4845F6FD  bl 0x82e58a40
	ctx.lr = 0x829F9348;
	sub_82E58A40(ctx, base);
	// 829F9348: 38610228  addi r3, r1, 0x228
	ctx.r[3].s64 = ctx.r[1].s64 + 552;
	// 829F934C: 483F8945  bl 0x82df1c90
	ctx.lr = 0x829F9350;
	sub_82DF1C90(ctx, base);
	// 829F9350: 806100AC  lwz r3, 0xac(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 829F9354: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F9358: 419A0008  beq cr6, 0x829f9360
	if ctx.cr[6].eq {
	pc = 0x829F9360; continue 'dispatch;
	}
	// 829F935C: 4B8C7535  bl 0x822c0890
	ctx.lr = 0x829F9360;
	sub_822C0890(ctx, base);
	// 829F9360: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829F9364: 419A000C  beq cr6, 0x829f9370
	if ctx.cr[6].eq {
	pc = 0x829F9370; continue 'dispatch;
	}
	// 829F9368: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F936C: 4B8C7525  bl 0x822c0890
	ctx.lr = 0x829F9370;
	sub_822C0890(ctx, base);
	// 829F9370: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 829F9374: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829F9378: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 829F937C: 808B1674  lwz r4, 0x1674(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5748 as u32) ) } as u64;
	// 829F9380: 483F8879  bl 0x82df1bf8
	ctx.lr = 0x829F9384;
	sub_82DF1BF8(ctx, base);
	// 829F9384: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829F9388: 38610220  addi r3, r1, 0x220
	ctx.r[3].s64 = ctx.r[1].s64 + 544;
	// 829F938C: 388B13BC  addi r4, r11, 0x13bc
	ctx.r[4].s64 = ctx.r[11].s64 + 5052;
	// 829F9390: 83A100F0  lwz r29, 0xf0(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(240 as u32) ) } as u64;
	// 829F9394: 4840019D  bl 0x82df9530
	ctx.lr = 0x829F9398;
	sub_82DF9530(ctx, base);
	// 829F9398: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829F939C: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 829F93A0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F93A4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F93A8: 4BB2D0A9  bl 0x82526450
	ctx.lr = 0x829F93AC;
	sub_82526450(ctx, base);
	// 829F93AC: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 829F93B0: 483F88E1  bl 0x82df1c90
	ctx.lr = 0x829F93B4;
	sub_82DF1C90(ctx, base);
	// 829F93B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F93B8: 484603A9  bl 0x82e59760
	ctx.lr = 0x829F93BC;
	sub_82E59760(ctx, base);
	// 829F93BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F93C0: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 829F93C4: 4BFF4BA5  bl 0x829edf68
	ctx.lr = 0x829F93C8;
	sub_829EDF68(ctx, base);
	// 829F93C8: 897E0060  lbz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 829F93CC: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829F93D0: 396B000E  addi r11, r11, 0xe
	ctx.r[11].s64 = ctx.r[11].s64 + 14;
	// 829F93D4: 1D6B0003  mulli r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 * 3;
	// 829F93D8: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 829F93DC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829F93E0: 7C0BF42E  lfsx f0, r11, r30
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F93E4: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 829F93E8: 41980B24  blt cr6, 0x829f9f0c
	if ctx.cr[6].lt {
	pc = 0x829F9F0C; continue 'dispatch;
	}
	// 829F93EC: 897E00EC  lbz r11, 0xec(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(236 as u32) ) } as u64;
	// 829F93F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F93F4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829F93F8: 997E00EC  stb r11, 0xec(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(236 as u32), ctx.r[11].u8 ) };
	// 829F93FC: 48460365  bl 0x82e59760
	ctx.lr = 0x829F9400;
	sub_82E59760(ctx, base);
	// 829F9400: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F9404: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 829F9408: 4BFF4B61  bl 0x829edf68
	ctx.lr = 0x829F940C;
	sub_829EDF68(ctx, base);
	// 829F940C: 897E0060  lbz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 829F9410: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829F9414: 396B000E  addi r11, r11, 0xe
	ctx.r[11].s64 = ctx.r[11].s64 + 14;
	// 829F9418: 1D6B0003  mulli r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 * 3;
	// 829F941C: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 829F9420: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F9424: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829F9428: 7C0BF42E  lfsx f0, r11, r30
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F942C: EC3F0028  fsubs f1, f31, f0
	ctx.f[1].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 829F9430: 48428AF9  bl 0x82e21f28
	ctx.lr = 0x829F9434;
	sub_82E21F28(ctx, base);
	// 829F9434: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F9438: 4BFF4B31  bl 0x829edf68
	ctx.lr = 0x829F943C;
	sub_829EDF68(ctx, base);
	// 829F943C: 7D63F214  add r11, r3, r30
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[30].u64;
	// 829F9440: 895E00EC  lbz r10, 0xec(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(236 as u32) ) } as u64;
	// 829F9444: 896B00E4  lbz r11, 0xe4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(228 as u32) ) } as u64;
	// 829F9448: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829F944C: 41980AC0  blt cr6, 0x829f9f0c
	if ctx.cr[6].lt {
	pc = 0x829F9F0C; continue 'dispatch;
	}
	// 829F9450: 897E00E7  lbz r11, 0xe7(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(231 as u32) ) } as u64;
	// 829F9454: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 829F9458: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829F945C: 995E0060  stb r10, 0x60(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(96 as u32), ctx.r[10].u8 ) };
	// 829F9460: 418200F4  beq 0x829f9554
	if ctx.cr[0].eq {
	pc = 0x829F9554; continue 'dispatch;
	}
	// 829F9464: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829F9468: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829F946C: 388B6F4C  addi r4, r11, 0x6f4c
	ctx.r[4].s64 = ctx.r[11].s64 + 28492;
	// 829F9470: 483FA599  bl 0x82df3a08
	ctx.lr = 0x829F9474;
	sub_82DF3A08(ctx, base);
	// 829F9474: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 829F9478: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 829F947C: 809F0160  lwz r4, 0x160(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 829F9480: 38610188  addi r3, r1, 0x188
	ctx.r[3].s64 = ctx.r[1].s64 + 392;
	// 829F9484: C3EB6150  lfs f31, 0x6150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829F9488: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829F948C: 481B982D  bl 0x82bb2cb8
	ctx.lr = 0x829F9490;
	sub_82BB2CB8(ctx, base);
	// 829F9490: 8061018C  lwz r3, 0x18c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(396 as u32) ) } as u64;
	// 829F9494: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F9498: 419A0008  beq cr6, 0x829f94a0
	if ctx.cr[6].eq {
	pc = 0x829F94A0; continue 'dispatch;
	}
	// 829F949C: 4B8C73F5  bl 0x822c0890
	ctx.lr = 0x829F94A0;
	sub_822C0890(ctx, base);
	// 829F94A0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829F94A4: 483F9F85  bl 0x82df3428
	ctx.lr = 0x829F94A8;
	sub_82DF3428(ctx, base);
	// 829F94A8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829F94AC: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 829F94B0: 3BAB6E6C  addi r29, r11, 0x6e6c
	ctx.r[29].s64 = ctx.r[11].s64 + 28268;
	// 829F94B4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829F94B8: 483FA551  bl 0x82df3a08
	ctx.lr = 0x829F94BC;
	sub_82DF3A08(ctx, base);
	// 829F94BC: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 829F94C0: 386101F8  addi r3, r1, 0x1f8
	ctx.r[3].s64 = ctx.r[1].s64 + 504;
	// 829F94C4: 809F0160  lwz r4, 0x160(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 829F94C8: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 829F94CC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829F94D0: 481B9EA9  bl 0x82bb3378
	ctx.lr = 0x829F94D4;
	sub_82BB3378(ctx, base);
	// 829F94D4: 806101FC  lwz r3, 0x1fc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(508 as u32) ) } as u64;
	// 829F94D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F94DC: 419A0008  beq cr6, 0x829f94e4
	if ctx.cr[6].eq {
	pc = 0x829F94E4; continue 'dispatch;
	}
	// 829F94E0: 4B8C73B1  bl 0x822c0890
	ctx.lr = 0x829F94E4;
	sub_822C0890(ctx, base);
	// 829F94E4: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 829F94E8: 483F9F41  bl 0x82df3428
	ctx.lr = 0x829F94EC;
	sub_82DF3428(ctx, base);
	// 829F94EC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829F94F0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829F94F4: 483FA515  bl 0x82df3a08
	ctx.lr = 0x829F94F8;
	sub_82DF3A08(ctx, base);
	// 829F94F8: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 829F94FC: 38610198  addi r3, r1, 0x198
	ctx.r[3].s64 = ctx.r[1].s64 + 408;
	// 829F9500: 809F0160  lwz r4, 0x160(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 829F9504: 481B96C5  bl 0x82bb2bc8
	ctx.lr = 0x829F9508;
	sub_82BB2BC8(ctx, base);
	// 829F9508: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829F950C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F9510: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F9514: 4BFF4A55  bl 0x829edf68
	ctx.lr = 0x829F9518;
	sub_829EDF68(ctx, base);
	// 829F9518: 897E0060  lbz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 829F951C: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829F9520: 396B0009  addi r11, r11, 9
	ctx.r[11].s64 = ctx.r[11].s64 + 9;
	// 829F9524: 1D6B0003  mulli r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 * 3;
	// 829F9528: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 829F952C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F9530: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829F9534: 7C2BF42E  lfsx f1, r11, r30
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829F9538: 481BF539  bl 0x82bb8a70
	ctx.lr = 0x829F953C;
	sub_82BB8A70(ctx, base);
	// 829F953C: 8061019C  lwz r3, 0x19c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(412 as u32) ) } as u64;
	// 829F9540: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F9544: 419A0008  beq cr6, 0x829f954c
	if ctx.cr[6].eq {
	pc = 0x829F954C; continue 'dispatch;
	}
	// 829F9548: 4B8C7349  bl 0x822c0890
	ctx.lr = 0x829F954C;
	sub_822C0890(ctx, base);
	// 829F954C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829F9550: 480000F0  b 0x829f9640
	pc = 0x829F9640; continue 'dispatch;
	// 829F9554: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829F9558: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 829F955C: 388B6EE8  addi r4, r11, 0x6ee8
	ctx.r[4].s64 = ctx.r[11].s64 + 28392;
	// 829F9560: 483FA4A9  bl 0x82df3a08
	ctx.lr = 0x829F9564;
	sub_82DF3A08(ctx, base);
	// 829F9564: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 829F9568: 38A10088  addi r5, r1, 0x88
	ctx.r[5].s64 = ctx.r[1].s64 + 136;
	// 829F956C: 809F0160  lwz r4, 0x160(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 829F9570: 38610248  addi r3, r1, 0x248
	ctx.r[3].s64 = ctx.r[1].s64 + 584;
	// 829F9574: C3EB6150  lfs f31, 0x6150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829F9578: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829F957C: 481B973D  bl 0x82bb2cb8
	ctx.lr = 0x829F9580;
	sub_82BB2CB8(ctx, base);
	// 829F9580: 8061024C  lwz r3, 0x24c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(588 as u32) ) } as u64;
	// 829F9584: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F9588: 419A0008  beq cr6, 0x829f9590
	if ctx.cr[6].eq {
	pc = 0x829F9590; continue 'dispatch;
	}
	// 829F958C: 4B8C7305  bl 0x822c0890
	ctx.lr = 0x829F9590;
	sub_822C0890(ctx, base);
	// 829F9590: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 829F9594: 483F9E95  bl 0x82df3428
	ctx.lr = 0x829F9598;
	sub_82DF3428(ctx, base);
	// 829F9598: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829F959C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 829F95A0: 3BAB6EC0  addi r29, r11, 0x6ec0
	ctx.r[29].s64 = ctx.r[11].s64 + 28352;
	// 829F95A4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829F95A8: 483FA461  bl 0x82df3a08
	ctx.lr = 0x829F95AC;
	sub_82DF3A08(ctx, base);
	// 829F95AC: 38A10078  addi r5, r1, 0x78
	ctx.r[5].s64 = ctx.r[1].s64 + 120;
	// 829F95B0: 386101A8  addi r3, r1, 0x1a8
	ctx.r[3].s64 = ctx.r[1].s64 + 424;
	// 829F95B4: 809F0160  lwz r4, 0x160(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 829F95B8: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 829F95BC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829F95C0: 481B9DB9  bl 0x82bb3378
	ctx.lr = 0x829F95C4;
	sub_82BB3378(ctx, base);
	// 829F95C4: 806101AC  lwz r3, 0x1ac(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(428 as u32) ) } as u64;
	// 829F95C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F95CC: 419A0008  beq cr6, 0x829f95d4
	if ctx.cr[6].eq {
	pc = 0x829F95D4; continue 'dispatch;
	}
	// 829F95D0: 4B8C72C1  bl 0x822c0890
	ctx.lr = 0x829F95D4;
	sub_822C0890(ctx, base);
	// 829F95D4: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 829F95D8: 483F9E51  bl 0x82df3428
	ctx.lr = 0x829F95DC;
	sub_82DF3428(ctx, base);
	// 829F95DC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829F95E0: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 829F95E4: 483FA425  bl 0x82df3a08
	ctx.lr = 0x829F95E8;
	sub_82DF3A08(ctx, base);
	// 829F95E8: 38A10098  addi r5, r1, 0x98
	ctx.r[5].s64 = ctx.r[1].s64 + 152;
	// 829F95EC: 38610208  addi r3, r1, 0x208
	ctx.r[3].s64 = ctx.r[1].s64 + 520;
	// 829F95F0: 809F0160  lwz r4, 0x160(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 829F95F4: 481B95D5  bl 0x82bb2bc8
	ctx.lr = 0x829F95F8;
	sub_82BB2BC8(ctx, base);
	// 829F95F8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829F95FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F9600: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F9604: 4BFF4965  bl 0x829edf68
	ctx.lr = 0x829F9608;
	sub_829EDF68(ctx, base);
	// 829F9608: 897E0060  lbz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 829F960C: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829F9610: 396B0009  addi r11, r11, 9
	ctx.r[11].s64 = ctx.r[11].s64 + 9;
	// 829F9614: 1D6B0003  mulli r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 * 3;
	// 829F9618: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 829F961C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F9620: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829F9624: 7C2BF42E  lfsx f1, r11, r30
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829F9628: 481BF449  bl 0x82bb8a70
	ctx.lr = 0x829F962C;
	sub_82BB8A70(ctx, base);
	// 829F962C: 8061020C  lwz r3, 0x20c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(524 as u32) ) } as u64;
	// 829F9630: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F9634: 419A0008  beq cr6, 0x829f963c
	if ctx.cr[6].eq {
	pc = 0x829F963C; continue 'dispatch;
	}
	// 829F9638: 4B8C7259  bl 0x822c0890
	ctx.lr = 0x829F963C;
	sub_822C0890(ctx, base);
	// 829F963C: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 829F9640: 483F9DE9  bl 0x82df3428
	ctx.lr = 0x829F9644;
	sub_82DF3428(ctx, base);
	// 829F9644: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 829F9648: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F964C: 4BFF4735  bl 0x829edd80
	ctx.lr = 0x829F9650;
	sub_829EDD80(ctx, base);
	// 829F9650: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829F9654: 807E0064  lwz r3, 0x64(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 829F9658: 484880E9  bl 0x82e81740
	ctx.lr = 0x829F965C;
	sub_82E81740(ctx, base);
	// 829F965C: 480008B0  b 0x829f9f0c
	pc = 0x829F9F0C; continue 'dispatch;
	// 829F9660: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F9664: 484600FD  bl 0x82e59760
	ctx.lr = 0x829F9668;
	sub_82E59760(ctx, base);
	// 829F9668: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F966C: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 829F9670: 4BFF48F9  bl 0x829edf68
	ctx.lr = 0x829F9674;
	sub_829EDF68(ctx, base);
	// 829F9674: 897E0060  lbz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 829F9678: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829F967C: 396B000E  addi r11, r11, 0xe
	ctx.r[11].s64 = ctx.r[11].s64 + 14;
	// 829F9680: 1D6B0003  mulli r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 * 3;
	// 829F9684: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 829F9688: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829F968C: 7C0BF42E  lfsx f0, r11, r30
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F9690: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 829F9694: 41980878  blt cr6, 0x829f9f0c
	if ctx.cr[6].lt {
	pc = 0x829F9F0C; continue 'dispatch;
	}
	// 829F9698: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F969C: 484600C5  bl 0x82e59760
	ctx.lr = 0x829F96A0;
	sub_82E59760(ctx, base);
	// 829F96A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F96A4: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 829F96A8: 4BFF48C1  bl 0x829edf68
	ctx.lr = 0x829F96AC;
	sub_829EDF68(ctx, base);
	// 829F96AC: 897E0060  lbz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 829F96B0: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829F96B4: 396B000E  addi r11, r11, 0xe
	ctx.r[11].s64 = ctx.r[11].s64 + 14;
	// 829F96B8: 1D6B0003  mulli r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 * 3;
	// 829F96BC: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 829F96C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F96C4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829F96C8: 7C0BF42E  lfsx f0, r11, r30
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F96CC: EC3F0028  fsubs f1, f31, f0
	ctx.f[1].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 829F96D0: 48428859  bl 0x82e21f28
	ctx.lr = 0x829F96D4;
	sub_82E21F28(ctx, base);
	// 829F96D4: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 829F96D8: 997E0060  stb r11, 0x60(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(96 as u32), ctx.r[11].u8 ) };
	// 829F96DC: 897E00E7  lbz r11, 0xe7(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(231 as u32) ) } as u64;
	// 829F96E0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829F96E4: 418200B4  beq 0x829f9798
	if ctx.cr[0].eq {
	pc = 0x829F9798; continue 'dispatch;
	}
	// 829F96E8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829F96EC: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 829F96F0: 3BAB6F30  addi r29, r11, 0x6f30
	ctx.r[29].s64 = ctx.r[11].s64 + 28464;
	// 829F96F4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829F96F8: 483FA311  bl 0x82df3a08
	ctx.lr = 0x829F96FC;
	sub_82DF3A08(ctx, base);
	// 829F96FC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 829F9700: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 829F9704: 809F0160  lwz r4, 0x160(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 829F9708: 386101B8  addi r3, r1, 0x1b8
	ctx.r[3].s64 = ctx.r[1].s64 + 440;
	// 829F970C: C04B6150  lfs f2, 0x6150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 829F9710: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 829F9714: 481B9C65  bl 0x82bb3378
	ctx.lr = 0x829F9718;
	sub_82BB3378(ctx, base);
	// 829F9718: 806101BC  lwz r3, 0x1bc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(444 as u32) ) } as u64;
	// 829F971C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F9720: 419A0008  beq cr6, 0x829f9728
	if ctx.cr[6].eq {
	pc = 0x829F9728; continue 'dispatch;
	}
	// 829F9724: 4B8C716D  bl 0x822c0890
	ctx.lr = 0x829F9728;
	sub_822C0890(ctx, base);
	// 829F9728: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 829F972C: 483F9CFD  bl 0x82df3428
	ctx.lr = 0x829F9730;
	sub_82DF3428(ctx, base);
	// 829F9730: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829F9734: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 829F9738: 483FA2D1  bl 0x82df3a08
	ctx.lr = 0x829F973C;
	sub_82DF3A08(ctx, base);
	// 829F973C: 38A10064  addi r5, r1, 0x64
	ctx.r[5].s64 = ctx.r[1].s64 + 100;
	// 829F9740: 38610238  addi r3, r1, 0x238
	ctx.r[3].s64 = ctx.r[1].s64 + 568;
	// 829F9744: 809F0160  lwz r4, 0x160(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 829F9748: 481B9481  bl 0x82bb2bc8
	ctx.lr = 0x829F974C;
	sub_82BB2BC8(ctx, base);
	// 829F974C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829F9750: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F9754: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F9758: 4BFF4811  bl 0x829edf68
	ctx.lr = 0x829F975C;
	sub_829EDF68(ctx, base);
	// 829F975C: 897E0060  lbz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 829F9760: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829F9764: 396B0009  addi r11, r11, 9
	ctx.r[11].s64 = ctx.r[11].s64 + 9;
	// 829F9768: 1D6B0003  mulli r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 * 3;
	// 829F976C: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 829F9770: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F9774: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829F9778: 7C2BF42E  lfsx f1, r11, r30
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829F977C: 481BF2F5  bl 0x82bb8a70
	ctx.lr = 0x829F9780;
	sub_82BB8A70(ctx, base);
	// 829F9780: 8061023C  lwz r3, 0x23c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(572 as u32) ) } as u64;
	// 829F9784: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F9788: 419A0008  beq cr6, 0x829f9790
	if ctx.cr[6].eq {
	pc = 0x829F9790; continue 'dispatch;
	}
	// 829F978C: 4B8C7105  bl 0x822c0890
	ctx.lr = 0x829F9790;
	sub_822C0890(ctx, base);
	// 829F9790: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 829F9794: 480000B0  b 0x829f9844
	pc = 0x829F9844; continue 'dispatch;
	// 829F9798: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829F979C: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 829F97A0: 3BAB6ED4  addi r29, r11, 0x6ed4
	ctx.r[29].s64 = ctx.r[11].s64 + 28372;
	// 829F97A4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829F97A8: 483FA261  bl 0x82df3a08
	ctx.lr = 0x829F97AC;
	sub_82DF3A08(ctx, base);
	// 829F97AC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 829F97B0: 38A1006C  addi r5, r1, 0x6c
	ctx.r[5].s64 = ctx.r[1].s64 + 108;
	// 829F97B4: 809F0160  lwz r4, 0x160(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 829F97B8: 386101C8  addi r3, r1, 0x1c8
	ctx.r[3].s64 = ctx.r[1].s64 + 456;
	// 829F97BC: C04B6150  lfs f2, 0x6150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 829F97C0: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 829F97C4: 481B9BB5  bl 0x82bb3378
	ctx.lr = 0x829F97C8;
	sub_82BB3378(ctx, base);
	// 829F97C8: 806101CC  lwz r3, 0x1cc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(460 as u32) ) } as u64;
	// 829F97CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F97D0: 419A0008  beq cr6, 0x829f97d8
	if ctx.cr[6].eq {
	pc = 0x829F97D8; continue 'dispatch;
	}
	// 829F97D4: 4B8C70BD  bl 0x822c0890
	ctx.lr = 0x829F97D8;
	sub_822C0890(ctx, base);
	// 829F97D8: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 829F97DC: 483F9C4D  bl 0x82df3428
	ctx.lr = 0x829F97E0;
	sub_82DF3428(ctx, base);
	// 829F97E0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829F97E4: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 829F97E8: 483FA221  bl 0x82df3a08
	ctx.lr = 0x829F97EC;
	sub_82DF3A08(ctx, base);
	// 829F97EC: 38A10074  addi r5, r1, 0x74
	ctx.r[5].s64 = ctx.r[1].s64 + 116;
	// 829F97F0: 38610218  addi r3, r1, 0x218
	ctx.r[3].s64 = ctx.r[1].s64 + 536;
	// 829F97F4: 809F0160  lwz r4, 0x160(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 829F97F8: 481B93D1  bl 0x82bb2bc8
	ctx.lr = 0x829F97FC;
	sub_82BB2BC8(ctx, base);
	// 829F97FC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829F9800: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F9804: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F9808: 4BFF4761  bl 0x829edf68
	ctx.lr = 0x829F980C;
	sub_829EDF68(ctx, base);
	// 829F980C: 897E0060  lbz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 829F9810: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829F9814: 396B0009  addi r11, r11, 9
	ctx.r[11].s64 = ctx.r[11].s64 + 9;
	// 829F9818: 1D6B0003  mulli r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 * 3;
	// 829F981C: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 829F9820: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F9824: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829F9828: 7C2BF42E  lfsx f1, r11, r30
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829F982C: 481BF245  bl 0x82bb8a70
	ctx.lr = 0x829F9830;
	sub_82BB8A70(ctx, base);
	// 829F9830: 8061021C  lwz r3, 0x21c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(540 as u32) ) } as u64;
	// 829F9834: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F9838: 419A0008  beq cr6, 0x829f9840
	if ctx.cr[6].eq {
	pc = 0x829F9840; continue 'dispatch;
	}
	// 829F983C: 4B8C7055  bl 0x822c0890
	ctx.lr = 0x829F9840;
	sub_822C0890(ctx, base);
	// 829F9840: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 829F9844: 483F9BE5  bl 0x82df3428
	ctx.lr = 0x829F9848;
	sub_82DF3428(ctx, base);
	// 829F9848: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 829F984C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F9850: 4BFF4531  bl 0x829edd80
	ctx.lr = 0x829F9854;
	sub_829EDD80(ctx, base);
	// 829F9854: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 829F9858: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F985C: 4BFF4505  bl 0x829edd60
	ctx.lr = 0x829F9860;
	sub_829EDD60(ctx, base);
	// 829F9860: 807E0064  lwz r3, 0x64(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 829F9864: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F9868: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 829F986C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829F9870: 4E800421  bctrl
	ctx.lr = 0x829F9874;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829F9874: 48000698  b 0x829f9f0c
	pc = 0x829F9F0C; continue 'dispatch;
	// 829F9878: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F987C: 4BFF46ED  bl 0x829edf68
	ctx.lr = 0x829F9880;
	sub_829EDF68(ctx, base);
	// 829F9880: 3963001B  addi r11, r3, 0x1b
	ctx.r[11].s64 = ctx.r[3].s64 + 27;
	// 829F9884: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 829F9888: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829F988C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F9890: C3CA9450  lfs f30, -0x6bb0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 829F9894: 7C0BF42E  lfsx f0, r11, r30
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F9898: EFFE0024  fdivs f31, f30, f0
	ctx.f[31].f64 = ((ctx.f[30].f64 / ctx.f[0].f64) as f32) as f64;
	// 829F989C: 4845FEC5  bl 0x82e59760
	ctx.lr = 0x829F98A0;
	sub_82E59760(ctx, base);
	// 829F98A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F98A4: FFA00890  fmr f29, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].f64 = ctx.f[1].f64;
	// 829F98A8: 4845FED1  bl 0x82e59778
	ctx.lr = 0x829F98AC;
	sub_82E59778(ctx, base);
	// 829F98AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F98B0: EFBD0828  fsubs f29, f29, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].f64 = (((ctx.f[29].f64 - ctx.f[1].f64) as f32) as f64);
	// 829F98B4: 4845FEAD  bl 0x82e59760
	ctx.lr = 0x829F98B8;
	sub_82E59760(ctx, base);
	// 829F98B8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829F98BC: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 829F98C0: FF1DF800  fcmpu cr6, f29, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[29].f64, ctx.f[31].f64);
	// 829F98C4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829F98C8: 3B6B7160  addi r27, r11, 0x7160
	ctx.r[27].s64 = ctx.r[11].s64 + 29024;
	// 829F98CC: C3AA08A8  lfs f29, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 829F98D0: C38908A4  lfs f28, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 829F98D4: 40980270  bge cr6, 0x829f9b44
	if !ctx.cr[6].lt {
	pc = 0x829F9B44; continue 'dispatch;
	}
	// 829F98D8: FF1F0800  fcmpu cr6, f31, f1
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[1].f64);
	// 829F98DC: 41990268  bgt cr6, 0x829f9b44
	if ctx.cr[6].gt {
	pc = 0x829F9B44; continue 'dispatch;
	}
	// 829F98E0: D3810100  stfs f28, 0x100(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 829F98E4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829F98E8: D3A10104  stfs f29, 0x104(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 829F98EC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829F98F0: D3810108  stfs f28, 0x108(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 829F98F4: 38A001DB  li r5, 0x1db
	ctx.r[5].s64 = 475;
	// 829F98F8: D381010C  stfs f28, 0x10c(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 829F98FC: 38600050  li r3, 0x50
	ctx.r[3].s64 = 80;
	// 829F9900: 483F8AE9  bl 0x82df23e8
	ctx.lr = 0x829F9904;
	sub_82DF23E8(ctx, base);
	// 829F9904: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829F9908: 41820028  beq 0x829f9930
	if ctx.cr[0].eq {
	pc = 0x829F9930; continue 'dispatch;
	}
	// 829F990C: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 829F9910: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 829F9914: 38E10100  addi r7, r1, 0x100
	ctx.r[7].s64 = ctx.r[1].s64 + 256;
	// 829F9918: 38C00006  li r6, 6
	ctx.r[6].s64 = 6;
	// 829F991C: C06B7BC8  lfs f3, 0x7bc8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31688 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 829F9920: FC201890  fmr f1, f3
	ctx.f[1].f64 = ctx.f[3].f64;
	// 829F9924: 48157B65  bl 0x82b51488
	ctx.lr = 0x829F9928;
	sub_82B51488(ctx, base);
	// 829F9928: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829F992C: 48000008  b 0x829f9934
	pc = 0x829F9934; continue 'dispatch;
	// 829F9930: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 829F9934: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 829F9938: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829F993C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829F9940: 4B9761D9  bl 0x8236fb18
	ctx.lr = 0x829F9944;
	sub_8236FB18(ctx, base);
	// 829F9944: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 829F9948: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829F994C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829F9950: 4B8C66B1  bl 0x822c0000
	ctx.lr = 0x829F9954;
	sub_822C0000(ctx, base);
	// 829F9954: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829F9958: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829F995C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829F9960: 93A100BC  stw r29, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[29].u32 ) };
	// 829F9964: 916100B8  stw r11, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[11].u32 ) };
	// 829F9968: 419A0024  beq cr6, 0x829f998c
	if ctx.cr[6].eq {
	pc = 0x829F998C; continue 'dispatch;
	}
	// 829F996C: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 829F9970: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829F9974: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F9978: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829F997C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829F9980: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829F9984: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F9988: 4082FFE8  bne 0x829f9970
	if !ctx.cr[0].eq {
	pc = 0x829F9970; continue 'dispatch;
	}
	// 829F998C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F9990: 386101D8  addi r3, r1, 0x1d8
	ctx.r[3].s64 = ctx.r[1].s64 + 472;
	// 829F9994: 4BB15B85  bl 0x8250f518
	ctx.lr = 0x829F9998;
	sub_8250F518(ctx, base);
	// 829F9998: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F999C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F99A0: 386BFF6C  addi r3, r11, -0x94
	ctx.r[3].s64 = ctx.r[11].s64 + -148;
	// 829F99A4: 409A0008  bne cr6, 0x829f99ac
	if !ctx.cr[6].eq {
	pc = 0x829F99AC; continue 'dispatch;
	}
	// 829F99A8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 829F99AC: 3B8100B8  addi r28, r1, 0xb8
	ctx.r[28].s64 = ctx.r[1].s64 + 184;
	// 829F99B0: 4BB2E6A1  bl 0x82528050
	ctx.lr = 0x829F99B4;
	sub_82528050(ctx, base);
	// 829F99B4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829F99B8: FC20E090  fmr f1, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[28].f64;
	// 829F99BC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829F99C0: 38A001E2  li r5, 0x1e2
	ctx.r[5].s64 = 482;
	// 829F99C4: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 829F99C8: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 829F99CC: 4845F075  bl 0x82e58a40
	ctx.lr = 0x829F99D0;
	sub_82E58A40(ctx, base);
	// 829F99D0: 386101D8  addi r3, r1, 0x1d8
	ctx.r[3].s64 = ctx.r[1].s64 + 472;
	// 829F99D4: 483F82BD  bl 0x82df1c90
	ctx.lr = 0x829F99D8;
	sub_82DF1C90(ctx, base);
	// 829F99D8: 806100BC  lwz r3, 0xbc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 829F99DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F99E0: 419A0008  beq cr6, 0x829f99e8
	if ctx.cr[6].eq {
	pc = 0x829F99E8; continue 'dispatch;
	}
	// 829F99E4: 4B8C6EAD  bl 0x822c0890
	ctx.lr = 0x829F99E8;
	sub_822C0890(ctx, base);
	// 829F99E8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829F99EC: 419A000C  beq cr6, 0x829f99f8
	if ctx.cr[6].eq {
	pc = 0x829F99F8; continue 'dispatch;
	}
	// 829F99F0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F99F4: 4B8C6E9D  bl 0x822c0890
	ctx.lr = 0x829F99F8;
	sub_822C0890(ctx, base);
	// 829F99F8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 829F99FC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829F9A00: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 829F9A04: 808B1674  lwz r4, 0x1674(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5748 as u32) ) } as u64;
	// 829F9A08: 483F81F1  bl 0x82df1bf8
	ctx.lr = 0x829F9A0C;
	sub_82DF1BF8(ctx, base);
	// 829F9A0C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829F9A10: 386101F0  addi r3, r1, 0x1f0
	ctx.r[3].s64 = ctx.r[1].s64 + 496;
	// 829F9A14: 388B13BC  addi r4, r11, 0x13bc
	ctx.r[4].s64 = ctx.r[11].s64 + 5052;
	// 829F9A18: 83A100E8  lwz r29, 0xe8(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(232 as u32) ) } as u64;
	// 829F9A1C: 483FFB15  bl 0x82df9530
	ctx.lr = 0x829F9A20;
	sub_82DF9530(ctx, base);
	// 829F9A20: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829F9A24: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 829F9A28: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F9A2C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F9A30: 4BB2CA21  bl 0x82526450
	ctx.lr = 0x829F9A34;
	sub_82526450(ctx, base);
	// 829F9A34: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 829F9A38: 483F8259  bl 0x82df1c90
	ctx.lr = 0x829F9A3C;
	sub_82DF1C90(ctx, base);
	// 829F9A3C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829F9A40: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829F9A44: 38A001EC  li r5, 0x1ec
	ctx.r[5].s64 = 492;
	// 829F9A48: 38600110  li r3, 0x110
	ctx.r[3].s64 = 272;
	// 829F9A4C: 483F899D  bl 0x82df23e8
	ctx.lr = 0x829F9A50;
	sub_82DF23E8(ctx, base);
	// 829F9A50: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 829F9A54: 41820030  beq 0x829f9a84
	if ctx.cr[0].eq {
	pc = 0x829F9A84; continue 'dispatch;
	}
	// 829F9A58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F9A5C: 4BB180FD  bl 0x82511b58
	ctx.lr = 0x829F9A60;
	sub_82511B58(ctx, base);
	// 829F9A60: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 829F9A64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F9A68: 4BB18081  bl 0x82511ae8
	ctx.lr = 0x829F9A6C;
	sub_82511AE8(ctx, base);
	// 829F9A6C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829F9A70: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F9A74: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 829F9A78: 4BFFDE21  bl 0x829f7898
	ctx.lr = 0x829F9A7C;
	sub_829F7898(ctx, base);
	// 829F9A7C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829F9A80: 48000008  b 0x829f9a88
	pc = 0x829F9A88; continue 'dispatch;
	// 829F9A84: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 829F9A88: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 829F9A8C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829F9A90: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829F9A94: 4BFFDBAD  bl 0x829f7640
	ctx.lr = 0x829F9A98;
	sub_829F7640(ctx, base);
	// 829F9A98: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 829F9A9C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829F9AA0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829F9AA4: 4B8C655D  bl 0x822c0000
	ctx.lr = 0x829F9AA8;
	sub_822C0000(ctx, base);
	// 829F9AA8: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829F9AAC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829F9AB0: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829F9AB4: 938100FC  stw r28, 0xfc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(252 as u32), ctx.r[28].u32 ) };
	// 829F9AB8: 916100F8  stw r11, 0xf8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), ctx.r[11].u32 ) };
	// 829F9ABC: 419A0024  beq cr6, 0x829f9ae0
	if ctx.cr[6].eq {
	pc = 0x829F9AE0; continue 'dispatch;
	}
	// 829F9AC0: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 829F9AC4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829F9AC8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F9ACC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829F9AD0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829F9AD4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829F9AD8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F9ADC: 4082FFE8  bne 0x829f9ac4
	if !ctx.cr[0].eq {
	pc = 0x829F9AC4; continue 'dispatch;
	}
	// 829F9AE0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F9AE4: 38610158  addi r3, r1, 0x158
	ctx.r[3].s64 = ctx.r[1].s64 + 344;
	// 829F9AE8: 4BB159E1  bl 0x8250f4c8
	ctx.lr = 0x829F9AEC;
	sub_8250F4C8(ctx, base);
	// 829F9AEC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F9AF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F9AF4: 3BABFFFC  addi r29, r11, -4
	ctx.r[29].s64 = ctx.r[11].s64 + -4;
	// 829F9AF8: 409A0008  bne cr6, 0x829f9b00
	if !ctx.cr[6].eq {
	pc = 0x829F9B00; continue 'dispatch;
	}
	// 829F9AFC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 829F9B00: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F9B04: 38610160  addi r3, r1, 0x160
	ctx.r[3].s64 = ctx.r[1].s64 + 352;
	// 829F9B08: 3B4100F8  addi r26, r1, 0xf8
	ctx.r[26].s64 = ctx.r[1].s64 + 248;
	// 829F9B0C: 4BB15A0D  bl 0x8250f518
	ctx.lr = 0x829F9B10;
	sub_8250F518(ctx, base);
	// 829F9B10: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829F9B14: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F9B18: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 829F9B1C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829F9B20: 4BB139E9  bl 0x8250d508
	ctx.lr = 0x829F9B24;
	sub_8250D508(ctx, base);
	// 829F9B24: 38610158  addi r3, r1, 0x158
	ctx.r[3].s64 = ctx.r[1].s64 + 344;
	// 829F9B28: 483F8169  bl 0x82df1c90
	ctx.lr = 0x829F9B2C;
	sub_82DF1C90(ctx, base);
	// 829F9B2C: 38610160  addi r3, r1, 0x160
	ctx.r[3].s64 = ctx.r[1].s64 + 352;
	// 829F9B30: 483F8161  bl 0x82df1c90
	ctx.lr = 0x829F9B34;
	sub_82DF1C90(ctx, base);
	// 829F9B34: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829F9B38: 419A000C  beq cr6, 0x829f9b44
	if ctx.cr[6].eq {
	pc = 0x829F9B44; continue 'dispatch;
	}
	// 829F9B3C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829F9B40: 4B8C6D51  bl 0x822c0890
	ctx.lr = 0x829F9B44;
	sub_822C0890(ctx, base);
	// 829F9B44: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F9B48: 4845FC19  bl 0x82e59760
	ctx.lr = 0x829F9B4C;
	sub_82E59760(ctx, base);
	// 829F9B4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F9B50: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 829F9B54: 4BFF4415  bl 0x829edf68
	ctx.lr = 0x829F9B58;
	sub_829EDF68(ctx, base);
	// 829F9B58: 897E0060  lbz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 829F9B5C: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829F9B60: 396B000E  addi r11, r11, 0xe
	ctx.r[11].s64 = ctx.r[11].s64 + 14;
	// 829F9B64: 1D6B0003  mulli r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 * 3;
	// 829F9B68: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 829F9B6C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829F9B70: 7C0BF42E  lfsx f0, r11, r30
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F9B74: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 829F9B78: 41980394  blt cr6, 0x829f9f0c
	if ctx.cr[6].lt {
	pc = 0x829F9F0C; continue 'dispatch;
	}
	// 829F9B7C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F9B80: 4845FBE1  bl 0x82e59760
	ctx.lr = 0x829F9B84;
	sub_82E59760(ctx, base);
	// 829F9B84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F9B88: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 829F9B8C: 4BFF43DD  bl 0x829edf68
	ctx.lr = 0x829F9B90;
	sub_829EDF68(ctx, base);
	// 829F9B90: 897E0060  lbz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 829F9B94: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829F9B98: 396B000E  addi r11, r11, 0xe
	ctx.r[11].s64 = ctx.r[11].s64 + 14;
	// 829F9B9C: 1D6B0003  mulli r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 * 3;
	// 829F9BA0: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 829F9BA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F9BA8: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829F9BAC: 7C0BF42E  lfsx f0, r11, r30
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F9BB0: EC3F0028  fsubs f1, f31, f0
	ctx.f[1].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 829F9BB4: 48428375  bl 0x82e21f28
	ctx.lr = 0x829F9BB8;
	sub_82E21F28(ctx, base);
	// 829F9BB8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F9BBC: 997E0060  stb r11, 0x60(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(96 as u32), ctx.r[11].u8 ) };
	// 829F9BC0: 897E00E7  lbz r11, 0xe7(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(231 as u32) ) } as u64;
	// 829F9BC4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829F9BC8: 418200BC  beq 0x829f9c84
	if ctx.cr[0].eq {
	pc = 0x829F9C84; continue 'dispatch;
	}
	// 829F9BCC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829F9BD0: 3861007C  addi r3, r1, 0x7c
	ctx.r[3].s64 = ctx.r[1].s64 + 124;
	// 829F9BD4: 3BAB6E88  addi r29, r11, 0x6e88
	ctx.r[29].s64 = ctx.r[11].s64 + 28296;
	// 829F9BD8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829F9BDC: 483F9E2D  bl 0x82df3a08
	ctx.lr = 0x829F9BE0;
	sub_82DF3A08(ctx, base);
	// 829F9BE0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 829F9BE4: 38A1007C  addi r5, r1, 0x7c
	ctx.r[5].s64 = ctx.r[1].s64 + 124;
	// 829F9BE8: 809F0160  lwz r4, 0x160(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 829F9BEC: 396B6150  addi r11, r11, 0x6150
	ctx.r[11].s64 = ctx.r[11].s64 + 24912;
	// 829F9BF0: 38610170  addi r3, r1, 0x170
	ctx.r[3].s64 = ctx.r[1].s64 + 368;
	// 829F9BF4: C3EB0000  lfs f31, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829F9BF8: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 829F9BFC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829F9C00: 481B9779  bl 0x82bb3378
	ctx.lr = 0x829F9C04;
	sub_82BB3378(ctx, base);
	// 829F9C04: 80610174  lwz r3, 0x174(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(372 as u32) ) } as u64;
	// 829F9C08: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F9C0C: 419A0008  beq cr6, 0x829f9c14
	if ctx.cr[6].eq {
	pc = 0x829F9C14; continue 'dispatch;
	}
	// 829F9C10: 4B8C6C81  bl 0x822c0890
	ctx.lr = 0x829F9C14;
	sub_822C0890(ctx, base);
	// 829F9C14: 3861007C  addi r3, r1, 0x7c
	ctx.r[3].s64 = ctx.r[1].s64 + 124;
	// 829F9C18: 483F9811  bl 0x82df3428
	ctx.lr = 0x829F9C1C;
	sub_82DF3428(ctx, base);
	// 829F9C1C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829F9C20: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 829F9C24: 483F9DE5  bl 0x82df3a08
	ctx.lr = 0x829F9C28;
	sub_82DF3A08(ctx, base);
	// 829F9C28: 38A10084  addi r5, r1, 0x84
	ctx.r[5].s64 = ctx.r[1].s64 + 132;
	// 829F9C2C: 38610180  addi r3, r1, 0x180
	ctx.r[3].s64 = ctx.r[1].s64 + 384;
	// 829F9C30: 809F0160  lwz r4, 0x160(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 829F9C34: 481B8F95  bl 0x82bb2bc8
	ctx.lr = 0x829F9C38;
	sub_82BB2BC8(ctx, base);
	// 829F9C38: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829F9C3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F9C40: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F9C44: 4BFF4325  bl 0x829edf68
	ctx.lr = 0x829F9C48;
	sub_829EDF68(ctx, base);
	// 829F9C48: 897E0060  lbz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 829F9C4C: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829F9C50: 396B0009  addi r11, r11, 9
	ctx.r[11].s64 = ctx.r[11].s64 + 9;
	// 829F9C54: 1D6B0003  mulli r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 * 3;
	// 829F9C58: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 829F9C5C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F9C60: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829F9C64: 7C2BF42E  lfsx f1, r11, r30
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829F9C68: 481BEE09  bl 0x82bb8a70
	ctx.lr = 0x829F9C6C;
	sub_82BB8A70(ctx, base);
	// 829F9C6C: 80610184  lwz r3, 0x184(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(388 as u32) ) } as u64;
	// 829F9C70: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F9C74: 419A0008  beq cr6, 0x829f9c7c
	if ctx.cr[6].eq {
	pc = 0x829F9C7C; continue 'dispatch;
	}
	// 829F9C78: 4B8C6C19  bl 0x822c0890
	ctx.lr = 0x829F9C7C;
	sub_822C0890(ctx, base);
	// 829F9C7C: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 829F9C80: 480000B8  b 0x829f9d38
	pc = 0x829F9D38; continue 'dispatch;
	// 829F9C84: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829F9C88: 3861008C  addi r3, r1, 0x8c
	ctx.r[3].s64 = ctx.r[1].s64 + 140;
	// 829F9C8C: 3BAB6F04  addi r29, r11, 0x6f04
	ctx.r[29].s64 = ctx.r[11].s64 + 28420;
	// 829F9C90: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829F9C94: 483F9D75  bl 0x82df3a08
	ctx.lr = 0x829F9C98;
	sub_82DF3A08(ctx, base);
	// 829F9C98: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 829F9C9C: 38A1008C  addi r5, r1, 0x8c
	ctx.r[5].s64 = ctx.r[1].s64 + 140;
	// 829F9CA0: 809F0160  lwz r4, 0x160(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 829F9CA4: 396B6150  addi r11, r11, 0x6150
	ctx.r[11].s64 = ctx.r[11].s64 + 24912;
	// 829F9CA8: 38610190  addi r3, r1, 0x190
	ctx.r[3].s64 = ctx.r[1].s64 + 400;
	// 829F9CAC: C3EB0000  lfs f31, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829F9CB0: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 829F9CB4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829F9CB8: 481B96C1  bl 0x82bb3378
	ctx.lr = 0x829F9CBC;
	sub_82BB3378(ctx, base);
	// 829F9CBC: 80610194  lwz r3, 0x194(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(404 as u32) ) } as u64;
	// 829F9CC0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F9CC4: 419A0008  beq cr6, 0x829f9ccc
	if ctx.cr[6].eq {
	pc = 0x829F9CCC; continue 'dispatch;
	}
	// 829F9CC8: 4B8C6BC9  bl 0x822c0890
	ctx.lr = 0x829F9CCC;
	sub_822C0890(ctx, base);
	// 829F9CCC: 3861008C  addi r3, r1, 0x8c
	ctx.r[3].s64 = ctx.r[1].s64 + 140;
	// 829F9CD0: 483F9759  bl 0x82df3428
	ctx.lr = 0x829F9CD4;
	sub_82DF3428(ctx, base);
	// 829F9CD4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829F9CD8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829F9CDC: 483F9D2D  bl 0x82df3a08
	ctx.lr = 0x829F9CE0;
	sub_82DF3A08(ctx, base);
	// 829F9CE0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 829F9CE4: 386101A0  addi r3, r1, 0x1a0
	ctx.r[3].s64 = ctx.r[1].s64 + 416;
	// 829F9CE8: 809F0160  lwz r4, 0x160(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 829F9CEC: 481B8EDD  bl 0x82bb2bc8
	ctx.lr = 0x829F9CF0;
	sub_82BB2BC8(ctx, base);
	// 829F9CF0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829F9CF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F9CF8: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F9CFC: 4BFF426D  bl 0x829edf68
	ctx.lr = 0x829F9D00;
	sub_829EDF68(ctx, base);
	// 829F9D00: 897E0060  lbz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 829F9D04: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829F9D08: 396B0009  addi r11, r11, 9
	ctx.r[11].s64 = ctx.r[11].s64 + 9;
	// 829F9D0C: 1D6B0003  mulli r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 * 3;
	// 829F9D10: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 829F9D14: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F9D18: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829F9D1C: 7C2BF42E  lfsx f1, r11, r30
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829F9D20: 481BED51  bl 0x82bb8a70
	ctx.lr = 0x829F9D24;
	sub_82BB8A70(ctx, base);
	// 829F9D24: 806101A4  lwz r3, 0x1a4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(420 as u32) ) } as u64;
	// 829F9D28: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F9D2C: 419A0008  beq cr6, 0x829f9d34
	if ctx.cr[6].eq {
	pc = 0x829F9D34; continue 'dispatch;
	}
	// 829F9D30: 4B8C6B61  bl 0x822c0890
	ctx.lr = 0x829F9D34;
	sub_822C0890(ctx, base);
	// 829F9D34: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829F9D38: 483F96F1  bl 0x82df3428
	ctx.lr = 0x829F9D3C;
	sub_82DF3428(ctx, base);
	// 829F9D3C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 829F9D40: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 829F9D44: D3E10050  stfs f31, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 829F9D48: 396B6880  addi r11, r11, 0x6880
	ctx.r[11].s64 = ctx.r[11].s64 + 26752;
	// 829F9D4C: D3C100A0  stfs f30, 0xa0(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 829F9D50: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 829F9D54: FC60E890  fmr f3, f29
	ctx.f[3].f64 = ctx.f[29].f64;
	// 829F9D58: 39000030  li r8, 0x30
	ctx.r[8].s64 = 48;
	// 829F9D5C: 38E10250  addi r7, r1, 0x250
	ctx.r[7].s64 = ctx.r[1].s64 + 592;
	// 829F9D60: 38C10260  addi r6, r1, 0x260
	ctx.r[6].s64 = ctx.r[1].s64 + 608;
	// 829F9D64: 38A10270  addi r5, r1, 0x270
	ctx.r[5].s64 = ctx.r[1].s64 + 624;
	// 829F9D68: 13CA5C07  vcmpneb. (lvlx128) v30, v10, v11
	tmp.u32 = ctx.r[10].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829F9D6C: 38810280  addi r4, r1, 0x280
	ctx.r[4].s64 = ctx.r[1].s64 + 640;
	// 829F9D70: 13E05C07  vcmpneb. (lvlx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829F9D74: 13A95C07  vcmpneb. (lvlx128) v29, v9, v11
	tmp.u32 = ctx.r[9].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829F9D78: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829F9D7C: 13885C07  vcmpneb. (lvlx128) v28, v8, v11
	tmp.u32 = ctx.r[8].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829F9D80: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F9F30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829F9F30 size=232
    let mut pc: u32 = 0x829F9F30;
    'dispatch: loop {
        match pc {
            0x829F9F30 => {
    //   block [0x829F9F30..0x829FA018)
	// 829F9F30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F9F34: 487AE239  bl 0x831a816c
	ctx.lr = 0x829F9F38;
	sub_831A8130(ctx, base);
	// 829F9F38: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F9F3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F9F40: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829F9F44: 4875A6BD  bl 0x83154600
	ctx.lr = 0x829F9F48;
	sub_83154600(ctx, base);
	// 829F9F48: 897F0060  lbz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 829F9F4C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F9F50: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 829F9F54: 409A00BC  bne cr6, 0x829fa010
	if !ctx.cr[6].eq {
	pc = 0x829FA010; continue 'dispatch;
	}
	// 829F9F58: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 829F9F5C: 39400064  li r10, 0x64
	ctx.r[10].s64 = 100;
	// 829F9F60: 3BAB6910  addi r29, r11, 0x6910
	ctx.r[29].s64 = ctx.r[11].s64 + 26896;
	// 829F9F64: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829F9F68: 4BB17B81  bl 0x82511ae8
	ctx.lr = 0x829F9F6C;
	sub_82511AE8(ctx, base);
	// 829F9F6C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 829F9F70: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829F9F74: 388B8614  addi r4, r11, -0x79ec
	ctx.r[4].s64 = ctx.r[11].s64 + -31212;
	// 829F9F78: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829F9F7C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829F9F80: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 829F9F84: 4BA1D43D  bl 0x824173c0
	ctx.lr = 0x829F9F88;
	sub_824173C0(ctx, base);
	// 829F9F88: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F9F8C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829F9F90: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F9F94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F9F98: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 829F9F9C: 419A0024  beq cr6, 0x829f9fc0
	if ctx.cr[6].eq {
	pc = 0x829F9FC0; continue 'dispatch;
	}
	// 829F9FA0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829F9FA4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829F9FA8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F9FAC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829F9FB0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829F9FB4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829F9FB8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F9FBC: 4082FFE8  bne 0x829f9fa4
	if !ctx.cr[0].eq {
	pc = 0x829F9FA4; continue 'dispatch;
	}
	// 829F9FC0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F9FC4: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 829F9FC8: 4860E161  bl 0x83008128
	ctx.lr = 0x829F9FCC;
	sub_83008128(ctx, base);
	// 829F9FCC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829F9FD0: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829F9FD4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829F9FD8: 388A7160  addi r4, r10, 0x7160
	ctx.r[4].s64 = ctx.r[10].s64 + 29024;
	// 829F9FDC: 38A002E6  li r5, 0x2e6
	ctx.r[5].s64 = 742;
	// 829F9FE0: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 829F9FE4: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829F9FE8: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 829F9FEC: 4845EA55  bl 0x82e58a40
	ctx.lr = 0x829F9FF0;
	sub_82E58A40(ctx, base);
	// 829F9FF0: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829F9FF4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F9FF8: 419A0008  beq cr6, 0x829fa000
	if ctx.cr[6].eq {
	pc = 0x829FA000; continue 'dispatch;
	}
	// 829F9FFC: 4B8C6895  bl 0x822c0890
	ctx.lr = 0x829FA000;
	sub_822C0890(ctx, base);
	// 829FA000: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829FA004: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FA008: 419A0008  beq cr6, 0x829fa010
	if ctx.cr[6].eq {
	pc = 0x829FA010; continue 'dispatch;
	}
	// 829FA00C: 4B8C6885  bl 0x822c0890
	ctx.lr = 0x829FA010;
	sub_822C0890(ctx, base);
	// 829FA010: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 829FA014: 487AE1A8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FA018(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829FA018 size=984
    let mut pc: u32 = 0x829FA018;
    'dispatch: loop {
        match pc {
            0x829FA018 => {
    //   block [0x829FA018..0x829FA3F0)
	// 829FA018: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FA01C: 487AE149  bl 0x831a8164
	ctx.lr = 0x829FA020;
	sub_831A8130(ctx, base);
	// 829FA020: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 829FA024: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FA028: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FA02C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 829FA030: 4875A5D1  bl 0x83154600
	ctx.lr = 0x829FA034;
	sub_83154600(ctx, base);
	// 829FA034: 897F0060  lbz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 829FA038: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829FA03C: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 829FA040: 409A03A4  bne cr6, 0x829fa3e4
	if !ctx.cr[6].eq {
	pc = 0x829FA3E4; continue 'dispatch;
	}
	// 829FA044: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 829FA048: 39400064  li r10, 0x64
	ctx.r[10].s64 = 100;
	// 829FA04C: 3BEB6910  addi r31, r11, 0x6910
	ctx.r[31].s64 = ctx.r[11].s64 + 26896;
	// 829FA050: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829FA054: 4BB17A95  bl 0x82511ae8
	ctx.lr = 0x829FA058;
	sub_82511AE8(ctx, base);
	// 829FA058: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 829FA05C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829FA060: 388B8614  addi r4, r11, -0x79ec
	ctx.r[4].s64 = ctx.r[11].s64 + -31212;
	// 829FA064: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829FA068: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 829FA06C: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 829FA070: 4BA1D351  bl 0x824173c0
	ctx.lr = 0x829FA074;
	sub_824173C0(ctx, base);
	// 829FA074: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FA078: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 829FA07C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FA080: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FA084: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 829FA088: 419A0024  beq cr6, 0x829fa0ac
	if ctx.cr[6].eq {
	pc = 0x829FA0AC; continue 'dispatch;
	}
	// 829FA08C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829FA090: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829FA094: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829FA098: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829FA09C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829FA0A0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829FA0A4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829FA0A8: 4082FFE8  bne 0x829fa090
	if !ctx.cr[0].eq {
	pc = 0x829FA090; continue 'dispatch;
	}
	// 829FA0AC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829FA0B0: 3BFD0028  addi r31, r29, 0x28
	ctx.r[31].s64 = ctx.r[29].s64 + 40;
	// 829FA0B4: 3B610060  addi r27, r1, 0x60
	ctx.r[27].s64 = ctx.r[1].s64 + 96;
	// 829FA0B8: 4860E071  bl 0x83008128
	ctx.lr = 0x829FA0BC;
	sub_83008128(ctx, base);
	// 829FA0BC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FA0C0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829FA0C4: 3BCB7160  addi r30, r11, 0x7160
	ctx.r[30].s64 = ctx.r[11].s64 + 29024;
	// 829FA0C8: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829FA0CC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829FA0D0: 38A002FC  li r5, 0x2fc
	ctx.r[5].s64 = 764;
	// 829FA0D4: C3EA08A4  lfs f31, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829FA0D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FA0DC: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 829FA0E0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829FA0E4: 4845E95D  bl 0x82e58a40
	ctx.lr = 0x829FA0E8;
	sub_82E58A40(ctx, base);
	// 829FA0E8: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829FA0EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FA0F0: 419A0008  beq cr6, 0x829fa0f8
	if ctx.cr[6].eq {
	pc = 0x829FA0F8; continue 'dispatch;
	}
	// 829FA0F4: 4B8C679D  bl 0x822c0890
	ctx.lr = 0x829FA0F8;
	sub_822C0890(ctx, base);
	// 829FA0F8: 806100CC  lwz r3, 0xcc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 829FA0FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FA100: 419A0008  beq cr6, 0x829fa108
	if ctx.cr[6].eq {
	pc = 0x829FA108; continue 'dispatch;
	}
	// 829FA104: 4B8C678D  bl 0x822c0890
	ctx.lr = 0x829FA108;
	sub_822C0890(ctx, base);
	// 829FA108: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829FA10C: 4BB179DD  bl 0x82511ae8
	ctx.lr = 0x829FA110;
	sub_82511AE8(ctx, base);
	// 829FA110: 39600320  li r11, 0x320
	ctx.r[11].s64 = 800;
	// 829FA114: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 829FA118: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829FA11C: 394100D0  addi r10, r1, 0xd0
	ctx.r[10].s64 = ctx.r[1].s64 + 208;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FA3F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FA3F0 size=220
    let mut pc: u32 = 0x829FA3F0;
    'dispatch: loop {
        match pc {
            0x829FA3F0 => {
    //   block [0x829FA3F0..0x829FA4CC)
	// 829FA3F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FA3F4: 487ADD75  bl 0x831a8168
	ctx.lr = 0x829FA3F8;
	sub_831A8130(ctx, base);
	// 829FA3F8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FA3FC: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 829FA400: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829FA404: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829FA408: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 829FA40C: 41820038  beq 0x829fa444
	if ctx.cr[0].eq {
	pc = 0x829FA444; continue 'dispatch;
	}
	// 829FA410: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FA414: 487AF575  bl 0x831a9988
	ctx.lr = 0x829FA418;
	sub_831A9988(ctx, base);
	// 829FA418: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 829FA41C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829FA420: 386B7660  addi r3, r11, 0x7660
	ctx.r[3].s64 = ctx.r[11].s64 + 30304;
	// 829FA424: 487ADCD5  bl 0x831a80f8
	ctx.lr = 0x829FA428;
	sub_831A80F8(ctx, base);
	// 829FA428: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829FA42C: 41820018  beq 0x829fa444
	if ctx.cr[0].eq {
	pc = 0x829FA444; continue 'dispatch;
	}
	// 829FA430: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829FA434: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FA438: 4BFFFAF9  bl 0x829f9f30
	ctx.lr = 0x829FA43C;
	sub_829F9F30(ctx, base);
	// 829FA43C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 829FA440: 48000084  b 0x829fa4c4
	pc = 0x829FA4C4; continue 'dispatch;
	// 829FA444: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829FA448: 419A006C  beq cr6, 0x829fa4b4
	if ctx.cr[6].eq {
	pc = 0x829FA4B4; continue 'dispatch;
	}
	// 829FA44C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FA450: 487AF539  bl 0x831a9988
	ctx.lr = 0x829FA454;
	sub_831A9988(ctx, base);
	// 829FA454: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 829FA458: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829FA45C: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 829FA460: 487ADC99  bl 0x831a80f8
	ctx.lr = 0x829FA464;
	sub_831A80F8(ctx, base);
	// 829FA464: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829FA468: 41820014  beq 0x829fa47c
	if ctx.cr[0].eq {
	pc = 0x829FA47C; continue 'dispatch;
	}
	// 829FA46C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829FA470: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FA474: 4BFFFBA5  bl 0x829fa018
	ctx.lr = 0x829FA478;
	sub_829FA018(ctx, base);
	// 829FA478: 4BFFFFC4  b 0x829fa43c
	pc = 0x829FA43C; continue 'dispatch;
	// 829FA47C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829FA480: 419A0034  beq cr6, 0x829fa4b4
	if ctx.cr[6].eq {
	pc = 0x829FA4B4; continue 'dispatch;
	}
	// 829FA484: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FA488: 487AF501  bl 0x831a9988
	ctx.lr = 0x829FA48C;
	sub_831A9988(ctx, base);
	// 829FA48C: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829FA490: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829FA494: 386BDFE0  addi r3, r11, -0x2020
	ctx.r[3].s64 = ctx.r[11].s64 + -8224;
	// 829FA498: 487ADC61  bl 0x831a80f8
	ctx.lr = 0x829FA49C;
	sub_831A80F8(ctx, base);
	// 829FA49C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829FA4A0: 41820014  beq 0x829fa4b4
	if ctx.cr[0].eq {
	pc = 0x829FA4B4; continue 'dispatch;
	}
	// 829FA4A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829FA4A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FA4AC: 4BFFD15D  bl 0x829f7608
	ctx.lr = 0x829FA4B0;
	sub_829F7608(ctx, base);
	// 829FA4B0: 4BFFFF8C  b 0x829fa43c
	pc = 0x829FA43C; continue 'dispatch;
	// 829FA4B4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 829FA4B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829FA4BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FA4C0: 48783FC9  bl 0x8317e488
	ctx.lr = 0x829FA4C4;
	sub_8317E488(ctx, base);
	// 829FA4C4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829FA4C8: 487ADCF0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FA4D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FA4D0 size=108
    let mut pc: u32 = 0x829FA4D0;
    'dispatch: loop {
        match pc {
            0x829FA4D0 => {
    //   block [0x829FA4D0..0x829FA53C)
	// 829FA4D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FA4D4: 487ADC99  bl 0x831a816c
	ctx.lr = 0x829FA4D8;
	sub_831A8130(ctx, base);
	// 829FA4D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FA4DC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 829FA4E0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829FA4E4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829FA4E8: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829FA4EC: 41820038  beq 0x829fa524
	if ctx.cr[0].eq {
	pc = 0x829FA524; continue 'dispatch;
	}
	// 829FA4F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FA4F4: 487AF495  bl 0x831a9988
	ctx.lr = 0x829FA4F8;
	sub_831A9988(ctx, base);
	// 829FA4F8: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 829FA4FC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829FA500: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 829FA504: 487ADBF5  bl 0x831a80f8
	ctx.lr = 0x829FA508;
	sub_831A80F8(ctx, base);
	// 829FA508: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829FA50C: 41820018  beq 0x829fa524
	if ctx.cr[0].eq {
	pc = 0x829FA524; continue 'dispatch;
	}
	// 829FA510: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829FA514: 387DFFD8  addi r3, r29, -0x28
	ctx.r[3].s64 = ctx.r[29].s64 + -40;
	// 829FA518: 4BFFDA71  bl 0x829f7f88
	ctx.lr = 0x829FA51C;
	sub_829F7F88(ctx, base);
	// 829FA51C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 829FA520: 48000014  b 0x829fa534
	pc = 0x829FA534; continue 'dispatch;
	// 829FA524: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829FA528: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829FA52C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829FA530: 4BB180E9  bl 0x82512618
	ctx.lr = 0x829FA534;
	sub_82512618(ctx, base);
	// 829FA534: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829FA538: 487ADC84  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FA540(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FA540 size=196
    let mut pc: u32 = 0x829FA540;
    'dispatch: loop {
        match pc {
            0x829FA540 => {
    //   block [0x829FA540..0x829FA604)
	// 829FA540: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FA544: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829FA548: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829FA54C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829FA550: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FA554: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829FA558: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829FA55C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829FA560: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829FA564: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829FA568: 4B8C63D1  bl 0x822c0938
	ctx.lr = 0x829FA56C;
	sub_822C0938(ctx, base);
	// 829FA56C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829FA570: 41820028  beq 0x829fa598
	if ctx.cr[0].eq {
	pc = 0x829FA598; continue 'dispatch;
	}
	// 829FA574: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FA578: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829FA57C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829FA580: 392B7248  addi r9, r11, 0x7248
	ctx.r[9].s64 = ctx.r[11].s64 + 29256;
	// 829FA584: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829FA588: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829FA58C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829FA590: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829FA594: 48000008  b 0x829fa59c
	pc = 0x829FA59C; continue 'dispatch;
	// 829FA598: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829FA59C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829FA5A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FA5A4: 409A0044  bne cr6, 0x829fa5e8
	if !ctx.cr[6].eq {
	pc = 0x829FA5E8; continue 'dispatch;
	}
	// 829FA5A8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829FA5AC: 419A001C  beq cr6, 0x829fa5c8
	if ctx.cr[6].eq {
	pc = 0x829FA5C8; continue 'dispatch;
	}
	// 829FA5B0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FA5B4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829FA5B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FA5BC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FA5C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829FA5C4: 4E800421  bctrl
	ctx.lr = 0x829FA5C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829FA5C8: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829FA5CC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829FA5D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FA5D4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829FA5D8: 816BE1B4  lwz r11, -0x1e4c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7756 as u32) ) } as u64;
	// 829FA5DC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829FA5E0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829FA5E4: 4B8C5A1D  bl 0x822c0000
	ctx.lr = 0x829FA5E8;
	sub_822C0000(ctx, base);
	// 829FA5E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FA5EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829FA5F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829FA5F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829FA5F8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829FA5FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829FA600: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FA608(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829FA608 size=92
    let mut pc: u32 = 0x829FA608;
    'dispatch: loop {
        match pc {
            0x829FA608 => {
    //   block [0x829FA608..0x829FA664)
	// 829FA608: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FA60C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829FA610: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829FA614: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FA618: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FA61C: 4BB17C45  bl 0x82512260
	ctx.lr = 0x829FA620;
	sub_82512260(ctx, base);
	// 829FA620: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829FA624: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829FA628: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 829FA62C: 394A7274  addi r10, r10, 0x7274
	ctx.r[10].s64 = ctx.r[10].s64 + 29300;
	// 829FA630: 3929725C  addi r9, r9, 0x725c
	ctx.r[9].s64 = ctx.r[9].s64 + 29276;
	// 829FA634: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 829FA638: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FA63C: D01F0100  stfs f0, 0x100(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 829FA640: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 829FA644: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 829FA648: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FA64C: 991F0104  stb r8, 0x104(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[8].u8 ) };
	// 829FA650: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829FA654: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829FA658: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829FA65C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829FA660: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FA668(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829FA668 size=8
    let mut pc: u32 = 0x829FA668;
    'dispatch: loop {
        match pc {
            0x829FA668 => {
    //   block [0x829FA668..0x829FA670)
	// 829FA668: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 829FA66C: 480000F4  b 0x829fa760
	sub_829FA760(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FA670(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829FA670 size=236
    let mut pc: u32 = 0x829FA670;
    'dispatch: loop {
        match pc {
            0x829FA670 => {
    //   block [0x829FA670..0x829FA75C)
	// 829FA670: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FA674: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829FA678: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829FA67C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FA680: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FA684: 484622A5  bl 0x82e5c928
	ctx.lr = 0x829FA688;
	sub_82E5C928(ctx, base);
	// 829FA688: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 829FA68C: 3D008203  lis r8, -0x7dfd
	ctx.r[8].s64 = -2113732608;
	// 829FA690: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FA694: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 829FA698: 38CB72B4  addi r6, r11, 0x72b4
	ctx.r[6].s64 = ctx.r[11].s64 + 29364;
	// 829FA69C: C1A908A8  lfs f13, 0x8a8(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829FA6A0: 3CE08209  lis r7, -0x7df7
	ctx.r[7].s64 = -2113339392;
	// 829FA6A4: C1887BC4  lfs f12, 0x7bc4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(31684 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829FA6A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829FA6AC: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 829FA6B0: 90DF0000  stw r6, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 829FA6B4: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 829FA6B8: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 829FA6BC: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 829FA6C0: C00A9450  lfs f0, -0x6bb0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FA6C4: C167ACFC  lfs f11, -0x5304(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-21252 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829FA6C8: 397F009C  addi r11, r31, 0x9c
	ctx.r[11].s64 = ctx.r[31].s64 + 156;
	// 829FA6CC: D1BF0070  stfs f13, 0x70(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 829FA6D0: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 829FA6D4: D19F0074  stfs f12, 0x74(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 829FA6D8: D1BF007C  stfs f13, 0x7c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 829FA6DC: D19F0080  stfs f12, 0x80(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 829FA6E0: D1BF008C  stfs f13, 0x8c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 829FA6E4: D1BF0094  stfs f13, 0x94(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 829FA6E8: D19F0098  stfs f12, 0x98(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 829FA6EC: C1899524  lfs f12, -0x6adc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829FA6F0: C1A8FD2C  lfs f13, -0x2d4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-724 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829FA6F4: D01F006C  stfs f0, 0x6c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 829FA6F8: D01F0078  stfs f0, 0x78(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 829FA6FC: D01F0084  stfs f0, 0x84(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 829FA700: D17F0088  stfs f11, 0x88(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 829FA704: D01F0090  stfs f0, 0x90(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 829FA708: C16BFFD0  lfs f11, -0x30(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-48 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829FA70C: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 829FA710: C14BFFDC  lfs f10, -0x24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-36 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 829FA714: ED6D5824  fdivs f11, f13, f11
	ctx.f[11].f64 = ((ctx.f[13].f64 / ctx.f[11].f64) as f32) as f64;
	// 829FA718: C12BFFE8  lfs f9, -0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 829FA71C: ED4D5024  fdivs f10, f13, f10
	ctx.f[10].f64 = ((ctx.f[13].f64 / ctx.f[10].f64) as f32) as f64;
	// 829FA720: C10BFFF4  lfs f8, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 829FA724: ED2C4824  fdivs f9, f12, f9
	ctx.f[9].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	// 829FA728: ED004024  fdivs f8, f0, f8
	ctx.f[8].f64 = ((ctx.f[0].f64 / ctx.f[8].f64) as f32) as f64;
	// 829FA72C: D16B0000  stfs f11, 0(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829FA730: D14B000C  stfs f10, 0xc(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829FA734: D12B0018  stfs f9, 0x18(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 829FA738: D10B0024  stfs f8, 0x24(r11)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 829FA73C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829FA740: 4082FFC8  bne 0x829fa708
	if !ctx.cr[0].eq {
	pc = 0x829FA708; continue 'dispatch;
	}
	// 829FA744: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FA748: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829FA74C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829FA750: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829FA754: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829FA758: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FA760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FA760 size=100
    let mut pc: u32 = 0x829FA760;
    'dispatch: loop {
        match pc {
            0x829FA760 => {
    //   block [0x829FA760..0x829FA7C4)
	// 829FA760: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FA764: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829FA768: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829FA76C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829FA770: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FA774: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FA778: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FA77C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829FA780: 396B7274  addi r11, r11, 0x7274
	ctx.r[11].s64 = ctx.r[11].s64 + 29300;
	// 829FA784: 394A725C  addi r10, r10, 0x725c
	ctx.r[10].s64 = ctx.r[10].s64 + 29276;
	// 829FA788: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829FA78C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829FA790: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 829FA794: 4B954BBD  bl 0x8234f350
	ctx.lr = 0x829FA798;
	sub_8234F350(ctx, base);
	// 829FA798: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829FA79C: 4182000C  beq 0x829fa7a8
	if ctx.cr[0].eq {
	pc = 0x829FA7A8; continue 'dispatch;
	}
	// 829FA7A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FA7A4: 483F7C35  bl 0x82df23d8
	ctx.lr = 0x829FA7A8;
	sub_82DF23D8(ctx, base);
	// 829FA7A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FA7AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829FA7B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829FA7B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829FA7B8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829FA7BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829FA7C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FA7C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829FA7C8 size=520
    let mut pc: u32 = 0x829FA7C8;
    'dispatch: loop {
        match pc {
            0x829FA7C8 => {
    //   block [0x829FA7C8..0x829FA9D0)
	// 829FA7C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FA7CC: 487AD9A1  bl 0x831a816c
	ctx.lr = 0x829FA7D0;
	sub_831A8130(ctx, base);
	// 829FA7D0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FA7D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FA7D8: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 829FA7DC: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 829FA7E0: 4BB171F9  bl 0x825119d8
	ctx.lr = 0x829FA7E4;
	sub_825119D8(ctx, base);
	// 829FA7E4: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 829FA7E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FA7EC: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 829FA7F0: 483F9219  bl 0x82df3a08
	ctx.lr = 0x829FA7F4;
	sub_82DF3A08(ctx, base);
	// 829FA7F4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829FA7F8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829FA7FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FA800: 4BB0DF81  bl 0x82508780
	ctx.lr = 0x829FA804;
	sub_82508780(ctx, base);
	// 829FA804: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FA808: 483F8C21  bl 0x82df3428
	ctx.lr = 0x829FA80C;
	sub_82DF3428(ctx, base);
	// 829FA80C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829FA810: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 829FA814: 409A0008  bne cr6, 0x829fa81c
	if !ctx.cr[6].eq {
	pc = 0x829FA81C; continue 'dispatch;
	}
	// 829FA818: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829FA81C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FA820: 4BB0DF81  bl 0x825087a0
	ctx.lr = 0x829FA824;
	sub_825087A0(ctx, base);
	// 829FA824: 397F00F0  addi r11, r31, 0xf0
	ctx.r[11].s64 = ctx.r[31].s64 + 240;
	// 829FA828: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829FA82C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 829FA830: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829FA834: 4B92299D  bl 0x8231d1d0
	ctx.lr = 0x829FA838;
	sub_8231D1D0(ctx, base);
	// 829FA838: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FA83C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829FA840: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FA844: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FA848: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 829FA84C: 419A0024  beq cr6, 0x829fa870
	if ctx.cr[6].eq {
	pc = 0x829FA870; continue 'dispatch;
	}
	// 829FA850: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829FA854: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829FA858: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829FA85C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829FA860: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829FA864: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829FA868: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829FA86C: 4082FFE8  bne 0x829fa854
	if !ctx.cr[0].eq {
	pc = 0x829FA854; continue 'dispatch;
	}
	// 829FA870: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829FA874: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829FA878: 4BB14C51  bl 0x8250f4c8
	ctx.lr = 0x829FA87C;
	sub_8250F4C8(ctx, base);
	// 829FA87C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FA880: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FA884: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 829FA888: 409A0008  bne cr6, 0x829fa890
	if !ctx.cr[6].eq {
	pc = 0x829FA890; continue 'dispatch;
	}
	// 829FA88C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 829FA890: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829FA894: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 829FA898: 4BB0E181  bl 0x82508a18
	ctx.lr = 0x829FA89C;
	sub_82508A18(ctx, base);
	// 829FA89C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FA8A0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829FA8A4: 388B7300  addi r4, r11, 0x7300
	ctx.r[4].s64 = ctx.r[11].s64 + 29440;
	// 829FA8A8: 38A0009C  li r5, 0x9c
	ctx.r[5].s64 = 156;
	// 829FA8AC: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 829FA8B0: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 829FA8B4: 4845C735  bl 0x82e56fe8
	ctx.lr = 0x829FA8B8;
	sub_82E56FE8(ctx, base);
	// 829FA8B8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829FA8BC: 483F73D5  bl 0x82df1c90
	ctx.lr = 0x829FA8C0;
	sub_82DF1C90(ctx, base);
	// 829FA8C0: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829FA8C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FA8C8: 419A0008  beq cr6, 0x829fa8d0
	if ctx.cr[6].eq {
	pc = 0x829FA8D0; continue 'dispatch;
	}
	// 829FA8CC: 4B8C5FC5  bl 0x822c0890
	ctx.lr = 0x829FA8D0;
	sub_822C0890(ctx, base);
	// 829FA8D0: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 829FA8D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FA8D8: 419A0008  beq cr6, 0x829fa8e0
	if ctx.cr[6].eq {
	pc = 0x829FA8E0; continue 'dispatch;
	}
	// 829FA8DC: 4B8C5FB5  bl 0x822c0890
	ctx.lr = 0x829FA8E0;
	sub_822C0890(ctx, base);
	// 829FA8E0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829FA8E4: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FA8E8: 48430201  bl 0x82e2aae8
	ctx.lr = 0x829FA8EC;
	sub_82E2AAE8(ctx, base);
	// 829FA8EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FA8F0: 4BB181A9  bl 0x82512a98
	ctx.lr = 0x829FA8F4;
	sub_82512A98(ctx, base);
	// 829FA8F4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FA8F8: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829FA8FC: 812D0000  lwz r9, 0(r13)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FA900: 396B72F0  addi r11, r11, 0x72f0
	ctx.r[11].s64 = ctx.r[11].s64 + 29424;
	// 829FA904: 394A7140  addi r10, r10, 0x7140
	ctx.r[10].s64 = ctx.r[10].s64 + 28992;
	// 829FA908: 39010090  addi r8, r1, 0x90
	ctx.r[8].s64 = ctx.r[1].s64 + 144;
	// 829FA90C: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
	// 829FA910: 38C00014  li r6, 0x14
	ctx.r[6].s64 = 20;
	// 829FA914: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829FA918: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 829FA91C: 13C050C7  vcmpequd (lvx128) v30, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829FA920: 38800040  li r4, 0x40
	ctx.r[4].s64 = 64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FA9D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829FA9D0 size=448
    let mut pc: u32 = 0x829FA9D0;
    'dispatch: loop {
        match pc {
            0x829FA9D0 => {
    //   block [0x829FA9D0..0x829FAB90)
	// 829FA9D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FA9D4: 487AD799  bl 0x831a816c
	ctx.lr = 0x829FA9D8;
	sub_831A8130(ctx, base);
	// 829FA9D8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FA9DC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829FA9E0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829FA9E4: 4BB15D25  bl 0x82510708
	ctx.lr = 0x829FA9E8;
	sub_82510708(ctx, base);
	// 829FA9E8: 397E00F0  addi r11, r30, 0xf0
	ctx.r[11].s64 = ctx.r[30].s64 + 240;
	// 829FA9EC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829FA9F0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 829FA9F4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829FA9F8: 4B9227D9  bl 0x8231d1d0
	ctx.lr = 0x829FA9FC;
	sub_8231D1D0(ctx, base);
	// 829FA9FC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FAA00: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829FAA04: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FAA08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FAA0C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 829FAA10: 419A0024  beq cr6, 0x829faa34
	if ctx.cr[6].eq {
	pc = 0x829FAA34; continue 'dispatch;
	}
	// 829FAA14: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829FAA18: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829FAA1C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829FAA20: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829FAA24: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829FAA28: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829FAA2C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829FAA30: 4082FFE8  bne 0x829faa18
	if !ctx.cr[0].eq {
	pc = 0x829FAA18; continue 'dispatch;
	}
	// 829FAA34: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829FAA38: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829FAA3C: 4BB14A8D  bl 0x8250f4c8
	ctx.lr = 0x829FAA40;
	sub_8250F4C8(ctx, base);
	// 829FAA40: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FAA44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FAA48: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 829FAA4C: 409A0008  bne cr6, 0x829faa54
	if !ctx.cr[6].eq {
	pc = 0x829FAA54; continue 'dispatch;
	}
	// 829FAA50: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 829FAA54: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829FAA58: 3BA10058  addi r29, r1, 0x58
	ctx.r[29].s64 = ctx.r[1].s64 + 88;
	// 829FAA5C: 4BB0DFBD  bl 0x82508a18
	ctx.lr = 0x829FAA60;
	sub_82508A18(ctx, base);
	// 829FAA60: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FAA64: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829FAA68: 388B7300  addi r4, r11, 0x7300
	ctx.r[4].s64 = ctx.r[11].s64 + 29440;
	// 829FAA6C: 38A000D6  li r5, 0xd6
	ctx.r[5].s64 = 214;
	// 829FAA70: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 829FAA74: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 829FAA78: 4845C571  bl 0x82e56fe8
	ctx.lr = 0x829FAA7C;
	sub_82E56FE8(ctx, base);
	// 829FAA7C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829FAA80: 483F7211  bl 0x82df1c90
	ctx.lr = 0x829FAA84;
	sub_82DF1C90(ctx, base);
	// 829FAA84: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829FAA88: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FAA8C: 419A0008  beq cr6, 0x829faa94
	if ctx.cr[6].eq {
	pc = 0x829FAA94; continue 'dispatch;
	}
	// 829FAA90: 4B8C5E01  bl 0x822c0890
	ctx.lr = 0x829FAA94;
	sub_822C0890(ctx, base);
	// 829FAA94: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 829FAA98: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FAA9C: 419A0008  beq cr6, 0x829faaa4
	if ctx.cr[6].eq {
	pc = 0x829FAAA4; continue 'dispatch;
	}
	// 829FAAA0: 4B8C5DF1  bl 0x822c0890
	ctx.lr = 0x829FAAA4;
	sub_822C0890(ctx, base);
	// 829FAAA4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 829FAAA8: C19E0100  lfs f12, 0x100(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(256 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829FAAAC: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FAAB0: EC00602A  fadds f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 829FAAB4: D01E0100  stfs f0, 0x100(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 829FAAB8: C1AB6150  lfs f13, 0x6150(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829FAABC: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 829FAAC0: 409800AC  bge cr6, 0x829fab6c
	if !ctx.cr[6].lt {
	pc = 0x829FAB6C; continue 'dispatch;
	}
	// 829FAAC4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 829FAAC8: 419800A4  blt cr6, 0x829fab6c
	if ctx.cr[6].lt {
	pc = 0x829FAB6C; continue 'dispatch;
	}
	// 829FAACC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FAAD0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FAAD4: 388B71AC  addi r4, r11, 0x71ac
	ctx.r[4].s64 = ctx.r[11].s64 + 29100;
	// 829FAAD8: 483F8F31  bl 0x82df3a08
	ctx.lr = 0x829FAADC;
	sub_82DF3A08(ctx, base);
	// 829FAADC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829FAAE0: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 829FAAE4: 4BB149E5  bl 0x8250f4c8
	ctx.lr = 0x829FAAE8;
	sub_8250F4C8(ctx, base);
	// 829FAAE8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FAAEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FAAF0: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 829FAAF4: 409A0008  bne cr6, 0x829faafc
	if !ctx.cr[6].eq {
	pc = 0x829FAAFC; continue 'dispatch;
	}
	// 829FAAF8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829FAAFC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829FAB00: 4BB0FE51  bl 0x8250a950
	ctx.lr = 0x829FAB04;
	sub_8250A950(ctx, base);
	// 829FAB04: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FAB08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FAB0C: 3BEBFF40  addi r31, r11, -0xc0
	ctx.r[31].s64 = ctx.r[11].s64 + -192;
	// 829FAB10: 409A0008  bne cr6, 0x829fab18
	if !ctx.cr[6].eq {
	pc = 0x829FAB18; continue 'dispatch;
	}
	// 829FAB14: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829FAB18: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829FAB1C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 829FAB20: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 829FAB24: 4BB175F5  bl 0x82512118
	ctx.lr = 0x829FAB28;
	sub_82512118(ctx, base);
	// 829FAB28: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829FAB2C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829FAB30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FAB34: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 829FAB38: 38C0000A  li r6, 0xa
	ctx.r[6].s64 = 10;
	// 829FAB3C: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829FAB40: 4BDD9661  bl 0x827d41a0
	ctx.lr = 0x829FAB44;
	sub_827D41A0(ctx, base);
	// 829FAB44: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829FAB48: 483F7149  bl 0x82df1c90
	ctx.lr = 0x829FAB4C;
	sub_82DF1C90(ctx, base);
	// 829FAB4C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 829FAB50: 483F7141  bl 0x82df1c90
	ctx.lr = 0x829FAB54;
	sub_82DF1C90(ctx, base);
	// 829FAB54: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 829FAB58: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FAB5C: 419A0008  beq cr6, 0x829fab64
	if ctx.cr[6].eq {
	pc = 0x829FAB64; continue 'dispatch;
	}
	// 829FAB60: 4B8C5D31  bl 0x822c0890
	ctx.lr = 0x829FAB64;
	sub_822C0890(ctx, base);
	// 829FAB64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FAB68: 483F88C1  bl 0x82df3428
	ctx.lr = 0x829FAB6C;
	sub_82DF3428(ctx, base);
	// 829FAB6C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829FAB70: C1BE0100  lfs f13, 0x100(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(256 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829FAB74: C00B0A90  lfs f0, 0xa90(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2704 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FAB78: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 829FAB7C: 4099000C  ble cr6, 0x829fab88
	if !ctx.cr[6].gt {
	pc = 0x829FAB88; continue 'dispatch;
	}
	// 829FAB80: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FAB84: 4BB15A4D  bl 0x825105d0
	ctx.lr = 0x829FAB88;
	sub_825105D0(ctx, base);
	// 829FAB88: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 829FAB8C: 487AD630  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FAB90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829FAB90 size=1212
    let mut pc: u32 = 0x829FAB90;
    'dispatch: loop {
        match pc {
            0x829FAB90 => {
    //   block [0x829FAB90..0x829FB04C)
	// 829FAB90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FAB94: 487AD5D5  bl 0x831a8168
	ctx.lr = 0x829FAB98;
	sub_831A8130(ctx, base);
	// 829FAB98: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 829FAB9C: 9421FEC0  stwu r1, -0x140(r1)
	ea = ctx.r[1].u32.wrapping_add(-320 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FABA0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FABA4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829FABA8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829FABAC: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 829FABB0: 4BB14919  bl 0x8250f4c8
	ctx.lr = 0x829FABB4;
	sub_8250F4C8(ctx, base);
	// 829FABB4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FABB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FABBC: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 829FABC0: 409A0008  bne cr6, 0x829fabc8
	if !ctx.cr[6].eq {
	pc = 0x829FABC8; continue 'dispatch;
	}
	// 829FABC4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 829FABC8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829FABCC: 4BB0DE4D  bl 0x82508a18
	ctx.lr = 0x829FABD0;
	sub_82508A18(ctx, base);
	// 829FABD0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829FABD4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FABD8: 4860D551  bl 0x83008128
	ctx.lr = 0x829FABDC;
	sub_83008128(ctx, base);
	// 829FABDC: 7D7D1850  subf r11, r29, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[29].s64;
	// 829FABE0: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 829FABE4: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 829FABE8: 557DDFFE  rlwinm r29, r11, 0x1b, 0x1f, 0x1f
	ctx.r[29].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 829FABEC: 483F70A5  bl 0x82df1c90
	ctx.lr = 0x829FABF0;
	sub_82DF1C90(ctx, base);
	// 829FABF0: 281D0000  cmplwi r29, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829FABF4: 41820390  beq 0x829faf84
	if ctx.cr[0].eq {
	pc = 0x829FAF84; continue 'dispatch;
	}
	// 829FABF8: 897F0104  lbz r11, 0x104(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) } as u64;
	// 829FABFC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829FAC00: 40820440  bne 0x829fb040
	if !ctx.cr[0].eq {
	pc = 0x829FB040; continue 'dispatch;
	}
	// 829FAC04: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829FAC08: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 829FAC0C: 997F0104  stb r11, 0x104(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[11].u8 ) };
	// 829FAC10: 39600064  li r11, 0x64
	ctx.r[11].s64 = 100;
	// 829FAC14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FAC18: 3BAA6910  addi r29, r10, 0x6910
	ctx.r[29].s64 = ctx.r[10].s64 + 26896;
	// 829FAC1C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 829FAC20: 4BB16EC9  bl 0x82511ae8
	ctx.lr = 0x829FAC24;
	sub_82511AE8(ctx, base);
	// 829FAC24: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 829FAC28: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829FAC2C: 388B8614  addi r4, r11, -0x79ec
	ctx.r[4].s64 = ctx.r[11].s64 + -31212;
	// 829FAC30: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829FAC34: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 829FAC38: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 829FAC3C: 4BA1C785  bl 0x824173c0
	ctx.lr = 0x829FAC40;
	sub_824173C0(ctx, base);
	// 829FAC40: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FAC44: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 829FAC48: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FAC4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FAC50: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 829FAC54: 419A0024  beq cr6, 0x829fac78
	if ctx.cr[6].eq {
	pc = 0x829FAC78; continue 'dispatch;
	}
	// 829FAC58: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829FAC5C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829FAC60: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829FAC64: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829FAC68: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829FAC6C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829FAC70: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829FAC74: 4082FFE8  bne 0x829fac5c
	if !ctx.cr[0].eq {
	pc = 0x829FAC5C; continue 'dispatch;
	}
	// 829FAC78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FAC7C: 3BDF0028  addi r30, r31, 0x28
	ctx.r[30].s64 = ctx.r[31].s64 + 40;
	// 829FAC80: 3B810068  addi r28, r1, 0x68
	ctx.r[28].s64 = ctx.r[1].s64 + 104;
	// 829FAC84: 4860D4A5  bl 0x83008128
	ctx.lr = 0x829FAC88;
	sub_83008128(ctx, base);
	// 829FAC88: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FAC8C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829FAC90: 3BAB7300  addi r29, r11, 0x7300
	ctx.r[29].s64 = ctx.r[11].s64 + 29440;
	// 829FAC94: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829FAC98: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829FAC9C: 38A000F5  li r5, 0xf5
	ctx.r[5].s64 = 245;
	// 829FACA0: C3EA08A4  lfs f31, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829FACA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FACA8: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 829FACAC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829FACB0: 4845DD91  bl 0x82e58a40
	ctx.lr = 0x829FACB4;
	sub_82E58A40(ctx, base);
	// 829FACB4: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 829FACB8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FACBC: 419A0008  beq cr6, 0x829facc4
	if ctx.cr[6].eq {
	pc = 0x829FACC4; continue 'dispatch;
	}
	// 829FACC0: 4B8C5BD1  bl 0x822c0890
	ctx.lr = 0x829FACC4;
	sub_822C0890(ctx, base);
	// 829FACC4: 806100BC  lwz r3, 0xbc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 829FACC8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FACCC: 419A0008  beq cr6, 0x829facd4
	if ctx.cr[6].eq {
	pc = 0x829FACD4; continue 'dispatch;
	}
	// 829FACD0: 4B8C5BC1  bl 0x822c0890
	ctx.lr = 0x829FACD4;
	sub_822C0890(ctx, base);
	// 829FACD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FACD8: 4BB16E11  bl 0x82511ae8
	ctx.lr = 0x829FACDC;
	sub_82511AE8(ctx, base);
	// 829FACDC: 396000F0  li r11, 0xf0
	ctx.r[11].s64 = 240;
	// 829FACE0: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 829FACE4: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829FACE8: 394100F0  addi r10, r1, 0xf0
	ctx.r[10].s64 = ctx.r[1].s64 + 240;
	// 829FACEC: D3E10094  stfs f31, 0x94(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 829FACF0: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FB050(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829FB050 size=624
    let mut pc: u32 = 0x829FB050;
    'dispatch: loop {
        match pc {
            0x829FB050 => {
    //   block [0x829FB050..0x829FB2C0)
	// 829FB050: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FB054: 487AD111  bl 0x831a8164
	ctx.lr = 0x829FB058;
	sub_831A8130(ctx, base);
	// 829FB058: DBC1FFC0  stfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 829FB05C: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 829FB060: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FB064: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FB068: 48759599  bl 0x83154600
	ctx.lr = 0x829FB06C;
	sub_83154600(ctx, base);
	// 829FB06C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829FB070: 3D208212  lis r9, -0x7dee
	ctx.r[9].s64 = -2112749568;
	// 829FB074: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829FB078: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829FB07C: 997F0060  stb r11, 0x60(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u8 ) };
	// 829FB080: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FB084: C3CA08A4  lfs f30, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 829FB088: 997F00CC  stb r11, 0xcc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), ctx.r[11].u8 ) };
	// 829FB08C: C009DFAC  lfs f0, -0x2054(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FB090: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 829FB094: D01E0398  stfs f0, 0x398(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(920 as u32), tmp.u32 ) };
	// 829FB098: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FB09C: 3BAB6F98  addi r29, r11, 0x6f98
	ctx.r[29].s64 = ctx.r[11].s64 + 28568;
	// 829FB0A0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829FB0A4: 483F8965  bl 0x82df3a08
	ctx.lr = 0x829FB0A8;
	sub_82DF3A08(ctx, base);
	// 829FB0A8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 829FB0AC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829FB0B0: 809E0160  lwz r4, 0x160(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(352 as u32) ) } as u64;
	// 829FB0B4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829FB0B8: C3EB6150  lfs f31, 0x6150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829FB0BC: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 829FB0C0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829FB0C4: 481B82B5  bl 0x82bb3378
	ctx.lr = 0x829FB0C8;
	sub_82BB3378(ctx, base);
	// 829FB0C8: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 829FB0CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FB0D0: 419A0008  beq cr6, 0x829fb0d8
	if ctx.cr[6].eq {
	pc = 0x829FB0D8; continue 'dispatch;
	}
	// 829FB0D4: 4B8C57BD  bl 0x822c0890
	ctx.lr = 0x829FB0D8;
	sub_822C0890(ctx, base);
	// 829FB0D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FB0DC: 483F834D  bl 0x82df3428
	ctx.lr = 0x829FB0E0;
	sub_82DF3428(ctx, base);
	// 829FB0E0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829FB0E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FB0E8: 483F8921  bl 0x82df3a08
	ctx.lr = 0x829FB0EC;
	sub_82DF3A08(ctx, base);
	// 829FB0EC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829FB0F0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829FB0F4: 809E0160  lwz r4, 0x160(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(352 as u32) ) } as u64;
	// 829FB0F8: 481B7AD1  bl 0x82bb2bc8
	ctx.lr = 0x829FB0FC;
	sub_82BB2BC8(ctx, base);
	// 829FB0FC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829FB100: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FB104: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FB108: 4BFF2E61  bl 0x829edf68
	ctx.lr = 0x829FB10C;
	sub_829EDF68(ctx, base);
	// 829FB10C: 897F0060  lbz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 829FB110: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829FB114: 396B0009  addi r11, r11, 9
	ctx.r[11].s64 = ctx.r[11].s64 + 9;
	// 829FB118: 1D6B0003  mulli r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 * 3;
	// 829FB11C: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 829FB120: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829FB124: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829FB128: 7C2BFC2E  lfsx f1, r11, r31
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829FB12C: 481BD945  bl 0x82bb8a70
	ctx.lr = 0x829FB130;
	sub_82BB8A70(ctx, base);
	// 829FB130: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 829FB134: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FB138: 419A0008  beq cr6, 0x829fb140
	if ctx.cr[6].eq {
	pc = 0x829FB140; continue 'dispatch;
	}
	// 829FB13C: 4B8C5755  bl 0x822c0890
	ctx.lr = 0x829FB140;
	sub_822C0890(ctx, base);
	// 829FB140: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FB144: 483F82E5  bl 0x82df3428
	ctx.lr = 0x829FB148;
	sub_82DF3428(ctx, base);
	// 829FB148: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 829FB14C: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 829FB150: D3E10058  stfs f31, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 829FB154: 396B6880  addi r11, r11, 0x6880
	ctx.r[11].s64 = ctx.r[11].s64 + 26752;
	// 829FB158: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 829FB15C: 39000030  li r8, 0x30
	ctx.r[8].s64 = 48;
	// 829FB160: 38E10090  addi r7, r1, 0x90
	ctx.r[7].s64 = ctx.r[1].s64 + 144;
	// 829FB164: 38C100A0  addi r6, r1, 0xa0
	ctx.r[6].s64 = ctx.r[1].s64 + 160;
	// 829FB168: 38A100B0  addi r5, r1, 0xb0
	ctx.r[5].s64 = ctx.r[1].s64 + 176;
	// 829FB16C: 13E05C07  vcmpneb. (lvlx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829FB170: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 829FB174: 13CA5C07  vcmpneb. (lvlx128) v30, v10, v11
	tmp.u32 = ctx.r[10].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829FB178: 13A95C07  vcmpneb. (lvlx128) v29, v9, v11
	tmp.u32 = ctx.r[9].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829FB17C: 3FE0820A  lis r31, -0x7df6
	ctx.r[31].s64 = -2113273856;
	// 829FB180: 13885C07  vcmpneb. (lvlx128) v28, v8, v11
	tmp.u32 = ctx.r[8].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829FB184: 3F808209  lis r28, -0x7df7
	ctx.r[28].s64 = -2113339392;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FB2C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829FB2C0 size=244
    let mut pc: u32 = 0x829FB2C0;
    'dispatch: loop {
        match pc {
            0x829FB2C0 => {
    //   block [0x829FB2C0..0x829FB3B4)
	// 829FB2C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FB2C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829FB2C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829FB2CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829FB2D0: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 829FB2D4: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FB2D8: 48759329  bl 0x83154600
	ctx.lr = 0x829FB2DC;
	sub_83154600(ctx, base);
	// 829FB2DC: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 829FB2E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FB2E4: 4BFF2A9D  bl 0x829edd80
	ctx.lr = 0x829FB2E8;
	sub_829EDD80(ctx, base);
	// 829FB2E8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829FB2EC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829FB2F0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829FB2F4: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829FB2F8: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 829FB2FC: 4BFF4C15  bl 0x829eff10
	ctx.lr = 0x829FB300;
	sub_829EFF10(ctx, base);
	// 829FB300: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FB304: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829FB308: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FB30C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FB310: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 829FB314: 419A0024  beq cr6, 0x829fb338
	if ctx.cr[6].eq {
	pc = 0x829FB338; continue 'dispatch;
	}
	// 829FB318: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829FB31C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829FB320: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829FB324: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829FB328: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829FB32C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829FB330: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829FB334: 4082FFE8  bne 0x829fb31c
	if !ctx.cr[0].eq {
	pc = 0x829FB31C; continue 'dispatch;
	}
	// 829FB338: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829FB33C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829FB340: 4BB13FF1  bl 0x8250f330
	ctx.lr = 0x829FB344;
	sub_8250F330(ctx, base);
	// 829FB344: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FB348: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 829FB34C: 4BAEE525  bl 0x824e9870
	ctx.lr = 0x829FB350;
	sub_824E9870(ctx, base);
	// 829FB350: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FB354: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829FB358: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829FB35C: 388B7300  addi r4, r11, 0x7300
	ctx.r[4].s64 = ctx.r[11].s64 + 29440;
	// 829FB360: 38A0017B  li r5, 0x17b
	ctx.r[5].s64 = 379;
	// 829FB364: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 829FB368: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 829FB36C: 4845D6D5  bl 0x82e58a40
	ctx.lr = 0x829FB370;
	sub_82E58A40(ctx, base);
	// 829FB370: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829FB374: 483F691D  bl 0x82df1c90
	ctx.lr = 0x829FB378;
	sub_82DF1C90(ctx, base);
	// 829FB378: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829FB37C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FB380: 419A0008  beq cr6, 0x829fb388
	if ctx.cr[6].eq {
	pc = 0x829FB388; continue 'dispatch;
	}
	// 829FB384: 4B8C550D  bl 0x822c0890
	ctx.lr = 0x829FB388;
	sub_822C0890(ctx, base);
	// 829FB388: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 829FB38C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FB390: 419A0008  beq cr6, 0x829fb398
	if ctx.cr[6].eq {
	pc = 0x829FB398; continue 'dispatch;
	}
	// 829FB394: 4B8C54FD  bl 0x822c0890
	ctx.lr = 0x829FB398;
	sub_822C0890(ctx, base);
	// 829FB398: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 829FB39C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829FB3A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829FB3A4: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 829FB3A8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829FB3AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829FB3B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FB3B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829FB3B8 size=2088
    let mut pc: u32 = 0x829FB3B8;
    'dispatch: loop {
        match pc {
            0x829FB3B8 => {
    //   block [0x829FB3B8..0x829FBBE0)
	// 829FB3B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FB3BC: 487ACDA5  bl 0x831a8160
	ctx.lr = 0x829FB3C0;
	sub_831A8130(ctx, base);
	// 829FB3C0: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 829FB3C4: 9421FE90  stwu r1, -0x170(r1)
	ea = ctx.r[1].u32.wrapping_add(-368 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FB3C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FB3CC: 48759235  bl 0x83154600
	ctx.lr = 0x829FB3D0;
	sub_83154600(ctx, base);
	// 829FB3D0: 897F0060  lbz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 829FB3D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829FB3D8: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829FB3DC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829FB3E0: 419805F8  blt cr6, 0x829fb9d8
	if ctx.cr[6].lt {
	pc = 0x829FB9D8; continue 'dispatch;
	}
	// 829FB3E4: 419A0210  beq cr6, 0x829fb5f4
	if ctx.cr[6].eq {
	pc = 0x829FB5F4; continue 'dispatch;
	}
	// 829FB3E8: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 829FB3EC: 419800CC  blt cr6, 0x829fb4b8
	if ctx.cr[6].lt {
	pc = 0x829FB4B8; continue 'dispatch;
	}
	// 829FB3F0: 409A07D4  bne cr6, 0x829fbbc4
	if !ctx.cr[6].eq {
	pc = 0x829FBBC4; continue 'dispatch;
	}
	// 829FB3F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FB3F8: 4845E369  bl 0x82e59760
	ctx.lr = 0x829FB3FC;
	sub_82E59760(ctx, base);
	// 829FB3FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FB400: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 829FB404: 4BFF2B65  bl 0x829edf68
	ctx.lr = 0x829FB408;
	sub_829EDF68(ctx, base);
	// 829FB408: 897F0060  lbz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 829FB40C: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829FB410: 396B000D  addi r11, r11, 0xd
	ctx.r[11].s64 = ctx.r[11].s64 + 13;
	// 829FB414: 1D6B0003  mulli r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 * 3;
	// 829FB418: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 829FB41C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829FB420: 7C0BFC2E  lfsx f0, r11, r31
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FB424: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 829FB428: 4198079C  blt cr6, 0x829fbbc4
	if ctx.cr[6].lt {
	pc = 0x829FBBC4; continue 'dispatch;
	}
	// 829FB42C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829FB430: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 829FB434: 4BFF4285  bl 0x829ef6b8
	ctx.lr = 0x829FB438;
	sub_829EF6B8(ctx, base);
	// 829FB438: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FB43C: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 829FB440: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FB444: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FB448: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 829FB44C: 419A0024  beq cr6, 0x829fb470
	if ctx.cr[6].eq {
	pc = 0x829FB470; continue 'dispatch;
	}
	// 829FB450: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829FB454: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829FB458: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829FB45C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829FB460: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829FB464: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829FB468: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829FB46C: 4082FFE8  bne 0x829fb454
	if !ctx.cr[0].eq {
	pc = 0x829FB454; continue 'dispatch;
	}
	// 829FB470: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829FB474: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 829FB478: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829FB47C: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 829FB480: 389E00E8  addi r4, r30, 0xe8
	ctx.r[4].s64 = ctx.r[30].s64 + 232;
	// 829FB484: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 829FB488: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829FB48C: 4846321D  bl 0x82e5e6a8
	ctx.lr = 0x829FB490;
	sub_82E5E6A8(ctx, base);
	// 829FB490: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 829FB494: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FB498: 419A0008  beq cr6, 0x829fb4a0
	if ctx.cr[6].eq {
	pc = 0x829FB4A0; continue 'dispatch;
	}
	// 829FB49C: 4B8C53F5  bl 0x822c0890
	ctx.lr = 0x829FB4A0;
	sub_822C0890(ctx, base);
	// 829FB4A0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 829FB4A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FB4A8: 419A0008  beq cr6, 0x829fb4b0
	if ctx.cr[6].eq {
	pc = 0x829FB4B0; continue 'dispatch;
	}
	// 829FB4AC: 4B8C53E5  bl 0x822c0890
	ctx.lr = 0x829FB4B0;
	sub_822C0890(ctx, base);
	// 829FB4B0: 8061010C  lwz r3, 0x10c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(268 as u32) ) } as u64;
	// 829FB4B4: 48000514  b 0x829fb9c8
	pc = 0x829FB9C8; continue 'dispatch;
	// 829FB4B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FB4BC: 4845E2A5  bl 0x82e59760
	ctx.lr = 0x829FB4C0;
	sub_82E59760(ctx, base);
	// 829FB4C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FB4C4: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 829FB4C8: 4BFF2AA1  bl 0x829edf68
	ctx.lr = 0x829FB4CC;
	sub_829EDF68(ctx, base);
	// 829FB4CC: 897F0060  lbz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 829FB4D0: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829FB4D4: 396B000D  addi r11, r11, 0xd
	ctx.r[11].s64 = ctx.r[11].s64 + 13;
	// 829FB4D8: 1D6B0003  mulli r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 * 3;
	// 829FB4DC: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 829FB4E0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829FB4E4: 7C0BFC2E  lfsx f0, r11, r31
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FB4E8: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 829FB4EC: 419806D8  blt cr6, 0x829fbbc4
	if ctx.cr[6].lt {
	pc = 0x829FBBC4; continue 'dispatch;
	}
	// 829FB4F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FB4F4: 4845E26D  bl 0x82e59760
	ctx.lr = 0x829FB4F8;
	sub_82E59760(ctx, base);
	// 829FB4F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FB4FC: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 829FB500: 4BFF2A69  bl 0x829edf68
	ctx.lr = 0x829FB504;
	sub_829EDF68(ctx, base);
	// 829FB504: 897F0060  lbz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 829FB508: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829FB50C: 396B000D  addi r11, r11, 0xd
	ctx.r[11].s64 = ctx.r[11].s64 + 13;
	// 829FB510: 1D6B0003  mulli r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 * 3;
	// 829FB514: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 829FB518: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FB51C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829FB520: 7C0BFC2E  lfsx f0, r11, r31
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FB524: EC3F0028  fsubs f1, f31, f0
	ctx.f[1].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 829FB528: 48426A01  bl 0x82e21f28
	ctx.lr = 0x829FB52C;
	sub_82E21F28(ctx, base);
	// 829FB52C: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 829FB530: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FB534: 995F0060  stb r10, 0x60(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[10].u8 ) };
	// 829FB538: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 829FB53C: 3BAB6FBC  addi r29, r11, 0x6fbc
	ctx.r[29].s64 = ctx.r[11].s64 + 28604;
	// 829FB540: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829FB544: 483F84C5  bl 0x82df3a08
	ctx.lr = 0x829FB548;
	sub_82DF3A08(ctx, base);
	// 829FB548: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 829FB54C: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 829FB550: 809E0160  lwz r4, 0x160(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(352 as u32) ) } as u64;
	// 829FB554: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 829FB558: C04B6150  lfs f2, 0x6150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 829FB55C: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 829FB560: 481B7E19  bl 0x82bb3378
	ctx.lr = 0x829FB564;
	sub_82BB3378(ctx, base);
	// 829FB564: 806100CC  lwz r3, 0xcc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 829FB568: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FB56C: 419A0008  beq cr6, 0x829fb574
	if ctx.cr[6].eq {
	pc = 0x829FB574; continue 'dispatch;
	}
	// 829FB570: 4B8C5321  bl 0x822c0890
	ctx.lr = 0x829FB574;
	sub_822C0890(ctx, base);
	// 829FB574: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 829FB578: 483F7EB1  bl 0x82df3428
	ctx.lr = 0x829FB57C;
	sub_82DF3428(ctx, base);
	// 829FB57C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829FB580: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829FB584: 483F8485  bl 0x82df3a08
	ctx.lr = 0x829FB588;
	sub_82DF3A08(ctx, base);
	// 829FB588: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 829FB58C: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 829FB590: 809E0160  lwz r4, 0x160(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(352 as u32) ) } as u64;
	// 829FB594: 481B7635  bl 0x82bb2bc8
	ctx.lr = 0x829FB598;
	sub_82BB2BC8(ctx, base);
	// 829FB598: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829FB59C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FB5A0: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FB5A4: 4BFF29C5  bl 0x829edf68
	ctx.lr = 0x829FB5A8;
	sub_829EDF68(ctx, base);
	// 829FB5A8: 897F0060  lbz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 829FB5AC: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829FB5B0: 396B0009  addi r11, r11, 9
	ctx.r[11].s64 = ctx.r[11].s64 + 9;
	// 829FB5B4: 1D6B0003  mulli r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 * 3;
	// 829FB5B8: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 829FB5BC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829FB5C0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829FB5C4: 7C2BFC2E  lfsx f1, r11, r31
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829FB5C8: 481BD4A9  bl 0x82bb8a70
	ctx.lr = 0x829FB5CC;
	sub_82BB8A70(ctx, base);
	// 829FB5CC: 806100FC  lwz r3, 0xfc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(252 as u32) ) } as u64;
	// 829FB5D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FB5D4: 419A0008  beq cr6, 0x829fb5dc
	if ctx.cr[6].eq {
	pc = 0x829FB5DC; continue 'dispatch;
	}
	// 829FB5D8: 4B8C52B9  bl 0x822c0890
	ctx.lr = 0x829FB5DC;
	sub_822C0890(ctx, base);
	// 829FB5DC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829FB5E0: 483F7E49  bl 0x82df3428
	ctx.lr = 0x829FB5E4;
	sub_82DF3428(ctx, base);
	// 829FB5E4: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 829FB5E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FB5EC: 4BFF27B5  bl 0x829edda0
	ctx.lr = 0x829FB5F0;
	sub_829EDDA0(ctx, base);
	// 829FB5F0: 480005D4  b 0x829fbbc4
	pc = 0x829FBBC4; continue 'dispatch;
	// 829FB5F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FB5F8: 4845E169  bl 0x82e59760
	ctx.lr = 0x829FB5FC;
	sub_82E59760(ctx, base);
	// 829FB5FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FB600: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 829FB604: 4BFF2965  bl 0x829edf68
	ctx.lr = 0x829FB608;
	sub_829EDF68(ctx, base);
	// 829FB608: 897F0060  lbz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 829FB60C: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829FB610: 396B000D  addi r11, r11, 0xd
	ctx.r[11].s64 = ctx.r[11].s64 + 13;
	// 829FB614: 1D6B0003  mulli r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 * 3;
	// 829FB618: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 829FB61C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829FB620: 7C0BFC2E  lfsx f0, r11, r31
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FB624: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 829FB628: 4198059C  blt cr6, 0x829fbbc4
	if ctx.cr[6].lt {
	pc = 0x829FBBC4; continue 'dispatch;
	}
	// 829FB62C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FB630: 4845E131  bl 0x82e59760
	ctx.lr = 0x829FB634;
	sub_82E59760(ctx, base);
	// 829FB634: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FB638: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 829FB63C: 4BFF292D  bl 0x829edf68
	ctx.lr = 0x829FB640;
	sub_829EDF68(ctx, base);
	// 829FB640: 897F0060  lbz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 829FB644: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829FB648: 396B000D  addi r11, r11, 0xd
	ctx.r[11].s64 = ctx.r[11].s64 + 13;
	// 829FB64C: 1D6B0003  mulli r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 * 3;
	// 829FB650: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 829FB654: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FB658: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829FB65C: 7C0BFC2E  lfsx f0, r11, r31
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FB660: EC3F0028  fsubs f1, f31, f0
	ctx.f[1].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 829FB664: 484268C5  bl 0x82e21f28
	ctx.lr = 0x829FB668;
	sub_82E21F28(ctx, base);
	// 829FB668: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 829FB66C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FB670: 995F0060  stb r10, 0x60(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[10].u8 ) };
	// 829FB674: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 829FB678: 3BAB6F70  addi r29, r11, 0x6f70
	ctx.r[29].s64 = ctx.r[11].s64 + 28528;
	// 829FB67C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829FB680: 483F8389  bl 0x82df3a08
	ctx.lr = 0x829FB684;
	sub_82DF3A08(ctx, base);
	// 829FB684: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 829FB688: 38A1006C  addi r5, r1, 0x6c
	ctx.r[5].s64 = ctx.r[1].s64 + 108;
	// 829FB68C: 809E0160  lwz r4, 0x160(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(352 as u32) ) } as u64;
	// 829FB690: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 829FB694: C3EB6150  lfs f31, 0x6150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829FB698: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 829FB69C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829FB6A0: 481B7CD9  bl 0x82bb3378
	ctx.lr = 0x829FB6A4;
	sub_82BB3378(ctx, base);
	// 829FB6A4: 806100DC  lwz r3, 0xdc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) } as u64;
	// 829FB6A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FB6AC: 419A0008  beq cr6, 0x829fb6b4
	if ctx.cr[6].eq {
	pc = 0x829FB6B4; continue 'dispatch;
	}
	// 829FB6B0: 4B8C51E1  bl 0x822c0890
	ctx.lr = 0x829FB6B4;
	sub_822C0890(ctx, base);
	// 829FB6B4: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 829FB6B8: 483F7D71  bl 0x82df3428
	ctx.lr = 0x829FB6BC;
	sub_82DF3428(ctx, base);
	// 829FB6BC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829FB6C0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829FB6C4: 483F8345  bl 0x82df3a08
	ctx.lr = 0x829FB6C8;
	sub_82DF3A08(ctx, base);
	// 829FB6C8: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 829FB6CC: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 829FB6D0: 809E0160  lwz r4, 0x160(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(352 as u32) ) } as u64;
	// 829FB6D4: 481B74F5  bl 0x82bb2bc8
	ctx.lr = 0x829FB6D8;
	sub_82BB2BC8(ctx, base);
	// 829FB6D8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829FB6DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FB6E0: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FB6E4: 4BFF2885  bl 0x829edf68
	ctx.lr = 0x829FB6E8;
	sub_829EDF68(ctx, base);
	// 829FB6E8: 897F0060  lbz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 829FB6EC: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829FB6F0: 396B0009  addi r11, r11, 9
	ctx.r[11].s64 = ctx.r[11].s64 + 9;
	// 829FB6F4: 1D6B0003  mulli r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 * 3;
	// 829FB6F8: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 829FB6FC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829FB700: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829FB704: 7C2BFC2E  lfsx f1, r11, r31
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829FB708: 481BD369  bl 0x82bb8a70
	ctx.lr = 0x829FB70C;
	sub_82BB8A70(ctx, base);
	// 829FB70C: 8061011C  lwz r3, 0x11c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(284 as u32) ) } as u64;
	// 829FB710: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FB714: 419A0008  beq cr6, 0x829fb71c
	if ctx.cr[6].eq {
	pc = 0x829FB71C; continue 'dispatch;
	}
	// 829FB718: 4B8C5179  bl 0x822c0890
	ctx.lr = 0x829FB71C;
	sub_822C0890(ctx, base);
	// 829FB71C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829FB720: 483F7D09  bl 0x82df3428
	ctx.lr = 0x829FB724;
	sub_82DF3428(ctx, base);
	// 829FB724: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FB728: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829FB72C: 3B6B7300  addi r27, r11, 0x7300
	ctx.r[27].s64 = ctx.r[11].s64 + 29440;
	// 829FB730: 38A001AC  li r5, 0x1ac
	ctx.r[5].s64 = 428;
	// 829FB734: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829FB738: 38600110  li r3, 0x110
	ctx.r[3].s64 = 272;
	// 829FB73C: 483F6CAD  bl 0x82df23e8
	ctx.lr = 0x829FB740;
	sub_82DF23E8(ctx, base);
	// 829FB740: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 829FB744: 41820030  beq 0x829fb774
	if ctx.cr[0].eq {
	pc = 0x829FB774; continue 'dispatch;
	}
	// 829FB748: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FB74C: 4BB1640D  bl 0x82511b58
	ctx.lr = 0x829FB750;
	sub_82511B58(ctx, base);
	// 829FB750: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 829FB754: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FB758: 4BB16391  bl 0x82511ae8
	ctx.lr = 0x829FB75C;
	sub_82511AE8(ctx, base);
	// 829FB75C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829FB760: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829FB764: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 829FB768: 4BFFEEA1  bl 0x829fa608
	ctx.lr = 0x829FB76C;
	sub_829FA608(ctx, base);
	// 829FB76C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829FB770: 48000008  b 0x829fb778
	pc = 0x829FB778; continue 'dispatch;
	// 829FB774: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 829FB778: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 829FB77C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829FB780: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829FB784: 4BFFEDBD  bl 0x829fa540
	ctx.lr = 0x829FB788;
	sub_829FA540(ctx, base);
	// 829FB788: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 829FB78C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829FB790: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829FB794: 4B8C486D  bl 0x822c0000
	ctx.lr = 0x829FB798;
	sub_822C0000(ctx, base);
	// 829FB798: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829FB79C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829FB7A0: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829FB7A4: 9381008C  stw r28, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[28].u32 ) };
	// 829FB7A8: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 829FB7AC: 419A0024  beq cr6, 0x829fb7d0
	if ctx.cr[6].eq {
	pc = 0x829FB7D0; continue 'dispatch;
	}
	// 829FB7B0: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 829FB7B4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829FB7B8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829FB7BC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829FB7C0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829FB7C4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829FB7C8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829FB7CC: 4082FFE8  bne 0x829fb7b4
	if !ctx.cr[0].eq {
	pc = 0x829FB7B4; continue 'dispatch;
	}
	// 829FB7D0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829FB7D4: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 829FB7D8: 4BB13CF1  bl 0x8250f4c8
	ctx.lr = 0x829FB7DC;
	sub_8250F4C8(ctx, base);
	// 829FB7DC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FB7E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FB7E4: 3BABFFFC  addi r29, r11, -4
	ctx.r[29].s64 = ctx.r[11].s64 + -4;
	// 829FB7E8: 409A0008  bne cr6, 0x829fb7f0
	if !ctx.cr[6].eq {
	pc = 0x829FB7F0; continue 'dispatch;
	}
	// 829FB7EC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 829FB7F0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829FB7F4: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 829FB7F8: 3B410088  addi r26, r1, 0x88
	ctx.r[26].s64 = ctx.r[1].s64 + 136;
	// 829FB7FC: 4BB13D1D  bl 0x8250f518
	ctx.lr = 0x829FB800;
	sub_8250F518(ctx, base);
	// 829FB800: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829FB804: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829FB808: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 829FB80C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829FB810: 4BB11CF9  bl 0x8250d508
	ctx.lr = 0x829FB814;
	sub_8250D508(ctx, base);
	// 829FB814: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 829FB818: 483F6479  bl 0x82df1c90
	ctx.lr = 0x829FB81C;
	sub_82DF1C90(ctx, base);
	// 829FB81C: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 829FB820: 483F6471  bl 0x82df1c90
	ctx.lr = 0x829FB824;
	sub_82DF1C90(ctx, base);
	// 829FB824: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829FB828: 419A000C  beq cr6, 0x829fb834
	if ctx.cr[6].eq {
	pc = 0x829FB834; continue 'dispatch;
	}
	// 829FB82C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829FB830: 4B8C5061  bl 0x822c0890
	ctx.lr = 0x829FB834;
	sub_822C0890(ctx, base);
	// 829FB834: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829FB838: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829FB83C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829FB840: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829FB844: 38A001B7  li r5, 0x1b7
	ctx.r[5].s64 = 439;
	// 829FB848: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FB84C: 38600050  li r3, 0x50
	ctx.r[3].s64 = 80;
	// 829FB850: C1AA08A8  lfs f13, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829FB854: D00100A0  stfs f0, 0xa0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 829FB858: D1A100A4  stfs f13, 0xa4(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 829FB85C: D00100A8  stfs f0, 0xa8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 829FB860: D00100AC  stfs f0, 0xac(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 829FB864: 483F6B85  bl 0x82df23e8
	ctx.lr = 0x829FB868;
	sub_82DF23E8(ctx, base);
	// 829FB868: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829FB86C: 41820028  beq 0x829fb894
	if ctx.cr[0].eq {
	pc = 0x829FB894; continue 'dispatch;
	}
	// 829FB870: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829FB874: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 829FB878: 38E100A0  addi r7, r1, 0xa0
	ctx.r[7].s64 = ctx.r[1].s64 + 160;
	// 829FB87C: 38C00005  li r6, 5
	ctx.r[6].s64 = 5;
	// 829FB880: C06B9450  lfs f3, -0x6bb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 829FB884: FC201890  fmr f1, f3
	ctx.f[1].f64 = ctx.f[3].f64;
	// 829FB888: 48155C01  bl 0x82b51488
	ctx.lr = 0x829FB88C;
	sub_82B51488(ctx, base);
	// 829FB88C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829FB890: 48000008  b 0x829fb898
	pc = 0x829FB898; continue 'dispatch;
	// 829FB894: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 829FB898: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 829FB89C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829FB8A0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829FB8A4: 4B974275  bl 0x8236fb18
	ctx.lr = 0x829FB8A8;
	sub_8236FB18(ctx, base);
	// 829FB8A8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 829FB8AC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829FB8B0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829FB8B4: 4B8C474D  bl 0x822c0000
	ctx.lr = 0x829FB8B8;
	sub_822C0000(ctx, base);
	// 829FB8B8: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829FB8BC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829FB8C0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829FB8C4: 93A10084  stw r29, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[29].u32 ) };
	// 829FB8C8: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 829FB8CC: 419A0024  beq cr6, 0x829fb8f0
	if ctx.cr[6].eq {
	pc = 0x829FB8F0; continue 'dispatch;
	}
	// 829FB8D0: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 829FB8D4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829FB8D8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829FB8DC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829FB8E0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829FB8E4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829FB8E8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829FB8EC: 4082FFE8  bne 0x829fb8d4
	if !ctx.cr[0].eq {
	pc = 0x829FB8D4; continue 'dispatch;
	}
	// 829FB8F0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829FB8F4: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 829FB8F8: 4BB13C21  bl 0x8250f518
	ctx.lr = 0x829FB8FC;
	sub_8250F518(ctx, base);
	// 829FB8FC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FB900: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FB904: 386BFF6C  addi r3, r11, -0x94
	ctx.r[3].s64 = ctx.r[11].s64 + -148;
	// 829FB908: 409A0008  bne cr6, 0x829fb910
	if !ctx.cr[6].eq {
	pc = 0x829FB910; continue 'dispatch;
	}
	// 829FB90C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 829FB910: 3B810080  addi r28, r1, 0x80
	ctx.r[28].s64 = ctx.r[1].s64 + 128;
	// 829FB914: 4BB2C73D  bl 0x82528050
	ctx.lr = 0x829FB918;
	sub_82528050(ctx, base);
	// 829FB918: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 829FB91C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829FB920: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829FB924: 38A001B8  li r5, 0x1b8
	ctx.r[5].s64 = 440;
	// 829FB928: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 829FB92C: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 829FB930: C02B3AF4  lfs f1, 0x3af4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(15092 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829FB934: 4845D10D  bl 0x82e58a40
	ctx.lr = 0x829FB938;
	sub_82E58A40(ctx, base);
	// 829FB938: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 829FB93C: 483F6355  bl 0x82df1c90
	ctx.lr = 0x829FB940;
	sub_82DF1C90(ctx, base);
	// 829FB940: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 829FB944: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FB948: 419A0008  beq cr6, 0x829fb950
	if ctx.cr[6].eq {
	pc = 0x829FB950; continue 'dispatch;
	}
	// 829FB94C: 4B8C4F45  bl 0x822c0890
	ctx.lr = 0x829FB950;
	sub_822C0890(ctx, base);
	// 829FB950: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829FB954: 419A000C  beq cr6, 0x829fb960
	if ctx.cr[6].eq {
	pc = 0x829FB960; continue 'dispatch;
	}
	// 829FB958: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829FB95C: 4B8C4F35  bl 0x822c0890
	ctx.lr = 0x829FB960;
	sub_822C0890(ctx, base);
	// 829FB960: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 829FB964: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829FB968: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 829FB96C: 808B1674  lwz r4, 0x1674(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5748 as u32) ) } as u64;
	// 829FB970: 483F6289  bl 0x82df1bf8
	ctx.lr = 0x829FB974;
	sub_82DF1BF8(ctx, base);
	// 829FB974: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 829FB978: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 829FB97C: 388B9F98  addi r4, r11, -0x6068
	ctx.r[4].s64 = ctx.r[11].s64 + -24680;
	// 829FB980: 83A10090  lwz r29, 0x90(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 829FB984: 483FDBAD  bl 0x82df9530
	ctx.lr = 0x829FB988;
	sub_82DF9530(ctx, base);
	// 829FB988: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829FB98C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829FB990: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829FB994: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FB998: 4BB2AAB9  bl 0x82526450
	ctx.lr = 0x829FB99C;
	sub_82526450(ctx, base);
	// 829FB99C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 829FB9A0: 483F62F1  bl 0x82df1c90
	ctx.lr = 0x829FB9A4;
	sub_82DF1C90(ctx, base);
	// 829FB9A4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FB9A8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829FB9AC: 38AB7348  addi r5, r11, 0x7348
	ctx.r[5].s64 = ctx.r[11].s64 + 29512;
	// 829FB9B0: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 829FB9B4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FB9B8: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 829FB9BC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829FB9C0: 4E800421  bctrl
	ctx.lr = 0x829FB9C4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829FB9C4: 806100D4  lwz r3, 0xd4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 829FB9C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FB9CC: 419A01F8  beq cr6, 0x829fbbc4
	if ctx.cr[6].eq {
	pc = 0x829FBBC4; continue 'dispatch;
	}
	// 829FB9D0: 4B8C4EC1  bl 0x822c0890
	ctx.lr = 0x829FB9D4;
	sub_822C0890(ctx, base);
	// 829FB9D4: 480001F0  b 0x829fbbc4
	pc = 0x829FBBC4; continue 'dispatch;
	// 829FB9D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FB9DC: 4845DD85  bl 0x82e59760
	ctx.lr = 0x829FB9E0;
	sub_82E59760(ctx, base);
	// 829FB9E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FB9E4: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 829FB9E8: 4BFF2581  bl 0x829edf68
	ctx.lr = 0x829FB9EC;
	sub_829EDF68(ctx, base);
	// 829FB9EC: 897F0060  lbz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 829FB9F0: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829FB9F4: 396B000D  addi r11, r11, 0xd
	ctx.r[11].s64 = ctx.r[11].s64 + 13;
	// 829FB9F8: 1D6B0003  mulli r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 * 3;
	// 829FB9FC: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 829FBA00: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829FBA04: 7C0BFC2E  lfsx f0, r11, r31
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FBA08: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 829FBA0C: 419801B8  blt cr6, 0x829fbbc4
	if ctx.cr[6].lt {
	pc = 0x829FBBC4; continue 'dispatch;
	}
	// 829FBA10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FBA14: 4845DD4D  bl 0x82e59760
	ctx.lr = 0x829FBA18;
	sub_82E59760(ctx, base);
	// 829FBA18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FBA1C: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 829FBA20: 4BFF2549  bl 0x829edf68
	ctx.lr = 0x829FBA24;
	sub_829EDF68(ctx, base);
	// 829FBA24: 897F0060  lbz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 829FBA28: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829FBA2C: 396B000D  addi r11, r11, 0xd
	ctx.r[11].s64 = ctx.r[11].s64 + 13;
	// 829FBA30: 1D6B0003  mulli r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 * 3;
	// 829FBA34: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 829FBA38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FBA3C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829FBA40: 7C0BFC2E  lfsx f0, r11, r31
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FBA44: EC3F0028  fsubs f1, f31, f0
	ctx.f[1].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 829FBA48: 484264E1  bl 0x82e21f28
	ctx.lr = 0x829FBA4C;
	sub_82E21F28(ctx, base);
	// 829FBA4C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829FBA50: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FBA54: 995F0060  stb r10, 0x60(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[10].u8 ) };
	// 829FBA58: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829FBA5C: 3BAB6F84  addi r29, r11, 0x6f84
	ctx.r[29].s64 = ctx.r[11].s64 + 28548;
	// 829FBA60: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829FBA64: 483F7FA5  bl 0x82df3a08
	ctx.lr = 0x829FBA68;
	sub_82DF3A08(ctx, base);
	// 829FBA68: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 829FBA6C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 829FBA70: 809E0160  lwz r4, 0x160(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(352 as u32) ) } as u64;
	// 829FBA74: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 829FBA78: C04B6150  lfs f2, 0x6150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 829FBA7C: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 829FBA80: 481B78F9  bl 0x82bb3378
	ctx.lr = 0x829FBA84;
	sub_82BB3378(ctx, base);
	// 829FBA84: 806100E4  lwz r3, 0xe4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(228 as u32) ) } as u64;
	// 829FBA88: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FBA8C: 419A0008  beq cr6, 0x829fba94
	if ctx.cr[6].eq {
	pc = 0x829FBA94; continue 'dispatch;
	}
	// 829FBA90: 4B8C4E01  bl 0x822c0890
	ctx.lr = 0x829FBA94;
	sub_822C0890(ctx, base);
	// 829FBA94: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829FBA98: 483F7991  bl 0x82df3428
	ctx.lr = 0x829FBA9C;
	sub_82DF3428(ctx, base);
	// 829FBA9C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829FBAA0: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 829FBAA4: 483F7F65  bl 0x82df3a08
	ctx.lr = 0x829FBAA8;
	sub_82DF3A08(ctx, base);
	// 829FBAA8: 38A10064  addi r5, r1, 0x64
	ctx.r[5].s64 = ctx.r[1].s64 + 100;
	// 829FBAAC: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 829FBAB0: 809E0160  lwz r4, 0x160(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(352 as u32) ) } as u64;
	// 829FBAB4: 481B7115  bl 0x82bb2bc8
	ctx.lr = 0x829FBAB8;
	sub_82BB2BC8(ctx, base);
	// 829FBAB8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829FBABC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FBAC0: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FBAC4: 4BFF24A5  bl 0x829edf68
	ctx.lr = 0x829FBAC8;
	sub_829EDF68(ctx, base);
	// 829FBAC8: 897F0060  lbz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 829FBACC: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829FBAD0: 396B0009  addi r11, r11, 9
	ctx.r[11].s64 = ctx.r[11].s64 + 9;
	// 829FBAD4: 1D6B0003  mulli r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 * 3;
	// 829FBAD8: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 829FBADC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829FBAE0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829FBAE4: 7C2BFC2E  lfsx f1, r11, r31
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829FBAE8: 481BCF89  bl 0x82bb8a70
	ctx.lr = 0x829FBAEC;
	sub_82BB8A70(ctx, base);
	// 829FBAEC: 806100F4  lwz r3, 0xf4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 829FBAF0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FBAF4: 419A0008  beq cr6, 0x829fbafc
	if ctx.cr[6].eq {
	pc = 0x829FBAFC; continue 'dispatch;
	}
	// 829FBAF8: 4B8C4D99  bl 0x822c0890
	ctx.lr = 0x829FBAFC;
	sub_822C0890(ctx, base);
	// 829FBAFC: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 829FBB00: 483F7929  bl 0x82df3428
	ctx.lr = 0x829FBB04;
	sub_82DF3428(ctx, base);
	// 829FBB04: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 829FBB08: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829FBB0C: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 829FBB10: C00B7BC4  lfs f0, 0x7bc4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31684 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FBB14: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 829FBB18: 4BFF43F9  bl 0x829eff10
	ctx.lr = 0x829FBB1C;
	sub_829EFF10(ctx, base);
	// 829FBB1C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FBB20: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 829FBB24: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FBB28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FBB2C: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 829FBB30: 419A0024  beq cr6, 0x829fbb54
	if ctx.cr[6].eq {
	pc = 0x829FBB54; continue 'dispatch;
	}
	// 829FBB34: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829FBB38: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829FBB3C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829FBB40: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829FBB44: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829FBB48: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829FBB4C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829FBB50: 4082FFE8  bne 0x829fbb38
	if !ctx.cr[0].eq {
	pc = 0x829FBB38; continue 'dispatch;
	}
	// 829FBB54: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829FBB58: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 829FBB5C: 4BB137D5  bl 0x8250f330
	ctx.lr = 0x829FBB60;
	sub_8250F330(ctx, base);
	// 829FBB60: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FBB64: 3BA10078  addi r29, r1, 0x78
	ctx.r[29].s64 = ctx.r[1].s64 + 120;
	// 829FBB68: 4BAEDD09  bl 0x824e9870
	ctx.lr = 0x829FBB6C;
	sub_824E9870(ctx, base);
	// 829FBB6C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829FBB70: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829FBB74: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829FBB78: 388A7300  addi r4, r10, 0x7300
	ctx.r[4].s64 = ctx.r[10].s64 + 29440;
	// 829FBB7C: 38A00196  li r5, 0x196
	ctx.r[5].s64 = 406;
	// 829FBB80: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 829FBB84: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829FBB88: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 829FBB8C: 4845CEB5  bl 0x82e58a40
	ctx.lr = 0x829FBB90;
	sub_82E58A40(ctx, base);
	// 829FBB90: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 829FBB94: 483F60FD  bl 0x82df1c90
	ctx.lr = 0x829FBB98;
	sub_82DF1C90(ctx, base);
	// 829FBB98: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 829FBB9C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FBBA0: 419A0008  beq cr6, 0x829fbba8
	if ctx.cr[6].eq {
	pc = 0x829FBBA8; continue 'dispatch;
	}
	// 829FBBA4: 4B8C4CED  bl 0x822c0890
	ctx.lr = 0x829FBBA8;
	sub_822C0890(ctx, base);
	// 829FBBA8: 80610114  lwz r3, 0x114(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(276 as u32) ) } as u64;
	// 829FBBAC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FBBB0: 419A0008  beq cr6, 0x829fbbb8
	if ctx.cr[6].eq {
	pc = 0x829FBBB8; continue 'dispatch;
	}
	// 829FBBB4: 4B8C4CDD  bl 0x822c0890
	ctx.lr = 0x829FBBB8;
	sub_822C0890(ctx, base);
	// 829FBBB8: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 829FBBBC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FBBC0: 4BFF21C1  bl 0x829edd80
	ctx.lr = 0x829FBBC4;
	sub_829EDD80(ctx, base);
	// 829FBBC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FBBC8: 4845DBB1  bl 0x82e59778
	ctx.lr = 0x829FBBCC;
	sub_82E59778(ctx, base);
	// 829FBBCC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FBBD0: 4BFF2479  bl 0x829ee048
	ctx.lr = 0x829FBBD4;
	sub_829EE048(ctx, base);
	// 829FBBD4: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 829FBBD8: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 829FBBDC: 487AC5D4  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FBBE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829FBBE0 size=232
    let mut pc: u32 = 0x829FBBE0;
    'dispatch: loop {
        match pc {
            0x829FBBE0 => {
    //   block [0x829FBBE0..0x829FBCC8)
	// 829FBBE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FBBE4: 487AC589  bl 0x831a816c
	ctx.lr = 0x829FBBE8;
	sub_831A8130(ctx, base);
	// 829FBBE8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FBBEC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FBBF0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829FBBF4: 48758A0D  bl 0x83154600
	ctx.lr = 0x829FBBF8;
	sub_83154600(ctx, base);
	// 829FBBF8: 897F0060  lbz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 829FBBFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FBC00: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829FBC04: 409A00BC  bne cr6, 0x829fbcc0
	if !ctx.cr[6].eq {
	pc = 0x829FBCC0; continue 'dispatch;
	}
	// 829FBC08: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 829FBC0C: 39400064  li r10, 0x64
	ctx.r[10].s64 = 100;
	// 829FBC10: 3BAB6910  addi r29, r11, 0x6910
	ctx.r[29].s64 = ctx.r[11].s64 + 26896;
	// 829FBC14: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829FBC18: 4BB15ED1  bl 0x82511ae8
	ctx.lr = 0x829FBC1C;
	sub_82511AE8(ctx, base);
	// 829FBC1C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 829FBC20: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829FBC24: 388B8614  addi r4, r11, -0x79ec
	ctx.r[4].s64 = ctx.r[11].s64 + -31212;
	// 829FBC28: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829FBC2C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829FBC30: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 829FBC34: 4BA1B78D  bl 0x824173c0
	ctx.lr = 0x829FBC38;
	sub_824173C0(ctx, base);
	// 829FBC38: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FBC3C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829FBC40: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FBC44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FBC48: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 829FBC4C: 419A0024  beq cr6, 0x829fbc70
	if ctx.cr[6].eq {
	pc = 0x829FBC70; continue 'dispatch;
	}
	// 829FBC50: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829FBC54: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829FBC58: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829FBC5C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829FBC60: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829FBC64: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829FBC68: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829FBC6C: 4082FFE8  bne 0x829fbc54
	if !ctx.cr[0].eq {
	pc = 0x829FBC54; continue 'dispatch;
	}
	// 829FBC70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FBC74: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 829FBC78: 4860C4B1  bl 0x83008128
	ctx.lr = 0x829FBC7C;
	sub_83008128(ctx, base);
	// 829FBC7C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829FBC80: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829FBC84: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829FBC88: 388A7300  addi r4, r10, 0x7300
	ctx.r[4].s64 = ctx.r[10].s64 + 29440;
	// 829FBC8C: 38A001F2  li r5, 0x1f2
	ctx.r[5].s64 = 498;
	// 829FBC90: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 829FBC94: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829FBC98: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 829FBC9C: 4845CDA5  bl 0x82e58a40
	ctx.lr = 0x829FBCA0;
	sub_82E58A40(ctx, base);
	// 829FBCA0: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829FBCA4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FBCA8: 419A0008  beq cr6, 0x829fbcb0
	if ctx.cr[6].eq {
	pc = 0x829FBCB0; continue 'dispatch;
	}
	// 829FBCAC: 4B8C4BE5  bl 0x822c0890
	ctx.lr = 0x829FBCB0;
	sub_822C0890(ctx, base);
	// 829FBCB0: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829FBCB4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FBCB8: 419A0008  beq cr6, 0x829fbcc0
	if ctx.cr[6].eq {
	pc = 0x829FBCC0; continue 'dispatch;
	}
	// 829FBCBC: 4B8C4BD5  bl 0x822c0890
	ctx.lr = 0x829FBCC0;
	sub_822C0890(ctx, base);
	// 829FBCC0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 829FBCC4: 487AC4F8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FBCC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829FBCC8 size=984
    let mut pc: u32 = 0x829FBCC8;
    'dispatch: loop {
        match pc {
            0x829FBCC8 => {
    //   block [0x829FBCC8..0x829FC0A0)
	// 829FBCC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FBCCC: 487AC499  bl 0x831a8164
	ctx.lr = 0x829FBCD0;
	sub_831A8130(ctx, base);
	// 829FBCD0: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 829FBCD4: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FBCD8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FBCDC: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 829FBCE0: 48758921  bl 0x83154600
	ctx.lr = 0x829FBCE4;
	sub_83154600(ctx, base);
	// 829FBCE4: 897F0060  lbz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 829FBCE8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829FBCEC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829FBCF0: 409A03A4  bne cr6, 0x829fc094
	if !ctx.cr[6].eq {
	pc = 0x829FC094; continue 'dispatch;
	}
	// 829FBCF4: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 829FBCF8: 39400064  li r10, 0x64
	ctx.r[10].s64 = 100;
	// 829FBCFC: 3BEB6910  addi r31, r11, 0x6910
	ctx.r[31].s64 = ctx.r[11].s64 + 26896;
	// 829FBD00: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829FBD04: 4BB15DE5  bl 0x82511ae8
	ctx.lr = 0x829FBD08;
	sub_82511AE8(ctx, base);
	// 829FBD08: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 829FBD0C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829FBD10: 388B8614  addi r4, r11, -0x79ec
	ctx.r[4].s64 = ctx.r[11].s64 + -31212;
	// 829FBD14: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829FBD18: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 829FBD1C: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 829FBD20: 4BA1B6A1  bl 0x824173c0
	ctx.lr = 0x829FBD24;
	sub_824173C0(ctx, base);
	// 829FBD24: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FBD28: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 829FBD2C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FBD30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FBD34: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 829FBD38: 419A0024  beq cr6, 0x829fbd5c
	if ctx.cr[6].eq {
	pc = 0x829FBD5C; continue 'dispatch;
	}
	// 829FBD3C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829FBD40: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829FBD44: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829FBD48: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829FBD4C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829FBD50: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829FBD54: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829FBD58: 4082FFE8  bne 0x829fbd40
	if !ctx.cr[0].eq {
	pc = 0x829FBD40; continue 'dispatch;
	}
	// 829FBD5C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829FBD60: 3BFD0028  addi r31, r29, 0x28
	ctx.r[31].s64 = ctx.r[29].s64 + 40;
	// 829FBD64: 3B610060  addi r27, r1, 0x60
	ctx.r[27].s64 = ctx.r[1].s64 + 96;
	// 829FBD68: 4860C3C1  bl 0x83008128
	ctx.lr = 0x829FBD6C;
	sub_83008128(ctx, base);
	// 829FBD6C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FBD70: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829FBD74: 3BCB7300  addi r30, r11, 0x7300
	ctx.r[30].s64 = ctx.r[11].s64 + 29440;
	// 829FBD78: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829FBD7C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829FBD80: 38A00202  li r5, 0x202
	ctx.r[5].s64 = 514;
	// 829FBD84: C3EA08A4  lfs f31, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829FBD88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FBD8C: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 829FBD90: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829FBD94: 4845CCAD  bl 0x82e58a40
	ctx.lr = 0x829FBD98;
	sub_82E58A40(ctx, base);
	// 829FBD98: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829FBD9C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FBDA0: 419A0008  beq cr6, 0x829fbda8
	if ctx.cr[6].eq {
	pc = 0x829FBDA8; continue 'dispatch;
	}
	// 829FBDA4: 4B8C4AED  bl 0x822c0890
	ctx.lr = 0x829FBDA8;
	sub_822C0890(ctx, base);
	// 829FBDA8: 806100C4  lwz r3, 0xc4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 829FBDAC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FBDB0: 419A0008  beq cr6, 0x829fbdb8
	if ctx.cr[6].eq {
	pc = 0x829FBDB8; continue 'dispatch;
	}
	// 829FBDB4: 4B8C4ADD  bl 0x822c0890
	ctx.lr = 0x829FBDB8;
	sub_822C0890(ctx, base);
	// 829FBDB8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829FBDBC: 4BB15D2D  bl 0x82511ae8
	ctx.lr = 0x829FBDC0;
	sub_82511AE8(ctx, base);
	// 829FBDC0: 39600320  li r11, 0x320
	ctx.r[11].s64 = 800;
	// 829FBDC4: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 829FBDC8: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829FBDCC: 394100D0  addi r10, r1, 0xd0
	ctx.r[10].s64 = ctx.r[1].s64 + 208;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FC0A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FC0A0 size=220
    let mut pc: u32 = 0x829FC0A0;
    'dispatch: loop {
        match pc {
            0x829FC0A0 => {
    //   block [0x829FC0A0..0x829FC17C)
	// 829FC0A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FC0A4: 487AC0C5  bl 0x831a8168
	ctx.lr = 0x829FC0A8;
	sub_831A8130(ctx, base);
	// 829FC0A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FC0AC: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 829FC0B0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829FC0B4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829FC0B8: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 829FC0BC: 41820038  beq 0x829fc0f4
	if ctx.cr[0].eq {
	pc = 0x829FC0F4; continue 'dispatch;
	}
	// 829FC0C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FC0C4: 487AD8C5  bl 0x831a9988
	ctx.lr = 0x829FC0C8;
	sub_831A9988(ctx, base);
	// 829FC0C8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 829FC0CC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829FC0D0: 386B7660  addi r3, r11, 0x7660
	ctx.r[3].s64 = ctx.r[11].s64 + 30304;
	// 829FC0D4: 487AC025  bl 0x831a80f8
	ctx.lr = 0x829FC0D8;
	sub_831A80F8(ctx, base);
	// 829FC0D8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829FC0DC: 41820018  beq 0x829fc0f4
	if ctx.cr[0].eq {
	pc = 0x829FC0F4; continue 'dispatch;
	}
	// 829FC0E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829FC0E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FC0E8: 4BFFFAF9  bl 0x829fbbe0
	ctx.lr = 0x829FC0EC;
	sub_829FBBE0(ctx, base);
	// 829FC0EC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 829FC0F0: 48000084  b 0x829fc174
	pc = 0x829FC174; continue 'dispatch;
	// 829FC0F4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829FC0F8: 419A006C  beq cr6, 0x829fc164
	if ctx.cr[6].eq {
	pc = 0x829FC164; continue 'dispatch;
	}
	// 829FC0FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FC100: 487AD889  bl 0x831a9988
	ctx.lr = 0x829FC104;
	sub_831A9988(ctx, base);
	// 829FC104: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 829FC108: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829FC10C: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 829FC110: 487ABFE9  bl 0x831a80f8
	ctx.lr = 0x829FC114;
	sub_831A80F8(ctx, base);
	// 829FC114: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829FC118: 41820014  beq 0x829fc12c
	if ctx.cr[0].eq {
	pc = 0x829FC12C; continue 'dispatch;
	}
	// 829FC11C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829FC120: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FC124: 4BFFFBA5  bl 0x829fbcc8
	ctx.lr = 0x829FC128;
	sub_829FBCC8(ctx, base);
	// 829FC128: 4BFFFFC4  b 0x829fc0ec
	pc = 0x829FC0EC; continue 'dispatch;
	// 829FC12C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829FC130: 419A0034  beq cr6, 0x829fc164
	if ctx.cr[6].eq {
	pc = 0x829FC164; continue 'dispatch;
	}
	// 829FC134: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FC138: 487AD851  bl 0x831a9988
	ctx.lr = 0x829FC13C;
	sub_831A9988(ctx, base);
	// 829FC13C: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829FC140: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829FC144: 386BDFE0  addi r3, r11, -0x2020
	ctx.r[3].s64 = ctx.r[11].s64 + -8224;
	// 829FC148: 487ABFB1  bl 0x831a80f8
	ctx.lr = 0x829FC14C;
	sub_831A80F8(ctx, base);
	// 829FC14C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829FC150: 41820014  beq 0x829fc164
	if ctx.cr[0].eq {
	pc = 0x829FC164; continue 'dispatch;
	}
	// 829FC154: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829FC158: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FC15C: 4BFFB4AD  bl 0x829f7608
	ctx.lr = 0x829FC160;
	sub_829F7608(ctx, base);
	// 829FC160: 4BFFFF8C  b 0x829fc0ec
	pc = 0x829FC0EC; continue 'dispatch;
	// 829FC164: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 829FC168: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829FC16C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FC170: 48782319  bl 0x8317e488
	ctx.lr = 0x829FC174;
	sub_8317E488(ctx, base);
	// 829FC174: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829FC178: 487AC040  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FC180(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FC180 size=108
    let mut pc: u32 = 0x829FC180;
    'dispatch: loop {
        match pc {
            0x829FC180 => {
    //   block [0x829FC180..0x829FC1EC)
	// 829FC180: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FC184: 487ABFE9  bl 0x831a816c
	ctx.lr = 0x829FC188;
	sub_831A8130(ctx, base);
	// 829FC188: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FC18C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 829FC190: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829FC194: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829FC198: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829FC19C: 41820038  beq 0x829fc1d4
	if ctx.cr[0].eq {
	pc = 0x829FC1D4; continue 'dispatch;
	}
	// 829FC1A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FC1A4: 487AD7E5  bl 0x831a9988
	ctx.lr = 0x829FC1A8;
	sub_831A9988(ctx, base);
	// 829FC1A8: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 829FC1AC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829FC1B0: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 829FC1B4: 487ABF45  bl 0x831a80f8
	ctx.lr = 0x829FC1B8;
	sub_831A80F8(ctx, base);
	// 829FC1B8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829FC1BC: 41820018  beq 0x829fc1d4
	if ctx.cr[0].eq {
	pc = 0x829FC1D4; continue 'dispatch;
	}
	// 829FC1C0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829FC1C4: 387DFFD8  addi r3, r29, -0x28
	ctx.r[3].s64 = ctx.r[29].s64 + -40;
	// 829FC1C8: 4BFFE9C9  bl 0x829fab90
	ctx.lr = 0x829FC1CC;
	sub_829FAB90(ctx, base);
	// 829FC1CC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 829FC1D0: 48000014  b 0x829fc1e4
	pc = 0x829FC1E4; continue 'dispatch;
	// 829FC1D4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829FC1D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829FC1DC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829FC1E0: 4BB16439  bl 0x82512618
	ctx.lr = 0x829FC1E4;
	sub_82512618(ctx, base);
	// 829FC1E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829FC1E8: 487ABFD4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FC1F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FC1F0 size=88
    let mut pc: u32 = 0x829FC1F0;
    'dispatch: loop {
        match pc {
            0x829FC1F0 => {
    //   block [0x829FC1F0..0x829FC248)
	// 829FC1F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FC1F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829FC1F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829FC1FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829FC200: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FC204: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FC208: 487583F9  bl 0x83154600
	ctx.lr = 0x829FC20C;
	sub_83154600(ctx, base);
	// 829FC20C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829FC210: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FC214: 4845D565  bl 0x82e59778
	ctx.lr = 0x829FC218;
	sub_82E59778(ctx, base);
	// 829FC218: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FC21C: 4BFF1E2D  bl 0x829ee048
	ctx.lr = 0x829FC220;
	sub_829EE048(ctx, base);
	// 829FC220: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FC224: 4845D555  bl 0x82e59778
	ctx.lr = 0x829FC228;
	sub_82E59778(ctx, base);
	// 829FC228: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FC22C: 4BFF1EBD  bl 0x829ee0e8
	ctx.lr = 0x829FC230;
	sub_829EE0E8(ctx, base);
	// 829FC230: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829FC234: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829FC238: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829FC23C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829FC240: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829FC244: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FC248(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829FC248 size=248
    let mut pc: u32 = 0x829FC248;
    'dispatch: loop {
        match pc {
            0x829FC248 => {
    //   block [0x829FC248..0x829FC340)
	// 829FC248: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FC24C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829FC250: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829FC254: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FC258: 487583A9  bl 0x83154600
	ctx.lr = 0x829FC25C;
	sub_83154600(ctx, base);
	// 829FC25C: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 829FC260: 3D408203  lis r10, -0x7dfd
	ctx.r[10].s64 = -2113732608;
	// 829FC264: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FC268: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 829FC26C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FC270: C00BDFAC  lfs f0, -0x2054(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FC274: 3889E814  addi r4, r9, -0x17ec
	ctx.r[4].s64 = ctx.r[9].s64 + -6124;
	// 829FC278: C1AA7BC4  lfs f13, 0x7bc4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(31684 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829FC27C: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 829FC280: D01F0394  stfs f0, 0x394(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(916 as u32), tmp.u32 ) };
	// 829FC284: 483F7785  bl 0x82df3a08
	ctx.lr = 0x829FC288;
	sub_82DF3A08(ctx, base);
	// 829FC288: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829FC28C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829FC290: 809F0160  lwz r4, 0x160(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 829FC294: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829FC298: C04B9450  lfs f2, -0x6bb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 829FC29C: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 829FC2A0: 481B70D9  bl 0x82bb3378
	ctx.lr = 0x829FC2A4;
	sub_82BB3378(ctx, base);
	// 829FC2A4: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829FC2A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FC2AC: 419A0008  beq cr6, 0x829fc2b4
	if ctx.cr[6].eq {
	pc = 0x829FC2B4; continue 'dispatch;
	}
	// 829FC2B0: 4B8C45E1  bl 0x822c0890
	ctx.lr = 0x829FC2B4;
	sub_822C0890(ctx, base);
	// 829FC2B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FC2B8: 483F7171  bl 0x82df3428
	ctx.lr = 0x829FC2BC;
	sub_82DF3428(ctx, base);
	// 829FC2BC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FC2C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FC2C4: 388B6D78  addi r4, r11, 0x6d78
	ctx.r[4].s64 = ctx.r[11].s64 + 28024;
	// 829FC2C8: 483F7741  bl 0x82df3a08
	ctx.lr = 0x829FC2CC;
	sub_82DF3A08(ctx, base);
	// 829FC2CC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 829FC2D0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829FC2D4: 809F0160  lwz r4, 0x160(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 829FC2D8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829FC2DC: C02B6150  lfs f1, 0x6150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829FC2E0: 481B69D9  bl 0x82bb2cb8
	ctx.lr = 0x829FC2E4;
	sub_82BB2CB8(ctx, base);
	// 829FC2E4: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829FC2E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FC2EC: 419A0008  beq cr6, 0x829fc2f4
	if ctx.cr[6].eq {
	pc = 0x829FC2F4; continue 'dispatch;
	}
	// 829FC2F0: 4B8C45A1  bl 0x822c0890
	ctx.lr = 0x829FC2F4;
	sub_822C0890(ctx, base);
	// 829FC2F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FC2F8: 483F7131  bl 0x82df3428
	ctx.lr = 0x829FC2FC;
	sub_82DF3428(ctx, base);
	// 829FC2FC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FC300: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829FC304: 38AB7358  addi r5, r11, 0x7358
	ctx.r[5].s64 = ctx.r[11].s64 + 29528;
	// 829FC308: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829FC30C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FC310: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 829FC314: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829FC318: 4E800421  bctrl
	ctx.lr = 0x829FC31C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829FC31C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 829FC320: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FC324: 419A0008  beq cr6, 0x829fc32c
	if ctx.cr[6].eq {
	pc = 0x829FC32C; continue 'dispatch;
	}
	// 829FC328: 4B8C4569  bl 0x822c0890
	ctx.lr = 0x829FC32C;
	sub_822C0890(ctx, base);
	// 829FC32C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829FC330: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829FC334: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829FC338: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829FC33C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FC340(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829FC340 size=96
    let mut pc: u32 = 0x829FC340;
    'dispatch: loop {
        match pc {
            0x829FC340 => {
    //   block [0x829FC340..0x829FC3A0)
	// 829FC340: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FC344: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829FC348: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829FC34C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FC350: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FC354: 484605D5  bl 0x82e5c928
	ctx.lr = 0x829FC358;
	sub_82E5C928(ctx, base);
	// 829FC358: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829FC35C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 829FC360: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 829FC364: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 829FC368: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FC36C: 39087374  addi r8, r8, 0x7374
	ctx.r[8].s64 = ctx.r[8].s64 + 29556;
	// 829FC370: C00B9594  lfs f0, -0x6a6c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27244 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FC374: C1AADF2C  lfs f13, -0x20d4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8404 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829FC378: C18989AC  lfs f12, -0x7654(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829FC37C: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 829FC380: D01F0064  stfs f0, 0x64(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 829FC384: D1BF0068  stfs f13, 0x68(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 829FC388: D19F006C  stfs f12, 0x6c(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 829FC38C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829FC390: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829FC394: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829FC398: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829FC39C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FC3A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829FC3A0 size=216
    let mut pc: u32 = 0x829FC3A0;
    'dispatch: loop {
        match pc {
            0x829FC3A0 => {
    //   block [0x829FC3A0..0x829FC478)
	// 829FC3A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FC3A4: 487ABDC5  bl 0x831a8168
	ctx.lr = 0x829FC3A8;
	sub_831A8130(ctx, base);
	// 829FC3A8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FC3AC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 829FC3B0: 48758251  bl 0x83154600
	ctx.lr = 0x829FC3B4;
	sub_83154600(ctx, base);
	// 829FC3B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FC3B8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829FC3BC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 829FC3C0: 3BBF0250  addi r29, r31, 0x250
	ctx.r[29].s64 = ctx.r[31].s64 + 592;
	// 829FC3C4: 3BC0000B  li r30, 0xb
	ctx.r[30].s64 = 11;
	// 829FC3C8: 997F0454  stb r11, 0x454(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1108 as u32), ctx.r[11].u8 ) };
	// 829FC3CC: 995C0060  stb r10, 0x60(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(96 as u32), ctx.r[10].u8 ) };
	// 829FC3D0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829FC3D4: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FC3D8: 4BA92F71  bl 0x8248f348
	ctx.lr = 0x829FC3DC;
	sub_8248F348(ctx, base);
	// 829FC3DC: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 829FC3E0: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 829FC3E4: 4082FFEC  bne 0x829fc3d0
	if !ctx.cr[0].eq {
	pc = 0x829FC3D0; continue 'dispatch;
	}
	// 829FC3E8: 3BBF03AC  addi r29, r31, 0x3ac
	ctx.r[29].s64 = ctx.r[31].s64 + 940;
	// 829FC3EC: 3BC00014  li r30, 0x14
	ctx.r[30].s64 = 20;
	// 829FC3F0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829FC3F4: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FC3F8: 48485349  bl 0x82e81740
	ctx.lr = 0x829FC3FC;
	sub_82E81740(ctx, base);
	// 829FC3FC: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 829FC400: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 829FC404: 4082FFEC  bne 0x829fc3f0
	if !ctx.cr[0].eq {
	pc = 0x829FC3F0; continue 'dispatch;
	}
	// 829FC408: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829FC40C: 807F044C  lwz r3, 0x44c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1100 as u32) ) } as u64;
	// 829FC410: 48485331  bl 0x82e81740
	ctx.lr = 0x829FC414;
	sub_82E81740(ctx, base);
	// 829FC414: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 829FC418: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FC41C: 4BFF1985  bl 0x829edda0
	ctx.lr = 0x829FC420;
	sub_829EDDA0(ctx, base);
	// 829FC420: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829FC424: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FC428: 4BFF2E61  bl 0x829ef288
	ctx.lr = 0x829FC42C;
	sub_829EF288(ctx, base);
	// 829FC42C: 3BC30004  addi r30, r3, 4
	ctx.r[30].s64 = ctx.r[3].s64 + 4;
	// 829FC430: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FC434: 4BB156B5  bl 0x82511ae8
	ctx.lr = 0x829FC438;
	sub_82511AE8(ctx, base);
	// 829FC438: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 829FC43C: C1A30004  lfs f13, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829FC440: C19E0000  lfs f12, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829FC444: C00BD7BC  lfs f0, -0x2844(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FC448: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 829FC44C: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 829FC450: 41990010  bgt cr6, 0x829fc460
	if ctx.cr[6].gt {
	pc = 0x829FC460; continue 'dispatch;
	}
	// 829FC454: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 829FC458: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FC45C: 4BFF1945  bl 0x829edda0
	ctx.lr = 0x829FC460;
	sub_829EDDA0(ctx, base);
	// 829FC460: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FC464: 4BB15685  bl 0x82511ae8
	ctx.lr = 0x829FC468;
	sub_82511AE8(ctx, base);
	// 829FC468: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FC46C: D01C0070  stfs f0, 0x70(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 829FC470: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 829FC474: 487ABD44  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FC478(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829FC478 size=472
    let mut pc: u32 = 0x829FC478;
    'dispatch: loop {
        match pc {
            0x829FC478 => {
    //   block [0x829FC478..0x829FC650)
	// 829FC478: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FC47C: 487ABCE9  bl 0x831a8164
	ctx.lr = 0x829FC480;
	sub_831A8130(ctx, base);
	// 829FC480: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FC484: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 829FC488: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 829FC48C: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 829FC490: 48758171  bl 0x83154600
	ctx.lr = 0x829FC494;
	sub_83154600(ctx, base);
	// 829FC494: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FC498: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829FC49C: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 829FC4A0: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 829FC4A4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829FC4A8: 997F0454  stb r11, 0x454(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1108 as u32), ctx.r[11].u8 ) };
	// 829FC4AC: 807F0158  lwz r3, 0x158(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(344 as u32) ) } as u64;
	// 829FC4B0: 808AD930  lwz r4, -0x26d0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-9936 as u32) ) } as u64;
	// 829FC4B4: C0290B54  lfs f1, 0xb54(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2900 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829FC4B8: 4841A671  bl 0x82e16b28
	ctx.lr = 0x829FC4BC;
	sub_82E16B28(ctx, base);
	// 829FC4BC: 3BBF03AC  addi r29, r31, 0x3ac
	ctx.r[29].s64 = ctx.r[31].s64 + 940;
	// 829FC4C0: 3BC00014  li r30, 0x14
	ctx.r[30].s64 = 20;
	// 829FC4C4: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FC4C8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FC4CC: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 829FC4D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829FC4D4: 4E800421  bctrl
	ctx.lr = 0x829FC4D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829FC4D8: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 829FC4DC: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 829FC4E0: 4082FFE4  bne 0x829fc4c4
	if !ctx.cr[0].eq {
	pc = 0x829FC4C4; continue 'dispatch;
	}
	// 829FC4E4: 3BBF0250  addi r29, r31, 0x250
	ctx.r[29].s64 = ctx.r[31].s64 + 592;
	// 829FC4E8: 3BC0000B  li r30, 0xb
	ctx.r[30].s64 = 11;
	// 829FC4EC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829FC4F0: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FC4F4: 4BA92E55  bl 0x8248f348
	ctx.lr = 0x829FC4F8;
	sub_8248F348(ctx, base);
	// 829FC4F8: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 829FC4FC: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 829FC500: 4082FFEC  bne 0x829fc4ec
	if !ctx.cr[0].eq {
	pc = 0x829FC4EC; continue 'dispatch;
	}
	// 829FC504: 897C0060  lbz r11, 0x60(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(96 as u32) ) } as u64;
	// 829FC508: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829FC50C: 409A013C  bne cr6, 0x829fc648
	if !ctx.cr[6].eq {
	pc = 0x829FC648; continue 'dispatch;
	}
	// 829FC510: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FC514: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829FC518: 388B73B0  addi r4, r11, 0x73b0
	ctx.r[4].s64 = ctx.r[11].s64 + 29616;
	// 829FC51C: 38A000E3  li r5, 0xe3
	ctx.r[5].s64 = 227;
	// 829FC520: 386000A8  li r3, 0xa8
	ctx.r[3].s64 = 168;
	// 829FC524: 483F5EC5  bl 0x82df23e8
	ctx.lr = 0x829FC528;
	sub_82DF23E8(ctx, base);
	// 829FC528: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 829FC52C: 41820038  beq 0x829fc564
	if ctx.cr[0].eq {
	pc = 0x829FC564; continue 'dispatch;
	}
	// 829FC530: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829FC534: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829FC538: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 829FC53C: 4BB12F8D  bl 0x8250f4c8
	ctx.lr = 0x829FC540;
	sub_8250F4C8(ctx, base);
	// 829FC540: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FC544: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FC548: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 829FC54C: 409A0008  bne cr6, 0x829fc554
	if !ctx.cr[6].eq {
	pc = 0x829FC554; continue 'dispatch;
	}
	// 829FC550: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829FC554: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FC558: 4BDD3FF9  bl 0x827d0550
	ctx.lr = 0x829FC55C;
	sub_827D0550(ctx, base);
	// 829FC55C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829FC560: 48000008  b 0x829fc568
	pc = 0x829FC568; continue 'dispatch;
	// 829FC564: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 829FC568: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 829FC56C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829FC570: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829FC574: 4BC74395  bl 0x82670908
	ctx.lr = 0x829FC578;
	sub_82670908(ctx, base);
	// 829FC578: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829FC57C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829FC580: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829FC584: 4B8C3A7D  bl 0x822c0000
	ctx.lr = 0x829FC588;
	sub_822C0000(ctx, base);
	// 829FC588: 576B07FF  clrlwi. r11, r27, 0x1f
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829FC58C: 4182000C  beq 0x829fc598
	if ctx.cr[0].eq {
	pc = 0x829FC598; continue 'dispatch;
	}
	// 829FC590: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829FC594: 483F56FD  bl 0x82df1c90
	ctx.lr = 0x829FC598;
	sub_82DF1C90(ctx, base);
	// 829FC598: 817F014C  lwz r11, 0x14c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(332 as u32) ) } as u64;
	// 829FC59C: 815F0148  lwz r10, 0x148(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(328 as u32) ) } as u64;
	// 829FC5A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FC5A4: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 829FC5A8: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 829FC5AC: 419A0024  beq cr6, 0x829fc5d0
	if ctx.cr[6].eq {
	pc = 0x829FC5D0; continue 'dispatch;
	}
	// 829FC5B0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829FC5B4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829FC5B8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829FC5BC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829FC5C0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829FC5C4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829FC5C8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829FC5CC: 4082FFE8  bne 0x829fc5b4
	if !ctx.cr[0].eq {
	pc = 0x829FC5B4; continue 'dispatch;
	}
	// 829FC5D0: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 829FC5D4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829FC5D8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829FC5DC: 3BCBD938  addi r30, r11, -0x26c8
	ctx.r[30].s64 = ctx.r[11].s64 + -9928;
	// 829FC5E0: 3BA10058  addi r29, r1, 0x58
	ctx.r[29].s64 = ctx.r[1].s64 + 88;
	// 829FC5E4: 4BB12EE5  bl 0x8250f4c8
	ctx.lr = 0x829FC5E8;
	sub_8250F4C8(ctx, base);
	// 829FC5E8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829FC5EC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829FC5F0: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829FC5F4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 829FC5F8: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 829FC5FC: 38E00006  li r7, 6
	ctx.r[7].s64 = 6;
	// 829FC600: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829FC604: 4BDD2E3D  bl 0x827cf440
	ctx.lr = 0x829FC608;
	sub_827CF440(ctx, base);
	// 829FC608: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829FC60C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FC610: 419A0008  beq cr6, 0x829fc618
	if ctx.cr[6].eq {
	pc = 0x829FC618; continue 'dispatch;
	}
	// 829FC614: 4B8C427D  bl 0x822c0890
	ctx.lr = 0x829FC618;
	sub_822C0890(ctx, base);
	// 829FC618: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FC61C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829FC620: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829FC624: 38AA7398  addi r5, r10, 0x7398
	ctx.r[5].s64 = ctx.r[10].s64 + 29592;
	// 829FC628: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829FC62C: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 829FC630: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829FC634: 4E800421  bctrl
	ctx.lr = 0x829FC638;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829FC638: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 829FC63C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FC640: 419A0008  beq cr6, 0x829fc648
	if ctx.cr[6].eq {
	pc = 0x829FC648; continue 'dispatch;
	}
	// 829FC644: 4B8C424D  bl 0x822c0890
	ctx.lr = 0x829FC648;
	sub_822C0890(ctx, base);
	// 829FC648: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 829FC64C: 487ABB68  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FC650(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829FC650 size=1320
    let mut pc: u32 = 0x829FC650;
    'dispatch: loop {
        match pc {
            0x829FC650 => {
    //   block [0x829FC650..0x829FCB78)
	// 829FC650: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FC654: 487ABB19  bl 0x831a816c
	ctx.lr = 0x829FC658;
	sub_831A8130(ctx, base);
	// 829FC658: DBA1FFC8  stfd f29, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[29].u64 ) };
	// 829FC65C: DBC1FFD0  stfd f30, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 829FC660: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 829FC664: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FC668: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 829FC66C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FC670: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 829FC674: 48757F8D  bl 0x83154600
	ctx.lr = 0x829FC678;
	sub_83154600(ctx, base);
	// 829FC678: 897F0060  lbz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 829FC67C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829FC680: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829FC684: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829FC688: 41980378  blt cr6, 0x829fca00
	if ctx.cr[6].lt {
	pc = 0x829FCA00; continue 'dispatch;
	}
	// 829FC68C: 419A00FC  beq cr6, 0x829fc788
	if ctx.cr[6].eq {
	pc = 0x829FC788; continue 'dispatch;
	}
	// 829FC690: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 829FC694: 409804D0  bge cr6, 0x829fcb64
	if !ctx.cr[6].lt {
	pc = 0x829FCB64; continue 'dispatch;
	}
	// 829FC698: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FC69C: 4845D0C5  bl 0x82e59760
	ctx.lr = 0x829FC6A0;
	sub_82E59760(ctx, base);
	// 829FC6A0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829FC6A4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829FC6A8: 807E0158  lwz r3, 0x158(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(344 as u32) ) } as u64;
	// 829FC6AC: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 829FC6B0: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 829FC6B4: 3D008338  lis r8, -0x7cc8
	ctx.r[8].s64 = -2093481984;
	// 829FC6B8: C00B9524  lfs f0, -0x6adc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FC6BC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829FC6C0: C1AA08A8  lfs f13, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829FC6C4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829FC6C8: ED81683C  fnmsubs f12, f1, f0, f13
	ctx.f[12].f64 = -(((ctx.f[1].f64 * ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 829FC6CC: C3E908A4  lfs f31, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829FC6D0: C0070A94  lfs f0, 0xa94(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(2708 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FC6D4: 8088D930  lwz r4, -0x26d0(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-9936 as u32) ) } as u64;
	// 829FC6D8: C1AB964C  lfs f13, -0x69b4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829FC6DC: FD8CFB2E  fsel f12, f12, f12, f31
	ctx.f[12].f64 = if ctx.f[12].f64 >= 0.0 { ctx.f[12].f64 } else { ctx.f[31].f64 };
	// 829FC6E0: EC2C6838  fmsubs f1, f12, f0, f13
	ctx.f[1].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 829FC6E4: 4841A445  bl 0x82e16b28
	ctx.lr = 0x829FC6E8;
	sub_82E16B28(ctx, base);
	// 829FC6E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FC6EC: 4845D075  bl 0x82e59760
	ctx.lr = 0x829FC6F0;
	sub_82E59760(ctx, base);
	// 829FC6F0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829FC6F4: C00B9450  lfs f0, -0x6bb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FC6F8: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 829FC6FC: 41980468  blt cr6, 0x829fcb64
	if ctx.cr[6].lt {
	pc = 0x829FCB64; continue 'dispatch;
	}
	// 829FC700: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829FC704: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829FC708: 4BFF2FB1  bl 0x829ef6b8
	ctx.lr = 0x829FC70C;
	sub_829EF6B8(ctx, base);
	// 829FC70C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FC710: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829FC714: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FC718: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FC71C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 829FC720: 419A0024  beq cr6, 0x829fc744
	if ctx.cr[6].eq {
	pc = 0x829FC744; continue 'dispatch;
	}
	// 829FC724: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829FC728: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829FC72C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829FC730: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829FC734: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829FC738: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829FC73C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829FC740: 4082FFE8  bne 0x829fc728
	if !ctx.cr[0].eq {
	pc = 0x829FC728; continue 'dispatch;
	}
	// 829FC744: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 829FC748: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829FC74C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829FC750: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 829FC754: 389E00E8  addi r4, r30, 0xe8
	ctx.r[4].s64 = ctx.r[30].s64 + 232;
	// 829FC758: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829FC75C: 48461F4D  bl 0x82e5e6a8
	ctx.lr = 0x829FC760;
	sub_82E5E6A8(ctx, base);
	// 829FC760: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 829FC764: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FC768: 419A0008  beq cr6, 0x829fc770
	if ctx.cr[6].eq {
	pc = 0x829FC770; continue 'dispatch;
	}
	// 829FC76C: 4B8C4125  bl 0x822c0890
	ctx.lr = 0x829FC770;
	sub_822C0890(ctx, base);
	// 829FC770: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829FC774: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FC778: 419A0008  beq cr6, 0x829fc780
	if ctx.cr[6].eq {
	pc = 0x829FC780; continue 'dispatch;
	}
	// 829FC77C: 4B8C4115  bl 0x822c0890
	ctx.lr = 0x829FC780;
	sub_822C0890(ctx, base);
	// 829FC780: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 829FC784: 4800026C  b 0x829fc9f0
	pc = 0x829FC9F0; continue 'dispatch;
	// 829FC788: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829FC78C: 807E0158  lwz r3, 0x158(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(344 as u32) ) } as u64;
	// 829FC790: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 829FC794: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829FC798: C3CA08A8  lfs f30, 0x8a8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 829FC79C: 808BD930  lwz r4, -0x26d0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9936 as u32) ) } as u64;
	// 829FC7A0: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 829FC7A4: 4841A385  bl 0x82e16b28
	ctx.lr = 0x829FC7A8;
	sub_82E16B28(ctx, base);
	// 829FC7A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FC7AC: 4BFF17BD  bl 0x829edf68
	ctx.lr = 0x829FC7B0;
	sub_829EDF68(ctx, base);
	// 829FC7B0: 39630019  addi r11, r3, 0x19
	ctx.r[11].s64 = ctx.r[3].s64 + 25;
	// 829FC7B4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 829FC7B8: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829FC7BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FC7C0: C3EA9524  lfs f31, -0x6adc(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829FC7C4: 7C0BFC2E  lfsx f0, r11, r31
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FC7C8: EFA0F828  fsubs f29, f0, f31
	ctx.f[29].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 829FC7CC: 4BFF179D  bl 0x829edf68
	ctx.lr = 0x829FC7D0;
	sub_829EDF68(ctx, base);
	// 829FC7D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FC7D4: 4845CF8D  bl 0x82e59760
	ctx.lr = 0x829FC7D8;
	sub_82E59760(ctx, base);
	// 829FC7D8: FF01E800  fcmpu cr6, f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[29].f64);
	// 829FC7DC: 41980064  blt cr6, 0x829fc840
	if ctx.cr[6].lt {
	pc = 0x829FC840; continue 'dispatch;
	}
	// 829FC7E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FC7E4: 4845CF7D  bl 0x82e59760
	ctx.lr = 0x829FC7E8;
	sub_82E59760(ctx, base);
	// 829FC7E8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 829FC7EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FC7F0: C00B89AC  lfs f0, -0x7654(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FC7F4: EFA10032  fmuls f29, f1, f0
	ctx.f[29].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 829FC7F8: 4BB152F1  bl 0x82511ae8
	ctx.lr = 0x829FC7FC;
	sub_82511AE8(ctx, base);
	// 829FC7FC: 396100B0  addi r11, r1, 0xb0
	ctx.r[11].s64 = ctx.r[1].s64 + 176;
	// 829FC800: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829FC804: 3D408212  lis r10, -0x7dee
	ctx.r[10].s64 = -2112749568;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FCB78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829FCB78 size=272
    let mut pc: u32 = 0x829FCB78;
    'dispatch: loop {
        match pc {
            0x829FCB78 => {
    //   block [0x829FCB78..0x829FCC88)
	// 829FCB78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FCB7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829FCB80: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829FCB84: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FCB88: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FCB8C: 4845FD9D  bl 0x82e5c928
	ctx.lr = 0x829FCB90;
	sub_82E5C928(ctx, base);
	// 829FCB90: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 829FCB94: 3D008203  lis r8, -0x7dfd
	ctx.r[8].s64 = -2113732608;
	// 829FCB98: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 829FCB9C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 829FCBA0: 38E77420  addi r7, r7, 0x7420
	ctx.r[7].s64 = ctx.r[7].s64 + 29728;
	// 829FCBA4: C00908A8  lfs f0, 0x8a8(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FCBA8: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 829FCBAC: C1887BC4  lfs f12, 0x7bc4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(31684 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829FCBB0: 90FF0000  stw r7, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 829FCBB4: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 829FCBB8: D01F0068  stfs f0, 0x68(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 829FCBBC: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 829FCBC0: C1AA9450  lfs f13, -0x6bb0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829FCBC4: D19F006C  stfs f12, 0x6c(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 829FCBC8: 397F00A0  addi r11, r31, 0xa0
	ctx.r[11].s64 = ctx.r[31].s64 + 160;
	// 829FCBCC: D01F007C  stfs f0, 0x7c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 829FCBD0: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 829FCBD4: D01F0080  stfs f0, 0x80(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 829FCBD8: D01F0084  stfs f0, 0x84(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 829FCBDC: D01F0088  stfs f0, 0x88(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 829FCBE0: D01F008C  stfs f0, 0x8c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 829FCBE4: D01F0090  stfs f0, 0x90(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 829FCBE8: D01F0098  stfs f0, 0x98(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 829FCBEC: D19F009C  stfs f12, 0x9c(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 829FCBF0: C169603C  lfs f11, 0x603c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(24636 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829FCBF4: C1889524  lfs f12, -0x6adc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829FCBF8: C0076244  lfs f0, 0x6244(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(25156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FCBFC: D1BF0064  stfs f13, 0x64(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 829FCC00: D1BF0070  stfs f13, 0x70(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 829FCC04: D1BF0074  stfs f13, 0x74(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 829FCC08: D1BF0078  stfs f13, 0x78(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 829FCC0C: D1BF0094  stfs f13, 0x94(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 829FCC10: C14BFFC4  lfs f10, -0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-60 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 829FCC14: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 829FCC18: C12BFFD0  lfs f9, -0x30(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-48 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 829FCC1C: ED4D5024  fdivs f10, f13, f10
	ctx.f[10].f64 = ((ctx.f[13].f64 / ctx.f[10].f64) as f32) as f64;
	// 829FCC20: C10BFFDC  lfs f8, -0x24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-36 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 829FCC24: ED204824  fdivs f9, f0, f9
	ctx.f[9].f64 = ((ctx.f[0].f64 / ctx.f[9].f64) as f32) as f64;
	// 829FCC28: C0EBFFE8  lfs f7, -0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 829FCC2C: ED0C4024  fdivs f8, f12, f8
	ctx.f[8].f64 = ((ctx.f[12].f64 / ctx.f[8].f64) as f32) as f64;
	// 829FCC30: C0CBFFF4  lfs f6, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 829FCC34: ECED3824  fdivs f7, f13, f7
	ctx.f[7].f64 = ((ctx.f[13].f64 / ctx.f[7].f64) as f32) as f64;
	// 829FCC38: ECCB3024  fdivs f6, f11, f6
	ctx.f[6].f64 = ((ctx.f[11].f64 / ctx.f[6].f64) as f32) as f64;
	// 829FCC3C: D14B0000  stfs f10, 0(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829FCC40: D12B000C  stfs f9, 0xc(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829FCC44: D10B0018  stfs f8, 0x18(r11)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 829FCC48: D0EB0024  stfs f7, 0x24(r11)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 829FCC4C: D0CB0030  stfs f6, 0x30(r11)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 829FCC50: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829FCC54: 4082FFBC  bne 0x829fcc10
	if !ctx.cr[0].eq {
	pc = 0x829FCC10; continue 'dispatch;
	}
	// 829FCC58: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829FCC5C: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 829FCC60: 39200003  li r9, 3
	ctx.r[9].s64 = 3;
	// 829FCC64: 997F00DC  stb r11, 0xdc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), ctx.r[11].u8 ) };
	// 829FCC68: 995F00DD  stb r10, 0xdd(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(221 as u32), ctx.r[10].u8 ) };
	// 829FCC6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FCC70: 993F00DE  stb r9, 0xde(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(222 as u32), ctx.r[9].u8 ) };
	// 829FCC74: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829FCC78: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829FCC7C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829FCC80: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829FCC84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FCC88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FCC88 size=68
    let mut pc: u32 = 0x829FCC88;
    'dispatch: loop {
        match pc {
            0x829FCC88 => {
    //   block [0x829FCC88..0x829FCCCC)
	// 829FCC88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FCC8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829FCC90: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829FCC94: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FCC98: 48757969  bl 0x83154600
	ctx.lr = 0x829FCC9C;
	sub_83154600(ctx, base);
	// 829FCC9C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FCCA0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829FCCA4: 807F03A4  lwz r3, 0x3a4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(932 as u32) ) } as u64;
	// 829FCCA8: 48484A99  bl 0x82e81740
	ctx.lr = 0x829FCCAC;
	sub_82E81740(ctx, base);
	// 829FCCAC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829FCCB0: 807F044C  lwz r3, 0x44c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1100 as u32) ) } as u64;
	// 829FCCB4: 48484A8D  bl 0x82e81740
	ctx.lr = 0x829FCCB8;
	sub_82E81740(ctx, base);
	// 829FCCB8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829FCCBC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829FCCC0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829FCCC4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829FCCC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FCCD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FCCD0 size=112
    let mut pc: u32 = 0x829FCCD0;
    'dispatch: loop {
        match pc {
            0x829FCCD0 => {
    //   block [0x829FCCD0..0x829FCD40)
	// 829FCCD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FCCD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829FCCD8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829FCCDC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FCCE0: 48757921  bl 0x83154600
	ctx.lr = 0x829FCCE4;
	sub_83154600(ctx, base);
	// 829FCCE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FCCE8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FCCEC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FCCF0: 38AB7458  addi r5, r11, 0x7458
	ctx.r[5].s64 = ctx.r[11].s64 + 29784;
	// 829FCCF4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829FCCF8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FCCFC: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 829FCD00: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829FCD04: 4E800421  bctrl
	ctx.lr = 0x829FCD08;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829FCD08: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829FCD0C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FCD10: 419A0008  beq cr6, 0x829fcd18
	if ctx.cr[6].eq {
	pc = 0x829FCD18; continue 'dispatch;
	}
	// 829FCD14: 4B8C3B7D  bl 0x822c0890
	ctx.lr = 0x829FCD18;
	sub_822C0890(ctx, base);
	// 829FCD18: 807F03A4  lwz r3, 0x3a4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(932 as u32) ) } as u64;
	// 829FCD1C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FCD20: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 829FCD24: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829FCD28: 4E800421  bctrl
	ctx.lr = 0x829FCD2C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829FCD2C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829FCD30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829FCD34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829FCD38: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829FCD3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FCD40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FCD40 size=196
    let mut pc: u32 = 0x829FCD40;
    'dispatch: loop {
        match pc {
            0x829FCD40 => {
    //   block [0x829FCD40..0x829FCE04)
	// 829FCD40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FCD44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829FCD48: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829FCD4C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829FCD50: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FCD54: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829FCD58: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829FCD5C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829FCD60: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829FCD64: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829FCD68: 4B8C3BD1  bl 0x822c0938
	ctx.lr = 0x829FCD6C;
	sub_822C0938(ctx, base);
	// 829FCD6C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829FCD70: 41820028  beq 0x829fcd98
	if ctx.cr[0].eq {
	pc = 0x829FCD98; continue 'dispatch;
	}
	// 829FCD74: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FCD78: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829FCD7C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829FCD80: 392B7448  addi r9, r11, 0x7448
	ctx.r[9].s64 = ctx.r[11].s64 + 29768;
	// 829FCD84: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829FCD88: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829FCD8C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829FCD90: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829FCD94: 48000008  b 0x829fcd9c
	pc = 0x829FCD9C; continue 'dispatch;
	// 829FCD98: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829FCD9C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829FCDA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FCDA4: 409A0044  bne cr6, 0x829fcde8
	if !ctx.cr[6].eq {
	pc = 0x829FCDE8; continue 'dispatch;
	}
	// 829FCDA8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829FCDAC: 419A001C  beq cr6, 0x829fcdc8
	if ctx.cr[6].eq {
	pc = 0x829FCDC8; continue 'dispatch;
	}
	// 829FCDB0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FCDB4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829FCDB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FCDBC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FCDC0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829FCDC4: 4E800421  bctrl
	ctx.lr = 0x829FCDC8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829FCDC8: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829FCDCC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829FCDD0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FCDD4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829FCDD8: 816BE290  lwz r11, -0x1d70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7536 as u32) ) } as u64;
	// 829FCDDC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829FCDE0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829FCDE4: 4B8C321D  bl 0x822c0000
	ctx.lr = 0x829FCDE8;
	sub_822C0000(ctx, base);
	// 829FCDE8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FCDEC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829FCDF0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829FCDF4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829FCDF8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829FCDFC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829FCE00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FCE08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829FCE08 size=280
    let mut pc: u32 = 0x829FCE08;
    'dispatch: loop {
        match pc {
            0x829FCE08 => {
    //   block [0x829FCE08..0x829FCF20)
	// 829FCE08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FCE0C: 487AB361  bl 0x831a816c
	ctx.lr = 0x829FCE10;
	sub_831A8130(ctx, base);
	// 829FCE10: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FCE14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FCE18: 487577E9  bl 0x83154600
	ctx.lr = 0x829FCE1C;
	sub_83154600(ctx, base);
	// 829FCE1C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829FCE20: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829FCE24: 997F00EC  stb r11, 0xec(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u8 ) };
	// 829FCE28: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829FCE2C: 997F0060  stb r11, 0x60(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u8 ) };
	// 829FCE30: 3BAA6E3C  addi r29, r10, 0x6e3c
	ctx.r[29].s64 = ctx.r[10].s64 + 28220;
	// 829FCE34: 997F00ED  stb r11, 0xed(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(237 as u32), ctx.r[11].u8 ) };
	// 829FCE38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FCE3C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829FCE40: 483F6BC9  bl 0x82df3a08
	ctx.lr = 0x829FCE44;
	sub_82DF3A08(ctx, base);
	// 829FCE44: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 829FCE48: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829FCE4C: 809E0160  lwz r4, 0x160(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(352 as u32) ) } as u64;
	// 829FCE50: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829FCE54: C04B6150  lfs f2, 0x6150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 829FCE58: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 829FCE5C: 481B651D  bl 0x82bb3378
	ctx.lr = 0x829FCE60;
	sub_82BB3378(ctx, base);
	// 829FCE60: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829FCE64: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FCE68: 419A0008  beq cr6, 0x829fce70
	if ctx.cr[6].eq {
	pc = 0x829FCE70; continue 'dispatch;
	}
	// 829FCE6C: 4B8C3A25  bl 0x822c0890
	ctx.lr = 0x829FCE70;
	sub_822C0890(ctx, base);
	// 829FCE70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FCE74: 483F65B5  bl 0x82df3428
	ctx.lr = 0x829FCE78;
	sub_82DF3428(ctx, base);
	// 829FCE78: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829FCE7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FCE80: 483F6B89  bl 0x82df3a08
	ctx.lr = 0x829FCE84;
	sub_82DF3A08(ctx, base);
	// 829FCE84: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829FCE88: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829FCE8C: 809E0160  lwz r4, 0x160(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(352 as u32) ) } as u64;
	// 829FCE90: 481B5D39  bl 0x82bb2bc8
	ctx.lr = 0x829FCE94;
	sub_82BB2BC8(ctx, base);
	// 829FCE94: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829FCE98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FCE9C: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FCEA0: 4BFF10C9  bl 0x829edf68
	ctx.lr = 0x829FCEA4;
	sub_829EDF68(ctx, base);
	// 829FCEA4: 897F0060  lbz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 829FCEA8: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829FCEAC: 1D6B0003  mulli r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 * 3;
	// 829FCEB0: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 829FCEB4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829FCEB8: 396B0019  addi r11, r11, 0x19
	ctx.r[11].s64 = ctx.r[11].s64 + 25;
	// 829FCEBC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829FCEC0: 7C2BFC2E  lfsx f1, r11, r31
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829FCEC4: 481BBBAD  bl 0x82bb8a70
	ctx.lr = 0x829FCEC8;
	sub_82BB8A70(ctx, base);
	// 829FCEC8: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829FCECC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FCED0: 419A0008  beq cr6, 0x829fced8
	if ctx.cr[6].eq {
	pc = 0x829FCED8; continue 'dispatch;
	}
	// 829FCED4: 4B8C39BD  bl 0x822c0890
	ctx.lr = 0x829FCED8;
	sub_822C0890(ctx, base);
	// 829FCED8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FCEDC: 483F654D  bl 0x82df3428
	ctx.lr = 0x829FCEE0;
	sub_82DF3428(ctx, base);
	// 829FCEE0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FCEE4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829FCEE8: 38AB7208  addi r5, r11, 0x7208
	ctx.r[5].s64 = ctx.r[11].s64 + 29192;
	// 829FCEEC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829FCEF0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FCEF4: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 829FCEF8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829FCEFC: 4E800421  bctrl
	ctx.lr = 0x829FCF00;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829FCF00: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 829FCF04: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FCF08: 419A0008  beq cr6, 0x829fcf10
	if ctx.cr[6].eq {
	pc = 0x829FCF10; continue 'dispatch;
	}
	// 829FCF0C: 4B8C3985  bl 0x822c0890
	ctx.lr = 0x829FCF10;
	sub_822C0890(ctx, base);
	// 829FCF10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FCF14: 4BFFFDBD  bl 0x829fccd0
	ctx.lr = 0x829FCF18;
	sub_829FCCD0(ctx, base);
	// 829FCF18: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 829FCF1C: 487AB2A0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FCF20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829FCF20 size=2428
    let mut pc: u32 = 0x829FCF20;
    'dispatch: loop {
        match pc {
            0x829FCF20 => {
    //   block [0x829FCF20..0x829FD89C)
	// 829FCF20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FCF24: 487AB241  bl 0x831a8164
	ctx.lr = 0x829FCF28;
	sub_831A8130(ctx, base);
	// 829FCF28: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 829FCF2C: 9421FE70  stwu r1, -0x190(r1)
	ea = ctx.r[1].u32.wrapping_add(-400 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FCF30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FCF34: 487576CD  bl 0x83154600
	ctx.lr = 0x829FCF38;
	sub_83154600(ctx, base);
	// 829FCF38: 897F0060  lbz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 829FCF3C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829FCF40: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829FCF44: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829FCF48: 419807B8  blt cr6, 0x829fd700
	if ctx.cr[6].lt {
	pc = 0x829FD700; continue 'dispatch;
	}
	// 829FCF4C: 419A04BC  beq cr6, 0x829fd408
	if ctx.cr[6].eq {
	pc = 0x829FD408; continue 'dispatch;
	}
	// 829FCF50: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 829FCF54: 41980248  blt cr6, 0x829fd19c
	if ctx.cr[6].lt {
	pc = 0x829FD19C; continue 'dispatch;
	}
	// 829FCF58: 419A00E0  beq cr6, 0x829fd038
	if ctx.cr[6].eq {
	pc = 0x829FD038; continue 'dispatch;
	}
	// 829FCF5C: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 829FCF60: 40980920  bge cr6, 0x829fd880
	if !ctx.cr[6].lt {
	pc = 0x829FD880; continue 'dispatch;
	}
	// 829FCF64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FCF68: 4845C7F9  bl 0x82e59760
	ctx.lr = 0x829FCF6C;
	sub_82E59760(ctx, base);
	// 829FCF6C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FCF70: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 829FCF74: 4BFF0FF5  bl 0x829edf68
	ctx.lr = 0x829FCF78;
	sub_829EDF68(ctx, base);
	// 829FCF78: 897F0060  lbz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 829FCF7C: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829FCF80: 1D6B0003  mulli r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 * 3;
	// 829FCF84: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 829FCF88: 396B0028  addi r11, r11, 0x28
	ctx.r[11].s64 = ctx.r[11].s64 + 40;
	// 829FCF8C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829FCF90: 7C0BFC2E  lfsx f0, r11, r31
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FCF94: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 829FCF98: 419808E8  blt cr6, 0x829fd880
	if ctx.cr[6].lt {
	pc = 0x829FD880; continue 'dispatch;
	}
	// 829FCF9C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829FCFA0: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 829FCFA4: 4BFF2715  bl 0x829ef6b8
	ctx.lr = 0x829FCFA8;
	sub_829EF6B8(ctx, base);
	// 829FCFA8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FCFAC: 91610090  stw r11, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 829FCFB0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FCFB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FCFB8: 91610094  stw r11, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 829FCFBC: 419A0024  beq cr6, 0x829fcfe0
	if ctx.cr[6].eq {
	pc = 0x829FCFE0; continue 'dispatch;
	}
	// 829FCFC0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829FCFC4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829FCFC8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829FCFCC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829FCFD0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829FCFD4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829FCFD8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829FCFDC: 4082FFE8  bne 0x829fcfc4
	if !ctx.cr[0].eq {
	pc = 0x829FCFC4; continue 'dispatch;
	}
	// 829FCFE0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829FCFE4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 829FCFE8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829FCFEC: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 829FCFF0: 389E00E8  addi r4, r30, 0xe8
	ctx.r[4].s64 = ctx.r[30].s64 + 232;
	// 829FCFF4: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 829FCFF8: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829FCFFC: 484616AD  bl 0x82e5e6a8
	ctx.lr = 0x829FD000;
	sub_82E5E6A8(ctx, base);
	// 829FD000: 806100BC  lwz r3, 0xbc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 829FD004: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FD008: 419A0008  beq cr6, 0x829fd010
	if ctx.cr[6].eq {
	pc = 0x829FD010; continue 'dispatch;
	}
	// 829FD00C: 4B8C3885  bl 0x822c0890
	ctx.lr = 0x829FD010;
	sub_822C0890(ctx, base);
	// 829FD010: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 829FD014: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FD018: 419A0008  beq cr6, 0x829fd020
	if ctx.cr[6].eq {
	pc = 0x829FD020; continue 'dispatch;
	}
	// 829FD01C: 4B8C3875  bl 0x822c0890
	ctx.lr = 0x829FD020;
	sub_822C0890(ctx, base);
	// 829FD020: 806100AC  lwz r3, 0xac(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 829FD024: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FD028: 419A0008  beq cr6, 0x829fd030
	if ctx.cr[6].eq {
	pc = 0x829FD030; continue 'dispatch;
	}
	// 829FD02C: 4B8C3865  bl 0x822c0890
	ctx.lr = 0x829FD030;
	sub_822C0890(ctx, base);
	// 829FD030: 807E044C  lwz r3, 0x44c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1100 as u32) ) } as u64;
	// 829FD034: 48000844  b 0x829fd878
	pc = 0x829FD878; continue 'dispatch;
	// 829FD038: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FD03C: 4845C725  bl 0x82e59760
	ctx.lr = 0x829FD040;
	sub_82E59760(ctx, base);
	// 829FD040: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FD044: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 829FD048: 4BFF0F21  bl 0x829edf68
	ctx.lr = 0x829FD04C;
	sub_829EDF68(ctx, base);
	// 829FD04C: 897F0060  lbz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 829FD050: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829FD054: 1D6B0003  mulli r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 * 3;
	// 829FD058: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 829FD05C: 396B0028  addi r11, r11, 0x28
	ctx.r[11].s64 = ctx.r[11].s64 + 40;
	// 829FD060: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829FD064: 7C0BFC2E  lfsx f0, r11, r31
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FD068: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 829FD06C: 41980814  blt cr6, 0x829fd880
	if ctx.cr[6].lt {
	pc = 0x829FD880; continue 'dispatch;
	}
	// 829FD070: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FD074: 4845C6ED  bl 0x82e59760
	ctx.lr = 0x829FD078;
	sub_82E59760(ctx, base);
	// 829FD078: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FD07C: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 829FD080: 4BFF0EE9  bl 0x829edf68
	ctx.lr = 0x829FD084;
	sub_829EDF68(ctx, base);
	// 829FD084: 897F0060  lbz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 829FD088: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829FD08C: 1D6B0003  mulli r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 * 3;
	// 829FD090: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 829FD094: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FD098: 396B0028  addi r11, r11, 0x28
	ctx.r[11].s64 = ctx.r[11].s64 + 40;
	// 829FD09C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829FD0A0: 7C0BFC2E  lfsx f0, r11, r31
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FD0A4: EC3F0028  fsubs f1, f31, f0
	ctx.f[1].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 829FD0A8: 48424E81  bl 0x82e21f28
	ctx.lr = 0x829FD0AC;
	sub_82E21F28(ctx, base);
	// 829FD0AC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829FD0B0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FD0B4: 995F0060  stb r10, 0x60(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[10].u8 ) };
	// 829FD0B8: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 829FD0BC: 3BAB6E2C  addi r29, r11, 0x6e2c
	ctx.r[29].s64 = ctx.r[11].s64 + 28204;
	// 829FD0C0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829FD0C4: 483F6945  bl 0x82df3a08
	ctx.lr = 0x829FD0C8;
	sub_82DF3A08(ctx, base);
	// 829FD0C8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 829FD0CC: 38A10074  addi r5, r1, 0x74
	ctx.r[5].s64 = ctx.r[1].s64 + 116;
	// 829FD0D0: 809E0160  lwz r4, 0x160(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(352 as u32) ) } as u64;
	// 829FD0D4: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 829FD0D8: C04B6150  lfs f2, 0x6150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 829FD0DC: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 829FD0E0: 481B6299  bl 0x82bb3378
	ctx.lr = 0x829FD0E4;
	sub_82BB3378(ctx, base);
	// 829FD0E4: 806100FC  lwz r3, 0xfc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(252 as u32) ) } as u64;
	// 829FD0E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FD0EC: 419A0008  beq cr6, 0x829fd0f4
	if ctx.cr[6].eq {
	pc = 0x829FD0F4; continue 'dispatch;
	}
	// 829FD0F0: 4B8C37A1  bl 0x822c0890
	ctx.lr = 0x829FD0F4;
	sub_822C0890(ctx, base);
	// 829FD0F4: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 829FD0F8: 483F6331  bl 0x82df3428
	ctx.lr = 0x829FD0FC;
	sub_82DF3428(ctx, base);
	// 829FD0FC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829FD100: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829FD104: 483F6905  bl 0x82df3a08
	ctx.lr = 0x829FD108;
	sub_82DF3A08(ctx, base);
	// 829FD108: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 829FD10C: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 829FD110: 809E0160  lwz r4, 0x160(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(352 as u32) ) } as u64;
	// 829FD114: 481B5AB5  bl 0x82bb2bc8
	ctx.lr = 0x829FD118;
	sub_82BB2BC8(ctx, base);
	// 829FD118: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829FD11C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FD120: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FD124: 4BFF0E45  bl 0x829edf68
	ctx.lr = 0x829FD128;
	sub_829EDF68(ctx, base);
	// 829FD128: 897F0060  lbz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 829FD12C: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829FD130: 1D6B0003  mulli r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 * 3;
	// 829FD134: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 829FD138: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829FD13C: 396B0019  addi r11, r11, 0x19
	ctx.r[11].s64 = ctx.r[11].s64 + 25;
	// 829FD140: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829FD144: 7C2BFC2E  lfsx f1, r11, r31
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829FD148: 481BB929  bl 0x82bb8a70
	ctx.lr = 0x829FD14C;
	sub_82BB8A70(ctx, base);
	// 829FD14C: 806100CC  lwz r3, 0xcc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 829FD150: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FD154: 419A0008  beq cr6, 0x829fd15c
	if ctx.cr[6].eq {
	pc = 0x829FD15C; continue 'dispatch;
	}
	// 829FD158: 4B8C3739  bl 0x822c0890
	ctx.lr = 0x829FD15C;
	sub_822C0890(ctx, base);
	// 829FD15C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829FD160: 483F62C9  bl 0x82df3428
	ctx.lr = 0x829FD164;
	sub_82DF3428(ctx, base);
	// 829FD164: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829FD168: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 829FD16C: 83BE0000  lwz r29, 0(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FD170: 4BFF2119  bl 0x829ef288
	ctx.lr = 0x829FD174;
	sub_829EF288(ctx, base);
	// 829FD174: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FD178: 815D002C  lwz r10, 0x2c(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(44 as u32) ) } as u64;
	// 829FD17C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829FD180: 38AB74B8  addi r5, r11, 0x74b8
	ctx.r[5].s64 = ctx.r[11].s64 + 29880;
	// 829FD184: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829FD188: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 829FD18C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829FD190: 4E800421  bctrl
	ctx.lr = 0x829FD194;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829FD194: 8061011C  lwz r3, 0x11c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(284 as u32) ) } as u64;
	// 829FD198: 480006D0  b 0x829fd868
	pc = 0x829FD868; continue 'dispatch;
	// 829FD19C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FD1A0: 4BFF0DC9  bl 0x829edf68
	ctx.lr = 0x829FD1A4;
	sub_829EDF68(ctx, base);
	// 829FD1A4: 7D63FA14  add r11, r3, r31
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[31].u64;
	// 829FD1A8: 895F00EC  lbz r10, 0xec(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 829FD1AC: 896B00DC  lbz r11, 0xdc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(220 as u32) ) } as u64;
	// 829FD1B0: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829FD1B4: 40980048  bge cr6, 0x829fd1fc
	if !ctx.cr[6].lt {
	pc = 0x829FD1FC; continue 'dispatch;
	}
	// 829FD1B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FD1BC: 4BB1492D  bl 0x82511ae8
	ctx.lr = 0x829FD1C0;
	sub_82511AE8(ctx, base);
	// 829FD1C0: 39600320  li r11, 0x320
	ctx.r[11].s64 = 800;
	// 829FD1C4: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829FD1C8: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 829FD1CC: 13DE58C7  vcmpequd (lvx128) v30, v30, v11
	tmp.u32 = ctx.r[30].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FD8A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FD8A0 size=136
    let mut pc: u32 = 0x829FD8A0;
    'dispatch: loop {
        match pc {
            0x829FD8A0 => {
    //   block [0x829FD8A0..0x829FD928)
	// 829FD8A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FD8A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829FD8A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829FD8AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829FD8B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FD8B4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829FD8B8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829FD8BC: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 829FD8C0: 409A0020  bne cr6, 0x829fd8e0
	if !ctx.cr[6].eq {
	pc = 0x829FD8E0; continue 'dispatch;
	}
	// 829FD8C4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829FD8C8: 419A0048  beq cr6, 0x829fd910
	if ctx.cr[6].eq {
	pc = 0x829FD910; continue 'dispatch;
	}
	// 829FD8CC: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 829FD8D0: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 829FD8D4: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 829FD8D8: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 829FD8DC: 48000034  b 0x829fd910
	pc = 0x829FD910; continue 'dispatch;
	// 829FD8E0: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 829FD8E4: 419A002C  beq cr6, 0x829fd910
	if ctx.cr[6].eq {
	pc = 0x829FD910; continue 'dispatch;
	}
	// 829FD8E8: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829FD8EC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FD8F0: 388BE530  addi r4, r11, -0x1ad0
	ctx.r[4].s64 = ctx.r[11].s64 + -6864;
	// 829FD8F4: 487AA805  bl 0x831a80f8
	ctx.lr = 0x829FD8F8;
	sub_831A80F8(ctx, base);
	// 829FD8F8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829FD8FC: 4182000C  beq 0x829fd908
	if ctx.cr[0].eq {
	pc = 0x829FD908; continue 'dispatch;
	}
	// 829FD900: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 829FD904: 4800000C  b 0x829fd910
	pc = 0x829FD910; continue 'dispatch;
	// 829FD908: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829FD90C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829FD910: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829FD914: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829FD918: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829FD91C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829FD920: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829FD924: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FD928(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829FD928 size=344
    let mut pc: u32 = 0x829FD928;
    'dispatch: loop {
        match pc {
            0x829FD928 => {
    //   block [0x829FD928..0x829FDA80)
	// 829FD928: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FD92C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829FD930: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829FD934: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829FD938: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FD93C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FD940: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829FD944: 4BB12DC5  bl 0x82510708
	ctx.lr = 0x829FD948;
	sub_82510708(ctx, base);
	// 829FD948: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FD94C: 809F00E4  lwz r4, 0xe4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 829FD950: 4BB14131  bl 0x82511a80
	ctx.lr = 0x829FD954;
	sub_82511A80(ctx, base);
	// 829FD954: 817F00E4  lwz r11, 0xe4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 829FD958: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FD95C: 388B0020  addi r4, r11, 0x20
	ctx.r[4].s64 = ctx.r[11].s64 + 32;
	// 829FD960: 4BB14191  bl 0x82511af0
	ctx.lr = 0x829FD964;
	sub_82511AF0(ctx, base);
	// 829FD964: 817F00E4  lwz r11, 0xe4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 829FD968: 807F00FC  lwz r3, 0xfc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 829FD96C: 388B0010  addi r4, r11, 0x10
	ctx.r[4].s64 = ctx.r[11].s64 + 16;
	// 829FD970: 4BB8D4F9  bl 0x8258ae68
	ctx.lr = 0x829FD974;
	sub_8258AE68(ctx, base);
	// 829FD974: 897F0104  lbz r11, 0x104(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) } as u64;
	// 829FD978: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829FD97C: 4198009C  blt cr6, 0x829fda18
	if ctx.cr[6].lt {
	pc = 0x829FDA18; continue 'dispatch;
	}
	// 829FD980: 419A0070  beq cr6, 0x829fd9f0
	if ctx.cr[6].eq {
	pc = 0x829FD9F0; continue 'dispatch;
	}
	// 829FD984: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 829FD988: 409800E0  bge cr6, 0x829fda68
	if !ctx.cr[6].lt {
	pc = 0x829FDA68; continue 'dispatch;
	}
	// 829FD98C: C01E0000  lfs f0, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FD990: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829FD994: C1BF0110  lfs f13, 0x110(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829FD998: EDA0682A  fadds f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 829FD99C: D1BF0110  stfs f13, 0x110(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 829FD9A0: C00BE314  lfs f0, -0x1cec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7404 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FD9A4: FD806890  fmr f12, f13
	ctx.f[12].f64 = ctx.f[13].f64;
	// 829FD9A8: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 829FD9AC: D01F0108  stfs f0, 0x108(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 829FD9B0: C00BE314  lfs f0, -0x1cec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7404 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FD9B4: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 829FD9B8: 41980018  blt cr6, 0x829fd9d0
	if ctx.cr[6].lt {
	pc = 0x829FD9D0; continue 'dispatch;
	}
	// 829FD9BC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829FD9C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FD9C4: C00B08A8  lfs f0, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FD9C8: D01F0108  stfs f0, 0x108(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 829FD9CC: 4BB12C05  bl 0x825105d0
	ctx.lr = 0x829FD9D0;
	sub_825105D0(ctx, base);
	// 829FD9D0: 817F00EC  lwz r11, 0xec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 829FD9D4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 829FD9D8: C1BE0000  lfs f13, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829FD9DC: C18B0004  lfs f12, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829FD9E0: C00A9524  lfs f0, -0x6adc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FD9E4: EC0D603C  fnmsubs f0, f13, f0, f12
	ctx.f[0].f64 = -(((ctx.f[13].f64 * ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 829FD9E8: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829FD9EC: 4800007C  b 0x829fda68
	pc = 0x829FDA68; continue 'dispatch;
	// 829FD9F0: 817F00E4  lwz r11, 0xe4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 829FD9F4: 896B0040  lbz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 829FD9F8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829FD9FC: 4182006C  beq 0x829fda68
	if ctx.cr[0].eq {
	pc = 0x829FDA68; continue 'dispatch;
	}
	// 829FDA00: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 829FDA04: 807F00EC  lwz r3, 0xec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 829FDA08: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829FDA0C: 997F0104  stb r11, 0x104(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[11].u8 ) };
	// 829FDA10: 48483D31  bl 0x82e81740
	ctx.lr = 0x829FDA14;
	sub_82E81740(ctx, base);
	// 829FDA14: 48000054  b 0x829fda68
	pc = 0x829FDA68; continue 'dispatch;
	// 829FDA18: C01E0000  lfs f0, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FDA1C: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829FDA20: C1BF0110  lfs f13, 0x110(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829FDA24: EDA0682A  fadds f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 829FDA28: D1BF0110  stfs f13, 0x110(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 829FDA2C: C00BE310  lfs f0, -0x1cf0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7408 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FDA30: FD806890  fmr f12, f13
	ctx.f[12].f64 = ctx.f[13].f64;
	// 829FDA34: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 829FDA38: D01F010C  stfs f0, 0x10c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 829FDA3C: C00BE310  lfs f0, -0x1cf0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7408 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FDA40: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 829FDA44: 41980024  blt cr6, 0x829fda68
	if ctx.cr[6].lt {
	pc = 0x829FDA68; continue 'dispatch;
	}
	// 829FDA48: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829FDA4C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 829FDA50: C00A08A8  lfs f0, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FDA54: D01F010C  stfs f0, 0x10c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 829FDA58: C00BE310  lfs f0, -0x1cf0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7408 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FDA5C: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 829FDA60: D01F0110  stfs f0, 0x110(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 829FDA64: 993F0104  stb r9, 0x104(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[9].u8 ) };
	// 829FDA68: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829FDA6C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829FDA70: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829FDA74: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829FDA78: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829FDA7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FDA80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FDA80 size=96
    let mut pc: u32 = 0x829FDA80;
    'dispatch: loop {
        match pc {
            0x829FDA80 => {
    //   block [0x829FDA80..0x829FDAE0)
	// 829FDA80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FDA84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829FDA88: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829FDA8C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FDA90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FDA94: 48756B6D  bl 0x83154600
	ctx.lr = 0x829FDA98;
	sub_83154600(ctx, base);
	// 829FDA98: 817F0060  lwz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 829FDA9C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829FDAA0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FDAA4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829FDAA8: 994B0040  stb r10, 0x40(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), ctx.r[10].u8 ) };
	// 829FDAAC: 807F03A4  lwz r3, 0x3a4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(932 as u32) ) } as u64;
	// 829FDAB0: 48483C91  bl 0x82e81740
	ctx.lr = 0x829FDAB4;
	sub_82E81740(ctx, base);
	// 829FDAB4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829FDAB8: 807F044C  lwz r3, 0x44c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1100 as u32) ) } as u64;
	// 829FDABC: 48483C85  bl 0x82e81740
	ctx.lr = 0x829FDAC0;
	sub_82E81740(ctx, base);
	// 829FDAC0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829FDAC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FDAC8: 4BFF02B9  bl 0x829edd80
	ctx.lr = 0x829FDACC;
	sub_829EDD80(ctx, base);
	// 829FDACC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829FDAD0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829FDAD4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829FDAD8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829FDADC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FDAE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FDAE0 size=172
    let mut pc: u32 = 0x829FDAE0;
    'dispatch: loop {
        match pc {
            0x829FDAE0 => {
    //   block [0x829FDAE0..0x829FDB8C)
	// 829FDAE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FDAE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829FDAE8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829FDAEC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829FDAF0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FDAF4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829FDAF8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829FDAFC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829FDB00: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829FDB04: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829FDB08: 4B8C2E31  bl 0x822c0938
	ctx.lr = 0x829FDB0C;
	sub_822C0938(ctx, base);
	// 829FDB0C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829FDB10: 41820028  beq 0x829fdb38
	if ctx.cr[0].eq {
	pc = 0x829FDB38; continue 'dispatch;
	}
	// 829FDB14: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FDB18: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829FDB1C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829FDB20: 392B74DC  addi r9, r11, 0x74dc
	ctx.r[9].s64 = ctx.r[11].s64 + 29916;
	// 829FDB24: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829FDB28: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829FDB2C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829FDB30: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829FDB34: 48000008  b 0x829fdb3c
	pc = 0x829FDB3C; continue 'dispatch;
	// 829FDB38: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829FDB3C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829FDB40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FDB44: 409A002C  bne cr6, 0x829fdb70
	if !ctx.cr[6].eq {
	pc = 0x829FDB70; continue 'dispatch;
	}
	// 829FDB48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FDB4C: 4B8C271D  bl 0x822c0268
	ctx.lr = 0x829FDB50;
	sub_822C0268(ctx, base);
	// 829FDB50: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829FDB54: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829FDB58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FDB5C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829FDB60: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829FDB64: 816BE3A0  lwz r11, -0x1c60(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7264 as u32) ) } as u64;
	// 829FDB68: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829FDB6C: 4B8C2495  bl 0x822c0000
	ctx.lr = 0x829FDB70;
	sub_822C0000(ctx, base);
	// 829FDB70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FDB74: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829FDB78: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829FDB7C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829FDB80: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829FDB84: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829FDB88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FDB90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FDB90 size=196
    let mut pc: u32 = 0x829FDB90;
    'dispatch: loop {
        match pc {
            0x829FDB90 => {
    //   block [0x829FDB90..0x829FDC54)
	// 829FDB90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FDB94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829FDB98: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829FDB9C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829FDBA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FDBA4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829FDBA8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829FDBAC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829FDBB0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829FDBB4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829FDBB8: 4B8C2D81  bl 0x822c0938
	ctx.lr = 0x829FDBBC;
	sub_822C0938(ctx, base);
	// 829FDBBC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829FDBC0: 41820028  beq 0x829fdbe8
	if ctx.cr[0].eq {
	pc = 0x829FDBE8; continue 'dispatch;
	}
	// 829FDBC4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FDBC8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829FDBCC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829FDBD0: 392B74F0  addi r9, r11, 0x74f0
	ctx.r[9].s64 = ctx.r[11].s64 + 29936;
	// 829FDBD4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829FDBD8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829FDBDC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829FDBE0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829FDBE4: 48000008  b 0x829fdbec
	pc = 0x829FDBEC; continue 'dispatch;
	// 829FDBE8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829FDBEC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829FDBF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FDBF4: 409A0044  bne cr6, 0x829fdc38
	if !ctx.cr[6].eq {
	pc = 0x829FDC38; continue 'dispatch;
	}
	// 829FDBF8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829FDBFC: 419A001C  beq cr6, 0x829fdc18
	if ctx.cr[6].eq {
	pc = 0x829FDC18; continue 'dispatch;
	}
	// 829FDC00: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FDC04: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829FDC08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FDC0C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FDC10: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829FDC14: 4E800421  bctrl
	ctx.lr = 0x829FDC18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829FDC18: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829FDC1C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829FDC20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FDC24: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829FDC28: 816BE3A0  lwz r11, -0x1c60(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7264 as u32) ) } as u64;
	// 829FDC2C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829FDC30: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829FDC34: 4B8C23CD  bl 0x822c0000
	ctx.lr = 0x829FDC38;
	sub_822C0000(ctx, base);
	// 829FDC38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FDC3C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829FDC40: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829FDC44: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829FDC48: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829FDC4C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829FDC50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FDC58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FDC58 size=196
    let mut pc: u32 = 0x829FDC58;
    'dispatch: loop {
        match pc {
            0x829FDC58 => {
    //   block [0x829FDC58..0x829FDD1C)
	// 829FDC58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FDC5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829FDC60: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829FDC64: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829FDC68: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FDC6C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829FDC70: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829FDC74: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829FDC78: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829FDC7C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829FDC80: 4B8C2CB9  bl 0x822c0938
	ctx.lr = 0x829FDC84;
	sub_822C0938(ctx, base);
	// 829FDC84: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829FDC88: 41820028  beq 0x829fdcb0
	if ctx.cr[0].eq {
	pc = 0x829FDCB0; continue 'dispatch;
	}
	// 829FDC8C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FDC90: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829FDC94: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829FDC98: 392B7504  addi r9, r11, 0x7504
	ctx.r[9].s64 = ctx.r[11].s64 + 29956;
	// 829FDC9C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829FDCA0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829FDCA4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829FDCA8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829FDCAC: 48000008  b 0x829fdcb4
	pc = 0x829FDCB4; continue 'dispatch;
	// 829FDCB0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829FDCB4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829FDCB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FDCBC: 409A0044  bne cr6, 0x829fdd00
	if !ctx.cr[6].eq {
	pc = 0x829FDD00; continue 'dispatch;
	}
	// 829FDCC0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829FDCC4: 419A001C  beq cr6, 0x829fdce0
	if ctx.cr[6].eq {
	pc = 0x829FDCE0; continue 'dispatch;
	}
	// 829FDCC8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FDCCC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829FDCD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FDCD4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FDCD8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829FDCDC: 4E800421  bctrl
	ctx.lr = 0x829FDCE0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829FDCE0: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829FDCE4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829FDCE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FDCEC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829FDCF0: 816BE3A0  lwz r11, -0x1c60(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7264 as u32) ) } as u64;
	// 829FDCF4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829FDCF8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829FDCFC: 4B8C2305  bl 0x822c0000
	ctx.lr = 0x829FDD00;
	sub_822C0000(ctx, base);
	// 829FDD00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FDD04: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829FDD08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829FDD0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829FDD10: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829FDD14: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829FDD18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FDD20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FDD20 size=196
    let mut pc: u32 = 0x829FDD20;
    'dispatch: loop {
        match pc {
            0x829FDD20 => {
    //   block [0x829FDD20..0x829FDDE4)
	// 829FDD20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FDD24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829FDD28: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829FDD2C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829FDD30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FDD34: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829FDD38: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829FDD3C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829FDD40: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829FDD44: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829FDD48: 4B8C2BF1  bl 0x822c0938
	ctx.lr = 0x829FDD4C;
	sub_822C0938(ctx, base);
	// 829FDD4C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829FDD50: 41820028  beq 0x829fdd78
	if ctx.cr[0].eq {
	pc = 0x829FDD78; continue 'dispatch;
	}
	// 829FDD54: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FDD58: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829FDD5C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829FDD60: 392B7518  addi r9, r11, 0x7518
	ctx.r[9].s64 = ctx.r[11].s64 + 29976;
	// 829FDD64: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829FDD68: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829FDD6C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829FDD70: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829FDD74: 48000008  b 0x829fdd7c
	pc = 0x829FDD7C; continue 'dispatch;
	// 829FDD78: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829FDD7C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829FDD80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FDD84: 409A0044  bne cr6, 0x829fddc8
	if !ctx.cr[6].eq {
	pc = 0x829FDDC8; continue 'dispatch;
	}
	// 829FDD88: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829FDD8C: 419A001C  beq cr6, 0x829fdda8
	if ctx.cr[6].eq {
	pc = 0x829FDDA8; continue 'dispatch;
	}
	// 829FDD90: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FDD94: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829FDD98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FDD9C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FDDA0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829FDDA4: 4E800421  bctrl
	ctx.lr = 0x829FDDA8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829FDDA8: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829FDDAC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829FDDB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FDDB4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829FDDB8: 816BE3A0  lwz r11, -0x1c60(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7264 as u32) ) } as u64;
	// 829FDDBC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829FDDC0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829FDDC4: 4B8C223D  bl 0x822c0000
	ctx.lr = 0x829FDDC8;
	sub_822C0000(ctx, base);
	// 829FDDC8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FDDCC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829FDDD0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829FDDD4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829FDDD8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829FDDDC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829FDDE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FDDE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FDDE8 size=196
    let mut pc: u32 = 0x829FDDE8;
    'dispatch: loop {
        match pc {
            0x829FDDE8 => {
    //   block [0x829FDDE8..0x829FDEAC)
	// 829FDDE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FDDEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829FDDF0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829FDDF4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829FDDF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FDDFC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829FDE00: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829FDE04: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829FDE08: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829FDE0C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829FDE10: 4B8C2B29  bl 0x822c0938
	ctx.lr = 0x829FDE14;
	sub_822C0938(ctx, base);
	// 829FDE14: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829FDE18: 41820028  beq 0x829fde40
	if ctx.cr[0].eq {
	pc = 0x829FDE40; continue 'dispatch;
	}
	// 829FDE1C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FDE20: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829FDE24: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829FDE28: 392B752C  addi r9, r11, 0x752c
	ctx.r[9].s64 = ctx.r[11].s64 + 29996;
	// 829FDE2C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829FDE30: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829FDE34: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829FDE38: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829FDE3C: 48000008  b 0x829fde44
	pc = 0x829FDE44; continue 'dispatch;
	// 829FDE40: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829FDE44: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829FDE48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FDE4C: 409A0044  bne cr6, 0x829fde90
	if !ctx.cr[6].eq {
	pc = 0x829FDE90; continue 'dispatch;
	}
	// 829FDE50: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829FDE54: 419A001C  beq cr6, 0x829fde70
	if ctx.cr[6].eq {
	pc = 0x829FDE70; continue 'dispatch;
	}
	// 829FDE58: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FDE5C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829FDE60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FDE64: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FDE68: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829FDE6C: 4E800421  bctrl
	ctx.lr = 0x829FDE70;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829FDE70: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829FDE74: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829FDE78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FDE7C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829FDE80: 816BE3A0  lwz r11, -0x1c60(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7264 as u32) ) } as u64;
	// 829FDE84: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829FDE88: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829FDE8C: 4B8C2175  bl 0x822c0000
	ctx.lr = 0x829FDE90;
	sub_822C0000(ctx, base);
	// 829FDE90: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FDE94: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829FDE98: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829FDE9C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829FDEA0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829FDEA4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829FDEA8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FDEB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829FDEB0 size=540
    let mut pc: u32 = 0x829FDEB0;
    'dispatch: loop {
        match pc {
            0x829FDEB0 => {
    //   block [0x829FDEB0..0x829FE0CC)
	// 829FDEB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FDEB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829FDEB8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829FDEBC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829FDEC0: DBC1FFD8  stfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 829FDEC4: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 829FDEC8: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FE0D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829FE0D0 size=596
    let mut pc: u32 = 0x829FE0D0;
    'dispatch: loop {
        match pc {
            0x829FE0D0 => {
    //   block [0x829FE0D0..0x829FE324)
	// 829FE0D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FE0D4: 487AA095  bl 0x831a8168
	ctx.lr = 0x829FE0D8;
	sub_831A8130(ctx, base);
	// 829FE0D8: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 829FE0DC: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FE328(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FE328 size=72
    let mut pc: u32 = 0x829FE328;
    'dispatch: loop {
        match pc {
            0x829FE328 => {
    //   block [0x829FE328..0x829FE370)
	// 829FE328: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FE32C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829FE330: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FE334: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 829FE338: 419A001C  beq cr6, 0x829fe354
	if ctx.cr[6].eq {
	pc = 0x829FE354; continue 'dispatch;
	}
	// 829FE33C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 829FE340: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 829FE344: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 829FE348: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829FE34C: 4BFFF555  bl 0x829fd8a0
	ctx.lr = 0x829FE350;
	sub_829FD8A0(ctx, base);
	// 829FE350: 48000010  b 0x829fe360
	pc = 0x829FE360; continue 'dispatch;
	// 829FE354: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829FE358: 396BE530  addi r11, r11, -0x1ad0
	ctx.r[11].s64 = ctx.r[11].s64 + -6864;
	// 829FE35C: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829FE360: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829FE364: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829FE368: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829FE36C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FE370(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829FE370 size=236
    let mut pc: u32 = 0x829FE370;
    'dispatch: loop {
        match pc {
            0x829FE370 => {
    //   block [0x829FE370..0x829FE45C)
	// 829FE370: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FE374: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829FE378: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829FE37C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829FE380: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FE384: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FE388: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829FE38C: 4BB13FA5  bl 0x82512330
	ctx.lr = 0x829FE390;
	sub_82512330(ctx, base);
	// 829FE390: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FE394: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829FE398: 396B7554  addi r11, r11, 0x7554
	ctx.r[11].s64 = ctx.r[11].s64 + 30036;
	// 829FE39C: 394A7540  addi r10, r10, 0x7540
	ctx.r[10].s64 = ctx.r[10].s64 + 30016;
	// 829FE3A0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829FE3A4: 397F00E4  addi r11, r31, 0xe4
	ctx.r[11].s64 = ctx.r[31].s64 + 228;
	// 829FE3A8: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 829FE3AC: 395E0004  addi r10, r30, 4
	ctx.r[10].s64 = ctx.r[30].s64 + 4;
	// 829FE3B0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FE3B4: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 829FE3B8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FE3BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FE3C0: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 829FE3C4: 419A0024  beq cr6, 0x829fe3e8
	if ctx.cr[6].eq {
	pc = 0x829FE3E8; continue 'dispatch;
	}
	// 829FE3C8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829FE3CC: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 829FE3D0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829FE3D4: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 829FE3D8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 829FE3DC: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829FE3E0: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829FE3E4: 4082FFE8  bne 0x829fe3cc
	if !ctx.cr[0].eq {
	pc = 0x829FE3CC; continue 'dispatch;
	}
	// 829FE3E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829FE3EC: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 829FE3F0: 917F00EC  stw r11, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 829FE3F4: 917F00F0  stw r11, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 829FE3F8: 917F00F4  stw r11, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 829FE3FC: 917F00F8  stw r11, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[11].u32 ) };
	// 829FE400: 917F00FC  stw r11, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[11].u32 ) };
	// 829FE404: C00908A4  lfs f0, 0x8a4(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FE408: 917F0100  stw r11, 0x100(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[11].u32 ) };
	// 829FE40C: D01F0108  stfs f0, 0x108(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 829FE410: D01F010C  stfs f0, 0x10c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 829FE414: 997F0104  stb r11, 0x104(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[11].u8 ) };
	// 829FE418: D01F0110  stfs f0, 0x110(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 829FE41C: D01F0114  stfs f0, 0x114(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 829FE420: D01F0118  stfs f0, 0x118(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), tmp.u32 ) };
	// 829FE424: D01F011C  stfs f0, 0x11c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(284 as u32), tmp.u32 ) };
	// 829FE428: D01F0120  stfs f0, 0x120(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), tmp.u32 ) };
	// 829FE42C: D01F0124  stfs f0, 0x124(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(292 as u32), tmp.u32 ) };
	// 829FE430: 806A0000  lwz r3, 0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FE434: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FE438: 419A0008  beq cr6, 0x829fe440
	if ctx.cr[6].eq {
	pc = 0x829FE440; continue 'dispatch;
	}
	// 829FE43C: 4B8C2455  bl 0x822c0890
	ctx.lr = 0x829FE440;
	sub_822C0890(ctx, base);
	// 829FE440: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FE444: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829FE448: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829FE44C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829FE450: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829FE454: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829FE458: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FE460(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829FE460 size=8
    let mut pc: u32 = 0x829FE460;
    'dispatch: loop {
        match pc {
            0x829FE460 => {
    //   block [0x829FE460..0x829FE468)
	// 829FE460: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 829FE464: 4800164C  b 0x829ffab0
	sub_829FFAB0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FE468(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FE468 size=136
    let mut pc: u32 = 0x829FE468;
    'dispatch: loop {
        match pc {
            0x829FE468 => {
    //   block [0x829FE468..0x829FE4F0)
	// 829FE468: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FE46C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829FE470: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829FE474: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FE478: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FE47C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FE480: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829FE484: 396B7554  addi r11, r11, 0x7554
	ctx.r[11].s64 = ctx.r[11].s64 + 30036;
	// 829FE488: 394A7540  addi r10, r10, 0x7540
	ctx.r[10].s64 = ctx.r[10].s64 + 30016;
	// 829FE48C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829FE490: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 829FE494: 807F0100  lwz r3, 0x100(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) } as u64;
	// 829FE498: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FE49C: 419A0008  beq cr6, 0x829fe4a4
	if ctx.cr[6].eq {
	pc = 0x829FE4A4; continue 'dispatch;
	}
	// 829FE4A0: 4B8C23F1  bl 0x822c0890
	ctx.lr = 0x829FE4A4;
	sub_822C0890(ctx, base);
	// 829FE4A4: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 829FE4A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FE4AC: 419A0008  beq cr6, 0x829fe4b4
	if ctx.cr[6].eq {
	pc = 0x829FE4B4; continue 'dispatch;
	}
	// 829FE4B0: 4B8C23E1  bl 0x822c0890
	ctx.lr = 0x829FE4B4;
	sub_822C0890(ctx, base);
	// 829FE4B4: 807F00F0  lwz r3, 0xf0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 829FE4B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FE4BC: 419A0008  beq cr6, 0x829fe4c4
	if ctx.cr[6].eq {
	pc = 0x829FE4C4; continue 'dispatch;
	}
	// 829FE4C0: 4B8C23D1  bl 0x822c0890
	ctx.lr = 0x829FE4C4;
	sub_822C0890(ctx, base);
	// 829FE4C4: 807F00E8  lwz r3, 0xe8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 829FE4C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FE4CC: 419A0008  beq cr6, 0x829fe4d4
	if ctx.cr[6].eq {
	pc = 0x829FE4D4; continue 'dispatch;
	}
	// 829FE4D0: 4B8C23C1  bl 0x822c0890
	ctx.lr = 0x829FE4D4;
	sub_822C0890(ctx, base);
	// 829FE4D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FE4D8: 4B950E79  bl 0x8234f350
	ctx.lr = 0x829FE4DC;
	sub_8234F350(ctx, base);
	// 829FE4DC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829FE4E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829FE4E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829FE4E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829FE4EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FE4F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FE4F0 size=196
    let mut pc: u32 = 0x829FE4F0;
    'dispatch: loop {
        match pc {
            0x829FE4F0 => {
    //   block [0x829FE4F0..0x829FE5B4)
	// 829FE4F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FE4F4: 487A9C79  bl 0x831a816c
	ctx.lr = 0x829FE4F8;
	sub_831A8130(ctx, base);
	// 829FE4F8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FE4FC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829FE500: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FE504: 4BB0C44D  bl 0x8250a950
	ctx.lr = 0x829FE508;
	sub_8250A950(ctx, base);
	// 829FE508: 807D00EC  lwz r3, 0xec(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(236 as u32) ) } as u64;
	// 829FE50C: 3BFD00EC  addi r31, r29, 0xec
	ctx.r[31].s64 = ctx.r[29].s64 + 236;
	// 829FE510: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 829FE514: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FE518: 419A0040  beq cr6, 0x829fe558
	if ctx.cr[6].eq {
	pc = 0x829FE558; continue 'dispatch;
	}
	// 829FE51C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829FE520: 48483221  bl 0x82e81740
	ctx.lr = 0x829FE524;
	sub_82E81740(ctx, base);
	// 829FE524: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829FE528: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FE52C: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 829FE530: 409A0008  bne cr6, 0x829fe538
	if !ctx.cr[6].eq {
	pc = 0x829FE538; continue 'dispatch;
	}
	// 829FE534: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FE538: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829FE53C: 4BDD54C5  bl 0x827d3a00
	ctx.lr = 0x829FE540;
	sub_827D3A00(ctx, base);
	// 829FE540: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 829FE544: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FE548: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FE54C: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 829FE550: 419A0008  beq cr6, 0x829fe558
	if ctx.cr[6].eq {
	pc = 0x829FE558; continue 'dispatch;
	}
	// 829FE554: 4B8C233D  bl 0x822c0890
	ctx.lr = 0x829FE558;
	sub_822C0890(ctx, base);
	// 829FE558: 807D00F4  lwz r3, 0xf4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(244 as u32) ) } as u64;
	// 829FE55C: 3BFD00F4  addi r31, r29, 0xf4
	ctx.r[31].s64 = ctx.r[29].s64 + 244;
	// 829FE560: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FE564: 419A0040  beq cr6, 0x829fe5a4
	if ctx.cr[6].eq {
	pc = 0x829FE5A4; continue 'dispatch;
	}
	// 829FE568: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829FE56C: 484831D5  bl 0x82e81740
	ctx.lr = 0x829FE570;
	sub_82E81740(ctx, base);
	// 829FE570: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829FE574: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FE578: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 829FE57C: 409A0008  bne cr6, 0x829fe584
	if !ctx.cr[6].eq {
	pc = 0x829FE584; continue 'dispatch;
	}
	// 829FE580: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FE584: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829FE588: 4BDD5479  bl 0x827d3a00
	ctx.lr = 0x829FE58C;
	sub_827D3A00(ctx, base);
	// 829FE58C: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 829FE590: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FE594: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FE598: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 829FE59C: 419A0008  beq cr6, 0x829fe5a4
	if ctx.cr[6].eq {
	pc = 0x829FE5A4; continue 'dispatch;
	}
	// 829FE5A0: 4B8C22F1  bl 0x822c0890
	ctx.lr = 0x829FE5A4;
	sub_822C0890(ctx, base);
	// 829FE5A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FE5A8: 483F36E9  bl 0x82df1c90
	ctx.lr = 0x829FE5AC;
	sub_82DF1C90(ctx, base);
	// 829FE5AC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829FE5B0: 487A9C0C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FE5B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829FE5B8 size=300
    let mut pc: u32 = 0x829FE5B8;
    'dispatch: loop {
        match pc {
            0x829FE5B8 => {
    //   block [0x829FE5B8..0x829FE6E4)
	// 829FE5B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FE5BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829FE5C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829FE5C4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FE5C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FE5CC: 4845E35D  bl 0x82e5c928
	ctx.lr = 0x829FE5D0;
	sub_82E5C928(ctx, base);
	// 829FE5D0: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 829FE5D4: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 829FE5D8: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 829FE5DC: 3CE08209  lis r7, -0x7df7
	ctx.r[7].s64 = -2113339392;
	// 829FE5E0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FE5E4: C18AD5B8  lfs f12, -0x2a48(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10824 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829FE5E8: 3CA08200  lis r5, -0x7e00
	ctx.r[5].s64 = -2113929216;
	// 829FE5EC: C1690A90  lfs f11, 0xa90(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2704 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829FE5F0: 394B7598  addi r10, r11, 0x7598
	ctx.r[10].s64 = ctx.r[11].s64 + 30104;
	// 829FE5F4: C1A89450  lfs f13, -0x6bb0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829FE5F8: 3CC08201  lis r6, -0x7dff
	ctx.r[6].s64 = -2113863680;
	// 829FE5FC: C147ACFC  lfs f10, -0x5304(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-21252 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 829FE600: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829FE604: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 829FE608: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 829FE60C: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 829FE610: 917F0060  stw r11, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 829FE614: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 829FE618: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 829FE61C: C00508A8  lfs f0, 0x8a8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FE620: 397F00A8  addi r11, r31, 0xa8
	ctx.r[11].s64 = ctx.r[31].s64 + 168;
	// 829FE624: C126D1B8  lfs f9, -0x2e48(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-11848 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 829FE628: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 829FE62C: D19F006C  stfs f12, 0x6c(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 829FE630: D17F0070  stfs f11, 0x70(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 829FE634: D01F0084  stfs f0, 0x84(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 829FE638: D01F0088  stfs f0, 0x88(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 829FE63C: D01F008C  stfs f0, 0x8c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 829FE640: D01F009C  stfs f0, 0x9c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 829FE644: D01F00A0  stfs f0, 0xa0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 829FE648: D01F00A4  stfs f0, 0xa4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 829FE64C: C169A1C4  lfs f11, -0x5e3c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829FE650: C188FD2C  lfs f12, -0x2d4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-724 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829FE654: C007964C  lfs f0, -0x69b4(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FE658: D1BF0074  stfs f13, 0x74(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 829FE65C: D1BF0078  stfs f13, 0x78(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 829FE660: D15F007C  stfs f10, 0x7c(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 829FE664: D13F0080  stfs f9, 0x80(r31)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 829FE668: D1BF0090  stfs f13, 0x90(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 829FE66C: D1BF0094  stfs f13, 0x94(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 829FE670: D1BF0098  stfs f13, 0x98(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 829FE674: C14BFFC4  lfs f10, -0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-60 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 829FE678: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 829FE67C: C12BFFD0  lfs f9, -0x30(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-48 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 829FE680: ED4D5024  fdivs f10, f13, f10
	ctx.f[10].f64 = ((ctx.f[13].f64 / ctx.f[10].f64) as f32) as f64;
	// 829FE684: C10BFFE8  lfs f8, -0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 829FE688: ED204824  fdivs f9, f0, f9
	ctx.f[9].f64 = ((ctx.f[0].f64 / ctx.f[9].f64) as f32) as f64;
	// 829FE68C: ED0C4024  fdivs f8, f12, f8
	ctx.f[8].f64 = ((ctx.f[12].f64 / ctx.f[8].f64) as f32) as f64;
	// 829FE690: D14B0000  stfs f10, 0(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829FE694: D12B000C  stfs f9, 0xc(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829FE698: D10B0024  stfs f8, 0x24(r11)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 829FE69C: D16B0030  stfs f11, 0x30(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 829FE6A0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829FE6A4: 4082FFD0  bne 0x829fe674
	if !ctx.cr[0].eq {
	pc = 0x829FE674; continue 'dispatch;
	}
	// 829FE6A8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829FE6AC: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829FE6B0: 3D208202  lis r9, -0x7dfe
	ctx.r[9].s64 = -2113798144;
	// 829FE6B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FE6B8: C00BA2EC  lfs f0, -0x5d14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23828 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FE6BC: C1AA7590  lfs f13, 0x7590(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(30096 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829FE6C0: C1899F48  lfs f12, -0x60b8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-24760 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829FE6C4: D01F00C0  stfs f0, 0xc0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 829FE6C8: D1BF00C4  stfs f13, 0xc4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 829FE6CC: D19F00C8  stfs f12, 0xc8(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 829FE6D0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829FE6D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829FE6D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829FE6DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829FE6E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FE6E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FE6E8 size=164
    let mut pc: u32 = 0x829FE6E8;
    'dispatch: loop {
        match pc {
            0x829FE6E8 => {
    //   block [0x829FE6E8..0x829FE78C)
	// 829FE6E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FE6EC: 487A9A7D  bl 0x831a8168
	ctx.lr = 0x829FE6F0;
	sub_831A8130(ctx, base);
	// 829FE6F0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FE6F4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 829FE6F8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829FE6FC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829FE700: 57BC063F  clrlwi. r28, r29, 0x18
	ctx.r[28].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 829FE704: 41820038  beq 0x829fe73c
	if ctx.cr[0].eq {
	pc = 0x829FE73C; continue 'dispatch;
	}
	// 829FE708: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FE70C: 487AB27D  bl 0x831a9988
	ctx.lr = 0x829FE710;
	sub_831A9988(ctx, base);
	// 829FE710: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 829FE714: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829FE718: 386B7660  addi r3, r11, 0x7660
	ctx.r[3].s64 = ctx.r[11].s64 + 30304;
	// 829FE71C: 487A99DD  bl 0x831a80f8
	ctx.lr = 0x829FE720;
	sub_831A80F8(ctx, base);
	// 829FE720: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829FE724: 41820018  beq 0x829fe73c
	if ctx.cr[0].eq {
	pc = 0x829FE73C; continue 'dispatch;
	}
	// 829FE728: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829FE72C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FE730: 48012141  bl 0x82a10870
	ctx.lr = 0x829FE734;
	sub_82A10870(ctx, base);
	// 829FE734: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 829FE738: 4800004C  b 0x829fe784
	pc = 0x829FE784; continue 'dispatch;
	// 829FE73C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829FE740: 419A0034  beq cr6, 0x829fe774
	if ctx.cr[6].eq {
	pc = 0x829FE774; continue 'dispatch;
	}
	// 829FE744: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FE748: 487AB241  bl 0x831a9988
	ctx.lr = 0x829FE74C;
	sub_831A9988(ctx, base);
	// 829FE74C: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 829FE750: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829FE754: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 829FE758: 487A99A1  bl 0x831a80f8
	ctx.lr = 0x829FE75C;
	sub_831A80F8(ctx, base);
	// 829FE75C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829FE760: 41820014  beq 0x829fe774
	if ctx.cr[0].eq {
	pc = 0x829FE774; continue 'dispatch;
	}
	// 829FE764: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829FE768: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FE76C: 48012105  bl 0x82a10870
	ctx.lr = 0x829FE770;
	sub_82A10870(ctx, base);
	// 829FE770: 4BFFFFC4  b 0x829fe734
	pc = 0x829FE734; continue 'dispatch;
	// 829FE774: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 829FE778: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829FE77C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FE780: 4877FD09  bl 0x8317e488
	ctx.lr = 0x829FE784;
	sub_8317E488(ctx, base);
	// 829FE784: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829FE788: 487A9A30  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FE790(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829FE790 size=744
    let mut pc: u32 = 0x829FE790;
    'dispatch: loop {
        match pc {
            0x829FE790 => {
    //   block [0x829FE790..0x829FEA78)
	// 829FE790: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FE794: 487A99C9  bl 0x831a815c
	ctx.lr = 0x829FE798;
	sub_831A8130(ctx, base);
	// 829FE798: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 829FE79C: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FE7A0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829FE7A4: 48755E5D  bl 0x83154600
	ctx.lr = 0x829FE7A8;
	sub_83154600(ctx, base);
	// 829FE7A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FE7AC: 4BFEF7BD  bl 0x829edf68
	ctx.lr = 0x829FE7B0;
	sub_829EDF68(ctx, base);
	// 829FE7B0: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 829FE7B4: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 829FE7B8: 396BDA60  addi r11, r11, -0x25a0
	ctx.r[11].s64 = ctx.r[11].s64 + -9632;
	// 829FE7BC: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 829FE7C0: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 829FE7C4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829FE7C8: 388875C0  addi r4, r8, 0x75c0
	ctx.r[4].s64 = ctx.r[8].s64 + 30144;
	// 829FE7CC: 7C0A5C2E  lfsx f0, r10, r11
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FE7D0: 38A00499  li r5, 0x499
	ctx.r[5].s64 = 1177;
	// 829FE7D4: C3E908A4  lfs f31, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829FE7D8: 38600050  li r3, 0x50
	ctx.r[3].s64 = 80;
	// 829FE7DC: D01F0398  stfs f0, 0x398(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(920 as u32), tmp.u32 ) };
	// 829FE7E0: D3FD00F4  stfs f31, 0xf4(r29)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 829FE7E4: 4B8C1BF5  bl 0x822c03d8
	ctx.lr = 0x829FE7E8;
	sub_822C03D8(ctx, base);
	// 829FE7E8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829FE7EC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829FE7F0: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 829FE7F4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829FE7F8: 4BFFF2E9  bl 0x829fdae0
	ctx.lr = 0x829FE7FC;
	sub_829FDAE0(ctx, base);
	// 829FE7FC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829FE800: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829FE804: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829FE808: 4B8C17F9  bl 0x822c0000
	ctx.lr = 0x829FE80C;
	sub_822C0000(ctx, base);
	// 829FE80C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829FE810: 3BDD0060  addi r30, r29, 0x60
	ctx.r[30].s64 = ctx.r[29].s64 + 96;
	// 829FE814: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 829FE818: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 829FE81C: 917D0060  stw r11, 0x60(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 829FE820: 4B8C5C41  bl 0x822c4460
	ctx.lr = 0x829FE824;
	sub_822C4460(ctx, base);
	// 829FE824: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829FE828: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FE82C: 419A0008  beq cr6, 0x829fe834
	if ctx.cr[6].eq {
	pc = 0x829FE834; continue 'dispatch;
	}
	// 829FE830: 4B8C2061  bl 0x822c0890
	ctx.lr = 0x829FE834;
	sub_822C0890(ctx, base);
	// 829FE834: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FE838: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 829FE83C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829FE840: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 829FE844: 9B6B0040  stb r27, 0x40(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), ctx.r[27].u8 ) };
	// 829FE848: 4BB138D1  bl 0x82512118
	ctx.lr = 0x829FE84C;
	sub_82512118(ctx, base);
	// 829FE84C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 829FE850: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FE854: D3E10060  stfs f31, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 829FE858: D3E10064  stfs f31, 0x64(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 829FE85C: 835E0000  lwz r26, 0(r30)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FE860: D3E1006C  stfs f31, 0x6c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 829FE864: 3B810060  addi r28, r1, 0x60
	ctx.r[28].s64 = ctx.r[1].s64 + 96;
	// 829FE868: C00BD7BC  lfs f0, -0x2844(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FE86C: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 829FE870: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FE874: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 829FE878: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829FE87C: 4E800421  bctrl
	ctx.lr = 0x829FE880;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829FE880: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829FE884: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FE888: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 829FE88C: 4847D43D  bl 0x82e7bcc8
	ctx.lr = 0x829FE890;
	sub_82E7BCC8(ctx, base);
	// 829FE890: 3B800010  li r28, 0x10
	ctx.r[28].s64 = 16;
	// 829FE894: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FEA78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829FEA78 size=908
    let mut pc: u32 = 0x829FEA78;
    'dispatch: loop {
        match pc {
            0x829FEA78 => {
    //   block [0x829FEA78..0x829FEE04)
	// 829FEA78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FEA7C: 487A96ED  bl 0x831a8168
	ctx.lr = 0x829FEA80;
	sub_831A8130(ctx, base);
	// 829FEA80: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 829FEA84: 487A9FF1  bl 0x831a8a74
	ctx.lr = 0x829FEA88;
	sub_831A8A40(ctx, base);
	// 829FEA88: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FEA8C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FEA90: 48755B71  bl 0x83154600
	ctx.lr = 0x829FEA94;
	sub_83154600(ctx, base);
	// 829FEA94: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829FEA98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FEA9C: 4845ACDD  bl 0x82e59778
	ctx.lr = 0x829FEAA0;
	sub_82E59778(ctx, base);
	// 829FEAA0: C01F00F4  lfs f0, 0xf4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FEAA4: EC01002A  fadds f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 829FEAA8: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829FEAAC: D01F00F4  stfs f0, 0xf4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 829FEAB0: C1ABE30C  lfs f13, -0x1cf4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7412 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829FEAB4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 829FEAB8: 4099033C  ble cr6, 0x829fedf4
	if !ctx.cr[6].gt {
	pc = 0x829FEDF4; continue 'dispatch;
	}
	// 829FEABC: 817F0060  lwz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 829FEAC0: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 829FEAC4: 392100E0  addi r9, r1, 0xe0
	ctx.r[9].s64 = ctx.r[1].s64 + 224;
	// 829FEAC8: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 829FEACC: D01F00F4  stfs f0, 0xf4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 829FEAD0: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 829FEAD4: 13EB50C7  vcmpequd (lvx128) v31, v11, v10
	tmp.u32 = ctx.r[11].u32 + ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FEE08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829FEE08 size=136
    let mut pc: u32 = 0x829FEE08;
    'dispatch: loop {
        match pc {
            0x829FEE08 => {
    //   block [0x829FEE08..0x829FEE90)
	// 829FEE08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FEE0C: 487A935D  bl 0x831a8168
	ctx.lr = 0x829FEE10;
	sub_831A8130(ctx, base);
	// 829FEE10: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FEE14: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829FEE18: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 829FEE1C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829FEE20: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 829FEE24: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 829FEE28: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829FEE2C: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 829FEE30: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 829FEE34: 38600040  li r3, 0x40
	ctx.r[3].s64 = 64;
	// 829FEE38: 483F35B1  bl 0x82df23e8
	ctx.lr = 0x829FEE3C;
	sub_82DF23E8(ctx, base);
	// 829FEE3C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829FEE40: 4182001C  beq 0x829fee5c
	if ctx.cr[0].eq {
	pc = 0x829FEE5C; continue 'dispatch;
	}
	// 829FEE44: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829FEE48: C05D0000  lfs f2, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 829FEE4C: C03F0000  lfs f1, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829FEE50: 48154AF1  bl 0x82b53940
	ctx.lr = 0x829FEE54;
	sub_82B53940(ctx, base);
	// 829FEE54: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FEE58: 48000008  b 0x829fee60
	pc = 0x829FEE60; continue 'dispatch;
	// 829FEE5C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829FEE60: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 829FEE64: 3BDC0004  addi r30, r28, 4
	ctx.r[30].s64 = ctx.r[28].s64 + 4;
	// 829FEE68: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829FEE6C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FEE70: 4BFFEEB1  bl 0x829fdd20
	ctx.lr = 0x829FEE74;
	sub_829FDD20(ctx, base);
	// 829FEE74: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829FEE78: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829FEE7C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FEE80: 4B8C1181  bl 0x822c0000
	ctx.lr = 0x829FEE84;
	sub_822C0000(ctx, base);
	// 829FEE84: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829FEE88: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829FEE8C: 487A932C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FEE90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FEE90 size=124
    let mut pc: u32 = 0x829FEE90;
    'dispatch: loop {
        match pc {
            0x829FEE90 => {
    //   block [0x829FEE90..0x829FEF0C)
	// 829FEE90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FEE94: 487A92D9  bl 0x831a816c
	ctx.lr = 0x829FEE98;
	sub_831A8130(ctx, base);
	// 829FEE98: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FEE9C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829FEEA0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829FEEA4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829FEEA8: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 829FEEAC: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 829FEEB0: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 829FEEB4: 483F3535  bl 0x82df23e8
	ctx.lr = 0x829FEEB8;
	sub_82DF23E8(ctx, base);
	// 829FEEB8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 829FEEBC: 4182001C  beq 0x829feed8
	if ctx.cr[0].eq {
	pc = 0x829FEED8; continue 'dispatch;
	}
	// 829FEEC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FEEC4: 4845A7BD  bl 0x82e59680
	ctx.lr = 0x829FEEC8;
	sub_82E59680(ctx, base);
	// 829FEEC8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FEECC: 396B74D4  addi r11, r11, 0x74d4
	ctx.r[11].s64 = ctx.r[11].s64 + 29908;
	// 829FEED0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829FEED4: 48000008  b 0x829feedc
	pc = 0x829FEEDC; continue 'dispatch;
	// 829FEED8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829FEEDC: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 829FEEE0: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 829FEEE4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829FEEE8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FEEEC: 4BFFEEFD  bl 0x829fdde8
	ctx.lr = 0x829FEEF0;
	sub_829FDDE8(ctx, base);
	// 829FEEF0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829FEEF4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829FEEF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FEEFC: 4B8C1105  bl 0x822c0000
	ctx.lr = 0x829FEF00;
	sub_822C0000(ctx, base);
	// 829FEF00: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829FEF04: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829FEF08: 487A92B4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FEF10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829FEF10 size=2976
    let mut pc: u32 = 0x829FEF10;
    'dispatch: loop {
        match pc {
            0x829FEF10 => {
    //   block [0x829FEF10..0x829FFAB0)
	// 829FEF10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FEF14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829FEF18: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829FEF1C: 3981FFF0  addi r12, r1, -0x10
	ctx.r[12].s64 = ctx.r[1].s64 + -16;
	// 829FEF20: 487A9B51  bl 0x831a8a70
	ctx.lr = 0x829FEF24;
	sub_831A8A40(ctx, base);
	// 829FEF24: 9421F6E0  stwu r1, -0x920(r1)
	ea = ctx.r[1].u32.wrapping_add(-2336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FEF28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FEF2C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829FEF30: 419A0B64  beq cr6, 0x829ffa94
	if ctx.cr[6].eq {
	pc = 0x829FFA94; continue 'dispatch;
	}
	// 829FEF34: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FEF38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FEF3C: 388B7900  addi r4, r11, 0x7900
	ctx.r[4].s64 = ctx.r[11].s64 + 30976;
	// 829FEF40: 483F4AC9  bl 0x82df3a08
	ctx.lr = 0x829FEF44;
	sub_82DF3A08(ctx, base);
	// 829FEF44: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 829FEF48: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 829FEF4C: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 829FEF50: 3D00832E  lis r8, -0x7cd2
	ctx.r[8].s64 = -2094137344;
	// 829FEF54: 38610860  addi r3, r1, 0x860
	ctx.r[3].s64 = ctx.r[1].s64 + 2144;
	// 829FEF58: C36A89AC  lfs f27, -0x7654(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 829FEF5C: 3888E318  addi r4, r8, -0x1ce8
	ctx.r[4].s64 = ctx.r[8].s64 + -7400;
	// 829FEF60: C06B4C58  lfs f3, 0x4c58(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(19544 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 829FEF64: FC40D890  fmr f2, f27
	ctx.f[2].f64 = ctx.f[27].f64;
	// 829FEF68: C0299F7C  lfs f1, -0x6084(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-24708 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829FEF6C: 4BBA4245  bl 0x825a31b0
	ctx.lr = 0x829FEF70;
	sub_825A31B0(ctx, base);
	// 829FEF70: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 829FEF74: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829FEF78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FEF7C: 4BBA27F5  bl 0x825a1770
	ctx.lr = 0x829FEF80;
	sub_825A1770(ctx, base);
	// 829FEF80: 38610898  addi r3, r1, 0x898
	ctx.r[3].s64 = ctx.r[1].s64 + 2200;
	// 829FEF84: 483F44A5  bl 0x82df3428
	ctx.lr = 0x829FEF88;
	sub_82DF3428(ctx, base);
	// 829FEF88: 38610878  addi r3, r1, 0x878
	ctx.r[3].s64 = ctx.r[1].s64 + 2168;
	// 829FEF8C: 4B8C9D2D  bl 0x822c8cb8
	ctx.lr = 0x829FEF90;
	sub_822C8CB8(ctx, base);
	// 829FEF90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FEF94: 483F4495  bl 0x82df3428
	ctx.lr = 0x829FEF98;
	sub_82DF3428(ctx, base);
	// 829FEF98: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FEF9C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FEFA0: 388B78F0  addi r4, r11, 0x78f0
	ctx.r[4].s64 = ctx.r[11].s64 + 30960;
	// 829FEFA4: 483F4A65  bl 0x82df3a08
	ctx.lr = 0x829FEFA8;
	sub_82DF3A08(ctx, base);
	// 829FEFA8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829FEFAC: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 829FEFB0: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 829FEFB4: 3D00832E  lis r8, -0x7cd2
	ctx.r[8].s64 = -2094137344;
	// 829FEFB8: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 829FEFBC: C3AB964C  lfs f29, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 829FEFC0: 3888E31C  addi r4, r8, -0x1ce4
	ctx.r[4].s64 = ctx.r[8].s64 + -7396;
	// 829FEFC4: C3CA6218  lfs f30, 0x6218(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25112 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 829FEFC8: FC60E890  fmr f3, f29
	ctx.f[3].f64 = ctx.f[29].f64;
	// 829FEFCC: C3E908A4  lfs f31, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829FEFD0: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 829FEFD4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829FEFD8: 4BBA41D9  bl 0x825a31b0
	ctx.lr = 0x829FEFDC;
	sub_825A31B0(ctx, base);
	// 829FEFDC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 829FEFE0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829FEFE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FEFE8: 4BBA2789  bl 0x825a1770
	ctx.lr = 0x829FEFEC;
	sub_825A1770(ctx, base);
	// 829FEFEC: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 829FEFF0: 483F4439  bl 0x82df3428
	ctx.lr = 0x829FEFF4;
	sub_82DF3428(ctx, base);
	// 829FEFF4: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 829FEFF8: 4B8C9CC1  bl 0x822c8cb8
	ctx.lr = 0x829FEFFC;
	sub_822C8CB8(ctx, base);
	// 829FEFFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FF000: 483F4429  bl 0x82df3428
	ctx.lr = 0x829FF004;
	sub_82DF3428(ctx, base);
	// 829FF004: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FF008: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FF00C: 388B78D8  addi r4, r11, 0x78d8
	ctx.r[4].s64 = ctx.r[11].s64 + 30936;
	// 829FF010: 483F49F9  bl 0x82df3a08
	ctx.lr = 0x829FF014;
	sub_82DF3A08(ctx, base);
	// 829FF014: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829FF018: 386104E0  addi r3, r1, 0x4e0
	ctx.r[3].s64 = ctx.r[1].s64 + 1248;
	// 829FF01C: FC60E890  fmr f3, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[29].f64;
	// 829FF020: 388BE320  addi r4, r11, -0x1ce0
	ctx.r[4].s64 = ctx.r[11].s64 + -7392;
	// 829FF024: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 829FF028: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829FF02C: 4BBA4185  bl 0x825a31b0
	ctx.lr = 0x829FF030;
	sub_825A31B0(ctx, base);
	// 829FF030: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 829FF034: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829FF038: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FF03C: 4BBA2735  bl 0x825a1770
	ctx.lr = 0x829FF040;
	sub_825A1770(ctx, base);
	// 829FF040: 38610518  addi r3, r1, 0x518
	ctx.r[3].s64 = ctx.r[1].s64 + 1304;
	// 829FF044: 483F43E5  bl 0x82df3428
	ctx.lr = 0x829FF048;
	sub_82DF3428(ctx, base);
	// 829FF048: 386104F8  addi r3, r1, 0x4f8
	ctx.r[3].s64 = ctx.r[1].s64 + 1272;
	// 829FF04C: 4B8C9C6D  bl 0x822c8cb8
	ctx.lr = 0x829FF050;
	sub_822C8CB8(ctx, base);
	// 829FF050: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FF054: 483F43D5  bl 0x82df3428
	ctx.lr = 0x829FF058;
	sub_82DF3428(ctx, base);
	// 829FF058: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FF05C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FF060: 388B78C0  addi r4, r11, 0x78c0
	ctx.r[4].s64 = ctx.r[11].s64 + 30912;
	// 829FF064: 483F49A5  bl 0x82df3a08
	ctx.lr = 0x829FF068;
	sub_82DF3A08(ctx, base);
	// 829FF068: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829FF06C: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 829FF070: 38610160  addi r3, r1, 0x160
	ctx.r[3].s64 = ctx.r[1].s64 + 352;
	// 829FF074: 388BE324  addi r4, r11, -0x1cdc
	ctx.r[4].s64 = ctx.r[11].s64 + -7388;
	// 829FF078: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829FF07C: FC60E890  fmr f3, f29
	ctx.f[3].f64 = ctx.f[29].f64;
	// 829FF080: 4BBA4131  bl 0x825a31b0
	ctx.lr = 0x829FF084;
	sub_825A31B0(ctx, base);
	// 829FF084: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 829FF088: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829FF08C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FF090: 4BBA26E1  bl 0x825a1770
	ctx.lr = 0x829FF094;
	sub_825A1770(ctx, base);
	// 829FF094: 38610198  addi r3, r1, 0x198
	ctx.r[3].s64 = ctx.r[1].s64 + 408;
	// 829FF098: 483F4391  bl 0x82df3428
	ctx.lr = 0x829FF09C;
	sub_82DF3428(ctx, base);
	// 829FF09C: 38610178  addi r3, r1, 0x178
	ctx.r[3].s64 = ctx.r[1].s64 + 376;
	// 829FF0A0: 4B8C9C19  bl 0x822c8cb8
	ctx.lr = 0x829FF0A4;
	sub_822C8CB8(ctx, base);
	// 829FF0A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FF0A8: 483F4381  bl 0x82df3428
	ctx.lr = 0x829FF0AC;
	sub_82DF3428(ctx, base);
	// 829FF0AC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FF0B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FF0B4: 388B78A8  addi r4, r11, 0x78a8
	ctx.r[4].s64 = ctx.r[11].s64 + 30888;
	// 829FF0B8: 483F4951  bl 0x82df3a08
	ctx.lr = 0x829FF0BC;
	sub_82DF3A08(ctx, base);
	// 829FF0BC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829FF0C0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829FF0C4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829FF0C8: 3D20832E  lis r9, -0x7cd2
	ctx.r[9].s64 = -2094137344;
	// 829FF0CC: 386106E0  addi r3, r1, 0x6e0
	ctx.r[3].s64 = ctx.r[1].s64 + 1760;
	// 829FF0D0: 3889E328  addi r4, r9, -0x1cd8
	ctx.r[4].s64 = ctx.r[9].s64 + -7384;
	// 829FF0D4: C38B9528  lfs f28, -0x6ad8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 829FF0D8: C34A08A8  lfs f26, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 829FF0DC: FC60E090  fmr f3, f28
	ctx.f[3].f64 = ctx.f[28].f64;
	// 829FF0E0: FC40D090  fmr f2, f26
	ctx.f[2].f64 = ctx.f[26].f64;
	// 829FF0E4: 4BBA40CD  bl 0x825a31b0
	ctx.lr = 0x829FF0E8;
	sub_825A31B0(ctx, base);
	// 829FF0E8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 829FF0EC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829FF0F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FF0F4: 4BBA267D  bl 0x825a1770
	ctx.lr = 0x829FF0F8;
	sub_825A1770(ctx, base);
	// 829FF0F8: 38610718  addi r3, r1, 0x718
	ctx.r[3].s64 = ctx.r[1].s64 + 1816;
	// 829FF0FC: 483F432D  bl 0x82df3428
	ctx.lr = 0x829FF100;
	sub_82DF3428(ctx, base);
	// 829FF100: 386106F8  addi r3, r1, 0x6f8
	ctx.r[3].s64 = ctx.r[1].s64 + 1784;
	// 829FF104: 4B8C9BB5  bl 0x822c8cb8
	ctx.lr = 0x829FF108;
	sub_822C8CB8(ctx, base);
	// 829FF108: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FF10C: 483F431D  bl 0x82df3428
	ctx.lr = 0x829FF110;
	sub_82DF3428(ctx, base);
	// 829FF110: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FF114: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FF118: 388B7890  addi r4, r11, 0x7890
	ctx.r[4].s64 = ctx.r[11].s64 + 30864;
	// 829FF11C: 483F48ED  bl 0x82df3a08
	ctx.lr = 0x829FF120;
	sub_82DF3A08(ctx, base);
	// 829FF120: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 829FF124: 386101E0  addi r3, r1, 0x1e0
	ctx.r[3].s64 = ctx.r[1].s64 + 480;
	// 829FF128: FC60E090  fmr f3, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[28].f64;
	// 829FF12C: 388BDA5C  addi r4, r11, -0x25a4
	ctx.r[4].s64 = ctx.r[11].s64 + -9636;
	// 829FF130: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829FF134: FC40D090  fmr f2, f26
	ctx.f[2].f64 = ctx.f[26].f64;
	// 829FF138: 4BBA4079  bl 0x825a31b0
	ctx.lr = 0x829FF13C;
	sub_825A31B0(ctx, base);
	// 829FF13C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 829FF140: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829FF144: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FF148: 4BBA2629  bl 0x825a1770
	ctx.lr = 0x829FF14C;
	sub_825A1770(ctx, base);
	// 829FF14C: 38610218  addi r3, r1, 0x218
	ctx.r[3].s64 = ctx.r[1].s64 + 536;
	// 829FF150: 483F42D9  bl 0x82df3428
	ctx.lr = 0x829FF154;
	sub_82DF3428(ctx, base);
	// 829FF154: 386101F8  addi r3, r1, 0x1f8
	ctx.r[3].s64 = ctx.r[1].s64 + 504;
	// 829FF158: 4B8C9B61  bl 0x822c8cb8
	ctx.lr = 0x829FF15C;
	sub_822C8CB8(ctx, base);
	// 829FF15C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FF160: 483F42C9  bl 0x82df3428
	ctx.lr = 0x829FF164;
	sub_82DF3428(ctx, base);
	// 829FF164: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FF168: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FF16C: 388B7878  addi r4, r11, 0x7878
	ctx.r[4].s64 = ctx.r[11].s64 + 30840;
	// 829FF170: 483F4899  bl 0x82df3a08
	ctx.lr = 0x829FF174;
	sub_82DF3A08(ctx, base);
	// 829FF174: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829FF178: 38610560  addi r3, r1, 0x560
	ctx.r[3].s64 = ctx.r[1].s64 + 1376;
	// 829FF17C: FC60E090  fmr f3, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[28].f64;
	// 829FF180: 388BE32C  addi r4, r11, -0x1cd4
	ctx.r[4].s64 = ctx.r[11].s64 + -7380;
	// 829FF184: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 829FF188: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829FF18C: 4BBA4025  bl 0x825a31b0
	ctx.lr = 0x829FF190;
	sub_825A31B0(ctx, base);
	// 829FF190: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 829FF194: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829FF198: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FF19C: 4BBA25D5  bl 0x825a1770
	ctx.lr = 0x829FF1A0;
	sub_825A1770(ctx, base);
	// 829FF1A0: 38610598  addi r3, r1, 0x598
	ctx.r[3].s64 = ctx.r[1].s64 + 1432;
	// 829FF1A4: 483F4285  bl 0x82df3428
	ctx.lr = 0x829FF1A8;
	sub_82DF3428(ctx, base);
	// 829FF1A8: 38610578  addi r3, r1, 0x578
	ctx.r[3].s64 = ctx.r[1].s64 + 1400;
	// 829FF1AC: 4B8C9B0D  bl 0x822c8cb8
	ctx.lr = 0x829FF1B0;
	sub_822C8CB8(ctx, base);
	// 829FF1B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FF1B4: 483F4275  bl 0x82df3428
	ctx.lr = 0x829FF1B8;
	sub_82DF3428(ctx, base);
	// 829FF1B8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FF1BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FF1C0: 388B7860  addi r4, r11, 0x7860
	ctx.r[4].s64 = ctx.r[11].s64 + 30816;
	// 829FF1C4: 483F4845  bl 0x82df3a08
	ctx.lr = 0x829FF1C8;
	sub_82DF3A08(ctx, base);
	// 829FF1C8: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829FF1CC: 38610260  addi r3, r1, 0x260
	ctx.r[3].s64 = ctx.r[1].s64 + 608;
	// 829FF1D0: FC60E890  fmr f3, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[29].f64;
	// 829FF1D4: 388BE330  addi r4, r11, -0x1cd0
	ctx.r[4].s64 = ctx.r[11].s64 + -7376;
	// 829FF1D8: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 829FF1DC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829FF1E0: 4BBA3FD1  bl 0x825a31b0
	ctx.lr = 0x829FF1E4;
	sub_825A31B0(ctx, base);
	// 829FF1E4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 829FF1E8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829FF1EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FF1F0: 4BBA2581  bl 0x825a1770
	ctx.lr = 0x829FF1F4;
	sub_825A1770(ctx, base);
	// 829FF1F4: 38610298  addi r3, r1, 0x298
	ctx.r[3].s64 = ctx.r[1].s64 + 664;
	// 829FF1F8: 483F4231  bl 0x82df3428
	ctx.lr = 0x829FF1FC;
	sub_82DF3428(ctx, base);
	// 829FF1FC: 38610278  addi r3, r1, 0x278
	ctx.r[3].s64 = ctx.r[1].s64 + 632;
	// 829FF200: 4B8C9AB9  bl 0x822c8cb8
	ctx.lr = 0x829FF204;
	sub_822C8CB8(ctx, base);
	// 829FF204: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FF208: 483F4221  bl 0x82df3428
	ctx.lr = 0x829FF20C;
	sub_82DF3428(ctx, base);
	// 829FF20C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FF210: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FF214: 388B7848  addi r4, r11, 0x7848
	ctx.r[4].s64 = ctx.r[11].s64 + 30792;
	// 829FF218: 483F47F1  bl 0x82df3a08
	ctx.lr = 0x829FF21C;
	sub_82DF3A08(ctx, base);
	// 829FF21C: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829FF220: 386107E0  addi r3, r1, 0x7e0
	ctx.r[3].s64 = ctx.r[1].s64 + 2016;
	// 829FF224: FC60E890  fmr f3, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[29].f64;
	// 829FF228: 388BE334  addi r4, r11, -0x1ccc
	ctx.r[4].s64 = ctx.r[11].s64 + -7372;
	// 829FF22C: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 829FF230: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829FF234: 4BBA3F7D  bl 0x825a31b0
	ctx.lr = 0x829FF238;
	sub_825A31B0(ctx, base);
	// 829FF238: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 829FF23C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829FF240: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FF244: 4BBA252D  bl 0x825a1770
	ctx.lr = 0x829FF248;
	sub_825A1770(ctx, base);
	// 829FF248: 38610818  addi r3, r1, 0x818
	ctx.r[3].s64 = ctx.r[1].s64 + 2072;
	// 829FF24C: 483F41DD  bl 0x82df3428
	ctx.lr = 0x829FF250;
	sub_82DF3428(ctx, base);
	// 829FF250: 386107F8  addi r3, r1, 0x7f8
	ctx.r[3].s64 = ctx.r[1].s64 + 2040;
	// 829FF254: 4B8C9A65  bl 0x822c8cb8
	ctx.lr = 0x829FF258;
	sub_822C8CB8(ctx, base);
	// 829FF258: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FF25C: 483F41CD  bl 0x82df3428
	ctx.lr = 0x829FF260;
	sub_82DF3428(ctx, base);
	// 829FF260: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FF264: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FF268: 388B7830  addi r4, r11, 0x7830
	ctx.r[4].s64 = ctx.r[11].s64 + 30768;
	// 829FF26C: 483F479D  bl 0x82df3a08
	ctx.lr = 0x829FF270;
	sub_82DF3A08(ctx, base);
	// 829FF270: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829FF274: 386102E0  addi r3, r1, 0x2e0
	ctx.r[3].s64 = ctx.r[1].s64 + 736;
	// 829FF278: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829FF27C: 388BE338  addi r4, r11, -0x1cc8
	ctx.r[4].s64 = ctx.r[11].s64 + -7368;
	// 829FF280: FC60E890  fmr f3, f29
	ctx.f[3].f64 = ctx.f[29].f64;
	// 829FF284: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 829FF288: 4BBA3F29  bl 0x825a31b0
	ctx.lr = 0x829FF28C;
	sub_825A31B0(ctx, base);
	// 829FF28C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 829FF290: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829FF294: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FF298: 4BBA24D9  bl 0x825a1770
	ctx.lr = 0x829FF29C;
	sub_825A1770(ctx, base);
	// 829FF29C: 38610318  addi r3, r1, 0x318
	ctx.r[3].s64 = ctx.r[1].s64 + 792;
	// 829FF2A0: 483F4189  bl 0x82df3428
	ctx.lr = 0x829FF2A4;
	sub_82DF3428(ctx, base);
	// 829FF2A4: 386102F8  addi r3, r1, 0x2f8
	ctx.r[3].s64 = ctx.r[1].s64 + 760;
	// 829FF2A8: 4B8C9A11  bl 0x822c8cb8
	ctx.lr = 0x829FF2AC;
	sub_822C8CB8(ctx, base);
	// 829FF2AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FF2B0: 483F4179  bl 0x82df3428
	ctx.lr = 0x829FF2B4;
	sub_82DF3428(ctx, base);
	// 829FF2B4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FF2B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FF2BC: 388B7818  addi r4, r11, 0x7818
	ctx.r[4].s64 = ctx.r[11].s64 + 30744;
	// 829FF2C0: 483F4749  bl 0x82df3a08
	ctx.lr = 0x829FF2C4;
	sub_82DF3A08(ctx, base);
	// 829FF2C4: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829FF2C8: 386105E0  addi r3, r1, 0x5e0
	ctx.r[3].s64 = ctx.r[1].s64 + 1504;
	// 829FF2CC: FC60E090  fmr f3, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[28].f64;
	// 829FF2D0: 388BE33C  addi r4, r11, -0x1cc4
	ctx.r[4].s64 = ctx.r[11].s64 + -7364;
	// 829FF2D4: FC40D890  fmr f2, f27
	ctx.f[2].f64 = ctx.f[27].f64;
	// 829FF2D8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829FF2DC: 4BBA3ED5  bl 0x825a31b0
	ctx.lr = 0x829FF2E0;
	sub_825A31B0(ctx, base);
	// 829FF2E0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 829FF2E4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829FF2E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FF2EC: 4BBA2485  bl 0x825a1770
	ctx.lr = 0x829FF2F0;
	sub_825A1770(ctx, base);
	// 829FF2F0: 38610618  addi r3, r1, 0x618
	ctx.r[3].s64 = ctx.r[1].s64 + 1560;
	// 829FF2F4: 483F4135  bl 0x82df3428
	ctx.lr = 0x829FF2F8;
	sub_82DF3428(ctx, base);
	// 829FF2F8: 386105F8  addi r3, r1, 0x5f8
	ctx.r[3].s64 = ctx.r[1].s64 + 1528;
	// 829FF2FC: 4B8C99BD  bl 0x822c8cb8
	ctx.lr = 0x829FF300;
	sub_822C8CB8(ctx, base);
	// 829FF300: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FF304: 483F4125  bl 0x82df3428
	ctx.lr = 0x829FF308;
	sub_82DF3428(ctx, base);
	// 829FF308: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FF30C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FF310: 388B7800  addi r4, r11, 0x7800
	ctx.r[4].s64 = ctx.r[11].s64 + 30720;
	// 829FF314: 483F46F5  bl 0x82df3a08
	ctx.lr = 0x829FF318;
	sub_82DF3A08(ctx, base);
	// 829FF318: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829FF31C: 38610360  addi r3, r1, 0x360
	ctx.r[3].s64 = ctx.r[1].s64 + 864;
	// 829FF320: FC60E090  fmr f3, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[28].f64;
	// 829FF324: 388BE340  addi r4, r11, -0x1cc0
	ctx.r[4].s64 = ctx.r[11].s64 + -7360;
	// 829FF328: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829FF32C: FC40D890  fmr f2, f27
	ctx.f[2].f64 = ctx.f[27].f64;
	// 829FF330: 4BBA3E81  bl 0x825a31b0
	ctx.lr = 0x829FF334;
	sub_825A31B0(ctx, base);
	// 829FF334: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 829FF338: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829FF33C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FF340: 4BBA2431  bl 0x825a1770
	ctx.lr = 0x829FF344;
	sub_825A1770(ctx, base);
	// 829FF344: 38610398  addi r3, r1, 0x398
	ctx.r[3].s64 = ctx.r[1].s64 + 920;
	// 829FF348: 483F40E1  bl 0x82df3428
	ctx.lr = 0x829FF34C;
	sub_82DF3428(ctx, base);
	// 829FF34C: 38610378  addi r3, r1, 0x378
	ctx.r[3].s64 = ctx.r[1].s64 + 888;
	// 829FF350: 4B8C9969  bl 0x822c8cb8
	ctx.lr = 0x829FF354;
	sub_822C8CB8(ctx, base);
	// 829FF354: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FF358: 483F40D1  bl 0x82df3428
	ctx.lr = 0x829FF35C;
	sub_82DF3428(ctx, base);
	// 829FF35C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FF360: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FF364: 388B77E8  addi r4, r11, 0x77e8
	ctx.r[4].s64 = ctx.r[11].s64 + 30696;
	// 829FF368: 483F46A1  bl 0x82df3a08
	ctx.lr = 0x829FF36C;
	sub_82DF3A08(ctx, base);
	// 829FF36C: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829FF370: 38610760  addi r3, r1, 0x760
	ctx.r[3].s64 = ctx.r[1].s64 + 1888;
	// 829FF374: FC60E890  fmr f3, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[29].f64;
	// 829FF378: 388BE344  addi r4, r11, -0x1cbc
	ctx.r[4].s64 = ctx.r[11].s64 + -7356;
	// 829FF37C: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 829FF380: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829FF384: 4BBA3E2D  bl 0x825a31b0
	ctx.lr = 0x829FF388;
	sub_825A31B0(ctx, base);
	// 829FF388: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 829FF38C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829FF390: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FF394: 4BBA23DD  bl 0x825a1770
	ctx.lr = 0x829FF398;
	sub_825A1770(ctx, base);
	// 829FF398: 38610798  addi r3, r1, 0x798
	ctx.r[3].s64 = ctx.r[1].s64 + 1944;
	// 829FF39C: 483F408D  bl 0x82df3428
	ctx.lr = 0x829FF3A0;
	sub_82DF3428(ctx, base);
	// 829FF3A0: 38610778  addi r3, r1, 0x778
	ctx.r[3].s64 = ctx.r[1].s64 + 1912;
	// 829FF3A4: 4B8C9915  bl 0x822c8cb8
	ctx.lr = 0x829FF3A8;
	sub_822C8CB8(ctx, base);
	// 829FF3A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FF3AC: 483F407D  bl 0x82df3428
	ctx.lr = 0x829FF3B0;
	sub_82DF3428(ctx, base);
	// 829FF3B0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FF3B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FF3B8: 388B77D0  addi r4, r11, 0x77d0
	ctx.r[4].s64 = ctx.r[11].s64 + 30672;
	// 829FF3BC: 483F464D  bl 0x82df3a08
	ctx.lr = 0x829FF3C0;
	sub_82DF3A08(ctx, base);
	// 829FF3C0: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829FF3C4: 386103E0  addi r3, r1, 0x3e0
	ctx.r[3].s64 = ctx.r[1].s64 + 992;
	// 829FF3C8: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 829FF3CC: 388BE348  addi r4, r11, -0x1cb8
	ctx.r[4].s64 = ctx.r[11].s64 + -7352;
	// 829FF3D0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829FF3D4: FC60E890  fmr f3, f29
	ctx.f[3].f64 = ctx.f[29].f64;
	// 829FF3D8: 4BBA3DD9  bl 0x825a31b0
	ctx.lr = 0x829FF3DC;
	sub_825A31B0(ctx, base);
	// 829FF3DC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 829FF3E0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829FF3E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FF3E8: 4BBA2389  bl 0x825a1770
	ctx.lr = 0x829FF3EC;
	sub_825A1770(ctx, base);
	// 829FF3EC: 38610418  addi r3, r1, 0x418
	ctx.r[3].s64 = ctx.r[1].s64 + 1048;
	// 829FF3F0: 483F4039  bl 0x82df3428
	ctx.lr = 0x829FF3F4;
	sub_82DF3428(ctx, base);
	// 829FF3F4: 386103F8  addi r3, r1, 0x3f8
	ctx.r[3].s64 = ctx.r[1].s64 + 1016;
	// 829FF3F8: 4B8C98C1  bl 0x822c8cb8
	ctx.lr = 0x829FF3FC;
	sub_822C8CB8(ctx, base);
	// 829FF3FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FF400: 483F4029  bl 0x82df3428
	ctx.lr = 0x829FF404;
	sub_82DF3428(ctx, base);
	// 829FF404: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FF408: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FF40C: 388B77B4  addi r4, r11, 0x77b4
	ctx.r[4].s64 = ctx.r[11].s64 + 30644;
	// 829FF410: 483F45F9  bl 0x82df3a08
	ctx.lr = 0x829FF414;
	sub_82DF3A08(ctx, base);
	// 829FF414: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829FF418: 38610660  addi r3, r1, 0x660
	ctx.r[3].s64 = ctx.r[1].s64 + 1632;
	// 829FF41C: FC60E090  fmr f3, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[28].f64;
	// 829FF420: 388BE34C  addi r4, r11, -0x1cb4
	ctx.r[4].s64 = ctx.r[11].s64 + -7348;
	// 829FF424: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 829FF428: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829FF42C: 4BBA3D85  bl 0x825a31b0
	ctx.lr = 0x829FF430;
	sub_825A31B0(ctx, base);
	// 829FF430: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 829FF434: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829FF438: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FF43C: 4BBA2335  bl 0x825a1770
	ctx.lr = 0x829FF440;
	sub_825A1770(ctx, base);
	// 829FF440: 38610698  addi r3, r1, 0x698
	ctx.r[3].s64 = ctx.r[1].s64 + 1688;
	// 829FF444: 483F3FE5  bl 0x82df3428
	ctx.lr = 0x829FF448;
	sub_82DF3428(ctx, base);
	// 829FF448: 38610678  addi r3, r1, 0x678
	ctx.r[3].s64 = ctx.r[1].s64 + 1656;
	// 829FF44C: 4B8C986D  bl 0x822c8cb8
	ctx.lr = 0x829FF450;
	sub_822C8CB8(ctx, base);
	// 829FF450: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FF454: 483F3FD5  bl 0x82df3428
	ctx.lr = 0x829FF458;
	sub_82DF3428(ctx, base);
	// 829FF458: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FF45C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FF460: 388B77A0  addi r4, r11, 0x77a0
	ctx.r[4].s64 = ctx.r[11].s64 + 30624;
	// 829FF464: 483F45A5  bl 0x82df3a08
	ctx.lr = 0x829FF468;
	sub_82DF3A08(ctx, base);
	// 829FF468: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829FF46C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 829FF470: 38C00064  li r6, 0x64
	ctx.r[6].s64 = 100;
	// 829FF474: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829FF478: 388BE350  addi r4, r11, -0x1cb0
	ctx.r[4].s64 = ctx.r[11].s64 + -7344;
	// 829FF47C: 38610460  addi r3, r1, 0x460
	ctx.r[3].s64 = ctx.r[1].s64 + 1120;
	// 829FF480: 4BBA3F29  bl 0x825a33a8
	ctx.lr = 0x829FF484;
	sub_825A33A8(ctx, base);
	// 829FF484: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 829FF488: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829FF48C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FF490: 4BBA2A49  bl 0x825a1ed8
	ctx.lr = 0x829FF494;
	sub_825A1ED8(ctx, base);
	// 829FF494: 38610498  addi r3, r1, 0x498
	ctx.r[3].s64 = ctx.r[1].s64 + 1176;
	// 829FF498: 483F3F91  bl 0x82df3428
	ctx.lr = 0x829FF49C;
	sub_82DF3428(ctx, base);
	// 829FF49C: 38610478  addi r3, r1, 0x478
	ctx.r[3].s64 = ctx.r[1].s64 + 1144;
	// 829FF4A0: 4B8C9819  bl 0x822c8cb8
	ctx.lr = 0x829FF4A4;
	sub_822C8CB8(ctx, base);
	// 829FF4A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FF4A8: 483F3F81  bl 0x82df3428
	ctx.lr = 0x829FF4AC;
	sub_82DF3428(ctx, base);
	// 829FF4AC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FF4B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FF4B4: 388B7788  addi r4, r11, 0x7788
	ctx.r[4].s64 = ctx.r[11].s64 + 30600;
	// 829FF4B8: 483F4551  bl 0x82df3a08
	ctx.lr = 0x829FF4BC;
	sub_82DF3A08(ctx, base);
	// 829FF4BC: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829FF4C0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829FF4C4: FC60E890  fmr f3, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[29].f64;
	// 829FF4C8: 388BE354  addi r4, r11, -0x1cac
	ctx.r[4].s64 = ctx.r[11].s64 + -7340;
	// 829FF4CC: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 829FF4D0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829FF4D4: 4BBA3CDD  bl 0x825a31b0
	ctx.lr = 0x829FF4D8;
	sub_825A31B0(ctx, base);
	// 829FF4D8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 829FF4DC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829FF4E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FF4E4: 4BBA228D  bl 0x825a1770
	ctx.lr = 0x829FF4E8;
	sub_825A1770(ctx, base);
	// 829FF4E8: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 829FF4EC: 483F3F3D  bl 0x82df3428
	ctx.lr = 0x829FF4F0;
	sub_82DF3428(ctx, base);
	// 829FF4F0: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 829FF4F4: 4B8C97C5  bl 0x822c8cb8
	ctx.lr = 0x829FF4F8;
	sub_822C8CB8(ctx, base);
	// 829FF4F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FF4FC: 483F3F2D  bl 0x82df3428
	ctx.lr = 0x829FF500;
	sub_82DF3428(ctx, base);
	// 829FF500: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FF504: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FF508: 388B7770  addi r4, r11, 0x7770
	ctx.r[4].s64 = ctx.r[11].s64 + 30576;
	// 829FF50C: 483F44FD  bl 0x82df3a08
	ctx.lr = 0x829FF510;
	sub_82DF3A08(ctx, base);
	// 829FF510: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829FF514: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 829FF518: FC60E890  fmr f3, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[29].f64;
	// 829FF51C: 388BE358  addi r4, r11, -0x1ca8
	ctx.r[4].s64 = ctx.r[11].s64 + -7336;
	// 829FF520: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 829FF524: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829FF528: 4BBA3C89  bl 0x825a31b0
	ctx.lr = 0x829FF52C;
	sub_825A31B0(ctx, base);
	// 829FF52C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 829FF530: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829FF534: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FF538: 4BBA2239  bl 0x825a1770
	ctx.lr = 0x829FF53C;
	sub_825A1770(ctx, base);
	// 829FF53C: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 829FF540: 483F3EE9  bl 0x82df3428
	ctx.lr = 0x829FF544;
	sub_82DF3428(ctx, base);
	// 829FF544: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 829FF548: 4B8C9771  bl 0x822c8cb8
	ctx.lr = 0x829FF54C;
	sub_822C8CB8(ctx, base);
	// 829FF54C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FF550: 483F3ED9  bl 0x82df3428
	ctx.lr = 0x829FF554;
	sub_82DF3428(ctx, base);
	// 829FF554: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FF558: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FF55C: 388B7758  addi r4, r11, 0x7758
	ctx.r[4].s64 = ctx.r[11].s64 + 30552;
	// 829FF560: 483F44A9  bl 0x82df3a08
	ctx.lr = 0x829FF564;
	sub_82DF3A08(ctx, base);
	// 829FF564: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829FF568: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 829FF56C: FC60E890  fmr f3, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[29].f64;
	// 829FF570: 388BE35C  addi r4, r11, -0x1ca4
	ctx.r[4].s64 = ctx.r[11].s64 + -7332;
	// 829FF574: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 829FF578: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829FF57C: 4BBA3C35  bl 0x825a31b0
	ctx.lr = 0x829FF580;
	sub_825A31B0(ctx, base);
	// 829FF580: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 829FF584: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829FF588: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FF58C: 4BBA21E5  bl 0x825a1770
	ctx.lr = 0x829FF590;
	sub_825A1770(ctx, base);
	// 829FF590: 38610158  addi r3, r1, 0x158
	ctx.r[3].s64 = ctx.r[1].s64 + 344;
	// 829FF594: 483F3E95  bl 0x82df3428
	ctx.lr = 0x829FF598;
	sub_82DF3428(ctx, base);
	// 829FF598: 38610138  addi r3, r1, 0x138
	ctx.r[3].s64 = ctx.r[1].s64 + 312;
	// 829FF59C: 4B8C971D  bl 0x822c8cb8
	ctx.lr = 0x829FF5A0;
	sub_822C8CB8(ctx, base);
	// 829FF5A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FF5A4: 483F3E85  bl 0x82df3428
	ctx.lr = 0x829FF5A8;
	sub_82DF3428(ctx, base);
	// 829FF5A8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FF5AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FF5B0: 388B773C  addi r4, r11, 0x773c
	ctx.r[4].s64 = ctx.r[11].s64 + 30524;
	// 829FF5B4: 483F4455  bl 0x82df3a08
	ctx.lr = 0x829FF5B8;
	sub_82DF3A08(ctx, base);
	// 829FF5B8: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829FF5BC: 386101A0  addi r3, r1, 0x1a0
	ctx.r[3].s64 = ctx.r[1].s64 + 416;
	// 829FF5C0: FC60E890  fmr f3, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[29].f64;
	// 829FF5C4: 388BE360  addi r4, r11, -0x1ca0
	ctx.r[4].s64 = ctx.r[11].s64 + -7328;
	// 829FF5C8: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 829FF5CC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829FF5D0: 4BBA3BE1  bl 0x825a31b0
	ctx.lr = 0x829FF5D4;
	sub_825A31B0(ctx, base);
	// 829FF5D4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 829FF5D8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829FF5DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FF5E0: 4BBA2191  bl 0x825a1770
	ctx.lr = 0x829FF5E4;
	sub_825A1770(ctx, base);
	// 829FF5E4: 386101D8  addi r3, r1, 0x1d8
	ctx.r[3].s64 = ctx.r[1].s64 + 472;
	// 829FF5E8: 483F3E41  bl 0x82df3428
	ctx.lr = 0x829FF5EC;
	sub_82DF3428(ctx, base);
	// 829FF5EC: 386101B8  addi r3, r1, 0x1b8
	ctx.r[3].s64 = ctx.r[1].s64 + 440;
	// 829FF5F0: 4B8C96C9  bl 0x822c8cb8
	ctx.lr = 0x829FF5F4;
	sub_822C8CB8(ctx, base);
	// 829FF5F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FF5F8: 483F3E31  bl 0x82df3428
	ctx.lr = 0x829FF5FC;
	sub_82DF3428(ctx, base);
	// 829FF5FC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FF600: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FF604: 388B7720  addi r4, r11, 0x7720
	ctx.r[4].s64 = ctx.r[11].s64 + 30496;
	// 829FF608: 483F4401  bl 0x82df3a08
	ctx.lr = 0x829FF60C;
	sub_82DF3A08(ctx, base);
	// 829FF60C: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829FF610: 38610220  addi r3, r1, 0x220
	ctx.r[3].s64 = ctx.r[1].s64 + 544;
	// 829FF614: FC60E890  fmr f3, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[29].f64;
	// 829FF618: 388BE364  addi r4, r11, -0x1c9c
	ctx.r[4].s64 = ctx.r[11].s64 + -7324;
	// 829FF61C: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 829FF620: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829FF624: 4BBA3B8D  bl 0x825a31b0
	ctx.lr = 0x829FF628;
	sub_825A31B0(ctx, base);
	// 829FF628: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 829FF62C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829FF630: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FF634: 4BBA213D  bl 0x825a1770
	ctx.lr = 0x829FF638;
	sub_825A1770(ctx, base);
	// 829FF638: 38610258  addi r3, r1, 0x258
	ctx.r[3].s64 = ctx.r[1].s64 + 600;
	// 829FF63C: 483F3DED  bl 0x82df3428
	ctx.lr = 0x829FF640;
	sub_82DF3428(ctx, base);
	// 829FF640: 38610238  addi r3, r1, 0x238
	ctx.r[3].s64 = ctx.r[1].s64 + 568;
	// 829FF644: 4B8C9675  bl 0x822c8cb8
	ctx.lr = 0x829FF648;
	sub_822C8CB8(ctx, base);
	// 829FF648: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FF64C: 483F3DDD  bl 0x82df3428
	ctx.lr = 0x829FF650;
	sub_82DF3428(ctx, base);
	// 829FF650: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FF654: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FF658: 388B7708  addi r4, r11, 0x7708
	ctx.r[4].s64 = ctx.r[11].s64 + 30472;
	// 829FF65C: 483F43AD  bl 0x82df3a08
	ctx.lr = 0x829FF660;
	sub_82DF3A08(ctx, base);
	// 829FF660: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829FF664: 386102A0  addi r3, r1, 0x2a0
	ctx.r[3].s64 = ctx.r[1].s64 + 672;
	// 829FF668: FC60E890  fmr f3, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[29].f64;
	// 829FF66C: 388BE368  addi r4, r11, -0x1c98
	ctx.r[4].s64 = ctx.r[11].s64 + -7320;
	// 829FF670: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 829FF674: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829FF678: 4BBA3B39  bl 0x825a31b0
	ctx.lr = 0x829FF67C;
	sub_825A31B0(ctx, base);
	// 829FF67C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 829FF680: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829FF684: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FF688: 4BBA20E9  bl 0x825a1770
	ctx.lr = 0x829FF68C;
	sub_825A1770(ctx, base);
	// 829FF68C: 386102D8  addi r3, r1, 0x2d8
	ctx.r[3].s64 = ctx.r[1].s64 + 728;
	// 829FF690: 483F3D99  bl 0x82df3428
	ctx.lr = 0x829FF694;
	sub_82DF3428(ctx, base);
	// 829FF694: 386102B8  addi r3, r1, 0x2b8
	ctx.r[3].s64 = ctx.r[1].s64 + 696;
	// 829FF698: 4B8C9621  bl 0x822c8cb8
	ctx.lr = 0x829FF69C;
	sub_822C8CB8(ctx, base);
	// 829FF69C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FF6A0: 483F3D89  bl 0x82df3428
	ctx.lr = 0x829FF6A4;
	sub_82DF3428(ctx, base);
	// 829FF6A4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FF6A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FF6AC: 388B76F0  addi r4, r11, 0x76f0
	ctx.r[4].s64 = ctx.r[11].s64 + 30448;
	// 829FF6B0: 483F4359  bl 0x82df3a08
	ctx.lr = 0x829FF6B4;
	sub_82DF3A08(ctx, base);
	// 829FF6B4: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829FF6B8: 38610320  addi r3, r1, 0x320
	ctx.r[3].s64 = ctx.r[1].s64 + 800;
	// 829FF6BC: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 829FF6C0: 388BE36C  addi r4, r11, -0x1c94
	ctx.r[4].s64 = ctx.r[11].s64 + -7316;
	// 829FF6C4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829FF6C8: FC60E090  fmr f3, f28
	ctx.f[3].f64 = ctx.f[28].f64;
	// 829FF6CC: 4BBA3AE5  bl 0x825a31b0
	ctx.lr = 0x829FF6D0;
	sub_825A31B0(ctx, base);
	// 829FF6D0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 829FF6D4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829FF6D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FF6DC: 4BBA2095  bl 0x825a1770
	ctx.lr = 0x829FF6E0;
	sub_825A1770(ctx, base);
	// 829FF6E0: 38610358  addi r3, r1, 0x358
	ctx.r[3].s64 = ctx.r[1].s64 + 856;
	// 829FF6E4: 483F3D45  bl 0x82df3428
	ctx.lr = 0x829FF6E8;
	sub_82DF3428(ctx, base);
	// 829FF6E8: 38610338  addi r3, r1, 0x338
	ctx.r[3].s64 = ctx.r[1].s64 + 824;
	// 829FF6EC: 4B8C95CD  bl 0x822c8cb8
	ctx.lr = 0x829FF6F0;
	sub_822C8CB8(ctx, base);
	// 829FF6F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FF6F4: 483F3D35  bl 0x82df3428
	ctx.lr = 0x829FF6F8;
	sub_82DF3428(ctx, base);
	// 829FF6F8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FF6FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FF700: 388B76E0  addi r4, r11, 0x76e0
	ctx.r[4].s64 = ctx.r[11].s64 + 30432;
	// 829FF704: 483F4305  bl 0x82df3a08
	ctx.lr = 0x829FF708;
	sub_82DF3A08(ctx, base);
	// 829FF708: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829FF70C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 829FF710: 388BE370  addi r4, r11, -0x1c90
	ctx.r[4].s64 = ctx.r[11].s64 + -7312;
	// 829FF714: 38C00064  li r6, 0x64
	ctx.r[6].s64 = 100;
	// 829FF718: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829FF71C: 386103A0  addi r3, r1, 0x3a0
	ctx.r[3].s64 = ctx.r[1].s64 + 928;
	// 829FF720: 4BBA3C89  bl 0x825a33a8
	ctx.lr = 0x829FF724;
	sub_825A33A8(ctx, base);
	// 829FF724: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 829FF728: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829FF72C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FF730: 4BBA27A9  bl 0x825a1ed8
	ctx.lr = 0x829FF734;
	sub_825A1ED8(ctx, base);
	// 829FF734: 386103D8  addi r3, r1, 0x3d8
	ctx.r[3].s64 = ctx.r[1].s64 + 984;
	// 829FF738: 483F3CF1  bl 0x82df3428
	ctx.lr = 0x829FF73C;
	sub_82DF3428(ctx, base);
	// 829FF73C: 386103B8  addi r3, r1, 0x3b8
	ctx.r[3].s64 = ctx.r[1].s64 + 952;
	// 829FF740: 4B8C9579  bl 0x822c8cb8
	ctx.lr = 0x829FF744;
	sub_822C8CB8(ctx, base);
	// 829FF744: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FF748: 483F3CE1  bl 0x82df3428
	ctx.lr = 0x829FF74C;
	sub_82DF3428(ctx, base);
	// 829FF74C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FF750: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FF754: 388B76CC  addi r4, r11, 0x76cc
	ctx.r[4].s64 = ctx.r[11].s64 + 30412;
	// 829FF758: 483F42B1  bl 0x82df3a08
	ctx.lr = 0x829FF75C;
	sub_82DF3A08(ctx, base);
	// 829FF75C: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829FF760: 38610420  addi r3, r1, 0x420
	ctx.r[3].s64 = ctx.r[1].s64 + 1056;
	// 829FF764: FC60E890  fmr f3, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[29].f64;
	// 829FF768: 388BE374  addi r4, r11, -0x1c8c
	ctx.r[4].s64 = ctx.r[11].s64 + -7308;
	// 829FF76C: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 829FF770: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829FF774: 4BBA3A3D  bl 0x825a31b0
	ctx.lr = 0x829FF778;
	sub_825A31B0(ctx, base);
	// 829FF778: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 829FF77C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829FF780: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FF784: 4BBA1FED  bl 0x825a1770
	ctx.lr = 0x829FF788;
	sub_825A1770(ctx, base);
	// 829FF788: 38610458  addi r3, r1, 0x458
	ctx.r[3].s64 = ctx.r[1].s64 + 1112;
	// 829FF78C: 483F3C9D  bl 0x82df3428
	ctx.lr = 0x829FF790;
	sub_82DF3428(ctx, base);
	// 829FF790: 38610438  addi r3, r1, 0x438
	ctx.r[3].s64 = ctx.r[1].s64 + 1080;
	// 829FF794: 4B8C9525  bl 0x822c8cb8
	ctx.lr = 0x829FF798;
	sub_822C8CB8(ctx, base);
	// 829FF798: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FF79C: 483F3C8D  bl 0x82df3428
	ctx.lr = 0x829FF7A0;
	sub_82DF3428(ctx, base);
	// 829FF7A0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FF7A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FF7A8: 388B76B8  addi r4, r11, 0x76b8
	ctx.r[4].s64 = ctx.r[11].s64 + 30392;
	// 829FF7AC: 483F425D  bl 0x82df3a08
	ctx.lr = 0x829FF7B0;
	sub_82DF3A08(ctx, base);
	// 829FF7B0: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829FF7B4: 386104A0  addi r3, r1, 0x4a0
	ctx.r[3].s64 = ctx.r[1].s64 + 1184;
	// 829FF7B8: FC60E890  fmr f3, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[29].f64;
	// 829FF7BC: 388BE378  addi r4, r11, -0x1c88
	ctx.r[4].s64 = ctx.r[11].s64 + -7304;
	// 829FF7C0: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 829FF7C4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829FF7C8: 4BBA39E9  bl 0x825a31b0
	ctx.lr = 0x829FF7CC;
	sub_825A31B0(ctx, base);
	// 829FF7CC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 829FF7D0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829FF7D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FF7D8: 4BBA1F99  bl 0x825a1770
	ctx.lr = 0x829FF7DC;
	sub_825A1770(ctx, base);
	// 829FF7DC: 386104D8  addi r3, r1, 0x4d8
	ctx.r[3].s64 = ctx.r[1].s64 + 1240;
	// 829FF7E0: 483F3C49  bl 0x82df3428
	ctx.lr = 0x829FF7E4;
	sub_82DF3428(ctx, base);
	// 829FF7E4: 386104B8  addi r3, r1, 0x4b8
	ctx.r[3].s64 = ctx.r[1].s64 + 1208;
	// 829FF7E8: 4B8C94D1  bl 0x822c8cb8
	ctx.lr = 0x829FF7EC;
	sub_822C8CB8(ctx, base);
	// 829FF7EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FF7F0: 483F3C39  bl 0x82df3428
	ctx.lr = 0x829FF7F4;
	sub_82DF3428(ctx, base);
	// 829FF7F4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FF7F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FF7FC: 388B76A4  addi r4, r11, 0x76a4
	ctx.r[4].s64 = ctx.r[11].s64 + 30372;
	// 829FF800: 483F4209  bl 0x82df3a08
	ctx.lr = 0x829FF804;
	sub_82DF3A08(ctx, base);
	// 829FF804: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829FF808: FC60E890  fmr f3, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[29].f64;
	// 829FF80C: 38610520  addi r3, r1, 0x520
	ctx.r[3].s64 = ctx.r[1].s64 + 1312;
	// 829FF810: 388BE37C  addi r4, r11, -0x1c84
	ctx.r[4].s64 = ctx.r[11].s64 + -7300;
	// 829FF814: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 829FF818: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829FF81C: 4BBA3995  bl 0x825a31b0
	ctx.lr = 0x829FF820;
	sub_825A31B0(ctx, base);
	// 829FF820: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 829FF824: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829FF828: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FF82C: 4BBA1F45  bl 0x825a1770
	ctx.lr = 0x829FF830;
	sub_825A1770(ctx, base);
	// 829FF830: 38610558  addi r3, r1, 0x558
	ctx.r[3].s64 = ctx.r[1].s64 + 1368;
	// 829FF834: 483F3BF5  bl 0x82df3428
	ctx.lr = 0x829FF838;
	sub_82DF3428(ctx, base);
	// 829FF838: 38610538  addi r3, r1, 0x538
	ctx.r[3].s64 = ctx.r[1].s64 + 1336;
	// 829FF83C: 4B8C947D  bl 0x822c8cb8
	ctx.lr = 0x829FF840;
	sub_822C8CB8(ctx, base);
	// 829FF840: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FF844: 483F3BE5  bl 0x82df3428
	ctx.lr = 0x829FF848;
	sub_82DF3428(ctx, base);
	// 829FF848: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FF84C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FF850: 388B768C  addi r4, r11, 0x768c
	ctx.r[4].s64 = ctx.r[11].s64 + 30348;
	// 829FF854: 483F41B5  bl 0x82df3a08
	ctx.lr = 0x829FF858;
	sub_82DF3A08(ctx, base);
	// 829FF858: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829FF85C: 386105A0  addi r3, r1, 0x5a0
	ctx.r[3].s64 = ctx.r[1].s64 + 1440;
	// 829FF860: FC60E890  fmr f3, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[29].f64;
	// 829FF864: 388BE380  addi r4, r11, -0x1c80
	ctx.r[4].s64 = ctx.r[11].s64 + -7296;
	// 829FF868: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 829FF86C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829FF870: 4BBA3941  bl 0x825a31b0
	ctx.lr = 0x829FF874;
	sub_825A31B0(ctx, base);
	// 829FF874: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 829FF878: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829FF87C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FF880: 4BBA1EF1  bl 0x825a1770
	ctx.lr = 0x829FF884;
	sub_825A1770(ctx, base);
	// 829FF884: 386105D8  addi r3, r1, 0x5d8
	ctx.r[3].s64 = ctx.r[1].s64 + 1496;
	// 829FF888: 483F3BA1  bl 0x82df3428
	ctx.lr = 0x829FF88C;
	sub_82DF3428(ctx, base);
	// 829FF88C: 386105B8  addi r3, r1, 0x5b8
	ctx.r[3].s64 = ctx.r[1].s64 + 1464;
	// 829FF890: 4B8C9429  bl 0x822c8cb8
	ctx.lr = 0x829FF894;
	sub_822C8CB8(ctx, base);
	// 829FF894: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FF898: 483F3B91  bl 0x82df3428
	ctx.lr = 0x829FF89C;
	sub_82DF3428(ctx, base);
	// 829FF89C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FF8A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FF8A4: 388B7674  addi r4, r11, 0x7674
	ctx.r[4].s64 = ctx.r[11].s64 + 30324;
	// 829FF8A8: 483F4161  bl 0x82df3a08
	ctx.lr = 0x829FF8AC;
	sub_82DF3A08(ctx, base);
	// 829FF8AC: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829FF8B0: 38610620  addi r3, r1, 0x620
	ctx.r[3].s64 = ctx.r[1].s64 + 1568;
	// 829FF8B4: FC60E890  fmr f3, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[29].f64;
	// 829FF8B8: 388BE384  addi r4, r11, -0x1c7c
	ctx.r[4].s64 = ctx.r[11].s64 + -7292;
	// 829FF8BC: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 829FF8C0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829FF8C4: 4BBA38ED  bl 0x825a31b0
	ctx.lr = 0x829FF8C8;
	sub_825A31B0(ctx, base);
	// 829FF8C8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 829FF8CC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829FF8D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FF8D4: 4BBA1E9D  bl 0x825a1770
	ctx.lr = 0x829FF8D8;
	sub_825A1770(ctx, base);
	// 829FF8D8: 38610658  addi r3, r1, 0x658
	ctx.r[3].s64 = ctx.r[1].s64 + 1624;
	// 829FF8DC: 483F3B4D  bl 0x82df3428
	ctx.lr = 0x829FF8E0;
	sub_82DF3428(ctx, base);
	// 829FF8E0: 38610638  addi r3, r1, 0x638
	ctx.r[3].s64 = ctx.r[1].s64 + 1592;
	// 829FF8E4: 4B8C93D5  bl 0x822c8cb8
	ctx.lr = 0x829FF8E8;
	sub_822C8CB8(ctx, base);
	// 829FF8E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FF8EC: 483F3B3D  bl 0x82df3428
	ctx.lr = 0x829FF8F0;
	sub_82DF3428(ctx, base);
	// 829FF8F0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FF8F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FF8F8: 388B7660  addi r4, r11, 0x7660
	ctx.r[4].s64 = ctx.r[11].s64 + 30304;
	// 829FF8FC: 483F410D  bl 0x82df3a08
	ctx.lr = 0x829FF900;
	sub_82DF3A08(ctx, base);
	// 829FF900: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829FF904: 386106A0  addi r3, r1, 0x6a0
	ctx.r[3].s64 = ctx.r[1].s64 + 1696;
	// 829FF908: FC60E890  fmr f3, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[29].f64;
	// 829FF90C: 388BE388  addi r4, r11, -0x1c78
	ctx.r[4].s64 = ctx.r[11].s64 + -7288;
	// 829FF910: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 829FF914: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829FF918: 4BBA3899  bl 0x825a31b0
	ctx.lr = 0x829FF91C;
	sub_825A31B0(ctx, base);
	// 829FF91C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 829FF920: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829FF924: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FF928: 4BBA1E49  bl 0x825a1770
	ctx.lr = 0x829FF92C;
	sub_825A1770(ctx, base);
	// 829FF92C: 386106D8  addi r3, r1, 0x6d8
	ctx.r[3].s64 = ctx.r[1].s64 + 1752;
	// 829FF930: 483F3AF9  bl 0x82df3428
	ctx.lr = 0x829FF934;
	sub_82DF3428(ctx, base);
	// 829FF934: 386106B8  addi r3, r1, 0x6b8
	ctx.r[3].s64 = ctx.r[1].s64 + 1720;
	// 829FF938: 4B8C9381  bl 0x822c8cb8
	ctx.lr = 0x829FF93C;
	sub_822C8CB8(ctx, base);
	// 829FF93C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FF940: 483F3AE9  bl 0x82df3428
	ctx.lr = 0x829FF944;
	sub_82DF3428(ctx, base);
	// 829FF944: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FF948: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FF94C: 388B7648  addi r4, r11, 0x7648
	ctx.r[4].s64 = ctx.r[11].s64 + 30280;
	// 829FF950: 483F40B9  bl 0x82df3a08
	ctx.lr = 0x829FF954;
	sub_82DF3A08(ctx, base);
	// 829FF954: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829FF958: FC60E090  fmr f3, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[28].f64;
	// 829FF95C: 38610720  addi r3, r1, 0x720
	ctx.r[3].s64 = ctx.r[1].s64 + 1824;
	// 829FF960: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 829FF964: 388BE38C  addi r4, r11, -0x1c74
	ctx.r[4].s64 = ctx.r[11].s64 + -7284;
	// 829FF968: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829FF96C: 4BBA3845  bl 0x825a31b0
	ctx.lr = 0x829FF970;
	sub_825A31B0(ctx, base);
	// 829FF970: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 829FF974: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829FF978: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FF97C: 4BBA1DF5  bl 0x825a1770
	ctx.lr = 0x829FF980;
	sub_825A1770(ctx, base);
	// 829FF980: 38610758  addi r3, r1, 0x758
	ctx.r[3].s64 = ctx.r[1].s64 + 1880;
	// 829FF984: 483F3AA5  bl 0x82df3428
	ctx.lr = 0x829FF988;
	sub_82DF3428(ctx, base);
	// 829FF988: 38610738  addi r3, r1, 0x738
	ctx.r[3].s64 = ctx.r[1].s64 + 1848;
	// 829FF98C: 4B8C932D  bl 0x822c8cb8
	ctx.lr = 0x829FF990;
	sub_822C8CB8(ctx, base);
	// 829FF990: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FF994: 483F3A95  bl 0x82df3428
	ctx.lr = 0x829FF998;
	sub_82DF3428(ctx, base);
	// 829FF998: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FF99C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FF9A0: 388B7630  addi r4, r11, 0x7630
	ctx.r[4].s64 = ctx.r[11].s64 + 30256;
	// 829FF9A4: 483F4065  bl 0x82df3a08
	ctx.lr = 0x829FF9A8;
	sub_82DF3A08(ctx, base);
	// 829FF9A8: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829FF9AC: 386107A0  addi r3, r1, 0x7a0
	ctx.r[3].s64 = ctx.r[1].s64 + 1952;
	// 829FF9B0: FC60E890  fmr f3, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[29].f64;
	// 829FF9B4: 388BE390  addi r4, r11, -0x1c70
	ctx.r[4].s64 = ctx.r[11].s64 + -7280;
	// 829FF9B8: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 829FF9BC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829FF9C0: 4BBA37F1  bl 0x825a31b0
	ctx.lr = 0x829FF9C4;
	sub_825A31B0(ctx, base);
	// 829FF9C4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 829FF9C8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829FF9CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FF9D0: 4BBA1DA1  bl 0x825a1770
	ctx.lr = 0x829FF9D4;
	sub_825A1770(ctx, base);
	// 829FF9D4: 386107D8  addi r3, r1, 0x7d8
	ctx.r[3].s64 = ctx.r[1].s64 + 2008;
	// 829FF9D8: 483F3A51  bl 0x82df3428
	ctx.lr = 0x829FF9DC;
	sub_82DF3428(ctx, base);
	// 829FF9DC: 386107B8  addi r3, r1, 0x7b8
	ctx.r[3].s64 = ctx.r[1].s64 + 1976;
	// 829FF9E0: 4B8C92D9  bl 0x822c8cb8
	ctx.lr = 0x829FF9E4;
	sub_822C8CB8(ctx, base);
	// 829FF9E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FF9E8: 483F3A41  bl 0x82df3428
	ctx.lr = 0x829FF9EC;
	sub_82DF3428(ctx, base);
	// 829FF9EC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FF9F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FF9F4: 388B761C  addi r4, r11, 0x761c
	ctx.r[4].s64 = ctx.r[11].s64 + 30236;
	// 829FF9F8: 483F4011  bl 0x82df3a08
	ctx.lr = 0x829FF9FC;
	sub_82DF3A08(ctx, base);
	// 829FF9FC: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829FFA00: 38610820  addi r3, r1, 0x820
	ctx.r[3].s64 = ctx.r[1].s64 + 2080;
	// 829FFA04: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 829FFA08: 388BE394  addi r4, r11, -0x1c6c
	ctx.r[4].s64 = ctx.r[11].s64 + -7276;
	// 829FFA0C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829FFA10: FC60E890  fmr f3, f29
	ctx.f[3].f64 = ctx.f[29].f64;
	// 829FFA14: 4BBA379D  bl 0x825a31b0
	ctx.lr = 0x829FFA18;
	sub_825A31B0(ctx, base);
	// 829FFA18: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 829FFA1C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829FFA20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FFA24: 4BBA1D4D  bl 0x825a1770
	ctx.lr = 0x829FFA28;
	sub_825A1770(ctx, base);
	// 829FFA28: 38610858  addi r3, r1, 0x858
	ctx.r[3].s64 = ctx.r[1].s64 + 2136;
	// 829FFA2C: 483F39FD  bl 0x82df3428
	ctx.lr = 0x829FFA30;
	sub_82DF3428(ctx, base);
	// 829FFA30: 38610838  addi r3, r1, 0x838
	ctx.r[3].s64 = ctx.r[1].s64 + 2104;
	// 829FFA34: 4B8C9285  bl 0x822c8cb8
	ctx.lr = 0x829FFA38;
	sub_822C8CB8(ctx, base);
	// 829FFA38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FFA3C: 483F39ED  bl 0x82df3428
	ctx.lr = 0x829FFA40;
	sub_82DF3428(ctx, base);
	// 829FFA40: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FFA44: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FFA48: 388B7608  addi r4, r11, 0x7608
	ctx.r[4].s64 = ctx.r[11].s64 + 30216;
	// 829FFA4C: 483F3FBD  bl 0x82df3a08
	ctx.lr = 0x829FFA50;
	sub_82DF3A08(ctx, base);
	// 829FFA50: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829FFA54: 386108A0  addi r3, r1, 0x8a0
	ctx.r[3].s64 = ctx.r[1].s64 + 2208;
	// 829FFA58: FC60E090  fmr f3, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[28].f64;
	// 829FFA5C: 388BE398  addi r4, r11, -0x1c68
	ctx.r[4].s64 = ctx.r[11].s64 + -7272;
	// 829FFA60: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 829FFA64: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829FFA68: 4BBA3749  bl 0x825a31b0
	ctx.lr = 0x829FFA6C;
	sub_825A31B0(ctx, base);
	// 829FFA6C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 829FFA70: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829FFA74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FFA78: 4BBA1CF9  bl 0x825a1770
	ctx.lr = 0x829FFA7C;
	sub_825A1770(ctx, base);
	// 829FFA7C: 386108D8  addi r3, r1, 0x8d8
	ctx.r[3].s64 = ctx.r[1].s64 + 2264;
	// 829FFA80: 483F39A9  bl 0x82df3428
	ctx.lr = 0x829FFA84;
	sub_82DF3428(ctx, base);
	// 829FFA84: 386108B8  addi r3, r1, 0x8b8
	ctx.r[3].s64 = ctx.r[1].s64 + 2232;
	// 829FFA88: 4B8C9231  bl 0x822c8cb8
	ctx.lr = 0x829FFA8C;
	sub_822C8CB8(ctx, base);
	// 829FFA8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FFA90: 483F3999  bl 0x82df3428
	ctx.lr = 0x829FFA94;
	sub_82DF3428(ctx, base);
	// 829FFA94: 38210920  addi r1, r1, 0x920
	ctx.r[1].s64 = ctx.r[1].s64 + 2336;
	// 829FFA98: 3981FFF0  addi r12, r1, -0x10
	ctx.r[12].s64 = ctx.r[1].s64 + -16;
	// 829FFA9C: 487A9021  bl 0x831a8abc
	ctx.lr = 0x829FFAA0;
	sub_831A8A8C(ctx, base);
	// 829FFAA0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829FFAA4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829FFAA8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829FFAAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FFAB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FFAB0 size=76
    let mut pc: u32 = 0x829FFAB0;
    'dispatch: loop {
        match pc {
            0x829FFAB0 => {
    //   block [0x829FFAB0..0x829FFAFC)
	// 829FFAB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FFAB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829FFAB8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829FFABC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829FFAC0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FFAC4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FFAC8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829FFACC: 4BFFE99D  bl 0x829fe468
	ctx.lr = 0x829FFAD0;
	sub_829FE468(ctx, base);
	// 829FFAD0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829FFAD4: 4182000C  beq 0x829ffae0
	if ctx.cr[0].eq {
	pc = 0x829FFAE0; continue 'dispatch;
	}
	// 829FFAD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FFADC: 483F28FD  bl 0x82df23d8
	ctx.lr = 0x829FFAE0;
	sub_82DF23D8(ctx, base);
	// 829FFAE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FFAE4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829FFAE8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829FFAEC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829FFAF0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829FFAF4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829FFAF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FFB00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829FFB00 size=792
    let mut pc: u32 = 0x829FFB00;
    'dispatch: loop {
        match pc {
            0x829FFB00 => {
    //   block [0x829FFB00..0x829FFE18)
	// 829FFB00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FFB04: 487A8661  bl 0x831a8164
	ctx.lr = 0x829FFB08;
	sub_831A8130(ctx, base);
	// 829FFB08: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 829FFB0C: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FFB10: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FFB14: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 829FFB18: 817F00E4  lwz r11, 0xe4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 829FFB1C: 896B0040  lbz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 829FFB20: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829FFB24: 408202E8  bne 0x829ffe0c
	if !ctx.cr[0].eq {
	pc = 0x829FFE0C; continue 'dispatch;
	}
	// 829FFB28: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829FFB2C: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 829FFB30: 4BB0F999  bl 0x8250f4c8
	ctx.lr = 0x829FFB34;
	sub_8250F4C8(ctx, base);
	// 829FFB34: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FFB38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FFB3C: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 829FFB40: 409A0008  bne cr6, 0x829ffb48
	if !ctx.cr[6].eq {
	pc = 0x829FFB48; continue 'dispatch;
	}
	// 829FFB44: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 829FFB48: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829FFB4C: 4BB08ECD  bl 0x82508a18
	ctx.lr = 0x829FFB50;
	sub_82508A18(ctx, base);
	// 829FFB50: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829FFB54: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829FFB58: 486085D1  bl 0x83008128
	ctx.lr = 0x829FFB5C;
	sub_83008128(ctx, base);
	// 829FFB5C: 7D63F050  subf r11, r3, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[3].s64;
	// 829FFB60: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 829FFB64: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 829FFB68: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 829FFB6C: 697E0001  xori r30, r11, 1
	ctx.r[30].u64 = ctx.r[11].u64 ^ 1;
	// 829FFB70: 483F2121  bl 0x82df1c90
	ctx.lr = 0x829FFB74;
	sub_82DF1C90(ctx, base);
	// 829FFB74: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829FFB78: 40820294  bne 0x829ffe0c
	if !ctx.cr[0].eq {
	pc = 0x829FFE0C; continue 'dispatch;
	}
	// 829FFB7C: 817F00E4  lwz r11, 0xe4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 829FFB80: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 829FFB84: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
	// 829FFB88: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 829FFB8C: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 829FFB90: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 829FFB94: 9BCB0040  stb r30, 0x40(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), ctx.r[30].u8 ) };
	// 829FFB98: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 829FFB9C: 80DF00E4  lwz r6, 0xe4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 829FFBA0: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 829FFBA4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829FFBA8: C3E708A4  lfs f31, 0x8a4(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829FFBAC: C00BD7BC  lfs f0, -0x2844(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FFBB0: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 829FFBB4: 13E650C7  vcmpequd (lvx128) v31, v6, v10
	tmp.u32 = ctx.r[6].u32 + ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829FFBB8: 13C648C7  vcmpequd (lvx128) v30, v6, v9
	tmp.u32 = ctx.r[6].u32 + ctx.r[9].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FFE18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829FFE18 size=1996
    let mut pc: u32 = 0x829FFE18;
    'dispatch: loop {
        match pc {
            0x829FFE18 => {
    //   block [0x829FFE18..0x82A005E4)
	// 829FFE18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FFE1C: 487A8349  bl 0x831a8164
	ctx.lr = 0x829FFE20;
	sub_831A8130(ctx, base);
	// 829FFE20: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 829FFE24: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FFE28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FFE2C: 487547D5  bl 0x83154600
	ctx.lr = 0x829FFE30;
	sub_83154600(ctx, base);
	// 829FFE30: 897F0068  lbz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 829FFE34: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829FFE38: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829FFE3C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829FFE40: 41980644  blt cr6, 0x82a00484
	if ctx.cr[6].lt {
	pc = 0x82A00484; continue 'dispatch;
	}
	// 829FFE44: 419A03E8  beq cr6, 0x82a0022c
	if ctx.cr[6].eq {
	pc = 0x82A0022C; continue 'dispatch;
	}
	// 829FFE48: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 829FFE4C: 41980214  blt cr6, 0x82a00060
	if ctx.cr[6].lt {
	pc = 0x82A00060; continue 'dispatch;
	}
	// 829FFE50: 419A00E4  beq cr6, 0x829fff34
	if ctx.cr[6].eq {
	pc = 0x829FFF34; continue 'dispatch;
	}
	// 829FFE54: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 829FFE58: 40980770  bge cr6, 0x82a005c8
	if !ctx.cr[6].lt {
	pc = 0x82A005C8; continue 'dispatch;
	}
	// 829FFE5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FFE60: 48459901  bl 0x82e59760
	ctx.lr = 0x829FFE64;
	sub_82E59760(ctx, base);
	// 829FFE64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FFE68: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 829FFE6C: 4BFEE0FD  bl 0x829edf68
	ctx.lr = 0x829FFE70;
	sub_829EDF68(ctx, base);
	// 829FFE70: 897F0068  lbz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 829FFE74: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829FFE78: 396B000E  addi r11, r11, 0xe
	ctx.r[11].s64 = ctx.r[11].s64 + 14;
	// 829FFE7C: 1D6B0003  mulli r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 * 3;
	// 829FFE80: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 829FFE84: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829FFE88: 7C0BFC2E  lfsx f0, r11, r31
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FFE8C: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 829FFE90: 41980738  blt cr6, 0x82a005c8
	if ctx.cr[6].lt {
	pc = 0x82A005C8; continue 'dispatch;
	}
	// 829FFE94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FFE98: 48754769  bl 0x83154600
	ctx.lr = 0x829FFE9C;
	sub_83154600(ctx, base);
	// 829FFE9C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829FFEA0: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 829FFEA4: 4BFEF815  bl 0x829ef6b8
	ctx.lr = 0x829FFEA8;
	sub_829EF6B8(ctx, base);
	// 829FFEA8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FFEAC: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 829FFEB0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FFEB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FFEB8: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 829FFEBC: 419A0024  beq cr6, 0x829ffee0
	if ctx.cr[6].eq {
	pc = 0x829FFEE0; continue 'dispatch;
	}
	// 829FFEC0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829FFEC4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829FFEC8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829FFECC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829FFED0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829FFED4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829FFED8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829FFEDC: 4082FFE8  bne 0x829ffec4
	if !ctx.cr[0].eq {
	pc = 0x829FFEC4; continue 'dispatch;
	}
	// 829FFEE0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829FFEE4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 829FFEE8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829FFEEC: 38A10078  addi r5, r1, 0x78
	ctx.r[5].s64 = ctx.r[1].s64 + 120;
	// 829FFEF0: 389E00E8  addi r4, r30, 0xe8
	ctx.r[4].s64 = ctx.r[30].s64 + 232;
	// 829FFEF4: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 829FFEF8: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829FFEFC: 4845E7AD  bl 0x82e5e6a8
	ctx.lr = 0x829FFF00;
	sub_82E5E6A8(ctx, base);
	// 829FFF00: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 829FFF04: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FFF08: 419A0008  beq cr6, 0x829fff10
	if ctx.cr[6].eq {
	pc = 0x829FFF10; continue 'dispatch;
	}
	// 829FFF0C: 4B8C0985  bl 0x822c0890
	ctx.lr = 0x829FFF10;
	sub_822C0890(ctx, base);
	// 829FFF10: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 829FFF14: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FFF18: 419A0008  beq cr6, 0x829fff20
	if ctx.cr[6].eq {
	pc = 0x829FFF20; continue 'dispatch;
	}
	// 829FFF1C: 4B8C0975  bl 0x822c0890
	ctx.lr = 0x829FFF20;
	sub_822C0890(ctx, base);
	// 829FFF20: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 829FFF24: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FFF28: 419A06A0  beq cr6, 0x82a005c8
	if ctx.cr[6].eq {
	pc = 0x82A005C8; continue 'dispatch;
	}
	// 829FFF2C: 4B8C0965  bl 0x822c0890
	ctx.lr = 0x829FFF30;
	sub_822C0890(ctx, base);
	// 829FFF30: 48000698  b 0x82a005c8
	pc = 0x82A005C8; continue 'dispatch;
	// 829FFF34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FFF38: 48459829  bl 0x82e59760
	ctx.lr = 0x829FFF3C;
	sub_82E59760(ctx, base);
	// 829FFF3C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FFF40: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 829FFF44: 4BFEE025  bl 0x829edf68
	ctx.lr = 0x829FFF48;
	sub_829EDF68(ctx, base);
	// 829FFF48: 897F0068  lbz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 829FFF4C: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829FFF50: 396B000E  addi r11, r11, 0xe
	ctx.r[11].s64 = ctx.r[11].s64 + 14;
	// 829FFF54: 1D6B0003  mulli r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 * 3;
	// 829FFF58: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 829FFF5C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829FFF60: 7C0BFC2E  lfsx f0, r11, r31
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FFF64: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 829FFF68: 41980660  blt cr6, 0x82a005c8
	if ctx.cr[6].lt {
	pc = 0x82A005C8; continue 'dispatch;
	}
	// 829FFF6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FFF70: 484597F1  bl 0x82e59760
	ctx.lr = 0x829FFF74;
	sub_82E59760(ctx, base);
	// 829FFF74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829FFF78: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 829FFF7C: 4BFEDFED  bl 0x829edf68
	ctx.lr = 0x829FFF80;
	sub_829EDF68(ctx, base);
	// 829FFF80: 897F0068  lbz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 829FFF84: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829FFF88: 396B000E  addi r11, r11, 0xe
	ctx.r[11].s64 = ctx.r[11].s64 + 14;
	// 829FFF8C: 1D6B0003  mulli r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 * 3;
	// 829FFF90: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 829FFF94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FFF98: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829FFF9C: 7C0BFC2E  lfsx f0, r11, r31
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FFFA0: EC3F0028  fsubs f1, f31, f0
	ctx.f[1].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 829FFFA4: 48421F85  bl 0x82e21f28
	ctx.lr = 0x829FFFA8;
	sub_82E21F28(ctx, base);
	// 829FFFA8: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 829FFFAC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FFFB0: 995F0068  stb r10, 0x68(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[10].u8 ) };
	// 829FFFB4: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 829FFFB8: 3BAB6DB8  addi r29, r11, 0x6db8
	ctx.r[29].s64 = ctx.r[11].s64 + 28088;
	// 829FFFBC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829FFFC0: 483F3A49  bl 0x82df3a08
	ctx.lr = 0x829FFFC4;
	sub_82DF3A08(ctx, base);
	// 829FFFC4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 829FFFC8: 38A10074  addi r5, r1, 0x74
	ctx.r[5].s64 = ctx.r[1].s64 + 116;
	// 829FFFCC: 809E0160  lwz r4, 0x160(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(352 as u32) ) } as u64;
	// 829FFFD0: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 829FFFD4: C04B6150  lfs f2, 0x6150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 829FFFD8: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 829FFFDC: 481B339D  bl 0x82bb3378
	ctx.lr = 0x829FFFE0;
	sub_82BB3378(ctx, base);
	// 829FFFE0: 806100DC  lwz r3, 0xdc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) } as u64;
	// 829FFFE4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FFFE8: 419A0008  beq cr6, 0x829ffff0
	if ctx.cr[6].eq {
	pc = 0x829FFFF0; continue 'dispatch;
	}
	// 829FFFEC: 4B8C08A5  bl 0x822c0890
	ctx.lr = 0x829FFFF0;
	sub_822C0890(ctx, base);
	// 829FFFF0: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 829FFFF4: 483F3435  bl 0x82df3428
	ctx.lr = 0x829FFFF8;
	sub_82DF3428(ctx, base);
	// 829FFFF8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829FFFFC: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 82A00000: 483F3A09  bl 0x82df3a08
	ctx.lr = 0x82A00004;
	sub_82DF3A08(ctx, base);
	// 82A00004: 38A1006C  addi r5, r1, 0x6c
	ctx.r[5].s64 = ctx.r[1].s64 + 108;
	// 82A00008: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82A0000C: 809E0160  lwz r4, 0x160(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(352 as u32) ) } as u64;
	// 82A00010: 481B2BB9  bl 0x82bb2bc8
	ctx.lr = 0x82A00014;
	sub_82BB2BC8(ctx, base);
	// 82A00014: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A00018: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A0001C: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A00020: 4BFEDF49  bl 0x829edf68
	ctx.lr = 0x82A00024;
	sub_829EDF68(ctx, base);
	// 82A00024: 897F0068  lbz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A00028: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82A0002C: 396B0009  addi r11, r11, 9
	ctx.r[11].s64 = ctx.r[11].s64 + 9;
	// 82A00030: 1D6B0003  mulli r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 * 3;
	// 82A00034: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 82A00038: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A0003C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A00040: 7C2BFC2E  lfsx f1, r11, r31
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A00044: 481B8A2D  bl 0x82bb8a70
	ctx.lr = 0x82A00048;
	sub_82BB8A70(ctx, base);
	// 82A00048: 806100AC  lwz r3, 0xac(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82A0004C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A00050: 419A0008  beq cr6, 0x82a00058
	if ctx.cr[6].eq {
	pc = 0x82A00058; continue 'dispatch;
	}
	// 82A00054: 4B8C083D  bl 0x822c0890
	ctx.lr = 0x82A00058;
	sub_822C0890(ctx, base);
	// 82A00058: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 82A0005C: 48000420  b 0x82a0047c
	pc = 0x82A0047C; continue 'dispatch;
	// 82A00060: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A00064: 4BFFE06D  bl 0x829fe0d0
	ctx.lr = 0x82A00068;
	sub_829FE0D0(ctx, base);
	// 82A00068: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0006C: 48754595  bl 0x83154600
	ctx.lr = 0x82A00070;
	sub_83154600(ctx, base);
	// 82A00070: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A00074: 4BFFEA05  bl 0x829fea78
	ctx.lr = 0x82A00078;
	sub_829FEA78(ctx, base);
	// 82A00078: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0007C: 484596E5  bl 0x82e59760
	ctx.lr = 0x82A00080;
	sub_82E59760(ctx, base);
	// 82A00080: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A00084: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82A00088: 4BFEDEE1  bl 0x829edf68
	ctx.lr = 0x82A0008C;
	sub_829EDF68(ctx, base);
	// 82A0008C: 897F0068  lbz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A00090: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82A00094: 396B000E  addi r11, r11, 0xe
	ctx.r[11].s64 = ctx.r[11].s64 + 14;
	// 82A00098: 1D6B0003  mulli r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 * 3;
	// 82A0009C: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 82A000A0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A000A4: 7C0BFC2E  lfsx f0, r11, r31
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A000A8: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82A000AC: 419800D8  blt cr6, 0x82a00184
	if ctx.cr[6].lt {
	pc = 0x82A00184; continue 'dispatch;
	}
	// 82A000B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A000B4: 484596AD  bl 0x82e59760
	ctx.lr = 0x82A000B8;
	sub_82E59760(ctx, base);
	// 82A000B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A000BC: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82A000C0: 4BFEDEA9  bl 0x829edf68
	ctx.lr = 0x82A000C4;
	sub_829EDF68(ctx, base);
	// 82A000C4: 897F0068  lbz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A000C8: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82A000CC: 396B000E  addi r11, r11, 0xe
	ctx.r[11].s64 = ctx.r[11].s64 + 14;
	// 82A000D0: 1D6B0003  mulli r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 * 3;
	// 82A000D4: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 82A000D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A000DC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A000E0: 7C0BFC2E  lfsx f0, r11, r31
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A000E4: EC3F0028  fsubs f1, f31, f0
	ctx.f[1].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 82A000E8: 48421E41  bl 0x82e21f28
	ctx.lr = 0x82A000EC;
	sub_82E21F28(ctx, base);
	// 82A000EC: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82A000F0: 997F0068  stb r11, 0x68(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u8 ) };
	// 82A000F4: 807E044C  lwz r3, 0x44c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1100 as u32) ) } as u64;
	// 82A000F8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A000FC: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A00100: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A00104: 4E800421  bctrl
	ctx.lr = 0x82A00108;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A00108: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A0010C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A00110: 388B6DCC  addi r4, r11, 0x6dcc
	ctx.r[4].s64 = ctx.r[11].s64 + 28108;
	// 82A00114: 483F38F5  bl 0x82df3a08
	ctx.lr = 0x82A00118;
	sub_82DF3A08(ctx, base);
	// 82A00118: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82A0011C: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 82A00120: 809E0160  lwz r4, 0x160(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(352 as u32) ) } as u64;
	// 82A00124: 481B2AA5  bl 0x82bb2bc8
	ctx.lr = 0x82A00128;
	sub_82BB2BC8(ctx, base);
	// 82A00128: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A0012C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A00130: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A00134: 4BFEDE35  bl 0x829edf68
	ctx.lr = 0x82A00138;
	sub_829EDF68(ctx, base);
	// 82A00138: 897F0068  lbz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A0013C: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82A00140: 396B0009  addi r11, r11, 9
	ctx.r[11].s64 = ctx.r[11].s64 + 9;
	// 82A00144: 1D6B0003  mulli r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 * 3;
	// 82A00148: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 82A0014C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A00150: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A00154: 7C2BFC2E  lfsx f1, r11, r31
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A00158: 481B8919  bl 0x82bb8a70
	ctx.lr = 0x82A0015C;
	sub_82BB8A70(ctx, base);
	// 82A0015C: 806100CC  lwz r3, 0xcc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 82A00160: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A00164: 419A0008  beq cr6, 0x82a0016c
	if ctx.cr[6].eq {
	pc = 0x82A0016C; continue 'dispatch;
	}
	// 82A00168: 4B8C0729  bl 0x822c0890
	ctx.lr = 0x82A0016C;
	sub_822C0890(ctx, base);
	// 82A0016C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A00170: 483F32B9  bl 0x82df3428
	ctx.lr = 0x82A00174;
	sub_82DF3428(ctx, base);
	// 82A00174: 815F0060  lwz r10, 0x60(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82A00178: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A0017C: 996A0040  stb r11, 0x40(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(64 as u32), ctx.r[11].u8 ) };
	// 82A00180: 48000448  b 0x82a005c8
	pc = 0x82A005C8; continue 'dispatch;
	// 82A00184: 817F0060  lwz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82A00188: 896B0040  lbz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82A0018C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A00190: 41820438  beq 0x82a005c8
	if ctx.cr[0].eq {
	pc = 0x82A005C8; continue 'dispatch;
	}
	// 82A00194: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A00198: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0019C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A001A0: 48421D89  bl 0x82e21f28
	ctx.lr = 0x82A001A4;
	sub_82E21F28(ctx, base);
	// 82A001A4: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82A001A8: 997F0068  stb r11, 0x68(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u8 ) };
	// 82A001AC: 807E044C  lwz r3, 0x44c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1100 as u32) ) } as u64;
	// 82A001B0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A001B4: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A001B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A001BC: 4E800421  bctrl
	ctx.lr = 0x82A001C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A001C0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A001C4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A001C8: 388B6DCC  addi r4, r11, 0x6dcc
	ctx.r[4].s64 = ctx.r[11].s64 + 28108;
	// 82A001CC: 483F383D  bl 0x82df3a08
	ctx.lr = 0x82A001D0;
	sub_82DF3A08(ctx, base);
	// 82A001D0: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 82A001D4: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 82A001D8: 809E0160  lwz r4, 0x160(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(352 as u32) ) } as u64;
	// 82A001DC: 481B29ED  bl 0x82bb2bc8
	ctx.lr = 0x82A001E0;
	sub_82BB2BC8(ctx, base);
	// 82A001E0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A001E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A001E8: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A001EC: 4BFEDD7D  bl 0x829edf68
	ctx.lr = 0x82A001F0;
	sub_829EDF68(ctx, base);
	// 82A001F0: 897F0068  lbz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A001F4: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82A001F8: 396B0009  addi r11, r11, 9
	ctx.r[11].s64 = ctx.r[11].s64 + 9;
	// 82A001FC: 1D6B0003  mulli r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 * 3;
	// 82A00200: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 82A00204: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A00208: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A0020C: 7C2BFC2E  lfsx f1, r11, r31
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A00210: 481B8861  bl 0x82bb8a70
	ctx.lr = 0x82A00214;
	sub_82BB8A70(ctx, base);
	// 82A00214: 806100BC  lwz r3, 0xbc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82A00218: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0021C: 419A0008  beq cr6, 0x82a00224
	if ctx.cr[6].eq {
	pc = 0x82A00224; continue 'dispatch;
	}
	// 82A00220: 4B8C0671  bl 0x822c0890
	ctx.lr = 0x82A00224;
	sub_822C0890(ctx, base);
	// 82A00224: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A00228: 48000254  b 0x82a0047c
	pc = 0x82A0047C; continue 'dispatch;
	// 82A0022C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A00230: 48459531  bl 0x82e59760
	ctx.lr = 0x82A00234;
	sub_82E59760(ctx, base);
	// 82A00234: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A00238: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82A0023C: 4BFEDD2D  bl 0x829edf68
	ctx.lr = 0x82A00240;
	sub_829EDF68(ctx, base);
	// 82A00240: 897F0068  lbz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A00244: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82A00248: 396B000E  addi r11, r11, 0xe
	ctx.r[11].s64 = ctx.r[11].s64 + 14;
	// 82A0024C: 1D6B0003  mulli r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 * 3;
	// 82A00250: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 82A00254: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A00258: 7C0BFC2E  lfsx f0, r11, r31
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A0025C: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82A00260: 41980368  blt cr6, 0x82a005c8
	if ctx.cr[6].lt {
	pc = 0x82A005C8; continue 'dispatch;
	}
	// 82A00264: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A00268: 484594F9  bl 0x82e59760
	ctx.lr = 0x82A0026C;
	sub_82E59760(ctx, base);
	// 82A0026C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A00270: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82A00274: 4BFEDCF5  bl 0x829edf68
	ctx.lr = 0x82A00278;
	sub_829EDF68(ctx, base);
	// 82A00278: 897F0068  lbz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A0027C: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82A00280: 396B000E  addi r11, r11, 0xe
	ctx.r[11].s64 = ctx.r[11].s64 + 14;
	// 82A00284: 1D6B0003  mulli r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 * 3;
	// 82A00288: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 82A0028C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A00290: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A00294: 7C0BFC2E  lfsx f0, r11, r31
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A00298: EC3F0028  fsubs f1, f31, f0
	ctx.f[1].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 82A0029C: 48421C8D  bl 0x82e21f28
	ctx.lr = 0x82A002A0;
	sub_82E21F28(ctx, base);
	// 82A002A0: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82A002A4: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A002A8: 997F0068  stb r11, 0x68(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u8 ) };
	// 82A002AC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A002B0: 388A75C0  addi r4, r10, 0x75c0
	ctx.r[4].s64 = ctx.r[10].s64 + 30144;
	// 82A002B4: 38A004ED  li r5, 0x4ed
	ctx.r[5].s64 = 1261;
	// 82A002B8: 38600128  li r3, 0x128
	ctx.r[3].s64 = 296;
	// 82A002BC: 483F212D  bl 0x82df23e8
	ctx.lr = 0x82A002C0;
	sub_82DF23E8(ctx, base);
	// 82A002C0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A002C4: 4182004C  beq 0x82a00310
	if ctx.cr[0].eq {
	pc = 0x82A00310; continue 'dispatch;
	}
	// 82A002C8: 817F0064  lwz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A002CC: 815F0060  lwz r10, 0x60(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82A002D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A002D4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A002D8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A002DC: 419A0024  beq cr6, 0x82a00300
	if ctx.cr[6].eq {
	pc = 0x82A00300; continue 'dispatch;
	}
	// 82A002E0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A002E4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A002E8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A002EC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A002F0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A002F4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A002F8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A002FC: 4082FFE8  bne 0x82a002e4
	if !ctx.cr[0].eq {
	pc = 0x82A002E4; continue 'dispatch;
	}
	// 82A00300: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A00304: 4BFFE06D  bl 0x829fe370
	ctx.lr = 0x82A00308;
	sub_829FE370(ctx, base);
	// 82A00308: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A0030C: 48000008  b 0x82a00314
	pc = 0x82A00314; continue 'dispatch;
	// 82A00310: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82A00314: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82A00318: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A0031C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A00320: 4BFFD871  bl 0x829fdb90
	ctx.lr = 0x82A00324;
	sub_829FDB90(ctx, base);
	// 82A00324: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A00328: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A0032C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A00330: 4B8BFCD1  bl 0x822c0000
	ctx.lr = 0x82A00334;
	sub_822C0000(ctx, base);
	// 82A00334: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A00338: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A0033C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82A00340: 93810084  stw r28, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[28].u32 ) };
	// 82A00344: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82A00348: 419A0024  beq cr6, 0x82a0036c
	if ctx.cr[6].eq {
	pc = 0x82A0036C; continue 'dispatch;
	}
	// 82A0034C: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 82A00350: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A00354: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A00358: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A0035C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A00360: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A00364: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A00368: 4082FFE8  bne 0x82a00350
	if !ctx.cr[0].eq {
	pc = 0x82A00350; continue 'dispatch;
	}
	// 82A0036C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A00370: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82A00374: 4BB0F155  bl 0x8250f4c8
	ctx.lr = 0x82A00378;
	sub_8250F4C8(ctx, base);
	// 82A00378: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0037C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A00380: 3BABFFFC  addi r29, r11, -4
	ctx.r[29].s64 = ctx.r[11].s64 + -4;
	// 82A00384: 409A0008  bne cr6, 0x82a0038c
	if !ctx.cr[6].eq {
	pc = 0x82A0038C; continue 'dispatch;
	}
	// 82A00388: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82A0038C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A00390: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82A00394: 3B610080  addi r27, r1, 0x80
	ctx.r[27].s64 = ctx.r[1].s64 + 128;
	// 82A00398: 4BB0F181  bl 0x8250f518
	ctx.lr = 0x82A0039C;
	sub_8250F518(ctx, base);
	// 82A0039C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A003A0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A003A4: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82A003A8: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82A003AC: 4BB0D15D  bl 0x8250d508
	ctx.lr = 0x82A003B0;
	sub_8250D508(ctx, base);
	// 82A003B0: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82A003B4: 483F18DD  bl 0x82df1c90
	ctx.lr = 0x82A003B8;
	sub_82DF1C90(ctx, base);
	// 82A003B8: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82A003BC: 483F18D5  bl 0x82df1c90
	ctx.lr = 0x82A003C0;
	sub_82DF1C90(ctx, base);
	// 82A003C0: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82A003C4: 419A000C  beq cr6, 0x82a003d0
	if ctx.cr[6].eq {
	pc = 0x82A003D0; continue 'dispatch;
	}
	// 82A003C8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A003CC: 4B8C04C5  bl 0x822c0890
	ctx.lr = 0x82A003D0;
	sub_822C0890(ctx, base);
	// 82A003D0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A003D4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A003D8: 3BAB6DCC  addi r29, r11, 0x6dcc
	ctx.r[29].s64 = ctx.r[11].s64 + 28108;
	// 82A003DC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A003E0: 483F3629  bl 0x82df3a08
	ctx.lr = 0x82A003E4;
	sub_82DF3A08(ctx, base);
	// 82A003E4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82A003E8: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 82A003EC: 809E0160  lwz r4, 0x160(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(352 as u32) ) } as u64;
	// 82A003F0: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82A003F4: C04B6150  lfs f2, 0x6150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82A003F8: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 82A003FC: 481B2F7D  bl 0x82bb3378
	ctx.lr = 0x82A00400;
	sub_82BB3378(ctx, base);
	// 82A00400: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82A00404: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A00408: 419A0008  beq cr6, 0x82a00410
	if ctx.cr[6].eq {
	pc = 0x82A00410; continue 'dispatch;
	}
	// 82A0040C: 4B8C0485  bl 0x822c0890
	ctx.lr = 0x82A00410;
	sub_822C0890(ctx, base);
	// 82A00410: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A00414: 483F3015  bl 0x82df3428
	ctx.lr = 0x82A00418;
	sub_82DF3428(ctx, base);
	// 82A00418: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A0041C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A00420: 483F35E9  bl 0x82df3a08
	ctx.lr = 0x82A00424;
	sub_82DF3A08(ctx, base);
	// 82A00424: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82A00428: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82A0042C: 809E0160  lwz r4, 0x160(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(352 as u32) ) } as u64;
	// 82A00430: 481B2799  bl 0x82bb2bc8
	ctx.lr = 0x82A00434;
	sub_82BB2BC8(ctx, base);
	// 82A00434: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A00438: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A0043C: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A00440: 4BFEDB29  bl 0x829edf68
	ctx.lr = 0x82A00444;
	sub_829EDF68(ctx, base);
	// 82A00444: 897F0068  lbz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A00448: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82A0044C: 396B0009  addi r11, r11, 9
	ctx.r[11].s64 = ctx.r[11].s64 + 9;
	// 82A00450: 1D6B0003  mulli r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 * 3;
	// 82A00454: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 82A00458: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A0045C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A00460: 7C2BFC2E  lfsx f1, r11, r31
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A00464: 481B860D  bl 0x82bb8a70
	ctx.lr = 0x82A00468;
	sub_82BB8A70(ctx, base);
	// 82A00468: 806100C4  lwz r3, 0xc4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82A0046C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A00470: 419A0008  beq cr6, 0x82a00478
	if ctx.cr[6].eq {
	pc = 0x82A00478; continue 'dispatch;
	}
	// 82A00474: 4B8C041D  bl 0x822c0890
	ctx.lr = 0x82A00478;
	sub_822C0890(ctx, base);
	// 82A00478: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A0047C: 483F2FAD  bl 0x82df3428
	ctx.lr = 0x82A00480;
	sub_82DF3428(ctx, base);
	// 82A00480: 48000148  b 0x82a005c8
	pc = 0x82A005C8; continue 'dispatch;
	// 82A00484: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A00488: 484592D9  bl 0x82e59760
	ctx.lr = 0x82A0048C;
	sub_82E59760(ctx, base);
	// 82A0048C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A00490: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82A00494: 4BFEDAD5  bl 0x829edf68
	ctx.lr = 0x82A00498;
	sub_829EDF68(ctx, base);
	// 82A00498: 897F0068  lbz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A0049C: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82A004A0: 396B000E  addi r11, r11, 0xe
	ctx.r[11].s64 = ctx.r[11].s64 + 14;
	// 82A004A4: 1D6B0003  mulli r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 * 3;
	// 82A004A8: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 82A004AC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A004B0: 7C0BFC2E  lfsx f0, r11, r31
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A004B4: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82A004B8: 41980110  blt cr6, 0x82a005c8
	if ctx.cr[6].lt {
	pc = 0x82A005C8; continue 'dispatch;
	}
	// 82A004BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A004C0: 484592A1  bl 0x82e59760
	ctx.lr = 0x82A004C4;
	sub_82E59760(ctx, base);
	// 82A004C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A004C8: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82A004CC: 4BFEDA9D  bl 0x829edf68
	ctx.lr = 0x82A004D0;
	sub_829EDF68(ctx, base);
	// 82A004D0: 897F0068  lbz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A004D4: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82A004D8: 396B000E  addi r11, r11, 0xe
	ctx.r[11].s64 = ctx.r[11].s64 + 14;
	// 82A004DC: 1D6B0003  mulli r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 * 3;
	// 82A004E0: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 82A004E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A004E8: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A004EC: 7C0BFC2E  lfsx f0, r11, r31
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A004F0: EC3F0028  fsubs f1, f31, f0
	ctx.f[1].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 82A004F4: 48421A35  bl 0x82e21f28
	ctx.lr = 0x82A004F8;
	sub_82E21F28(ctx, base);
	// 82A004F8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A004FC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A00500: 995F0068  stb r10, 0x68(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[10].u8 ) };
	// 82A00504: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82A00508: 3BAB6DDC  addi r29, r11, 0x6ddc
	ctx.r[29].s64 = ctx.r[11].s64 + 28124;
	// 82A0050C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A00510: 483F34F9  bl 0x82df3a08
	ctx.lr = 0x82A00514;
	sub_82DF3A08(ctx, base);
	// 82A00514: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82A00518: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 82A0051C: 809E0160  lwz r4, 0x160(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(352 as u32) ) } as u64;
	// 82A00520: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82A00524: C04B6150  lfs f2, 0x6150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82A00528: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 82A0052C: 481B2E4D  bl 0x82bb3378
	ctx.lr = 0x82A00530;
	sub_82BB3378(ctx, base);
	// 82A00530: 806100D4  lwz r3, 0xd4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 82A00534: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A00538: 419A0008  beq cr6, 0x82a00540
	if ctx.cr[6].eq {
	pc = 0x82A00540; continue 'dispatch;
	}
	// 82A0053C: 4B8C0355  bl 0x822c0890
	ctx.lr = 0x82A00540;
	sub_822C0890(ctx, base);
	// 82A00540: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82A00544: 483F2EE5  bl 0x82df3428
	ctx.lr = 0x82A00548;
	sub_82DF3428(ctx, base);
	// 82A00548: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A0054C: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82A00550: 483F34B9  bl 0x82df3a08
	ctx.lr = 0x82A00554;
	sub_82DF3A08(ctx, base);
	// 82A00554: 38A10064  addi r5, r1, 0x64
	ctx.r[5].s64 = ctx.r[1].s64 + 100;
	// 82A00558: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82A0055C: 809E0160  lwz r4, 0x160(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(352 as u32) ) } as u64;
	// 82A00560: 481B2669  bl 0x82bb2bc8
	ctx.lr = 0x82A00564;
	sub_82BB2BC8(ctx, base);
	// 82A00564: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A00568: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A0056C: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A00570: 4BFED9F9  bl 0x829edf68
	ctx.lr = 0x82A00574;
	sub_829EDF68(ctx, base);
	// 82A00574: 897F0068  lbz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A00578: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82A0057C: 396B0009  addi r11, r11, 9
	ctx.r[11].s64 = ctx.r[11].s64 + 9;
	// 82A00580: 1D6B0003  mulli r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 * 3;
	// 82A00584: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 82A00588: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A0058C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A00590: 7C2BFC2E  lfsx f1, r11, r31
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A00594: 481B84DD  bl 0x82bb8a70
	ctx.lr = 0x82A00598;
	sub_82BB8A70(ctx, base);
	// 82A00598: 806100E4  lwz r3, 0xe4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(228 as u32) ) } as u64;
	// 82A0059C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A005A0: 419A0008  beq cr6, 0x82a005a8
	if ctx.cr[6].eq {
	pc = 0x82A005A8; continue 'dispatch;
	}
	// 82A005A4: 4B8C02ED  bl 0x822c0890
	ctx.lr = 0x82A005A8;
	sub_822C0890(ctx, base);
	// 82A005A8: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82A005AC: 483F2E7D  bl 0x82df3428
	ctx.lr = 0x82A005B0;
	sub_82DF3428(ctx, base);
	// 82A005B0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A005B4: 807E03A4  lwz r3, 0x3a4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(932 as u32) ) } as u64;
	// 82A005B8: 48481189  bl 0x82e81740
	ctx.lr = 0x82A005BC;
	sub_82E81740(ctx, base);
	// 82A005BC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A005C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A005C4: 4BFED7BD  bl 0x829edd80
	ctx.lr = 0x82A005C8;
	sub_829EDD80(ctx, base);
	// 82A005C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A005CC: 484591AD  bl 0x82e59778
	ctx.lr = 0x82A005D0;
	sub_82E59778(ctx, base);
	// 82A005D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A005D4: 4BFEDA75  bl 0x829ee048
	ctx.lr = 0x82A005D8;
	sub_829EE048(ctx, base);
	// 82A005D8: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 82A005DC: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82A005E0: 487A7BD4  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A005E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A005E8 size=108
    let mut pc: u32 = 0x82A005E8;
    'dispatch: loop {
        match pc {
            0x82A005E8 => {
    //   block [0x82A005E8..0x82A00654)
	// 82A005E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A005EC: 487A7B81  bl 0x831a816c
	ctx.lr = 0x82A005F0;
	sub_831A8130(ctx, base);
	// 82A005F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A005F4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82A005F8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A005FC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A00600: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A00604: 41820038  beq 0x82a0063c
	if ctx.cr[0].eq {
	pc = 0x82A0063C; continue 'dispatch;
	}
	// 82A00608: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0060C: 487A937D  bl 0x831a9988
	ctx.lr = 0x82A00610;
	sub_831A9988(ctx, base);
	// 82A00610: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 82A00614: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A00618: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 82A0061C: 487A7ADD  bl 0x831a80f8
	ctx.lr = 0x82A00620;
	sub_831A80F8(ctx, base);
	// 82A00620: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A00624: 41820018  beq 0x82a0063c
	if ctx.cr[0].eq {
	pc = 0x82A0063C; continue 'dispatch;
	}
	// 82A00628: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0062C: 387DFFD8  addi r3, r29, -0x28
	ctx.r[3].s64 = ctx.r[29].s64 + -40;
	// 82A00630: 4BFFF4D1  bl 0x829ffb00
	ctx.lr = 0x82A00634;
	sub_829FFB00(ctx, base);
	// 82A00634: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A00638: 48000014  b 0x82a0064c
	pc = 0x82A0064C; continue 'dispatch;
	// 82A0063C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A00640: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A00644: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A00648: 4BB11FD1  bl 0x82512618
	ctx.lr = 0x82A0064C;
	sub_82512618(ctx, base);
	// 82A0064C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A00650: 487A7B6C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A00658(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A00658 size=128
    let mut pc: u32 = 0x82A00658;
    'dispatch: loop {
        match pc {
            0x82A00658 => {
    //   block [0x82A00658..0x82A006D8)
	// 82A00658: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0065C: 487A7B11  bl 0x831a816c
	ctx.lr = 0x82A00660;
	sub_831A8130(ctx, base);
	// 82A00660: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A00664: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82A00668: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A0066C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A00670: 3BEBDA6C  addi r31, r11, -0x2594
	ctx.r[31].s64 = ctx.r[11].s64 + -9620;
	// 82A00674: 816ADA74  lwz r11, -0x258c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-9612 as u32) ) } as u64;
	// 82A00678: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82A0067C: 40820024  bne 0x82a006a0
	if !ctx.cr[0].eq {
	pc = 0x82A006A0; continue 'dispatch;
	}
	// 82A00680: 3D208290  lis r9, -0x7d70
	ctx.r[9].s64 = -2104492032;
	// 82A00684: 3D0082A0  lis r8, -0x7d60
	ctx.r[8].s64 = -2103443456;
	// 82A00688: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82A0068C: 3929DD90  addi r9, r9, -0x2270
	ctx.r[9].s64 = ctx.r[9].s64 + -8816;
	// 82A00690: 3908E328  addi r8, r8, -0x1cd8
	ctx.r[8].s64 = ctx.r[8].s64 + -7384;
	// 82A00694: 916ADA74  stw r11, -0x258c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-9612 as u32), ctx.r[11].u32 ) };
	// 82A00698: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A0069C: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82A006A0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82A006A4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82A006A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A006AC: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 82A006B0: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 82A006B4: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A006B8: 4BC53F09  bl 0x826545c0
	ctx.lr = 0x82A006BC;
	sub_826545C0(ctx, base);
	// 82A006BC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A006C0: 4182000C  beq 0x82a006cc
	if ctx.cr[0].eq {
	pc = 0x82A006CC; continue 'dispatch;
	}
	// 82A006C4: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A006C8: 48000008  b 0x82a006d0
	pc = 0x82A006D0; continue 'dispatch;
	// 82A006CC: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82A006D0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A006D4: 487A7AE8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A006D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A006D8 size=964
    let mut pc: u32 = 0x82A006D8;
    'dispatch: loop {
        match pc {
            0x82A006D8 => {
    //   block [0x82A006D8..0x82A00A9C)
	// 82A006D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A006DC: 487A7A85  bl 0x831a8160
	ctx.lr = 0x82A006E0;
	sub_831A8130(ctx, base);
	// 82A006E0: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A006E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A006E8: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82A006EC: 4BB112ED  bl 0x825119d8
	ctx.lr = 0x82A006F0;
	sub_825119D8(ctx, base);
	// 82A006F0: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82A006F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A006F8: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 82A006FC: 483F330D  bl 0x82df3a08
	ctx.lr = 0x82A00700;
	sub_82DF3A08(ctx, base);
	// 82A00700: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A00704: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A00708: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A0070C: 4BB08075  bl 0x82508780
	ctx.lr = 0x82A00710;
	sub_82508780(ctx, base);
	// 82A00710: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A00714: 483F2D15  bl 0x82df3428
	ctx.lr = 0x82A00718;
	sub_82DF3428(ctx, base);
	// 82A00718: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82A0071C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A00720: 389E0028  addi r4, r30, 0x28
	ctx.r[4].s64 = ctx.r[30].s64 + 40;
	// 82A00724: 409A0008  bne cr6, 0x82a0072c
	if !ctx.cr[6].eq {
	pc = 0x82A0072C; continue 'dispatch;
	}
	// 82A00728: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82A0072C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A00730: 4BB08071  bl 0x825087a0
	ctx.lr = 0x82A00734;
	sub_825087A0(ctx, base);
	// 82A00734: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A00738: 4BB12361  bl 0x82512a98
	ctx.lr = 0x82A0073C;
	sub_82512A98(ctx, base);
	// 82A0073C: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A00740: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 82A00744: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 82A00748: 38800040  li r4, 0x40
	ctx.r[4].s64 = 64;
	// 82A0074C: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82A00750: 4849FFE1  bl 0x82ea0730
	ctx.lr = 0x82A00754;
	sub_82EA0730(ctx, base);
	// 82A00754: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A00758: 39400040  li r10, 0x40
	ctx.r[10].s64 = 64;
	// 82A0075C: 392100C0  addi r9, r1, 0xc0
	ctx.r[9].s64 = ctx.r[1].s64 + 192;
	// 82A00760: B1430004  sth r10, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u16 ) };
	// 82A00764: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82A00768: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A0076C: C02BE304  lfs f1, -0x1cfc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7420 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A00770: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A00774: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 82A00778: 3908BC40  addi r8, r8, -0x43c0
	ctx.r[8].s64 = ctx.r[8].s64 + -17344;
	// 82A0077C: 38C100B0  addi r6, r1, 0xb0
	ctx.r[6].s64 = ctx.r[1].s64 + 176;
	// 82A00780: C00A08A4  lfs f0, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A00784: 38A100B0  addi r5, r1, 0xb0
	ctx.r[5].s64 = ctx.r[1].s64 + 176;
	// 82A00788: C1ABE308  lfs f13, -0x1cf8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7416 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A0078C: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 82A00790: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82A00794: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82A00798: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82A0079C: D1A10078  stfs f13, 0x78(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82A007A0: 13E040C7  vcmpequd (lvx128) v31, v0, v8
	tmp.u32 = ctx.r[8].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A007A4: 13C038C7  vcmpequd (lvx128) v30, v0, v7
	tmp.u32 = ctx.r[7].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A00AA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A00AA0 size=76
    let mut pc: u32 = 0x82A00AA0;
    'dispatch: loop {
        match pc {
            0x82A00AA0 => {
    //   block [0x82A00AA0..0x82A00AEC)
	// 82A00AA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A00AA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A00AA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A00AAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A00AB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A00AB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A00AB8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A00ABC: 4845BE6D  bl 0x82e5c928
	ctx.lr = 0x82A00AC0;
	sub_82E5C928(ctx, base);
	// 82A00AC0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A00AC4: 9BDF0060  stb r30, 0x60(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[30].u8 ) };
	// 82A00AC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A00ACC: 396B794C  addi r11, r11, 0x794c
	ctx.r[11].s64 = ctx.r[11].s64 + 31052;
	// 82A00AD0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A00AD4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A00AD8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A00ADC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A00AE0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A00AE4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A00AE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A00AF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A00AF0 size=300
    let mut pc: u32 = 0x82A00AF0;
    'dispatch: loop {
        match pc {
            0x82A00AF0 => {
    //   block [0x82A00AF0..0x82A00C1C)
	// 82A00AF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A00AF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A00AF8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A00AFC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A00B00: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A00B04: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A00B08: 48753AF9  bl 0x83154600
	ctx.lr = 0x82A00B0C;
	sub_83154600(ctx, base);
	// 82A00B0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A00B10: 4BFED459  bl 0x829edf68
	ctx.lr = 0x82A00B14;
	sub_829EDF68(ctx, base);
	// 82A00B14: 3963FFFE  addi r11, r3, -2
	ctx.r[11].s64 = ctx.r[3].s64 + -2;
	// 82A00B18: 3D408212  lis r10, -0x7dee
	ctx.r[10].s64 = -2112749568;
	// 82A00B1C: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82A00B20: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A00B24: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82A00B28: 993E0062  stb r9, 0x62(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(98 as u32), ctx.r[9].u8 ) };
	// 82A00B2C: 997E0061  stb r11, 0x61(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(97 as u32), ctx.r[11].u8 ) };
	// 82A00B30: C00ADFAC  lfs f0, -0x2054(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A00B34: D01F0398  stfs f0, 0x398(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(920 as u32), tmp.u32 ) };
	// 82A00B38: 897E0060  lbz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82A00B3C: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82A00B40: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A00B44: 4198004C  blt cr6, 0x82a00b90
	if ctx.cr[6].lt {
	pc = 0x82A00B90; continue 'dispatch;
	}
	// 82A00B48: 409A008C  bne cr6, 0x82a00bd4
	if !ctx.cr[6].eq {
	pc = 0x82A00BD4; continue 'dispatch;
	}
	// 82A00B4C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A00B50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A00B54: 388B6D84  addi r4, r11, 0x6d84
	ctx.r[4].s64 = ctx.r[11].s64 + 28036;
	// 82A00B58: 483F2EB1  bl 0x82df3a08
	ctx.lr = 0x82A00B5C;
	sub_82DF3A08(ctx, base);
	// 82A00B5C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82A00B60: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A00B64: 809F0160  lwz r4, 0x160(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 82A00B68: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A00B6C: C04B6150  lfs f2, 0x6150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82A00B70: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 82A00B74: 481B2805  bl 0x82bb3378
	ctx.lr = 0x82A00B78;
	sub_82BB3378(ctx, base);
	// 82A00B78: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A00B7C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A00B80: 419A0008  beq cr6, 0x82a00b88
	if ctx.cr[6].eq {
	pc = 0x82A00B88; continue 'dispatch;
	}
	// 82A00B84: 4B8BFD0D  bl 0x822c0890
	ctx.lr = 0x82A00B88;
	sub_822C0890(ctx, base);
	// 82A00B88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A00B8C: 48000044  b 0x82a00bd0
	pc = 0x82A00BD0; continue 'dispatch;
	// 82A00B90: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A00B94: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A00B98: 388B6D94  addi r4, r11, 0x6d94
	ctx.r[4].s64 = ctx.r[11].s64 + 28052;
	// 82A00B9C: 483F2E6D  bl 0x82df3a08
	ctx.lr = 0x82A00BA0;
	sub_82DF3A08(ctx, base);
	// 82A00BA0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82A00BA4: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82A00BA8: 809F0160  lwz r4, 0x160(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 82A00BAC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A00BB0: C04B6150  lfs f2, 0x6150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82A00BB4: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 82A00BB8: 481B27C1  bl 0x82bb3378
	ctx.lr = 0x82A00BBC;
	sub_82BB3378(ctx, base);
	// 82A00BBC: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A00BC0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A00BC4: 419A0008  beq cr6, 0x82a00bcc
	if ctx.cr[6].eq {
	pc = 0x82A00BCC; continue 'dispatch;
	}
	// 82A00BC8: 4B8BFCC9  bl 0x822c0890
	ctx.lr = 0x82A00BCC;
	sub_822C0890(ctx, base);
	// 82A00BCC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A00BD0: 483F2859  bl 0x82df3428
	ctx.lr = 0x82A00BD4;
	sub_82DF3428(ctx, base);
	// 82A00BD4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A00BD8: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A00BDC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A00BE0: 38AA7970  addi r5, r10, 0x7970
	ctx.r[5].s64 = ctx.r[10].s64 + 31088;
	// 82A00BE4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A00BE8: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82A00BEC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A00BF0: 4E800421  bctrl
	ctx.lr = 0x82A00BF4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A00BF4: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A00BF8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A00BFC: 419A0008  beq cr6, 0x82a00c04
	if ctx.cr[6].eq {
	pc = 0x82A00C04; continue 'dispatch;
	}
	// 82A00C00: 4B8BFC91  bl 0x822c0890
	ctx.lr = 0x82A00C04;
	sub_822C0890(ctx, base);
	// 82A00C04: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A00C08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A00C0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A00C10: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A00C14: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A00C18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A00C20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A00C20 size=2668
    let mut pc: u32 = 0x82A00C20;
    'dispatch: loop {
        match pc {
            0x82A00C20 => {
    //   block [0x82A00C20..0x82A0168C)
	// 82A00C20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A00C24: 487A7539  bl 0x831a815c
	ctx.lr = 0x82A00C28;
	sub_831A8130(ctx, base);
	// 82A00C28: 3981FFC0  addi r12, r1, -0x40
	ctx.r[12].s64 = ctx.r[1].s64 + -64;
	// 82A00C2C: 487A7E49  bl 0x831a8a74
	ctx.lr = 0x82A00C30;
	sub_831A8A40(ctx, base);
	// 82A00C30: 3980FF70  li r12, -0x90
	ctx.r[12].s64 = -144;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A01690(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A01690 size=20
    let mut pc: u32 = 0x82A01690;
    'dispatch: loop {
        match pc {
            0x82A01690 => {
    //   block [0x82A01690..0x82A016A4)
	// 82A01690: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A01694: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A01698: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A0169C: 994B0061  stb r10, 0x61(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(97 as u32), ctx.r[10].u8 ) };
	// 82A016A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A016A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A016A8 size=648
    let mut pc: u32 = 0x82A016A8;
    'dispatch: loop {
        match pc {
            0x82A016A8 => {
    //   block [0x82A016A8..0x82A01930)
	// 82A016A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A016AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A016B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A016B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A016B8: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82A016BC: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A016C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A016C4: 48752F3D  bl 0x83154600
	ctx.lr = 0x82A016C8;
	sub_83154600(ctx, base);
	// 82A016C8: 897F0060  lbz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82A016CC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A016D0: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82A016D4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A016D8: 41980190  blt cr6, 0x82a01868
	if ctx.cr[6].lt {
	pc = 0x82A01868; continue 'dispatch;
	}
	// 82A016DC: 419A00A4  beq cr6, 0x82a01780
	if ctx.cr[6].eq {
	pc = 0x82A01780; continue 'dispatch;
	}
	// 82A016E0: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82A016E4: 40980230  bge cr6, 0x82a01914
	if !ctx.cr[6].lt {
	pc = 0x82A01914; continue 'dispatch;
	}
	// 82A016E8: 897F0061  lbz r11, 0x61(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(97 as u32) ) } as u64;
	// 82A016EC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A016F0: 41820224  beq 0x82a01914
	if ctx.cr[0].eq {
	pc = 0x82A01914; continue 'dispatch;
	}
	// 82A016F4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A016F8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A016FC: 4BFEDFBD  bl 0x829ef6b8
	ctx.lr = 0x82A01700;
	sub_829EF6B8(ctx, base);
	// 82A01700: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A01704: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A01708: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0170C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A01710: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A01714: 419A0024  beq cr6, 0x82a01738
	if ctx.cr[6].eq {
	pc = 0x82A01738; continue 'dispatch;
	}
	// 82A01718: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A0171C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A01720: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A01724: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A01728: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A0172C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A01730: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A01734: 4082FFE8  bne 0x82a0171c
	if !ctx.cr[0].eq {
	pc = 0x82A0171C; continue 'dispatch;
	}
	// 82A01738: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A0173C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A01740: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A01744: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82A01748: 389E00E8  addi r4, r30, 0xe8
	ctx.r[4].s64 = ctx.r[30].s64 + 232;
	// 82A0174C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A01750: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A01754: 4845CF55  bl 0x82e5e6a8
	ctx.lr = 0x82A01758;
	sub_82E5E6A8(ctx, base);
	// 82A01758: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A0175C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A01760: 419A0008  beq cr6, 0x82a01768
	if ctx.cr[6].eq {
	pc = 0x82A01768; continue 'dispatch;
	}
	// 82A01764: 4B8BF12D  bl 0x822c0890
	ctx.lr = 0x82A01768;
	sub_822C0890(ctx, base);
	// 82A01768: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A0176C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A01770: 419A0008  beq cr6, 0x82a01778
	if ctx.cr[6].eq {
	pc = 0x82A01778; continue 'dispatch;
	}
	// 82A01774: 4B8BF11D  bl 0x822c0890
	ctx.lr = 0x82A01778;
	sub_822C0890(ctx, base);
	// 82A01778: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A0177C: 4800018C  b 0x82a01908
	pc = 0x82A01908; continue 'dispatch;
	// 82A01780: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A01784: 48457FDD  bl 0x82e59760
	ctx.lr = 0x82A01788;
	sub_82E59760(ctx, base);
	// 82A01788: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0178C: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82A01790: 48457FE9  bl 0x82e59778
	ctx.lr = 0x82A01794;
	sub_82E59778(ctx, base);
	// 82A01794: EC1F0828  fsubs f0, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[1].f64) as f32) as f64);
	// 82A01798: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A0179C: C3EBC65C  lfs f31, -0x39a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-14756 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A017A0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82A017A4: 40980044  bge cr6, 0x82a017e8
	if !ctx.cr[6].lt {
	pc = 0x82A017E8; continue 'dispatch;
	}
	// 82A017A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A017AC: 48457FB5  bl 0x82e59760
	ctx.lr = 0x82A017B0;
	sub_82E59760(ctx, base);
	// 82A017B0: FF01F800  fcmpu cr6, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 82A017B4: 41980034  blt cr6, 0x82a017e8
	if ctx.cr[6].lt {
	pc = 0x82A017E8; continue 'dispatch;
	}
	// 82A017B8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A017BC: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A017C0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A017C4: 38AA6874  addi r5, r10, 0x6874
	ctx.r[5].s64 = ctx.r[10].s64 + 26740;
	// 82A017C8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A017CC: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82A017D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A017D4: 4E800421  bctrl
	ctx.lr = 0x82A017D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A017D8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A017DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A017E0: 419A0008  beq cr6, 0x82a017e8
	if ctx.cr[6].eq {
	pc = 0x82A017E8; continue 'dispatch;
	}
	// 82A017E4: 4B8BF0AD  bl 0x822c0890
	ctx.lr = 0x82A017E8;
	sub_822C0890(ctx, base);
	// 82A017E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A017EC: 48457F75  bl 0x82e59760
	ctx.lr = 0x82A017F0;
	sub_82E59760(ctx, base);
	// 82A017F0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A017F4: C3EBA1C4  lfs f31, -0x5e3c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A017F8: FF01F800  fcmpu cr6, f1, f31
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 82A017FC: 41980118  blt cr6, 0x82a01914
	if ctx.cr[6].lt {
	pc = 0x82A01914; continue 'dispatch;
	}
	// 82A01800: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A01804: 48457F5D  bl 0x82e59760
	ctx.lr = 0x82A01808;
	sub_82E59760(ctx, base);
	// 82A01808: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0180C: EC21F828  fsubs f1, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = (((ctx.f[1].f64 - ctx.f[31].f64) as f32) as f64);
	// 82A01810: 48420719  bl 0x82e21f28
	ctx.lr = 0x82A01814;
	sub_82E21F28(ctx, base);
	// 82A01814: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 82A01818: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0181C: 388BD748  addi r4, r11, -0x28b8
	ctx.r[4].s64 = ctx.r[11].s64 + -10424;
	// 82A01820: 897F0060  lbz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82A01824: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A01828: 997F0060  stb r11, 0x60(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u8 ) };
	// 82A0182C: 483F21DD  bl 0x82df3a08
	ctx.lr = 0x82A01830;
	sub_82DF3A08(ctx, base);
	// 82A01830: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A01834: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A01838: 809E0160  lwz r4, 0x160(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(352 as u32) ) } as u64;
	// 82A0183C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A01840: C04B964C  lfs f2, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82A01844: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 82A01848: 481B1B31  bl 0x82bb3378
	ctx.lr = 0x82A0184C;
	sub_82BB3378(ctx, base);
	// 82A0184C: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82A01850: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A01854: 419A0008  beq cr6, 0x82a0185c
	if ctx.cr[6].eq {
	pc = 0x82A0185C; continue 'dispatch;
	}
	// 82A01858: 4B8BF039  bl 0x822c0890
	ctx.lr = 0x82A0185C;
	sub_822C0890(ctx, base);
	// 82A0185C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A01860: 483F1BC9  bl 0x82df3428
	ctx.lr = 0x82A01864;
	sub_82DF3428(ctx, base);
	// 82A01864: 480000B0  b 0x82a01914
	pc = 0x82A01914; continue 'dispatch;
	// 82A01868: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0186C: 48457EF5  bl 0x82e59760
	ctx.lr = 0x82A01870;
	sub_82E59760(ctx, base);
	// 82A01870: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82A01874: C3EBA100  lfs f31, -0x5f00(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24320 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A01878: FF01F800  fcmpu cr6, f1, f31
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 82A0187C: 41980098  blt cr6, 0x82a01914
	if ctx.cr[6].lt {
	pc = 0x82A01914; continue 'dispatch;
	}
	// 82A01880: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A01884: 48457EDD  bl 0x82e59760
	ctx.lr = 0x82A01888;
	sub_82E59760(ctx, base);
	// 82A01888: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0188C: EC21F828  fsubs f1, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = (((ctx.f[1].f64 - ctx.f[31].f64) as f32) as f64);
	// 82A01890: 48420699  bl 0x82e21f28
	ctx.lr = 0x82A01894;
	sub_82E21F28(ctx, base);
	// 82A01894: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A01898: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A0189C: 388B6DB0  addi r4, r11, 0x6db0
	ctx.r[4].s64 = ctx.r[11].s64 + 28080;
	// 82A018A0: 897F0060  lbz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82A018A4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A018A8: 997F0060  stb r11, 0x60(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u8 ) };
	// 82A018AC: 483F215D  bl 0x82df3a08
	ctx.lr = 0x82A018B0;
	sub_82DF3A08(ctx, base);
	// 82A018B0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A018B4: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82A018B8: 809E0160  lwz r4, 0x160(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(352 as u32) ) } as u64;
	// 82A018BC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A018C0: C04B964C  lfs f2, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82A018C4: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 82A018C8: 481B1AB1  bl 0x82bb3378
	ctx.lr = 0x82A018CC;
	sub_82BB3378(ctx, base);
	// 82A018CC: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82A018D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A018D4: 419A0008  beq cr6, 0x82a018dc
	if ctx.cr[6].eq {
	pc = 0x82A018DC; continue 'dispatch;
	}
	// 82A018D8: 4B8BEFB9  bl 0x822c0890
	ctx.lr = 0x82A018DC;
	sub_822C0890(ctx, base);
	// 82A018DC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A018E0: 483F1B49  bl 0x82df3428
	ctx.lr = 0x82A018E4;
	sub_82DF3428(ctx, base);
	// 82A018E4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A018E8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A018EC: 38AB7970  addi r5, r11, 0x7970
	ctx.r[5].s64 = ctx.r[11].s64 + 31088;
	// 82A018F0: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82A018F4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A018F8: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82A018FC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A01900: 4E800421  bctrl
	ctx.lr = 0x82A01904;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A01904: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82A01908: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0190C: 419A0008  beq cr6, 0x82a01914
	if ctx.cr[6].eq {
	pc = 0x82A01914; continue 'dispatch;
	}
	// 82A01910: 4B8BEF81  bl 0x822c0890
	ctx.lr = 0x82A01914;
	sub_822C0890(ctx, base);
	// 82A01914: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A01918: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0191C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A01920: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82A01924: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A01928: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A0192C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A01930(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A01930 size=812
    let mut pc: u32 = 0x82A01930;
    'dispatch: loop {
        match pc {
            0x82A01930 => {
    //   block [0x82A01930..0x82A01C5C)
	// 82A01930: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A01934: 487A6831  bl 0x831a8164
	ctx.lr = 0x82A01938;
	sub_831A8130(ctx, base);
	// 82A01938: DBC1FFC0  stfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 82A0193C: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82A01940: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A01944: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A01948: 48752CB9  bl 0x83154600
	ctx.lr = 0x82A0194C;
	sub_83154600(ctx, base);
	// 82A0194C: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82A01950: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82A01954: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 82A01958: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82A0195C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A01960: C00BDFAC  lfs f0, -0x2054(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A01964: C1AA0A90  lfs f13, 0xa90(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2704 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A01968: C3E9ACFC  lfs f31, -0x5304(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-21252 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A0196C: ED800372  fmuls f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82A01970: C1A8D1B8  lfs f13, -0x2e48(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-11848 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A01974: ED6007F2  fmuls f11, f0, f31
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82A01978: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82A0197C: D18100A0  stfs f12, 0xa0(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82A01980: D16100A4  stfs f11, 0xa4(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82A01984: D00100A8  stfs f0, 0xa8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82A01988: 4BFEC5E1  bl 0x829edf68
	ctx.lr = 0x82A0198C;
	sub_829EDF68(ctx, base);
	// 82A0198C: 546B103A  slwi r11, r3, 2
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A01990: 394100A0  addi r10, r1, 0xa0
	ctx.r[10].s64 = ctx.r[1].s64 + 160;
	// 82A01994: 3D208207  lis r9, -0x7df9
	ctx.r[9].s64 = -2113470464;
	// 82A01998: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A0199C: 3889D748  addi r4, r9, -0x28b8
	ctx.r[4].s64 = ctx.r[9].s64 + -10424;
	// 82A019A0: 7C0B542E  lfsx f0, r11, r10
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A019A4: D01D0398  stfs f0, 0x398(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(920 as u32), tmp.u32 ) };
	// 82A019A8: 483F2061  bl 0x82df3a08
	ctx.lr = 0x82A019AC;
	sub_82DF3A08(ctx, base);
	// 82A019AC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A019B0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82A019B4: 809D0160  lwz r4, 0x160(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(352 as u32) ) } as u64;
	// 82A019B8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A019BC: C04B964C  lfs f2, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82A019C0: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 82A019C4: 481B19B5  bl 0x82bb3378
	ctx.lr = 0x82A019C8;
	sub_82BB3378(ctx, base);
	// 82A019C8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A019CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A019D0: 419A0008  beq cr6, 0x82a019d8
	if ctx.cr[6].eq {
	pc = 0x82A019D8; continue 'dispatch;
	}
	// 82A019D4: 4B8BEEBD  bl 0x822c0890
	ctx.lr = 0x82A019D8;
	sub_822C0890(ctx, base);
	// 82A019D8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A019DC: 483F1A4D  bl 0x82df3428
	ctx.lr = 0x82A019E0;
	sub_82DF3428(ctx, base);
	// 82A019E0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82A019E4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A019E8: 9B9F0060  stb r28, 0x60(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[28].u8 ) };
	// 82A019EC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A019F0: 9B9F0061  stb r28, 0x61(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(97 as u32), ctx.r[28].u8 ) };
	// 82A019F4: 9B810050  stb r28, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u8 ) };
	// 82A019F8: 4BAA8571  bl 0x824a9f68
	ctx.lr = 0x82A019FC;
	sub_824A9F68(ctx, base);
	// 82A019FC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A01A00: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A01A04: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A01A08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A01A0C: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A01A10: 419A0024  beq cr6, 0x82a01a34
	if ctx.cr[6].eq {
	pc = 0x82A01A34; continue 'dispatch;
	}
	// 82A01A14: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A01A18: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A01A1C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A01A20: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A01A24: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A01A28: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A01A2C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A01A30: 4082FFE8  bne 0x82a01a18
	if !ctx.cr[0].eq {
	pc = 0x82A01A18; continue 'dispatch;
	}
	// 82A01A34: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A01A38: 80DD024C  lwz r6, 0x24c(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(588 as u32) ) } as u64;
	// 82A01A3C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A01A40: 3BEB7A08  addi r31, r11, 0x7a08
	ctx.r[31].s64 = ctx.r[11].s64 + 31240;
	// 82A01A44: 3BDD0028  addi r30, r29, 0x28
	ctx.r[30].s64 = ctx.r[29].s64 + 40;
	// 82A01A48: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 82A01A4C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A01A50: C3CA08A4  lfs f30, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82A01A54: 38A00054  li r5, 0x54
	ctx.r[5].s64 = 84;
	// 82A01A58: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A01A5C: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82A01A60: 48456FE1  bl 0x82e58a40
	ctx.lr = 0x82A01A64;
	sub_82E58A40(ctx, base);
	// 82A01A64: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A01A68: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A01A6C: 419A0008  beq cr6, 0x82a01a74
	if ctx.cr[6].eq {
	pc = 0x82A01A74; continue 'dispatch;
	}
	// 82A01A70: 4B8BEE21  bl 0x822c0890
	ctx.lr = 0x82A01A74;
	sub_822C0890(ctx, base);
	// 82A01A74: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82A01A78: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A01A7C: 419A0008  beq cr6, 0x82a01a84
	if ctx.cr[6].eq {
	pc = 0x82A01A84; continue 'dispatch;
	}
	// 82A01A80: 4B8BEE11  bl 0x822c0890
	ctx.lr = 0x82A01A84;
	sub_822C0890(ctx, base);
	// 82A01A84: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A01A88: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82A01A8C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A01A90: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A01A94: 38AA6910  addi r5, r10, 0x6910
	ctx.r[5].s64 = ctx.r[10].s64 + 26896;
	// 82A01A98: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82A01A9C: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 82A01AA0: 4BC91539  bl 0x82692fd8
	ctx.lr = 0x82A01AA4;
	sub_82692FD8(ctx, base);
	// 82A01AA4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A01AA8: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82A01AAC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A01AB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A01AB4: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82A01AB8: 419A0024  beq cr6, 0x82a01adc
	if ctx.cr[6].eq {
	pc = 0x82A01ADC; continue 'dispatch;
	}
	// 82A01ABC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A01AC0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A01AC4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A01AC8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A01ACC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A01AD0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A01AD4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A01AD8: 4082FFE8  bne 0x82a01ac0
	if !ctx.cr[0].eq {
	pc = 0x82A01AC0; continue 'dispatch;
	}
	// 82A01ADC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A01AE0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A01AE4: 4BB0D9E5  bl 0x8250f4c8
	ctx.lr = 0x82A01AE8;
	sub_8250F4C8(ctx, base);
	// 82A01AE8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A01AEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A01AF0: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A01AF4: 409A0008  bne cr6, 0x82a01afc
	if !ctx.cr[6].eq {
	pc = 0x82A01AFC; continue 'dispatch;
	}
	// 82A01AF8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A01AFC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A01B00: 3B610068  addi r27, r1, 0x68
	ctx.r[27].s64 = ctx.r[1].s64 + 104;
	// 82A01B04: 4BB06F15  bl 0x82508a18
	ctx.lr = 0x82A01B08;
	sub_82508A18(ctx, base);
	// 82A01B08: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A01B0C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A01B10: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82A01B14: 38A00057  li r5, 0x57
	ctx.r[5].s64 = 87;
	// 82A01B18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A01B1C: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82A01B20: 48456F21  bl 0x82e58a40
	ctx.lr = 0x82A01B24;
	sub_82E58A40(ctx, base);
	// 82A01B24: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A01B28: 483F0169  bl 0x82df1c90
	ctx.lr = 0x82A01B2C;
	sub_82DF1C90(ctx, base);
	// 82A01B2C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A01B30: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A01B34: 419A0008  beq cr6, 0x82a01b3c
	if ctx.cr[6].eq {
	pc = 0x82A01B3C; continue 'dispatch;
	}
	// 82A01B38: 4B8BED59  bl 0x822c0890
	ctx.lr = 0x82A01B3C;
	sub_822C0890(ctx, base);
	// 82A01B3C: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82A01B40: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A01B44: 419A0008  beq cr6, 0x82a01b4c
	if ctx.cr[6].eq {
	pc = 0x82A01B4C; continue 'dispatch;
	}
	// 82A01B48: 4B8BED49  bl 0x822c0890
	ctx.lr = 0x82A01B4C;
	sub_822C0890(ctx, base);
	// 82A01B4C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A01B50: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A01B54: 38A0005C  li r5, 0x5c
	ctx.r[5].s64 = 92;
	// 82A01B58: 386000F8  li r3, 0xf8
	ctx.r[3].s64 = 248;
	// 82A01B5C: 483F088D  bl 0x82df23e8
	ctx.lr = 0x82A01B60;
	sub_82DF23E8(ctx, base);
	// 82A01B60: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A01B64: 41820028  beq 0x82a01b8c
	if ctx.cr[0].eq {
	pc = 0x82A01B8C; continue 'dispatch;
	}
	// 82A01B68: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A01B6C: 4860744D  bl 0x83008fb8
	ctx.lr = 0x82A01B70;
	sub_83008FB8(ctx, base);
	// 82A01B70: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A01B74: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 82A01B78: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A01B7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A01B80: 4BF84E11  bl 0x82986990
	ctx.lr = 0x82A01B84;
	sub_82986990(ctx, base);
	// 82A01B84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A01B88: 48000008  b 0x82a01b90
	pc = 0x82A01B90; continue 'dispatch;
	// 82A01B8C: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 82A01B90: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82A01B94: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A01B98: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82A01B9C: 4BF85D6D  bl 0x82987908
	ctx.lr = 0x82A01BA0;
	sub_82987908(ctx, base);
	// 82A01BA0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A01BA4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A01BA8: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82A01BAC: 4B8BE455  bl 0x822c0000
	ctx.lr = 0x82A01BB0;
	sub_822C0000(ctx, base);
	// 82A01BB0: 83C1005C  lwz r30, 0x5c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A01BB4: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A01BB8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A01BBC: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 82A01BC0: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A01BC4: 419A0024  beq cr6, 0x82a01be8
	if ctx.cr[6].eq {
	pc = 0x82A01BE8; continue 'dispatch;
	}
	// 82A01BC8: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 82A01BCC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A01BD0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A01BD4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A01BD8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A01BDC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A01BE0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A01BE4: 4082FFE8  bne 0x82a01bcc
	if !ctx.cr[0].eq {
	pc = 0x82A01BCC; continue 'dispatch;
	}
	// 82A01BE8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A01BEC: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82A01BF0: 4BB0D8D9  bl 0x8250f4c8
	ctx.lr = 0x82A01BF4;
	sub_8250F4C8(ctx, base);
	// 82A01BF4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A01BF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A01BFC: 3BEBFFFC  addi r31, r11, -4
	ctx.r[31].s64 = ctx.r[11].s64 + -4;
	// 82A01C00: 409A0008  bne cr6, 0x82a01c08
	if !ctx.cr[6].eq {
	pc = 0x82A01C08; continue 'dispatch;
	}
	// 82A01C04: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 82A01C08: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A01C0C: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82A01C10: 3B810058  addi r28, r1, 0x58
	ctx.r[28].s64 = ctx.r[1].s64 + 88;
	// 82A01C14: 4BB0D905  bl 0x8250f518
	ctx.lr = 0x82A01C18;
	sub_8250F518(ctx, base);
	// 82A01C18: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A01C1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A01C20: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82A01C24: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82A01C28: 4BB0B8E1  bl 0x8250d508
	ctx.lr = 0x82A01C2C;
	sub_8250D508(ctx, base);
	// 82A01C2C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82A01C30: 483F0061  bl 0x82df1c90
	ctx.lr = 0x82A01C34;
	sub_82DF1C90(ctx, base);
	// 82A01C34: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82A01C38: 483F0059  bl 0x82df1c90
	ctx.lr = 0x82A01C3C;
	sub_82DF1C90(ctx, base);
	// 82A01C3C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A01C40: 419A000C  beq cr6, 0x82a01c4c
	if ctx.cr[6].eq {
	pc = 0x82A01C4C; continue 'dispatch;
	}
	// 82A01C44: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A01C48: 4B8BEC49  bl 0x822c0890
	ctx.lr = 0x82A01C4C;
	sub_822C0890(ctx, base);
	// 82A01C4C: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82A01C50: CBC1FFC0  lfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82A01C54: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82A01C58: 487A655C  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A01C60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A01C60 size=392
    let mut pc: u32 = 0x82A01C60;
    'dispatch: loop {
        match pc {
            0x82A01C60 => {
    //   block [0x82A01C60..0x82A01DE8)
	// 82A01C60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A01C64: 487A6505  bl 0x831a8168
	ctx.lr = 0x82A01C68;
	sub_831A8130(ctx, base);
	// 82A01C68: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82A01C6C: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A01C70: 48752991  bl 0x83154600
	ctx.lr = 0x82A01C74;
	sub_83154600(ctx, base);
	// 82A01C74: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82A01C78: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82A01C7C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A01C80: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A01C84: 38AA6910  addi r5, r10, 0x6910
	ctx.r[5].s64 = ctx.r[10].s64 + 26896;
	// 82A01C88: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82A01C8C: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 82A01C90: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A01C94: 4BC91345  bl 0x82692fd8
	ctx.lr = 0x82A01C98;
	sub_82692FD8(ctx, base);
	// 82A01C98: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A01C9C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A01CA0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A01CA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A01CA8: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A01CAC: 419A0024  beq cr6, 0x82a01cd0
	if ctx.cr[6].eq {
	pc = 0x82A01CD0; continue 'dispatch;
	}
	// 82A01CB0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A01CB4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A01CB8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A01CBC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A01CC0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A01CC4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A01CC8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A01CCC: 4082FFE8  bne 0x82a01cb4
	if !ctx.cr[0].eq {
	pc = 0x82A01CB4; continue 'dispatch;
	}
	// 82A01CD0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A01CD4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A01CD8: 4BB0D7F1  bl 0x8250f4c8
	ctx.lr = 0x82A01CDC;
	sub_8250F4C8(ctx, base);
	// 82A01CDC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A01CE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A01CE4: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A01CE8: 409A0008  bne cr6, 0x82a01cf0
	if !ctx.cr[6].eq {
	pc = 0x82A01CF0; continue 'dispatch;
	}
	// 82A01CEC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A01CF0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A01CF4: 3BFD0028  addi r31, r29, 0x28
	ctx.r[31].s64 = ctx.r[29].s64 + 40;
	// 82A01CF8: 3B810058  addi r28, r1, 0x58
	ctx.r[28].s64 = ctx.r[1].s64 + 88;
	// 82A01CFC: 4BB06D1D  bl 0x82508a18
	ctx.lr = 0x82A01D00;
	sub_82508A18(ctx, base);
	// 82A01D00: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A01D04: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A01D08: 3BCB7A08  addi r30, r11, 0x7a08
	ctx.r[30].s64 = ctx.r[11].s64 + 31240;
	// 82A01D0C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A01D10: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A01D14: 38A0006A  li r5, 0x6a
	ctx.r[5].s64 = 106;
	// 82A01D18: C3EA08A4  lfs f31, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A01D1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A01D20: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82A01D24: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A01D28: 48456D19  bl 0x82e58a40
	ctx.lr = 0x82A01D2C;
	sub_82E58A40(ctx, base);
	// 82A01D2C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A01D30: 483EFF61  bl 0x82df1c90
	ctx.lr = 0x82A01D34;
	sub_82DF1C90(ctx, base);
	// 82A01D34: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A01D38: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A01D3C: 419A0008  beq cr6, 0x82a01d44
	if ctx.cr[6].eq {
	pc = 0x82A01D44; continue 'dispatch;
	}
	// 82A01D40: 4B8BEB51  bl 0x822c0890
	ctx.lr = 0x82A01D44;
	sub_822C0890(ctx, base);
	// 82A01D44: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A01D48: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A01D4C: 419A0008  beq cr6, 0x82a01d54
	if ctx.cr[6].eq {
	pc = 0x82A01D54; continue 'dispatch;
	}
	// 82A01D50: 4B8BEB41  bl 0x822c0890
	ctx.lr = 0x82A01D54;
	sub_822C0890(ctx, base);
	// 82A01D54: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A01D58: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A01D5C: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 82A01D60: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A01D64: 4BAA8205  bl 0x824a9f68
	ctx.lr = 0x82A01D68;
	sub_824A9F68(ctx, base);
	// 82A01D68: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A01D6C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A01D70: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A01D74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A01D78: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A01D7C: 419A0024  beq cr6, 0x82a01da0
	if ctx.cr[6].eq {
	pc = 0x82A01DA0; continue 'dispatch;
	}
	// 82A01D80: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A01D84: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A01D88: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A01D8C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A01D90: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A01D94: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A01D98: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A01D9C: 4082FFE8  bne 0x82a01d84
	if !ctx.cr[0].eq {
	pc = 0x82A01D84; continue 'dispatch;
	}
	// 82A01DA0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A01DA4: 80DD024C  lwz r6, 0x24c(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(588 as u32) ) } as u64;
	// 82A01DA8: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 82A01DAC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A01DB0: 38A0006D  li r5, 0x6d
	ctx.r[5].s64 = 109;
	// 82A01DB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A01DB8: 48456C89  bl 0x82e58a40
	ctx.lr = 0x82A01DBC;
	sub_82E58A40(ctx, base);
	// 82A01DBC: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A01DC0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A01DC4: 419A0008  beq cr6, 0x82a01dcc
	if ctx.cr[6].eq {
	pc = 0x82A01DCC; continue 'dispatch;
	}
	// 82A01DC8: 4B8BEAC9  bl 0x822c0890
	ctx.lr = 0x82A01DCC;
	sub_822C0890(ctx, base);
	// 82A01DCC: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82A01DD0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A01DD4: 419A0008  beq cr6, 0x82a01ddc
	if ctx.cr[6].eq {
	pc = 0x82A01DDC; continue 'dispatch;
	}
	// 82A01DD8: 4B8BEAB9  bl 0x822c0890
	ctx.lr = 0x82A01DDC;
	sub_822C0890(ctx, base);
	// 82A01DDC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A01DE0: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82A01DE4: 487A63D4  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A01DE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A01DE8 size=100
    let mut pc: u32 = 0x82A01DE8;
    'dispatch: loop {
        match pc {
            0x82A01DE8 => {
    //   block [0x82A01DE8..0x82A01E4C)
	// 82A01DE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A01DEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A01DF0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A01DF4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A01DF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A01DFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A01E00: 48752801  bl 0x83154600
	ctx.lr = 0x82A01E04;
	sub_83154600(ctx, base);
	// 82A01E04: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A01E08: 897E045C  lbz r11, 0x45c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(1116 as u32) ) } as u64;
	// 82A01E0C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A01E10: 40820024  bne 0x82a01e34
	if !ctx.cr[0].eq {
	pc = 0x82A01E34; continue 'dispatch;
	}
	// 82A01E14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A01E18: 4BFFF891  bl 0x82a016a8
	ctx.lr = 0x82A01E1C;
	sub_82A016A8(ctx, base);
	// 82A01E1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A01E20: 48000119  bl 0x82a01f38
	ctx.lr = 0x82A01E24;
	sub_82A01F38(ctx, base);
	// 82A01E24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A01E28: 48457951  bl 0x82e59778
	ctx.lr = 0x82A01E2C;
	sub_82E59778(ctx, base);
	// 82A01E2C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A01E30: 4BFEC219  bl 0x829ee048
	ctx.lr = 0x82A01E34;
	sub_829EE048(ctx, base);
	// 82A01E34: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A01E38: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A01E3C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A01E40: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A01E44: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A01E48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A01E50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A01E50 size=180
    let mut pc: u32 = 0x82A01E50;
    'dispatch: loop {
        match pc {
            0x82A01E50 => {
    //   block [0x82A01E50..0x82A01F04)
	// 82A01E50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A01E54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A01E58: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A01E5C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A01E60: 487527A1  bl 0x83154600
	ctx.lr = 0x82A01E64;
	sub_83154600(ctx, base);
	// 82A01E64: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A01E68: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A01E6C: 4BF88F4D  bl 0x8298adb8
	ctx.lr = 0x82A01E70;
	sub_8298ADB8(ctx, base);
	// 82A01E70: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A01E74: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A01E78: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A01E7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A01E80: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A01E84: 419A0024  beq cr6, 0x82a01ea8
	if ctx.cr[6].eq {
	pc = 0x82A01EA8; continue 'dispatch;
	}
	// 82A01E88: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A01E8C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A01E90: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A01E94: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A01E98: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A01E9C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A01EA0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A01EA4: 4082FFE8  bne 0x82a01e8c
	if !ctx.cr[0].eq {
	pc = 0x82A01E8C; continue 'dispatch;
	}
	// 82A01EA8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A01EAC: 80DF024C  lwz r6, 0x24c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(588 as u32) ) } as u64;
	// 82A01EB0: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A01EB4: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82A01EB8: 388A7A08  addi r4, r10, 0x7a08
	ctx.r[4].s64 = ctx.r[10].s64 + 31240;
	// 82A01EBC: 38A000BF  li r5, 0xbf
	ctx.r[5].s64 = 191;
	// 82A01EC0: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82A01EC4: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A01EC8: 48456B79  bl 0x82e58a40
	ctx.lr = 0x82A01ECC;
	sub_82E58A40(ctx, base);
	// 82A01ECC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A01ED0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A01ED4: 419A0008  beq cr6, 0x82a01edc
	if ctx.cr[6].eq {
	pc = 0x82A01EDC; continue 'dispatch;
	}
	// 82A01ED8: 4B8BE9B9  bl 0x822c0890
	ctx.lr = 0x82A01EDC;
	sub_822C0890(ctx, base);
	// 82A01EDC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A01EE0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A01EE4: 419A0008  beq cr6, 0x82a01eec
	if ctx.cr[6].eq {
	pc = 0x82A01EEC; continue 'dispatch;
	}
	// 82A01EE8: 4B8BE9A9  bl 0x822c0890
	ctx.lr = 0x82A01EEC;
	sub_822C0890(ctx, base);
	// 82A01EEC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A01EF0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A01EF4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A01EF8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A01EFC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A01F00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A01F08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A01F08 size=44
    let mut pc: u32 = 0x82A01F08;
    'dispatch: loop {
        match pc {
            0x82A01F08 => {
    //   block [0x82A01F08..0x82A01F34)
	// 82A01F08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A01F0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A01F10: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A01F14: 487526ED  bl 0x83154600
	ctx.lr = 0x82A01F18;
	sub_83154600(ctx, base);
	// 82A01F18: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A01F1C: 8063044C  lwz r3, 0x44c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1100 as u32) ) } as u64;
	// 82A01F20: 4847F821  bl 0x82e81740
	ctx.lr = 0x82A01F24;
	sub_82E81740(ctx, base);
	// 82A01F24: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A01F28: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A01F2C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A01F30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A01F38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A01F38 size=120
    let mut pc: u32 = 0x82A01F38;
    'dispatch: loop {
        match pc {
            0x82A01F38 => {
    //   block [0x82A01F38..0x82A01FB0)
	// 82A01F38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A01F3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A01F40: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A01F44: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A01F48: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A01F4C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A01F50: 487526B1  bl 0x83154600
	ctx.lr = 0x82A01F54;
	sub_83154600(ctx, base);
	// 82A01F54: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A01F58: 4BB0FB91  bl 0x82511ae8
	ctx.lr = 0x82A01F5C;
	sub_82511AE8(ctx, base);
	// 82A01F5C: 39600320  li r11, 0x320
	ctx.r[11].s64 = 800;
	// 82A01F60: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A01F64: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82A01F68: 13DE58C7  vcmpequd (lvx128) v30, v30, v11
	tmp.u32 = ctx.r[30].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A01FB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A01FB0 size=208
    let mut pc: u32 = 0x82A01FB0;
    'dispatch: loop {
        match pc {
            0x82A01FB0 => {
    //   block [0x82A01FB0..0x82A02080)
	// 82A01FB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A01FB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A01FB8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A01FBC: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A01FC0: 48752641  bl 0x83154600
	ctx.lr = 0x82A01FC4;
	sub_83154600(ctx, base);
	// 82A01FC4: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82A01FC8: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82A01FCC: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 82A01FD0: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82A01FD4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A01FD8: C00BDFAC  lfs f0, -0x2054(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A01FDC: C1AA0A90  lfs f13, 0xa90(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2704 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A01FE0: C189ACFC  lfs f12, -0x5304(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-21252 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A01FE4: ED600372  fmuls f11, f0, f13
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82A01FE8: C1A8D1B8  lfs f13, -0x2e48(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-11848 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A01FEC: ED800332  fmuls f12, f0, f12
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82A01FF0: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82A01FF4: D1610060  stfs f11, 0x60(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A01FF8: D1810064  stfs f12, 0x64(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82A01FFC: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82A02000: 4BFEBF69  bl 0x829edf68
	ctx.lr = 0x82A02004;
	sub_829EDF68(ctx, base);
	// 82A02004: 546B103A  slwi r11, r3, 2
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A02008: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 82A0200C: 3D208207  lis r9, -0x7df9
	ctx.r[9].s64 = -2113470464;
	// 82A02010: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A02014: 3889D748  addi r4, r9, -0x28b8
	ctx.r[4].s64 = ctx.r[9].s64 + -10424;
	// 82A02018: 7C0B542E  lfsx f0, r11, r10
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A0201C: D01F0398  stfs f0, 0x398(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(920 as u32), tmp.u32 ) };
	// 82A02020: 483F19E9  bl 0x82df3a08
	ctx.lr = 0x82A02024;
	sub_82DF3A08(ctx, base);
	// 82A02024: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A02028: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A0202C: 809F0160  lwz r4, 0x160(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 82A02030: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A02034: C04B9450  lfs f2, -0x6bb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82A02038: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 82A0203C: 481B133D  bl 0x82bb3378
	ctx.lr = 0x82A02040;
	sub_82BB3378(ctx, base);
	// 82A02040: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A02044: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A02048: 419A0008  beq cr6, 0x82a02050
	if ctx.cr[6].eq {
	pc = 0x82A02050; continue 'dispatch;
	}
	// 82A0204C: 4B8BE845  bl 0x822c0890
	ctx.lr = 0x82A02050;
	sub_822C0890(ctx, base);
	// 82A02050: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A02054: 483F13D5  bl 0x82df3428
	ctx.lr = 0x82A02058;
	sub_82DF3428(ctx, base);
	// 82A02058: 807F044C  lwz r3, 0x44c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1100 as u32) ) } as u64;
	// 82A0205C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A02060: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A02064: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A02068: 4E800421  bctrl
	ctx.lr = 0x82A0206C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A0206C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A02070: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A02074: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A02078: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A0207C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A02080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A02080 size=312
    let mut pc: u32 = 0x82A02080;
    'dispatch: loop {
        match pc {
            0x82A02080 => {
    //   block [0x82A02080..0x82A021B8)
	// 82A02080: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A02084: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A02088: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A0208C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A02090: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82A02094: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A02098: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A0209C: 48752565  bl 0x83154600
	ctx.lr = 0x82A020A0;
	sub_83154600(ctx, base);
	// 82A020A0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A020A4: 897E045C  lbz r11, 0x45c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(1116 as u32) ) } as u64;
	// 82A020A8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A020AC: 408200F0  bne 0x82a0219c
	if !ctx.cr[0].eq {
	pc = 0x82A0219C; continue 'dispatch;
	}
	// 82A020B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A020B4: 4BFFFE85  bl 0x82a01f38
	ctx.lr = 0x82A020B8;
	sub_82A01F38(ctx, base);
	// 82A020B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A020BC: 484576BD  bl 0x82e59778
	ctx.lr = 0x82A020C0;
	sub_82E59778(ctx, base);
	// 82A020C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A020C4: 4BFEBF85  bl 0x829ee048
	ctx.lr = 0x82A020C8;
	sub_829EE048(ctx, base);
	// 82A020C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A020CC: 48457695  bl 0x82e59760
	ctx.lr = 0x82A020D0;
	sub_82E59760(ctx, base);
	// 82A020D0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A020D4: C3EB7A4C  lfs f31, 0x7a4c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31308 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A020D8: FF01F800  fcmpu cr6, f1, f31
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 82A020DC: 409900C0  ble cr6, 0x82a0219c
	if !ctx.cr[6].gt {
	pc = 0x82A0219C; continue 'dispatch;
	}
	// 82A020E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A020E4: 4BFED045  bl 0x829ef128
	ctx.lr = 0x82A020E8;
	sub_829EF128(ctx, base);
	// 82A020E8: 2F030004  cmpwi cr6, r3, 4
	ctx.cr[6].compare_i32(ctx.r[3].s32, 4, &mut ctx.xer);
	// 82A020EC: 419A009C  beq cr6, 0x82a02188
	if ctx.cr[6].eq {
	pc = 0x82A02188; continue 'dispatch;
	}
	// 82A020F0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A020F4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A020F8: 4BFED5C1  bl 0x829ef6b8
	ctx.lr = 0x82A020FC;
	sub_829EF6B8(ctx, base);
	// 82A020FC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A02100: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A02104: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A02108: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0210C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A02110: 419A0024  beq cr6, 0x82a02134
	if ctx.cr[6].eq {
	pc = 0x82A02134; continue 'dispatch;
	}
	// 82A02114: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A02118: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A0211C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A02120: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A02124: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A02128: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A0212C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A02130: 4082FFE8  bne 0x82a02118
	if !ctx.cr[0].eq {
	pc = 0x82A02118; continue 'dispatch;
	}
	// 82A02134: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A02138: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A0213C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A02140: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A02144: 389E00E8  addi r4, r30, 0xe8
	ctx.r[4].s64 = ctx.r[30].s64 + 232;
	// 82A02148: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A0214C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A02150: 4845C559  bl 0x82e5e6a8
	ctx.lr = 0x82A02154;
	sub_82E5E6A8(ctx, base);
	// 82A02154: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A02158: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0215C: 419A0008  beq cr6, 0x82a02164
	if ctx.cr[6].eq {
	pc = 0x82A02164; continue 'dispatch;
	}
	// 82A02160: 4B8BE731  bl 0x822c0890
	ctx.lr = 0x82A02164;
	sub_822C0890(ctx, base);
	// 82A02164: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A02168: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0216C: 419A0008  beq cr6, 0x82a02174
	if ctx.cr[6].eq {
	pc = 0x82A02174; continue 'dispatch;
	}
	// 82A02170: 4B8BE721  bl 0x822c0890
	ctx.lr = 0x82A02174;
	sub_822C0890(ctx, base);
	// 82A02174: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A02178: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0217C: 419A0020  beq cr6, 0x82a0219c
	if ctx.cr[6].eq {
	pc = 0x82A0219C; continue 'dispatch;
	}
	// 82A02180: 4B8BE711  bl 0x822c0890
	ctx.lr = 0x82A02184;
	sub_822C0890(ctx, base);
	// 82A02184: 48000018  b 0x82a0219c
	pc = 0x82A0219C; continue 'dispatch;
	// 82A02188: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0218C: 484575D5  bl 0x82e59760
	ctx.lr = 0x82A02190;
	sub_82E59760(ctx, base);
	// 82A02190: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A02194: EC21F828  fsubs f1, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = (((ctx.f[1].f64 - ctx.f[31].f64) as f32) as f64);
	// 82A02198: 4841FD91  bl 0x82e21f28
	ctx.lr = 0x82A0219C;
	sub_82E21F28(ctx, base);
	// 82A0219C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A021A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A021A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A021A8: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82A021AC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A021B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A021B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A021B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A021B8 size=12
    let mut pc: u32 = 0x82A021B8;
    'dispatch: loop {
        match pc {
            0x82A021B8 => {
    //   block [0x82A021B8..0x82A021C4)
	// 82A021B8: 896301E0  lbz r11, 0x1e0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(480 as u32) ) } as u64;
	// 82A021BC: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 82A021C0: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A021C4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A021C4 size=28
    let mut pc: u32 = 0x82A021C4;
    'dispatch: loop {
        match pc {
            0x82A021C4 => {
    //   block [0x82A021C4..0x82A021E0)
	// 82A021C4: 89640018  lbz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A021C8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A021CC: 99630114  stb r11, 0x114(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(276 as u32), ctx.r[11].u8 ) };
	// 82A021D0: 89640019  lbz r11, 0x19(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(25 as u32) ) } as u64;
	// 82A021D4: 99630115  stb r11, 0x115(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(277 as u32), ctx.r[11].u8 ) };
	// 82A021D8: 994301E0  stb r10, 0x1e0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(480 as u32), ctx.r[10].u8 ) };
	// 82A021DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A021E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A021E0 size=88
    let mut pc: u32 = 0x82A021E0;
    'dispatch: loop {
        match pc {
            0x82A021E0 => {
    //   block [0x82A021E0..0x82A02238)
	// 82A021E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A021E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A021E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A021EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A021F0: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82A021F4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A021F8: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82A021FC: 3BC30158  addi r30, r3, 0x158
	ctx.r[30].s64 = ctx.r[3].s64 + 344;
	// 82A02200: 3BE00008  li r31, 8
	ctx.r[31].s64 = 8;
	// 82A02204: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A02208: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A0220C: 481B32E5  bl 0x82bb54f0
	ctx.lr = 0x82A02210;
	sub_82BB54F0(ctx, base);
	// 82A02210: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A02214: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82A02218: 4082FFEC  bne 0x82a02204
	if !ctx.cr[0].eq {
	pc = 0x82A02204; continue 'dispatch;
	}
	// 82A0221C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A02220: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A02224: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A02228: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82A0222C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A02230: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A02234: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A02238(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A02238 size=196
    let mut pc: u32 = 0x82A02238;
    'dispatch: loop {
        match pc {
            0x82A02238 => {
    //   block [0x82A02238..0x82A022FC)
	// 82A02238: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0223C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A02240: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A02244: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A02248: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0224C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A02250: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A02254: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A02258: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A0225C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A02260: 4B8BE6D9  bl 0x822c0938
	ctx.lr = 0x82A02264;
	sub_822C0938(ctx, base);
	// 82A02264: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A02268: 41820028  beq 0x82a02290
	if ctx.cr[0].eq {
	pc = 0x82A02290; continue 'dispatch;
	}
	// 82A0226C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A02270: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A02274: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A02278: 392B7A64  addi r9, r11, 0x7a64
	ctx.r[9].s64 = ctx.r[11].s64 + 31332;
	// 82A0227C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A02280: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A02284: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A02288: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A0228C: 48000008  b 0x82a02294
	pc = 0x82A02294; continue 'dispatch;
	// 82A02290: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A02294: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A02298: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0229C: 409A0044  bne cr6, 0x82a022e0
	if !ctx.cr[6].eq {
	pc = 0x82A022E0; continue 'dispatch;
	}
	// 82A022A0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A022A4: 419A001C  beq cr6, 0x82a022c0
	if ctx.cr[6].eq {
	pc = 0x82A022C0; continue 'dispatch;
	}
	// 82A022A8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A022AC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A022B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A022B4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A022B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A022BC: 4E800421  bctrl
	ctx.lr = 0x82A022C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A022C0: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A022C4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A022C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A022CC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A022D0: 816BE680  lwz r11, -0x1980(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6528 as u32) ) } as u64;
	// 82A022D4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A022D8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A022DC: 4B8BDD25  bl 0x822c0000
	ctx.lr = 0x82A022E0;
	sub_822C0000(ctx, base);
	// 82A022E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A022E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A022E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A022EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A022F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A022F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A022F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A02300(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A02300 size=196
    let mut pc: u32 = 0x82A02300;
    'dispatch: loop {
        match pc {
            0x82A02300 => {
    //   block [0x82A02300..0x82A023C4)
	// 82A02300: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A02304: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A02308: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A0230C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A02310: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A02314: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A02318: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A0231C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A02320: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A02324: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A02328: 4B8BE611  bl 0x822c0938
	ctx.lr = 0x82A0232C;
	sub_822C0938(ctx, base);
	// 82A0232C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A02330: 41820028  beq 0x82a02358
	if ctx.cr[0].eq {
	pc = 0x82A02358; continue 'dispatch;
	}
	// 82A02334: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A02338: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A0233C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A02340: 392B7A78  addi r9, r11, 0x7a78
	ctx.r[9].s64 = ctx.r[11].s64 + 31352;
	// 82A02344: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A02348: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A0234C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A02350: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A02354: 48000008  b 0x82a0235c
	pc = 0x82A0235C; continue 'dispatch;
	// 82A02358: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A0235C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A02360: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A02364: 409A0044  bne cr6, 0x82a023a8
	if !ctx.cr[6].eq {
	pc = 0x82A023A8; continue 'dispatch;
	}
	// 82A02368: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A0236C: 419A001C  beq cr6, 0x82a02388
	if ctx.cr[6].eq {
	pc = 0x82A02388; continue 'dispatch;
	}
	// 82A02370: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A02374: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A02378: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0237C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A02380: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A02384: 4E800421  bctrl
	ctx.lr = 0x82A02388;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A02388: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A0238C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A02390: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A02394: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A02398: 816BE680  lwz r11, -0x1980(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6528 as u32) ) } as u64;
	// 82A0239C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A023A0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A023A4: 4B8BDC5D  bl 0x822c0000
	ctx.lr = 0x82A023A8;
	sub_822C0000(ctx, base);
	// 82A023A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A023AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A023B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A023B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A023B8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A023BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A023C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A023C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A023C8 size=196
    let mut pc: u32 = 0x82A023C8;
    'dispatch: loop {
        match pc {
            0x82A023C8 => {
    //   block [0x82A023C8..0x82A0248C)
	// 82A023C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A023CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A023D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A023D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A023D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A023DC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A023E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A023E4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A023E8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A023EC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A023F0: 4B8BE549  bl 0x822c0938
	ctx.lr = 0x82A023F4;
	sub_822C0938(ctx, base);
	// 82A023F4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A023F8: 41820028  beq 0x82a02420
	if ctx.cr[0].eq {
	pc = 0x82A02420; continue 'dispatch;
	}
	// 82A023FC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A02400: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A02404: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A02408: 392B7A8C  addi r9, r11, 0x7a8c
	ctx.r[9].s64 = ctx.r[11].s64 + 31372;
	// 82A0240C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A02410: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A02414: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A02418: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A0241C: 48000008  b 0x82a02424
	pc = 0x82A02424; continue 'dispatch;
	// 82A02420: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A02424: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A02428: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0242C: 409A0044  bne cr6, 0x82a02470
	if !ctx.cr[6].eq {
	pc = 0x82A02470; continue 'dispatch;
	}
	// 82A02430: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A02434: 419A001C  beq cr6, 0x82a02450
	if ctx.cr[6].eq {
	pc = 0x82A02450; continue 'dispatch;
	}
	// 82A02438: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0243C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A02440: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A02444: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A02448: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A0244C: 4E800421  bctrl
	ctx.lr = 0x82A02450;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A02450: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A02454: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A02458: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0245C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A02460: 816BE680  lwz r11, -0x1980(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6528 as u32) ) } as u64;
	// 82A02464: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A02468: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A0246C: 4B8BDB95  bl 0x822c0000
	ctx.lr = 0x82A02470;
	sub_822C0000(ctx, base);
	// 82A02470: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A02474: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A02478: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0247C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A02480: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A02484: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A02488: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A02490(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A02490 size=216
    let mut pc: u32 = 0x82A02490;
    'dispatch: loop {
        match pc {
            0x82A02490 => {
    //   block [0x82A02490..0x82A02568)
	// 82A02490: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A02494: 487A5CD9  bl 0x831a816c
	ctx.lr = 0x82A02498;
	sub_831A8130(ctx, base);
	// 82A02498: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0249C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A024A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A024A4: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A024A8: 392B7AB4  addi r9, r11, 0x7ab4
	ctx.r[9].s64 = ctx.r[11].s64 + 31412;
	// 82A024AC: 394A7AA0  addi r10, r10, 0x7aa0
	ctx.r[10].s64 = ctx.r[10].s64 + 31392;
	// 82A024B0: 397F01D8  addi r11, r31, 0x1d8
	ctx.r[11].s64 = ctx.r[31].s64 + 472;
	// 82A024B4: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A024B8: 3BA00007  li r29, 7
	ctx.r[29].s64 = 7;
	// 82A024BC: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82A024C0: 3BCB0004  addi r30, r11, 4
	ctx.r[30].s64 = ctx.r[11].s64 + 4;
	// 82A024C4: 3BDEFFF8  addi r30, r30, -8
	ctx.r[30].s64 = ctx.r[30].s64 + -8;
	// 82A024C8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A024CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A024D0: 419A0008  beq cr6, 0x82a024d8
	if ctx.cr[6].eq {
	pc = 0x82A024D8; continue 'dispatch;
	}
	// 82A024D4: 4B8BE3BD  bl 0x822c0890
	ctx.lr = 0x82A024D8;
	sub_822C0890(ctx, base);
	// 82A024D8: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82A024DC: 4080FFE8  bge 0x82a024c4
	if !ctx.cr[0].lt {
	pc = 0x82A024C4; continue 'dispatch;
	}
	// 82A024E0: 397F0198  addi r11, r31, 0x198
	ctx.r[11].s64 = ctx.r[31].s64 + 408;
	// 82A024E4: 3BA00007  li r29, 7
	ctx.r[29].s64 = 7;
	// 82A024E8: 3BCB0004  addi r30, r11, 4
	ctx.r[30].s64 = ctx.r[11].s64 + 4;
	// 82A024EC: 3BDEFFF8  addi r30, r30, -8
	ctx.r[30].s64 = ctx.r[30].s64 + -8;
	// 82A024F0: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A024F4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A024F8: 419A0008  beq cr6, 0x82a02500
	if ctx.cr[6].eq {
	pc = 0x82A02500; continue 'dispatch;
	}
	// 82A024FC: 4B8BE395  bl 0x822c0890
	ctx.lr = 0x82A02500;
	sub_822C0890(ctx, base);
	// 82A02500: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82A02504: 4080FFE8  bge 0x82a024ec
	if !ctx.cr[0].lt {
	pc = 0x82A024EC; continue 'dispatch;
	}
	// 82A02508: 397F0158  addi r11, r31, 0x158
	ctx.r[11].s64 = ctx.r[31].s64 + 344;
	// 82A0250C: 3BA00007  li r29, 7
	ctx.r[29].s64 = 7;
	// 82A02510: 3BCB0004  addi r30, r11, 4
	ctx.r[30].s64 = ctx.r[11].s64 + 4;
	// 82A02514: 3BDEFFF8  addi r30, r30, -8
	ctx.r[30].s64 = ctx.r[30].s64 + -8;
	// 82A02518: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0251C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A02520: 419A0008  beq cr6, 0x82a02528
	if ctx.cr[6].eq {
	pc = 0x82A02528; continue 'dispatch;
	}
	// 82A02524: 4B8BE36D  bl 0x822c0890
	ctx.lr = 0x82A02528;
	sub_822C0890(ctx, base);
	// 82A02528: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82A0252C: 4080FFE8  bge 0x82a02514
	if !ctx.cr[0].lt {
	pc = 0x82A02514; continue 'dispatch;
	}
	// 82A02530: 397F0114  addi r11, r31, 0x114
	ctx.r[11].s64 = ctx.r[31].s64 + 276;
	// 82A02534: 3BA00003  li r29, 3
	ctx.r[29].s64 = 3;
	// 82A02538: 3BCB0008  addi r30, r11, 8
	ctx.r[30].s64 = ctx.r[11].s64 + 8;
	// 82A0253C: 3BDEFFF4  addi r30, r30, -0xc
	ctx.r[30].s64 = ctx.r[30].s64 + -12;
	// 82A02540: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A02544: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A02548: 419A0008  beq cr6, 0x82a02550
	if ctx.cr[6].eq {
	pc = 0x82A02550; continue 'dispatch;
	}
	// 82A0254C: 4B8BE345  bl 0x822c0890
	ctx.lr = 0x82A02550;
	sub_822C0890(ctx, base);
	// 82A02550: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82A02554: 4080FFE8  bge 0x82a0253c
	if !ctx.cr[0].lt {
	pc = 0x82A0253C; continue 'dispatch;
	}
	// 82A02558: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0255C: 4B94CDF5  bl 0x8234f350
	ctx.lr = 0x82A02560;
	sub_8234F350(ctx, base);
	// 82A02560: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A02564: 487A5C58  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A02568(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A02568 size=8
    let mut pc: u32 = 0x82A02568;
    'dispatch: loop {
        match pc {
            0x82A02568 => {
    //   block [0x82A02568..0x82A02570)
	// 82A02568: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 82A0256C: 4800047C  b 0x82a029e8
	sub_82A029E8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A02570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A02570 size=148
    let mut pc: u32 = 0x82A02570;
    'dispatch: loop {
        match pc {
            0x82A02570 => {
    //   block [0x82A02570..0x82A02604)
	// 82A02570: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A02574: 487A5BF9  bl 0x831a816c
	ctx.lr = 0x82A02578;
	sub_831A8130(ctx, base);
	// 82A02578: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0257C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A02580: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A02584: 4BB0FAE5  bl 0x82512068
	ctx.lr = 0x82A02588;
	sub_82512068(ctx, base);
	// 82A02588: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A0258C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A02590: 4BB083C1  bl 0x8250a950
	ctx.lr = 0x82A02594;
	sub_8250A950(ctx, base);
	// 82A02594: 3BFF0198  addi r31, r31, 0x198
	ctx.r[31].s64 = ctx.r[31].s64 + 408;
	// 82A02598: 3BA00008  li r29, 8
	ctx.r[29].s64 = 8;
	// 82A0259C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A025A0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A025A4: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82A025A8: 419A0040  beq cr6, 0x82a025e8
	if ctx.cr[6].eq {
	pc = 0x82A025E8; continue 'dispatch;
	}
	// 82A025AC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A025B0: 4847F191  bl 0x82e81740
	ctx.lr = 0x82A025B4;
	sub_82E81740(ctx, base);
	// 82A025B4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A025B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A025BC: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 82A025C0: 409A0008  bne cr6, 0x82a025c8
	if !ctx.cr[6].eq {
	pc = 0x82A025C8; continue 'dispatch;
	}
	// 82A025C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A025C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A025CC: 4BDD13A5  bl 0x827d3970
	ctx.lr = 0x82A025D0;
	sub_827D3970(ctx, base);
	// 82A025D0: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82A025D4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A025D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A025DC: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82A025E0: 419A0008  beq cr6, 0x82a025e8
	if ctx.cr[6].eq {
	pc = 0x82A025E8; continue 'dispatch;
	}
	// 82A025E4: 4B8BE2AD  bl 0x822c0890
	ctx.lr = 0x82A025E8;
	sub_822C0890(ctx, base);
	// 82A025E8: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82A025EC: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 82A025F0: 4082FFB0  bne 0x82a025a0
	if !ctx.cr[0].eq {
	pc = 0x82A025A0; continue 'dispatch;
	}
	// 82A025F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A025F8: 483EF699  bl 0x82df1c90
	ctx.lr = 0x82A025FC;
	sub_82DF1C90(ctx, base);
	// 82A025FC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A02600: 487A5BBC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A02608(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A02608 size=404
    let mut pc: u32 = 0x82A02608;
    'dispatch: loop {
        match pc {
            0x82A02608 => {
    //   block [0x82A02608..0x82A0279C)
	// 82A02608: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0260C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A02610: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A02614: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A02618: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0261C: 89640018  lbz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A02620: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A02624: 89440019  lbz r10, 0x19(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(25 as u32) ) } as u64;
	// 82A02628: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0262C: 7D7E0774  extsb r30, r11
	ctx.r[30].s64 = ctx.r[11].s8 as i64;
	// 82A02630: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A02634: 7D5EFA14  add r10, r30, r31
	ctx.r[10].u64 = ctx.r[30].u64 + ctx.r[31].u64;
	// 82A02638: 418200A8  beq 0x82a026e0
	if ctx.cr[0].eq {
	pc = 0x82A026E0; continue 'dispatch;
	}
	// 82A0263C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A02640: 3D208205  lis r9, -0x7dfb
	ctx.r[9].s64 = -2113601536;
	// 82A02644: 996A01D8  stb r11, 0x1d8(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(472 as u32), ctx.r[11].u8 ) };
	// 82A02648: 38890060  addi r4, r9, 0x60
	ctx.r[4].s64 = ctx.r[9].s64 + 96;
	// 82A0264C: 483F13BD  bl 0x82df3a08
	ctx.lr = 0x82A02650;
	sub_82DF3A08(ctx, base);
	// 82A02650: 395E002B  addi r10, r30, 0x2b
	ctx.r[10].s64 = ctx.r[30].s64 + 43;
	// 82A02654: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A02658: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A0265C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A02660: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A02664: C04B964C  lfs f2, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82A02668: 7C8AF82E  lwzx r4, r10, r31
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82A0266C: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 82A02670: 481B0D09  bl 0x82bb3378
	ctx.lr = 0x82A02674;
	sub_82BB3378(ctx, base);
	// 82A02674: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A02678: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0267C: 419A0008  beq cr6, 0x82a02684
	if ctx.cr[6].eq {
	pc = 0x82A02684; continue 'dispatch;
	}
	// 82A02680: 4B8BE211  bl 0x822c0890
	ctx.lr = 0x82A02684;
	sub_822C0890(ctx, base);
	// 82A02684: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A02688: 483F0DA1  bl 0x82df3428
	ctx.lr = 0x82A0268C;
	sub_82DF3428(ctx, base);
	// 82A0268C: 397E0033  addi r11, r30, 0x33
	ctx.r[11].s64 = ctx.r[30].s64 + 51;
	// 82A02690: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A02694: 7C6BF82E  lwzx r3, r11, r31
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82A02698: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0269C: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A026A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A026A4: 4E800421  bctrl
	ctx.lr = 0x82A026A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A026A8: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A026AC: 57CA2036  slwi r10, r30, 4
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A026B0: 396BE690  addi r11, r11, -0x1970
	ctx.r[11].s64 = ctx.r[11].s64 + -6512;
	// 82A026B4: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 82A026B8: 7CCA5A14  add r6, r10, r11
	ctx.r[6].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82A026BC: 38A97AF0  addi r5, r9, 0x7af0
	ctx.r[5].s64 = ctx.r[9].s64 + 31472;
	// 82A026C0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A026C4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A026C8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A026CC: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82A026D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A026D4: 4E800421  bctrl
	ctx.lr = 0x82A026D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A026D8: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A026DC: 4800009C  b 0x82a02778
	pc = 0x82A02778; continue 'dispatch;
	// 82A026E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A026E4: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 82A026E8: 996A01D8  stb r11, 0x1d8(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(472 as u32), ctx.r[11].u8 ) };
	// 82A026EC: 388922B8  addi r4, r9, 0x22b8
	ctx.r[4].s64 = ctx.r[9].s64 + 8888;
	// 82A026F0: 483F1319  bl 0x82df3a08
	ctx.lr = 0x82A026F4;
	sub_82DF3A08(ctx, base);
	// 82A026F4: 395E002B  addi r10, r30, 0x2b
	ctx.r[10].s64 = ctx.r[30].s64 + 43;
	// 82A026F8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A026FC: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A02700: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A02704: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A02708: C04B964C  lfs f2, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82A0270C: 7C8AF82E  lwzx r4, r10, r31
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82A02710: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 82A02714: 481B0C65  bl 0x82bb3378
	ctx.lr = 0x82A02718;
	sub_82BB3378(ctx, base);
	// 82A02718: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A0271C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A02720: 419A0008  beq cr6, 0x82a02728
	if ctx.cr[6].eq {
	pc = 0x82A02728; continue 'dispatch;
	}
	// 82A02724: 4B8BE16D  bl 0x822c0890
	ctx.lr = 0x82A02728;
	sub_822C0890(ctx, base);
	// 82A02728: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0272C: 483F0CFD  bl 0x82df3428
	ctx.lr = 0x82A02730;
	sub_82DF3428(ctx, base);
	// 82A02730: 397E0033  addi r11, r30, 0x33
	ctx.r[11].s64 = ctx.r[30].s64 + 51;
	// 82A02734: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A02738: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A0273C: 7C6BF82E  lwzx r3, r11, r31
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82A02740: 4847F001  bl 0x82e81740
	ctx.lr = 0x82A02744;
	sub_82E81740(ctx, base);
	// 82A02744: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A02748: 57CA2036  slwi r10, r30, 4
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A0274C: 396BE690  addi r11, r11, -0x1970
	ctx.r[11].s64 = ctx.r[11].s64 + -6512;
	// 82A02750: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 82A02754: 7CCA5A14  add r6, r10, r11
	ctx.r[6].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82A02758: 38A97AF0  addi r5, r9, 0x7af0
	ctx.r[5].s64 = ctx.r[9].s64 + 31472;
	// 82A0275C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A02760: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A02764: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A02768: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82A0276C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A02770: 4E800421  bctrl
	ctx.lr = 0x82A02774;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A02774: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A02778: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0277C: 419A0008  beq cr6, 0x82a02784
	if ctx.cr[6].eq {
	pc = 0x82A02784; continue 'dispatch;
	}
	// 82A02780: 4B8BE111  bl 0x822c0890
	ctx.lr = 0x82A02784;
	sub_822C0890(ctx, base);
	// 82A02784: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A02788: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0278C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A02790: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A02794: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A02798: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A027A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A027A0 size=124
    let mut pc: u32 = 0x82A027A0;
    'dispatch: loop {
        match pc {
            0x82A027A0 => {
    //   block [0x82A027A0..0x82A0281C)
	// 82A027A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A027A4: 487A59C9  bl 0x831a816c
	ctx.lr = 0x82A027A8;
	sub_831A8130(ctx, base);
	// 82A027A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A027AC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A027B0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A027B4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A027B8: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82A027BC: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 82A027C0: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 82A027C4: 483EFC25  bl 0x82df23e8
	ctx.lr = 0x82A027C8;
	sub_82DF23E8(ctx, base);
	// 82A027C8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A027CC: 4182001C  beq 0x82a027e8
	if ctx.cr[0].eq {
	pc = 0x82A027E8; continue 'dispatch;
	}
	// 82A027D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A027D4: 48456EAD  bl 0x82e59680
	ctx.lr = 0x82A027D8;
	sub_82E59680(ctx, base);
	// 82A027D8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A027DC: 396B7A5C  addi r11, r11, 0x7a5c
	ctx.r[11].s64 = ctx.r[11].s64 + 31324;
	// 82A027E0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A027E4: 48000008  b 0x82a027ec
	pc = 0x82A027EC; continue 'dispatch;
	// 82A027E8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A027EC: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A027F0: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82A027F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A027F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A027FC: 4BFFFA3D  bl 0x82a02238
	ctx.lr = 0x82A02800;
	sub_82A02238(ctx, base);
	// 82A02800: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A02804: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A02808: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A0280C: 4B8BD7F5  bl 0x822c0000
	ctx.lr = 0x82A02810;
	sub_822C0000(ctx, base);
	// 82A02810: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A02814: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A02818: 487A59A4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A02820(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A02820 size=220
    let mut pc: u32 = 0x82A02820;
    'dispatch: loop {
        match pc {
            0x82A02820 => {
    //   block [0x82A02820..0x82A028FC)
	// 82A02820: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A02824: 487A5945  bl 0x831a8168
	ctx.lr = 0x82A02828;
	sub_831A8130(ctx, base);
	// 82A02828: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0282C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82A02830: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A02834: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A02838: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82A0283C: 41820038  beq 0x82a02874
	if ctx.cr[0].eq {
	pc = 0x82A02874; continue 'dispatch;
	}
	// 82A02840: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A02844: 487A7145  bl 0x831a9988
	ctx.lr = 0x82A02848;
	sub_831A9988(ctx, base);
	// 82A02848: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82A0284C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A02850: 386BC8E4  addi r3, r11, -0x371c
	ctx.r[3].s64 = ctx.r[11].s64 + -14108;
	// 82A02854: 487A58A5  bl 0x831a80f8
	ctx.lr = 0x82A02858;
	sub_831A80F8(ctx, base);
	// 82A02858: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A0285C: 41820018  beq 0x82a02874
	if ctx.cr[0].eq {
	pc = 0x82A02874; continue 'dispatch;
	}
	// 82A02860: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A02864: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A02868: 4BC68489  bl 0x8266acf0
	ctx.lr = 0x82A0286C;
	sub_8266ACF0(ctx, base);
	// 82A0286C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A02870: 48000084  b 0x82a028f4
	pc = 0x82A028F4; continue 'dispatch;
	// 82A02874: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A02878: 419A006C  beq cr6, 0x82a028e4
	if ctx.cr[6].eq {
	pc = 0x82A028E4; continue 'dispatch;
	}
	// 82A0287C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A02880: 487A7109  bl 0x831a9988
	ctx.lr = 0x82A02884;
	sub_831A9988(ctx, base);
	// 82A02884: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A02888: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A0288C: 386BD76C  addi r3, r11, -0x2894
	ctx.r[3].s64 = ctx.r[11].s64 + -10388;
	// 82A02890: 487A5869  bl 0x831a80f8
	ctx.lr = 0x82A02894;
	sub_831A80F8(ctx, base);
	// 82A02894: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A02898: 41820014  beq 0x82a028ac
	if ctx.cr[0].eq {
	pc = 0x82A028AC; continue 'dispatch;
	}
	// 82A0289C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A028A0: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A028A4: 4BFFF915  bl 0x82a021b8
	ctx.lr = 0x82A028A8;
	sub_82A021B8(ctx, base);
	// 82A028A8: 4BFFFFC4  b 0x82a0286c
	pc = 0x82A0286C; continue 'dispatch;
	// 82A028AC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A028B0: 419A0034  beq cr6, 0x82a028e4
	if ctx.cr[6].eq {
	pc = 0x82A028E4; continue 'dispatch;
	}
	// 82A028B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A028B8: 487A70D1  bl 0x831a9988
	ctx.lr = 0x82A028BC;
	sub_831A9988(ctx, base);
	// 82A028BC: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A028C0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A028C4: 386BE710  addi r3, r11, -0x18f0
	ctx.r[3].s64 = ctx.r[11].s64 + -6384;
	// 82A028C8: 487A5831  bl 0x831a80f8
	ctx.lr = 0x82A028CC;
	sub_831A80F8(ctx, base);
	// 82A028CC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A028D0: 41820014  beq 0x82a028e4
	if ctx.cr[0].eq {
	pc = 0x82A028E4; continue 'dispatch;
	}
	// 82A028D4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A028D8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A028DC: 4BFFFD2D  bl 0x82a02608
	ctx.lr = 0x82A028E0;
	sub_82A02608(ctx, base);
	// 82A028E0: 4BFFFF8C  b 0x82a0286c
	pc = 0x82A0286C; continue 'dispatch;
	// 82A028E4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82A028E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A028EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A028F0: 4BB0FD29  bl 0x82512618
	ctx.lr = 0x82A028F4;
	sub_82512618(ctx, base);
	// 82A028F4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A028F8: 487A58C0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A02900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A02900 size=232
    let mut pc: u32 = 0x82A02900;
    'dispatch: loop {
        match pc {
            0x82A02900 => {
    //   block [0x82A02900..0x82A029E8)
	// 82A02900: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A02904: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A02908: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A0290C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A02910: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A02914: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82A02918: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82A0291C: 38ABBA80  addi r5, r11, -0x4580
	ctx.r[5].s64 = ctx.r[11].s64 + -17792;
	// 82A02920: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A02924: 4BB0F93D  bl 0x82512260
	ctx.lr = 0x82A02928;
	sub_82512260(ctx, base);
	// 82A02928: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A0292C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A02930: 392B7AB4  addi r9, r11, 0x7ab4
	ctx.r[9].s64 = ctx.r[11].s64 + 31412;
	// 82A02934: 394A7AA0  addi r10, r10, 0x7aa0
	ctx.r[10].s64 = ctx.r[10].s64 + 31392;
	// 82A02938: 397F00E4  addi r11, r31, 0xe4
	ctx.r[11].s64 = ctx.r[31].s64 + 228;
	// 82A0293C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A02940: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82A02944: 39200003  li r9, 3
	ctx.r[9].s64 = 3;
	// 82A02948: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 82A0294C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A02950: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A02954: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82A02958: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A0295C: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	// 82A02960: 4080FFF0  bge 0x82a02950
	if !ctx.cr[0].lt {
	pc = 0x82A02950; continue 'dispatch;
	}
	// 82A02964: 39000002  li r8, 2
	ctx.r[8].s64 = 2;
	// 82A02968: 997F0114  stb r11, 0x114(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), ctx.r[11].u8 ) };
	// 82A0296C: 395F0118  addi r10, r31, 0x118
	ctx.r[10].s64 = ctx.r[31].s64 + 280;
	// 82A02970: 991F0115  stb r8, 0x115(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(277 as u32), ctx.r[8].u8 ) };
	// 82A02974: 39200007  li r9, 7
	ctx.r[9].s64 = 7;
	// 82A02978: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A0297C: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82A02980: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A02984: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82A02988: 4080FFF0  bge 0x82a02978
	if !ctx.cr[0].lt {
	pc = 0x82A02978; continue 'dispatch;
	}
	// 82A0298C: 395F0158  addi r10, r31, 0x158
	ctx.r[10].s64 = ctx.r[31].s64 + 344;
	// 82A02990: 39200007  li r9, 7
	ctx.r[9].s64 = 7;
	// 82A02994: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A02998: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82A0299C: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A029A0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82A029A4: 4080FFF0  bge 0x82a02994
	if !ctx.cr[0].lt {
	pc = 0x82A02994; continue 'dispatch;
	}
	// 82A029A8: 395F0198  addi r10, r31, 0x198
	ctx.r[10].s64 = ctx.r[31].s64 + 408;
	// 82A029AC: 39200007  li r9, 7
	ctx.r[9].s64 = 7;
	// 82A029B0: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A029B4: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82A029B8: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A029BC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82A029C0: 4080FFF0  bge 0x82a029b0
	if !ctx.cr[0].lt {
	pc = 0x82A029B0; continue 'dispatch;
	}
	// 82A029C4: 93DF01E4  stw r30, 0x1e4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(484 as u32), ctx.r[30].u32 ) };
	// 82A029C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A029CC: 991F01E0  stb r8, 0x1e0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(480 as u32), ctx.r[8].u8 ) };
	// 82A029D0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A029D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A029D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A029DC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A029E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A029E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A029E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A029E8 size=76
    let mut pc: u32 = 0x82A029E8;
    'dispatch: loop {
        match pc {
            0x82A029E8 => {
    //   block [0x82A029E8..0x82A02A34)
	// 82A029E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A029EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A029F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A029F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A029F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A029FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A02A00: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A02A04: 4BFFFA8D  bl 0x82a02490
	ctx.lr = 0x82A02A08;
	sub_82A02490(ctx, base);
	// 82A02A08: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A02A0C: 4182000C  beq 0x82a02a18
	if ctx.cr[0].eq {
	pc = 0x82A02A18; continue 'dispatch;
	}
	// 82A02A10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A02A14: 483EF9C5  bl 0x82df23d8
	ctx.lr = 0x82A02A18;
	sub_82DF23D8(ctx, base);
	// 82A02A18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A02A1C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A02A20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A02A24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A02A28: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A02A2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A02A30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A02A38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A02A38 size=148
    let mut pc: u32 = 0x82A02A38;
    'dispatch: loop {
        match pc {
            0x82A02A38 => {
    //   block [0x82A02A38..0x82A02ACC)
	// 82A02A38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A02A3C: 487A572D  bl 0x831a8168
	ctx.lr = 0x82A02A40;
	sub_831A8130(ctx, base);
	// 82A02A40: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A02A44: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A02A48: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A02A4C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A02A50: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82A02A54: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A02A58: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82A02A5C: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 82A02A60: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82A02A64: 483EF985  bl 0x82df23e8
	ctx.lr = 0x82A02A68;
	sub_82DF23E8(ctx, base);
	// 82A02A68: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A02A6C: 4182002C  beq 0x82a02a98
	if ctx.cr[0].eq {
	pc = 0x82A02A98; continue 'dispatch;
	}
	// 82A02A70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A02A74: 8B9C0000  lbz r28, 0(r28)
	ctx.r[28].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A02A78: 8BDE0000  lbz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A02A7C: 48456C05  bl 0x82e59680
	ctx.lr = 0x82A02A80;
	sub_82E59680(ctx, base);
	// 82A02A80: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A02A84: 9BDF0018  stb r30, 0x18(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u8 ) };
	// 82A02A88: 396B7A54  addi r11, r11, 0x7a54
	ctx.r[11].s64 = ctx.r[11].s64 + 31316;
	// 82A02A8C: 9B9F0019  stb r28, 0x19(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(25 as u32), ctx.r[28].u8 ) };
	// 82A02A90: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A02A94: 48000008  b 0x82a02a9c
	pc = 0x82A02A9C; continue 'dispatch;
	// 82A02A98: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A02A9C: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A02AA0: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82A02AA4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A02AA8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A02AAC: 4BFFF91D  bl 0x82a023c8
	ctx.lr = 0x82A02AB0;
	sub_82A023C8(ctx, base);
	// 82A02AB0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A02AB4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A02AB8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A02ABC: 4B8BD545  bl 0x822c0000
	ctx.lr = 0x82A02AC0;
	sub_822C0000(ctx, base);
	// 82A02AC0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A02AC4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A02AC8: 487A56F0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A02AD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A02AD0 size=1288
    let mut pc: u32 = 0x82A02AD0;
    'dispatch: loop {
        match pc {
            0x82A02AD0 => {
    //   block [0x82A02AD0..0x82A02FD8)
	// 82A02AD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A02AD4: 487A565D  bl 0x831a8130
	ctx.lr = 0x82A02AD8;
	sub_831A8130(ctx, base);
	// 82A02AD8: DBA1FF50  stfd f29, -0xb0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-176 as u32), ctx.f[29].u64 ) };
	// 82A02ADC: DBC1FF58  stfd f30, -0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-168 as u32), ctx.f[30].u64 ) };
	// 82A02AE0: DBE1FF60  stfd f31, -0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.f[31].u64 ) };
	// 82A02AE4: 9421FE30  stwu r1, -0x1d0(r1)
	ea = ctx.r[1].u32.wrapping_add(-464 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A02AE8: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82A02AEC: 39E00000  li r15, 0
	ctx.r[15].s64 = 0;
	// 82A02AF0: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82A02AF4: 93C101F4  stw r30, 0x1f4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(500 as u32), ctx.r[30].u32 ) };
	// 82A02AF8: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 82A02AFC: 91E10050  stw r15, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[15].u32 ) };
	// 82A02B00: 4BB0EED9  bl 0x825119d8
	ctx.lr = 0x82A02B04;
	sub_825119D8(ctx, base);
	// 82A02B04: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82A02B08: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82A02B0C: 4BB0C865  bl 0x8250f370
	ctx.lr = 0x82A02B10;
	sub_8250F370(ctx, base);
	// 82A02B10: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82A02B14: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A02B18: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 82A02B1C: 483F0EED  bl 0x82df3a08
	ctx.lr = 0x82A02B20;
	sub_82DF3A08(ctx, base);
	// 82A02B20: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 82A02B24: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82A02B28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A02B2C: 4BB05C55  bl 0x82508780
	ctx.lr = 0x82A02B30;
	sub_82508780(ctx, base);
	// 82A02B30: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A02B34: 483F08F5  bl 0x82df3428
	ctx.lr = 0x82A02B38;
	sub_82DF3428(ctx, base);
	// 82A02B38: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 82A02B3C: 38990028  addi r4, r25, 0x28
	ctx.r[4].s64 = ctx.r[25].s64 + 40;
	// 82A02B40: 409A0008  bne cr6, 0x82a02b48
	if !ctx.cr[6].eq {
	pc = 0x82A02B48; continue 'dispatch;
	}
	// 82A02B44: 7DE47B78  mr r4, r15
	ctx.r[4].u64 = ctx.r[15].u64;
	// 82A02B48: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A02B4C: 4BB05C55  bl 0x825087a0
	ctx.lr = 0x82A02B50;
	sub_825087A0(ctx, base);
	// 82A02B50: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82A02B54: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A02B58: 48427F91  bl 0x82e2aae8
	ctx.lr = 0x82A02B5C;
	sub_82E2AAE8(ctx, base);
	// 82A02B5C: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82A02B60: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A02B64: 4843D3A5  bl 0x82e3ff08
	ctx.lr = 0x82A02B68;
	sub_82E3FF08(ctx, base);
	// 82A02B68: 397901D8  addi r11, r25, 0x1d8
	ctx.r[11].s64 = ctx.r[25].s64 + 472;
	// 82A02B6C: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 82A02B70: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A02B74: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A02B78: 3CA08200  lis r5, -0x7e00
	ctx.r[5].s64 = -2113929216;
	// 82A02B7C: 7DEE7B78  mr r14, r15
	ctx.r[14].u64 = ctx.r[15].u64;
	// 82A02B80: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A02B84: C3C608A4  lfs f30, 0x8a4(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82A02B88: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 82A02B8C: C3EB9534  lfs f31, -0x6acc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A02B90: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 82A02B94: C3A508A8  lfs f29, 0x8a8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(2216 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82A02B98: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 82A02B9C: 3CC08205  lis r6, -0x7dfb
	ctx.r[6].s64 = -2113601536;
	// 82A02BA0: 91C10060  stw r14, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[14].u32 ) };
	// 82A02BA4: 3CA0820A  lis r5, -0x7df6
	ctx.r[5].s64 = -2113273856;
	// 82A02BA8: 3C80832E  lis r4, -0x7cd2
	ctx.r[4].s64 = -2094137344;
	// 82A02BAC: 3C608338  lis r3, -0x7cc8
	ctx.r[3].s64 = -2093481984;
	// 82A02BB0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A02BB4: 3BD90118  addi r30, r25, 0x118
	ctx.r[30].s64 = ctx.r[25].s64 + 280;
	// 82A02BB8: 3A000001  li r16, 1
	ctx.r[16].s64 = 1;
	// 82A02BBC: 3E408335  lis r18, -0x7ccb
	ctx.r[18].s64 = -2093678592;
	// 82A02BC0: 3A2A7B88  addi r17, r10, 0x7b88
	ctx.r[17].s64 = ctx.r[10].s64 + 31624;
	// 82A02BC4: 3B097B70  addi r24, r9, 0x7b70
	ctx.r[24].s64 = ctx.r[9].s64 + 31600;
	// 82A02BC8: 3AE822B8  addi r23, r8, 0x22b8
	ctx.r[23].s64 = ctx.r[8].s64 + 8888;
	// 82A02BCC: 3B477B5C  addi r26, r7, 0x7b5c
	ctx.r[26].s64 = ctx.r[7].s64 + 31580;
	// 82A02BD0: 3AC60060  addi r22, r6, 0x60
	ctx.r[22].s64 = ctx.r[6].s64 + 96;
	// 82A02BD4: 3A657B54  addi r19, r5, 0x7b54
	ctx.r[19].s64 = ctx.r[5].s64 + 31572;
	// 82A02BD8: 3AA4E690  addi r21, r4, -0x1970
	ctx.r[21].s64 = ctx.r[4].s64 + -6512;
	// 82A02BDC: 3A83DA80  addi r20, r3, -0x2580
	ctx.r[20].s64 = ctx.r[3].s64 + -9600;
	// 82A02BE0: 3B6B7B08  addi r27, r11, 0x7b08
	ctx.r[27].s64 = ctx.r[11].s64 + 31496;
	// 82A02BE4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A02BE8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A02BEC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A02BF0: 91E10068  stw r15, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[15].u32 ) };
	// 82A02BF4: 38A00086  li r5, 0x86
	ctx.r[5].s64 = 134;
	// 82A02BF8: 91E1006C  stw r15, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[15].u32 ) };
	// 82A02BFC: 38600100  li r3, 0x100
	ctx.r[3].s64 = 256;
	// 82A02C00: 99EB0000  stb r15, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[15].u8 ) };
	// 82A02C04: 483EF7E5  bl 0x82df23e8
	ctx.lr = 0x82A02C08;
	sub_82DF23E8(ctx, base);
	// 82A02C08: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A02C0C: 41820018  beq 0x82a02c24
	if ctx.cr[0].eq {
	pc = 0x82A02C24; continue 'dispatch;
	}
	// 82A02C10: 7CAEA214  add r5, r14, r20
	ctx.r[5].u64 = ctx.r[14].u64 + ctx.r[20].u64;
	// 82A02C14: 7C8EAA14  add r4, r14, r21
	ctx.r[4].u64 = ctx.r[14].u64 + ctx.r[21].u64;
	// 82A02C18: 4BB88109  bl 0x8258ad20
	ctx.lr = 0x82A02C1C;
	sub_8258AD20(ctx, base);
	// 82A02C1C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A02C20: 48000008  b 0x82a02c28
	pc = 0x82A02C28; continue 'dispatch;
	// 82A02C24: 7DE47B78  mr r4, r15
	ctx.r[4].u64 = ctx.r[15].u64;
	// 82A02C28: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A02C2C: 4B9D0BFD  bl 0x823d3828
	ctx.lr = 0x82A02C30;
	sub_823D3828(ctx, base);
	// 82A02C30: 7E649B78  mr r4, r19
	ctx.r[4].u64 = ctx.r[19].u64;
	// 82A02C34: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82A02C38: 483F0DD1  bl 0x82df3a08
	ctx.lr = 0x82A02C3C;
	sub_82DF3A08(ctx, base);
	// 82A02C3C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A02C40: 38A10064  addi r5, r1, 0x64
	ctx.r[5].s64 = ctx.r[1].s64 + 100;
	// 82A02C44: 38810088  addi r4, r1, 0x88
	ctx.r[4].s64 = ctx.r[1].s64 + 136;
	// 82A02C48: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A02C4C: 4842C225  bl 0x82e2ee70
	ctx.lr = 0x82A02C50;
	sub_82E2EE70(ctx, base);
	// 82A02C50: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82A02C54: 483F07D5  bl 0x82df3428
	ctx.lr = 0x82A02C58;
	sub_82DF3428(ctx, base);
	// 82A02C58: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82A02C5C: 83A1006C  lwz r29, 0x6c(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A02C60: 83810068  lwz r28, 0x68(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A02C64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A02C68: 419A008C  beq cr6, 0x82a02cf4
	if ctx.cr[6].eq {
	pc = 0x82A02CF4; continue 'dispatch;
	}
	// 82A02C6C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A02C70: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A02C74: 38A0008E  li r5, 0x8e
	ctx.r[5].s64 = 142;
	// 82A02C78: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 82A02C7C: 483EF76D  bl 0x82df23e8
	ctx.lr = 0x82A02C80;
	sub_82DF23E8(ctx, base);
	// 82A02C80: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A02C84: 41820014  beq 0x82a02c98
	if ctx.cr[0].eq {
	pc = 0x82A02C98; continue 'dispatch;
	}
	// 82A02C88: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82A02C8C: 48413C05  bl 0x82e16890
	ctx.lr = 0x82A02C90;
	sub_82E16890(ctx, base);
	// 82A02C90: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A02C94: 48000008  b 0x82a02c9c
	pc = 0x82A02C9C; continue 'dispatch;
	// 82A02C98: 7DE47B78  mr r4, r15
	ctx.r[4].u64 = ctx.r[15].u64;
	// 82A02C9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A02CA0: 4B95A6D1  bl 0x8235d370
	ctx.lr = 0x82A02CA4;
	sub_8235D370(ctx, base);
	// 82A02CA4: 93810090  stw r28, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[28].u32 ) };
	// 82A02CA8: 93A10094  stw r29, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[29].u32 ) };
	// 82A02CAC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A02CB0: 419A0024  beq cr6, 0x82a02cd4
	if ctx.cr[6].eq {
	pc = 0x82A02CD4; continue 'dispatch;
	}
	// 82A02CB4: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82A02CB8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A02CBC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A02CC0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A02CC4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A02CC8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A02CCC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A02CD0: 4082FFE8  bne 0x82a02cb8
	if !ctx.cr[0].eq {
	pc = 0x82A02CB8; continue 'dispatch;
	}
	// 82A02CD4: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 82A02CD8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A02CDC: 484123D5  bl 0x82e150b0
	ctx.lr = 0x82A02CE0;
	sub_82E150B0(ctx, base);
	// 82A02CE0: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82A02CE4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A02CE8: 80927058  lwz r4, 0x7058(r18)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(28760 as u32) ) } as u64;
	// 82A02CEC: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82A02CF0: 4BB0DE69  bl 0x82510b58
	ctx.lr = 0x82A02CF4;
	sub_82510B58(ctx, base);
	// 82A02CF4: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A02CF8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A02CFC: 419A0008  beq cr6, 0x82a02d04
	if ctx.cr[6].eq {
	pc = 0x82A02D04; continue 'dispatch;
	}
	// 82A02D00: 4B8BDB91  bl 0x822c0890
	ctx.lr = 0x82A02D04;
	sub_822C0890(ctx, base);
	// 82A02D04: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A02D08: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A02D0C: 419A017C  beq cr6, 0x82a02e88
	if ctx.cr[6].eq {
	pc = 0x82A02E88; continue 'dispatch;
	}
	// 82A02D10: D3A100C8  stfs f29, 0xc8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82A02D14: 92C100C0  stw r22, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[22].u32 ) };
	// 82A02D18: D3C100D0  stfs f30, 0xd0(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 82A02D1C: 934100C4  stw r26, 0xc4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[26].u32 ) };
	// 82A02D20: D3E100D4  stfs f31, 0xd4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82A02D24: 920100CC  stw r16, 0xcc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), ctx.r[16].u32 ) };
	// 82A02D28: D3E100D8  stfs f31, 0xd8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82A02D2C: 99E100DC  stb r15, 0xdc(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), ctx.r[15].u8 ) };
	// 82A02D30: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82A02D34: 483FBB95  bl 0x82dfe8c8
	ctx.lr = 0x82A02D38;
	sub_82DFE8C8(ctx, base);
	// 82A02D38: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 82A02D3C: 483FBB8D  bl 0x82dfe8c8
	ctx.lr = 0x82A02D40;
	sub_82DFE8C8(ctx, base);
	// 82A02D40: D3A100F8  stfs f29, 0xf8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 82A02D44: D3C10100  stfs f30, 0x100(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 82A02D48: 92E100F0  stw r23, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[23].u32 ) };
	// 82A02D4C: D3E10104  stfs f31, 0x104(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 82A02D50: 930100F4  stw r24, 0xf4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(244 as u32), ctx.r[24].u32 ) };
	// 82A02D54: D3E10108  stfs f31, 0x108(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 82A02D58: 920100FC  stw r16, 0xfc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(252 as u32), ctx.r[16].u32 ) };
	// 82A02D5C: 99E1010C  stb r15, 0x10c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(268 as u32), ctx.r[15].u8 ) };
	// 82A02D60: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 82A02D64: 483FBB65  bl 0x82dfe8c8
	ctx.lr = 0x82A02D68;
	sub_82DFE8C8(ctx, base);
	// 82A02D68: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 82A02D6C: 483FBB5D  bl 0x82dfe8c8
	ctx.lr = 0x82A02D70;
	sub_82DFE8C8(ctx, base);
	// 82A02D70: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A02D74: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A02D78: 38A000A0  li r5, 0xa0
	ctx.r[5].s64 = 160;
	// 82A02D7C: 38600140  li r3, 0x140
	ctx.r[3].s64 = 320;
	// 82A02D80: 483EF669  bl 0x82df23e8
	ctx.lr = 0x82A02D84;
	sub_82DF23E8(ctx, base);
	// 82A02D84: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A02D88: 4182004C  beq 0x82a02dd4
	if ctx.cr[0].eq {
	pc = 0x82A02DD4; continue 'dispatch;
	}
	// 82A02D8C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82A02D90: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A02D94: 483F0C75  bl 0x82df3a08
	ctx.lr = 0x82A02D98;
	sub_82DF3A08(ctx, base);
	// 82A02D98: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A02D9C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82A02DA0: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82A02DA4: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82A02DA8: 616B0002  ori r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u64 | 2;
	// 82A02DAC: 39C10058  addi r14, r1, 0x58
	ctx.r[14].s64 = ctx.r[1].s64 + 88;
	// 82A02DB0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A02DB4: 4BB0C715  bl 0x8250f4c8
	ctx.lr = 0x82A02DB8;
	sub_8250F4C8(ctx, base);
	// 82A02DB8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A02DBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A02DC0: 7DC57378  mr r5, r14
	ctx.r[5].u64 = ctx.r[14].u64;
	// 82A02DC4: 481B0E3D  bl 0x82bb3c00
	ctx.lr = 0x82A02DC8;
	sub_82BB3C00(ctx, base);
	// 82A02DC8: 81C10060  lwz r14, 0x60(r1)
	ctx.r[14].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82A02DCC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A02DD0: 48000008  b 0x82a02dd8
	pc = 0x82A02DD8; continue 'dispatch;
	// 82A02DD4: 7DE47B78  mr r4, r15
	ctx.r[4].u64 = ctx.r[15].u64;
	// 82A02DD8: 3BFE0040  addi r31, r30, 0x40
	ctx.r[31].s64 = ctx.r[30].s64 + 64;
	// 82A02DDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A02DE0: 4B95A601  bl 0x8235d3e0
	ctx.lr = 0x82A02DE4;
	sub_8235D3E0(ctx, base);
	// 82A02DE4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A02DE8: 556A07BD  rlwinm. r10, r11, 0, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82A02DEC: 41820018  beq 0x82a02e04
	if ctx.cr[0].eq {
	pc = 0x82A02E04; continue 'dispatch;
	}
	// 82A02DF0: 556B07FA  rlwinm r11, r11, 0, 0x1f, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82A02DF4: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82A02DF8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A02DFC: 483EEE95  bl 0x82df1c90
	ctx.lr = 0x82A02E00;
	sub_82DF1C90(ctx, base);
	// 82A02E00: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A02E04: 556A07FF  clrlwi. r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82A02E08: 41820014  beq 0x82a02e1c
	if ctx.cr[0].eq {
	pc = 0x82A02E1C; continue 'dispatch;
	}
	// 82A02E0C: 556B003C  rlwinm r11, r11, 0, 0, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82A02E10: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A02E14: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A02E18: 483F0611  bl 0x82df3428
	ctx.lr = 0x82A02E1C;
	sub_82DF3428(ctx, base);
	// 82A02E1C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A02E20: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82A02E24: 419A0064  beq cr6, 0x82a02e88
	if ctx.cr[6].eq {
	pc = 0x82A02E88; continue 'dispatch;
	}
	// 82A02E28: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82A02E2C: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 82A02E30: 481B2131  bl 0x82bb4f60
	ctx.lr = 0x82A02E34;
	sub_82BB4F60(ctx, base);
	// 82A02E34: 817E0044  lwz r11, 0x44(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(68 as u32) ) } as u64;
	// 82A02E38: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A02E3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A02E40: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82A02E44: 91410080  stw r10, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 82A02E48: 419A0024  beq cr6, 0x82a02e6c
	if ctx.cr[6].eq {
	pc = 0x82A02E6C; continue 'dispatch;
	}
	// 82A02E4C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A02E50: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A02E54: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A02E58: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A02E5C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A02E60: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A02E64: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A02E68: 4082FFE8  bne 0x82a02e50
	if !ctx.cr[0].eq {
	pc = 0x82A02E50; continue 'dispatch;
	}
	// 82A02E6C: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82A02E70: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A02E74: 484120FD  bl 0x82e14f70
	ctx.lr = 0x82A02E78;
	sub_82E14F70(ctx, base);
	// 82A02E78: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82A02E7C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A02E80: 419A0008  beq cr6, 0x82a02e88
	if ctx.cr[6].eq {
	pc = 0x82A02E88; continue 'dispatch;
	}
	// 82A02E84: 4B8BDA0D  bl 0x822c0890
	ctx.lr = 0x82A02E88;
	sub_822C0890(ctx, base);
	// 82A02E88: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A02E8C: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A02E90: 483FB951  bl 0x82dfe7e0
	ctx.lr = 0x82A02E94;
	sub_82DFE7E0(ctx, base);
	// 82A02E94: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A02E98: 41820010  beq 0x82a02ea8
	if ctx.cr[0].eq {
	pc = 0x82A02EA8; continue 'dispatch;
	}
	// 82A02E9C: 807E0040  lwz r3, 0x40(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) } as u64;
	// 82A02EA0: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82A02EA4: 481B264D  bl 0x82bb54f0
	ctx.lr = 0x82A02EA8;
	sub_82BB54F0(ctx, base);
	// 82A02EA8: 7E248B78  mr r4, r17
	ctx.r[4].u64 = ctx.r[17].u64;
	// 82A02EAC: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82A02EB0: 483F0B59  bl 0x82df3a08
	ctx.lr = 0x82A02EB4;
	sub_82DF3A08(ctx, base);
	// 82A02EB4: 93810078  stw r28, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[28].u32 ) };
	// 82A02EB8: 93A1007C  stw r29, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[29].u32 ) };
	// 82A02EBC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A02EC0: 419A0024  beq cr6, 0x82a02ee4
	if ctx.cr[6].eq {
	pc = 0x82A02EE4; continue 'dispatch;
	}
	// 82A02EC4: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82A02EC8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A02ECC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A02ED0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A02ED4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A02ED8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A02EDC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A02EE0: 4082FFE8  bne 0x82a02ec8
	if !ctx.cr[0].eq {
	pc = 0x82A02EC8; continue 'dispatch;
	}
	// 82A02EE4: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82A02EE8: 808101F4  lwz r4, 0x1f4(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(500 as u32) ) } as u64;
	// 82A02EEC: 4BB07A65  bl 0x8250a950
	ctx.lr = 0x82A02EF0;
	sub_8250A950(ctx, base);
	// 82A02EF0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A02EF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A02EF8: 388BFF40  addi r4, r11, -0xc0
	ctx.r[4].s64 = ctx.r[11].s64 + -192;
	// 82A02EFC: 409A0008  bne cr6, 0x82a02f04
	if !ctx.cr[6].eq {
	pc = 0x82A02F04; continue 'dispatch;
	}
	// 82A02F00: 7DE47B78  mr r4, r15
	ctx.r[4].u64 = ctx.r[15].u64;
	// 82A02F04: 38E0000B  li r7, 0xb
	ctx.r[7].s64 = 11;
	// 82A02F08: 38C1005C  addi r6, r1, 0x5c
	ctx.r[6].s64 = ctx.r[1].s64 + 92;
	// 82A02F0C: 38A10078  addi r5, r1, 0x78
	ctx.r[5].s64 = ctx.r[1].s64 + 120;
	// 82A02F10: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82A02F14: 4BDD1D9D  bl 0x827d4cb0
	ctx.lr = 0x82A02F18;
	sub_827D4CB0(ctx, base);
	// 82A02F18: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A02F1C: 387E0084  addi r3, r30, 0x84
	ctx.r[3].s64 = ctx.r[30].s64 + 132;
	// 82A02F20: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82A02F24: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A02F28: 917E0080  stw r11, 0x80(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82A02F2C: 4B8C1535  bl 0x822c4460
	ctx.lr = 0x82A02F30;
	sub_822C4460(ctx, base);
	// 82A02F30: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82A02F34: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A02F38: 419A0008  beq cr6, 0x82a02f40
	if ctx.cr[6].eq {
	pc = 0x82A02F40; continue 'dispatch;
	}
	// 82A02F3C: 4B8BD955  bl 0x822c0890
	ctx.lr = 0x82A02F40;
	sub_822C0890(ctx, base);
	// 82A02F40: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82A02F44: 483EED4D  bl 0x82df1c90
	ctx.lr = 0x82A02F48;
	sub_82DF1C90(ctx, base);
	// 82A02F48: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82A02F4C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A02F50: 419A0008  beq cr6, 0x82a02f58
	if ctx.cr[6].eq {
	pc = 0x82A02F58; continue 'dispatch;
	}
	// 82A02F54: 4B8BD93D  bl 0x822c0890
	ctx.lr = 0x82A02F58;
	sub_822C0890(ctx, base);
	// 82A02F58: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82A02F5C: 483F04CD  bl 0x82df3428
	ctx.lr = 0x82A02F60;
	sub_82DF3428(ctx, base);
	// 82A02F60: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A02F64: 807E0080  lwz r3, 0x80(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(128 as u32) ) } as u64;
	// 82A02F68: 4847E7D9  bl 0x82e81740
	ctx.lr = 0x82A02F6C;
	sub_82E81740(ctx, base);
	// 82A02F6C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A02F70: 419A000C  beq cr6, 0x82a02f7c
	if ctx.cr[6].eq {
	pc = 0x82A02F7C; continue 'dispatch;
	}
	// 82A02F74: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A02F78: 4B8BD919  bl 0x822c0890
	ctx.lr = 0x82A02F7C;
	sub_822C0890(ctx, base);
	// 82A02F7C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A02F80: 39CE0010  addi r14, r14, 0x10
	ctx.r[14].s64 = ctx.r[14].s64 + 16;
	// 82A02F84: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82A02F88: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A02F8C: 91C10060  stw r14, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[14].u32 ) };
	// 82A02F90: 2F0E0080  cmpwi cr6, r14, 0x80
	ctx.cr[6].compare_i32(ctx.r[14].s32, 128, &mut ctx.xer);
	// 82A02F94: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A02F98: 4198FC4C  blt cr6, 0x82a02be4
	if ctx.cr[6].lt {
	pc = 0x82A02BE4; continue 'dispatch;
	}
	// 82A02F9C: 7DEB7B78  mr r11, r15
	ctx.r[11].u64 = ctx.r[15].u64;
	// 82A02FA0: 394B0013  addi r10, r11, 0x13
	ctx.r[10].s64 = ctx.r[11].s64 + 19;
	// 82A02FA4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A02FA8: 1D4A000C  mulli r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 * 12;
	// 82A02FAC: 7E0AC9AE  stbx r16, r10, r25
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[25].u32), ctx.r[16].u8) };
	// 82A02FB0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A02FB4: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 82A02FB8: 4198FFE8  blt cr6, 0x82a02fa0
	if ctx.cr[6].lt {
	pc = 0x82A02FA0; continue 'dispatch;
	}
	// 82A02FBC: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82A02FC0: 48427B41  bl 0x82e2ab00
	ctx.lr = 0x82A02FC4;
	sub_82E2AB00(ctx, base);
	// 82A02FC4: 382101D0  addi r1, r1, 0x1d0
	ctx.r[1].s64 = ctx.r[1].s64 + 464;
	// 82A02FC8: CBA1FF50  lfd f29, -0xb0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-176 as u32) ) };
	// 82A02FCC: CBC1FF58  lfd f30, -0xa8(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-168 as u32) ) };
	// 82A02FD0: CBE1FF60  lfd f31, -0xa0(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-160 as u32) ) };
	// 82A02FD4: 487A51AC  b 0x831a8180
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A02FD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A02FD8 size=924
    let mut pc: u32 = 0x82A02FD8;
    'dispatch: loop {
        match pc {
            0x82A02FD8 => {
    //   block [0x82A02FD8..0x82A03374)
	// 82A02FD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A02FDC: 487A5155  bl 0x831a8130
	ctx.lr = 0x82A02FE0;
	sub_831A8130(ctx, base);
	// 82A02FE0: DBE1FF60  stfd f31, -0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.f[31].u64 ) };
	// 82A02FE4: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A02FE8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82A02FEC: 897B01E0  lbz r11, 0x1e0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(480 as u32) ) } as u64;
	// 82A02FF0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A02FF4: 419800D4  blt cr6, 0x82a030c8
	if ctx.cr[6].lt {
	pc = 0x82A030C8; continue 'dispatch;
	}
	// 82A02FF8: 409A0370  bne cr6, 0x82a03368
	if !ctx.cr[6].eq {
	pc = 0x82A03368; continue 'dispatch;
	}
	// 82A02FFC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A03000: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A03004: 392B0013  addi r9, r11, 0x13
	ctx.r[9].s64 = ctx.r[11].s64 + 19;
	// 82A03008: 1D29000C  mulli r9, r9, 0xc
	ctx.r[9].s64 = ctx.r[9].s64 * 12;
	// 82A0300C: 7D29D8AE  lbzx r9, r9, r27
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 82A03010: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A03014: 41820018  beq 0x82a0302c
	if ctx.cr[0].eq {
	pc = 0x82A0302C; continue 'dispatch;
	}
	// 82A03018: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A0301C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A03020: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 82A03024: 4198FFE0  blt cr6, 0x82a03004
	if ctx.cr[6].lt {
	pc = 0x82A03004; continue 'dispatch;
	}
	// 82A03028: 48000008  b 0x82a03030
	pc = 0x82A03030; continue 'dispatch;
	// 82A0302C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A03030: 554B063F  clrlwi. r11, r10, 0x18
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A03034: 41820334  beq 0x82a03368
	if ctx.cr[0].eq {
	pc = 0x82A03368; continue 'dispatch;
	}
	// 82A03038: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82A0303C: 4BFFF765  bl 0x82a027a0
	ctx.lr = 0x82A03040;
	sub_82A027A0(ctx, base);
	// 82A03040: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A03044: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 82A03048: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0304C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A03050: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 82A03054: 419A0024  beq cr6, 0x82a03078
	if ctx.cr[6].eq {
	pc = 0x82A03078; continue 'dispatch;
	}
	// 82A03058: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A0305C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A03060: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A03064: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A03068: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A0306C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A03070: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A03074: 4082FFE8  bne 0x82a0305c
	if !ctx.cr[0].eq {
	pc = 0x82A0305C; continue 'dispatch;
	}
	// 82A03078: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A0307C: 80DB01E4  lwz r6, 0x1e4(r27)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(484 as u32) ) } as u64;
	// 82A03080: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A03084: 38E10088  addi r7, r1, 0x88
	ctx.r[7].s64 = ctx.r[1].s64 + 136;
	// 82A03088: 388A7B08  addi r4, r10, 0x7b08
	ctx.r[4].s64 = ctx.r[10].s64 + 31496;
	// 82A0308C: 38A0018C  li r5, 0x18c
	ctx.r[5].s64 = 396;
	// 82A03090: 387B0028  addi r3, r27, 0x28
	ctx.r[3].s64 = ctx.r[27].s64 + 40;
	// 82A03094: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A03098: 484559A9  bl 0x82e58a40
	ctx.lr = 0x82A0309C;
	sub_82E58A40(ctx, base);
	// 82A0309C: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82A030A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A030A4: 419A0008  beq cr6, 0x82a030ac
	if ctx.cr[6].eq {
	pc = 0x82A030AC; continue 'dispatch;
	}
	// 82A030A8: 4B8BD7E9  bl 0x822c0890
	ctx.lr = 0x82A030AC;
	sub_822C0890(ctx, base);
	// 82A030AC: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82A030B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A030B4: 419A0008  beq cr6, 0x82a030bc
	if ctx.cr[6].eq {
	pc = 0x82A030BC; continue 'dispatch;
	}
	// 82A030B8: 4B8BD7D9  bl 0x822c0890
	ctx.lr = 0x82A030BC;
	sub_822C0890(ctx, base);
	// 82A030BC: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82A030C0: 997B01E0  stb r11, 0x1e0(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(480 as u32), ctx.r[11].u8 ) };
	// 82A030C4: 480002A4  b 0x82a03368
	pc = 0x82A03368; continue 'dispatch;
	// 82A030C8: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 82A030CC: 8A7B0115  lbz r19, 0x115(r27)
	ctx.r[19].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(277 as u32) ) } as u64;
	// 82A030D0: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82A030D4: 99410075  stb r10, 0x75(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(117 as u32), ctx.r[10].u8 ) };
	// 82A030D8: 39400006  li r10, 6
	ctx.r[10].s64 = 6;
	// 82A030DC: 99610076  stb r11, 0x76(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[11].u8 ) };
	// 82A030E0: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82A030E4: 99410077  stb r10, 0x77(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(119 as u32), ctx.r[10].u8 ) };
	// 82A030E8: 3A800001  li r20, 1
	ctx.r[20].s64 = 1;
	// 82A030EC: 39200007  li r9, 7
	ctx.r[9].s64 = 7;
	// 82A030F0: 9B210074  stb r25, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[25].u8 ) };
	// 82A030F4: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82A030F8: 9A810079  stb r20, 0x79(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(121 as u32), ctx.r[20].u8 ) };
	// 82A030FC: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 82A03100: 99210078  stb r9, 0x78(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[9].u8 ) };
	// 82A03104: 9961007A  stb r11, 0x7a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(122 as u32), ctx.r[11].u8 ) };
	// 82A03108: 7F3ACB78  mr r26, r25
	ctx.r[26].u64 = ctx.r[25].u64;
	// 82A0310C: 9941007B  stb r10, 0x7b(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(123 as u32), ctx.r[10].u8 ) };
	// 82A03110: 28130000  cmplwi r19, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A03114: 41820250  beq 0x82a03364
	if ctx.cr[0].eq {
	pc = 0x82A03364; continue 'dispatch;
	}
	// 82A03118: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82A0311C: 9A810070  stb r20, 0x70(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[20].u8 ) };
	// 82A03120: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A03124: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82A03128: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 82A0312C: 3ADB0028  addi r22, r27, 0x28
	ctx.r[22].s64 = ctx.r[27].s64 + 40;
	// 82A03130: C3E808A4  lfs f31, 0x8a4(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A03134: 3B0BE690  addi r24, r11, -0x1970
	ctx.r[24].s64 = ctx.r[11].s64 + -6512;
	// 82A03138: 3AEADA80  addi r23, r10, -0x2580
	ctx.r[23].s64 = ctx.r[10].s64 + -9600;
	// 82A0313C: 3AA97B08  addi r21, r9, 0x7b08
	ctx.r[21].s64 = ctx.r[9].s64 + 31496;
	// 82A03140: 39790013  addi r11, r25, 0x13
	ctx.r[11].s64 = ctx.r[25].s64 + 19;
	// 82A03144: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A03148: 1D6B000C  mulli r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 * 12;
	// 82A0314C: 7D4BD9AE  stbx r10, r11, r27
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[27].u32), ctx.r[10].u8) };
	// 82A03150: 39410074  addi r10, r1, 0x74
	ctx.r[10].s64 = ctx.r[1].s64 + 116;
	// 82A03154: 39210078  addi r9, r1, 0x78
	ctx.r[9].s64 = ctx.r[1].s64 + 120;
	// 82A03158: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82A0315C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A03160: 38A00168  li r5, 0x168
	ctx.r[5].s64 = 360;
	// 82A03164: 7FF950AE  lbzx r31, r25, r10
	ctx.r[31].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82A03168: 38600220  li r3, 0x220
	ctx.r[3].s64 = 544;
	// 82A0316C: 7FD948AE  lbzx r30, r25, r9
	ctx.r[30].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82A03170: 7FABDA14  add r29, r11, r27
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82A03174: 9BE10071  stb r31, 0x71(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(113 as u32), ctx.r[31].u8 ) };
	// 82A03178: 483EF271  bl 0x82df23e8
	ctx.lr = 0x82A0317C;
	sub_82DF23E8(ctx, base);
	// 82A0317C: 7C7C1B79  or. r28, r3, r3
	ctx.r[28].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82A03180: 41820068  beq 0x82a031e8
	if ctx.cr[0].eq {
	pc = 0x82A031E8; continue 'dispatch;
	}
	// 82A03184: 7FCB0774  extsb r11, r30
	ctx.r[11].s64 = ctx.r[30].s8 as i64;
	// 82A03188: 8A5B0114  lbz r18, 0x114(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(276 as u32) ) } as u64;
	// 82A0318C: 7FEA0774  extsb r10, r31
	ctx.r[10].s64 = ctx.r[31].s8 as i64;
	// 82A03190: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A03194: 554A2036  slwi r10, r10, 4
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A03198: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 82A0319C: 7E2BBA14  add r17, r11, r23
	ctx.r[17].u64 = ctx.r[11].u64 + ctx.r[23].u64;
	// 82A031A0: 7E0BC214  add r16, r11, r24
	ctx.r[16].u64 = ctx.r[11].u64 + ctx.r[24].u64;
	// 82A031A4: 7DEABA14  add r15, r10, r23
	ctx.r[15].u64 = ctx.r[10].u64 + ctx.r[23].u64;
	// 82A031A8: 7DCAC214  add r14, r10, r24
	ctx.r[14].u64 = ctx.r[10].u64 + ctx.r[24].u64;
	// 82A031AC: 48605E0D  bl 0x83008fb8
	ctx.lr = 0x82A031B0;
	sub_83008FB8(ctx, base);
	// 82A031B0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A031B4: 92210054  stw r17, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[17].u32 ) };
	// 82A031B8: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82A031BC: 9A41005F  stb r18, 0x5f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(95 as u32), ctx.r[18].u8 ) };
	// 82A031C0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A031C4: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 82A031C8: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82A031CC: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82A031D0: 7DC87378  mr r8, r14
	ctx.r[8].u64 = ctx.r[14].u64;
	// 82A031D4: 7DE97B78  mr r9, r15
	ctx.r[9].u64 = ctx.r[15].u64;
	// 82A031D8: 7E0A8378  mr r10, r16
	ctx.r[10].u64 = ctx.r[16].u64;
	// 82A031DC: 48008355  bl 0x82a0b530
	ctx.lr = 0x82A031E0;
	sub_82A0B530(ctx, base);
	// 82A031E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A031E4: 48000008  b 0x82a031ec
	pc = 0x82A031EC; continue 'dispatch;
	// 82A031E8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A031EC: 93E10080  stw r31, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 82A031F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A031F4: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 82A031F8: 4BFFF109  bl 0x82a02300
	ctx.lr = 0x82A031FC;
	sub_82A02300(ctx, base);
	// 82A031FC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A03200: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A03204: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 82A03208: 4B8BCDF9  bl 0x822c0000
	ctx.lr = 0x82A0320C;
	sub_822C0000(ctx, base);
	// 82A0320C: 81610080  lwz r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82A03210: 3BFD0004  addi r31, r29, 4
	ctx.r[31].s64 = ctx.r[29].s64 + 4;
	// 82A03214: 38810084  addi r4, r1, 0x84
	ctx.r[4].s64 = ctx.r[1].s64 + 132;
	// 82A03218: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82A0321C: 917D0004  stw r11, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A03220: 4B8C1241  bl 0x822c4460
	ctx.lr = 0x82A03224;
	sub_822C4460(ctx, base);
	// 82A03224: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82A03228: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0322C: 419A0008  beq cr6, 0x82a03234
	if ctx.cr[6].eq {
	pc = 0x82A03234; continue 'dispatch;
	}
	// 82A03230: 4B8BD661  bl 0x822c0890
	ctx.lr = 0x82A03234;
	sub_822C0890(ctx, base);
	// 82A03234: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A03238: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0323C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A03240: 9161009C  stw r11, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	// 82A03244: 91410098  stw r10, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[10].u32 ) };
	// 82A03248: 419A0024  beq cr6, 0x82a0326c
	if ctx.cr[6].eq {
	pc = 0x82A0326C; continue 'dispatch;
	}
	// 82A0324C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A03250: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A03254: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A03258: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A0325C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A03260: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A03264: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A03268: 4082FFE8  bne 0x82a03250
	if !ctx.cr[0].eq {
	pc = 0x82A03250; continue 'dispatch;
	}
	// 82A0326C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A03270: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82A03274: 4BB0C255  bl 0x8250f4c8
	ctx.lr = 0x82A03278;
	sub_8250F4C8(ctx, base);
	// 82A03278: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0327C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A03280: 3BEBFFFC  addi r31, r11, -4
	ctx.r[31].s64 = ctx.r[11].s64 + -4;
	// 82A03284: 409A0008  bne cr6, 0x82a0328c
	if !ctx.cr[6].eq {
	pc = 0x82A0328C; continue 'dispatch;
	}
	// 82A03288: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A0328C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A03290: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82A03294: 3BC10098  addi r30, r1, 0x98
	ctx.r[30].s64 = ctx.r[1].s64 + 152;
	// 82A03298: 4BB0C281  bl 0x8250f518
	ctx.lr = 0x82A0329C;
	sub_8250F518(ctx, base);
	// 82A0329C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A032A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A032A4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A032A8: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82A032AC: 4BB0A25D  bl 0x8250d508
	ctx.lr = 0x82A032B0;
	sub_8250D508(ctx, base);
	// 82A032B0: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82A032B4: 483EE9DD  bl 0x82df1c90
	ctx.lr = 0x82A032B8;
	sub_82DF1C90(ctx, base);
	// 82A032B8: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82A032BC: 483EE9D5  bl 0x82df1c90
	ctx.lr = 0x82A032C0;
	sub_82DF1C90(ctx, base);
	// 82A032C0: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 82A032C4: 38810071  addi r4, r1, 0x71
	ctx.r[4].s64 = ctx.r[1].s64 + 113;
	// 82A032C8: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 82A032CC: 4BFFF76D  bl 0x82a02a38
	ctx.lr = 0x82A032D0;
	sub_82A02A38(ctx, base);
	// 82A032D0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A032D4: 91610090  stw r11, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 82A032D8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A032DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A032E0: 91610094  stw r11, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 82A032E4: 419A0024  beq cr6, 0x82a03308
	if ctx.cr[6].eq {
	pc = 0x82A03308; continue 'dispatch;
	}
	// 82A032E8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A032EC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A032F0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A032F4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A032F8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A032FC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A03300: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A03304: 4082FFE8  bne 0x82a032ec
	if !ctx.cr[0].eq {
	pc = 0x82A032EC; continue 'dispatch;
	}
	// 82A03308: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 82A0330C: 3BE10090  addi r31, r1, 0x90
	ctx.r[31].s64 = ctx.r[1].s64 + 144;
	// 82A03310: 48605CA9  bl 0x83008fb8
	ctx.lr = 0x82A03314;
	sub_83008FB8(ctx, base);
	// 82A03314: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A03318: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82A0331C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A03320: 38A00177  li r5, 0x177
	ctx.r[5].s64 = 375;
	// 82A03324: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 82A03328: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82A0332C: 48455715  bl 0x82e58a40
	ctx.lr = 0x82A03330;
	sub_82E58A40(ctx, base);
	// 82A03330: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82A03334: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A03338: 419A0008  beq cr6, 0x82a03340
	if ctx.cr[6].eq {
	pc = 0x82A03340; continue 'dispatch;
	}
	// 82A0333C: 4B8BD555  bl 0x822c0890
	ctx.lr = 0x82A03340;
	sub_822C0890(ctx, base);
	// 82A03340: 806100BC  lwz r3, 0xbc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82A03344: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A03348: 419A0008  beq cr6, 0x82a03350
	if ctx.cr[6].eq {
	pc = 0x82A03350; continue 'dispatch;
	}
	// 82A0334C: 4B8BD545  bl 0x822c0890
	ctx.lr = 0x82A03350;
	sub_822C0890(ctx, base);
	// 82A03350: 39790001  addi r11, r25, 1
	ctx.r[11].s64 = ctx.r[25].s64 + 1;
	// 82A03354: 557A063E  clrlwi r26, r11, 0x18
	ctx.r[26].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A03358: 7F59D378  mr r25, r26
	ctx.r[25].u64 = ctx.r[26].u64;
	// 82A0335C: 7F1A9840  cmplw cr6, r26, r19
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[19].u32, &mut ctx.xer);
	// 82A03360: 4198FDE0  blt cr6, 0x82a03140
	if ctx.cr[6].lt {
	pc = 0x82A03140; continue 'dispatch;
	}
	// 82A03364: 9A9B01E0  stb r20, 0x1e0(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(480 as u32), ctx.r[20].u8 ) };
	// 82A03368: 38210160  addi r1, r1, 0x160
	ctx.r[1].s64 = ctx.r[1].s64 + 352;
	// 82A0336C: CBE1FF60  lfd f31, -0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-160 as u32) ) };
	// 82A03370: 487A4E10  b 0x831a8180
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A03378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A03378 size=80
    let mut pc: u32 = 0x82A03378;
    'dispatch: loop {
        match pc {
            0x82A03378 => {
    //   block [0x82A03378..0x82A033C8)
	// 82A03378: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0337C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A03380: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A03384: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A03388: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0338C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A03390: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A03394: 4BB0D375  bl 0x82510708
	ctx.lr = 0x82A03398;
	sub_82510708(ctx, base);
	// 82A03398: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0339C: C03E0000  lfs f1, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A033A0: 4BFFEE41  bl 0x82a021e0
	ctx.lr = 0x82A033A4;
	sub_82A021E0(ctx, base);
	// 82A033A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A033A8: C03E0000  lfs f1, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A033AC: 4BFFFC2D  bl 0x82a02fd8
	ctx.lr = 0x82A033B0;
	sub_82A02FD8(ctx, base);
	// 82A033B0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A033B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A033B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A033BC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A033C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A033C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A033C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A033C8 size=48
    let mut pc: u32 = 0x82A033C8;
    'dispatch: loop {
        match pc {
            0x82A033C8 => {
    //   block [0x82A033C8..0x82A033F8)
	// 82A033C8: 89630124  lbz r11, 0x124(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(292 as u32) ) } as u64;
	// 82A033CC: C1A30108  lfs f13, 0x108(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(264 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A033D0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A033D4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A033D8: C00B9450  lfs f0, -0x6bb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A033DC: 41820020  beq 0x82a033fc
	if ctx.cr[0].eq {
		sub_82A033FC(ctx, base);
		return;
	}
	// 82A033E0: EDA1683A  fmadds f13, f1, f0, f13
	ctx.f[13].f64 = (((ctx.f[1].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82A033E4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A033E8: D1A30108  stfs f13, 0x108(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 82A033EC: C00A08A8  lfs f0, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A033F0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82A033F4: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A033F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A033F8 size=4
    let mut pc: u32 = 0x82A033F8;
    'dispatch: loop {
        match pc {
            0x82A033F8 => {
    //   block [0x82A033F8..0x82A033FC)
	// 82A033F8: 4800001C  b 0x82a03414
	sub_82A03414(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A033FC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A033FC size=24
    let mut pc: u32 = 0x82A033FC;
    'dispatch: loop {
        match pc {
            0x82A033FC => {
    //   block [0x82A033FC..0x82A03414)
	// 82A033FC: EDA1683C  fnmsubs f13, f1, f0, f13
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = -(((ctx.f[1].f64 * ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82A03400: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A03404: D1A30108  stfs f13, 0x108(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 82A03408: C00A08A4  lfs f0, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A0340C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82A03410: 4C980020  bgelr cr6
	if !ctx.cr[6].lt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A03414(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A03414 size=8
    let mut pc: u32 = 0x82A03414;
    'dispatch: loop {
        match pc {
            0x82A03414 => {
    //   block [0x82A03414..0x82A0341C)
	// 82A03414: D0030108  stfs f0, 0x108(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 82A03418: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A03420(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A03420 size=136
    let mut pc: u32 = 0x82A03420;
    'dispatch: loop {
        match pc {
            0x82A03420 => {
    //   block [0x82A03420..0x82A034A8)
	// 82A03420: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A03424: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A03428: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A0342C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A03430: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A03434: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A03438: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A0343C: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82A03440: 409A0020  bne cr6, 0x82a03460
	if !ctx.cr[6].eq {
	pc = 0x82A03460; continue 'dispatch;
	}
	// 82A03444: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A03448: 419A0048  beq cr6, 0x82a03490
	if ctx.cr[6].eq {
	pc = 0x82A03490; continue 'dispatch;
	}
	// 82A0344C: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 82A03450: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82A03454: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 82A03458: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 82A0345C: 48000034  b 0x82a03490
	pc = 0x82A03490; continue 'dispatch;
	// 82A03460: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 82A03464: 419A002C  beq cr6, 0x82a03490
	if ctx.cr[6].eq {
	pc = 0x82A03490; continue 'dispatch;
	}
	// 82A03468: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A0346C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A03470: 388BE850  addi r4, r11, -0x17b0
	ctx.r[4].s64 = ctx.r[11].s64 + -6064;
	// 82A03474: 487A4C85  bl 0x831a80f8
	ctx.lr = 0x82A03478;
	sub_831A80F8(ctx, base);
	// 82A03478: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A0347C: 4182000C  beq 0x82a03488
	if ctx.cr[0].eq {
	pc = 0x82A03488; continue 'dispatch;
	}
	// 82A03480: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82A03484: 4800000C  b 0x82a03490
	pc = 0x82A03490; continue 'dispatch;
	// 82A03488: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A0348C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A03490: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A03494: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A03498: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A0349C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A034A0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A034A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A034A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A034A8 size=204
    let mut pc: u32 = 0x82A034A8;
    'dispatch: loop {
        match pc {
            0x82A034A8 => {
    //   block [0x82A034A8..0x82A03574)
	// 82A034A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A034AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A034B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A034B4: DBC1FFE0  stfd f30, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[30].u64 ) };
	// 82A034B8: DBE1FFE8  stfd f31, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82A034BC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A034C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A034C4: FFC00890  fmr f30, f1
	ctx.f[30].f64 = ctx.f[1].f64;
	// 82A034C8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A034CC: 895F0124  lbz r10, 0x124(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(292 as u32) ) } as u64;
	// 82A034D0: C01F010C  lfs f0, 0x10c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A034D4: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A034D8: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A034DC: 41820024  beq 0x82a03500
	if ctx.cr[0].eq {
	pc = 0x82A03500; continue 'dispatch;
	}
	// 82A034E0: EDA0F02A  fadds f13, f0, f30
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64;
	// 82A034E4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A034E8: D1BF010C  stfs f13, 0x10c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 82A034EC: C00B08A8  lfs f0, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A034F0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82A034F4: 41980028  blt cr6, 0x82a0351c
	if ctx.cr[6].lt {
	pc = 0x82A0351C; continue 'dispatch;
	}
	// 82A034F8: D01F010C  stfs f0, 0x10c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 82A034FC: 48000020  b 0x82a0351c
	pc = 0x82A0351C; continue 'dispatch;
	// 82A03500: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82A03504: 40990018  ble cr6, 0x82a0351c
	if !ctx.cr[6].gt {
	pc = 0x82A0351C; continue 'dispatch;
	}
	// 82A03508: EC00F028  fsubs f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[30].f64) as f32) as f64);
	// 82A0350C: D01F010C  stfs f0, 0x10c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 82A03510: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82A03514: 41990008  bgt cr6, 0x82a0351c
	if ctx.cr[6].gt {
	pc = 0x82A0351C; continue 'dispatch;
	}
	// 82A03518: D3FF010C  stfs f31, 0x10c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 82A0351C: C03F010C  lfs f1, 0x10c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A03520: 807F0110  lwz r3, 0x110(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 82A03524: 4814349D  bl 0x82b469c0
	ctx.lr = 0x82A03528;
	sub_82B469C0(ctx, base);
	// 82A03528: C01F0120  lfs f0, 0x120(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A0352C: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82A03530: 40990028  ble cr6, 0x82a03558
	if !ctx.cr[6].gt {
	pc = 0x82A03558; continue 'dispatch;
	}
	// 82A03534: EC20F028  fsubs f1, f0, f30
	ctx.f[1].f64 = (((ctx.f[0].f64 - ctx.f[30].f64) as f32) as f64);
	// 82A03538: 807F0118  lwz r3, 0x118(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 82A0353C: D03F0120  stfs f1, 0x120(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), tmp.u32 ) };
	// 82A03540: FF01F800  fcmpu cr6, f1, f31
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 82A03544: 4099000C  ble cr6, 0x82a03550
	if !ctx.cr[6].gt {
	pc = 0x82A03550; continue 'dispatch;
	}
	// 82A03548: 48143479  bl 0x82b469c0
	ctx.lr = 0x82A0354C;
	sub_82B469C0(ctx, base);
	// 82A0354C: 4800000C  b 0x82a03558
	pc = 0x82A03558; continue 'dispatch;
	// 82A03550: D3FF0120  stfs f31, 0x120(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), tmp.u32 ) };
	// 82A03554: 48143175  bl 0x82b466c8
	ctx.lr = 0x82A03558;
	sub_82B466C8(ctx, base);
	// 82A03558: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A0355C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A03560: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A03564: CBC1FFE0  lfd f30, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82A03568: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A0356C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A03570: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A03578(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A03578 size=216
    let mut pc: u32 = 0x82A03578;
    'dispatch: loop {
        match pc {
            0x82A03578 => {
    //   block [0x82A03578..0x82A03650)
	// 82A03578: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0357C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A03580: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A03584: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A03588: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A0358C: 89440018  lbz r10, 0x18(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A03590: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82A03594: 893F0124  lbz r9, 0x124(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(292 as u32) ) } as u64;
	// 82A03598: 995F0124  stb r10, 0x124(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(292 as u32), ctx.r[10].u8 ) };
	// 82A0359C: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A035A0: 419A009C  beq cr6, 0x82a0363c
	if ctx.cr[6].eq {
	pc = 0x82A0363C; continue 'dispatch;
	}
	// 82A035A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A035A8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A035AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A035B0: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82A035B4: 419A005C  beq cr6, 0x82a03610
	if ctx.cr[6].eq {
	pc = 0x82A03610; continue 'dispatch;
	}
	// 82A035B8: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A035BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A035C0: 38AA7BB8  addi r5, r10, 0x7bb8
	ctx.r[5].s64 = ctx.r[10].s64 + 31672;
	// 82A035C4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A035C8: 4E800421  bctrl
	ctx.lr = 0x82A035CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A035CC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A035D0: 395F0118  addi r10, r31, 0x118
	ctx.r[10].s64 = ctx.r[31].s64 + 280;
	// 82A035D4: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82A035D8: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 82A035DC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A035E0: 917F0118  stw r11, 0x118(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), ctx.r[11].u32 ) };
	// 82A035E4: 4B8C0E7D  bl 0x822c4460
	ctx.lr = 0x82A035E8;
	sub_822C4460(ctx, base);
	// 82A035E8: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A035EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A035F0: 419A0008  beq cr6, 0x82a035f8
	if ctx.cr[6].eq {
	pc = 0x82A035F8; continue 'dispatch;
	}
	// 82A035F4: 4B8BD29D  bl 0x822c0890
	ctx.lr = 0x82A035F8;
	sub_822C0890(ctx, base);
	// 82A035F8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A035FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A03600: C00B08A8  lfs f0, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A03604: D01F0120  stfs f0, 0x120(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), tmp.u32 ) };
	// 82A03608: 4BB0E6A1  bl 0x82511ca8
	ctx.lr = 0x82A0360C;
	sub_82511CA8(ctx, base);
	// 82A0360C: 48000030  b 0x82a0363c
	pc = 0x82A0363C; continue 'dispatch;
	// 82A03610: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A03614: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A03618: 38AA7BA0  addi r5, r10, 0x7ba0
	ctx.r[5].s64 = ctx.r[10].s64 + 31648;
	// 82A0361C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A03620: 4E800421  bctrl
	ctx.lr = 0x82A03624;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A03624: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A03628: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0362C: 419A0008  beq cr6, 0x82a03634
	if ctx.cr[6].eq {
	pc = 0x82A03634; continue 'dispatch;
	}
	// 82A03630: 4B8BD261  bl 0x822c0890
	ctx.lr = 0x82A03634;
	sub_822C0890(ctx, base);
	// 82A03634: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A03638: 4BB0E651  bl 0x82511c88
	ctx.lr = 0x82A0363C;
	sub_82511C88(ctx, base);
	// 82A0363C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A03640: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A03644: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A03648: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A0364C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A03650(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A03650 size=72
    let mut pc: u32 = 0x82A03650;
    'dispatch: loop {
        match pc {
            0x82A03650 => {
    //   block [0x82A03650..0x82A03698)
	// 82A03650: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A03654: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A03658: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0365C: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 82A03660: 419A001C  beq cr6, 0x82a0367c
	if ctx.cr[6].eq {
	pc = 0x82A0367C; continue 'dispatch;
	}
	// 82A03664: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82A03668: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A0366C: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82A03670: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A03674: 4BFFFDAD  bl 0x82a03420
	ctx.lr = 0x82A03678;
	sub_82A03420(ctx, base);
	// 82A03678: 48000010  b 0x82a03688
	pc = 0x82A03688; continue 'dispatch;
	// 82A0367C: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A03680: 396BE850  addi r11, r11, -0x17b0
	ctx.r[11].s64 = ctx.r[11].s64 + -6064;
	// 82A03684: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A03688: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A0368C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A03690: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A03694: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A03698(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A03698 size=140
    let mut pc: u32 = 0x82A03698;
    'dispatch: loop {
        match pc {
            0x82A03698 => {
    //   block [0x82A03698..0x82A03724)
	// 82A03698: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0369C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A036A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A036A4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A036A8: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82A036AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A036B0: 38ABBA80  addi r5, r11, -0x4580
	ctx.r[5].s64 = ctx.r[11].s64 + -17792;
	// 82A036B4: 4BB0EBAD  bl 0x82512260
	ctx.lr = 0x82A036B8;
	sub_82512260(ctx, base);
	// 82A036B8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A036BC: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A036C0: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82A036C4: 390B7BEC  addi r8, r11, 0x7bec
	ctx.r[8].s64 = ctx.r[11].s64 + 31724;
	// 82A036C8: 394A7BD4  addi r10, r10, 0x7bd4
	ctx.r[10].s64 = ctx.r[10].s64 + 31700;
	// 82A036CC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A036D0: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82A036D4: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82A036D8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A036DC: 917F0100  stw r11, 0x100(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[11].u32 ) };
	// 82A036E0: C00908A8  lfs f0, 0x8a8(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A036E4: 917F0104  stw r11, 0x104(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[11].u32 ) };
	// 82A036E8: D01F0108  stfs f0, 0x108(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 82A036EC: D01F010C  stfs f0, 0x10c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 82A036F0: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 82A036F4: 917F0114  stw r11, 0x114(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), ctx.r[11].u32 ) };
	// 82A036F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A036FC: 917F0118  stw r11, 0x118(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), ctx.r[11].u32 ) };
	// 82A03700: C00A08A4  lfs f0, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A03704: 917F011C  stw r11, 0x11c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(284 as u32), ctx.r[11].u32 ) };
	// 82A03708: D01F0120  stfs f0, 0x120(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), tmp.u32 ) };
	// 82A0370C: 997F0124  stb r11, 0x124(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(292 as u32), ctx.r[11].u8 ) };
	// 82A03710: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A03714: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A03718: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A0371C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A03720: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A03728(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A03728 size=8
    let mut pc: u32 = 0x82A03728;
    'dispatch: loop {
        match pc {
            0x82A03728 => {
    //   block [0x82A03728..0x82A03730)
	// 82A03728: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 82A0372C: 48000174  b 0x82a038a0
	sub_82A038A0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A03730(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A03730 size=120
    let mut pc: u32 = 0x82A03730;
    'dispatch: loop {
        match pc {
            0x82A03730 => {
    //   block [0x82A03730..0x82A037A8)
	// 82A03730: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A03734: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A03738: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A0373C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A03740: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A03744: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A03748: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A0374C: 396B7BEC  addi r11, r11, 0x7bec
	ctx.r[11].s64 = ctx.r[11].s64 + 31724;
	// 82A03750: 394A7BD4  addi r10, r10, 0x7bd4
	ctx.r[10].s64 = ctx.r[10].s64 + 31700;
	// 82A03754: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A03758: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82A0375C: 807F011C  lwz r3, 0x11c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(284 as u32) ) } as u64;
	// 82A03760: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A03764: 419A0008  beq cr6, 0x82a0376c
	if ctx.cr[6].eq {
	pc = 0x82A0376C; continue 'dispatch;
	}
	// 82A03768: 4B8BD129  bl 0x822c0890
	ctx.lr = 0x82A0376C;
	sub_822C0890(ctx, base);
	// 82A0376C: 807F0114  lwz r3, 0x114(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 82A03770: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A03774: 419A0008  beq cr6, 0x82a0377c
	if ctx.cr[6].eq {
	pc = 0x82A0377C; continue 'dispatch;
	}
	// 82A03778: 4B8BD119  bl 0x822c0890
	ctx.lr = 0x82A0377C;
	sub_822C0890(ctx, base);
	// 82A0377C: 807F0104  lwz r3, 0x104(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) } as u64;
	// 82A03780: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A03784: 419A0008  beq cr6, 0x82a0378c
	if ctx.cr[6].eq {
	pc = 0x82A0378C; continue 'dispatch;
	}
	// 82A03788: 4B8BD109  bl 0x822c0890
	ctx.lr = 0x82A0378C;
	sub_822C0890(ctx, base);
	// 82A0378C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A03790: 4B94BBC1  bl 0x8234f350
	ctx.lr = 0x82A03794;
	sub_8234F350(ctx, base);
	// 82A03794: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A03798: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0379C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A037A0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A037A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A037A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A037A8 size=144
    let mut pc: u32 = 0x82A037A8;
    'dispatch: loop {
        match pc {
            0x82A037A8 => {
    //   block [0x82A037A8..0x82A03838)
	// 82A037A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A037AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A037B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A037B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A037B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A037BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A037C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A037C4: 4BB0718D  bl 0x8250a950
	ctx.lr = 0x82A037C8;
	sub_8250A950(ctx, base);
	// 82A037C8: 3BFF0100  addi r31, r31, 0x100
	ctx.r[31].s64 = ctx.r[31].s64 + 256;
	// 82A037CC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A037D0: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82A037D4: 419A0044  beq cr6, 0x82a03818
	if ctx.cr[6].eq {
	pc = 0x82A03818; continue 'dispatch;
	}
	// 82A037D8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A037DC: 4847DF65  bl 0x82e81740
	ctx.lr = 0x82A037E0;
	sub_82E81740(ctx, base);
	// 82A037E0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A037E4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A037E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A037EC: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 82A037F0: 409A0008  bne cr6, 0x82a037f8
	if !ctx.cr[6].eq {
	pc = 0x82A037F8; continue 'dispatch;
	}
	// 82A037F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A037F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A037FC: 4BDD0205  bl 0x827d3a00
	ctx.lr = 0x82A03800;
	sub_827D3A00(ctx, base);
	// 82A03800: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82A03804: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A03808: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0380C: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82A03810: 419A0008  beq cr6, 0x82a03818
	if ctx.cr[6].eq {
	pc = 0x82A03818; continue 'dispatch;
	}
	// 82A03814: 4B8BD07D  bl 0x822c0890
	ctx.lr = 0x82A03818;
	sub_822C0890(ctx, base);
	// 82A03818: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0381C: 483EE475  bl 0x82df1c90
	ctx.lr = 0x82A03820;
	sub_82DF1C90(ctx, base);
	// 82A03820: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A03824: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A03828: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A0382C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A03830: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A03834: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A03838(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A03838 size=16
    let mut pc: u32 = 0x82A03838;
    'dispatch: loop {
        match pc {
            0x82A03838 => {
    //   block [0x82A03838..0x82A03848)
	// 82A03838: 8124015C  lwz r9, 0x15c(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(348 as u32) ) } as u64;
	// 82A0383C: 39440158  addi r10, r4, 0x158
	ctx.r[10].s64 = ctx.r[4].s64 + 344;
	// 82A03840: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A03844: 4800004C  b 0x82a03890
	sub_82A03848(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A03848(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A03848 size=84
    let mut pc: u32 = 0x82A03848;
    'dispatch: loop {
        match pc {
            0x82A03848 => {
    //   block [0x82A03848..0x82A0389C)
	// 82A03848: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A0384C: C0030108  lfs f0, 0x108(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(264 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A03850: 81090080  lwz r8, 0x80(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(128 as u32) ) } as u64;
	// 82A03854: 9101FFE0  stw r8, -0x20(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[8].u32 ) };
	// 82A03858: 8901FFE0  lbz r8, -0x20(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) } as u64;
	// 82A0385C: F901FFE8  std r8, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[8].u64 ) };
	// 82A03860: C9A1FFE8  lfd f13, -0x18(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A03864: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82A03868: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82A0386C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A03870: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82A03874: D801FFF0  stfd f0, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[0].u64 ) };
	// 82A03878: 8901FFF7  lbz r8, -9(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(-9 as u32) ) } as u64;
	// 82A0387C: 9901FFE0  stb r8, -0x20(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[8].u8 ) };
	// 82A03880: 8101FFE0  lwz r8, -0x20(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) } as u64;
	// 82A03884: 91090080  stw r8, 0x80(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(128 as u32), ctx.r[8].u32 ) };
	// 82A03888: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0388C: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A03890: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A03894: 409AFFB4  bne cr6, 0x82a03848
	if !ctx.cr[6].eq {
	pc = 0x82A03848; continue 'dispatch;
	}
	// 82A03898: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A038A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A038A0 size=76
    let mut pc: u32 = 0x82A038A0;
    'dispatch: loop {
        match pc {
            0x82A038A0 => {
    //   block [0x82A038A0..0x82A038EC)
	// 82A038A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A038A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A038A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A038AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A038B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A038B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A038B8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A038BC: 4BFFFE75  bl 0x82a03730
	ctx.lr = 0x82A038C0;
	sub_82A03730(ctx, base);
	// 82A038C0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A038C4: 4182000C  beq 0x82a038d0
	if ctx.cr[0].eq {
	pc = 0x82A038D0; continue 'dispatch;
	}
	// 82A038C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A038CC: 483EEB0D  bl 0x82df23d8
	ctx.lr = 0x82A038D0;
	sub_82DF23D8(ctx, base);
	// 82A038D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A038D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A038D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A038DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A038E0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A038E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A038E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A038F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A038F0 size=1596
    let mut pc: u32 = 0x82A038F0;
    'dispatch: loop {
        match pc {
            0x82A038F0 => {
    //   block [0x82A038F0..0x82A03F2C)
	// 82A038F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A038F4: 487A4871  bl 0x831a8164
	ctx.lr = 0x82A038F8;
	sub_831A8130(ctx, base);
	// 82A038F8: DBA1FFB8  stfd f29, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[29].u64 ) };
	// 82A038FC: DBC1FFC0  stfd f30, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 82A03900: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82A03904: 3980FFA0  li r12, -0x60
	ctx.r[12].s64 = -96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A03F30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A03F30 size=200
    let mut pc: u32 = 0x82A03F30;
    'dispatch: loop {
        match pc {
            0x82A03F30 => {
    //   block [0x82A03F30..0x82A03FF8)
	// 82A03F30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A03F34: 487A4239  bl 0x831a816c
	ctx.lr = 0x82A03F38;
	sub_831A8130(ctx, base);
	// 82A03F38: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A03F3C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A03F40: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A03F44: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A03F48: 3BAB6910  addi r29, r11, 0x6910
	ctx.r[29].s64 = ctx.r[11].s64 + 26896;
	// 82A03F4C: 4BB0DB9D  bl 0x82511ae8
	ctx.lr = 0x82A03F50;
	sub_82511AE8(ctx, base);
	// 82A03F50: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82A03F54: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A03F58: 388B8614  addi r4, r11, -0x79ec
	ctx.r[4].s64 = ctx.r[11].s64 + -31212;
	// 82A03F5C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A03F60: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82A03F64: 4BE07F2D  bl 0x8280be90
	ctx.lr = 0x82A03F68;
	sub_8280BE90(ctx, base);
	// 82A03F68: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A03F6C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A03F70: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A03F74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A03F78: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A03F7C: 419A0024  beq cr6, 0x82a03fa0
	if ctx.cr[6].eq {
	pc = 0x82A03FA0; continue 'dispatch;
	}
	// 82A03F80: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A03F84: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A03F88: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A03F8C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A03F90: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A03F94: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A03F98: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A03F9C: 4082FFE8  bne 0x82a03f84
	if !ctx.cr[0].eq {
	pc = 0x82A03F84; continue 'dispatch;
	}
	// 82A03FA0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A03FA4: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 82A03FA8: 48604181  bl 0x83008128
	ctx.lr = 0x82A03FAC;
	sub_83008128(ctx, base);
	// 82A03FAC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A03FB0: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A03FB4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A03FB8: 388A7C58  addi r4, r10, 0x7c58
	ctx.r[4].s64 = ctx.r[10].s64 + 31832;
	// 82A03FBC: 38A00192  li r5, 0x192
	ctx.r[5].s64 = 402;
	// 82A03FC0: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82A03FC4: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A03FC8: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82A03FCC: 48454A75  bl 0x82e58a40
	ctx.lr = 0x82A03FD0;
	sub_82E58A40(ctx, base);
	// 82A03FD0: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A03FD4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A03FD8: 419A0008  beq cr6, 0x82a03fe0
	if ctx.cr[6].eq {
	pc = 0x82A03FE0; continue 'dispatch;
	}
	// 82A03FDC: 4B8BC8B5  bl 0x822c0890
	ctx.lr = 0x82A03FE0;
	sub_822C0890(ctx, base);
	// 82A03FE0: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A03FE4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A03FE8: 419A0008  beq cr6, 0x82a03ff0
	if ctx.cr[6].eq {
	pc = 0x82A03FF0; continue 'dispatch;
	}
	// 82A03FEC: 4B8BC8A5  bl 0x822c0890
	ctx.lr = 0x82A03FF0;
	sub_822C0890(ctx, base);
	// 82A03FF0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A03FF4: 487A41C8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A03FF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A03FF8 size=220
    let mut pc: u32 = 0x82A03FF8;
    'dispatch: loop {
        match pc {
            0x82A03FF8 => {
    //   block [0x82A03FF8..0x82A040D4)
	// 82A03FF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A03FFC: 487A416D  bl 0x831a8168
	ctx.lr = 0x82A04000;
	sub_831A8130(ctx, base);
	// 82A04000: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A04004: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82A04008: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A0400C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A04010: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82A04014: 41820038  beq 0x82a0404c
	if ctx.cr[0].eq {
	pc = 0x82A0404C; continue 'dispatch;
	}
	// 82A04018: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0401C: 487A596D  bl 0x831a9988
	ctx.lr = 0x82A04020;
	sub_831A9988(ctx, base);
	// 82A04020: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82A04024: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A04028: 386BC8E4  addi r3, r11, -0x371c
	ctx.r[3].s64 = ctx.r[11].s64 + -14108;
	// 82A0402C: 487A40CD  bl 0x831a80f8
	ctx.lr = 0x82A04030;
	sub_831A80F8(ctx, base);
	// 82A04030: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A04034: 41820018  beq 0x82a0404c
	if ctx.cr[0].eq {
	pc = 0x82A0404C; continue 'dispatch;
	}
	// 82A04038: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0403C: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A04040: 4BC66CB1  bl 0x8266acf0
	ctx.lr = 0x82A04044;
	sub_8266ACF0(ctx, base);
	// 82A04044: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A04048: 48000084  b 0x82a040cc
	pc = 0x82A040CC; continue 'dispatch;
	// 82A0404C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A04050: 419A006C  beq cr6, 0x82a040bc
	if ctx.cr[6].eq {
	pc = 0x82A040BC; continue 'dispatch;
	}
	// 82A04054: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A04058: 487A5931  bl 0x831a9988
	ctx.lr = 0x82A0405C;
	sub_831A9988(ctx, base);
	// 82A0405C: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A04060: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A04064: 386BE928  addi r3, r11, -0x16d8
	ctx.r[3].s64 = ctx.r[11].s64 + -5848;
	// 82A04068: 487A4091  bl 0x831a80f8
	ctx.lr = 0x82A0406C;
	sub_831A80F8(ctx, base);
	// 82A0406C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A04070: 41820014  beq 0x82a04084
	if ctx.cr[0].eq {
	pc = 0x82A04084; continue 'dispatch;
	}
	// 82A04074: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A04078: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A0407C: 4BFFF4FD  bl 0x82a03578
	ctx.lr = 0x82A04080;
	sub_82A03578(ctx, base);
	// 82A04080: 4BFFFFC4  b 0x82a04044
	pc = 0x82A04044; continue 'dispatch;
	// 82A04084: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A04088: 419A0034  beq cr6, 0x82a040bc
	if ctx.cr[6].eq {
	pc = 0x82A040BC; continue 'dispatch;
	}
	// 82A0408C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A04090: 487A58F9  bl 0x831a9988
	ctx.lr = 0x82A04094;
	sub_831A9988(ctx, base);
	// 82A04094: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 82A04098: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A0409C: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 82A040A0: 487A4059  bl 0x831a80f8
	ctx.lr = 0x82A040A4;
	sub_831A80F8(ctx, base);
	// 82A040A4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A040A8: 41820014  beq 0x82a040bc
	if ctx.cr[0].eq {
	pc = 0x82A040BC; continue 'dispatch;
	}
	// 82A040AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A040B0: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A040B4: 4BFFFE7D  bl 0x82a03f30
	ctx.lr = 0x82A040B8;
	sub_82A03F30(ctx, base);
	// 82A040B8: 4BFFFF8C  b 0x82a04044
	pc = 0x82A04044; continue 'dispatch;
	// 82A040BC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82A040C0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A040C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A040C8: 4BB0E551  bl 0x82512618
	ctx.lr = 0x82A040CC;
	sub_82512618(ctx, base);
	// 82A040CC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A040D0: 487A40E8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A040D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A040D8 size=84
    let mut pc: u32 = 0x82A040D8;
    'dispatch: loop {
        match pc {
            0x82A040D8 => {
    //   block [0x82A040D8..0x82A0412C)
	// 82A040D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A040DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A040E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A040E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A040E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A040EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A040F0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A040F4: 4BB0C615  bl 0x82510708
	ctx.lr = 0x82A040F8;
	sub_82510708(ctx, base);
	// 82A040F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A040FC: 4BFFF7F5  bl 0x82a038f0
	ctx.lr = 0x82A04100;
	sub_82A038F0(ctx, base);
	// 82A04100: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A04104: C03E0000  lfs f1, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A04108: 4BFFF2C1  bl 0x82a033c8
	ctx.lr = 0x82A0410C;
	sub_82A033C8(ctx, base);
	// 82A0410C: C03E0000  lfs f1, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A04110: 4BFFF399  bl 0x82a034a8
	ctx.lr = 0x82A04114;
	sub_82A034A8(ctx, base);
	// 82A04114: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A04118: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0411C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A04120: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A04124: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A04128: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A04130(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A04130 size=128
    let mut pc: u32 = 0x82A04130;
    'dispatch: loop {
        match pc {
            0x82A04130 => {
    //   block [0x82A04130..0x82A041B0)
	// 82A04130: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A04134: 487A4039  bl 0x831a816c
	ctx.lr = 0x82A04138;
	sub_831A8130(ctx, base);
	// 82A04138: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0413C: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82A04140: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A04144: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A04148: 3BEBDB00  addi r31, r11, -0x2500
	ctx.r[31].s64 = ctx.r[11].s64 + -9472;
	// 82A0414C: 816ADB08  lwz r11, -0x24f8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-9464 as u32) ) } as u64;
	// 82A04150: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82A04154: 40820024  bne 0x82a04178
	if !ctx.cr[0].eq {
	pc = 0x82A04178; continue 'dispatch;
	}
	// 82A04158: 3D208290  lis r9, -0x7d70
	ctx.r[9].s64 = -2104492032;
	// 82A0415C: 3D0082A0  lis r8, -0x7d60
	ctx.r[8].s64 = -2103443456;
	// 82A04160: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82A04164: 3929DD90  addi r9, r9, -0x2270
	ctx.r[9].s64 = ctx.r[9].s64 + -8816;
	// 82A04168: 39083650  addi r8, r8, 0x3650
	ctx.r[8].s64 = ctx.r[8].s64 + 13904;
	// 82A0416C: 916ADB08  stw r11, -0x24f8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-9464 as u32), ctx.r[11].u32 ) };
	// 82A04170: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A04174: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82A04178: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82A0417C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82A04180: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A04184: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 82A04188: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 82A0418C: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A04190: 4BC50431  bl 0x826545c0
	ctx.lr = 0x82A04194;
	sub_826545C0(ctx, base);
	// 82A04194: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A04198: 4182000C  beq 0x82a041a4
	if ctx.cr[0].eq {
	pc = 0x82A041A4; continue 'dispatch;
	}
	// 82A0419C: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A041A0: 48000008  b 0x82a041a8
	pc = 0x82A041A8; continue 'dispatch;
	// 82A041A4: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82A041A8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A041AC: 487A4010  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A041B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A041B0 size=1020
    let mut pc: u32 = 0x82A041B0;
    'dispatch: loop {
        match pc {
            0x82A041B0 => {
    //   block [0x82A041B0..0x82A045AC)
	// 82A041B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A041B4: 487A3FAD  bl 0x831a8160
	ctx.lr = 0x82A041B8;
	sub_831A8130(ctx, base);
	// 82A041B8: 9421FEC0  stwu r1, -0x140(r1)
	ea = ctx.r[1].u32.wrapping_add(-320 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A041BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A041C0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82A041C4: 4BB0D815  bl 0x825119d8
	ctx.lr = 0x82A041C8;
	sub_825119D8(ctx, base);
	// 82A041C8: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82A041CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A041D0: 4BB0B1A1  bl 0x8250f370
	ctx.lr = 0x82A041D4;
	sub_8250F370(ctx, base);
	// 82A041D4: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82A041D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A041DC: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 82A041E0: 483EF829  bl 0x82df3a08
	ctx.lr = 0x82A041E4;
	sub_82DF3A08(ctx, base);
	// 82A041E4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A041E8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A041EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A041F0: 4BB04591  bl 0x82508780
	ctx.lr = 0x82A041F4;
	sub_82508780(ctx, base);
	// 82A041F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A041F8: 483EF231  bl 0x82df3428
	ctx.lr = 0x82A041FC;
	sub_82DF3428(ctx, base);
	// 82A041FC: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82A04200: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A04204: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 82A04208: 409A0008  bne cr6, 0x82a04210
	if !ctx.cr[6].eq {
	pc = 0x82A04210; continue 'dispatch;
	}
	// 82A0420C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82A04210: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A04214: 4BB0458D  bl 0x825087a0
	ctx.lr = 0x82A04218;
	sub_825087A0(ctx, base);
	// 82A04218: 397F00F0  addi r11, r31, 0xf0
	ctx.r[11].s64 = ctx.r[31].s64 + 240;
	// 82A0421C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A04220: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A04224: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82A04228: 4B918FA9  bl 0x8231d1d0
	ctx.lr = 0x82A0422C;
	sub_8231D1D0(ctx, base);
	// 82A0422C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A04230: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82A04234: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A04238: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0423C: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82A04240: 419A0024  beq cr6, 0x82a04264
	if ctx.cr[6].eq {
	pc = 0x82A04264; continue 'dispatch;
	}
	// 82A04244: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A04248: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A0424C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A04250: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A04254: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A04258: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A0425C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A04260: 4082FFE8  bne 0x82a04248
	if !ctx.cr[0].eq {
	pc = 0x82A04248; continue 'dispatch;
	}
	// 82A04264: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A04268: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82A0426C: 4BB0B25D  bl 0x8250f4c8
	ctx.lr = 0x82A04270;
	sub_8250F4C8(ctx, base);
	// 82A04270: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A04274: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A04278: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A0427C: 409A0008  bne cr6, 0x82a04284
	if !ctx.cr[6].eq {
	pc = 0x82A04284; continue 'dispatch;
	}
	// 82A04280: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A04284: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A04288: 3BA10068  addi r29, r1, 0x68
	ctx.r[29].s64 = ctx.r[1].s64 + 104;
	// 82A0428C: 4BB0478D  bl 0x82508a18
	ctx.lr = 0x82A04290;
	sub_82508A18(ctx, base);
	// 82A04290: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A04294: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A04298: 388B7C58  addi r4, r11, 0x7c58
	ctx.r[4].s64 = ctx.r[11].s64 + 31832;
	// 82A0429C: 38A00061  li r5, 0x61
	ctx.r[5].s64 = 97;
	// 82A042A0: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82A042A4: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82A042A8: 48452D41  bl 0x82e56fe8
	ctx.lr = 0x82A042AC;
	sub_82E56FE8(ctx, base);
	// 82A042AC: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82A042B0: 483ED9E1  bl 0x82df1c90
	ctx.lr = 0x82A042B4;
	sub_82DF1C90(ctx, base);
	// 82A042B4: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A042B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A042BC: 419A0008  beq cr6, 0x82a042c4
	if ctx.cr[6].eq {
	pc = 0x82A042C4; continue 'dispatch;
	}
	// 82A042C0: 4B8BC5D1  bl 0x822c0890
	ctx.lr = 0x82A042C4;
	sub_822C0890(ctx, base);
	// 82A042C4: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82A042C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A042CC: 419A0008  beq cr6, 0x82a042d4
	if ctx.cr[6].eq {
	pc = 0x82A042D4; continue 'dispatch;
	}
	// 82A042D0: 4B8BC5C1  bl 0x822c0890
	ctx.lr = 0x82A042D4;
	sub_822C0890(ctx, base);
	// 82A042D4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A042D8: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A042DC: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 82A042E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A042E4: 38A97CBC  addi r5, r9, 0x7cbc
	ctx.r[5].s64 = ctx.r[9].s64 + 31932;
	// 82A042E8: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82A042EC: C00B08A8  lfs f0, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A042F0: 816A0038  lwz r11, 0x38(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(56 as u32) ) } as u64;
	// 82A042F4: D01F010C  stfs f0, 0x10c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 82A042F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A042FC: 4E800421  bctrl
	ctx.lr = 0x82A04300;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A04300: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A04304: 395F0110  addi r10, r31, 0x110
	ctx.r[10].s64 = ctx.r[31].s64 + 272;
	// 82A04308: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82A0430C: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 82A04310: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A04314: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 82A04318: 4B8C0149  bl 0x822c4460
	ctx.lr = 0x82A0431C;
	sub_822C4460(ctx, base);
	// 82A0431C: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82A04320: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A04324: 419A0008  beq cr6, 0x82a0432c
	if ctx.cr[6].eq {
	pc = 0x82A0432C; continue 'dispatch;
	}
	// 82A04328: 4B8BC569  bl 0x822c0890
	ctx.lr = 0x82A0432C;
	sub_822C0890(ctx, base);
	// 82A0432C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A04330: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A04334: 4BB0661D  bl 0x8250a950
	ctx.lr = 0x82A04338;
	sub_8250A950(ctx, base);
	// 82A04338: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0433C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A04340: 3BCBFF40  addi r30, r11, -0xc0
	ctx.r[30].s64 = ctx.r[11].s64 + -192;
	// 82A04344: 409A0008  bne cr6, 0x82a0434c
	if !ctx.cr[6].eq {
	pc = 0x82A0434C; continue 'dispatch;
	}
	// 82A04348: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 82A0434C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A04350: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A04354: 388B7CAC  addi r4, r11, 0x7cac
	ctx.r[4].s64 = ctx.r[11].s64 + 31916;
	// 82A04358: 483EF6B1  bl 0x82df3a08
	ctx.lr = 0x82A0435C;
	sub_82DF3A08(ctx, base);
	// 82A0435C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A04360: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A04364: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A04368: 4BB0DDB1  bl 0x82512118
	ctx.lr = 0x82A0436C;
	sub_82512118(ctx, base);
	// 82A0436C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A04370: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A04374: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A04378: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82A0437C: 38E0000B  li r7, 0xb
	ctx.r[7].s64 = 11;
	// 82A04380: 4BDD0931  bl 0x827d4cb0
	ctx.lr = 0x82A04384;
	sub_827D4CB0(ctx, base);
	// 82A04384: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A04388: 3BDF0100  addi r30, r31, 0x100
	ctx.r[30].s64 = ctx.r[31].s64 + 256;
	// 82A0438C: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82A04390: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 82A04394: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A04398: 917F0100  stw r11, 0x100(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[11].u32 ) };
	// 82A0439C: 4B8C00C5  bl 0x822c4460
	ctx.lr = 0x82A043A0;
	sub_822C4460(ctx, base);
	// 82A043A0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A043A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A043A8: 419A0008  beq cr6, 0x82a043b0
	if ctx.cr[6].eq {
	pc = 0x82A043B0; continue 'dispatch;
	}
	// 82A043AC: 4B8BC4E5  bl 0x822c0890
	ctx.lr = 0x82A043B0;
	sub_822C0890(ctx, base);
	// 82A043B0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A043B4: 483ED8DD  bl 0x82df1c90
	ctx.lr = 0x82A043B8;
	sub_82DF1C90(ctx, base);
	// 82A043B8: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82A043BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A043C0: 419A0008  beq cr6, 0x82a043c8
	if ctx.cr[6].eq {
	pc = 0x82A043C8; continue 'dispatch;
	}
	// 82A043C4: 4B8BC4CD  bl 0x822c0890
	ctx.lr = 0x82A043C8;
	sub_822C0890(ctx, base);
	// 82A043C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A043CC: 483EF05D  bl 0x82df3428
	ctx.lr = 0x82A043D0;
	sub_82DF3428(ctx, base);
	// 82A043D0: 897F0124  lbz r11, 0x124(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(292 as u32) ) } as u64;
	// 82A043D4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A043D8: 40820010  bne 0x82a043e8
	if !ctx.cr[0].eq {
	pc = 0x82A043E8; continue 'dispatch;
	}
	// 82A043DC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A043E0: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A043E4: D01F0108  stfs f0, 0x108(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 82A043E8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A043EC: 4847B005  bl 0x82e7f3f0
	ctx.lr = 0x82A043F0;
	sub_82E7F3F0(ctx, base);
	// 82A043F0: 83630004  lwz r27, 4(r3)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A043F4: 839B0000  lwz r28, 0(r27)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A043F8: 48000064  b 0x82a0445c
	pc = 0x82A0445C; continue 'dispatch;
	// 82A043FC: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A04400: 3BAB0108  addi r29, r11, 0x108
	ctx.r[29].s64 = ctx.r[11].s64 + 264;
	// 82A04404: 816B010C  lwz r11, 0x10c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(268 as u32) ) } as u64;
	// 82A04408: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0440C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A04410: 419A0048  beq cr6, 0x82a04458
	if ctx.cr[6].eq {
	pc = 0x82A04458; continue 'dispatch;
	}
	// 82A04414: 3D6082A0  lis r11, -0x7d60
	ctx.r[11].s64 = -2103443456;
	// 82A04418: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 82A0441C: 396B3838  addi r11, r11, 0x3838
	ctx.r[11].s64 = ctx.r[11].s64 + 14392;
	// 82A04420: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A04424: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82A04428: 93E100A8  stw r31, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[31].u32 ) };
	// 82A0442C: E8A100A8  ld r5, 0xa8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 82A04430: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A04434: 934100E0  stw r26, 0xe0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[26].u32 ) };
	// 82A04438: 4BFFFCF9  bl 0x82a04130
	ctx.lr = 0x82A0443C;
	sub_82A04130(ctx, base);
	// 82A0443C: 388100E0  addi r4, r1, 0xe0
	ctx.r[4].s64 = ctx.r[1].s64 + 224;
	// 82A04440: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A04444: 4BC85A05  bl 0x82689e48
	ctx.lr = 0x82A04448;
	sub_82689E48(ctx, base);
	// 82A04448: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0444C: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A04450: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A04454: 409AFFD0  bne cr6, 0x82a04424
	if !ctx.cr[6].eq {
	pc = 0x82A04424; continue 'dispatch;
	}
	// 82A04458: 839C0000  lwz r28, 0(r28)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0445C: 7F1CD840  cmplw cr6, r28, r27
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82A04460: 409AFF9C  bne cr6, 0x82a043fc
	if !ctx.cr[6].eq {
	pc = 0x82A043FC; continue 'dispatch;
	}
	// 82A04464: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A04468: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0446C: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82A04470: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 82A04474: 396BBC40  addi r11, r11, -0x43c0
	ctx.r[11].s64 = ctx.r[11].s64 + -17344;
	// 82A04478: 39296110  addi r9, r9, 0x6110
	ctx.r[9].s64 = ctx.r[9].s64 + 24848;
	// 82A0447C: 390100C0  addi r8, r1, 0xc0
	ctx.r[8].s64 = ctx.r[1].s64 + 192;
	// 82A04480: 38E100D0  addi r7, r1, 0xd0
	ctx.r[7].s64 = ctx.r[1].s64 + 208;
	// 82A04484: 38C00014  li r6, 0x14
	ctx.r[6].s64 = 20;
	// 82A04488: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A0448C: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 82A04490: 13C048C7  vcmpequd (lvx128) v30, v0, v9
	tmp.u32 = ctx.r[9].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A04494: 38800040  li r4, 0x40
	ctx.r[4].s64 = 64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A045B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A045B0 size=32
    let mut pc: u32 = 0x82A045B0;
    'dispatch: loop {
        match pc {
            0x82A045B0 => {
    //   block [0x82A045B0..0x82A045D0)
	// 82A045B0: 896301F0  lbz r11, 0x1f0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(496 as u32) ) } as u64;
	// 82A045B4: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82A045B8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A045BC: 81640018  lwz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A045C0: 41820008  beq 0x82a045c8
	if ctx.cr[0].eq {
	pc = 0x82A045C8; continue 'dispatch;
	}
	// 82A045C4: 3940000A  li r10, 0xa
	ctx.r[10].s64 = 10;
	// 82A045C8: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A045CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A045D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A045D0 size=60
    let mut pc: u32 = 0x82A045D0;
    'dispatch: loop {
        match pc {
            0x82A045D0 => {
    //   block [0x82A045D0..0x82A0460C)
	// 82A045D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A045D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A045D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A045DC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A045E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A045E4: 3864FF1C  addi r3, r4, -0xe4
	ctx.r[3].s64 = ctx.r[4].s64 + -228;
	// 82A045E8: 4BB0D501  bl 0x82511ae8
	ctx.lr = 0x82A045EC;
	sub_82511AE8(ctx, base);
	// 82A045EC: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A04610(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A04610 size=52
    let mut pc: u32 = 0x82A04610;
    'dispatch: loop {
        match pc {
            0x82A04610 => {
    //   block [0x82A04610..0x82A04644)
	// 82A04610: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A04614: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A04618: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A0461C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A04620: 80630288  lwz r3, 0x288(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(648 as u32) ) } as u64;
	// 82A04624: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A04628: 481BCFF1  bl 0x82bc1618
	ctx.lr = 0x82A0462C;
	sub_82BC1618(ctx, base);
	// 82A0462C: 987F0018  stb r3, 0x18(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[3].u8 ) };
	// 82A04630: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A04634: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A04638: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A0463C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A04640: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A04648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A04648 size=148
    let mut pc: u32 = 0x82A04648;
    'dispatch: loop {
        match pc {
            0x82A04648 => {
    //   block [0x82A04648..0x82A046DC)
	// 82A04648: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0464C: 487A3B21  bl 0x831a816c
	ctx.lr = 0x82A04650;
	sub_831A8130(ctx, base);
	// 82A04650: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82A04654: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A04658: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A0465C: 4874FFA5  bl 0x83154600
	ctx.lr = 0x82A04660;
	sub_83154600(ctx, base);
	// 82A04660: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A04664: 897F0200  lbz r11, 0x200(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(512 as u32) ) } as u64;
	// 82A04668: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A0466C: 4182004C  beq 0x82a046b8
	if ctx.cr[0].eq {
	pc = 0x82A046B8; continue 'dispatch;
	}
	// 82A04670: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A04674: 4BAE6415  bl 0x824eaa88
	ctx.lr = 0x82A04678;
	sub_824EAA88(ctx, base);
	// 82A04678: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A0467C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A04680: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A04684: 4BB0AD45  bl 0x8250f3c8
	ctx.lr = 0x82A04688;
	sub_8250F3C8(ctx, base);
	// 82A04688: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A0468C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A04690: 4BAE6981  bl 0x824eb010
	ctx.lr = 0x82A04694;
	sub_824EB010(ctx, base);
	// 82A04694: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A04698: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82A0469C: 483ED5F5  bl 0x82df1c90
	ctx.lr = 0x82A046A0;
	sub_82DF1C90(ctx, base);
	// 82A046A0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A046A4: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 82A046A8: C00B9450  lfs f0, -0x6bb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A046AC: C1AA2788  lfs f13, 0x2788(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(10120 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A046B0: EC1F683C  fnmsubs f0, f31, f0, f13
	ctx.f[0].f64 = -(((ctx.f[31].f64 * ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82A046B4: 4800000C  b 0x82a046c0
	pc = 0x82A046C0; continue 'dispatch;
	// 82A046B8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A046BC: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A046C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A046C4: D01E0060  stfs f0, 0x60(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A046C8: 997F01F0  stb r11, 0x1f0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(496 as u32), ctx.r[11].u8 ) };
	// 82A046CC: 997F01F1  stb r11, 0x1f1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(497 as u32), ctx.r[11].u8 ) };
	// 82A046D0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A046D4: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82A046D8: 487A3AE4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A046E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A046E0 size=76
    let mut pc: u32 = 0x82A046E0;
    'dispatch: loop {
        match pc {
            0x82A046E0 => {
    //   block [0x82A046E0..0x82A0472C)
	// 82A046E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A046E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A046E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A046EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A046F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A046F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A046F8: 4874FF09  bl 0x83154600
	ctx.lr = 0x82A046FC;
	sub_83154600(ctx, base);
	// 82A046FC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A04700: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A04704: 48455075  bl 0x82e59778
	ctx.lr = 0x82A04708;
	sub_82E59778(ctx, base);
	// 82A04708: C01E01F4  lfs f0, 0x1f4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(500 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A0470C: EC000828  fsubs f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 82A04710: D01E01F4  stfs f0, 0x1f4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(500 as u32), tmp.u32 ) };
	// 82A04714: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A04718: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0471C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A04720: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A04724: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A04728: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A04730(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A04730 size=244
    let mut pc: u32 = 0x82A04730;
    'dispatch: loop {
        match pc {
            0x82A04730 => {
    //   block [0x82A04730..0x82A04824)
	// 82A04730: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A04734: 487A3A39  bl 0x831a816c
	ctx.lr = 0x82A04738;
	sub_831A8130(ctx, base);
	// 82A04738: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0473C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A04740: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A04744: 897E01F0  lbz r11, 0x1f0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(496 as u32) ) } as u64;
	// 82A04748: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A0474C: 40820010  bne 0x82a0475c
	if !ctx.cr[0].eq {
	pc = 0x82A0475C; continue 'dispatch;
	}
	// 82A04750: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A04754: 917F0048  stw r11, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 82A04758: 480000C4  b 0x82a0481c
	pc = 0x82A0481C; continue 'dispatch;
	// 82A0475C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A04760: C1BE01F4  lfs f13, 0x1f4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(500 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A04764: C00B08A8  lfs f0, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A04768: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82A0476C: 4099FFE4  ble cr6, 0x82a04750
	if !ctx.cr[6].gt {
	pc = 0x82A04750; continue 'dispatch;
	}
	// 82A04770: 39600046  li r11, 0x46
	ctx.r[11].s64 = 70;
	// 82A04774: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A04778: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82A0477C: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 82A04780: 915F0048  stw r10, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[10].u32 ) };
	// 82A04784: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A04788: 93BF0020  stw r29, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[29].u32 ) };
	// 82A0478C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A04790: 4BB0EED9  bl 0x82513668
	ctx.lr = 0x82A04794;
	sub_82513668(ctx, base);
	// 82A04794: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A04828(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A04828 size=288
    let mut pc: u32 = 0x82A04828;
    'dispatch: loop {
        match pc {
            0x82A04828 => {
    //   block [0x82A04828..0x82A04948)
	// 82A04828: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0482C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A04830: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A04834: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A04838: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0483C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A04840: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A04844: 897E01F0  lbz r11, 0x1f0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(496 as u32) ) } as u64;
	// 82A04848: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A0484C: 40820010  bne 0x82a0485c
	if !ctx.cr[0].eq {
	pc = 0x82A0485C; continue 'dispatch;
	}
	// 82A04850: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A04854: 917F0060  stw r11, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A04858: 480000D8  b 0x82a04930
	pc = 0x82A04930; continue 'dispatch;
	// 82A0485C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A04860: C1BE01F4  lfs f13, 0x1f4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(500 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A04864: C00B08A8  lfs f0, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A04868: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82A0486C: 4099FFE4  ble cr6, 0x82a04850
	if !ctx.cr[6].gt {
	pc = 0x82A04850; continue 'dispatch;
	}
	// 82A04870: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 82A04874: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A04878: 917F0030  stw r11, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 82A0487C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A04880: 915F0060  stw r10, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 82A04884: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A04888: 4BB0EDE1  bl 0x82513668
	ctx.lr = 0x82A0488C;
	sub_82513668(ctx, base);
	// 82A0488C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A04948(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A04948 size=196
    let mut pc: u32 = 0x82A04948;
    'dispatch: loop {
        match pc {
            0x82A04948 => {
    //   block [0x82A04948..0x82A04A0C)
	// 82A04948: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0494C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A04950: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A04954: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A04958: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0495C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A04960: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A04964: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A04968: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A0496C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A04970: 4B8BBFC9  bl 0x822c0938
	ctx.lr = 0x82A04974;
	sub_822C0938(ctx, base);
	// 82A04974: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A04978: 41820028  beq 0x82a049a0
	if ctx.cr[0].eq {
	pc = 0x82A049A0; continue 'dispatch;
	}
	// 82A0497C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A04980: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A04984: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A04988: 392B7D00  addi r9, r11, 0x7d00
	ctx.r[9].s64 = ctx.r[11].s64 + 32000;
	// 82A0498C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A04990: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A04994: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A04998: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A0499C: 48000008  b 0x82a049a4
	pc = 0x82A049A4; continue 'dispatch;
	// 82A049A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A049A4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A049A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A049AC: 409A0044  bne cr6, 0x82a049f0
	if !ctx.cr[6].eq {
	pc = 0x82A049F0; continue 'dispatch;
	}
	// 82A049B0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A049B4: 419A001C  beq cr6, 0x82a049d0
	if ctx.cr[6].eq {
	pc = 0x82A049D0; continue 'dispatch;
	}
	// 82A049B8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A049BC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A049C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A049C4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A049C8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A049CC: 4E800421  bctrl
	ctx.lr = 0x82A049D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A049D0: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A049D4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A049D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A049DC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A049E0: 816BE954  lwz r11, -0x16ac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-5804 as u32) ) } as u64;
	// 82A049E4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A049E8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A049EC: 4B8BB615  bl 0x822c0000
	ctx.lr = 0x82A049F0;
	sub_822C0000(ctx, base);
	// 82A049F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A049F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A049F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A049FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A04A00: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A04A04: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A04A08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A04A10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A04A10 size=196
    let mut pc: u32 = 0x82A04A10;
    'dispatch: loop {
        match pc {
            0x82A04A10 => {
    //   block [0x82A04A10..0x82A04AD4)
	// 82A04A10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A04A14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A04A18: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A04A1C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A04A20: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A04A24: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A04A28: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A04A2C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A04A30: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A04A34: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A04A38: 4B8BBF01  bl 0x822c0938
	ctx.lr = 0x82A04A3C;
	sub_822C0938(ctx, base);
	// 82A04A3C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A04A40: 41820028  beq 0x82a04a68
	if ctx.cr[0].eq {
	pc = 0x82A04A68; continue 'dispatch;
	}
	// 82A04A44: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A04A48: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A04A4C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A04A50: 392B7D14  addi r9, r11, 0x7d14
	ctx.r[9].s64 = ctx.r[11].s64 + 32020;
	// 82A04A54: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A04A58: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A04A5C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A04A60: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A04A64: 48000008  b 0x82a04a6c
	pc = 0x82A04A6C; continue 'dispatch;
	// 82A04A68: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A04A6C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A04A70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A04A74: 409A0044  bne cr6, 0x82a04ab8
	if !ctx.cr[6].eq {
	pc = 0x82A04AB8; continue 'dispatch;
	}
	// 82A04A78: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A04A7C: 419A001C  beq cr6, 0x82a04a98
	if ctx.cr[6].eq {
	pc = 0x82A04A98; continue 'dispatch;
	}
	// 82A04A80: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A04A84: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A04A88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A04A8C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A04A90: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A04A94: 4E800421  bctrl
	ctx.lr = 0x82A04A98;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A04A98: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A04A9C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A04AA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A04AA4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A04AA8: 816BE954  lwz r11, -0x16ac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-5804 as u32) ) } as u64;
	// 82A04AAC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A04AB0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A04AB4: 4B8BB54D  bl 0x822c0000
	ctx.lr = 0x82A04AB8;
	sub_822C0000(ctx, base);
	// 82A04AB8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A04ABC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A04AC0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A04AC4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A04AC8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A04ACC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A04AD0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A04AD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A04AD8 size=196
    let mut pc: u32 = 0x82A04AD8;
    'dispatch: loop {
        match pc {
            0x82A04AD8 => {
    //   block [0x82A04AD8..0x82A04B9C)
	// 82A04AD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A04ADC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A04AE0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A04AE4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A04AE8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A04AEC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A04AF0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A04AF4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A04AF8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A04AFC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A04B00: 4B8BBE39  bl 0x822c0938
	ctx.lr = 0x82A04B04;
	sub_822C0938(ctx, base);
	// 82A04B04: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A04B08: 41820028  beq 0x82a04b30
	if ctx.cr[0].eq {
	pc = 0x82A04B30; continue 'dispatch;
	}
	// 82A04B0C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A04B10: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A04B14: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A04B18: 392B7D28  addi r9, r11, 0x7d28
	ctx.r[9].s64 = ctx.r[11].s64 + 32040;
	// 82A04B1C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A04B20: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A04B24: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A04B28: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A04B2C: 48000008  b 0x82a04b34
	pc = 0x82A04B34; continue 'dispatch;
	// 82A04B30: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A04B34: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A04B38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A04B3C: 409A0044  bne cr6, 0x82a04b80
	if !ctx.cr[6].eq {
	pc = 0x82A04B80; continue 'dispatch;
	}
	// 82A04B40: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A04B44: 419A001C  beq cr6, 0x82a04b60
	if ctx.cr[6].eq {
	pc = 0x82A04B60; continue 'dispatch;
	}
	// 82A04B48: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A04B4C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A04B50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A04B54: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A04B58: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A04B5C: 4E800421  bctrl
	ctx.lr = 0x82A04B60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A04B60: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A04B64: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A04B68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A04B6C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A04B70: 816BE954  lwz r11, -0x16ac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-5804 as u32) ) } as u64;
	// 82A04B74: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A04B78: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A04B7C: 4B8BB485  bl 0x822c0000
	ctx.lr = 0x82A04B80;
	sub_822C0000(ctx, base);
	// 82A04B80: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A04B84: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A04B88: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A04B8C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A04B90: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A04B94: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A04B98: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A04BA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A04BA0 size=196
    let mut pc: u32 = 0x82A04BA0;
    'dispatch: loop {
        match pc {
            0x82A04BA0 => {
    //   block [0x82A04BA0..0x82A04C64)
	// 82A04BA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A04BA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A04BA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A04BAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A04BB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A04BB4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A04BB8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A04BBC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A04BC0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A04BC4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A04BC8: 4B8BBD71  bl 0x822c0938
	ctx.lr = 0x82A04BCC;
	sub_822C0938(ctx, base);
	// 82A04BCC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A04BD0: 41820028  beq 0x82a04bf8
	if ctx.cr[0].eq {
	pc = 0x82A04BF8; continue 'dispatch;
	}
	// 82A04BD4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A04BD8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A04BDC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A04BE0: 392B7D3C  addi r9, r11, 0x7d3c
	ctx.r[9].s64 = ctx.r[11].s64 + 32060;
	// 82A04BE4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A04BE8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A04BEC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A04BF0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A04BF4: 48000008  b 0x82a04bfc
	pc = 0x82A04BFC; continue 'dispatch;
	// 82A04BF8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A04BFC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A04C00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A04C04: 409A0044  bne cr6, 0x82a04c48
	if !ctx.cr[6].eq {
	pc = 0x82A04C48; continue 'dispatch;
	}
	// 82A04C08: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A04C0C: 419A001C  beq cr6, 0x82a04c28
	if ctx.cr[6].eq {
	pc = 0x82A04C28; continue 'dispatch;
	}
	// 82A04C10: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A04C14: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A04C18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A04C1C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A04C20: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A04C24: 4E800421  bctrl
	ctx.lr = 0x82A04C28;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A04C28: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A04C2C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A04C30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A04C34: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A04C38: 816BE954  lwz r11, -0x16ac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-5804 as u32) ) } as u64;
	// 82A04C3C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A04C40: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A04C44: 4B8BB3BD  bl 0x822c0000
	ctx.lr = 0x82A04C48;
	sub_822C0000(ctx, base);
	// 82A04C48: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A04C4C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A04C50: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A04C54: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A04C58: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A04C5C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A04C60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A04C68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A04C68 size=196
    let mut pc: u32 = 0x82A04C68;
    'dispatch: loop {
        match pc {
            0x82A04C68 => {
    //   block [0x82A04C68..0x82A04D2C)
	// 82A04C68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A04C6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A04C70: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A04C74: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A04C78: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A04C7C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A04C80: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A04C84: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A04C88: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A04C8C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A04C90: 4B8BBCA9  bl 0x822c0938
	ctx.lr = 0x82A04C94;
	sub_822C0938(ctx, base);
	// 82A04C94: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A04C98: 41820028  beq 0x82a04cc0
	if ctx.cr[0].eq {
	pc = 0x82A04CC0; continue 'dispatch;
	}
	// 82A04C9C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A04CA0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A04CA4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A04CA8: 392B7D50  addi r9, r11, 0x7d50
	ctx.r[9].s64 = ctx.r[11].s64 + 32080;
	// 82A04CAC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A04CB0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A04CB4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A04CB8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A04CBC: 48000008  b 0x82a04cc4
	pc = 0x82A04CC4; continue 'dispatch;
	// 82A04CC0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A04CC4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A04CC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A04CCC: 409A0044  bne cr6, 0x82a04d10
	if !ctx.cr[6].eq {
	pc = 0x82A04D10; continue 'dispatch;
	}
	// 82A04CD0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A04CD4: 419A001C  beq cr6, 0x82a04cf0
	if ctx.cr[6].eq {
	pc = 0x82A04CF0; continue 'dispatch;
	}
	// 82A04CD8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A04CDC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A04CE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A04CE4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A04CE8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A04CEC: 4E800421  bctrl
	ctx.lr = 0x82A04CF0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A04CF0: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A04CF4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A04CF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A04CFC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A04D00: 816BE954  lwz r11, -0x16ac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-5804 as u32) ) } as u64;
	// 82A04D04: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A04D08: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A04D0C: 4B8BB2F5  bl 0x822c0000
	ctx.lr = 0x82A04D10;
	sub_822C0000(ctx, base);
	// 82A04D10: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A04D14: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A04D18: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A04D1C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A04D20: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A04D24: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A04D28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A04D30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A04D30 size=196
    let mut pc: u32 = 0x82A04D30;
    'dispatch: loop {
        match pc {
            0x82A04D30 => {
    //   block [0x82A04D30..0x82A04DF4)
	// 82A04D30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A04D34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A04D38: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A04D3C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A04D40: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A04D44: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A04D48: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A04D4C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A04D50: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A04D54: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A04D58: 4B8BBBE1  bl 0x822c0938
	ctx.lr = 0x82A04D5C;
	sub_822C0938(ctx, base);
	// 82A04D5C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A04D60: 41820028  beq 0x82a04d88
	if ctx.cr[0].eq {
	pc = 0x82A04D88; continue 'dispatch;
	}
	// 82A04D64: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A04D68: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A04D6C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A04D70: 392B7D64  addi r9, r11, 0x7d64
	ctx.r[9].s64 = ctx.r[11].s64 + 32100;
	// 82A04D74: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A04D78: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A04D7C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A04D80: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A04D84: 48000008  b 0x82a04d8c
	pc = 0x82A04D8C; continue 'dispatch;
	// 82A04D88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A04D8C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A04D90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A04D94: 409A0044  bne cr6, 0x82a04dd8
	if !ctx.cr[6].eq {
	pc = 0x82A04DD8; continue 'dispatch;
	}
	// 82A04D98: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A04D9C: 419A001C  beq cr6, 0x82a04db8
	if ctx.cr[6].eq {
	pc = 0x82A04DB8; continue 'dispatch;
	}
	// 82A04DA0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A04DA4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A04DA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A04DAC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A04DB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A04DB4: 4E800421  bctrl
	ctx.lr = 0x82A04DB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A04DB8: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A04DBC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A04DC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A04DC4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A04DC8: 816BE954  lwz r11, -0x16ac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-5804 as u32) ) } as u64;
	// 82A04DCC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A04DD0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A04DD4: 4B8BB22D  bl 0x822c0000
	ctx.lr = 0x82A04DD8;
	sub_822C0000(ctx, base);
	// 82A04DD8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A04DDC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A04DE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A04DE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A04DE8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A04DEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A04DF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A04DF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A04DF8 size=196
    let mut pc: u32 = 0x82A04DF8;
    'dispatch: loop {
        match pc {
            0x82A04DF8 => {
    //   block [0x82A04DF8..0x82A04EBC)
	// 82A04DF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A04DFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A04E00: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A04E04: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A04E08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A04E0C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A04E10: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A04E14: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A04E18: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A04E1C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A04E20: 4B8BBB19  bl 0x822c0938
	ctx.lr = 0x82A04E24;
	sub_822C0938(ctx, base);
	// 82A04E24: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A04E28: 41820028  beq 0x82a04e50
	if ctx.cr[0].eq {
	pc = 0x82A04E50; continue 'dispatch;
	}
	// 82A04E2C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A04E30: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A04E34: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A04E38: 392B7D78  addi r9, r11, 0x7d78
	ctx.r[9].s64 = ctx.r[11].s64 + 32120;
	// 82A04E3C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A04E40: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A04E44: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A04E48: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A04E4C: 48000008  b 0x82a04e54
	pc = 0x82A04E54; continue 'dispatch;
	// 82A04E50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A04E54: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A04E58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A04E5C: 409A0044  bne cr6, 0x82a04ea0
	if !ctx.cr[6].eq {
	pc = 0x82A04EA0; continue 'dispatch;
	}
	// 82A04E60: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A04E64: 419A001C  beq cr6, 0x82a04e80
	if ctx.cr[6].eq {
	pc = 0x82A04E80; continue 'dispatch;
	}
	// 82A04E68: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A04E6C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A04E70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A04E74: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A04E78: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A04E7C: 4E800421  bctrl
	ctx.lr = 0x82A04E80;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A04E80: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A04E84: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A04E88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A04E8C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A04E90: 816BE954  lwz r11, -0x16ac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-5804 as u32) ) } as u64;
	// 82A04E94: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A04E98: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A04E9C: 4B8BB165  bl 0x822c0000
	ctx.lr = 0x82A04EA0;
	sub_822C0000(ctx, base);
	// 82A04EA0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A04EA4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A04EA8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A04EAC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A04EB0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A04EB4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A04EB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A04EC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A04EC0 size=196
    let mut pc: u32 = 0x82A04EC0;
    'dispatch: loop {
        match pc {
            0x82A04EC0 => {
    //   block [0x82A04EC0..0x82A04F84)
	// 82A04EC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A04EC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A04EC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A04ECC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A04ED0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A04ED4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A04ED8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A04EDC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A04EE0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A04EE4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A04EE8: 4B8BBA51  bl 0x822c0938
	ctx.lr = 0x82A04EEC;
	sub_822C0938(ctx, base);
	// 82A04EEC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A04EF0: 41820028  beq 0x82a04f18
	if ctx.cr[0].eq {
	pc = 0x82A04F18; continue 'dispatch;
	}
	// 82A04EF4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A04EF8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A04EFC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A04F00: 392B7D8C  addi r9, r11, 0x7d8c
	ctx.r[9].s64 = ctx.r[11].s64 + 32140;
	// 82A04F04: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A04F08: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A04F0C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A04F10: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A04F14: 48000008  b 0x82a04f1c
	pc = 0x82A04F1C; continue 'dispatch;
	// 82A04F18: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A04F1C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A04F20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A04F24: 409A0044  bne cr6, 0x82a04f68
	if !ctx.cr[6].eq {
	pc = 0x82A04F68; continue 'dispatch;
	}
	// 82A04F28: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A04F2C: 419A001C  beq cr6, 0x82a04f48
	if ctx.cr[6].eq {
	pc = 0x82A04F48; continue 'dispatch;
	}
	// 82A04F30: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A04F34: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A04F38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A04F3C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A04F40: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A04F44: 4E800421  bctrl
	ctx.lr = 0x82A04F48;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A04F48: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A04F4C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A04F50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A04F54: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A04F58: 816BE954  lwz r11, -0x16ac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-5804 as u32) ) } as u64;
	// 82A04F5C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A04F60: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A04F64: 4B8BB09D  bl 0x822c0000
	ctx.lr = 0x82A04F68;
	sub_822C0000(ctx, base);
	// 82A04F68: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A04F6C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A04F70: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A04F74: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A04F78: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A04F7C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A04F80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A04F88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A04F88 size=196
    let mut pc: u32 = 0x82A04F88;
    'dispatch: loop {
        match pc {
            0x82A04F88 => {
    //   block [0x82A04F88..0x82A0504C)
	// 82A04F88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A04F8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A04F90: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A04F94: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A04F98: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A04F9C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A04FA0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A04FA4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A04FA8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A04FAC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A04FB0: 4B8BB989  bl 0x822c0938
	ctx.lr = 0x82A04FB4;
	sub_822C0938(ctx, base);
	// 82A04FB4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A04FB8: 41820028  beq 0x82a04fe0
	if ctx.cr[0].eq {
	pc = 0x82A04FE0; continue 'dispatch;
	}
	// 82A04FBC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A04FC0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A04FC4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A04FC8: 392B7DA0  addi r9, r11, 0x7da0
	ctx.r[9].s64 = ctx.r[11].s64 + 32160;
	// 82A04FCC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A04FD0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A04FD4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A04FD8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A04FDC: 48000008  b 0x82a04fe4
	pc = 0x82A04FE4; continue 'dispatch;
	// 82A04FE0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A04FE4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A04FE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A04FEC: 409A0044  bne cr6, 0x82a05030
	if !ctx.cr[6].eq {
	pc = 0x82A05030; continue 'dispatch;
	}
	// 82A04FF0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A04FF4: 419A001C  beq cr6, 0x82a05010
	if ctx.cr[6].eq {
	pc = 0x82A05010; continue 'dispatch;
	}
	// 82A04FF8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A04FFC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A05000: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A05004: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A05008: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A0500C: 4E800421  bctrl
	ctx.lr = 0x82A05010;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A05010: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A05014: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A05018: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0501C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A05020: 816BE954  lwz r11, -0x16ac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-5804 as u32) ) } as u64;
	// 82A05024: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A05028: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A0502C: 4B8BAFD5  bl 0x822c0000
	ctx.lr = 0x82A05030;
	sub_822C0000(ctx, base);
	// 82A05030: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A05034: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A05038: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0503C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A05040: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A05044: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A05048: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A05050(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A05050 size=224
    let mut pc: u32 = 0x82A05050;
    'dispatch: loop {
        match pc {
            0x82A05050 => {
    //   block [0x82A05050..0x82A05130)
	// 82A05050: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A05054: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A05058: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A0505C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A05060: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82A05064: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A05068: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A0506C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A05070: 4BB0B699  bl 0x82510708
	ctx.lr = 0x82A05074;
	sub_82510708(ctx, base);
	// 82A05074: C1BE0000  lfs f13, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A05078: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A0507C: C19F00F4  lfs f12, 0xf4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A05080: EDAD602A  fadds f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 82A05084: D1BF00F4  stfs f13, 0xf4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 82A05088: C00BD5B8  lfs f0, -0x2a48(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10824 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A0508C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82A05090: 40990008  ble cr6, 0x82a05098
	if !ctx.cr[6].gt {
	pc = 0x82A05098; continue 'dispatch;
	}
	// 82A05094: D01F00F4  stfs f0, 0xf4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 82A05098: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82A0509C: C1BF00F4  lfs f13, 0xf4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A050A0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A050A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A050A8: C00BE830  lfs f0, -0x17d0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A050AC: EFED0032  fmuls f31, f13, f0
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A050B0: 4BB0CCE9  bl 0x82511d98
	ctx.lr = 0x82A050B4;
	sub_82511D98(ctx, base);
	// 82A050B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A050B8: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82A050BC: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82A050C0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A050C4: 48476AC5  bl 0x82e7bb88
	ctx.lr = 0x82A050C8;
	sub_82E7BB88(ctx, base);
	// 82A050C8: 809F00EC  lwz r4, 0xec(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82A050CC: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 82A050D0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82A050D4: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 82A050D8: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
	// 82A050DC: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82A050E0: 80640084  lwz r3, 0x84(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(132 as u32) ) } as u64;
	// 82A050E4: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82A050E8: 13E85C07  vcmpneb. (lvlx128) v31, v8, v11
	tmp.u32 = ctx.r[8].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A050EC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A050F0: 39630010  addi r11, r3, 0x10
	ctx.r[11].s64 = ctx.r[3].s64 + 16;
	// 82A050F4: 13C93C07  vcmpneb. (lvlx128) v30, v9, v7
	tmp.u32 = ctx.r[9].u32 + ctx.r[7].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A050F8: 13AA3407  vcmpneb. (lvlx128) v29, v10, v6
	tmp.u32 = ctx.r[10].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A050FC: 13802C07  vcmpneb. (lvlx128) v28, v0, v5
	tmp.u32 = ctx.r[5].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A05130(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A05130 size=232
    let mut pc: u32 = 0x82A05130;
    'dispatch: loop {
        match pc {
            0x82A05130 => {
    //   block [0x82A05130..0x82A05218)
	// 82A05130: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A05134: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A05138: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A0513C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A05140: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A05144: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A05148: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A0514C: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 82A05150: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 82A05154: 396B7E78  addi r11, r11, 0x7e78
	ctx.r[11].s64 = ctx.r[11].s64 + 32376;
	// 82A05158: 815F02A8  lwz r10, 0x2a8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(680 as u32) ) } as u64;
	// 82A0515C: 39297E64  addi r9, r9, 0x7e64
	ctx.r[9].s64 = ctx.r[9].s64 + 32356;
	// 82A05160: 39087E54  addi r8, r8, 0x7e54
	ctx.r[8].s64 = ctx.r[8].s64 + 32340;
	// 82A05164: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A05168: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 82A0516C: 3BDF0160  addi r30, r31, 0x160
	ctx.r[30].s64 = ctx.r[31].s64 + 352;
	// 82A05170: 911F0160  stw r8, 0x160(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), ctx.r[8].u32 ) };
	// 82A05174: 896A0000  lbz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A05178: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A0517C: 996A0000  stb r11, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 82A05180: 807F02AC  lwz r3, 0x2ac(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(684 as u32) ) } as u64;
	// 82A05184: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A05188: 419A0008  beq cr6, 0x82a05190
	if ctx.cr[6].eq {
	pc = 0x82A05190; continue 'dispatch;
	}
	// 82A0518C: 4B8BB705  bl 0x822c0890
	ctx.lr = 0x82A05190;
	sub_822C0890(ctx, base);
	// 82A05190: 807F02A4  lwz r3, 0x2a4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(676 as u32) ) } as u64;
	// 82A05194: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A05198: 419A0008  beq cr6, 0x82a051a0
	if ctx.cr[6].eq {
	pc = 0x82A051A0; continue 'dispatch;
	}
	// 82A0519C: 4B8BB6F5  bl 0x822c0890
	ctx.lr = 0x82A051A0;
	sub_822C0890(ctx, base);
	// 82A051A0: 807F029C  lwz r3, 0x29c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(668 as u32) ) } as u64;
	// 82A051A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A051A8: 419A0008  beq cr6, 0x82a051b0
	if ctx.cr[6].eq {
	pc = 0x82A051B0; continue 'dispatch;
	}
	// 82A051AC: 4B8BB6E5  bl 0x822c0890
	ctx.lr = 0x82A051B0;
	sub_822C0890(ctx, base);
	// 82A051B0: 807F0294  lwz r3, 0x294(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(660 as u32) ) } as u64;
	// 82A051B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A051B8: 419A0008  beq cr6, 0x82a051c0
	if ctx.cr[6].eq {
	pc = 0x82A051C0; continue 'dispatch;
	}
	// 82A051BC: 4B8BB6D5  bl 0x822c0890
	ctx.lr = 0x82A051C0;
	sub_822C0890(ctx, base);
	// 82A051C0: 807F028C  lwz r3, 0x28c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(652 as u32) ) } as u64;
	// 82A051C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A051C8: 419A0008  beq cr6, 0x82a051d0
	if ctx.cr[6].eq {
	pc = 0x82A051D0; continue 'dispatch;
	}
	// 82A051CC: 4B8BB6C5  bl 0x822c0890
	ctx.lr = 0x82A051D0;
	sub_822C0890(ctx, base);
	// 82A051D0: 807F0264  lwz r3, 0x264(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(612 as u32) ) } as u64;
	// 82A051D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A051D8: 419A0008  beq cr6, 0x82a051e0
	if ctx.cr[6].eq {
	pc = 0x82A051E0; continue 'dispatch;
	}
	// 82A051DC: 4B8BB6B5  bl 0x822c0890
	ctx.lr = 0x82A051E0;
	sub_822C0890(ctx, base);
	// 82A051E0: 807F01FC  lwz r3, 0x1fc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) } as u64;
	// 82A051E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A051E8: 419A0008  beq cr6, 0x82a051f0
	if ctx.cr[6].eq {
	pc = 0x82A051F0; continue 'dispatch;
	}
	// 82A051EC: 4B8BB6A5  bl 0x822c0890
	ctx.lr = 0x82A051F0;
	sub_822C0890(ctx, base);
	// 82A051F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A051F4: 48458655  bl 0x82e5d848
	ctx.lr = 0x82A051F8;
	sub_82E5D848(ctx, base);
	// 82A051F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A051FC: 4BB0E4CD  bl 0x825136c8
	ctx.lr = 0x82A05200;
	sub_825136C8(ctx, base);
	// 82A05200: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A05204: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A05208: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A0520C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A05210: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A05214: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A05218(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A05218 size=8
    let mut pc: u32 = 0x82A05218;
    'dispatch: loop {
        match pc {
            0x82A05218 => {
    //   block [0x82A05218..0x82A05220)
	// 82A05218: 3863FEA0  addi r3, r3, -0x160
	ctx.r[3].s64 = ctx.r[3].s64 + -352;
	// 82A0521C: 480007DC  b 0x82a059f8
	sub_82A059F8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A05220(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A05220 size=8
    let mut pc: u32 = 0x82A05220;
    'dispatch: loop {
        match pc {
            0x82A05220 => {
    //   block [0x82A05220..0x82A05228)
	// 82A05220: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 82A05224: 480007D4  b 0x82a059f8
	sub_82A059F8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A05228(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A05228 size=548
    let mut pc: u32 = 0x82A05228;
    'dispatch: loop {
        match pc {
            0x82A05228 => {
    //   block [0x82A05228..0x82A0544C)
	// 82A05228: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0522C: 487A2F3D  bl 0x831a8168
	ctx.lr = 0x82A05230;
	sub_831A8130(ctx, base);
	// 82A05230: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A05234: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A05238: 4874F3C9  bl 0x83154600
	ctx.lr = 0x82A0523C;
	sub_83154600(ctx, base);
	// 82A0523C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A05240: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A05244: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A05248: 4BDB1391  bl 0x827b65d8
	ctx.lr = 0x82A0524C;
	sub_827B65D8(ctx, base);
	// 82A0524C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A05250: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A05254: 838B0008  lwz r28, 8(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A05258: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82A0525C: 419A000C  beq cr6, 0x82a05268
	if ctx.cr[6].eq {
	pc = 0x82A05268; continue 'dispatch;
	}
	// 82A05260: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A05264: 484C959D  bl 0x82ece800
	ctx.lr = 0x82A05268;
	sub_82ECE800(ctx, base);
	// 82A05268: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A0526C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A05270: 419A0008  beq cr6, 0x82a05278
	if ctx.cr[6].eq {
	pc = 0x82A05278; continue 'dispatch;
	}
	// 82A05274: 4B8BB61D  bl 0x822c0890
	ctx.lr = 0x82A05278;
	sub_822C0890(ctx, base);
	// 82A05278: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0527C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A05280: 4BDB1359  bl 0x827b65d8
	ctx.lr = 0x82A05284;
	sub_827B65D8(ctx, base);
	// 82A05284: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A05288: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A0528C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82A05290: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 82A05294: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A05298: 484C68F9  bl 0x82ecbb90
	ctx.lr = 0x82A0529C;
	sub_82ECBB90(ctx, base);
	// 82A0529C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A052A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A052A4: 419A0008  beq cr6, 0x82a052ac
	if ctx.cr[6].eq {
	pc = 0x82A052AC; continue 'dispatch;
	}
	// 82A052A8: 4B8BB5E9  bl 0x822c0890
	ctx.lr = 0x82A052AC;
	sub_822C0890(ctx, base);
	// 82A052AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A052B0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A052B4: 4BDB1325  bl 0x827b65d8
	ctx.lr = 0x82A052B8;
	sub_827B65D8(ctx, base);
	// 82A052B8: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A052BC: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A052C0: 3BCB7060  addi r30, r11, 0x7060
	ctx.r[30].s64 = ctx.r[11].s64 + 28768;
	// 82A052C4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A052C8: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A052CC: 4B8E44F5  bl 0x822e97c0
	ctx.lr = 0x82A052D0;
	sub_822E97C0(ctx, base);
	// 82A052D0: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A052D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A052D8: 419A0008  beq cr6, 0x82a052e0
	if ctx.cr[6].eq {
	pc = 0x82A052E0; continue 'dispatch;
	}
	// 82A052DC: 4B8BB5B5  bl 0x822c0890
	ctx.lr = 0x82A052E0;
	sub_822C0890(ctx, base);
	// 82A052E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A052E4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A052E8: 4BDB12F1  bl 0x827b65d8
	ctx.lr = 0x82A052EC;
	sub_827B65D8(ctx, base);
	// 82A052EC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A052F0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A052F4: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A052F8: 4B8E7C01  bl 0x822ecef8
	ctx.lr = 0x82A052FC;
	sub_822ECEF8(ctx, base);
	// 82A052FC: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A05300: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A05304: 419A0008  beq cr6, 0x82a0530c
	if ctx.cr[6].eq {
	pc = 0x82A0530C; continue 'dispatch;
	}
	// 82A05308: 4B8BB589  bl 0x822c0890
	ctx.lr = 0x82A0530C;
	sub_822C0890(ctx, base);
	// 82A0530C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A05310: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A05314: 4BDB12C5  bl 0x827b65d8
	ctx.lr = 0x82A05318;
	sub_827B65D8(ctx, base);
	// 82A05318: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0531C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A05320: 386B00D0  addi r3, r11, 0xd0
	ctx.r[3].s64 = ctx.r[11].s64 + 208;
	// 82A05324: 484D5255  bl 0x82eda578
	ctx.lr = 0x82A05328;
	sub_82EDA578(ctx, base);
	// 82A05328: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A0532C: D03D006C  stfs f1, 0x6c(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82A05330: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A05334: 419A0008  beq cr6, 0x82a0533c
	if ctx.cr[6].eq {
	pc = 0x82A0533C; continue 'dispatch;
	}
	// 82A05338: 4B8BB559  bl 0x822c0890
	ctx.lr = 0x82A0533C;
	sub_822C0890(ctx, base);
	// 82A0533C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82A05340: 419A000C  beq cr6, 0x82a0534c
	if ctx.cr[6].eq {
	pc = 0x82A0534C; continue 'dispatch;
	}
	// 82A05344: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A05348: 484C7CC1  bl 0x82ecd008
	ctx.lr = 0x82A0534C;
	sub_82ECD008(ctx, base);
	// 82A0534C: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82A05350: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A05354: 4BB0E225  bl 0x82513578
	ctx.lr = 0x82A05358;
	sub_82513578(ctx, base);
	// 82A05358: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A05450(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A05450 size=204
    let mut pc: u32 = 0x82A05450;
    'dispatch: loop {
        match pc {
            0x82A05450 => {
    //   block [0x82A05450..0x82A0551C)
	// 82A05450: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A05454: 487A2D19  bl 0x831a816c
	ctx.lr = 0x82A05458;
	sub_831A8130(ctx, base);
	// 82A05458: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0545C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A05460: 4874F1A1  bl 0x83154600
	ctx.lr = 0x82A05464;
	sub_83154600(ctx, base);
	// 82A05464: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A05468: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0546C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A05470: 4BDB1169  bl 0x827b65d8
	ctx.lr = 0x82A05474;
	sub_827B65D8(ctx, base);
	// 82A05474: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A05478: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0547C: 83AB0008  lwz r29, 8(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A05480: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A05484: 419A000C  beq cr6, 0x82a05490
	if ctx.cr[6].eq {
	pc = 0x82A05490; continue 'dispatch;
	}
	// 82A05488: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A0548C: 484C9375  bl 0x82ece800
	ctx.lr = 0x82A05490;
	sub_82ECE800(ctx, base);
	// 82A05490: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A05494: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A05498: 419A0008  beq cr6, 0x82a054a0
	if ctx.cr[6].eq {
	pc = 0x82A054A0; continue 'dispatch;
	}
	// 82A0549C: 4B8BB3F5  bl 0x822c0890
	ctx.lr = 0x82A054A0;
	sub_822C0890(ctx, base);
	// 82A054A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A054A4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A054A8: 4BDB1131  bl 0x827b65d8
	ctx.lr = 0x82A054AC;
	sub_827B65D8(ctx, base);
	// 82A054AC: C03E006C  lfs f1, 0x6c(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(108 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A054B0: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A054B4: 4B8E86A5  bl 0x822edb58
	ctx.lr = 0x82A054B8;
	sub_822EDB58(ctx, base);
	// 82A054B8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A054BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A054C0: 419A0008  beq cr6, 0x82a054c8
	if ctx.cr[6].eq {
	pc = 0x82A054C8; continue 'dispatch;
	}
	// 82A054C4: 4B8BB3CD  bl 0x822c0890
	ctx.lr = 0x82A054C8;
	sub_822C0890(ctx, base);
	// 82A054C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A054CC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A054D0: 4BDB1109  bl 0x827b65d8
	ctx.lr = 0x82A054D4;
	sub_827B65D8(ctx, base);
	// 82A054D4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A054D8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A054DC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82A054E0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A054E4: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A054E8: 484C66A9  bl 0x82ecbb90
	ctx.lr = 0x82A054EC;
	sub_82ECBB90(ctx, base);
	// 82A054EC: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A054F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A054F4: 419A0008  beq cr6, 0x82a054fc
	if ctx.cr[6].eq {
	pc = 0x82A054FC; continue 'dispatch;
	}
	// 82A054F8: 4B8BB399  bl 0x822c0890
	ctx.lr = 0x82A054FC;
	sub_822C0890(ctx, base);
	// 82A054FC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A05500: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A05504: 917F0274  stw r11, 0x274(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(628 as u32), ctx.r[11].u32 ) };
	// 82A05508: 419A000C  beq cr6, 0x82a05514
	if ctx.cr[6].eq {
	pc = 0x82A05514; continue 'dispatch;
	}
	// 82A0550C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A05510: 484C7AF9  bl 0x82ecd008
	ctx.lr = 0x82A05514;
	sub_82ECD008(ctx, base);
	// 82A05514: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A05518: 487A2CA4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A05520(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A05520 size=228
    let mut pc: u32 = 0x82A05520;
    'dispatch: loop {
        match pc {
            0x82A05520 => {
    //   block [0x82A05520..0x82A05604)
	// 82A05520: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A05524: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A05528: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A0552C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A05530: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A05534: 4874F0CD  bl 0x83154600
	ctx.lr = 0x82A05538;
	sub_83154600(ctx, base);
	// 82A05538: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A0553C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A05540: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A05544: 4BDB1095  bl 0x827b65d8
	ctx.lr = 0x82A05548;
	sub_827B65D8(ctx, base);
	// 82A05548: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0554C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A05550: 83CB0008  lwz r30, 8(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A05554: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A05558: 419A000C  beq cr6, 0x82a05564
	if ctx.cr[6].eq {
	pc = 0x82A05564; continue 'dispatch;
	}
	// 82A0555C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A05560: 484C92A1  bl 0x82ece800
	ctx.lr = 0x82A05564;
	sub_82ECE800(ctx, base);
	// 82A05564: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A05568: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0556C: 419A0008  beq cr6, 0x82a05574
	if ctx.cr[6].eq {
	pc = 0x82A05574; continue 'dispatch;
	}
	// 82A05570: 4B8BB321  bl 0x822c0890
	ctx.lr = 0x82A05574;
	sub_822C0890(ctx, base);
	// 82A05574: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A05578: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A0557C: 4BDB105D  bl 0x827b65d8
	ctx.lr = 0x82A05580;
	sub_827B65D8(ctx, base);
	// 82A05580: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82A05584: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A05588: 808B666C  lwz r4, 0x666c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26220 as u32) ) } as u64;
	// 82A0558C: 4BA89E15  bl 0x8248f3a0
	ctx.lr = 0x82A05590;
	sub_8248F3A0(ctx, base);
	// 82A05590: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A05594: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A05598: 419A0008  beq cr6, 0x82a055a0
	if ctx.cr[6].eq {
	pc = 0x82A055A0; continue 'dispatch;
	}
	// 82A0559C: 4B8BB2F5  bl 0x822c0890
	ctx.lr = 0x82A055A0;
	sub_822C0890(ctx, base);
	// 82A055A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A055A4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A055A8: 4BDB1031  bl 0x827b65d8
	ctx.lr = 0x82A055AC;
	sub_827B65D8(ctx, base);
	// 82A055AC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A055B0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A055B4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82A055B8: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 82A055BC: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A055C0: 484C65D1  bl 0x82ecbb90
	ctx.lr = 0x82A055C4;
	sub_82ECBB90(ctx, base);
	// 82A055C4: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A055C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A055CC: 419A0008  beq cr6, 0x82a055d4
	if ctx.cr[6].eq {
	pc = 0x82A055D4; continue 'dispatch;
	}
	// 82A055D0: 4B8BB2C1  bl 0x822c0890
	ctx.lr = 0x82A055D4;
	sub_822C0890(ctx, base);
	// 82A055D4: 807F0288  lwz r3, 0x288(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(648 as u32) ) } as u64;
	// 82A055D8: 4BA27021  bl 0x8242c5f8
	ctx.lr = 0x82A055DC;
	sub_8242C5F8(ctx, base);
	// 82A055DC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A055E0: 419A000C  beq cr6, 0x82a055ec
	if ctx.cr[6].eq {
	pc = 0x82A055EC; continue 'dispatch;
	}
	// 82A055E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A055E8: 484C7A21  bl 0x82ecd008
	ctx.lr = 0x82A055EC;
	sub_82ECD008(ctx, base);
	// 82A055EC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A055F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A055F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A055F8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A055FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A05600: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A05608(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A05608 size=272
    let mut pc: u32 = 0x82A05608;
    'dispatch: loop {
        match pc {
            0x82A05608 => {
    //   block [0x82A05608..0x82A05718)
	// 82A05608: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0560C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A05610: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A05614: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A05618: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0561C: 4874EFE5  bl 0x83154600
	ctx.lr = 0x82A05620;
	sub_83154600(ctx, base);
	// 82A05620: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A05624: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A05628: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0562C: 4BDB0FAD  bl 0x827b65d8
	ctx.lr = 0x82A05630;
	sub_827B65D8(ctx, base);
	// 82A05630: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A05634: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A05638: 83CB0008  lwz r30, 8(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A0563C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A05640: 419A000C  beq cr6, 0x82a0564c
	if ctx.cr[6].eq {
	pc = 0x82A0564C; continue 'dispatch;
	}
	// 82A05644: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A05648: 484C91B9  bl 0x82ece800
	ctx.lr = 0x82A0564C;
	sub_82ECE800(ctx, base);
	// 82A0564C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A05650: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A05654: 419A0008  beq cr6, 0x82a0565c
	if ctx.cr[6].eq {
	pc = 0x82A0565C; continue 'dispatch;
	}
	// 82A05658: 4B8BB239  bl 0x822c0890
	ctx.lr = 0x82A0565C;
	sub_822C0890(ctx, base);
	// 82A0565C: 807F0288  lwz r3, 0x288(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(648 as u32) ) } as u64;
	// 82A05660: 4BA273A1  bl 0x8242ca00
	ctx.lr = 0x82A05664;
	sub_8242CA00(ctx, base);
	// 82A05664: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A05668: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A0566C: 4BDB0F6D  bl 0x827b65d8
	ctx.lr = 0x82A05670;
	sub_827B65D8(ctx, base);
	// 82A05670: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82A05674: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A05678: 808B6830  lwz r4, 0x6830(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26672 as u32) ) } as u64;
	// 82A0567C: 4BA89D25  bl 0x8248f3a0
	ctx.lr = 0x82A05680;
	sub_8248F3A0(ctx, base);
	// 82A05680: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A05684: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A05688: 419A0008  beq cr6, 0x82a05690
	if ctx.cr[6].eq {
	pc = 0x82A05690; continue 'dispatch;
	}
	// 82A0568C: 4B8BB205  bl 0x822c0890
	ctx.lr = 0x82A05690;
	sub_822C0890(ctx, base);
	// 82A05690: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A05694: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A05698: 4BDB0F41  bl 0x827b65d8
	ctx.lr = 0x82A0569C;
	sub_827B65D8(ctx, base);
	// 82A0569C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A056A0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A056A4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82A056A8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A056AC: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A056B0: 484C64E1  bl 0x82ecbb90
	ctx.lr = 0x82A056B4;
	sub_82ECBB90(ctx, base);
	// 82A056B4: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A056B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A056BC: 419A0008  beq cr6, 0x82a056c4
	if ctx.cr[6].eq {
	pc = 0x82A056C4; continue 'dispatch;
	}
	// 82A056C0: 4B8BB1D1  bl 0x822c0890
	ctx.lr = 0x82A056C4;
	sub_822C0890(ctx, base);
	// 82A056C4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A056C8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A056CC: 4BDB0F0D  bl 0x827b65d8
	ctx.lr = 0x82A056D0;
	sub_827B65D8(ctx, base);
	// 82A056D0: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A056D4: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A056D8: 388B6910  addi r4, r11, 0x6910
	ctx.r[4].s64 = ctx.r[11].s64 + 26896;
	// 82A056DC: 4B8E7A75  bl 0x822ed150
	ctx.lr = 0x82A056E0;
	sub_822ED150(ctx, base);
	// 82A056E0: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A056E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A056E8: 419A0008  beq cr6, 0x82a056f0
	if ctx.cr[6].eq {
	pc = 0x82A056F0; continue 'dispatch;
	}
	// 82A056EC: 4B8BB1A5  bl 0x822c0890
	ctx.lr = 0x82A056F0;
	sub_822C0890(ctx, base);
	// 82A056F0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A056F4: 419A000C  beq cr6, 0x82a05700
	if ctx.cr[6].eq {
	pc = 0x82A05700; continue 'dispatch;
	}
	// 82A056F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A056FC: 484C790D  bl 0x82ecd008
	ctx.lr = 0x82A05700;
	sub_82ECD008(ctx, base);
	// 82A05700: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A05704: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A05708: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A0570C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A05710: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A05714: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A05718(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A05718 size=492
    let mut pc: u32 = 0x82A05718;
    'dispatch: loop {
        match pc {
            0x82A05718 => {
    //   block [0x82A05718..0x82A05904)
	// 82A05718: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0571C: 487A2A4D  bl 0x831a8168
	ctx.lr = 0x82A05720;
	sub_831A8130(ctx, base);
	// 82A05720: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A05724: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A05728: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A0572C: 389F0230  addi r4, r31, 0x230
	ctx.r[4].s64 = ctx.r[31].s64 + 560;
	// 82A05730: 4BB0DE49  bl 0x82513578
	ctx.lr = 0x82A05734;
	sub_82513578(ctx, base);
	// 82A05734: 815F0260  lwz r10, 0x260(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(608 as u32) ) } as u64;
	// 82A05738: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A0573C: 3BBE0030  addi r29, r30, 0x30
	ctx.r[29].s64 = ctx.r[30].s64 + 48;
	// 82A05740: 3B9E0040  addi r28, r30, 0x40
	ctx.r[28].s64 = ctx.r[30].s64 + 64;
	// 82A05744: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A05748: 916A0068  stw r11, 0x68(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82A0574C: 916A00D0  stw r11, 0xd0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(208 as u32), ctx.r[11].u32 ) };
	// 82A05750: C01F0230  lfs f0, 0x230(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(560 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A05754: 817F0260  lwz r11, 0x260(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(608 as u32) ) } as u64;
	// 82A05758: 394B0068  addi r10, r11, 0x68
	ctx.r[10].s64 = ctx.r[11].s64 + 104;
	// 82A0575C: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A05760: 39280015  addi r9, r8, 0x15
	ctx.r[9].s64 = ctx.r[8].s64 + 21;
	// 82A05764: 5528103A  slwi r8, r9, 2
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A05768: 392B00D0  addi r9, r11, 0xd0
	ctx.r[9].s64 = ctx.r[11].s64 + 208;
	// 82A0576C: 7C085D2E  stfsx f0, r8, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 82A05770: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A05774: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82A05778: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82A0577C: C01F0234  lfs f0, 0x234(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(564 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A05780: 810B0068  lwz r8, 0x68(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A05784: 39080015  addi r8, r8, 0x15
	ctx.r[8].s64 = ctx.r[8].s64 + 21;
	// 82A05788: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A0578C: 7C08552E  stfsx f0, r8, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32), tmp.u32) };
	// 82A05790: 814B0068  lwz r10, 0x68(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A05794: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A05798: 914B0068  stw r10, 0x68(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 82A0579C: C01F0238  lfs f0, 0x238(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A057A0: 814B00D0  lwz r10, 0xd0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(208 as u32) ) } as u64;
	// 82A057A4: 394A0015  addi r10, r10, 0x15
	ctx.r[10].s64 = ctx.r[10].s64 + 21;
	// 82A057A8: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A057AC: 7C0A4D2E  stfsx f0, r10, r9
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), tmp.u32) };
	// 82A057B0: 814B00D0  lwz r10, 0xd0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(208 as u32) ) } as u64;
	// 82A057B4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A057B8: 914B00D0  stw r10, 0xd0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(208 as u32), ctx.r[10].u32 ) };
	// 82A057BC: C01E0030  lfs f0, 0x30(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A057C0: 817F0260  lwz r11, 0x260(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(608 as u32) ) } as u64;
	// 82A057C4: 394B0068  addi r10, r11, 0x68
	ctx.r[10].s64 = ctx.r[11].s64 + 104;
	// 82A057C8: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A057CC: 39280015  addi r9, r8, 0x15
	ctx.r[9].s64 = ctx.r[8].s64 + 21;
	// 82A057D0: 5528103A  slwi r8, r9, 2
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A057D4: 392B00D0  addi r9, r11, 0xd0
	ctx.r[9].s64 = ctx.r[11].s64 + 208;
	// 82A057D8: 7C085D2E  stfsx f0, r8, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 82A057DC: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A057E0: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82A057E4: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82A057E8: C01E0034  lfs f0, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A057EC: 810B0068  lwz r8, 0x68(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A057F0: 39080015  addi r8, r8, 0x15
	ctx.r[8].s64 = ctx.r[8].s64 + 21;
	// 82A057F4: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A057F8: 7C08552E  stfsx f0, r8, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32), tmp.u32) };
	// 82A057FC: 814B0068  lwz r10, 0x68(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A05800: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A05804: 914B0068  stw r10, 0x68(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 82A05808: C01E0038  lfs f0, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A0580C: 814B00D0  lwz r10, 0xd0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(208 as u32) ) } as u64;
	// 82A05810: 394A0015  addi r10, r10, 0x15
	ctx.r[10].s64 = ctx.r[10].s64 + 21;
	// 82A05814: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A05818: 7C0A4D2E  stfsx f0, r10, r9
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), tmp.u32) };
	// 82A0581C: 814B00D0  lwz r10, 0xd0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(208 as u32) ) } as u64;
	// 82A05820: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A05824: 914B00D0  stw r10, 0xd0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(208 as u32), ctx.r[10].u32 ) };
	// 82A05828: C01E0040  lfs f0, 0x40(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A0582C: 817F0260  lwz r11, 0x260(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(608 as u32) ) } as u64;
	// 82A05830: 394B0068  addi r10, r11, 0x68
	ctx.r[10].s64 = ctx.r[11].s64 + 104;
	// 82A05834: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A05838: 39290015  addi r9, r9, 0x15
	ctx.r[9].s64 = ctx.r[9].s64 + 21;
	// 82A0583C: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A05840: 7C095D2E  stfsx f0, r9, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 82A05844: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A05848: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82A0584C: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A05850: C01E0044  lfs f0, 0x44(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(68 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A05854: 812B0068  lwz r9, 0x68(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A05858: 39290015  addi r9, r9, 0x15
	ctx.r[9].s64 = ctx.r[9].s64 + 21;
	// 82A0585C: 5528103A  slwi r8, r9, 2
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A05860: 392B00D0  addi r9, r11, 0xd0
	ctx.r[9].s64 = ctx.r[11].s64 + 208;
	// 82A05864: 7C08552E  stfsx f0, r8, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32), tmp.u32) };
	// 82A05868: 814B0068  lwz r10, 0x68(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A0586C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A05870: 914B0068  stw r10, 0x68(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 82A05874: C01E0048  lfs f0, 0x48(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A05878: 814B00D0  lwz r10, 0xd0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(208 as u32) ) } as u64;
	// 82A0587C: 394A0015  addi r10, r10, 0x15
	ctx.r[10].s64 = ctx.r[10].s64 + 21;
	// 82A05880: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A05884: 7C0A4D2E  stfsx f0, r10, r9
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), tmp.u32) };
	// 82A05888: 814B00D0  lwz r10, 0xd0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(208 as u32) ) } as u64;
	// 82A0588C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A05890: 914B00D0  stw r10, 0xd0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(208 as u32), ctx.r[10].u32 ) };
	// 82A05894: 807F0260  lwz r3, 0x260(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(608 as u32) ) } as u64;
	// 82A05898: 4BA0FA79  bl 0x82415310
	ctx.lr = 0x82A0589C;
	sub_82415310(ctx, base);
	// 82A0589C: C01E0050  lfs f0, 0x50(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A058A0: 39600240  li r11, 0x240
	ctx.r[11].s64 = 576;
	// 82A058A4: D01F0280  stfs f0, 0x280(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(640 as u32), tmp.u32 ) };
	// 82A058A8: 39400250  li r10, 0x250
	ctx.r[10].s64 = 592;
	// 82A058AC: 13E0E8C7  vcmpequd (lvx128) v31, v0, v29
	tmp.u32 = ctx.r[29].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A058B0: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A05908(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A05908 size=132
    let mut pc: u32 = 0x82A05908;
    'dispatch: loop {
        match pc {
            0x82A05908 => {
    //   block [0x82A05908..0x82A0598C)
	// 82A05908: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0590C: 487A2861  bl 0x831a816c
	ctx.lr = 0x82A05910;
	sub_831A8130(ctx, base);
	// 82A05910: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A05914: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A05918: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82A0591C: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 82A05920: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A05924: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 82A05928: 4BB0C939  bl 0x82512260
	ctx.lr = 0x82A0592C;
	sub_82512260(ctx, base);
	// 82A0592C: 387F00E4  addi r3, r31, 0xe4
	ctx.r[3].s64 = ctx.r[31].s64 + 228;
	// 82A05930: 4BF41521  bl 0x82946e50
	ctx.lr = 0x82A05934;
	sub_82946E50(ctx, base);
	// 82A05934: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A05938: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A0593C: 93DF00E8  stw r30, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[30].u32 ) };
	// 82A05940: 396B7EDC  addi r11, r11, 0x7edc
	ctx.r[11].s64 = ctx.r[11].s64 + 32476;
	// 82A05944: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 82A05948: 394A7EC8  addi r10, r10, 0x7ec8
	ctx.r[10].s64 = ctx.r[10].s64 + 32456;
	// 82A0594C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A05950: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82A05954: 39297EAC  addi r9, r9, 0x7eac
	ctx.r[9].s64 = ctx.r[9].s64 + 32428;
	// 82A05958: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82A0595C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A05960: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 82A05964: 3940012C  li r10, 0x12c
	ctx.r[10].s64 = 300;
	// 82A05968: 917F00EC  stw r11, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 82A0596C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A05970: C00808A4  lfs f0, 0x8a4(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A05974: 917F00F0  stw r11, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 82A05978: D01F00F4  stfs f0, 0xf4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 82A0597C: 915F00F8  stw r10, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[10].u32 ) };
	// 82A05980: 9BBF00FC  stb r29, 0xfc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[29].u8 ) };
	// 82A05984: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A05988: 487A2834  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A05990(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A05990 size=8
    let mut pc: u32 = 0x82A05990;
    'dispatch: loop {
        match pc {
            0x82A05990 => {
    //   block [0x82A05990..0x82A05998)
	// 82A05990: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 82A05994: 48000674  b 0x82a06008
	sub_82A06008(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A05998(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A05998 size=8
    let mut pc: u32 = 0x82A05998;
    'dispatch: loop {
        match pc {
            0x82A05998 => {
    //   block [0x82A05998..0x82A059A0)
	// 82A05998: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 82A0599C: 4800066C  b 0x82a06008
	sub_82A06008(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A059A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A059A0 size=84
    let mut pc: u32 = 0x82A059A0;
    'dispatch: loop {
        match pc {
            0x82A059A0 => {
    //   block [0x82A059A0..0x82A059F4)
	// 82A059A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A059A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A059A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A059AC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A059B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A059B4: 807F00F0  lwz r3, 0xf0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 82A059B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A059BC: 419A0008  beq cr6, 0x82a059c4
	if ctx.cr[6].eq {
	pc = 0x82A059C4; continue 'dispatch;
	}
	// 82A059C0: 4B8BAED1  bl 0x822c0890
	ctx.lr = 0x82A059C4;
	sub_822C0890(ctx, base);
	// 82A059C4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A059C8: 387F00E4  addi r3, r31, 0xe4
	ctx.r[3].s64 = ctx.r[31].s64 + 228;
	// 82A059CC: 409A0008  bne cr6, 0x82a059d4
	if !ctx.cr[6].eq {
	pc = 0x82A059D4; continue 'dispatch;
	}
	// 82A059D0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A059D4: 4BF4147D  bl 0x82946e50
	ctx.lr = 0x82A059D8;
	sub_82946E50(ctx, base);
	// 82A059D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A059DC: 4B949975  bl 0x8234f350
	ctx.lr = 0x82A059E0;
	sub_8234F350(ctx, base);
	// 82A059E0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A059E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A059E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A059EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A059F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A059F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A059F8 size=76
    let mut pc: u32 = 0x82A059F8;
    'dispatch: loop {
        match pc {
            0x82A059F8 => {
    //   block [0x82A059F8..0x82A05A44)
	// 82A059F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A059FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A05A00: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A05A04: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A05A08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A05A0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A05A10: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A05A14: 4BFFF71D  bl 0x82a05130
	ctx.lr = 0x82A05A18;
	sub_82A05130(ctx, base);
	// 82A05A18: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A05A1C: 4182000C  beq 0x82a05a28
	if ctx.cr[0].eq {
	pc = 0x82A05A28; continue 'dispatch;
	}
	// 82A05A20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A05A24: 483EC9B5  bl 0x82df23d8
	ctx.lr = 0x82A05A28;
	sub_82DF23D8(ctx, base);
	// 82A05A28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A05A2C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A05A30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A05A34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A05A38: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A05A3C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A05A40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A05A48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A05A48 size=144
    let mut pc: u32 = 0x82A05A48;
    'dispatch: loop {
        match pc {
            0x82A05A48 => {
    //   block [0x82A05A48..0x82A05AD8)
	// 82A05A48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A05A4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A05A50: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A05A54: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A05A58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A05A5C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A05A60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A05A64: 4BB04EED  bl 0x8250a950
	ctx.lr = 0x82A05A68;
	sub_8250A950(ctx, base);
	// 82A05A68: 3BFF01F8  addi r31, r31, 0x1f8
	ctx.r[31].s64 = ctx.r[31].s64 + 504;
	// 82A05A6C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A05A70: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A05A74: 419A0044  beq cr6, 0x82a05ab8
	if ctx.cr[6].eq {
	pc = 0x82A05AB8; continue 'dispatch;
	}
	// 82A05A78: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A05A7C: 4847BCC5  bl 0x82e81740
	ctx.lr = 0x82A05A80;
	sub_82E81740(ctx, base);
	// 82A05A80: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A05A84: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A05A88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A05A8C: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 82A05A90: 409A0008  bne cr6, 0x82a05a98
	if !ctx.cr[6].eq {
	pc = 0x82A05A98; continue 'dispatch;
	}
	// 82A05A94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A05A98: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A05A9C: 4BDCDED5  bl 0x827d3970
	ctx.lr = 0x82A05AA0;
	sub_827D3970(ctx, base);
	// 82A05AA0: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82A05AA4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A05AA8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A05AAC: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82A05AB0: 419A0008  beq cr6, 0x82a05ab8
	if ctx.cr[6].eq {
	pc = 0x82A05AB8; continue 'dispatch;
	}
	// 82A05AB4: 4B8BADDD  bl 0x822c0890
	ctx.lr = 0x82A05AB8;
	sub_822C0890(ctx, base);
	// 82A05AB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A05ABC: 483EC1D5  bl 0x82df1c90
	ctx.lr = 0x82A05AC0;
	sub_82DF1C90(ctx, base);
	// 82A05AC0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A05AC4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A05AC8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A05ACC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A05AD0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A05AD4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A05AD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A05AD8 size=428
    let mut pc: u32 = 0x82A05AD8;
    'dispatch: loop {
        match pc {
            0x82A05AD8 => {
    //   block [0x82A05AD8..0x82A05C84)
	// 82A05AD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A05ADC: 487A2689  bl 0x831a8164
	ctx.lr = 0x82A05AE0;
	sub_831A8130(ctx, base);
	// 82A05AE0: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A05AE4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A05AE8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A05AEC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A05AF0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A05AF4: 388B7F18  addi r4, r11, 0x7f18
	ctx.r[4].s64 = ctx.r[11].s64 + 32536;
	// 82A05AF8: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82A05AFC: 38A002D6  li r5, 0x2d6
	ctx.r[5].s64 = 726;
	// 82A05B00: 386000F0  li r3, 0xf0
	ctx.r[3].s64 = 240;
	// 82A05B04: 483EC8E5  bl 0x82df23e8
	ctx.lr = 0x82A05B08;
	sub_82DF23E8(ctx, base);
	// 82A05B08: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A05B0C: 41820074  beq 0x82a05b80
	if ctx.cr[0].eq {
	pc = 0x82A05B80; continue 'dispatch;
	}
	// 82A05B10: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A05B14: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A05B18: 4BDB0AC1  bl 0x827b65d8
	ctx.lr = 0x82A05B1C;
	sub_827B65D8(ctx, base);
	// 82A05B1C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A05B20: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A05B24: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A05B28: 3BC00003  li r30, 3
	ctx.r[30].s64 = 3;
	// 82A05B2C: 838B0000  lwz r28, 0(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A05B30: 4BDB0AA9  bl 0x827b65d8
	ctx.lr = 0x82A05B34;
	sub_827B65D8(ctx, base);
	// 82A05B34: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A05B38: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A05B3C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A05B40: 4B8E7431  bl 0x822ecf70
	ctx.lr = 0x82A05B44;
	sub_822ECF70(ctx, base);
	// 82A05B44: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A05B48: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82A05B4C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A05B50: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82A05B54: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A05B58: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A05B5C: 4E800421  bctrl
	ctx.lr = 0x82A05B60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A05B60: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A05B64: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A05B68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A05B6C: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82A05B70: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A05B74: 4800B1FD  bl 0x82a10d70
	ctx.lr = 0x82A05B78;
	sub_82A10D70(ctx, base);
	// 82A05B78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A05B7C: 48000008  b 0x82a05b84
	pc = 0x82A05B84; continue 'dispatch;
	// 82A05B80: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A05B84: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82A05B88: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A05B8C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A05B90: 4BFFEDB9  bl 0x82a04948
	ctx.lr = 0x82A05B94;
	sub_82A04948(ctx, base);
	// 82A05B94: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A05B98: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A05B9C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A05BA0: 4B8BA461  bl 0x822c0000
	ctx.lr = 0x82A05BA4;
	sub_822C0000(ctx, base);
	// 82A05BA4: 57CB07BD  rlwinm. r11, r30, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A05BA8: 41820018  beq 0x82a05bc0
	if ctx.cr[0].eq {
	pc = 0x82A05BC0; continue 'dispatch;
	}
	// 82A05BAC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A05BB0: 57DE07FA  rlwinm r30, r30, 0, 0x1f, 0x1d
	ctx.r[30].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 82A05BB4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A05BB8: 419A0008  beq cr6, 0x82a05bc0
	if ctx.cr[6].eq {
	pc = 0x82A05BC0; continue 'dispatch;
	}
	// 82A05BBC: 4B8BACD5  bl 0x822c0890
	ctx.lr = 0x82A05BC0;
	sub_822C0890(ctx, base);
	// 82A05BC0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A05BC4: 41820014  beq 0x82a05bd8
	if ctx.cr[0].eq {
	pc = 0x82A05BD8; continue 'dispatch;
	}
	// 82A05BC8: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A05BCC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A05BD0: 419A0008  beq cr6, 0x82a05bd8
	if ctx.cr[6].eq {
	pc = 0x82A05BD8; continue 'dispatch;
	}
	// 82A05BD4: 4B8BACBD  bl 0x822c0890
	ctx.lr = 0x82A05BD8;
	sub_822C0890(ctx, base);
	// 82A05BD8: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A05BDC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A05BE0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A05BE4: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82A05BE8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A05BEC: 419A0024  beq cr6, 0x82a05c10
	if ctx.cr[6].eq {
	pc = 0x82A05C10; continue 'dispatch;
	}
	// 82A05BF0: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 82A05BF4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A05BF8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A05BFC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A05C00: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A05C04: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A05C08: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A05C0C: 4082FFE8  bne 0x82a05bf4
	if !ctx.cr[0].eq {
	pc = 0x82A05BF4; continue 'dispatch;
	}
	// 82A05C10: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A05C14: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A05C18: 4BB098B1  bl 0x8250f4c8
	ctx.lr = 0x82A05C1C;
	sub_8250F4C8(ctx, base);
	// 82A05C1C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A05C20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A05C24: 3BEBFFFC  addi r31, r11, -4
	ctx.r[31].s64 = ctx.r[11].s64 + -4;
	// 82A05C28: 409A0008  bne cr6, 0x82a05c30
	if !ctx.cr[6].eq {
	pc = 0x82A05C30; continue 'dispatch;
	}
	// 82A05C2C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A05C30: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A05C34: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A05C38: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 82A05C3C: 4BB098DD  bl 0x8250f518
	ctx.lr = 0x82A05C40;
	sub_8250F518(ctx, base);
	// 82A05C40: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A05C44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A05C48: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82A05C4C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A05C50: 4BB078B9  bl 0x8250d508
	ctx.lr = 0x82A05C54;
	sub_8250D508(ctx, base);
	// 82A05C54: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A05C58: 483EC039  bl 0x82df1c90
	ctx.lr = 0x82A05C5C;
	sub_82DF1C90(ctx, base);
	// 82A05C5C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A05C60: 483EC031  bl 0x82df1c90
	ctx.lr = 0x82A05C64;
	sub_82DF1C90(ctx, base);
	// 82A05C64: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A05C68: 419A000C  beq cr6, 0x82a05c74
	if ctx.cr[6].eq {
	pc = 0x82A05C74; continue 'dispatch;
	}
	// 82A05C6C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A05C70: 4B8BAC21  bl 0x822c0890
	ctx.lr = 0x82A05C74;
	sub_822C0890(ctx, base);
	// 82A05C74: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A05C78: 4BB0A959  bl 0x825105d0
	ctx.lr = 0x82A05C7C;
	sub_825105D0(ctx, base);
	// 82A05C7C: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82A05C80: 487A2534  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A05C88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A05C88 size=124
    let mut pc: u32 = 0x82A05C88;
    'dispatch: loop {
        match pc {
            0x82A05C88 => {
    //   block [0x82A05C88..0x82A05D04)
	// 82A05C88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A05C8C: 487A24E1  bl 0x831a816c
	ctx.lr = 0x82A05C90;
	sub_831A8130(ctx, base);
	// 82A05C90: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A05C94: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A05C98: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A05C9C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A05CA0: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82A05CA4: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 82A05CA8: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 82A05CAC: 483EC73D  bl 0x82df23e8
	ctx.lr = 0x82A05CB0;
	sub_82DF23E8(ctx, base);
	// 82A05CB0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A05CB4: 4182001C  beq 0x82a05cd0
	if ctx.cr[0].eq {
	pc = 0x82A05CD0; continue 'dispatch;
	}
	// 82A05CB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A05CBC: 484539C5  bl 0x82e59680
	ctx.lr = 0x82A05CC0;
	sub_82E59680(ctx, base);
	// 82A05CC0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A05CC4: 396B7CE8  addi r11, r11, 0x7ce8
	ctx.r[11].s64 = ctx.r[11].s64 + 31976;
	// 82A05CC8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A05CCC: 48000008  b 0x82a05cd4
	pc = 0x82A05CD4; continue 'dispatch;
	// 82A05CD0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A05CD4: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A05CD8: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82A05CDC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A05CE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A05CE4: 4BFFEDF5  bl 0x82a04ad8
	ctx.lr = 0x82A05CE8;
	sub_82A04AD8(ctx, base);
	// 82A05CE8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A05CEC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A05CF0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A05CF4: 4B8BA30D  bl 0x822c0000
	ctx.lr = 0x82A05CF8;
	sub_822C0000(ctx, base);
	// 82A05CF8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A05CFC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A05D00: 487A24BC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A05D08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A05D08 size=124
    let mut pc: u32 = 0x82A05D08;
    'dispatch: loop {
        match pc {
            0x82A05D08 => {
    //   block [0x82A05D08..0x82A05D84)
	// 82A05D08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A05D0C: 487A2461  bl 0x831a816c
	ctx.lr = 0x82A05D10;
	sub_831A8130(ctx, base);
	// 82A05D10: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A05D14: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A05D18: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A05D1C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A05D20: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82A05D24: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 82A05D28: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 82A05D2C: 483EC6BD  bl 0x82df23e8
	ctx.lr = 0x82A05D30;
	sub_82DF23E8(ctx, base);
	// 82A05D30: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A05D34: 4182001C  beq 0x82a05d50
	if ctx.cr[0].eq {
	pc = 0x82A05D50; continue 'dispatch;
	}
	// 82A05D38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A05D3C: 48453945  bl 0x82e59680
	ctx.lr = 0x82A05D40;
	sub_82E59680(ctx, base);
	// 82A05D40: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A05D44: 396B7CF0  addi r11, r11, 0x7cf0
	ctx.r[11].s64 = ctx.r[11].s64 + 31984;
	// 82A05D48: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A05D4C: 48000008  b 0x82a05d54
	pc = 0x82A05D54; continue 'dispatch;
	// 82A05D50: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A05D54: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A05D58: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82A05D5C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A05D60: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A05D64: 4BFFEE3D  bl 0x82a04ba0
	ctx.lr = 0x82A05D68;
	sub_82A04BA0(ctx, base);
	// 82A05D68: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A05D6C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A05D70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A05D74: 4B8BA28D  bl 0x822c0000
	ctx.lr = 0x82A05D78;
	sub_822C0000(ctx, base);
	// 82A05D78: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A05D7C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A05D80: 487A243C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A05D88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A05D88 size=124
    let mut pc: u32 = 0x82A05D88;
    'dispatch: loop {
        match pc {
            0x82A05D88 => {
    //   block [0x82A05D88..0x82A05E04)
	// 82A05D88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A05D8C: 487A23E1  bl 0x831a816c
	ctx.lr = 0x82A05D90;
	sub_831A8130(ctx, base);
	// 82A05D90: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A05D94: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A05D98: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A05D9C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A05DA0: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82A05DA4: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 82A05DA8: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 82A05DAC: 483EC63D  bl 0x82df23e8
	ctx.lr = 0x82A05DB0;
	sub_82DF23E8(ctx, base);
	// 82A05DB0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A05DB4: 4182001C  beq 0x82a05dd0
	if ctx.cr[0].eq {
	pc = 0x82A05DD0; continue 'dispatch;
	}
	// 82A05DB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A05DBC: 484538C5  bl 0x82e59680
	ctx.lr = 0x82A05DC0;
	sub_82E59680(ctx, base);
	// 82A05DC0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A05DC4: 396B7CF8  addi r11, r11, 0x7cf8
	ctx.r[11].s64 = ctx.r[11].s64 + 31992;
	// 82A05DC8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A05DCC: 48000008  b 0x82a05dd4
	pc = 0x82A05DD4; continue 'dispatch;
	// 82A05DD0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A05DD4: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A05DD8: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82A05DDC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A05DE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A05DE4: 4BFFEE85  bl 0x82a04c68
	ctx.lr = 0x82A05DE8;
	sub_82A04C68(ctx, base);
	// 82A05DE8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A05DEC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A05DF0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A05DF4: 4B8BA20D  bl 0x822c0000
	ctx.lr = 0x82A05DF8;
	sub_822C0000(ctx, base);
	// 82A05DF8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A05DFC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A05E00: 487A23BC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A05E08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A05E08 size=124
    let mut pc: u32 = 0x82A05E08;
    'dispatch: loop {
        match pc {
            0x82A05E08 => {
    //   block [0x82A05E08..0x82A05E84)
	// 82A05E08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A05E0C: 487A2361  bl 0x831a816c
	ctx.lr = 0x82A05E10;
	sub_831A8130(ctx, base);
	// 82A05E10: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A05E14: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A05E18: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A05E1C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A05E20: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 82A05E24: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 82A05E28: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 82A05E2C: 483EC5BD  bl 0x82df23e8
	ctx.lr = 0x82A05E30;
	sub_82DF23E8(ctx, base);
	// 82A05E30: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A05E34: 4182001C  beq 0x82a05e50
	if ctx.cr[0].eq {
	pc = 0x82A05E50; continue 'dispatch;
	}
	// 82A05E38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A05E3C: 48456AED  bl 0x82e5c928
	ctx.lr = 0x82A05E40;
	sub_82E5C928(ctx, base);
	// 82A05E40: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A05E44: 396B7DB4  addi r11, r11, 0x7db4
	ctx.r[11].s64 = ctx.r[11].s64 + 32180;
	// 82A05E48: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A05E4C: 48000008  b 0x82a05e54
	pc = 0x82A05E54; continue 'dispatch;
	// 82A05E50: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A05E54: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A05E58: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82A05E5C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A05E60: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A05E64: 4BFFEECD  bl 0x82a04d30
	ctx.lr = 0x82A05E68;
	sub_82A04D30(ctx, base);
	// 82A05E68: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A05E6C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A05E70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A05E74: 4B8BA18D  bl 0x822c0000
	ctx.lr = 0x82A05E78;
	sub_822C0000(ctx, base);
	// 82A05E78: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A05E7C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A05E80: 487A233C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A05E88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A05E88 size=124
    let mut pc: u32 = 0x82A05E88;
    'dispatch: loop {
        match pc {
            0x82A05E88 => {
    //   block [0x82A05E88..0x82A05F04)
	// 82A05E88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A05E8C: 487A22E1  bl 0x831a816c
	ctx.lr = 0x82A05E90;
	sub_831A8130(ctx, base);
	// 82A05E90: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A05E94: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A05E98: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A05E9C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A05EA0: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 82A05EA4: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 82A05EA8: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 82A05EAC: 483EC53D  bl 0x82df23e8
	ctx.lr = 0x82A05EB0;
	sub_82DF23E8(ctx, base);
	// 82A05EB0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A05EB4: 4182001C  beq 0x82a05ed0
	if ctx.cr[0].eq {
	pc = 0x82A05ED0; continue 'dispatch;
	}
	// 82A05EB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A05EBC: 48456A6D  bl 0x82e5c928
	ctx.lr = 0x82A05EC0;
	sub_82E5C928(ctx, base);
	// 82A05EC0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A05EC4: 396B7DDC  addi r11, r11, 0x7ddc
	ctx.r[11].s64 = ctx.r[11].s64 + 32220;
	// 82A05EC8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A05ECC: 48000008  b 0x82a05ed4
	pc = 0x82A05ED4; continue 'dispatch;
	// 82A05ED0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A05ED4: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A05ED8: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82A05EDC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A05EE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A05EE4: 4BFFEF15  bl 0x82a04df8
	ctx.lr = 0x82A05EE8;
	sub_82A04DF8(ctx, base);
	// 82A05EE8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A05EEC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A05EF0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A05EF4: 4B8BA10D  bl 0x822c0000
	ctx.lr = 0x82A05EF8;
	sub_822C0000(ctx, base);
	// 82A05EF8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A05EFC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A05F00: 487A22BC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A05F08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A05F08 size=124
    let mut pc: u32 = 0x82A05F08;
    'dispatch: loop {
        match pc {
            0x82A05F08 => {
    //   block [0x82A05F08..0x82A05F84)
	// 82A05F08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A05F0C: 487A2261  bl 0x831a816c
	ctx.lr = 0x82A05F10;
	sub_831A8130(ctx, base);
	// 82A05F10: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A05F14: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A05F18: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A05F1C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A05F20: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 82A05F24: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 82A05F28: 38600090  li r3, 0x90
	ctx.r[3].s64 = 144;
	// 82A05F2C: 483EC4BD  bl 0x82df23e8
	ctx.lr = 0x82A05F30;
	sub_82DF23E8(ctx, base);
	// 82A05F30: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A05F34: 4182001C  beq 0x82a05f50
	if ctx.cr[0].eq {
	pc = 0x82A05F50; continue 'dispatch;
	}
	// 82A05F38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A05F3C: 484569ED  bl 0x82e5c928
	ctx.lr = 0x82A05F40;
	sub_82E5C928(ctx, base);
	// 82A05F40: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A05F44: 396B7E04  addi r11, r11, 0x7e04
	ctx.r[11].s64 = ctx.r[11].s64 + 32260;
	// 82A05F48: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A05F4C: 48000008  b 0x82a05f54
	pc = 0x82A05F54; continue 'dispatch;
	// 82A05F50: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A05F54: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A05F58: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82A05F5C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A05F60: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A05F64: 4BFFEF5D  bl 0x82a04ec0
	ctx.lr = 0x82A05F68;
	sub_82A04EC0(ctx, base);
	// 82A05F68: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A05F6C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A05F70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A05F74: 4B8BA08D  bl 0x822c0000
	ctx.lr = 0x82A05F78;
	sub_822C0000(ctx, base);
	// 82A05F78: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A05F7C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A05F80: 487A223C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A05F88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A05F88 size=124
    let mut pc: u32 = 0x82A05F88;
    'dispatch: loop {
        match pc {
            0x82A05F88 => {
    //   block [0x82A05F88..0x82A06004)
	// 82A05F88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A05F8C: 487A21E1  bl 0x831a816c
	ctx.lr = 0x82A05F90;
	sub_831A8130(ctx, base);
	// 82A05F90: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A05F94: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A05F98: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A05F9C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A05FA0: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 82A05FA4: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 82A05FA8: 38600090  li r3, 0x90
	ctx.r[3].s64 = 144;
	// 82A05FAC: 483EC43D  bl 0x82df23e8
	ctx.lr = 0x82A05FB0;
	sub_82DF23E8(ctx, base);
	// 82A05FB0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A05FB4: 4182001C  beq 0x82a05fd0
	if ctx.cr[0].eq {
	pc = 0x82A05FD0; continue 'dispatch;
	}
	// 82A05FB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A05FBC: 4845696D  bl 0x82e5c928
	ctx.lr = 0x82A05FC0;
	sub_82E5C928(ctx, base);
	// 82A05FC0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A05FC4: 396B7E2C  addi r11, r11, 0x7e2c
	ctx.r[11].s64 = ctx.r[11].s64 + 32300;
	// 82A05FC8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A05FCC: 48000008  b 0x82a05fd4
	pc = 0x82A05FD4; continue 'dispatch;
	// 82A05FD0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A05FD4: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A05FD8: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82A05FDC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A05FE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A05FE4: 4BFFEFA5  bl 0x82a04f88
	ctx.lr = 0x82A05FE8;
	sub_82A04F88(ctx, base);
	// 82A05FE8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A05FEC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A05FF0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A05FF4: 4B8BA00D  bl 0x822c0000
	ctx.lr = 0x82A05FF8;
	sub_822C0000(ctx, base);
	// 82A05FF8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A05FFC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A06000: 487A21BC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A06008(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A06008 size=76
    let mut pc: u32 = 0x82A06008;
    'dispatch: loop {
        match pc {
            0x82A06008 => {
    //   block [0x82A06008..0x82A06054)
	// 82A06008: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0600C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A06010: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A06014: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A06018: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0601C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A06020: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A06024: 4BFFF97D  bl 0x82a059a0
	ctx.lr = 0x82A06028;
	sub_82A059A0(ctx, base);
	// 82A06028: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A0602C: 4182000C  beq 0x82a06038
	if ctx.cr[0].eq {
	pc = 0x82A06038; continue 'dispatch;
	}
	// 82A06030: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A06034: 483EC3A5  bl 0x82df23d8
	ctx.lr = 0x82A06038;
	sub_82DF23D8(ctx, base);
	// 82A06038: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0603C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A06040: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A06044: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A06048: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A0604C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A06050: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A06058(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A06058 size=204
    let mut pc: u32 = 0x82A06058;
    'dispatch: loop {
        match pc {
            0x82A06058 => {
    //   block [0x82A06058..0x82A06124)
	// 82A06058: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0605C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A06060: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A06064: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A06068: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0606C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A06070: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A06074: 4BB0BFF5  bl 0x82512068
	ctx.lr = 0x82A06078;
	sub_82512068(ctx, base);
	// 82A06078: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82A0607C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A06080: 4BB02601  bl 0x82508680
	ctx.lr = 0x82A06084;
	sub_82508680(ctx, base);
	// 82A06084: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A06088: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A0608C: 4BF07B05  bl 0x8290db90
	ctx.lr = 0x82A06090;
	sub_8290DB90(ctx, base);
	// 82A06090: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A06094: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A06098: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0609C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A060A0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A060A4: 419A0024  beq cr6, 0x82a060c8
	if ctx.cr[6].eq {
	pc = 0x82A060C8; continue 'dispatch;
	}
	// 82A060A8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A060AC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A060B0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A060B4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A060B8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A060BC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A060C0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A060C4: 4082FFE8  bne 0x82a060ac
	if !ctx.cr[0].eq {
	pc = 0x82A060AC; continue 'dispatch;
	}
	// 82A060C8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A060CC: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A060D0: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82A060D4: 388A7F18  addi r4, r10, 0x7f18
	ctx.r[4].s64 = ctx.r[10].s64 + 32536;
	// 82A060D8: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82A060DC: 38A00136  li r5, 0x136
	ctx.r[5].s64 = 310;
	// 82A060E0: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A060E4: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82A060E8: 48452959  bl 0x82e58a40
	ctx.lr = 0x82A060EC;
	sub_82E58A40(ctx, base);
	// 82A060EC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A060F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A060F4: 419A0008  beq cr6, 0x82a060fc
	if ctx.cr[6].eq {
	pc = 0x82A060FC; continue 'dispatch;
	}
	// 82A060F8: 4B8BA799  bl 0x822c0890
	ctx.lr = 0x82A060FC;
	sub_822C0890(ctx, base);
	// 82A060FC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A06100: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A06104: 419A0008  beq cr6, 0x82a0610c
	if ctx.cr[6].eq {
	pc = 0x82A0610C; continue 'dispatch;
	}
	// 82A06108: 4B8BA789  bl 0x822c0890
	ctx.lr = 0x82A0610C;
	sub_822C0890(ctx, base);
	// 82A0610C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A06110: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A06114: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A06118: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A0611C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A06120: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A06128(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A06128 size=760
    let mut pc: u32 = 0x82A06128;
    'dispatch: loop {
        match pc {
            0x82A06128 => {
    //   block [0x82A06128..0x82A06420)
	// 82A06128: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0612C: 487A203D  bl 0x831a8168
	ctx.lr = 0x82A06130;
	sub_831A8130(ctx, base);
	// 82A06130: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82A06134: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A06138: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A0613C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82A06140: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A06144: 3BAA7F18  addi r29, r10, 0x7f18
	ctx.r[29].s64 = ctx.r[10].s64 + 32536;
	// 82A06148: 817F00F8  lwz r11, 0xf8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 82A0614C: C3E908A4  lfs f31, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A06150: 356BFED5  addic. r11, r11, -0x12b
	ctx.xer.ca = (ctx.r[11].u32 > (!(-299 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -299;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A06154: 917F00F8  stw r11, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[11].u32 ) };
	// 82A06158: 4181015C  bgt 0x82a062b4
	if ctx.cr[0].gt {
	pc = 0x82A062B4; continue 'dispatch;
	}
	// 82A0615C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A06160: 4BFFFB29  bl 0x82a05c88
	ctx.lr = 0x82A06164;
	sub_82A05C88(ctx, base);
	// 82A06164: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A06168: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A0616C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A06170: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A06174: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A06178: 419A0024  beq cr6, 0x82a0619c
	if ctx.cr[6].eq {
	pc = 0x82A0619C; continue 'dispatch;
	}
	// 82A0617C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A06180: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A06184: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A06188: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A0618C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A06190: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A06194: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A06198: 4082FFE8  bne 0x82a06180
	if !ctx.cr[0].eq {
	pc = 0x82A06180; continue 'dispatch;
	}
	// 82A0619C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A061A0: 80DF00E8  lwz r6, 0xe8(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 82A061A4: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 82A061A8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A061AC: 38A00180  li r5, 0x180
	ctx.r[5].s64 = 384;
	// 82A061B0: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82A061B4: 4845288D  bl 0x82e58a40
	ctx.lr = 0x82A061B8;
	sub_82E58A40(ctx, base);
	// 82A061B8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A061BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A061C0: 419A0008  beq cr6, 0x82a061c8
	if ctx.cr[6].eq {
	pc = 0x82A061C8; continue 'dispatch;
	}
	// 82A061C4: 4B8BA6CD  bl 0x822c0890
	ctx.lr = 0x82A061C8;
	sub_822C0890(ctx, base);
	// 82A061C8: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A061CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A061D0: 419A0008  beq cr6, 0x82a061d8
	if ctx.cr[6].eq {
	pc = 0x82A061D8; continue 'dispatch;
	}
	// 82A061D4: 4B8BA6BD  bl 0x822c0890
	ctx.lr = 0x82A061D8;
	sub_822C0890(ctx, base);
	// 82A061D8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A061DC: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A061E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A061E4: 38AA7F78  addi r5, r10, 0x7f78
	ctx.r[5].s64 = ctx.r[10].s64 + 32632;
	// 82A061E8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A061EC: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82A061F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A061F4: 4E800421  bctrl
	ctx.lr = 0x82A061F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A061F8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A061FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A06200: 419A0008  beq cr6, 0x82a06208
	if ctx.cr[6].eq {
	pc = 0x82A06208; continue 'dispatch;
	}
	// 82A06204: 4B8BA68D  bl 0x822c0890
	ctx.lr = 0x82A06208;
	sub_822C0890(ctx, base);
	// 82A06208: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A0620C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A06210: 388B7F5C  addi r4, r11, 0x7f5c
	ctx.r[4].s64 = ctx.r[11].s64 + 32604;
	// 82A06214: 483ED7F5  bl 0x82df3a08
	ctx.lr = 0x82A06218;
	sub_82DF3A08(ctx, base);
	// 82A06218: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0621C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A06220: 4BB092A9  bl 0x8250f4c8
	ctx.lr = 0x82A06224;
	sub_8250F4C8(ctx, base);
	// 82A06224: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A06228: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0622C: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82A06230: 409A0008  bne cr6, 0x82a06238
	if !ctx.cr[6].eq {
	pc = 0x82A06238; continue 'dispatch;
	}
	// 82A06234: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A06238: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A0623C: 4BB04715  bl 0x8250a950
	ctx.lr = 0x82A06240;
	sub_8250A950(ctx, base);
	// 82A06240: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A06244: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A06248: 3BCBFF40  addi r30, r11, -0xc0
	ctx.r[30].s64 = ctx.r[11].s64 + -192;
	// 82A0624C: 409A0008  bne cr6, 0x82a06254
	if !ctx.cr[6].eq {
	pc = 0x82A06254; continue 'dispatch;
	}
	// 82A06250: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A06254: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A06258: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82A0625C: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 82A06260: 4BB0BEB9  bl 0x82512118
	ctx.lr = 0x82A06264;
	sub_82512118(ctx, base);
	// 82A06264: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A06268: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A0626C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A06270: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82A06274: 38C0000A  li r6, 0xa
	ctx.r[6].s64 = 10;
	// 82A06278: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A0627C: 4BDCDF25  bl 0x827d41a0
	ctx.lr = 0x82A06280;
	sub_827D41A0(ctx, base);
	// 82A06280: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A06284: 483EBA0D  bl 0x82df1c90
	ctx.lr = 0x82A06288;
	sub_82DF1C90(ctx, base);
	// 82A06288: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A0628C: 483EBA05  bl 0x82df1c90
	ctx.lr = 0x82A06290;
	sub_82DF1C90(ctx, base);
	// 82A06290: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82A06294: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A06298: 419A0008  beq cr6, 0x82a062a0
	if ctx.cr[6].eq {
	pc = 0x82A062A0; continue 'dispatch;
	}
	// 82A0629C: 4B8BA5F5  bl 0x822c0890
	ctx.lr = 0x82A062A0;
	sub_822C0890(ctx, base);
	// 82A062A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A062A4: 483ED185  bl 0x82df3428
	ctx.lr = 0x82A062A8;
	sub_82DF3428(ctx, base);
	// 82A062A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A062AC: 4BB0A325  bl 0x825105d0
	ctx.lr = 0x82A062B0;
	sub_825105D0(ctx, base);
	// 82A062B0: 480000D4  b 0x82a06384
	pc = 0x82A06384; continue 'dispatch;
	// 82A062B4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A062B8: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A062BC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A062C0: 38AA6748  addi r5, r10, 0x6748
	ctx.r[5].s64 = ctx.r[10].s64 + 26440;
	// 82A062C4: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82A062C8: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82A062CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A062D0: 4E800421  bctrl
	ctx.lr = 0x82A062D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A062D4: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82A062D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A062DC: 419A0008  beq cr6, 0x82a062e4
	if ctx.cr[6].eq {
	pc = 0x82A062E4; continue 'dispatch;
	}
	// 82A062E0: 4B8BA5B1  bl 0x822c0890
	ctx.lr = 0x82A062E4;
	sub_822C0890(ctx, base);
	// 82A062E4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A062E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A062EC: 388B7F5C  addi r4, r11, 0x7f5c
	ctx.r[4].s64 = ctx.r[11].s64 + 32604;
	// 82A062F0: 483ED719  bl 0x82df3a08
	ctx.lr = 0x82A062F4;
	sub_82DF3A08(ctx, base);
	// 82A062F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A062F8: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82A062FC: 4BB091CD  bl 0x8250f4c8
	ctx.lr = 0x82A06300;
	sub_8250F4C8(ctx, base);
	// 82A06300: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A06304: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A06308: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82A0630C: 409A0008  bne cr6, 0x82a06314
	if !ctx.cr[6].eq {
	pc = 0x82A06314; continue 'dispatch;
	}
	// 82A06310: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A06314: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82A06318: 4BB04639  bl 0x8250a950
	ctx.lr = 0x82A0631C;
	sub_8250A950(ctx, base);
	// 82A0631C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A06320: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A06324: 3BCBFF40  addi r30, r11, -0xc0
	ctx.r[30].s64 = ctx.r[11].s64 + -192;
	// 82A06328: 409A0008  bne cr6, 0x82a06330
	if !ctx.cr[6].eq {
	pc = 0x82A06330; continue 'dispatch;
	}
	// 82A0632C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A06330: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A06334: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82A06338: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 82A0633C: 4BB0BDDD  bl 0x82512118
	ctx.lr = 0x82A06340;
	sub_82512118(ctx, base);
	// 82A06340: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A06344: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A06348: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A0634C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82A06350: 38C0000A  li r6, 0xa
	ctx.r[6].s64 = 10;
	// 82A06354: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A06358: 4BDCDE49  bl 0x827d41a0
	ctx.lr = 0x82A0635C;
	sub_827D41A0(ctx, base);
	// 82A0635C: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82A06360: 483EB931  bl 0x82df1c90
	ctx.lr = 0x82A06364;
	sub_82DF1C90(ctx, base);
	// 82A06364: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82A06368: 483EB929  bl 0x82df1c90
	ctx.lr = 0x82A0636C;
	sub_82DF1C90(ctx, base);
	// 82A0636C: 806100AC  lwz r3, 0xac(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82A06370: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A06374: 419A0008  beq cr6, 0x82a0637c
	if ctx.cr[6].eq {
	pc = 0x82A0637C; continue 'dispatch;
	}
	// 82A06378: 4B8BA519  bl 0x822c0890
	ctx.lr = 0x82A0637C;
	sub_822C0890(ctx, base);
	// 82A0637C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A06380: 483ED0A9  bl 0x82df3428
	ctx.lr = 0x82A06384;
	sub_82DF3428(ctx, base);
	// 82A06384: 39600006  li r11, 6
	ctx.r[11].s64 = 6;
	// 82A06388: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A0638C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A06390: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82A06394: 4BFF16AD  bl 0x829f7a40
	ctx.lr = 0x82A06398;
	sub_829F7A40(ctx, base);
	// 82A06398: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0639C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A063A0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A063A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A063A8: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A063AC: 419A0024  beq cr6, 0x82a063d0
	if ctx.cr[6].eq {
	pc = 0x82A063D0; continue 'dispatch;
	}
	// 82A063B0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A063B4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A063B8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A063BC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A063C0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A063C4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A063C8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A063CC: 4082FFE8  bne 0x82a063b4
	if !ctx.cr[0].eq {
	pc = 0x82A063B4; continue 'dispatch;
	}
	// 82A063D0: 3BC10060  addi r30, r1, 0x60
	ctx.r[30].s64 = ctx.r[1].s64 + 96;
	// 82A063D4: 4BFE797D  bl 0x829edd50
	ctx.lr = 0x82A063D8;
	sub_829EDD50(ctx, base);
	// 82A063D8: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A063DC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A063E0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A063E4: 38A0019A  li r5, 0x19a
	ctx.r[5].s64 = 410;
	// 82A063E8: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82A063EC: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82A063F0: 48452651  bl 0x82e58a40
	ctx.lr = 0x82A063F4;
	sub_82E58A40(ctx, base);
	// 82A063F4: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A063F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A063FC: 419A0008  beq cr6, 0x82a06404
	if ctx.cr[6].eq {
	pc = 0x82A06404; continue 'dispatch;
	}
	// 82A06400: 4B8BA491  bl 0x822c0890
	ctx.lr = 0x82A06404;
	sub_822C0890(ctx, base);
	// 82A06404: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82A06408: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0640C: 419A0008  beq cr6, 0x82a06414
	if ctx.cr[6].eq {
	pc = 0x82A06414; continue 'dispatch;
	}
	// 82A06410: 4B8BA481  bl 0x822c0890
	ctx.lr = 0x82A06414;
	sub_822C0890(ctx, base);
	// 82A06414: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82A06418: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82A0641C: 487A1D9C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A06420(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A06420 size=388
    let mut pc: u32 = 0x82A06420;
    'dispatch: loop {
        match pc {
            0x82A06420 => {
    //   block [0x82A06420..0x82A065A4)
	// 82A06420: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A06424: 487A1D49  bl 0x831a816c
	ctx.lr = 0x82A06428;
	sub_831A8130(ctx, base);
	// 82A06428: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0642C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A06430: 817E00F8  lwz r11, 0xf8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(248 as u32) ) } as u64;
	// 82A06434: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A06438: 40990164  ble cr6, 0x82a0659c
	if !ctx.cr[6].gt {
	pc = 0x82A0659C; continue 'dispatch;
	}
	// 82A0643C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A06440: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A06444: 93FE00F8  stw r31, 0xf8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(248 as u32), ctx.r[31].u32 ) };
	// 82A06448: 4BFFF841  bl 0x82a05c88
	ctx.lr = 0x82A0644C;
	sub_82A05C88(ctx, base);
	// 82A0644C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A06450: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A06454: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A06458: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0645C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A06460: 419A0024  beq cr6, 0x82a06484
	if ctx.cr[6].eq {
	pc = 0x82A06484; continue 'dispatch;
	}
	// 82A06464: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A06468: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A0646C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A06470: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A06474: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A06478: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A0647C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A06480: 4082FFE8  bne 0x82a06468
	if !ctx.cr[0].eq {
	pc = 0x82A06468; continue 'dispatch;
	}
	// 82A06484: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A06488: 80DE00E8  lwz r6, 0xe8(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(232 as u32) ) } as u64;
	// 82A0648C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A06490: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 82A06494: 388A7F18  addi r4, r10, 0x7f18
	ctx.r[4].s64 = ctx.r[10].s64 + 32536;
	// 82A06498: 38A001AB  li r5, 0x1ab
	ctx.r[5].s64 = 427;
	// 82A0649C: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 82A064A0: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A064A4: 4845259D  bl 0x82e58a40
	ctx.lr = 0x82A064A8;
	sub_82E58A40(ctx, base);
	// 82A064A8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A064AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A064B0: 419A0008  beq cr6, 0x82a064b8
	if ctx.cr[6].eq {
	pc = 0x82A064B8; continue 'dispatch;
	}
	// 82A064B4: 4B8BA3DD  bl 0x822c0890
	ctx.lr = 0x82A064B8;
	sub_822C0890(ctx, base);
	// 82A064B8: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A064BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A064C0: 419A0008  beq cr6, 0x82a064c8
	if ctx.cr[6].eq {
	pc = 0x82A064C8; continue 'dispatch;
	}
	// 82A064C4: 4B8BA3CD  bl 0x822c0890
	ctx.lr = 0x82A064C8;
	sub_822C0890(ctx, base);
	// 82A064C8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A064CC: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A064D0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A064D4: 38AA7F78  addi r5, r10, 0x7f78
	ctx.r[5].s64 = ctx.r[10].s64 + 32632;
	// 82A064D8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A064DC: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82A064E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A064E4: 4E800421  bctrl
	ctx.lr = 0x82A064E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A064E8: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A064EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A064F0: 419A0008  beq cr6, 0x82a064f8
	if ctx.cr[6].eq {
	pc = 0x82A064F8; continue 'dispatch;
	}
	// 82A064F4: 4B8BA39D  bl 0x822c0890
	ctx.lr = 0x82A064F8;
	sub_822C0890(ctx, base);
	// 82A064F8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A064FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A06500: 388B7F5C  addi r4, r11, 0x7f5c
	ctx.r[4].s64 = ctx.r[11].s64 + 32604;
	// 82A06504: 483ED505  bl 0x82df3a08
	ctx.lr = 0x82A06508;
	sub_82DF3A08(ctx, base);
	// 82A06508: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A0650C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A06510: 4BB08FB9  bl 0x8250f4c8
	ctx.lr = 0x82A06514;
	sub_8250F4C8(ctx, base);
	// 82A06514: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A06518: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0651C: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82A06520: 409A0008  bne cr6, 0x82a06528
	if !ctx.cr[6].eq {
	pc = 0x82A06528; continue 'dispatch;
	}
	// 82A06524: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A06528: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A0652C: 4BB04425  bl 0x8250a950
	ctx.lr = 0x82A06530;
	sub_8250A950(ctx, base);
	// 82A06530: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A06534: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A06538: 419A0008  beq cr6, 0x82a06540
	if ctx.cr[6].eq {
	pc = 0x82A06540; continue 'dispatch;
	}
	// 82A0653C: 3BEBFF40  addi r31, r11, -0xc0
	ctx.r[31].s64 = ctx.r[11].s64 + -192;
	// 82A06540: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A06544: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A06548: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 82A0654C: 4BB0BBCD  bl 0x82512118
	ctx.lr = 0x82A06550;
	sub_82512118(ctx, base);
	// 82A06550: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A06554: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A06558: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0655C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A06560: 38C0000A  li r6, 0xa
	ctx.r[6].s64 = 10;
	// 82A06564: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A06568: 4BDCDC39  bl 0x827d41a0
	ctx.lr = 0x82A0656C;
	sub_827D41A0(ctx, base);
	// 82A0656C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A06570: 483EB721  bl 0x82df1c90
	ctx.lr = 0x82A06574;
	sub_82DF1C90(ctx, base);
	// 82A06574: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A06578: 483EB719  bl 0x82df1c90
	ctx.lr = 0x82A0657C;
	sub_82DF1C90(ctx, base);
	// 82A0657C: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82A06580: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A06584: 419A0008  beq cr6, 0x82a0658c
	if ctx.cr[6].eq {
	pc = 0x82A0658C; continue 'dispatch;
	}
	// 82A06588: 4B8BA309  bl 0x822c0890
	ctx.lr = 0x82A0658C;
	sub_822C0890(ctx, base);
	// 82A0658C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A06590: 483ECE99  bl 0x82df3428
	ctx.lr = 0x82A06594;
	sub_82DF3428(ctx, base);
	// 82A06594: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A06598: 4BB0A039  bl 0x825105d0
	ctx.lr = 0x82A0659C;
	sub_825105D0(ctx, base);
	// 82A0659C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A065A0: 487A1C1C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A065A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A065A8 size=716
    let mut pc: u32 = 0x82A065A8;
    'dispatch: loop {
        match pc {
            0x82A065A8 => {
    //   block [0x82A065A8..0x82A06874)
	// 82A065A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A065AC: 487A1BA9  bl 0x831a8154
	ctx.lr = 0x82A065B0;
	sub_831A8130(ctx, base);
	// 82A065B0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A065B4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A065B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A065BC: 3B8B7F9C  addi r28, r11, 0x7f9c
	ctx.r[28].s64 = ctx.r[11].s64 + 32668;
	// 82A065C0: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 82A065C4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A065C8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A065CC: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 82A065D0: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 82A065D4: 7CFE3B78  mr r30, r7
	ctx.r[30].u64 = ctx.r[7].u64;
	// 82A065D8: 7D1D4378  mr r29, r8
	ctx.r[29].u64 = ctx.r[8].u64;
	// 82A065DC: 483ED42D  bl 0x82df3a08
	ctx.lr = 0x82A065E0;
	sub_82DF3A08(ctx, base);
	// 82A065E0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A065E4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A065E8: 388B7F8C  addi r4, r11, 0x7f8c
	ctx.r[4].s64 = ctx.r[11].s64 + 32652;
	// 82A065EC: 483ED41D  bl 0x82df3a08
	ctx.lr = 0x82A065F0;
	sub_82DF3A08(ctx, base);
	// 82A065F0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A065F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A065F8: 483ED411  bl 0x82df3a08
	ctx.lr = 0x82A065FC;
	sub_82DF3A08(ctx, base);
	// 82A065FC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82A06600: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A06604: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 82A06608: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 82A0660C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A06610: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A06614: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 82A06618: 4BB0D4C9  bl 0x82513ae0
	ctx.lr = 0x82A0661C;
	sub_82513AE0(ctx, base);
	// 82A0661C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A06620: 483ECE09  bl 0x82df3428
	ctx.lr = 0x82A06624;
	sub_82DF3428(ctx, base);
	// 82A06624: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A06628: 483ECE01  bl 0x82df3428
	ctx.lr = 0x82A0662C;
	sub_82DF3428(ctx, base);
	// 82A0662C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A06630: 483ECDF9  bl 0x82df3428
	ctx.lr = 0x82A06634;
	sub_82DF3428(ctx, base);
	// 82A06634: 387F0160  addi r3, r31, 0x160
	ctx.r[3].s64 = ctx.r[31].s64 + 352;
	// 82A06638: 48457299  bl 0x82e5d8d0
	ctx.lr = 0x82A0663C;
	sub_82E5D8D0(ctx, base);
	// 82A0663C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A06640: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 82A06644: 396B7CD8  addi r11, r11, 0x7cd8
	ctx.r[11].s64 = ctx.r[11].s64 + 31960;
	// 82A06648: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A0664C: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 82A06650: 917F0160  stw r11, 0x160(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), ctx.r[11].u32 ) };
	// 82A06654: 39687E54  addi r11, r8, 0x7e54
	ctx.r[11].s64 = ctx.r[8].s64 + 32340;
	// 82A06658: 93DF01C0  stw r30, 0x1c0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(448 as u32), ctx.r[30].u32 ) };
	// 82A0665C: 394A7E78  addi r10, r10, 0x7e78
	ctx.r[10].s64 = ctx.r[10].s64 + 32376;
	// 82A06660: 39297E64  addi r9, r9, 0x7e64
	ctx.r[9].s64 = ctx.r[9].s64 + 32356;
	// 82A06664: 917F0160  stw r11, 0x160(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), ctx.r[11].u32 ) };
	// 82A06668: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A0666C: 394001D0  li r10, 0x1d0
	ctx.r[10].s64 = 464;
	// 82A06670: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 82A06674: 13C0C8C7  vcmpequd (lvx128) v30, v0, v25
	tmp.u32 = ctx.r[25].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A06878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A06878 size=1080
    let mut pc: u32 = 0x82A06878;
    'dispatch: loop {
        match pc {
            0x82A06878 => {
    //   block [0x82A06878..0x82A06CB0)
	// 82A06878: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0687C: 487A18E9  bl 0x831a8164
	ctx.lr = 0x82A06880;
	sub_831A8130(ctx, base);
	// 82A06880: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82A06884: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A06CB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A06CB0 size=272
    let mut pc: u32 = 0x82A06CB0;
    'dispatch: loop {
        match pc {
            0x82A06CB0 => {
    //   block [0x82A06CB0..0x82A06DC0)
	// 82A06CB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A06CB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A06CB8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A06CBC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A06CC0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A06CC4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A06CC8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A06CCC: 897F01F1  lbz r11, 0x1f1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(497 as u32) ) } as u64;
	// 82A06CD0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A06CD4: 418200D4  beq 0x82a06da8
	if ctx.cr[0].eq {
	pc = 0x82A06DA8; continue 'dispatch;
	}
	// 82A06CD8: 4BFFEE01  bl 0x82a05ad8
	ctx.lr = 0x82A06CDC;
	sub_82A05AD8(ctx, base);
	// 82A06CDC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A06CE0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A06CE4: 4BDAF8F5  bl 0x827b65d8
	ctx.lr = 0x82A06CE8;
	sub_827B65D8(ctx, base);
	// 82A06CE8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A06CEC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A06CF0: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A06CF4: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A06CF8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A06CFC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A06D00: 4E800421  bctrl
	ctx.lr = 0x82A06D04;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A06D04: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A06D08: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A06D0C: 4BBE0925  bl 0x825e7630
	ctx.lr = 0x82A06D10;
	sub_825E7630(ctx, base);
	// 82A06D10: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A06D14: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A06D18: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A06D1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A06D20: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A06D24: 419A0024  beq cr6, 0x82a06d48
	if ctx.cr[6].eq {
	pc = 0x82A06D48; continue 'dispatch;
	}
	// 82A06D28: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A06D2C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A06D30: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A06D34: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A06D38: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A06D3C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A06D40: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A06D44: 4082FFE8  bne 0x82a06d2c
	if !ctx.cr[0].eq {
	pc = 0x82A06D2C; continue 'dispatch;
	}
	// 82A06D48: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A06D4C: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 82A06D50: 486013D9  bl 0x83008128
	ctx.lr = 0x82A06D54;
	sub_83008128(ctx, base);
	// 82A06D54: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A06D58: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A06D5C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A06D60: 388A7F18  addi r4, r10, 0x7f18
	ctx.r[4].s64 = ctx.r[10].s64 + 32536;
	// 82A06D64: 38A002E9  li r5, 0x2e9
	ctx.r[5].s64 = 745;
	// 82A06D68: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82A06D6C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A06D70: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82A06D74: 48451CCD  bl 0x82e58a40
	ctx.lr = 0x82A06D78;
	sub_82E58A40(ctx, base);
	// 82A06D78: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A06D7C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A06D80: 419A0008  beq cr6, 0x82a06d88
	if ctx.cr[6].eq {
	pc = 0x82A06D88; continue 'dispatch;
	}
	// 82A06D84: 4B8B9B0D  bl 0x822c0890
	ctx.lr = 0x82A06D88;
	sub_822C0890(ctx, base);
	// 82A06D88: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A06D8C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A06D90: 419A0008  beq cr6, 0x82a06d98
	if ctx.cr[6].eq {
	pc = 0x82A06D98; continue 'dispatch;
	}
	// 82A06D94: 4B8B9AFD  bl 0x822c0890
	ctx.lr = 0x82A06D98;
	sub_822C0890(ctx, base);
	// 82A06D98: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A06D9C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A06DA0: 419A0008  beq cr6, 0x82a06da8
	if ctx.cr[6].eq {
	pc = 0x82A06DA8; continue 'dispatch;
	}
	// 82A06DA4: 4B8B9AED  bl 0x822c0890
	ctx.lr = 0x82A06DA8;
	sub_822C0890(ctx, base);
	// 82A06DA8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A06DAC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A06DB0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A06DB4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A06DB8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A06DBC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A06DC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A06DC0 size=260
    let mut pc: u32 = 0x82A06DC0;
    'dispatch: loop {
        match pc {
            0x82A06DC0 => {
    //   block [0x82A06DC0..0x82A06EC4)
	// 82A06DC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A06DC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A06DC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A06DCC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A06DD0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A06DD4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A06DD8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A06DDC: 4BFFECFD  bl 0x82a05ad8
	ctx.lr = 0x82A06DE0;
	sub_82A05AD8(ctx, base);
	// 82A06DE0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A06DE4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A06DE8: 4BDAF7F1  bl 0x827b65d8
	ctx.lr = 0x82A06DEC;
	sub_827B65D8(ctx, base);
	// 82A06DEC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A06DF0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A06DF4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A06DF8: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A06DFC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A06E00: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A06E04: 4E800421  bctrl
	ctx.lr = 0x82A06E08;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A06E08: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A06E0C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A06E10: 4BBE0821  bl 0x825e7630
	ctx.lr = 0x82A06E14;
	sub_825E7630(ctx, base);
	// 82A06E14: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A06E18: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A06E1C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A06E20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A06E24: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A06E28: 419A0024  beq cr6, 0x82a06e4c
	if ctx.cr[6].eq {
	pc = 0x82A06E4C; continue 'dispatch;
	}
	// 82A06E2C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A06E30: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A06E34: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A06E38: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A06E3C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A06E40: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A06E44: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A06E48: 4082FFE8  bne 0x82a06e30
	if !ctx.cr[0].eq {
	pc = 0x82A06E30; continue 'dispatch;
	}
	// 82A06E4C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A06E50: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 82A06E54: 486012D5  bl 0x83008128
	ctx.lr = 0x82A06E58;
	sub_83008128(ctx, base);
	// 82A06E58: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A06E5C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A06E60: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A06E64: 388A7F18  addi r4, r10, 0x7f18
	ctx.r[4].s64 = ctx.r[10].s64 + 32536;
	// 82A06E68: 38A0030D  li r5, 0x30d
	ctx.r[5].s64 = 781;
	// 82A06E6C: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82A06E70: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A06E74: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82A06E78: 48451BC9  bl 0x82e58a40
	ctx.lr = 0x82A06E7C;
	sub_82E58A40(ctx, base);
	// 82A06E7C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A06E80: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A06E84: 419A0008  beq cr6, 0x82a06e8c
	if ctx.cr[6].eq {
	pc = 0x82A06E8C; continue 'dispatch;
	}
	// 82A06E88: 4B8B9A09  bl 0x822c0890
	ctx.lr = 0x82A06E8C;
	sub_822C0890(ctx, base);
	// 82A06E8C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A06E90: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A06E94: 419A0008  beq cr6, 0x82a06e9c
	if ctx.cr[6].eq {
	pc = 0x82A06E9C; continue 'dispatch;
	}
	// 82A06E98: 4B8B99F9  bl 0x822c0890
	ctx.lr = 0x82A06E9C;
	sub_822C0890(ctx, base);
	// 82A06E9C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A06EA0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A06EA4: 419A0008  beq cr6, 0x82a06eac
	if ctx.cr[6].eq {
	pc = 0x82A06EAC; continue 'dispatch;
	}
	// 82A06EA8: 4B8B99E9  bl 0x822c0890
	ctx.lr = 0x82A06EAC;
	sub_822C0890(ctx, base);
	// 82A06EAC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A06EB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A06EB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A06EB8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A06EBC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A06EC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A06EC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A06EC8 size=188
    let mut pc: u32 = 0x82A06EC8;
    'dispatch: loop {
        match pc {
            0x82A06EC8 => {
    //   block [0x82A06EC8..0x82A06F84)
	// 82A06EC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A06ECC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A06ED0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A06ED4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A06ED8: 4874D729  bl 0x83154600
	ctx.lr = 0x82A06EDC;
	sub_83154600(ctx, base);
	// 82A06EDC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A06EE0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A06EE4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A06EE8: 997F01F0  stb r11, 0x1f0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(496 as u32), ctx.r[11].u8 ) };
	// 82A06EEC: 997F01F1  stb r11, 0x1f1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(497 as u32), ctx.r[11].u8 ) };
	// 82A06EF0: 4BFFEE99  bl 0x82a05d88
	ctx.lr = 0x82A06EF4;
	sub_82A05D88(ctx, base);
	// 82A06EF4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A06EF8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A06EFC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A06F00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A06F04: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A06F08: 419A0024  beq cr6, 0x82a06f2c
	if ctx.cr[6].eq {
	pc = 0x82A06F2C; continue 'dispatch;
	}
	// 82A06F0C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A06F10: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A06F14: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A06F18: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A06F1C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A06F20: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A06F24: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A06F28: 4082FFE8  bne 0x82a06f10
	if !ctx.cr[0].eq {
	pc = 0x82A06F10; continue 'dispatch;
	}
	// 82A06F2C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A06F30: 80DF01C0  lwz r6, 0x1c0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(448 as u32) ) } as u64;
	// 82A06F34: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A06F38: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82A06F3C: 388A7F18  addi r4, r10, 0x7f18
	ctx.r[4].s64 = ctx.r[10].s64 + 32536;
	// 82A06F40: 38A0034E  li r5, 0x34e
	ctx.r[5].s64 = 846;
	// 82A06F44: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82A06F48: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A06F4C: 48451AF5  bl 0x82e58a40
	ctx.lr = 0x82A06F50;
	sub_82E58A40(ctx, base);
	// 82A06F50: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A06F54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A06F58: 419A0008  beq cr6, 0x82a06f60
	if ctx.cr[6].eq {
	pc = 0x82A06F60; continue 'dispatch;
	}
	// 82A06F5C: 4B8B9935  bl 0x822c0890
	ctx.lr = 0x82A06F60;
	sub_822C0890(ctx, base);
	// 82A06F60: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A06F64: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A06F68: 419A0008  beq cr6, 0x82a06f70
	if ctx.cr[6].eq {
	pc = 0x82A06F70; continue 'dispatch;
	}
	// 82A06F6C: 4B8B9925  bl 0x822c0890
	ctx.lr = 0x82A06F70;
	sub_822C0890(ctx, base);
	// 82A06F70: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A06F74: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A06F78: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A06F7C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A06F80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A06F88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A06F88 size=164
    let mut pc: u32 = 0x82A06F88;
    'dispatch: loop {
        match pc {
            0x82A06F88 => {
    //   block [0x82A06F88..0x82A0702C)
	// 82A06F88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A06F8C: 487A11DD  bl 0x831a8168
	ctx.lr = 0x82A06F90;
	sub_831A8130(ctx, base);
	// 82A06F90: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A06F94: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82A06F98: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A06F9C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A06FA0: 57BC063F  clrlwi. r28, r29, 0x18
	ctx.r[28].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82A06FA4: 41820038  beq 0x82a06fdc
	if ctx.cr[0].eq {
	pc = 0x82A06FDC; continue 'dispatch;
	}
	// 82A06FA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A06FAC: 487A29DD  bl 0x831a9988
	ctx.lr = 0x82A06FB0;
	sub_831A9988(ctx, base);
	// 82A06FB0: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82A06FB4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A06FB8: 386B3984  addi r3, r11, 0x3984
	ctx.r[3].s64 = ctx.r[11].s64 + 14724;
	// 82A06FBC: 487A113D  bl 0x831a80f8
	ctx.lr = 0x82A06FC0;
	sub_831A80F8(ctx, base);
	// 82A06FC0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A06FC4: 41820018  beq 0x82a06fdc
	if ctx.cr[0].eq {
	pc = 0x82A06FDC; continue 'dispatch;
	}
	// 82A06FC8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A06FCC: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A06FD0: 4BFFF159  bl 0x82a06128
	ctx.lr = 0x82A06FD4;
	sub_82A06128(ctx, base);
	// 82A06FD4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A06FD8: 4800004C  b 0x82a07024
	pc = 0x82A07024; continue 'dispatch;
	// 82A06FDC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82A06FE0: 419A0034  beq cr6, 0x82a07014
	if ctx.cr[6].eq {
	pc = 0x82A07014; continue 'dispatch;
	}
	// 82A06FE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A06FE8: 487A29A1  bl 0x831a9988
	ctx.lr = 0x82A06FEC;
	sub_831A9988(ctx, base);
	// 82A06FEC: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 82A06FF0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A06FF4: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 82A06FF8: 487A1101  bl 0x831a80f8
	ctx.lr = 0x82A06FFC;
	sub_831A80F8(ctx, base);
	// 82A06FFC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A07000: 41820014  beq 0x82a07014
	if ctx.cr[0].eq {
	pc = 0x82A07014; continue 'dispatch;
	}
	// 82A07004: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A07008: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A0700C: 4BFFF415  bl 0x82a06420
	ctx.lr = 0x82A07010;
	sub_82A06420(ctx, base);
	// 82A07010: 4BFFFFC4  b 0x82a06fd4
	pc = 0x82A06FD4; continue 'dispatch;
	// 82A07014: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A07018: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0701C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A07020: 4BB0B5F9  bl 0x82512618
	ctx.lr = 0x82A07024;
	sub_82512618(ctx, base);
	// 82A07024: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A07028: 487A1190  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A07030(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A07030 size=668
    let mut pc: u32 = 0x82A07030;
    'dispatch: loop {
        match pc {
            0x82A07030 => {
    //   block [0x82A07030..0x82A072CC)
	// 82A07030: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A07034: 487A1135  bl 0x831a8168
	ctx.lr = 0x82A07038;
	sub_831A8130(ctx, base);
	// 82A07038: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0703C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82A07040: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A07044: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A07048: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82A0704C: 41820038  beq 0x82a07084
	if ctx.cr[0].eq {
	pc = 0x82A07084; continue 'dispatch;
	}
	// 82A07050: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A07054: 487A2935  bl 0x831a9988
	ctx.lr = 0x82A07058;
	sub_831A9988(ctx, base);
	// 82A07058: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82A0705C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A07060: 386B3984  addi r3, r11, 0x3984
	ctx.r[3].s64 = ctx.r[11].s64 + 14724;
	// 82A07064: 487A1095  bl 0x831a80f8
	ctx.lr = 0x82A07068;
	sub_831A80F8(ctx, base);
	// 82A07068: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A0706C: 41820018  beq 0x82a07084
	if ctx.cr[0].eq {
	pc = 0x82A07084; continue 'dispatch;
	}
	// 82A07070: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A07074: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A07078: 4BFFFC39  bl 0x82a06cb0
	ctx.lr = 0x82A0707C;
	sub_82A06CB0(ctx, base);
	// 82A0707C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A07080: 48000244  b 0x82a072c4
	pc = 0x82A072C4; continue 'dispatch;
	// 82A07084: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A07088: 419A022C  beq cr6, 0x82a072b4
	if ctx.cr[6].eq {
	pc = 0x82A072B4; continue 'dispatch;
	}
	// 82A0708C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A07090: 487A28F9  bl 0x831a9988
	ctx.lr = 0x82A07094;
	sub_831A9988(ctx, base);
	// 82A07094: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 82A07098: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A0709C: 386BD9D8  addi r3, r11, -0x2628
	ctx.r[3].s64 = ctx.r[11].s64 + -9768;
	// 82A070A0: 487A1059  bl 0x831a80f8
	ctx.lr = 0x82A070A4;
	sub_831A80F8(ctx, base);
	// 82A070A4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A070A8: 41820014  beq 0x82a070bc
	if ctx.cr[0].eq {
	pc = 0x82A070BC; continue 'dispatch;
	}
	// 82A070AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A070B0: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A070B4: 4BFFD4FD  bl 0x82a045b0
	ctx.lr = 0x82A070B8;
	sub_82A045B0(ctx, base);
	// 82A070B8: 4BFFFFC4  b 0x82a0707c
	pc = 0x82A0707C; continue 'dispatch;
	// 82A070BC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A070C0: 419A01F4  beq cr6, 0x82a072b4
	if ctx.cr[6].eq {
	pc = 0x82A072B4; continue 'dispatch;
	}
	// 82A070C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A070C8: 487A28C1  bl 0x831a9988
	ctx.lr = 0x82A070CC;
	sub_831A9988(ctx, base);
	// 82A070CC: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 82A070D0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A070D4: 386B1FA4  addi r3, r11, 0x1fa4
	ctx.r[3].s64 = ctx.r[11].s64 + 8100;
	// 82A070D8: 487A1021  bl 0x831a80f8
	ctx.lr = 0x82A070DC;
	sub_831A80F8(ctx, base);
	// 82A070DC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A070E0: 41820014  beq 0x82a070f4
	if ctx.cr[0].eq {
	pc = 0x82A070F4; continue 'dispatch;
	}
	// 82A070E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A070E8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A070EC: 4BFFD645  bl 0x82a04730
	ctx.lr = 0x82A070F0;
	sub_82A04730(ctx, base);
	// 82A070F0: 4BFFFF8C  b 0x82a0707c
	pc = 0x82A0707C; continue 'dispatch;
	// 82A070F4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A070F8: 419A01BC  beq cr6, 0x82a072b4
	if ctx.cr[6].eq {
	pc = 0x82A072B4; continue 'dispatch;
	}
	// 82A070FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A07100: 487A2889  bl 0x831a9988
	ctx.lr = 0x82A07104;
	sub_831A9988(ctx, base);
	// 82A07104: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 82A07108: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A0710C: 386B3A18  addi r3, r11, 0x3a18
	ctx.r[3].s64 = ctx.r[11].s64 + 14872;
	// 82A07110: 487A0FE9  bl 0x831a80f8
	ctx.lr = 0x82A07114;
	sub_831A80F8(ctx, base);
	// 82A07114: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A07118: 41820014  beq 0x82a0712c
	if ctx.cr[0].eq {
	pc = 0x82A0712C; continue 'dispatch;
	}
	// 82A0711C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A07120: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A07124: 4BCF90DD  bl 0x82700200
	ctx.lr = 0x82A07128;
	sub_82700200(ctx, base);
	// 82A07128: 4BFFFF54  b 0x82a0707c
	pc = 0x82A0707C; continue 'dispatch;
	// 82A0712C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A07130: 419A0184  beq cr6, 0x82a072b4
	if ctx.cr[6].eq {
	pc = 0x82A072B4; continue 'dispatch;
	}
	// 82A07134: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A07138: 487A2851  bl 0x831a9988
	ctx.lr = 0x82A0713C;
	sub_831A9988(ctx, base);
	// 82A0713C: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 82A07140: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A07144: 386BFE48  addi r3, r11, -0x1b8
	ctx.r[3].s64 = ctx.r[11].s64 + -440;
	// 82A07148: 487A0FB1  bl 0x831a80f8
	ctx.lr = 0x82A0714C;
	sub_831A80F8(ctx, base);
	// 82A0714C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A07150: 41820014  beq 0x82a07164
	if ctx.cr[0].eq {
	pc = 0x82A07164; continue 'dispatch;
	}
	// 82A07154: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A07158: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A0715C: 4BCF910D  bl 0x82700268
	ctx.lr = 0x82A07160;
	sub_82700268(ctx, base);
	// 82A07160: 4BFFFF1C  b 0x82a0707c
	pc = 0x82A0707C; continue 'dispatch;
	// 82A07164: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A07168: 419A014C  beq cr6, 0x82a072b4
	if ctx.cr[6].eq {
	pc = 0x82A072B4; continue 'dispatch;
	}
	// 82A0716C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A07170: 487A2819  bl 0x831a9988
	ctx.lr = 0x82A07174;
	sub_831A9988(ctx, base);
	// 82A07174: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 82A07178: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A0717C: 386BFD00  addi r3, r11, -0x300
	ctx.r[3].s64 = ctx.r[11].s64 + -768;
	// 82A07180: 487A0F79  bl 0x831a80f8
	ctx.lr = 0x82A07184;
	sub_831A80F8(ctx, base);
	// 82A07184: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A07188: 41820014  beq 0x82a0719c
	if ctx.cr[0].eq {
	pc = 0x82A0719C; continue 'dispatch;
	}
	// 82A0718C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A07190: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A07194: 4BFFE585  bl 0x82a05718
	ctx.lr = 0x82A07198;
	sub_82A05718(ctx, base);
	// 82A07198: 4BFFFEE4  b 0x82a0707c
	pc = 0x82A0707C; continue 'dispatch;
	// 82A0719C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A071A0: 419A0114  beq cr6, 0x82a072b4
	if ctx.cr[6].eq {
	pc = 0x82A072B4; continue 'dispatch;
	}
	// 82A071A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A071A8: 487A27E1  bl 0x831a9988
	ctx.lr = 0x82A071AC;
	sub_831A9988(ctx, base);
	// 82A071AC: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 82A071B0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A071B4: 386B39EC  addi r3, r11, 0x39ec
	ctx.r[3].s64 = ctx.r[11].s64 + 14828;
	// 82A071B8: 487A0F41  bl 0x831a80f8
	ctx.lr = 0x82A071BC;
	sub_831A80F8(ctx, base);
	// 82A071BC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A071C0: 41820014  beq 0x82a071d4
	if ctx.cr[0].eq {
	pc = 0x82A071D4; continue 'dispatch;
	}
	// 82A071C4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A071C8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A071CC: 4BCF909D  bl 0x82700268
	ctx.lr = 0x82A071D0;
	sub_82700268(ctx, base);
	// 82A071D0: 4BFFFEAC  b 0x82a0707c
	pc = 0x82A0707C; continue 'dispatch;
	// 82A071D4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A071D8: 419A00DC  beq cr6, 0x82a072b4
	if ctx.cr[6].eq {
	pc = 0x82A072B4; continue 'dispatch;
	}
	// 82A071DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A071E0: 487A27A9  bl 0x831a9988
	ctx.lr = 0x82A071E4;
	sub_831A9988(ctx, base);
	// 82A071E4: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 82A071E8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A071EC: 386B3A44  addi r3, r11, 0x3a44
	ctx.r[3].s64 = ctx.r[11].s64 + 14916;
	// 82A071F0: 487A0F09  bl 0x831a80f8
	ctx.lr = 0x82A071F4;
	sub_831A80F8(ctx, base);
	// 82A071F4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A071F8: 41820014  beq 0x82a0720c
	if ctx.cr[0].eq {
	pc = 0x82A0720C; continue 'dispatch;
	}
	// 82A071FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A07200: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A07204: 4BFFD625  bl 0x82a04828
	ctx.lr = 0x82A07208;
	sub_82A04828(ctx, base);
	// 82A07208: 4BFFFE74  b 0x82a0707c
	pc = 0x82A0707C; continue 'dispatch;
	// 82A0720C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A07210: 419A00A4  beq cr6, 0x82a072b4
	if ctx.cr[6].eq {
	pc = 0x82A072B4; continue 'dispatch;
	}
	// 82A07214: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A07218: 487A2771  bl 0x831a9988
	ctx.lr = 0x82A0721C;
	sub_831A9988(ctx, base);
	// 82A0721C: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A07220: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A07224: 386BE99C  addi r3, r11, -0x1664
	ctx.r[3].s64 = ctx.r[11].s64 + -5732;
	// 82A07228: 487A0ED1  bl 0x831a80f8
	ctx.lr = 0x82A0722C;
	sub_831A80F8(ctx, base);
	// 82A0722C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A07230: 41820014  beq 0x82a07244
	if ctx.cr[0].eq {
	pc = 0x82A07244; continue 'dispatch;
	}
	// 82A07234: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A07238: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A0723C: 4BC3F21D  bl 0x82646458
	ctx.lr = 0x82A07240;
	sub_82646458(ctx, base);
	// 82A07240: 4BFFFE3C  b 0x82a0707c
	pc = 0x82A0707C; continue 'dispatch;
	// 82A07244: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A07248: 419A006C  beq cr6, 0x82a072b4
	if ctx.cr[6].eq {
	pc = 0x82A072B4; continue 'dispatch;
	}
	// 82A0724C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A07250: 487A2739  bl 0x831a9988
	ctx.lr = 0x82A07254;
	sub_831A9988(ctx, base);
	// 82A07254: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82A07258: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A0725C: 386B66B4  addi r3, r11, 0x66b4
	ctx.r[3].s64 = ctx.r[11].s64 + 26292;
	// 82A07260: 487A0E99  bl 0x831a80f8
	ctx.lr = 0x82A07264;
	sub_831A80F8(ctx, base);
	// 82A07264: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A07268: 41820014  beq 0x82a0727c
	if ctx.cr[0].eq {
	pc = 0x82A0727C; continue 'dispatch;
	}
	// 82A0726C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A07270: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A07274: 4BFFD39D  bl 0x82a04610
	ctx.lr = 0x82A07278;
	sub_82A04610(ctx, base);
	// 82A07278: 4BFFFE04  b 0x82a0707c
	pc = 0x82A0707C; continue 'dispatch;
	// 82A0727C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A07280: 419A0034  beq cr6, 0x82a072b4
	if ctx.cr[6].eq {
	pc = 0x82A072B4; continue 'dispatch;
	}
	// 82A07284: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A07288: 487A2701  bl 0x831a9988
	ctx.lr = 0x82A0728C;
	sub_831A9988(ctx, base);
	// 82A0728C: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 82A07290: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A07294: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 82A07298: 487A0E61  bl 0x831a80f8
	ctx.lr = 0x82A0729C;
	sub_831A80F8(ctx, base);
	// 82A0729C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A072A0: 41820014  beq 0x82a072b4
	if ctx.cr[0].eq {
	pc = 0x82A072B4; continue 'dispatch;
	}
	// 82A072A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A072A8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A072AC: 4BFFFB15  bl 0x82a06dc0
	ctx.lr = 0x82A072B0;
	sub_82A06DC0(ctx, base);
	// 82A072B0: 4BFFFDCC  b 0x82a0707c
	pc = 0x82A0707C; continue 'dispatch;
	// 82A072B4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82A072B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A072BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A072C0: 4BB0C9F1  bl 0x82513cb0
	ctx.lr = 0x82A072C4;
	sub_82513CB0(ctx, base);
	// 82A072C4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A072C8: 487A0EF0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A072D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A072D0 size=1068
    let mut pc: u32 = 0x82A072D0;
    'dispatch: loop {
        match pc {
            0x82A072D0 => {
    //   block [0x82A072D0..0x82A076FC)
	// 82A072D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A072D4: 487A0E91  bl 0x831a8164
	ctx.lr = 0x82A072D8;
	sub_831A8130(ctx, base);
	// 82A072D8: DBC1FFC0  stfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 82A072DC: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82A072E0: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A07700(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A07700 size=260
    let mut pc: u32 = 0x82A07700;
    'dispatch: loop {
        match pc {
            0x82A07700 => {
    //   block [0x82A07700..0x82A07804)
	// 82A07700: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A07704: 487A0A65  bl 0x831a8168
	ctx.lr = 0x82A07708;
	sub_831A8130(ctx, base);
	// 82A07708: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0770C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A07710: 4874CEF1  bl 0x83154600
	ctx.lr = 0x82A07714;
	sub_83154600(ctx, base);
	// 82A07714: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A07718: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0771C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A07720: 4BDAEEB9  bl 0x827b65d8
	ctx.lr = 0x82A07724;
	sub_827B65D8(ctx, base);
	// 82A07724: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A07728: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A0772C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A07730: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A07734: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A07738: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A0773C: 4E800421  bctrl
	ctx.lr = 0x82A07740;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A07740: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A07744: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A07748: 419A0008  beq cr6, 0x82a07750
	if ctx.cr[6].eq {
	pc = 0x82A07750; continue 'dispatch;
	}
	// 82A0774C: 4B8B9145  bl 0x822c0890
	ctx.lr = 0x82A07750;
	sub_822C0890(ctx, base);
	// 82A07750: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A07754: 4BA5ED85  bl 0x824664d8
	ctx.lr = 0x82A07758;
	sub_824664D8(ctx, base);
	// 82A07758: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82A0775C: 9061005C  stw r3, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[3].u32 ) };
	// 82A07760: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82A07764: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 82A07768: 807F0290  lwz r3, 0x290(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(656 as u32) ) } as u64;
	// 82A0776C: 4BA8A80D  bl 0x82491f78
	ctx.lr = 0x82A07770;
	sub_82491F78(ctx, base);
	// 82A07770: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82A07774: 83DF0290  lwz r30, 0x290(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(656 as u32) ) } as u64;
	// 82A07778: 48601841  bl 0x83008fb8
	ctx.lr = 0x82A0777C;
	sub_83008FB8(ctx, base);
	// 82A0777C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A07780: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A07784: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A07788: 4BA8A7C9  bl 0x82491f50
	ctx.lr = 0x82A0778C;
	sub_82491F50(ctx, base);
	// 82A0778C: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A07790: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A07794: 48000030  b 0x82a077c4
	pc = 0x82A077C4; continue 'dispatch;
	// 82A07798: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A0779C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A077A0: 419A001C  beq cr6, 0x82a077bc
	if ctx.cr[6].eq {
	pc = 0x82A077BC; continue 'dispatch;
	}
	// 82A077A4: 5563003E  slwi r3, r11, 0
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82A077A8: 4BDD2829  bl 0x827d9fd0
	ctx.lr = 0x82A077AC;
	sub_827D9FD0(ctx, base);
	// 82A077AC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A077B0: 4182000C  beq 0x82a077bc
	if ctx.cr[0].eq {
	pc = 0x82A077BC; continue 'dispatch;
	}
	// 82A077B4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A077B8: 917F0268  stw r11, 0x268(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(616 as u32), ctx.r[11].u32 ) };
	// 82A077BC: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A077C0: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A077C4: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A077C8: 409AFFD0  bne cr6, 0x82a07798
	if !ctx.cr[6].eq {
	pc = 0x82A07798; continue 'dispatch;
	}
	// 82A077CC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A077D0: 4BA20EB1  bl 0x82428680
	ctx.lr = 0x82A077D4;
	sub_82428680(ctx, base);
	// 82A077D4: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82A077D8: 8081005C  lwz r4, 0x5c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A077DC: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 82A077E0: 483EA9A9  bl 0x82df2188
	ctx.lr = 0x82A077E4;
	sub_82DF2188(ctx, base);
	// 82A077E4: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 82A077E8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A077EC: 48451F8D  bl 0x82e59778
	ctx.lr = 0x82A077F0;
	sub_82E59778(ctx, base);
	// 82A077F0: C01F01F4  lfs f0, 0x1f4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(500 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A077F4: EC000828  fsubs f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 82A077F8: D01F01F4  stfs f0, 0x1f4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(500 as u32), tmp.u32 ) };
	// 82A077FC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A07800: 487A09B8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A07808(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A07808 size=808
    let mut pc: u32 = 0x82A07808;
    'dispatch: loop {
        match pc {
            0x82A07808 => {
    //   block [0x82A07808..0x82A07B30)
	// 82A07808: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0780C: 487A0955  bl 0x831a8160
	ctx.lr = 0x82A07810;
	sub_831A8130(ctx, base);
	// 82A07810: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 82A07814: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A07818: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A0781C: 4874CDE5  bl 0x83154600
	ctx.lr = 0x82A07820;
	sub_83154600(ctx, base);
	// 82A07820: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A07824: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A07828: 48451F51  bl 0x82e59778
	ctx.lr = 0x82A0782C;
	sub_82E59778(ctx, base);
	// 82A0782C: C01F01F4  lfs f0, 0x1f4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(500 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A07830: EC000828  fsubs f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 82A07834: D01F01F4  stfs f0, 0x1f4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(500 as u32), tmp.u32 ) };
	// 82A07838: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A0783C: 48451F3D  bl 0x82e59778
	ctx.lr = 0x82A07840;
	sub_82E59778(ctx, base);
	// 82A07840: C01C0068  lfs f0, 0x68(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A07844: EDA10032  fmuls f13, f1, f0
	ctx.f[13].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A07848: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A0784C: C19C0064  lfs f12, 0x64(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(100 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A07850: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A07854: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A07858: C00B093C  lfs f0, 0x93c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2364 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A0785C: C3EA08A8  lfs f31, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A07860: EC0D603A  fmadds f0, f13, f0, f12
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 82A07864: D01C0064  stfs f0, 0x64(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82A07868: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82A0786C: 4198008C  blt cr6, 0x82a078f8
	if ctx.cr[6].lt {
	pc = 0x82A078F8; continue 'dispatch;
	}
	// 82A07870: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82A07874: 4BDAED65  bl 0x827b65d8
	ctx.lr = 0x82A07878;
	sub_827B65D8(ctx, base);
	// 82A07878: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A0787C: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82A07880: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A07884: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A07888: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A0788C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A07890: 4E800421  bctrl
	ctx.lr = 0x82A07894;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A07894: 3BDC0080  addi r30, r28, 0x80
	ctx.r[30].s64 = ctx.r[28].s64 + 128;
	// 82A07898: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82A0789C: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A078A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A07B30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A07B30 size=92
    let mut pc: u32 = 0x82A07B30;
    'dispatch: loop {
        match pc {
            0x82A07B30 => {
    //   block [0x82A07B30..0x82A07B8C)
	// 82A07B30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A07B34: 487A0639  bl 0x831a816c
	ctx.lr = 0x82A07B38;
	sub_831A8130(ctx, base);
	// 82A07B38: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A07B3C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A07B40: 3D4082A0  lis r10, -0x7d60
	ctx.r[10].s64 = -2103443456;
	// 82A07B44: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A07B48: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A07B4C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A07B50: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A07B54: 388A5E08  addi r4, r10, 0x5e08
	ctx.r[4].s64 = ctx.r[10].s64 + 24072;
	// 82A07B58: 4B957F19  bl 0x8235fa70
	ctx.lr = 0x82A07B5C;
	sub_8235FA70(ctx, base);
	// 82A07B5C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A07B60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A07B64: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82A07B68: 483EC099  bl 0x82df3c00
	ctx.lr = 0x82A07B6C;
	sub_82DF3C00(ctx, base);
	// 82A07B6C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A07B70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A07B74: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A07B78: 484545E1  bl 0x82e5c158
	ctx.lr = 0x82A07B7C;
	sub_82E5C158(ctx, base);
	// 82A07B7C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A07B80: 483EB8A9  bl 0x82df3428
	ctx.lr = 0x82A07B84;
	sub_82DF3428(ctx, base);
	// 82A07B84: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A07B88: 487A0634  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A07B90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A07B90 size=92
    let mut pc: u32 = 0x82A07B90;
    'dispatch: loop {
        match pc {
            0x82A07B90 => {
    //   block [0x82A07B90..0x82A07BEC)
	// 82A07B90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A07B94: 487A05D9  bl 0x831a816c
	ctx.lr = 0x82A07B98;
	sub_831A8130(ctx, base);
	// 82A07B98: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A07B9C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A07BA0: 3D4082A0  lis r10, -0x7d60
	ctx.r[10].s64 = -2103443456;
	// 82A07BA4: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A07BA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A07BAC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A07BB0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A07BB4: 388A5E88  addi r4, r10, 0x5e88
	ctx.r[4].s64 = ctx.r[10].s64 + 24200;
	// 82A07BB8: 4B957EB9  bl 0x8235fa70
	ctx.lr = 0x82A07BBC;
	sub_8235FA70(ctx, base);
	// 82A07BBC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A07BC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A07BC4: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82A07BC8: 483EC039  bl 0x82df3c00
	ctx.lr = 0x82A07BCC;
	sub_82DF3C00(ctx, base);
	// 82A07BCC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A07BD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A07BD4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A07BD8: 48454581  bl 0x82e5c158
	ctx.lr = 0x82A07BDC;
	sub_82E5C158(ctx, base);
	// 82A07BDC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A07BE0: 483EB849  bl 0x82df3428
	ctx.lr = 0x82A07BE4;
	sub_82DF3428(ctx, base);
	// 82A07BE4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A07BE8: 487A05D4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A07BF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A07BF0 size=92
    let mut pc: u32 = 0x82A07BF0;
    'dispatch: loop {
        match pc {
            0x82A07BF0 => {
    //   block [0x82A07BF0..0x82A07C4C)
	// 82A07BF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A07BF4: 487A0579  bl 0x831a816c
	ctx.lr = 0x82A07BF8;
	sub_831A8130(ctx, base);
	// 82A07BF8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A07BFC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A07C00: 3D4082A0  lis r10, -0x7d60
	ctx.r[10].s64 = -2103443456;
	// 82A07C04: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A07C08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A07C0C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A07C10: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A07C14: 388A5F08  addi r4, r10, 0x5f08
	ctx.r[4].s64 = ctx.r[10].s64 + 24328;
	// 82A07C18: 4B957E59  bl 0x8235fa70
	ctx.lr = 0x82A07C1C;
	sub_8235FA70(ctx, base);
	// 82A07C1C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A07C20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A07C24: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82A07C28: 483EBFD9  bl 0x82df3c00
	ctx.lr = 0x82A07C2C;
	sub_82DF3C00(ctx, base);
	// 82A07C2C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A07C30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A07C34: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A07C38: 48454521  bl 0x82e5c158
	ctx.lr = 0x82A07C3C;
	sub_82E5C158(ctx, base);
	// 82A07C3C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A07C40: 483EB7E9  bl 0x82df3428
	ctx.lr = 0x82A07C44;
	sub_82DF3428(ctx, base);
	// 82A07C44: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A07C48: 487A0574  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A07C50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A07C50 size=92
    let mut pc: u32 = 0x82A07C50;
    'dispatch: loop {
        match pc {
            0x82A07C50 => {
    //   block [0x82A07C50..0x82A07CAC)
	// 82A07C50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A07C54: 487A0519  bl 0x831a816c
	ctx.lr = 0x82A07C58;
	sub_831A8130(ctx, base);
	// 82A07C58: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A07C5C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A07C60: 3D4082A0  lis r10, -0x7d60
	ctx.r[10].s64 = -2103443456;
	// 82A07C64: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A07C68: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A07C6C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A07C70: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A07C74: 388A5F88  addi r4, r10, 0x5f88
	ctx.r[4].s64 = ctx.r[10].s64 + 24456;
	// 82A07C78: 4B957DF9  bl 0x8235fa70
	ctx.lr = 0x82A07C7C;
	sub_8235FA70(ctx, base);
	// 82A07C7C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A07C80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A07C84: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82A07C88: 483EBF79  bl 0x82df3c00
	ctx.lr = 0x82A07C8C;
	sub_82DF3C00(ctx, base);
	// 82A07C8C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A07C90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A07C94: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A07C98: 484544C1  bl 0x82e5c158
	ctx.lr = 0x82A07C9C;
	sub_82E5C158(ctx, base);
	// 82A07C9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A07CA0: 483EB789  bl 0x82df3428
	ctx.lr = 0x82A07CA4;
	sub_82DF3428(ctx, base);
	// 82A07CA4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A07CA8: 487A0514  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A07CB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A07CB0 size=1536
    let mut pc: u32 = 0x82A07CB0;
    'dispatch: loop {
        match pc {
            0x82A07CB0 => {
    //   block [0x82A07CB0..0x82A082B0)
	// 82A07CB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A07CB4: 487A04A1  bl 0x831a8154
	ctx.lr = 0x82A07CB8;
	sub_831A8130(ctx, base);
	// 82A07CB8: DBE1FFA8  stfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 82A07CBC: 9421FDD0  stwu r1, -0x230(r1)
	ea = ctx.r[1].u32.wrapping_add(-560 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A07CC0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A07CC4: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82A07CC8: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82A07CCC: 4BB09D0D  bl 0x825119d8
	ctx.lr = 0x82A07CD0;
	sub_825119D8(ctx, base);
	// 82A07CD0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A07CD4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A07CD8: 4BB07699  bl 0x8250f370
	ctx.lr = 0x82A07CDC;
	sub_8250F370(ctx, base);
	// 82A07CDC: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82A07CE0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A07CE4: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 82A07CE8: 483EBD21  bl 0x82df3a08
	ctx.lr = 0x82A07CEC;
	sub_82DF3A08(ctx, base);
	// 82A07CEC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82A07CF0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A07CF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A07CF8: 4BB00A89  bl 0x82508780
	ctx.lr = 0x82A07CFC;
	sub_82508780(ctx, base);
	// 82A07CFC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A07D00: 483EB729  bl 0x82df3428
	ctx.lr = 0x82A07D04;
	sub_82DF3428(ctx, base);
	// 82A07D04: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 82A07D08: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82A07D0C: 389C0028  addi r4, r28, 0x28
	ctx.r[4].s64 = ctx.r[28].s64 + 40;
	// 82A07D10: 409A0008  bne cr6, 0x82a07d18
	if !ctx.cr[6].eq {
	pc = 0x82A07D18; continue 'dispatch;
	}
	// 82A07D14: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82A07D18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A07D1C: 4BB00A85  bl 0x825087a0
	ctx.lr = 0x82A07D20;
	sub_825087A0(ctx, base);
	// 82A07D20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A07D24: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A07D28: 48422DC1  bl 0x82e2aae8
	ctx.lr = 0x82A07D2C;
	sub_82E2AAE8(ctx, base);
	// 82A07D2C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A07D30: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A07D34: 388B8014  addi r4, r11, -0x7fec
	ctx.r[4].s64 = ctx.r[11].s64 + -32748;
	// 82A07D38: 483EBCD1  bl 0x82df3a08
	ctx.lr = 0x82A07D3C;
	sub_82DF3A08(ctx, base);
	// 82A07D3C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A07D40: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82A07D44: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A07D48: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A07D4C: 48427125  bl 0x82e2ee70
	ctx.lr = 0x82A07D50;
	sub_82E2EE70(ctx, base);
	// 82A07D50: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A07D54: 483EB6D5  bl 0x82df3428
	ctx.lr = 0x82A07D58;
	sub_82DF3428(ctx, base);
	// 82A07D58: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A07D5C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A07D60: 3AEB7F18  addi r23, r11, 0x7f18
	ctx.r[23].s64 = ctx.r[11].s64 + 32536;
	// 82A07D64: C3EA08A4  lfs f31, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A07D68: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 82A07D6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A07D70: 419A00F4  beq cr6, 0x82a07e64
	if ctx.cr[6].eq {
	pc = 0x82A07E64; continue 'dispatch;
	}
	// 82A07D74: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 82A07D78: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A07D7C: 38A000AF  li r5, 0xaf
	ctx.r[5].s64 = 175;
	// 82A07D80: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 82A07D84: 483EA665  bl 0x82df23e8
	ctx.lr = 0x82A07D88;
	sub_82DF23E8(ctx, base);
	// 82A07D88: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A07D8C: 41820014  beq 0x82a07da0
	if ctx.cr[0].eq {
	pc = 0x82A07DA0; continue 'dispatch;
	}
	// 82A07D90: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 82A07D94: 4840EAFD  bl 0x82e16890
	ctx.lr = 0x82A07D98;
	sub_82E16890(ctx, base);
	// 82A07D98: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A07D9C: 48000008  b 0x82a07da4
	pc = 0x82A07DA4; continue 'dispatch;
	// 82A07DA0: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82A07DA4: 387C00EC  addi r3, r28, 0xec
	ctx.r[3].s64 = ctx.r[28].s64 + 236;
	// 82A07DA8: 4B9555C9  bl 0x8235d370
	ctx.lr = 0x82A07DAC;
	sub_8235D370(ctx, base);
	// 82A07DAC: 38610190  addi r3, r1, 0x190
	ctx.r[3].s64 = ctx.r[1].s64 + 400;
	// 82A07DB0: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82A07DB4: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82A07DB8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A07DBC: 83FC00EC  lwz r31, 0xec(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(236 as u32) ) } as u64;
	// 82A07DC0: 484741B1  bl 0x82e7bf70
	ctx.lr = 0x82A07DC4;
	sub_82E7BF70(ctx, base);
	// 82A07DC4: 815F0084  lwz r10, 0x84(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 82A07DC8: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A07DCC: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 82A07DD0: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 82A07DD4: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 82A07DD8: 396A0010  addi r11, r10, 0x10
	ctx.r[11].s64 = ctx.r[10].s64 + 16;
	// 82A07DDC: 13E03407  vcmpneb. (lvlx128) v31, v0, v6
	tmp.u32 = ctx.r[6].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A07DE0: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 82A07DE4: 13C73407  vcmpneb. (lvlx128) v30, v7, v6
	tmp.u32 = ctx.r[7].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A07DE8: 13A83407  vcmpneb. (lvlx128) v29, v8, v6
	tmp.u32 = ctx.r[8].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A07DEC: 13893407  vcmpneb. (lvlx128) v28, v9, v6
	tmp.u32 = ctx.r[9].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A082B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A082B0 size=1232
    let mut pc: u32 = 0x82A082B0;
    'dispatch: loop {
        match pc {
            0x82A082B0 => {
    //   block [0x82A082B0..0x82A08780)
	// 82A082B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A082B4: 4879FEA1  bl 0x831a8154
	ctx.lr = 0x82A082B8;
	sub_831A8130(ctx, base);
	// 82A082B8: DBC1FFA0  stfd f30, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[30].u64 ) };
	// 82A082BC: DBE1FFA8  stfd f31, -0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 82A082C0: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A082C4: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82A082C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A082CC: 93610060  stw r27, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[27].u32 ) };
	// 82A082D0: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 82A082D4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82A082D8: 4BB0BF99  bl 0x82514270
	ctx.lr = 0x82A082DC;
	sub_82514270(ctx, base);
	// 82A082DC: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82A082E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A082E4: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 82A082E8: 483EB721  bl 0x82df3a08
	ctx.lr = 0x82A082EC;
	sub_82DF3A08(ctx, base);
	// 82A082EC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A082F0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A082F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A082F8: 4BB00489  bl 0x82508780
	ctx.lr = 0x82A082FC;
	sub_82508780(ctx, base);
	// 82A082FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A08300: 483EB129  bl 0x82df3428
	ctx.lr = 0x82A08304;
	sub_82DF3428(ctx, base);
	// 82A08304: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A08308: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 82A0830C: 409A0008  bne cr6, 0x82a08314
	if !ctx.cr[6].eq {
	pc = 0x82A08314; continue 'dispatch;
	}
	// 82A08310: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A08314: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A08318: 4BB00489  bl 0x825087a0
	ctx.lr = 0x82A0831C;
	sub_825087A0(ctx, base);
	// 82A0831C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A08320: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A08324: 4BDAE2B5  bl 0x827b65d8
	ctx.lr = 0x82A08328;
	sub_827B65D8(ctx, base);
	// 82A08328: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0832C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A08330: 83CB0008  lwz r30, 8(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A08334: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A08338: 419A000C  beq cr6, 0x82a08344
	if ctx.cr[6].eq {
	pc = 0x82A08344; continue 'dispatch;
	}
	// 82A0833C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A08340: 484C64C1  bl 0x82ece800
	ctx.lr = 0x82A08344;
	sub_82ECE800(ctx, base);
	// 82A08344: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A08348: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0834C: 419A0008  beq cr6, 0x82a08354
	if ctx.cr[6].eq {
	pc = 0x82A08354; continue 'dispatch;
	}
	// 82A08350: 4B8B8541  bl 0x822c0890
	ctx.lr = 0x82A08354;
	sub_822C0890(ctx, base);
	// 82A08354: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A08358: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A0835C: 4BDAE27D  bl 0x827b65d8
	ctx.lr = 0x82A08360;
	sub_827B65D8(ctx, base);
	// 82A08360: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82A08364: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A08368: 808B6830  lwz r4, 0x6830(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26672 as u32) ) } as u64;
	// 82A0836C: 4BA87035  bl 0x8248f3a0
	ctx.lr = 0x82A08370;
	sub_8248F3A0(ctx, base);
	// 82A08370: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A08374: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A08378: 419A0008  beq cr6, 0x82a08380
	if ctx.cr[6].eq {
	pc = 0x82A08380; continue 'dispatch;
	}
	// 82A0837C: 4B8B8515  bl 0x822c0890
	ctx.lr = 0x82A08380;
	sub_822C0890(ctx, base);
	// 82A08380: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A08384: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A08388: 4BDAE251  bl 0x827b65d8
	ctx.lr = 0x82A0838C;
	sub_827B65D8(ctx, base);
	// 82A0838C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A08390: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82A08394: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A08398: C3CA964C  lfs f30, -0x69b4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82A0839C: D3CB0184  stfs f30, 0x184(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 82A083A0: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82A083A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A083A8: 419A0008  beq cr6, 0x82a083b0
	if ctx.cr[6].eq {
	pc = 0x82A083B0; continue 'dispatch;
	}
	// 82A083AC: 4B8B84E5  bl 0x822c0890
	ctx.lr = 0x82A083B0;
	sub_822C0890(ctx, base);
	// 82A083B0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A083B4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A083B8: 4BDAE221  bl 0x827b65d8
	ctx.lr = 0x82A083BC;
	sub_827B65D8(ctx, base);
	// 82A083BC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A083C0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A083C4: D3CB0188  stfs f30, 0x188(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 82A083C8: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82A083CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A083D0: 419A0008  beq cr6, 0x82a083d8
	if ctx.cr[6].eq {
	pc = 0x82A083D8; continue 'dispatch;
	}
	// 82A083D4: 4B8B84BD  bl 0x822c0890
	ctx.lr = 0x82A083D8;
	sub_822C0890(ctx, base);
	// 82A083D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A083DC: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82A083E0: 4BDAE1F9  bl 0x827b65d8
	ctx.lr = 0x82A083E4;
	sub_827B65D8(ctx, base);
	// 82A083E4: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82A083E8: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A083EC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A083F0: C3EB6218  lfs f31, 0x6218(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(25112 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A083F4: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82A083F8: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A083FC: 386B018C  addi r3, r11, 0x18c
	ctx.r[3].s64 = ctx.r[11].s64 + 396;
	// 82A08400: 4849F651  bl 0x82ea7a50
	ctx.lr = 0x82A08404;
	sub_82EA7A50(ctx, base);
	// 82A08404: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82A08408: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0840C: 419A0008  beq cr6, 0x82a08414
	if ctx.cr[6].eq {
	pc = 0x82A08414; continue 'dispatch;
	}
	// 82A08410: 4B8B8481  bl 0x822c0890
	ctx.lr = 0x82A08414;
	sub_822C0890(ctx, base);
	// 82A08414: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A08418: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82A0841C: 4BDAE1BD  bl 0x827b65d8
	ctx.lr = 0x82A08420;
	sub_827B65D8(ctx, base);
	// 82A08420: D3E10050  stfs f31, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82A08424: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A08428: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A0842C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A08430: 386B018D  addi r3, r11, 0x18d
	ctx.r[3].s64 = ctx.r[11].s64 + 397;
	// 82A08434: 4849F61D  bl 0x82ea7a50
	ctx.lr = 0x82A08438;
	sub_82EA7A50(ctx, base);
	// 82A08438: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82A0843C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A08440: 419A0008  beq cr6, 0x82a08448
	if ctx.cr[6].eq {
	pc = 0x82A08448; continue 'dispatch;
	}
	// 82A08444: 4B8B844D  bl 0x822c0890
	ctx.lr = 0x82A08448;
	sub_822C0890(ctx, base);
	// 82A08448: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0844C: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82A08450: 4BDAE189  bl 0x827b65d8
	ctx.lr = 0x82A08454;
	sub_827B65D8(ctx, base);
	// 82A08454: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A08458: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A0845C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82A08460: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 82A08464: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A08468: 484C3729  bl 0x82ecbb90
	ctx.lr = 0x82A0846C;
	sub_82ECBB90(ctx, base);
	// 82A0846C: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82A08470: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A08474: 419A0008  beq cr6, 0x82a0847c
	if ctx.cr[6].eq {
	pc = 0x82A0847C; continue 'dispatch;
	}
	// 82A08478: 4B8B8419  bl 0x822c0890
	ctx.lr = 0x82A0847C;
	sub_822C0890(ctx, base);
	// 82A0847C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A08480: 419A000C  beq cr6, 0x82a0848c
	if ctx.cr[6].eq {
	pc = 0x82A0848C; continue 'dispatch;
	}
	// 82A08484: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A08488: 484C4B81  bl 0x82ecd008
	ctx.lr = 0x82A0848C;
	sub_82ECD008(ctx, base);
	// 82A0848C: 817F0160  lwz r11, 0x160(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 82A08490: 3BDF0160  addi r30, r31, 0x160
	ctx.r[30].s64 = ctx.r[31].s64 + 352;
	// 82A08494: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A08498: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A0849C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A084A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A084A4: 4E800421  bctrl
	ctx.lr = 0x82A084A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A084A8: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 82A084AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A084B0: 3BABF9A0  addi r29, r11, -0x660
	ctx.r[29].s64 = ctx.r[11].s64 + -1632;
	// 82A084B4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A084B8: 483EB551  bl 0x82df3a08
	ctx.lr = 0x82A084BC;
	sub_82DF3A08(ctx, base);
	// 82A084BC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A084C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A084C4: 4BFFF66D  bl 0x82a07b30
	ctx.lr = 0x82A084C8;
	sub_82A07B30(ctx, base);
	// 82A084C8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82A084CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A084D0: 388B0380  addi r4, r11, 0x380
	ctx.r[4].s64 = ctx.r[11].s64 + 896;
	// 82A084D4: 483EB535  bl 0x82df3a08
	ctx.lr = 0x82A084D8;
	sub_82DF3A08(ctx, base);
	// 82A084D8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A084DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A084E0: 4BFFF6B1  bl 0x82a07b90
	ctx.lr = 0x82A084E4;
	sub_82A07B90(ctx, base);
	// 82A084E4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82A084E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A084EC: 388B039C  addi r4, r11, 0x39c
	ctx.r[4].s64 = ctx.r[11].s64 + 924;
	// 82A084F0: 483EB519  bl 0x82df3a08
	ctx.lr = 0x82A084F4;
	sub_82DF3A08(ctx, base);
	// 82A084F4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A084F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A084FC: 4BFFF6F5  bl 0x82a07bf0
	ctx.lr = 0x82A08500;
	sub_82A07BF0(ctx, base);
	// 82A08500: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82A08504: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A08508: 388B03A4  addi r4, r11, 0x3a4
	ctx.r[4].s64 = ctx.r[11].s64 + 932;
	// 82A0850C: 483EB4FD  bl 0x82df3a08
	ctx.lr = 0x82A08510;
	sub_82DF3A08(ctx, base);
	// 82A08510: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A08514: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A08518: 4BFFF739  bl 0x82a07c50
	ctx.lr = 0x82A0851C;
	sub_82A07C50(ctx, base);
	// 82A0851C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A08520: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A08524: 483EB4E5  bl 0x82df3a08
	ctx.lr = 0x82A08528;
	sub_82DF3A08(ctx, base);
	// 82A08528: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A0852C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A08530: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A08534: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82A08538: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A0853C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A08540: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A08544: 4845641D  bl 0x82e5e960
	ctx.lr = 0x82A08548;
	sub_82E5E960(ctx, base);
	// 82A08548: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82A0854C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A08550: 419A0008  beq cr6, 0x82a08558
	if ctx.cr[6].eq {
	pc = 0x82A08558; continue 'dispatch;
	}
	// 82A08554: 4B8B833D  bl 0x822c0890
	ctx.lr = 0x82A08558;
	sub_822C0890(ctx, base);
	// 82A08558: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A0855C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A08560: 3B2B7F18  addi r25, r11, 0x7f18
	ctx.r[25].s64 = ctx.r[11].s64 + 32536;
	// 82A08564: 38A0023B  li r5, 0x23b
	ctx.r[5].s64 = 571;
	// 82A08568: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82A0856C: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 82A08570: 4B8B7E69  bl 0x822c03d8
	ctx.lr = 0x82A08574;
	sub_822C03D8(ctx, base);
	// 82A08574: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A08578: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 82A0857C: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82A08580: 3B400020  li r26, 0x20
	ctx.r[26].s64 = 32;
	// 82A08584: 3BAB6910  addi r29, r11, 0x6910
	ctx.r[29].s64 = ctx.r[11].s64 + 26896;
	// 82A08588: 3B8ABA80  addi r28, r10, -0x4580
	ctx.r[28].s64 = ctx.r[10].s64 + -17792;
	// 82A0858C: 41820090  beq 0x82a0861c
	if ctx.cr[0].eq {
	pc = 0x82A0861C; continue 'dispatch;
	}
	// 82A08590: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A08594: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 82A08598: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 82A0859C: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 82A085A0: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82A085A4: 4849818D  bl 0x82ea0730
	ctx.lr = 0x82A085A8;
	sub_82EA0730(ctx, base);
	// 82A085A8: B3430004  sth r26, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[26].u16 ) };
	// 82A085AC: C03F0278  lfs f1, 0x278(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(632 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A085B0: 48511C41  bl 0x82f1a1f0
	ctx.lr = 0x82A085B4;
	sub_82F1A1F0(ctx, base);
	// 82A085B4: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 82A085B8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82A085BC: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82A085C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A085C4: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 82A085C8: 80AB67D4  lwz r5, 0x67d4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26580 as u32) ) } as u64;
	// 82A085CC: 808A6834  lwz r4, 0x6834(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(26676 as u32) ) } as u64;
	// 82A085D0: 4B8EF1D1  bl 0x822f77a0
	ctx.lr = 0x82A085D4;
	sub_822F77A0(ctx, base);
	// 82A085D4: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 82A085D8: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82A085DC: 4B8DC8E5  bl 0x822e4ec0
	ctx.lr = 0x82A085E0;
	sub_822E4EC0(ctx, base);
	// 82A085E0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82A085E4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A085E8: E8970000  ld r4, 0(r23)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) };
	// 82A085EC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A085F0: E8630000  ld r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 82A085F4: 4BA83C95  bl 0x8248c288
	ctx.lr = 0x82A085F8;
	sub_8248C288(ctx, base);
	// 82A085F8: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 82A085FC: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82A08600: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82A08604: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82A08608: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82A0860C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A08610: 4BA89B91  bl 0x824921a0
	ctx.lr = 0x82A08614;
	sub_824921A0(ctx, base);
	// 82A08614: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A08618: 48000008  b 0x82a08620
	pc = 0x82A08620; continue 'dispatch;
	// 82A0861C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A08620: 387F0290  addi r3, r31, 0x290
	ctx.r[3].s64 = ctx.r[31].s64 + 656;
	// 82A08624: 4B8DC7C5  bl 0x822e4de8
	ctx.lr = 0x82A08628;
	sub_822E4DE8(ctx, base);
	// 82A08628: 576B07FF  clrlwi. r11, r27, 0x1f
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A0862C: 41820018  beq 0x82a08644
	if ctx.cr[0].eq {
	pc = 0x82A08644; continue 'dispatch;
	}
	// 82A08630: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A08634: 577B003C  rlwinm r27, r27, 0, 0, 0x1e
	ctx.r[27].u64 = ctx.r[27].u32 as u64 & 0xFFFFFFFFu64;
	// 82A08638: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0863C: 419A0008  beq cr6, 0x82a08644
	if ctx.cr[6].eq {
	pc = 0x82A08644; continue 'dispatch;
	}
	// 82A08640: 4B8DFC29  bl 0x822e8268
	ctx.lr = 0x82A08644;
	sub_822E8268(ctx, base);
	// 82A08644: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82A08648: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A0864C: 38A00243  li r5, 0x243
	ctx.r[5].s64 = 579;
	// 82A08650: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 82A08654: 4B8B7D85  bl 0x822c03d8
	ctx.lr = 0x82A08658;
	sub_822C03D8(ctx, base);
	// 82A08658: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82A0865C: 41820058  beq 0x82a086b4
	if ctx.cr[0].eq {
	pc = 0x82A086B4; continue 'dispatch;
	}
	// 82A08660: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A08664: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 82A08668: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 82A0866C: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 82A08670: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82A08674: 484980BD  bl 0x82ea0730
	ctx.lr = 0x82A08678;
	sub_82EA0730(ctx, base);
	// 82A08678: B3430004  sth r26, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[26].u16 ) };
	// 82A0867C: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82A08680: 48511B71  bl 0x82f1a1f0
	ctx.lr = 0x82A08684;
	sub_82F1A1F0(ctx, base);
	// 82A08684: 9061005C  stw r3, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[3].u32 ) };
	// 82A08688: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82A0868C: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82A08690: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82A08694: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 82A08698: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82A0869C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A086A0: 810B6814  lwz r8, 0x6814(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26644 as u32) ) } as u64;
	// 82A086A4: 637B0002  ori r27, r27, 2
	ctx.r[27].u64 = ctx.r[27].u64 | 2;
	// 82A086A8: 4BA89AF9  bl 0x824921a0
	ctx.lr = 0x82A086AC;
	sub_824921A0(ctx, base);
	// 82A086AC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A086B0: 48000008  b 0x82a086b8
	pc = 0x82A086B8; continue 'dispatch;
	// 82A086B4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A086B8: 387F0298  addi r3, r31, 0x298
	ctx.r[3].s64 = ctx.r[31].s64 + 664;
	// 82A086BC: 4B8DC72D  bl 0x822e4de8
	ctx.lr = 0x82A086C0;
	sub_822E4DE8(ctx, base);
	// 82A086C0: 576B07BD  rlwinm. r11, r27, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A086C4: 41820018  beq 0x82a086dc
	if ctx.cr[0].eq {
	pc = 0x82A086DC; continue 'dispatch;
	}
	// 82A086C8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A086CC: 577B07FA  rlwinm r27, r27, 0, 0x1f, 0x1d
	ctx.r[27].u64 = ctx.r[27].u32 as u64 & 0xFFFFFFFFu64;
	// 82A086D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A086D4: 419A0008  beq cr6, 0x82a086dc
	if ctx.cr[6].eq {
	pc = 0x82A086DC; continue 'dispatch;
	}
	// 82A086D8: 4B8DFB91  bl 0x822e8268
	ctx.lr = 0x82A086DC;
	sub_822E8268(ctx, base);
	// 82A086DC: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82A086E0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A086E4: 38A0024B  li r5, 0x24b
	ctx.r[5].s64 = 587;
	// 82A086E8: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 82A086EC: 4B8B7CED  bl 0x822c03d8
	ctx.lr = 0x82A086F0;
	sub_822C03D8(ctx, base);
	// 82A086F0: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82A086F4: 41820058  beq 0x82a0874c
	if ctx.cr[0].eq {
	pc = 0x82A0874C; continue 'dispatch;
	}
	// 82A086F8: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A086FC: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 82A08700: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 82A08704: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 82A08708: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82A0870C: 48498025  bl 0x82ea0730
	ctx.lr = 0x82A08710;
	sub_82EA0730(ctx, base);
	// 82A08710: B3430004  sth r26, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[26].u16 ) };
	// 82A08714: C03F027C  lfs f1, 0x27c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(636 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A08718: 48511AD9  bl 0x82f1a1f0
	ctx.lr = 0x82A0871C;
	sub_82F1A1F0(ctx, base);
	// 82A0871C: 90610060  stw r3, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 82A08720: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82A08724: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82A08728: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82A0872C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82A08730: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82A08734: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A08738: 810B671C  lwz r8, 0x671c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26396 as u32) ) } as u64;
	// 82A0873C: 637B0004  ori r27, r27, 4
	ctx.r[27].u64 = ctx.r[27].u64 | 4;
	// 82A08740: 4BA89A61  bl 0x824921a0
	ctx.lr = 0x82A08744;
	sub_824921A0(ctx, base);
	// 82A08744: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A08748: 48000008  b 0x82a08750
	pc = 0x82A08750; continue 'dispatch;
	// 82A0874C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A08750: 387F02A0  addi r3, r31, 0x2a0
	ctx.r[3].s64 = ctx.r[31].s64 + 672;
	// 82A08754: 4B8DC695  bl 0x822e4de8
	ctx.lr = 0x82A08758;
	sub_822E4DE8(ctx, base);
	// 82A08758: 576B077B  rlwinm. r11, r27, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A0875C: 41820014  beq 0x82a08770
	if ctx.cr[0].eq {
	pc = 0x82A08770; continue 'dispatch;
	}
	// 82A08760: 80610060  lwz r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82A08764: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A08768: 419A0008  beq cr6, 0x82a08770
	if ctx.cr[6].eq {
	pc = 0x82A08770; continue 'dispatch;
	}
	// 82A0876C: 4B8DFAFD  bl 0x822e8268
	ctx.lr = 0x82A08770;
	sub_822E8268(ctx, base);
	// 82A08770: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 82A08774: CBC1FFA0  lfd f30, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 82A08778: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 82A0877C: 4879FA28  b 0x831a81a4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A08780(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A08780 size=20
    let mut pc: u32 = 0x82A08780;
    'dispatch: loop {
        match pc {
            0x82A08780 => {
    //   block [0x82A08780..0x82A08794)
	// 82A08780: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82A08784: 38A300F8  addi r5, r3, 0xf8
	ctx.r[5].s64 = ctx.r[3].s64 + 248;
	// 82A08788: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82A0878C: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 82A08790: 4BB07A60  b 0x825101f0
	sub_825101F0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A08798(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A08798 size=108
    let mut pc: u32 = 0x82A08798;
    'dispatch: loop {
        match pc {
            0x82A08798 => {
    //   block [0x82A08798..0x82A08804)
	// 82A08798: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0879C: 4879F9D1  bl 0x831a816c
	ctx.lr = 0x82A087A0;
	sub_831A8130(ctx, base);
	// 82A087A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A087A4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82A087A8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A087AC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A087B0: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A087B4: 41820038  beq 0x82a087ec
	if ctx.cr[0].eq {
	pc = 0x82A087EC; continue 'dispatch;
	}
	// 82A087B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A087BC: 487A11CD  bl 0x831a9988
	ctx.lr = 0x82A087C0;
	sub_831A9988(ctx, base);
	// 82A087C0: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A087C4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A087C8: 386BE9D0  addi r3, r11, -0x1630
	ctx.r[3].s64 = ctx.r[11].s64 + -5680;
	// 82A087CC: 4879F92D  bl 0x831a80f8
	ctx.lr = 0x82A087D0;
	sub_831A80F8(ctx, base);
	// 82A087D0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A087D4: 41820018  beq 0x82a087ec
	if ctx.cr[0].eq {
	pc = 0x82A087EC; continue 'dispatch;
	}
	// 82A087D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A087DC: 387DFFD8  addi r3, r29, -0x28
	ctx.r[3].s64 = ctx.r[29].s64 + -40;
	// 82A087E0: 4BFFFFA1  bl 0x82a08780
	ctx.lr = 0x82A087E4;
	sub_82A08780(ctx, base);
	// 82A087E4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A087E8: 48000014  b 0x82a087fc
	pc = 0x82A087FC; continue 'dispatch;
	// 82A087EC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A087F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A087F4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A087F8: 4BB09E21  bl 0x82512618
	ctx.lr = 0x82A087FC;
	sub_82512618(ctx, base);
	// 82A087FC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A08800: 4879F9BC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A08808(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A08808 size=84
    let mut pc: u32 = 0x82A08808;
    'dispatch: loop {
        match pc {
            0x82A08808 => {
    //   block [0x82A08808..0x82A0885C)
	// 82A08808: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0880C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A08810: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A08814: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82A08818: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0881C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A08820: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82A08824: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 82A08828: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A0882C: 483F5FB5  bl 0x82dfe7e0
	ctx.lr = 0x82A08830;
	sub_82DFE7E0(ctx, base);
	// 82A08830: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A08834: 41820010  beq 0x82a08844
	if ctx.cr[0].eq {
	pc = 0x82A08844; continue 'dispatch;
	}
	// 82A08838: 807F00F0  lwz r3, 0xf0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 82A0883C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A08840: 481ACCB1  bl 0x82bb54f0
	ctx.lr = 0x82A08844;
	sub_82BB54F0(ctx, base);
	// 82A08844: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A08848: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0884C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A08850: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A08854: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A08858: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A08860(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A08860 size=196
    let mut pc: u32 = 0x82A08860;
    'dispatch: loop {
        match pc {
            0x82A08860 => {
    //   block [0x82A08860..0x82A08924)
	// 82A08860: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A08864: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A08868: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A0886C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A08870: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A08874: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A08878: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A0887C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A08880: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A08884: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A08888: 4B8B80B1  bl 0x822c0938
	ctx.lr = 0x82A0888C;
	sub_822C0938(ctx, base);
	// 82A0888C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A08890: 41820028  beq 0x82a088b8
	if ctx.cr[0].eq {
	pc = 0x82A088B8; continue 'dispatch;
	}
	// 82A08894: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A08898: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A0889C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A088A0: 392B8030  addi r9, r11, -0x7fd0
	ctx.r[9].s64 = ctx.r[11].s64 + -32720;
	// 82A088A4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A088A8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A088AC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A088B0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A088B4: 48000008  b 0x82a088bc
	pc = 0x82A088BC; continue 'dispatch;
	// 82A088B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A088BC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A088C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A088C4: 409A0044  bne cr6, 0x82a08908
	if !ctx.cr[6].eq {
	pc = 0x82A08908; continue 'dispatch;
	}
	// 82A088C8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A088CC: 419A001C  beq cr6, 0x82a088e8
	if ctx.cr[6].eq {
	pc = 0x82A088E8; continue 'dispatch;
	}
	// 82A088D0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A088D4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A088D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A088DC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A088E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A088E4: 4E800421  bctrl
	ctx.lr = 0x82A088E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A088E8: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A088EC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A088F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A088F4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A088F8: 816BEE24  lwz r11, -0x11dc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4572 as u32) ) } as u64;
	// 82A088FC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A08900: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A08904: 4B8B76FD  bl 0x822c0000
	ctx.lr = 0x82A08908;
	sub_822C0000(ctx, base);
	// 82A08908: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A0890C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A08910: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A08914: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A08918: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A0891C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A08920: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A08928(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A08928 size=172
    let mut pc: u32 = 0x82A08928;
    'dispatch: loop {
        match pc {
            0x82A08928 => {
    //   block [0x82A08928..0x82A089D4)
	// 82A08928: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0892C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A08930: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A08934: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A08938: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0893C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A08940: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A08944: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A08948: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A0894C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A08950: 4B8B7FE9  bl 0x822c0938
	ctx.lr = 0x82A08954;
	sub_822C0938(ctx, base);
	// 82A08954: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A08958: 41820028  beq 0x82a08980
	if ctx.cr[0].eq {
	pc = 0x82A08980; continue 'dispatch;
	}
	// 82A0895C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A08960: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A08964: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A08968: 392B8044  addi r9, r11, -0x7fbc
	ctx.r[9].s64 = ctx.r[11].s64 + -32700;
	// 82A0896C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A08970: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A08974: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A08978: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A0897C: 48000008  b 0x82a08984
	pc = 0x82A08984; continue 'dispatch;
	// 82A08980: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A08984: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A08988: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0898C: 409A002C  bne cr6, 0x82a089b8
	if !ctx.cr[6].eq {
	pc = 0x82A089B8; continue 'dispatch;
	}
	// 82A08990: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A08994: 4B8B78D5  bl 0x822c0268
	ctx.lr = 0x82A08998;
	sub_822C0268(ctx, base);
	// 82A08998: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A0899C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A089A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A089A4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A089A8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A089AC: 816BEE24  lwz r11, -0x11dc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4572 as u32) ) } as u64;
	// 82A089B0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A089B4: 4B8B764D  bl 0x822c0000
	ctx.lr = 0x82A089B8;
	sub_822C0000(ctx, base);
	// 82A089B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A089BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A089C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A089C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A089C8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A089CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A089D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A089D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A089D8 size=196
    let mut pc: u32 = 0x82A089D8;
    'dispatch: loop {
        match pc {
            0x82A089D8 => {
    //   block [0x82A089D8..0x82A08A9C)
	// 82A089D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A089DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A089E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A089E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A089E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A089EC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A089F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A089F4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A089F8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A089FC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A08A00: 4B8B7F39  bl 0x822c0938
	ctx.lr = 0x82A08A04;
	sub_822C0938(ctx, base);
	// 82A08A04: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A08A08: 41820028  beq 0x82a08a30
	if ctx.cr[0].eq {
	pc = 0x82A08A30; continue 'dispatch;
	}
	// 82A08A0C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A08A10: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A08A14: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A08A18: 392B8058  addi r9, r11, -0x7fa8
	ctx.r[9].s64 = ctx.r[11].s64 + -32680;
	// 82A08A1C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A08A20: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A08A24: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A08A28: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A08A2C: 48000008  b 0x82a08a34
	pc = 0x82A08A34; continue 'dispatch;
	// 82A08A30: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A08A34: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A08A38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A08A3C: 409A0044  bne cr6, 0x82a08a80
	if !ctx.cr[6].eq {
	pc = 0x82A08A80; continue 'dispatch;
	}
	// 82A08A40: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A08A44: 419A001C  beq cr6, 0x82a08a60
	if ctx.cr[6].eq {
	pc = 0x82A08A60; continue 'dispatch;
	}
	// 82A08A48: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A08A4C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A08A50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A08A54: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A08A58: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A08A5C: 4E800421  bctrl
	ctx.lr = 0x82A08A60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A08A60: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A08A64: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A08A68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A08A6C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A08A70: 816BEE24  lwz r11, -0x11dc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4572 as u32) ) } as u64;
	// 82A08A74: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A08A78: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A08A7C: 4B8B7585  bl 0x822c0000
	ctx.lr = 0x82A08A80;
	sub_822C0000(ctx, base);
	// 82A08A80: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A08A84: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A08A88: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A08A8C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A08A90: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A08A94: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A08A98: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A08AA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A08AA0 size=160
    let mut pc: u32 = 0x82A08AA0;
    'dispatch: loop {
        match pc {
            0x82A08AA0 => {
    //   block [0x82A08AA0..0x82A08B40)
	// 82A08AA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A08AA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A08AA8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A08AAC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A08AB0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A08AB4: 4BB097AD  bl 0x82512260
	ctx.lr = 0x82A08AB8;
	sub_82512260(ctx, base);
	// 82A08AB8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82A08ABC: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A08AC0: 396BA214  addi r11, r11, -0x5dec
	ctx.r[11].s64 = ctx.r[11].s64 + -24044;
	// 82A08AC4: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82A08AC8: 3D00820B  lis r8, -0x7df5
	ctx.r[8].s64 = -2113208320;
	// 82A08ACC: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 82A08AD0: 394A80CC  addi r10, r10, -0x7f34
	ctx.r[10].s64 = ctx.r[10].s64 + -32564;
	// 82A08AD4: 392980B8  addi r9, r9, -0x7f48
	ctx.r[9].s64 = ctx.r[9].s64 + -32584;
	// 82A08AD8: 3908806C  addi r8, r8, -0x7f94
	ctx.r[8].s64 = ctx.r[8].s64 + -32660;
	// 82A08ADC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A08AE0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A08AE4: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 82A08AE8: 911F00E4  stw r8, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[8].u32 ) };
	// 82A08AEC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A08AF0: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 82A08AF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A08AF8: 917F00EC  stw r11, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 82A08AFC: 917F00F0  stw r11, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 82A08B00: 917F00F4  stw r11, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 82A08B04: 917F00F8  stw r11, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[11].u32 ) };
	// 82A08B08: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A08B0C: 917F00FC  stw r11, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[11].u32 ) };
	// 82A08B10: 917F0100  stw r11, 0x100(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[11].u32 ) };
	// 82A08B14: 917F0104  stw r11, 0x104(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[11].u32 ) };
	// 82A08B18: 917F0108  stw r11, 0x108(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[11].u32 ) };
	// 82A08B1C: 917F010C  stw r11, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[11].u32 ) };
	// 82A08B20: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 82A08B24: 917F0114  stw r11, 0x114(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), ctx.r[11].u32 ) };
	// 82A08B28: D01F0118  stfs f0, 0x118(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), tmp.u32 ) };
	// 82A08B2C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A08B30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A08B34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A08B38: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A08B3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A08B40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A08B40 size=156
    let mut pc: u32 = 0x82A08B40;
    'dispatch: loop {
        match pc {
            0x82A08B40 => {
    //   block [0x82A08B40..0x82A08BDC)
	// 82A08B40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A08B44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A08B48: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A08B4C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A08B50: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A08B54: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A08B58: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A08B5C: 4BB0950D  bl 0x82512068
	ctx.lr = 0x82A08B60;
	sub_82512068(ctx, base);
	// 82A08B60: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A08B64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A08B68: 4BB01DE9  bl 0x8250a950
	ctx.lr = 0x82A08B6C;
	sub_8250A950(ctx, base);
	// 82A08B6C: 3BFF0100  addi r31, r31, 0x100
	ctx.r[31].s64 = ctx.r[31].s64 + 256;
	// 82A08B70: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A08B74: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82A08B78: 419A0044  beq cr6, 0x82a08bbc
	if ctx.cr[6].eq {
	pc = 0x82A08BBC; continue 'dispatch;
	}
	// 82A08B7C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A08B80: 48478BC1  bl 0x82e81740
	ctx.lr = 0x82A08B84;
	sub_82E81740(ctx, base);
	// 82A08B84: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A08B88: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A08B8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A08B90: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 82A08B94: 409A0008  bne cr6, 0x82a08b9c
	if !ctx.cr[6].eq {
	pc = 0x82A08B9C; continue 'dispatch;
	}
	// 82A08B98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A08B9C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A08BA0: 4BDCADD1  bl 0x827d3970
	ctx.lr = 0x82A08BA4;
	sub_827D3970(ctx, base);
	// 82A08BA4: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82A08BA8: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A08BAC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A08BB0: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82A08BB4: 419A0008  beq cr6, 0x82a08bbc
	if ctx.cr[6].eq {
	pc = 0x82A08BBC; continue 'dispatch;
	}
	// 82A08BB8: 4B8B7CD9  bl 0x822c0890
	ctx.lr = 0x82A08BBC;
	sub_822C0890(ctx, base);
	// 82A08BBC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A08BC0: 483E90D1  bl 0x82df1c90
	ctx.lr = 0x82A08BC4;
	sub_82DF1C90(ctx, base);
	// 82A08BC4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A08BC8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A08BCC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A08BD0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A08BD4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A08BD8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A08BE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A08BE0 size=1040
    let mut pc: u32 = 0x82A08BE0;
    'dispatch: loop {
        match pc {
            0x82A08BE0 => {
    //   block [0x82A08BE0..0x82A08FF0)
	// 82A08BE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A08BE4: 4879F585  bl 0x831a8168
	ctx.lr = 0x82A08BE8;
	sub_831A8130(ctx, base);
	// 82A08BE8: DBC1FFC8  stfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 82A08BEC: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82A08BF0: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A08FF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A08FF0 size=80
    let mut pc: u32 = 0x82A08FF0;
    'dispatch: loop {
        match pc {
            0x82A08FF0 => {
    //   block [0x82A08FF0..0x82A09040)
	// 82A08FF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A08FF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A08FF8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A08FFC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A09000: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A09004: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A09008: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A0900C: 4BB076FD  bl 0x82510708
	ctx.lr = 0x82A09010;
	sub_82510708(ctx, base);
	// 82A09010: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A09014: C03E0000  lfs f1, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A09018: 4BFFF7F1  bl 0x82a08808
	ctx.lr = 0x82A0901C;
	sub_82A08808(ctx, base);
	// 82A0901C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A09020: C03E0000  lfs f1, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A09024: 4BFFFBBD  bl 0x82a08be0
	ctx.lr = 0x82A09028;
	sub_82A08BE0(ctx, base);
	// 82A09028: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A0902C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A09030: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A09034: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A09038: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A0903C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A09040(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A09040 size=440
    let mut pc: u32 = 0x82A09040;
    'dispatch: loop {
        match pc {
            0x82A09040 => {
    //   block [0x82A09040..0x82A091F8)
	// 82A09040: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A09044: 4879F11D  bl 0x831a8160
	ctx.lr = 0x82A09048;
	sub_831A8130(ctx, base);
	// 82A09048: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0904C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A09050: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82A09054: 3BCB8108  addi r30, r11, -0x7ef8
	ctx.r[30].s64 = ctx.r[11].s64 + -32504;
	// 82A09058: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82A0905C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A09060: 38A0003E  li r5, 0x3e
	ctx.r[5].s64 = 62;
	// 82A09064: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 82A09068: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A0906C: 38600124  li r3, 0x124
	ctx.r[3].s64 = 292;
	// 82A09070: 483E9379  bl 0x82df23e8
	ctx.lr = 0x82A09074;
	sub_82DF23E8(ctx, base);
	// 82A09074: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82A09078: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A0907C: 3BABBA80  addi r29, r11, -0x4580
	ctx.r[29].s64 = ctx.r[11].s64 + -17792;
	// 82A09080: 4182001C  beq 0x82a0909c
	if ctx.cr[0].eq {
	pc = 0x82A0909C; continue 'dispatch;
	}
	// 82A09084: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A09088: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A0908C: 388B6910  addi r4, r11, 0x6910
	ctx.r[4].s64 = ctx.r[11].s64 + 26896;
	// 82A09090: 4BFFFA11  bl 0x82a08aa0
	ctx.lr = 0x82A09094;
	sub_82A08AA0(ctx, base);
	// 82A09094: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A09098: 48000008  b 0x82a090a0
	pc = 0x82A090A0; continue 'dispatch;
	// 82A0909C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A090A0: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82A090A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A090A8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A090AC: 4BFFF7B5  bl 0x82a08860
	ctx.lr = 0x82A090B0;
	sub_82A08860(ctx, base);
	// 82A090B0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A090B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A090B8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A090BC: 4B8B6F45  bl 0x822c0000
	ctx.lr = 0x82A090C0;
	sub_822C0000(ctx, base);
	// 82A090C0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A090C4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A090C8: 38A0003F  li r5, 0x3f
	ctx.r[5].s64 = 63;
	// 82A090CC: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82A090D0: 4B8B7309  bl 0x822c03d8
	ctx.lr = 0x82A090D4;
	sub_822C03D8(ctx, base);
	// 82A090D4: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A090D8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A090DC: 418200B0  beq 0x82a0918c
	if ctx.cr[0].eq {
	pc = 0x82A0918C; continue 'dispatch;
	}
	// 82A090E0: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A090E4: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 82A090E8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A090EC: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 82A090F0: 409A0008  bne cr6, 0x82a090f8
	if !ctx.cr[6].eq {
	pc = 0x82A090F8; continue 'dispatch;
	}
	// 82A090F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A090F8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A090FC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82A09100: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 82A09104: 419A0024  beq cr6, 0x82a09128
	if ctx.cr[6].eq {
	pc = 0x82A09128; continue 'dispatch;
	}
	// 82A09108: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 82A0910C: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82A09110: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A09114: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82A09118: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82A0911C: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A09120: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A09124: 4082FFE8  bne 0x82a0910c
	if !ctx.cr[0].eq {
	pc = 0x82A0910C; continue 'dispatch;
	}
	// 82A09128: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 82A0912C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82A09130: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 82A09134: 419A0024  beq cr6, 0x82a09158
	if ctx.cr[6].eq {
	pc = 0x82A09158; continue 'dispatch;
	}
	// 82A09138: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 82A0913C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A09140: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A09144: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A09148: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A0914C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A09150: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A09154: 4082FFE8  bne 0x82a0913c
	if !ctx.cr[0].eq {
	pc = 0x82A0913C; continue 'dispatch;
	}
	// 82A09158: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A0915C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82A09160: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82A09164: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82A09168: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82A0916C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A09170: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A09174: 4BD8FDBD  bl 0x82798f30
	ctx.lr = 0x82A09178;
	sub_82798F30(ctx, base);
	// 82A09178: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A0917C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A09180: 4BD924E9  bl 0x8279b668
	ctx.lr = 0x82A09184;
	sub_8279B668(ctx, base);
	// 82A09184: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A09188: 48000008  b 0x82a09190
	pc = 0x82A09190; continue 'dispatch;
	// 82A0918C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A09190: 93FA0000  stw r31, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A09194: 3BDA0004  addi r30, r26, 4
	ctx.r[30].s64 = ctx.r[26].s64 + 4;
	// 82A09198: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0919C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A091A0: 4BB8EAB1  bl 0x82597c50
	ctx.lr = 0x82A091A4;
	sub_82597C50(ctx, base);
	// 82A091A4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A091A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A091AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A091B0: 4B8B6E51  bl 0x822c0000
	ctx.lr = 0x82A091B4;
	sub_822C0000(ctx, base);
	// 82A091B4: 576B07FF  clrlwi. r11, r27, 0x1f
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A091B8: 41820024  beq 0x82a091dc
	if ctx.cr[0].eq {
	pc = 0x82A091DC; continue 'dispatch;
	}
	// 82A091BC: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82A091C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A091C4: 419A0008  beq cr6, 0x82a091cc
	if ctx.cr[6].eq {
	pc = 0x82A091CC; continue 'dispatch;
	}
	// 82A091C8: 4B8B76C9  bl 0x822c0890
	ctx.lr = 0x82A091CC;
	sub_822C0890(ctx, base);
	// 82A091CC: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A091D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A091D4: 419A0008  beq cr6, 0x82a091dc
	if ctx.cr[6].eq {
	pc = 0x82A091DC; continue 'dispatch;
	}
	// 82A091D8: 4B8B76B9  bl 0x822c0890
	ctx.lr = 0x82A091DC;
	sub_822C0890(ctx, base);
	// 82A091DC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82A091E0: 419A000C  beq cr6, 0x82a091ec
	if ctx.cr[6].eq {
	pc = 0x82A091EC; continue 'dispatch;
	}
	// 82A091E4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A091E8: 4B8B76A9  bl 0x822c0890
	ctx.lr = 0x82A091EC;
	sub_822C0890(ctx, base);
	// 82A091EC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A091F0: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82A091F4: 4879EFBC  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A091F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A091F8 size=1912
    let mut pc: u32 = 0x82A091F8;
    'dispatch: loop {
        match pc {
            0x82A091F8 => {
    //   block [0x82A091F8..0x82A09970)
	// 82A091F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A091FC: 4879EF55  bl 0x831a8150
	ctx.lr = 0x82A09200;
	sub_831A8130(ctx, base);
	// 82A09200: DBA1FF90  stfd f29, -0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.f[29].u64 ) };
	// 82A09204: DBC1FF98  stfd f30, -0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[30].u64 ) };
	// 82A09208: DBE1FFA0  stfd f31, -0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[31].u64 ) };
	// 82A0920C: 3980FF80  li r12, -0x80
	ctx.r[12].s64 = -128;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A09970(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A09970 size=68
    let mut pc: u32 = 0x82A09970;
    'dispatch: loop {
        match pc {
            0x82A09970 => {
    //   block [0x82A09970..0x82A099B4)
	// 82A09970: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A09974: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A09978: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A0997C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A09980: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A09984: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A09988: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A0998C: 4BB06D7D  bl 0x82510708
	ctx.lr = 0x82A09990;
	sub_82510708(ctx, base);
	// 82A09990: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A09994: 387F00E4  addi r3, r31, 0xe4
	ctx.r[3].s64 = ctx.r[31].s64 + 228;
	// 82A09998: 484534E1  bl 0x82e5ce78
	ctx.lr = 0x82A0999C;
	sub_82E5CE78(ctx, base);
	// 82A0999C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A099A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A099A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A099A8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A099AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A099B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A099B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A099B8 size=52
    let mut pc: u32 = 0x82A099B8;
    'dispatch: loop {
        match pc {
            0x82A099B8 => {
    //   block [0x82A099B8..0x82A099EC)
	// 82A099B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A099BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A099C0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A099C4: 4874AC3D  bl 0x83154600
	ctx.lr = 0x82A099C8;
	sub_83154600(ctx, base);
	// 82A099C8: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A099CC: 39400170  li r10, 0x170
	ctx.r[10].s64 = 368;
	// 82A099D0: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 82A099D4: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A099F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A099F0 size=172
    let mut pc: u32 = 0x82A099F0;
    'dispatch: loop {
        match pc {
            0x82A099F0 => {
    //   block [0x82A099F0..0x82A09A9C)
	// 82A099F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A099F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A099F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A099FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A09A00: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A09A04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A09A08: 4874ABF9  bl 0x83154600
	ctx.lr = 0x82A09A0C;
	sub_83154600(ctx, base);
	// 82A09A0C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A09A10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A09A14: 4844FD4D  bl 0x82e59760
	ctx.lr = 0x82A09A18;
	sub_82E59760(ctx, base);
	// 82A09A18: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A09A1C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A09A20: C00B603C  lfs f0, 0x603c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24636 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A09A24: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A09A28: C1AA08A8  lfs f13, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A09A2C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A09A30: 41980008  blt cr6, 0x82a09a38
	if ctx.cr[6].lt {
	pc = 0x82A09A38; continue 'dispatch;
	}
	// 82A09A34: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82A09A38: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82A09A3C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82A09A40: C1ABDFAC  lfs f13, -0x2054(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A09A44: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A09A48: C00A9450  lfs f0, -0x6bb0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A09A4C: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A09A50: 4879F379  bl 0x831a8dc8
	ctx.lr = 0x82A09A54;
	sub_831A8DC8(ctx, base);
	// 82A09A54: 38BF0070  addi r5, r31, 0x70
	ctx.r[5].s64 = ctx.r[31].s64 + 112;
	// 82A09A58: FC200818  frsp f1, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82A09A5C: 389F0060  addi r4, r31, 0x60
	ctx.r[4].s64 = ctx.r[31].s64 + 96;
	// 82A09A60: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A09A64: 48473BDD  bl 0x82e7d640
	ctx.lr = 0x82A09A68;
	sub_82E7D640(ctx, base);
	// 82A09A68: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A09A6C: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82A09A70: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A09A74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A09A78: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A09AA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A09AA0 size=196
    let mut pc: u32 = 0x82A09AA0;
    'dispatch: loop {
        match pc {
            0x82A09AA0 => {
    //   block [0x82A09AA0..0x82A09B64)
	// 82A09AA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A09AA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A09AA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A09AAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A09AB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A09AB4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A09AB8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A09ABC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A09AC0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A09AC4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A09AC8: 4B8B6E71  bl 0x822c0938
	ctx.lr = 0x82A09ACC;
	sub_822C0938(ctx, base);
	// 82A09ACC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A09AD0: 41820028  beq 0x82a09af8
	if ctx.cr[0].eq {
	pc = 0x82A09AF8; continue 'dispatch;
	}
	// 82A09AD4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A09AD8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A09ADC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A09AE0: 392B820C  addi r9, r11, -0x7df4
	ctx.r[9].s64 = ctx.r[11].s64 + -32244;
	// 82A09AE4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A09AE8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A09AEC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A09AF0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A09AF4: 48000008  b 0x82a09afc
	pc = 0x82A09AFC; continue 'dispatch;
	// 82A09AF8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A09AFC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A09B00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A09B04: 409A0044  bne cr6, 0x82a09b48
	if !ctx.cr[6].eq {
	pc = 0x82A09B48; continue 'dispatch;
	}
	// 82A09B08: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A09B0C: 419A001C  beq cr6, 0x82a09b28
	if ctx.cr[6].eq {
	pc = 0x82A09B28; continue 'dispatch;
	}
	// 82A09B10: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A09B14: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A09B18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A09B1C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A09B20: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A09B24: 4E800421  bctrl
	ctx.lr = 0x82A09B28;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A09B28: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A09B2C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A09B30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A09B34: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A09B38: 816BEF54  lwz r11, -0x10ac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4268 as u32) ) } as u64;
	// 82A09B3C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A09B40: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A09B44: 4B8B64BD  bl 0x822c0000
	ctx.lr = 0x82A09B48;
	sub_822C0000(ctx, base);
	// 82A09B48: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A09B4C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A09B50: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A09B54: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A09B58: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A09B5C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A09B60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A09B68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A09B68 size=196
    let mut pc: u32 = 0x82A09B68;
    'dispatch: loop {
        match pc {
            0x82A09B68 => {
    //   block [0x82A09B68..0x82A09C2C)
	// 82A09B68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A09B6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A09B70: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A09B74: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A09B78: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A09B7C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A09B80: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A09B84: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A09B88: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A09B8C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A09B90: 4B8B6DA9  bl 0x822c0938
	ctx.lr = 0x82A09B94;
	sub_822C0938(ctx, base);
	// 82A09B94: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A09B98: 41820028  beq 0x82a09bc0
	if ctx.cr[0].eq {
	pc = 0x82A09BC0; continue 'dispatch;
	}
	// 82A09B9C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A09BA0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A09BA4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A09BA8: 392B8220  addi r9, r11, -0x7de0
	ctx.r[9].s64 = ctx.r[11].s64 + -32224;
	// 82A09BAC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A09BB0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A09BB4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A09BB8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A09BBC: 48000008  b 0x82a09bc4
	pc = 0x82A09BC4; continue 'dispatch;
	// 82A09BC0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A09BC4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A09BC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A09BCC: 409A0044  bne cr6, 0x82a09c10
	if !ctx.cr[6].eq {
	pc = 0x82A09C10; continue 'dispatch;
	}
	// 82A09BD0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A09BD4: 419A001C  beq cr6, 0x82a09bf0
	if ctx.cr[6].eq {
	pc = 0x82A09BF0; continue 'dispatch;
	}
	// 82A09BD8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A09BDC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A09BE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A09BE4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A09BE8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A09BEC: 4E800421  bctrl
	ctx.lr = 0x82A09BF0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A09BF0: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A09BF4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A09BF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A09BFC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A09C00: 816BEF54  lwz r11, -0x10ac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4268 as u32) ) } as u64;
	// 82A09C04: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A09C08: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A09C0C: 4B8B63F5  bl 0x822c0000
	ctx.lr = 0x82A09C10;
	sub_822C0000(ctx, base);
	// 82A09C10: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A09C14: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A09C18: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A09C1C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A09C20: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A09C24: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A09C28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A09C30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A09C30 size=196
    let mut pc: u32 = 0x82A09C30;
    'dispatch: loop {
        match pc {
            0x82A09C30 => {
    //   block [0x82A09C30..0x82A09CF4)
	// 82A09C30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A09C34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A09C38: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A09C3C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A09C40: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A09C44: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A09C48: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A09C4C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A09C50: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A09C54: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A09C58: 4B8B6CE1  bl 0x822c0938
	ctx.lr = 0x82A09C5C;
	sub_822C0938(ctx, base);
	// 82A09C5C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A09C60: 41820028  beq 0x82a09c88
	if ctx.cr[0].eq {
	pc = 0x82A09C88; continue 'dispatch;
	}
	// 82A09C64: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A09C68: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A09C6C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A09C70: 392B8234  addi r9, r11, -0x7dcc
	ctx.r[9].s64 = ctx.r[11].s64 + -32204;
	// 82A09C74: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A09C78: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A09C7C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A09C80: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A09C84: 48000008  b 0x82a09c8c
	pc = 0x82A09C8C; continue 'dispatch;
	// 82A09C88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A09C8C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A09C90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A09C94: 409A0044  bne cr6, 0x82a09cd8
	if !ctx.cr[6].eq {
	pc = 0x82A09CD8; continue 'dispatch;
	}
	// 82A09C98: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A09C9C: 419A001C  beq cr6, 0x82a09cb8
	if ctx.cr[6].eq {
	pc = 0x82A09CB8; continue 'dispatch;
	}
	// 82A09CA0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A09CA4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A09CA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A09CAC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A09CB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A09CB4: 4E800421  bctrl
	ctx.lr = 0x82A09CB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A09CB8: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A09CBC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A09CC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A09CC4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A09CC8: 816BEF54  lwz r11, -0x10ac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4268 as u32) ) } as u64;
	// 82A09CCC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A09CD0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A09CD4: 4B8B632D  bl 0x822c0000
	ctx.lr = 0x82A09CD8;
	sub_822C0000(ctx, base);
	// 82A09CD8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A09CDC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A09CE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A09CE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A09CE8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A09CEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A09CF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A09CF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A09CF8 size=216
    let mut pc: u32 = 0x82A09CF8;
    'dispatch: loop {
        match pc {
            0x82A09CF8 => {
    //   block [0x82A09CF8..0x82A09DD0)
	// 82A09CF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A09CFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A09D00: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A09D04: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A09D08: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A09DD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A09DD0 size=476
    let mut pc: u32 = 0x82A09DD0;
    'dispatch: loop {
        match pc {
            0x82A09DD0 => {
    //   block [0x82A09DD0..0x82A09FAC)
	// 82A09DD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A09DD4: 4879E385  bl 0x831a8158
	ctx.lr = 0x82A09DD8;
	sub_831A8130(ctx, base);
	// 82A09DD8: DBE1FFB0  stfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 82A09DDC: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A09DE0: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82A09DE4: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82A09DE8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A09DEC: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82A09DF0: 38ABBA80  addi r5, r11, -0x4580
	ctx.r[5].s64 = ctx.r[11].s64 + -17792;
	// 82A09DF4: 388A6910  addi r4, r10, 0x6910
	ctx.r[4].s64 = ctx.r[10].s64 + 26896;
	// 82A09DF8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A09DFC: 7CD93378  mr r25, r6
	ctx.r[25].u64 = ctx.r[6].u64;
	// 82A09E00: 4BB08461  bl 0x82512260
	ctx.lr = 0x82A09E04;
	sub_82512260(ctx, base);
	// 82A09E04: 387F00E4  addi r3, r31, 0xe4
	ctx.r[3].s64 = ctx.r[31].s64 + 228;
	// 82A09E08: 48453AC9  bl 0x82e5d8d0
	ctx.lr = 0x82A09E0C;
	sub_82E5D8D0(ctx, base);
	// 82A09E0C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A09E10: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A09E14: 396B81FC  addi r11, r11, -0x7e04
	ctx.r[11].s64 = ctx.r[11].s64 + -32260;
	// 82A09E18: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82A09E1C: 3D00820B  lis r8, -0x7df5
	ctx.r[8].s64 = -2113208320;
	// 82A09E20: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 82A09E24: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 82A09E28: 394A82BC  addi r10, r10, -0x7d44
	ctx.r[10].s64 = ctx.r[10].s64 + -32068;
	// 82A09E2C: 392982A8  addi r9, r9, -0x7d58
	ctx.r[9].s64 = ctx.r[9].s64 + -32088;
	// 82A09E30: 39088298  addi r8, r8, -0x7d68
	ctx.r[8].s64 = ctx.r[8].s64 + -32104;
	// 82A09E34: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A09E38: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A09E3C: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 82A09E40: 911F00E4  stw r8, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[8].u32 ) };
	// 82A09E44: C3E708A4  lfs f31, 0x8a4(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A09E48: 917F0144  stw r11, 0x144(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(324 as u32), ctx.r[11].u32 ) };
	// 82A09E4C: 395F0158  addi r10, r31, 0x158
	ctx.r[10].s64 = ctx.r[31].s64 + 344;
	// 82A09E50: 917F0148  stw r11, 0x148(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(328 as u32), ctx.r[11].u32 ) };
	// 82A09E54: D3FF014C  stfs f31, 0x14c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(332 as u32), tmp.u32 ) };
	// 82A09E58: D3FF0150  stfs f31, 0x150(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), tmp.u32 ) };
	// 82A09E5C: 3B9E0004  addi r28, r30, 4
	ctx.r[28].s64 = ctx.r[30].s64 + 4;
	// 82A09E60: D3FF0154  stfs f31, 0x154(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(340 as u32), tmp.u32 ) };
	// 82A09E64: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A09E68: 915F0158  stw r10, 0x158(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(344 as u32), ctx.r[10].u32 ) };
	// 82A09E6C: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A09E70: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A09E74: 915F015C  stw r10, 0x15c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(348 as u32), ctx.r[10].u32 ) };
	// 82A09E78: 419A0024  beq cr6, 0x82a09e9c
	if ctx.cr[6].eq {
	pc = 0x82A09E9C; continue 'dispatch;
	}
	// 82A09E7C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82A09E80: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82A09E84: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A09E88: 7D205028  lwarx r9, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82A09E8C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82A09E90: 7D20512D  stwcx. r9, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A09E94: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A09E98: 4082FFE8  bne 0x82a09e80
	if !ctx.cr[0].eq {
	pc = 0x82A09E80; continue 'dispatch;
	}
	// 82A09E9C: 917F0180  stw r11, 0x180(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(384 as u32), ctx.r[11].u32 ) };
	// 82A09EA0: D3FF0160  stfs f31, 0x160(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), tmp.u32 ) };
	// 82A09EA4: D3FF0164  stfs f31, 0x164(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(356 as u32), tmp.u32 ) };
	// 82A09EA8: 917F0184  stw r11, 0x184(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), ctx.r[11].u32 ) };
	// 82A09EAC: D3FF0168  stfs f31, 0x168(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(360 as u32), tmp.u32 ) };
	// 82A09EB0: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A09EB4: D3FF016C  stfs f31, 0x16c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(364 as u32), tmp.u32 ) };
	// 82A09EB8: 3BBF0160  addi r29, r31, 0x160
	ctx.r[29].s64 = ctx.r[31].s64 + 352;
	// 82A09EBC: D3FF0170  stfs f31, 0x170(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(368 as u32), tmp.u32 ) };
	// 82A09EC0: 3B0BEF60  addi r24, r11, -0x10a0
	ctx.r[24].s64 = ctx.r[11].s64 + -4256;
	// 82A09EC4: D3FF0174  stfs f31, 0x174(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(372 as u32), tmp.u32 ) };
	// 82A09EC8: 3B7F0170  addi r27, r31, 0x170
	ctx.r[27].s64 = ctx.r[31].s64 + 368;
	// 82A09ECC: D3FF0178  stfs f31, 0x178(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(376 as u32), tmp.u32 ) };
	// 82A09ED0: D3FF017C  stfs f31, 0x17c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(380 as u32), tmp.u32 ) };
	// 82A09ED4: 9B5F0188  stb r26, 0x188(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), ctx.r[26].u8 ) };
	// 82A09ED8: 933F018C  stw r25, 0x18c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), ctx.r[25].u32 ) };
	// 82A09EDC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A09EE0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A09EE4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A09EE8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A09EEC: 4E800421  bctrl
	ctx.lr = 0x82A09EF0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A09EF0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A09EF4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A09EF8: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 82A09EFC: 48471DCD  bl 0x82e7bcc8
	ctx.lr = 0x82A09F00;
	sub_82E7BCC8(ctx, base);
	// 82A09F00: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82A09F04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A09F08: 4BB07B79  bl 0x82511a80
	ctx.lr = 0x82A09F0C;
	sub_82511A80(ctx, base);
	// 82A09F0C: 3F40820B  lis r26, -0x7df5
	ctx.r[26].s64 = -2113208320;
	// 82A09F10: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A09F14: D3E10060  stfs f31, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A09F18: 395A81D8  addi r10, r26, -0x7e28
	ctx.r[10].s64 = ctx.r[26].s64 + -32296;
	// 82A09F1C: D3E10064  stfs f31, 0x64(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82A09F20: D3E1006C  stfs f31, 0x6c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82A09F24: 3B210060  addi r25, r1, 0x60
	ctx.r[25].s64 = ctx.r[1].s64 + 96;
	// 82A09F28: C00B08A8  lfs f0, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A09F2C: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82A09F30: C1AA0004  lfs f13, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A09F34: C0010074  lfs f0, 0x74(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A09F38: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82A09F3C: D01F0150  stfs f0, 0x150(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), tmp.u32 ) };
	// 82A09F40: D01F0154  stfs f0, 0x154(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(340 as u32), tmp.u32 ) };
	// 82A09F44: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A09F48: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A09F4C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A09F50: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A09F54: 4E800421  bctrl
	ctx.lr = 0x82A09F58;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A09F58: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A09F5C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A09F60: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 82A09F64: 48471DE5  bl 0x82e7bd48
	ctx.lr = 0x82A09F68;
	sub_82E7BD48(ctx, base);
	// 82A09F68: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82A09F6C: C01A81D8  lfs f0, -0x7e28(r26)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-32296 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A09F70: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82A09F74: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A09F78: 13C05C07  vcmpneb. (lvlx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A09FB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A09FB0 size=8
    let mut pc: u32 = 0x82A09FB0;
    'dispatch: loop {
        match pc {
            0x82A09FB0 => {
    //   block [0x82A09FB0..0x82A09FB8)
	// 82A09FB0: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 82A09FB4: 48000844  b 0x82a0a7f8
	sub_82A0A7F8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A09FB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A09FB8 size=8
    let mut pc: u32 = 0x82A09FB8;
    'dispatch: loop {
        match pc {
            0x82A09FB8 => {
    //   block [0x82A09FB8..0x82A09FC0)
	// 82A09FB8: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 82A09FBC: 4800083C  b 0x82a0a7f8
	sub_82A0A7F8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A09FC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A09FC0 size=116
    let mut pc: u32 = 0x82A09FC0;
    'dispatch: loop {
        match pc {
            0x82A09FC0 => {
    //   block [0x82A09FC0..0x82A0A034)
	// 82A09FC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A09FC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A09FC8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A09FCC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A09FD0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A09FD4: 807F0184  lwz r3, 0x184(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(388 as u32) ) } as u64;
	// 82A09FD8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A09FDC: 419A0008  beq cr6, 0x82a09fe4
	if ctx.cr[6].eq {
	pc = 0x82A09FE4; continue 'dispatch;
	}
	// 82A09FE0: 4B8B68B1  bl 0x822c0890
	ctx.lr = 0x82A09FE4;
	sub_822C0890(ctx, base);
	// 82A09FE4: 807F015C  lwz r3, 0x15c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(348 as u32) ) } as u64;
	// 82A09FE8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A09FEC: 419A0008  beq cr6, 0x82a09ff4
	if ctx.cr[6].eq {
	pc = 0x82A09FF4; continue 'dispatch;
	}
	// 82A09FF0: 4B8B68A1  bl 0x822c0890
	ctx.lr = 0x82A09FF4;
	sub_822C0890(ctx, base);
	// 82A09FF4: 807F0148  lwz r3, 0x148(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(328 as u32) ) } as u64;
	// 82A09FF8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A09FFC: 419A0008  beq cr6, 0x82a0a004
	if ctx.cr[6].eq {
	pc = 0x82A0A004; continue 'dispatch;
	}
	// 82A0A000: 4B8B6891  bl 0x822c0890
	ctx.lr = 0x82A0A004;
	sub_822C0890(ctx, base);
	// 82A0A004: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A0A008: 387F00E4  addi r3, r31, 0xe4
	ctx.r[3].s64 = ctx.r[31].s64 + 228;
	// 82A0A00C: 409A0008  bne cr6, 0x82a0a014
	if !ctx.cr[6].eq {
	pc = 0x82A0A014; continue 'dispatch;
	}
	// 82A0A010: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A0A014: 48453835  bl 0x82e5d848
	ctx.lr = 0x82A0A018;
	sub_82E5D848(ctx, base);
	// 82A0A018: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0A01C: 4B945335  bl 0x8234f350
	ctx.lr = 0x82A0A020;
	sub_8234F350(ctx, base);
	// 82A0A020: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A0A024: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0A028: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A0A02C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A0A030: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0A038(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A0A038 size=144
    let mut pc: u32 = 0x82A0A038;
    'dispatch: loop {
        match pc {
            0x82A0A038 => {
    //   block [0x82A0A038..0x82A0A0C8)
	// 82A0A038: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0A03C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A0A040: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A0A044: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A0A048: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0A04C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A0A050: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0A054: 4BB008FD  bl 0x8250a950
	ctx.lr = 0x82A0A058;
	sub_8250A950(ctx, base);
	// 82A0A058: 3BFF0144  addi r31, r31, 0x144
	ctx.r[31].s64 = ctx.r[31].s64 + 324;
	// 82A0A05C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0A060: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0A064: 419A0044  beq cr6, 0x82a0a0a8
	if ctx.cr[6].eq {
	pc = 0x82A0A0A8; continue 'dispatch;
	}
	// 82A0A068: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A0A06C: 484776D5  bl 0x82e81740
	ctx.lr = 0x82A0A070;
	sub_82E81740(ctx, base);
	// 82A0A070: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A0A074: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A0A078: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0A07C: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 82A0A080: 409A0008  bne cr6, 0x82a0a088
	if !ctx.cr[6].eq {
	pc = 0x82A0A088; continue 'dispatch;
	}
	// 82A0A084: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A0A088: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0A08C: 4BDC98E5  bl 0x827d3970
	ctx.lr = 0x82A0A090;
	sub_827D3970(ctx, base);
	// 82A0A090: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82A0A094: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0A098: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0A09C: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82A0A0A0: 419A0008  beq cr6, 0x82a0a0a8
	if ctx.cr[6].eq {
	pc = 0x82A0A0A8; continue 'dispatch;
	}
	// 82A0A0A4: 4B8B67ED  bl 0x822c0890
	ctx.lr = 0x82A0A0A8;
	sub_822C0890(ctx, base);
	// 82A0A0A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0A0AC: 483E7BE5  bl 0x82df1c90
	ctx.lr = 0x82A0A0B0;
	sub_82DF1C90(ctx, base);
	// 82A0A0B0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A0A0B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0A0B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A0A0BC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A0A0C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A0A0C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0A0C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A0A0C8 size=308
    let mut pc: u32 = 0x82A0A0C8;
    'dispatch: loop {
        match pc {
            0x82A0A0C8 => {
    //   block [0x82A0A0C8..0x82A0A1FC)
	// 82A0A0C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0A0CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A0A0D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A0A0D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A0A0D8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0A0DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A0A0E0: 4874A521  bl 0x83154600
	ctx.lr = 0x82A0A0E4;
	sub_83154600(ctx, base);
	// 82A0A0E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A0A0E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0A0EC: 4844F675  bl 0x82e59760
	ctx.lr = 0x82A0A0F0;
	sub_82E59760(ctx, base);
	// 82A0A0F0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A0A0F4: C00B81EC  lfs f0, -0x7e14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-32276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A0A0F8: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82A0A0FC: 419800E8  blt cr6, 0x82a0a1e4
	if ctx.cr[6].lt {
	pc = 0x82A0A1E4; continue 'dispatch;
	}
	// 82A0A100: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A0A104: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A0A108: 388B82F8  addi r4, r11, -0x7d08
	ctx.r[4].s64 = ctx.r[11].s64 + -32008;
	// 82A0A10C: 38A002BF  li r5, 0x2bf
	ctx.r[5].s64 = 703;
	// 82A0A110: 38600068  li r3, 0x68
	ctx.r[3].s64 = 104;
	// 82A0A114: 483E82D5  bl 0x82df23e8
	ctx.lr = 0x82A0A118;
	sub_82DF23E8(ctx, base);
	// 82A0A118: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A0A11C: 4182001C  beq 0x82a0a138
	if ctx.cr[0].eq {
	pc = 0x82A0A138; continue 'dispatch;
	}
	// 82A0A120: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0A124: 48452805  bl 0x82e5c928
	ctx.lr = 0x82A0A128;
	sub_82E5C928(ctx, base);
	// 82A0A128: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A0A12C: 396B8270  addi r11, r11, -0x7d90
	ctx.r[11].s64 = ctx.r[11].s64 + -32144;
	// 82A0A130: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A0A134: 48000008  b 0x82a0a13c
	pc = 0x82A0A13C; continue 'dispatch;
	// 82A0A138: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A0A13C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82A0A140: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0A144: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A0A148: 4BFFFA21  bl 0x82a09b68
	ctx.lr = 0x82A0A14C;
	sub_82A09B68(ctx, base);
	// 82A0A14C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A0A150: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0A154: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A0A158: 4B8B5EA9  bl 0x822c0000
	ctx.lr = 0x82A0A15C;
	sub_822C0000(ctx, base);
	// 82A0A15C: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A0A160: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A0A164: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A0A168: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82A0A16C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A0A170: 419A0024  beq cr6, 0x82a0a194
	if ctx.cr[6].eq {
	pc = 0x82A0A194; continue 'dispatch;
	}
	// 82A0A174: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82A0A178: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A0A17C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A0A180: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A0A184: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A0A188: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A0A18C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A0A190: 4082FFE8  bne 0x82a0a178
	if !ctx.cr[0].eq {
	pc = 0x82A0A178; continue 'dispatch;
	}
	// 82A0A194: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A0A198: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A0A19C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A0A1A0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82A0A1A4: 389E00E4  addi r4, r30, 0xe4
	ctx.r[4].s64 = ctx.r[30].s64 + 228;
	// 82A0A1A8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A0A1AC: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A0A1B0: 484544F9  bl 0x82e5e6a8
	ctx.lr = 0x82A0A1B4;
	sub_82E5E6A8(ctx, base);
	// 82A0A1B4: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A0A1B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0A1BC: 419A0008  beq cr6, 0x82a0a1c4
	if ctx.cr[6].eq {
	pc = 0x82A0A1C4; continue 'dispatch;
	}
	// 82A0A1C0: 4B8B66D1  bl 0x822c0890
	ctx.lr = 0x82A0A1C4;
	sub_822C0890(ctx, base);
	// 82A0A1C4: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A0A1C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0A1CC: 419A0008  beq cr6, 0x82a0a1d4
	if ctx.cr[6].eq {
	pc = 0x82A0A1D4; continue 'dispatch;
	}
	// 82A0A1D0: 4B8B66C1  bl 0x822c0890
	ctx.lr = 0x82A0A1D4;
	sub_822C0890(ctx, base);
	// 82A0A1D4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A0A1D8: 419A000C  beq cr6, 0x82a0a1e4
	if ctx.cr[6].eq {
	pc = 0x82A0A1E4; continue 'dispatch;
	}
	// 82A0A1DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0A1E0: 4B8B66B1  bl 0x822c0890
	ctx.lr = 0x82A0A1E4;
	sub_822C0890(ctx, base);
	// 82A0A1E4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A0A1E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0A1EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A0A1F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A0A1F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A0A1F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0A200(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A0A200 size=492
    let mut pc: u32 = 0x82A0A200;
    'dispatch: loop {
        match pc {
            0x82A0A200 => {
    //   block [0x82A0A200..0x82A0A3EC)
	// 82A0A200: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0A204: 4879DF65  bl 0x831a8168
	ctx.lr = 0x82A0A208;
	sub_831A8130(ctx, base);
	// 82A0A208: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82A0A20C: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0A210: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A0A214: 4874A3ED  bl 0x83154600
	ctx.lr = 0x82A0A218;
	sub_83154600(ctx, base);
	// 82A0A218: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A0A21C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0A220: 4844F541  bl 0x82e59760
	ctx.lr = 0x82A0A224;
	sub_82E59760(ctx, base);
	// 82A0A224: 895E0188  lbz r10, 0x188(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(392 as u32) ) } as u64;
	// 82A0A228: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A0A22C: 554A103E  rotlwi r10, r10, 2
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(2)) as u64;
	// 82A0A230: 3BABEF48  addi r29, r11, -0x10b8
	ctx.r[29].s64 = ctx.r[11].s64 + -4280;
	// 82A0A234: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A0A238: 7C0AEC2E  lfsx f0, r10, r29
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[29].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A0A23C: EC010024  fdivs f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 / ctx.f[0].f64) as f32) as f64;
	// 82A0A240: C1AB08A8  lfs f13, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A0A244: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A0A248: 41980008  blt cr6, 0x82a0a250
	if ctx.cr[6].lt {
	pc = 0x82A0A250; continue 'dispatch;
	}
	// 82A0A24C: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82A0A250: ED6D0028  fsubs f11, f13, f0
	ctx.f[11].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82A0A254: C15F0060  lfs f10, 0x60(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82A0A258: C1BF0064  lfs f13, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A0A25C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82A0A260: ED2D5028  fsubs f9, f13, f10
	ctx.f[9].f64 = (((ctx.f[13].f64 - ctx.f[10].f64) as f32) as f64);
	// 82A0A264: 3D40832E  lis r10, -0x7cd2
	ctx.r[10].s64 = -2094137344;
	// 82A0A268: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A0A26C: C1ABE830  lfs f13, -0x17d0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6096 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A0A270: C18AEF44  lfs f12, -0x10bc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-4284 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A0A274: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A0A278: EC09503A  fmadds f0, f9, f0, f10
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[0].f64 + ctx.f[10].f64) as f32) as f64);
	// 82A0A27C: EDAB0372  fmuls f13, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82A0A280: EFED033A  fmadds f31, f13, f12, f0
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82A0A284: 4BB07865  bl 0x82511ae8
	ctx.lr = 0x82A0A288;
	sub_82511AE8(ctx, base);
	// 82A0A288: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A0A28C: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 82A0A290: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82A0A294: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A0A298: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0A3F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A0A3F0 size=860
    let mut pc: u32 = 0x82A0A3F0;
    'dispatch: loop {
        match pc {
            0x82A0A3F0 => {
    //   block [0x82A0A3F0..0x82A0A74C)
	// 82A0A3F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0A3F4: 4879DD75  bl 0x831a8168
	ctx.lr = 0x82A0A3F8;
	sub_831A8130(ctx, base);
	// 82A0A3F8: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82A0A3FC: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0A750(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A0A750 size=164
    let mut pc: u32 = 0x82A0A750;
    'dispatch: loop {
        match pc {
            0x82A0A750 => {
    //   block [0x82A0A750..0x82A0A7F4)
	// 82A0A750: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0A754: 4879DA15  bl 0x831a8168
	ctx.lr = 0x82A0A758;
	sub_831A8130(ctx, base);
	// 82A0A758: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0A75C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82A0A760: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A0A764: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A0A768: 57BC063F  clrlwi. r28, r29, 0x18
	ctx.r[28].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82A0A76C: 41820038  beq 0x82a0a7a4
	if ctx.cr[0].eq {
	pc = 0x82A0A7A4; continue 'dispatch;
	}
	// 82A0A770: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0A774: 4879F215  bl 0x831a9988
	ctx.lr = 0x82A0A778;
	sub_831A9988(ctx, base);
	// 82A0A778: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 82A0A77C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A0A780: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 82A0A784: 4879D975  bl 0x831a80f8
	ctx.lr = 0x82A0A788;
	sub_831A80F8(ctx, base);
	// 82A0A788: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A0A78C: 41820018  beq 0x82a0a7a4
	if ctx.cr[0].eq {
	pc = 0x82A0A7A4; continue 'dispatch;
	}
	// 82A0A790: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0A794: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A0A798: 4BFFFC59  bl 0x82a0a3f0
	ctx.lr = 0x82A0A79C;
	sub_82A0A3F0(ctx, base);
	// 82A0A79C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A0A7A0: 4800004C  b 0x82a0a7ec
	pc = 0x82A0A7EC; continue 'dispatch;
	// 82A0A7A4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82A0A7A8: 419A0034  beq cr6, 0x82a0a7dc
	if ctx.cr[6].eq {
	pc = 0x82A0A7DC; continue 'dispatch;
	}
	// 82A0A7AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0A7B0: 4879F1D9  bl 0x831a9988
	ctx.lr = 0x82A0A7B4;
	sub_831A9988(ctx, base);
	// 82A0A7B4: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 82A0A7B8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A0A7BC: 386B67A0  addi r3, r11, 0x67a0
	ctx.r[3].s64 = ctx.r[11].s64 + 26528;
	// 82A0A7C0: 4879D939  bl 0x831a80f8
	ctx.lr = 0x82A0A7C4;
	sub_831A80F8(ctx, base);
	// 82A0A7C4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A0A7C8: 41820014  beq 0x82a0a7dc
	if ctx.cr[0].eq {
	pc = 0x82A0A7DC; continue 'dispatch;
	}
	// 82A0A7CC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0A7D0: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A0A7D4: 48101FCD  bl 0x82b0c7a0
	ctx.lr = 0x82A0A7D8;
	sub_82B0C7A0(ctx, base);
	// 82A0A7D8: 4BFFFFC4  b 0x82a0a79c
	pc = 0x82A0A79C; continue 'dispatch;
	// 82A0A7DC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A0A7E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0A7E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A0A7E8: 4BB07E31  bl 0x82512618
	ctx.lr = 0x82A0A7EC;
	sub_82512618(ctx, base);
	// 82A0A7EC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A0A7F0: 4879D9C8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0A7F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A0A7F8 size=76
    let mut pc: u32 = 0x82A0A7F8;
    'dispatch: loop {
        match pc {
            0x82A0A7F8 => {
    //   block [0x82A0A7F8..0x82A0A844)
	// 82A0A7F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0A7FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A0A800: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A0A804: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A0A808: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0A80C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A0A810: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A0A814: 4BFFF7AD  bl 0x82a09fc0
	ctx.lr = 0x82A0A818;
	sub_82A09FC0(ctx, base);
	// 82A0A818: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A0A81C: 4182000C  beq 0x82a0a828
	if ctx.cr[0].eq {
	pc = 0x82A0A828; continue 'dispatch;
	}
	// 82A0A820: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0A824: 483E7BB5  bl 0x82df23d8
	ctx.lr = 0x82A0A828;
	sub_82DF23D8(ctx, base);
	// 82A0A828: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0A82C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A0A830: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0A834: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A0A838: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A0A83C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A0A840: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0A848(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A0A848 size=564
    let mut pc: u32 = 0x82A0A848;
    'dispatch: loop {
        match pc {
            0x82A0A848 => {
    //   block [0x82A0A848..0x82A0AA7C)
	// 82A0A848: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0A84C: 4879D921  bl 0x831a816c
	ctx.lr = 0x82A0A850;
	sub_831A8130(ctx, base);
	// 82A0A850: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0A854: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A0A858: 48749DA9  bl 0x83154600
	ctx.lr = 0x82A0A85C;
	sub_83154600(ctx, base);
	// 82A0A85C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A0A860: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A0A864: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A0A868: 4BB07401  bl 0x82511c68
	ctx.lr = 0x82A0A86C;
	sub_82511C68(ctx, base);
	// 82A0A86C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0A870: 4BB07279  bl 0x82511ae8
	ctx.lr = 0x82A0A874;
	sub_82511AE8(ctx, base);
	// 82A0A874: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A0A878: 39400060  li r10, 0x60
	ctx.r[10].s64 = 96;
	// 82A0A87C: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 82A0A880: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A0A884: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82A0A888: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A0A88C: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0AA80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A0AA80 size=52
    let mut pc: u32 = 0x82A0AA80;
    'dispatch: loop {
        match pc {
            0x82A0AA80 => {
    //   block [0x82A0AA80..0x82A0AAB4)
	// 82A0AA80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0AA84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A0AA88: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A0AA8C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0AA90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A0AA94: 4BFFEF5D  bl 0x82a099f0
	ctx.lr = 0x82A0AA98;
	sub_82A099F0(ctx, base);
	// 82A0AA98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0AA9C: 4BFFF62D  bl 0x82a0a0c8
	ctx.lr = 0x82A0AAA0;
	sub_82A0A0C8(ctx, base);
	// 82A0AAA0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A0AAA4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0AAA8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A0AAAC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A0AAB0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0AAB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A0AAB8 size=952
    let mut pc: u32 = 0x82A0AAB8;
    'dispatch: loop {
        match pc {
            0x82A0AAB8 => {
    //   block [0x82A0AAB8..0x82A0AE70)
	// 82A0AAB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0AABC: 4879D6A5  bl 0x831a8160
	ctx.lr = 0x82A0AAC0;
	sub_831A8130(ctx, base);
	// 82A0AAC0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0AAC4: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82A0AAC8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A0AACC: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 82A0AAD0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82A0AAD4: 4BB06F05  bl 0x825119d8
	ctx.lr = 0x82A0AAD8;
	sub_825119D8(ctx, base);
	// 82A0AAD8: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82A0AADC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0AAE0: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 82A0AAE4: 483E8F25  bl 0x82df3a08
	ctx.lr = 0x82A0AAE8;
	sub_82DF3A08(ctx, base);
	// 82A0AAE8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A0AAEC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A0AAF0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A0AAF4: 4BAFDC8D  bl 0x82508780
	ctx.lr = 0x82A0AAF8;
	sub_82508780(ctx, base);
	// 82A0AAF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0AAFC: 483E892D  bl 0x82df3428
	ctx.lr = 0x82A0AB00;
	sub_82DF3428(ctx, base);
	// 82A0AB00: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A0AB04: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 82A0AB08: 409A0008  bne cr6, 0x82a0ab10
	if !ctx.cr[6].eq {
	pc = 0x82A0AB10; continue 'dispatch;
	}
	// 82A0AB0C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A0AB10: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A0AB14: 4BAFDC8D  bl 0x825087a0
	ctx.lr = 0x82A0AB18;
	sub_825087A0(ctx, base);
	// 82A0AB18: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A0AB1C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0AB20: 388B835C  addi r4, r11, -0x7ca4
	ctx.r[4].s64 = ctx.r[11].s64 + -31908;
	// 82A0AB24: 483E8EE5  bl 0x82df3a08
	ctx.lr = 0x82A0AB28;
	sub_82DF3A08(ctx, base);
	// 82A0AB28: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A0AB2C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A0AB30: 4BAFFE21  bl 0x8250a950
	ctx.lr = 0x82A0AB34;
	sub_8250A950(ctx, base);
	// 82A0AB34: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0AB38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0AB3C: 3BCBFF40  addi r30, r11, -0xc0
	ctx.r[30].s64 = ctx.r[11].s64 + -192;
	// 82A0AB40: 409A0008  bne cr6, 0x82a0ab48
	if !ctx.cr[6].eq {
	pc = 0x82A0AB48; continue 'dispatch;
	}
	// 82A0AB44: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A0AB48: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0AB4C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A0AB50: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 82A0AB54: 4BB075C5  bl 0x82512118
	ctx.lr = 0x82A0AB58;
	sub_82512118(ctx, base);
	// 82A0AB58: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A0AB5C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A0AB60: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A0AB64: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82A0AB68: 38E0000B  li r7, 0xb
	ctx.r[7].s64 = 11;
	// 82A0AB6C: 4BDCA145  bl 0x827d4cb0
	ctx.lr = 0x82A0AB70;
	sub_827D4CB0(ctx, base);
	// 82A0AB70: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A0AB74: 395F0144  addi r10, r31, 0x144
	ctx.r[10].s64 = ctx.r[31].s64 + 324;
	// 82A0AB78: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82A0AB7C: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 82A0AB80: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0AB84: 917F0144  stw r11, 0x144(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(324 as u32), ctx.r[11].u32 ) };
	// 82A0AB88: 4B8B98D9  bl 0x822c4460
	ctx.lr = 0x82A0AB8C;
	sub_822C4460(ctx, base);
	// 82A0AB8C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A0AB90: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0AB94: 419A0008  beq cr6, 0x82a0ab9c
	if ctx.cr[6].eq {
	pc = 0x82A0AB9C; continue 'dispatch;
	}
	// 82A0AB98: 4B8B5CF9  bl 0x822c0890
	ctx.lr = 0x82A0AB9C;
	sub_822C0890(ctx, base);
	// 82A0AB9C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A0ABA0: 483E70F1  bl 0x82df1c90
	ctx.lr = 0x82A0ABA4;
	sub_82DF1C90(ctx, base);
	// 82A0ABA4: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82A0ABA8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0ABAC: 419A0008  beq cr6, 0x82a0abb4
	if ctx.cr[6].eq {
	pc = 0x82A0ABB4; continue 'dispatch;
	}
	// 82A0ABB0: 4B8B5CE1  bl 0x822c0890
	ctx.lr = 0x82A0ABB4;
	sub_822C0890(ctx, base);
	// 82A0ABB4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0ABB8: 483E8871  bl 0x82df3428
	ctx.lr = 0x82A0ABBC;
	sub_82DF3428(ctx, base);
	// 82A0ABBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0ABC0: 4BB07ED9  bl 0x82512a98
	ctx.lr = 0x82A0ABC4;
	sub_82512A98(ctx, base);
	// 82A0ABC4: 83AD0000  lwz r29, 0(r13)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0ABC8: 3B800014  li r28, 0x14
	ctx.r[28].s64 = 20;
	// 82A0ABCC: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 82A0ABD0: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 82A0ABD4: 7C7CE82E  lwzx r3, r28, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82A0ABD8: 48495B59  bl 0x82ea0730
	ctx.lr = 0x82A0ABDC;
	sub_82EA0730(ctx, base);
	// 82A0ABDC: 3B600020  li r27, 0x20
	ctx.r[27].s64 = 32;
	// 82A0ABE0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A0ABE4: B3630004  sth r27, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[27].u16 ) };
	// 82A0ABE8: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A0ABEC: 4850F605  bl 0x82f1a1f0
	ctx.lr = 0x82A0ABF0;
	sub_82F1A1F0(ctx, base);
	// 82A0ABF0: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82A0ABF4: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 82A0ABF8: 4182000C  beq 0x82a0ac04
	if ctx.cr[0].eq {
	pc = 0x82A0AC04; continue 'dispatch;
	}
	// 82A0ABFC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A0AC00: 4B8DD649  bl 0x822e8248
	ctx.lr = 0x82A0AC04;
	sub_822E8248(ctx, base);
	// 82A0AC04: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A0AC08: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0AC0C: 388B834C  addi r4, r11, -0x7cb4
	ctx.r[4].s64 = ctx.r[11].s64 + -31924;
	// 82A0AC10: 483EE921  bl 0x82df9530
	ctx.lr = 0x82A0AC14;
	sub_82DF9530(ctx, base);
	// 82A0AC14: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82A0AC18: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A0AC1C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82A0AC20: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A0AC24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0AC28: 80CB6734  lwz r6, 0x6734(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26420 as u32) ) } as u64;
	// 82A0AC2C: 4BB084BD  bl 0x825130e8
	ctx.lr = 0x82A0AC30;
	sub_825130E8(ctx, base);
	// 82A0AC30: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A0AC34: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0AC38: 419A0008  beq cr6, 0x82a0ac40
	if ctx.cr[6].eq {
	pc = 0x82A0AC40; continue 'dispatch;
	}
	// 82A0AC3C: 4B8DD62D  bl 0x822e8268
	ctx.lr = 0x82A0AC40;
	sub_822E8268(ctx, base);
	// 82A0AC40: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A0AC44: 419A000C  beq cr6, 0x82a0ac50
	if ctx.cr[6].eq {
	pc = 0x82A0AC50; continue 'dispatch;
	}
	// 82A0AC48: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A0AC4C: 4B8DD61D  bl 0x822e8268
	ctx.lr = 0x82A0AC50;
	sub_822E8268(ctx, base);
	// 82A0AC50: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 82A0AC54: 7C7CE82E  lwzx r3, r28, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82A0AC58: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 82A0AC5C: 48495AD5  bl 0x82ea0730
	ctx.lr = 0x82A0AC60;
	sub_82EA0730(ctx, base);
	// 82A0AC60: B3630004  sth r27, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[27].u16 ) };
	// 82A0AC64: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A0AC68: C02B9524  lfs f1, -0x6adc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A0AC6C: 4850F585  bl 0x82f1a1f0
	ctx.lr = 0x82A0AC70;
	sub_82F1A1F0(ctx, base);
	// 82A0AC70: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82A0AC74: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 82A0AC78: 4182000C  beq 0x82a0ac84
	if ctx.cr[0].eq {
	pc = 0x82A0AC84; continue 'dispatch;
	}
	// 82A0AC7C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A0AC80: 4B8DD5C9  bl 0x822e8248
	ctx.lr = 0x82A0AC84;
	sub_822E8248(ctx, base);
	// 82A0AC84: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A0AC88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0AC8C: 388B833C  addi r4, r11, -0x7cc4
	ctx.r[4].s64 = ctx.r[11].s64 + -31940;
	// 82A0AC90: 483EE8A1  bl 0x82df9530
	ctx.lr = 0x82A0AC94;
	sub_82DF9530(ctx, base);
	// 82A0AC94: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82A0AC98: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82A0AC9C: 808B67D4  lwz r4, 0x67d4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26580 as u32) ) } as u64;
	// 82A0ACA0: 4B8DA291  bl 0x822e4f30
	ctx.lr = 0x82A0ACA4;
	sub_822E4F30(ctx, base);
	// 82A0ACA4: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82A0ACA8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A0ACAC: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82A0ACB0: 808B6790  lwz r4, 0x6790(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26512 as u32) ) } as u64;
	// 82A0ACB4: 4B8DA27D  bl 0x822e4f30
	ctx.lr = 0x82A0ACB8;
	sub_822E4F30(ctx, base);
	// 82A0ACB8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82A0ACBC: E89D0000  ld r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	// 82A0ACC0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A0ACC4: E8630000  ld r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 82A0ACC8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A0ACCC: 4BA815BD  bl 0x8248c288
	ctx.lr = 0x82A0ACD0;
	sub_8248C288(ctx, base);
	// 82A0ACD0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A0ACD4: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 82A0ACD8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A0ACDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0ACE0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A0ACE4: 4BB08405  bl 0x825130e8
	ctx.lr = 0x82A0ACE8;
	sub_825130E8(ctx, base);
	// 82A0ACE8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A0ACEC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0ACF0: 419A0008  beq cr6, 0x82a0acf8
	if ctx.cr[6].eq {
	pc = 0x82A0ACF8; continue 'dispatch;
	}
	// 82A0ACF4: 4B8DD575  bl 0x822e8268
	ctx.lr = 0x82A0ACF8;
	sub_822E8268(ctx, base);
	// 82A0ACF8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A0ACFC: 419A000C  beq cr6, 0x82a0ad08
	if ctx.cr[6].eq {
	pc = 0x82A0AD08; continue 'dispatch;
	}
	// 82A0AD00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A0AD04: 4B8DD565  bl 0x822e8268
	ctx.lr = 0x82A0AD08;
	sub_822E8268(ctx, base);
	// 82A0AD08: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A0AD0C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A0AD10: 3BAB82F8  addi r29, r11, -0x7d08
	ctx.r[29].s64 = ctx.r[11].s64 + -32008;
	// 82A0AD14: 38A000A7  li r5, 0xa7
	ctx.r[5].s64 = 167;
	// 82A0AD18: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A0AD1C: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 82A0AD20: 4B8B56B9  bl 0x822c03d8
	ctx.lr = 0x82A0AD24;
	sub_822C03D8(ctx, base);
	// 82A0AD24: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82A0AD28: 41820028  beq 0x82a0ad50
	if ctx.cr[0].eq {
	pc = 0x82A0AD50; continue 'dispatch;
	}
	// 82A0AD2C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0AD30: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A0AD34: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 82A0AD38: 4BB047E1  bl 0x8250f518
	ctx.lr = 0x82A0AD3C;
	sub_8250F518(ctx, base);
	// 82A0AD3C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A0AD40: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A0AD44: 4BA863AD  bl 0x824910f0
	ctx.lr = 0x82A0AD48;
	sub_824910F0(ctx, base);
	// 82A0AD48: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A0AD4C: 48000008  b 0x82a0ad54
	pc = 0x82A0AD54; continue 'dispatch;
	// 82A0AD50: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A0AD54: 387F0180  addi r3, r31, 0x180
	ctx.r[3].s64 = ctx.r[31].s64 + 384;
	// 82A0AD58: 4B8FF989  bl 0x8230a6e0
	ctx.lr = 0x82A0AD5C;
	sub_8230A6E0(ctx, base);
	// 82A0AD5C: 574B07FF  clrlwi. r11, r26, 0x1f
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A0AD60: 4182000C  beq 0x82a0ad6c
	if ctx.cr[0].eq {
	pc = 0x82A0AD6C; continue 'dispatch;
	}
	// 82A0AD64: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A0AD68: 483E6F29  bl 0x82df1c90
	ctx.lr = 0x82A0AD6C;
	sub_82DF1C90(ctx, base);
	// 82A0AD6C: 817F00E4  lwz r11, 0xe4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 82A0AD70: 3BDF00E4  addi r30, r31, 0xe4
	ctx.r[30].s64 = ctx.r[31].s64 + 228;
	// 82A0AD74: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0AD78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A0AD7C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A0AD80: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A0AD84: 4E800421  bctrl
	ctx.lr = 0x82A0AD88;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A0AD88: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A0AD8C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A0AD90: 38A000AF  li r5, 0xaf
	ctx.r[5].s64 = 175;
	// 82A0AD94: 38600080  li r3, 0x80
	ctx.r[3].s64 = 128;
	// 82A0AD98: 483E7651  bl 0x82df23e8
	ctx.lr = 0x82A0AD9C;
	sub_82DF23E8(ctx, base);
	// 82A0AD9C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A0ADA0: 4182001C  beq 0x82a0adbc
	if ctx.cr[0].eq {
	pc = 0x82A0ADBC; continue 'dispatch;
	}
	// 82A0ADA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0ADA8: 48451B81  bl 0x82e5c928
	ctx.lr = 0x82A0ADAC;
	sub_82E5C928(ctx, base);
	// 82A0ADAC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A0ADB0: 396B8248  addi r11, r11, -0x7db8
	ctx.r[11].s64 = ctx.r[11].s64 + -32184;
	// 82A0ADB4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A0ADB8: 48000008  b 0x82a0adc0
	pc = 0x82A0ADC0; continue 'dispatch;
	// 82A0ADBC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A0ADC0: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82A0ADC4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0ADC8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A0ADCC: 4BFFECD5  bl 0x82a09aa0
	ctx.lr = 0x82A0ADD0;
	sub_82A09AA0(ctx, base);
	// 82A0ADD0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A0ADD4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0ADD8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A0ADDC: 4B8B5225  bl 0x822c0000
	ctx.lr = 0x82A0ADE0;
	sub_822C0000(ctx, base);
	// 82A0ADE0: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A0ADE4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A0ADE8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A0ADEC: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 82A0ADF0: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A0ADF4: 419A0024  beq cr6, 0x82a0ae18
	if ctx.cr[6].eq {
	pc = 0x82A0AE18; continue 'dispatch;
	}
	// 82A0ADF8: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82A0ADFC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A0AE00: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A0AE04: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A0AE08: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A0AE0C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A0AE10: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A0AE14: 4082FFE8  bne 0x82a0adfc
	if !ctx.cr[0].eq {
	pc = 0x82A0ADFC; continue 'dispatch;
	}
	// 82A0AE18: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A0AE1C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A0AE20: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A0AE24: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82A0AE28: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A0AE2C: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82A0AE30: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A0AE34: 48453875  bl 0x82e5e6a8
	ctx.lr = 0x82A0AE38;
	sub_82E5E6A8(ctx, base);
	// 82A0AE38: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82A0AE3C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0AE40: 419A0008  beq cr6, 0x82a0ae48
	if ctx.cr[6].eq {
	pc = 0x82A0AE48; continue 'dispatch;
	}
	// 82A0AE44: 4B8B5A4D  bl 0x822c0890
	ctx.lr = 0x82A0AE48;
	sub_822C0890(ctx, base);
	// 82A0AE48: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A0AE4C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0AE50: 419A0008  beq cr6, 0x82a0ae58
	if ctx.cr[6].eq {
	pc = 0x82A0AE58; continue 'dispatch;
	}
	// 82A0AE54: 4B8B5A3D  bl 0x822c0890
	ctx.lr = 0x82A0AE58;
	sub_822C0890(ctx, base);
	// 82A0AE58: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A0AE5C: 419A000C  beq cr6, 0x82a0ae68
	if ctx.cr[6].eq {
	pc = 0x82A0AE68; continue 'dispatch;
	}
	// 82A0AE60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0AE64: 4B8B5A2D  bl 0x822c0890
	ctx.lr = 0x82A0AE68;
	sub_822C0890(ctx, base);
	// 82A0AE68: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82A0AE6C: 4879D344  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0AE70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A0AE70 size=108
    let mut pc: u32 = 0x82A0AE70;
    'dispatch: loop {
        match pc {
            0x82A0AE70 => {
    //   block [0x82A0AE70..0x82A0AEDC)
	// 82A0AE70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0AE74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A0AE78: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A0AE7C: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0AE80: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82A0AE84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A0AE88: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82A0AE8C: 386BFEBC  addi r3, r11, -0x144
	ctx.r[3].s64 = ctx.r[11].s64 + -324;
	// 82A0AE90: 4BB06F09  bl 0x82511d98
	ctx.lr = 0x82A0AE94;
	sub_82511D98(ctx, base);
	// 82A0AE94: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A0AE98: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82A0AE9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0AEA0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A0AEA4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82A0AEA8: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A0AEAC: C1AA9524  lfs f13, -0x6adc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A0AEB0: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82A0AEB4: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82A0AEB8: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82A0AEBC: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82A0AEC0: 48470E09  bl 0x82e7bcc8
	ctx.lr = 0x82A0AEC4;
	sub_82E7BCC8(ctx, base);
	// 82A0AEC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0AEC8: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A0AECC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0AED0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A0AED4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A0AED8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0AEE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A0AEE0 size=92
    let mut pc: u32 = 0x82A0AEE0;
    'dispatch: loop {
        match pc {
            0x82A0AEE0 => {
    //   block [0x82A0AEE0..0x82A0AF3C)
	// 82A0AEE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0AEE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A0AEE8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A0AEEC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0AEF0: E96301E6  lwa r11, 0x1e4(r3)
	ctx.r[11].s64 = (unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(484 as u32) ) } as i32) as i64;
	// 82A0AEF4: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A0AEF8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82A0AEFC: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A0AF00: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 82A0AF04: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A0AF08: C00A8498  lfs f0, -0x7b68(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-31592 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A0AF0C: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82A0AF10: D01F001C  stfs f0, 0x1c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82A0AF14: D1BF0018  stfs f13, 0x18(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82A0AF18: 4BB06BD1  bl 0x82511ae8
	ctx.lr = 0x82A0AF1C;
	sub_82511AE8(ctx, base);
	// 82A0AF1C: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 82A0AF20: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0AF40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A0AF40 size=108
    let mut pc: u32 = 0x82A0AF40;
    'dispatch: loop {
        match pc {
            0x82A0AF40 => {
    //   block [0x82A0AF40..0x82A0AFAC)
	// 82A0AF40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0AF44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A0AF48: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A0AF4C: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0AF50: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A0AF54: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82A0AF58: 4BB06E41  bl 0x82511d98
	ctx.lr = 0x82A0AF5C;
	sub_82511D98(ctx, base);
	// 82A0AF5C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A0AF60: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82A0AF64: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A0AF68: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82A0AF6C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A0AF70: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A0AF74: C1AAD7BC  lfs f13, -0x2844(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A0AF78: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82A0AF7C: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82A0AF80: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82A0AF84: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82A0AF88: 48470D41  bl 0x82e7bcc8
	ctx.lr = 0x82A0AF8C;
	sub_82E7BCC8(ctx, base);
	// 82A0AF8C: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A0AF90: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0AFB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A0AFB0 size=196
    let mut pc: u32 = 0x82A0AFB0;
    'dispatch: loop {
        match pc {
            0x82A0AFB0 => {
    //   block [0x82A0AFB0..0x82A0B074)
	// 82A0AFB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0AFB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A0AFB8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A0AFBC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A0AFC0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0AFC4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A0AFC8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A0AFCC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A0AFD0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A0AFD4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A0AFD8: 4B8B5961  bl 0x822c0938
	ctx.lr = 0x82A0AFDC;
	sub_822C0938(ctx, base);
	// 82A0AFDC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A0AFE0: 41820028  beq 0x82a0b008
	if ctx.cr[0].eq {
	pc = 0x82A0B008; continue 'dispatch;
	}
	// 82A0AFE4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A0AFE8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A0AFEC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A0AFF0: 392B8384  addi r9, r11, -0x7c7c
	ctx.r[9].s64 = ctx.r[11].s64 + -31868;
	// 82A0AFF4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A0AFF8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A0AFFC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A0B000: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A0B004: 48000008  b 0x82a0b00c
	pc = 0x82A0B00C; continue 'dispatch;
	// 82A0B008: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A0B00C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A0B010: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0B014: 409A0044  bne cr6, 0x82a0b058
	if !ctx.cr[6].eq {
	pc = 0x82A0B058; continue 'dispatch;
	}
	// 82A0B018: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A0B01C: 419A001C  beq cr6, 0x82a0b038
	if ctx.cr[6].eq {
	pc = 0x82A0B038; continue 'dispatch;
	}
	// 82A0B020: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0B024: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A0B028: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0B02C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0B030: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A0B034: 4E800421  bctrl
	ctx.lr = 0x82A0B038;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A0B038: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A0B03C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A0B040: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0B044: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A0B048: 816BF174  lwz r11, -0xe8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3724 as u32) ) } as u64;
	// 82A0B04C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A0B050: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A0B054: 4B8B4FAD  bl 0x822c0000
	ctx.lr = 0x82A0B058;
	sub_822C0000(ctx, base);
	// 82A0B058: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A0B05C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A0B060: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0B064: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A0B068: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A0B06C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A0B070: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0B078(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A0B078 size=196
    let mut pc: u32 = 0x82A0B078;
    'dispatch: loop {
        match pc {
            0x82A0B078 => {
    //   block [0x82A0B078..0x82A0B13C)
	// 82A0B078: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0B07C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A0B080: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A0B084: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A0B088: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0B08C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A0B090: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A0B094: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A0B098: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A0B09C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A0B0A0: 4B8B5899  bl 0x822c0938
	ctx.lr = 0x82A0B0A4;
	sub_822C0938(ctx, base);
	// 82A0B0A4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A0B0A8: 41820028  beq 0x82a0b0d0
	if ctx.cr[0].eq {
	pc = 0x82A0B0D0; continue 'dispatch;
	}
	// 82A0B0AC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A0B0B0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A0B0B4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A0B0B8: 392B8398  addi r9, r11, -0x7c68
	ctx.r[9].s64 = ctx.r[11].s64 + -31848;
	// 82A0B0BC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A0B0C0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A0B0C4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A0B0C8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A0B0CC: 48000008  b 0x82a0b0d4
	pc = 0x82A0B0D4; continue 'dispatch;
	// 82A0B0D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A0B0D4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A0B0D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0B0DC: 409A0044  bne cr6, 0x82a0b120
	if !ctx.cr[6].eq {
	pc = 0x82A0B120; continue 'dispatch;
	}
	// 82A0B0E0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A0B0E4: 419A001C  beq cr6, 0x82a0b100
	if ctx.cr[6].eq {
	pc = 0x82A0B100; continue 'dispatch;
	}
	// 82A0B0E8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0B0EC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A0B0F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0B0F4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0B0F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A0B0FC: 4E800421  bctrl
	ctx.lr = 0x82A0B100;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A0B100: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A0B104: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A0B108: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0B10C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A0B110: 816BF174  lwz r11, -0xe8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3724 as u32) ) } as u64;
	// 82A0B114: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A0B118: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A0B11C: 4B8B4EE5  bl 0x822c0000
	ctx.lr = 0x82A0B120;
	sub_822C0000(ctx, base);
	// 82A0B120: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A0B124: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A0B128: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0B12C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A0B130: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A0B134: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A0B138: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0B140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A0B140 size=196
    let mut pc: u32 = 0x82A0B140;
    'dispatch: loop {
        match pc {
            0x82A0B140 => {
    //   block [0x82A0B140..0x82A0B204)
	// 82A0B140: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0B144: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A0B148: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A0B14C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A0B150: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0B154: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A0B158: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A0B15C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A0B160: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A0B164: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A0B168: 4B8B57D1  bl 0x822c0938
	ctx.lr = 0x82A0B16C;
	sub_822C0938(ctx, base);
	// 82A0B16C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A0B170: 41820028  beq 0x82a0b198
	if ctx.cr[0].eq {
	pc = 0x82A0B198; continue 'dispatch;
	}
	// 82A0B174: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A0B178: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A0B17C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A0B180: 392B83AC  addi r9, r11, -0x7c54
	ctx.r[9].s64 = ctx.r[11].s64 + -31828;
	// 82A0B184: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A0B188: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A0B18C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A0B190: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A0B194: 48000008  b 0x82a0b19c
	pc = 0x82A0B19C; continue 'dispatch;
	// 82A0B198: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A0B19C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A0B1A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0B1A4: 409A0044  bne cr6, 0x82a0b1e8
	if !ctx.cr[6].eq {
	pc = 0x82A0B1E8; continue 'dispatch;
	}
	// 82A0B1A8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A0B1AC: 419A001C  beq cr6, 0x82a0b1c8
	if ctx.cr[6].eq {
	pc = 0x82A0B1C8; continue 'dispatch;
	}
	// 82A0B1B0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0B1B4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A0B1B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0B1BC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0B1C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A0B1C4: 4E800421  bctrl
	ctx.lr = 0x82A0B1C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A0B1C8: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A0B1CC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A0B1D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0B1D4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A0B1D8: 816BF174  lwz r11, -0xe8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3724 as u32) ) } as u64;
	// 82A0B1DC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A0B1E0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A0B1E4: 4B8B4E1D  bl 0x822c0000
	ctx.lr = 0x82A0B1E8;
	sub_822C0000(ctx, base);
	// 82A0B1E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A0B1EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A0B1F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0B1F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A0B1F8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A0B1FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A0B200: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0B208(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A0B208 size=196
    let mut pc: u32 = 0x82A0B208;
    'dispatch: loop {
        match pc {
            0x82A0B208 => {
    //   block [0x82A0B208..0x82A0B2CC)
	// 82A0B208: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0B20C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A0B210: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A0B214: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A0B218: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0B21C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A0B220: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A0B224: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A0B228: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A0B22C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A0B230: 4B8B5709  bl 0x822c0938
	ctx.lr = 0x82A0B234;
	sub_822C0938(ctx, base);
	// 82A0B234: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A0B238: 41820028  beq 0x82a0b260
	if ctx.cr[0].eq {
	pc = 0x82A0B260; continue 'dispatch;
	}
	// 82A0B23C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A0B240: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A0B244: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A0B248: 392B83C0  addi r9, r11, -0x7c40
	ctx.r[9].s64 = ctx.r[11].s64 + -31808;
	// 82A0B24C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A0B250: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A0B254: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A0B258: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A0B25C: 48000008  b 0x82a0b264
	pc = 0x82A0B264; continue 'dispatch;
	// 82A0B260: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A0B264: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A0B268: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0B26C: 409A0044  bne cr6, 0x82a0b2b0
	if !ctx.cr[6].eq {
	pc = 0x82A0B2B0; continue 'dispatch;
	}
	// 82A0B270: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A0B274: 419A001C  beq cr6, 0x82a0b290
	if ctx.cr[6].eq {
	pc = 0x82A0B290; continue 'dispatch;
	}
	// 82A0B278: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0B27C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A0B280: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0B284: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0B288: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A0B28C: 4E800421  bctrl
	ctx.lr = 0x82A0B290;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A0B290: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A0B294: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A0B298: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0B29C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A0B2A0: 816BF174  lwz r11, -0xe8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3724 as u32) ) } as u64;
	// 82A0B2A4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A0B2A8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A0B2AC: 4B8B4D55  bl 0x822c0000
	ctx.lr = 0x82A0B2B0;
	sub_822C0000(ctx, base);
	// 82A0B2B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A0B2B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A0B2B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0B2BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A0B2C0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A0B2C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A0B2C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0B2D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A0B2D0 size=196
    let mut pc: u32 = 0x82A0B2D0;
    'dispatch: loop {
        match pc {
            0x82A0B2D0 => {
    //   block [0x82A0B2D0..0x82A0B394)
	// 82A0B2D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0B2D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A0B2D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A0B2DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A0B2E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0B2E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A0B2E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A0B2EC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A0B2F0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A0B2F4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A0B2F8: 4B8B5641  bl 0x822c0938
	ctx.lr = 0x82A0B2FC;
	sub_822C0938(ctx, base);
	// 82A0B2FC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A0B300: 41820028  beq 0x82a0b328
	if ctx.cr[0].eq {
	pc = 0x82A0B328; continue 'dispatch;
	}
	// 82A0B304: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A0B308: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A0B30C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A0B310: 392B83D4  addi r9, r11, -0x7c2c
	ctx.r[9].s64 = ctx.r[11].s64 + -31788;
	// 82A0B314: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A0B318: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A0B31C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A0B320: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A0B324: 48000008  b 0x82a0b32c
	pc = 0x82A0B32C; continue 'dispatch;
	// 82A0B328: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A0B32C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A0B330: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0B334: 409A0044  bne cr6, 0x82a0b378
	if !ctx.cr[6].eq {
	pc = 0x82A0B378; continue 'dispatch;
	}
	// 82A0B338: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A0B33C: 419A001C  beq cr6, 0x82a0b358
	if ctx.cr[6].eq {
	pc = 0x82A0B358; continue 'dispatch;
	}
	// 82A0B340: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0B344: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A0B348: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0B34C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0B350: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A0B354: 4E800421  bctrl
	ctx.lr = 0x82A0B358;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A0B358: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A0B35C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A0B360: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0B364: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A0B368: 816BF174  lwz r11, -0xe8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3724 as u32) ) } as u64;
	// 82A0B36C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A0B370: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A0B374: 4B8B4C8D  bl 0x822c0000
	ctx.lr = 0x82A0B378;
	sub_822C0000(ctx, base);
	// 82A0B378: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A0B37C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A0B380: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0B384: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A0B388: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A0B38C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A0B390: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0B398(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A0B398 size=196
    let mut pc: u32 = 0x82A0B398;
    'dispatch: loop {
        match pc {
            0x82A0B398 => {
    //   block [0x82A0B398..0x82A0B45C)
	// 82A0B398: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0B39C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A0B3A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A0B3A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A0B3A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0B3AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A0B3B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A0B3B4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A0B3B8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A0B3BC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A0B3C0: 4B8B5579  bl 0x822c0938
	ctx.lr = 0x82A0B3C4;
	sub_822C0938(ctx, base);
	// 82A0B3C4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A0B3C8: 41820028  beq 0x82a0b3f0
	if ctx.cr[0].eq {
	pc = 0x82A0B3F0; continue 'dispatch;
	}
	// 82A0B3CC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A0B3D0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A0B3D4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A0B3D8: 392B83E8  addi r9, r11, -0x7c18
	ctx.r[9].s64 = ctx.r[11].s64 + -31768;
	// 82A0B3DC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A0B3E0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A0B3E4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A0B3E8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A0B3EC: 48000008  b 0x82a0b3f4
	pc = 0x82A0B3F4; continue 'dispatch;
	// 82A0B3F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A0B3F4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A0B3F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0B3FC: 409A0044  bne cr6, 0x82a0b440
	if !ctx.cr[6].eq {
	pc = 0x82A0B440; continue 'dispatch;
	}
	// 82A0B400: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A0B404: 419A001C  beq cr6, 0x82a0b420
	if ctx.cr[6].eq {
	pc = 0x82A0B420; continue 'dispatch;
	}
	// 82A0B408: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0B40C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A0B410: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0B414: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0B418: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A0B41C: 4E800421  bctrl
	ctx.lr = 0x82A0B420;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A0B420: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A0B424: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A0B428: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0B42C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A0B430: 816BF174  lwz r11, -0xe8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3724 as u32) ) } as u64;
	// 82A0B434: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A0B438: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A0B43C: 4B8B4BC5  bl 0x822c0000
	ctx.lr = 0x82A0B440;
	sub_822C0000(ctx, base);
	// 82A0B440: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A0B444: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A0B448: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0B44C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A0B450: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A0B454: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A0B458: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0B460(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A0B460 size=204
    let mut pc: u32 = 0x82A0B460;
    'dispatch: loop {
        match pc {
            0x82A0B460 => {
    //   block [0x82A0B460..0x82A0B52C)
	// 82A0B460: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0B464: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A0B468: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A0B46C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A0B470: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0B474: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A0B478: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A0B47C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82A0B480: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A0B484: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0B488: 997E0019  stb r11, 0x19(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 82A0B48C: 388A7868  addi r4, r10, 0x7868
	ctx.r[4].s64 = ctx.r[10].s64 + 30824;
	// 82A0B490: 483E8579  bl 0x82df3a08
	ctx.lr = 0x82A0B494;
	sub_82DF3A08(ctx, base);
	// 82A0B494: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A0B498: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A0B49C: 809F0148  lwz r4, 0x148(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(328 as u32) ) } as u64;
	// 82A0B4A0: 48409B91  bl 0x82e15030
	ctx.lr = 0x82A0B4A4;
	sub_82E15030(ctx, base);
	// 82A0B4A4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A0B4A8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A0B4AC: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0B4B0: 3BE10060  addi r31, r1, 0x60
	ctx.r[31].s64 = ctx.r[1].s64 + 96;
	// 82A0B4B4: C1ABA1C4  lfs f13, -0x5e3c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A0B4B8: C00A08A4  lfs f0, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A0B4BC: D1A10060  stfs f13, 0x60(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A0B4C0: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82A0B4C4: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82A0B4C8: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82A0B4CC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0B4D0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A0B4D4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A0B4D8: 4E800421  bctrl
	ctx.lr = 0x82A0B4DC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A0B4DC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A0B4E0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A0B4E4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A0B4E8: 484707E1  bl 0x82e7bcc8
	ctx.lr = 0x82A0B4EC;
	sub_82E7BCC8(ctx, base);
	// 82A0B4EC: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 82A0B4F0: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A0B4F4: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A0B4F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0B530(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A0B530 size=372
    let mut pc: u32 = 0x82A0B530;
    'dispatch: loop {
        match pc {
            0x82A0B530 => {
    //   block [0x82A0B530..0x82A0B6A4)
	// 82A0B530: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0B534: 4879CC25  bl 0x831a8158
	ctx.lr = 0x82A0B538;
	sub_831A8130(ctx, base);
	// 82A0B538: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0B53C: 7D1D4378  mr r29, r8
	ctx.r[29].u64 = ctx.r[8].u64;
	// 82A0B540: 7D3E4B78  mr r30, r9
	ctx.r[30].u64 = ctx.r[9].u64;
	// 82A0B544: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82A0B548: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82A0B54C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A0B550: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A0B554: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A0B558: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 82A0B55C: 7CF93B78  mr r25, r7
	ctx.r[25].u64 = ctx.r[7].u64;
	// 82A0B560: 7D585378  mr r24, r10
	ctx.r[24].u64 = ctx.r[10].u64;
	// 82A0B564: 4BB06CFD  bl 0x82512260
	ctx.lr = 0x82A0B568;
	sub_82512260(ctx, base);
	// 82A0B568: 387F00E4  addi r3, r31, 0xe4
	ctx.r[3].s64 = ctx.r[31].s64 + 228;
	// 82A0B56C: 48452365  bl 0x82e5d8d0
	ctx.lr = 0x82A0B570;
	sub_82E5D8D0(ctx, base);
	// 82A0B570: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A0B574: 387F0144  addi r3, r31, 0x144
	ctx.r[3].s64 = ctx.r[31].s64 + 324;
	// 82A0B578: 396B8374  addi r11, r11, -0x7c8c
	ctx.r[11].s64 = ctx.r[11].s64 + -31884;
	// 82A0B57C: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 82A0B580: 4BF3B8D1  bl 0x82946e50
	ctx.lr = 0x82A0B584;
	sub_82946E50(ctx, base);
	// 82A0B584: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A0B588: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A0B58C: 396B850C  addi r11, r11, -0x7af4
	ctx.r[11].s64 = ctx.r[11].s64 + -31476;
	// 82A0B590: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82A0B594: 3D00820B  lis r8, -0x7df5
	ctx.r[8].s64 = -2113208320;
	// 82A0B598: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A0B59C: 394A84F4  addi r10, r10, -0x7b0c
	ctx.r[10].s64 = ctx.r[10].s64 + -31500;
	// 82A0B5A0: 392984E4  addi r9, r9, -0x7b1c
	ctx.r[9].s64 = ctx.r[9].s64 + -31516;
	// 82A0B5A4: 390884C8  addi r8, r8, -0x7b38
	ctx.r[8].s64 = ctx.r[8].s64 + -31544;
	// 82A0B5A8: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82A0B5AC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A0B5B0: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 82A0B5B4: 911F0144  stw r8, 0x144(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(324 as u32), ctx.r[8].u32 ) };
	// 82A0B5B8: 395F0160  addi r10, r31, 0x160
	ctx.r[10].s64 = ctx.r[31].s64 + 352;
	// 82A0B5BC: 917F0148  stw r11, 0x148(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(328 as u32), ctx.r[11].u32 ) };
	// 82A0B5C0: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 82A0B5C4: 917F014C  stw r11, 0x14c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(332 as u32), ctx.r[11].u32 ) };
	// 82A0B5C8: 917F0150  stw r11, 0x150(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), ctx.r[11].u32 ) };
	// 82A0B5CC: 917F0154  stw r11, 0x154(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(340 as u32), ctx.r[11].u32 ) };
	// 82A0B5D0: 917F0158  stw r11, 0x158(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(344 as u32), ctx.r[11].u32 ) };
	// 82A0B5D4: 917F015C  stw r11, 0x15c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(348 as u32), ctx.r[11].u32 ) };
	// 82A0B5D8: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A0B5DC: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82A0B5E0: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A0B5E4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82A0B5E8: 4080FFF0  bge 0x82a0b5d8
	if !ctx.cr[0].lt {
	pc = 0x82A0B5D8; continue 'dispatch;
	}
	// 82A0B5EC: 9B9F0188  stb r28, 0x188(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), ctx.r[28].u8 ) };
	// 82A0B5F0: 394001A0  li r10, 0x1a0
	ctx.r[10].s64 = 416;
	// 82A0B5F4: 937F018C  stw r27, 0x18c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), ctx.r[27].u32 ) };
	// 82A0B5F8: 392001C0  li r9, 0x1c0
	ctx.r[9].s64 = 448;
	// 82A0B5FC: 9B5F0190  stb r26, 0x190(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), ctx.r[26].u8 ) };
	// 82A0B600: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82A0B604: 9B3F0191  stb r25, 0x191(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(401 as u32), ctx.r[25].u8 ) };
	// 82A0B608: 13E0E8C7  vcmpequd (lvx128) v31, v0, v29
	tmp.u32 = ctx.r[29].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0B6A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A0B6A8 size=8
    let mut pc: u32 = 0x82A0B6A8;
    'dispatch: loop {
        match pc {
            0x82A0B6A8 => {
    //   block [0x82A0B6A8..0x82A0B6B0)
	// 82A0B6A8: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 82A0B6AC: 480005E4  b 0x82a0bc90
	sub_82A0BC90(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0B6B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A0B6B0 size=8
    let mut pc: u32 = 0x82A0B6B0;
    'dispatch: loop {
        match pc {
            0x82A0B6B0 => {
    //   block [0x82A0B6B0..0x82A0B6B8)
	// 82A0B6B0: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 82A0B6B4: 480005DC  b 0x82a0bc90
	sub_82A0BC90(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0B6B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A0B6B8 size=8
    let mut pc: u32 = 0x82A0B6B8;
    'dispatch: loop {
        match pc {
            0x82A0B6B8 => {
    //   block [0x82A0B6B8..0x82A0B6C0)
	// 82A0B6B8: 3863FEBC  addi r3, r3, -0x144
	ctx.r[3].s64 = ctx.r[3].s64 + -324;
	// 82A0B6BC: 480005D4  b 0x82a0bc90
	sub_82A0BC90(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0B6C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A0B6C0 size=176
    let mut pc: u32 = 0x82A0B6C0;
    'dispatch: loop {
        match pc {
            0x82A0B6C0 => {
    //   block [0x82A0B6C0..0x82A0B770)
	// 82A0B6C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0B6C4: 4879CAA9  bl 0x831a816c
	ctx.lr = 0x82A0B6C8;
	sub_831A8130(ctx, base);
	// 82A0B6C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0B6CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A0B6D0: 807F0218  lwz r3, 0x218(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(536 as u32) ) } as u64;
	// 82A0B6D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0B6D8: 419A0008  beq cr6, 0x82a0b6e0
	if ctx.cr[6].eq {
	pc = 0x82A0B6E0; continue 'dispatch;
	}
	// 82A0B6DC: 4B8B51B5  bl 0x822c0890
	ctx.lr = 0x82A0B6E0;
	sub_822C0890(ctx, base);
	// 82A0B6E0: 397F0188  addi r11, r31, 0x188
	ctx.r[11].s64 = ctx.r[31].s64 + 392;
	// 82A0B6E4: 3BA00004  li r29, 4
	ctx.r[29].s64 = 4;
	// 82A0B6E8: 3BCB0004  addi r30, r11, 4
	ctx.r[30].s64 = ctx.r[11].s64 + 4;
	// 82A0B6EC: 3BDEFFF8  addi r30, r30, -8
	ctx.r[30].s64 = ctx.r[30].s64 + -8;
	// 82A0B6F0: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0B6F4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0B6F8: 419A0008  beq cr6, 0x82a0b700
	if ctx.cr[6].eq {
	pc = 0x82A0B700; continue 'dispatch;
	}
	// 82A0B6FC: 4B8B5195  bl 0x822c0890
	ctx.lr = 0x82A0B700;
	sub_822C0890(ctx, base);
	// 82A0B700: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82A0B704: 4080FFE8  bge 0x82a0b6ec
	if !ctx.cr[0].lt {
	pc = 0x82A0B6EC; continue 'dispatch;
	}
	// 82A0B708: 807F015C  lwz r3, 0x15c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(348 as u32) ) } as u64;
	// 82A0B70C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0B710: 419A0008  beq cr6, 0x82a0b718
	if ctx.cr[6].eq {
	pc = 0x82A0B718; continue 'dispatch;
	}
	// 82A0B714: 4B8B517D  bl 0x822c0890
	ctx.lr = 0x82A0B718;
	sub_822C0890(ctx, base);
	// 82A0B718: 807F0154  lwz r3, 0x154(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(340 as u32) ) } as u64;
	// 82A0B71C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0B720: 419A0008  beq cr6, 0x82a0b728
	if ctx.cr[6].eq {
	pc = 0x82A0B728; continue 'dispatch;
	}
	// 82A0B724: 4B8B516D  bl 0x822c0890
	ctx.lr = 0x82A0B728;
	sub_822C0890(ctx, base);
	// 82A0B728: 807F014C  lwz r3, 0x14c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(332 as u32) ) } as u64;
	// 82A0B72C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0B730: 419A0008  beq cr6, 0x82a0b738
	if ctx.cr[6].eq {
	pc = 0x82A0B738; continue 'dispatch;
	}
	// 82A0B734: 4B8B515D  bl 0x822c0890
	ctx.lr = 0x82A0B738;
	sub_822C0890(ctx, base);
	// 82A0B738: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A0B73C: 387F0144  addi r3, r31, 0x144
	ctx.r[3].s64 = ctx.r[31].s64 + 324;
	// 82A0B740: 409A0008  bne cr6, 0x82a0b748
	if !ctx.cr[6].eq {
	pc = 0x82A0B748; continue 'dispatch;
	}
	// 82A0B744: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A0B748: 4BF3B709  bl 0x82946e50
	ctx.lr = 0x82A0B74C;
	sub_82946E50(ctx, base);
	// 82A0B74C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A0B750: 387F00E4  addi r3, r31, 0xe4
	ctx.r[3].s64 = ctx.r[31].s64 + 228;
	// 82A0B754: 409A0008  bne cr6, 0x82a0b75c
	if !ctx.cr[6].eq {
	pc = 0x82A0B75C; continue 'dispatch;
	}
	// 82A0B758: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A0B75C: 484520ED  bl 0x82e5d848
	ctx.lr = 0x82A0B760;
	sub_82E5D848(ctx, base);
	// 82A0B760: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0B764: 4B943BED  bl 0x8234f350
	ctx.lr = 0x82A0B768;
	sub_8234F350(ctx, base);
	// 82A0B768: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A0B76C: 4879CA50  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0B770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A0B770 size=308
    let mut pc: u32 = 0x82A0B770;
    'dispatch: loop {
        match pc {
            0x82A0B770 => {
    //   block [0x82A0B770..0x82A0B8A4)
	// 82A0B770: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0B774: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A0B778: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A0B77C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A0B780: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0B784: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A0B788: 817E01E4  lwz r11, 0x1e4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(484 as u32) ) } as u64;
	// 82A0B78C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A0B790: 419900FC  bgt cr6, 0x82a0b88c
	if ctx.cr[6].gt {
	pc = 0x82A0B88C; continue 'dispatch;
	}
	// 82A0B794: 897E01F4  lbz r11, 0x1f4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(500 as u32) ) } as u64;
	// 82A0B798: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A0B79C: 408200F0  bne 0x82a0b88c
	if !ctx.cr[0].eq {
	pc = 0x82A0B88C; continue 'dispatch;
	}
	// 82A0B7A0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A0B7A4: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A0B7A8: 997E01F4  stb r11, 0x1f4(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(500 as u32), ctx.r[11].u8 ) };
	// 82A0B7AC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A0B7B0: 388A8548  addi r4, r10, -0x7ab8
	ctx.r[4].s64 = ctx.r[10].s64 + -31416;
	// 82A0B7B4: 38A00274  li r5, 0x274
	ctx.r[5].s64 = 628;
	// 82A0B7B8: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 82A0B7BC: 483E6C2D  bl 0x82df23e8
	ctx.lr = 0x82A0B7C0;
	sub_82DF23E8(ctx, base);
	// 82A0B7C0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A0B7C4: 4182001C  beq 0x82a0b7e0
	if ctx.cr[0].eq {
	pc = 0x82A0B7E0; continue 'dispatch;
	}
	// 82A0B7C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0B7CC: 4845115D  bl 0x82e5c928
	ctx.lr = 0x82A0B7D0;
	sub_82E5C928(ctx, base);
	// 82A0B7D0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A0B7D4: 396B83FC  addi r11, r11, -0x7c04
	ctx.r[11].s64 = ctx.r[11].s64 + -31748;
	// 82A0B7D8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A0B7DC: 48000008  b 0x82a0b7e4
	pc = 0x82A0B7E4; continue 'dispatch;
	// 82A0B7E0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A0B7E4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82A0B7E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0B7EC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A0B7F0: 4BFFF889  bl 0x82a0b078
	ctx.lr = 0x82A0B7F4;
	sub_82A0B078(ctx, base);
	// 82A0B7F4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A0B7F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0B7FC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A0B800: 4B8B4801  bl 0x822c0000
	ctx.lr = 0x82A0B804;
	sub_822C0000(ctx, base);
	// 82A0B804: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A0B808: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A0B80C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A0B810: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82A0B814: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A0B818: 419A0024  beq cr6, 0x82a0b83c
	if ctx.cr[6].eq {
	pc = 0x82A0B83C; continue 'dispatch;
	}
	// 82A0B81C: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82A0B820: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A0B824: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A0B828: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A0B82C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A0B830: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A0B834: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A0B838: 4082FFE8  bne 0x82a0b820
	if !ctx.cr[0].eq {
	pc = 0x82A0B820; continue 'dispatch;
	}
	// 82A0B83C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A0B840: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A0B844: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A0B848: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82A0B84C: 389E00E4  addi r4, r30, 0xe4
	ctx.r[4].s64 = ctx.r[30].s64 + 228;
	// 82A0B850: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A0B854: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A0B858: 48452E51  bl 0x82e5e6a8
	ctx.lr = 0x82A0B85C;
	sub_82E5E6A8(ctx, base);
	// 82A0B85C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A0B860: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0B864: 419A0008  beq cr6, 0x82a0b86c
	if ctx.cr[6].eq {
	pc = 0x82A0B86C; continue 'dispatch;
	}
	// 82A0B868: 4B8B5029  bl 0x822c0890
	ctx.lr = 0x82A0B86C;
	sub_822C0890(ctx, base);
	// 82A0B86C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A0B870: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0B874: 419A0008  beq cr6, 0x82a0b87c
	if ctx.cr[6].eq {
	pc = 0x82A0B87C; continue 'dispatch;
	}
	// 82A0B878: 4B8B5019  bl 0x822c0890
	ctx.lr = 0x82A0B87C;
	sub_822C0890(ctx, base);
	// 82A0B87C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A0B880: 419A000C  beq cr6, 0x82a0b88c
	if ctx.cr[6].eq {
	pc = 0x82A0B88C; continue 'dispatch;
	}
	// 82A0B884: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0B888: 4B8B5009  bl 0x822c0890
	ctx.lr = 0x82A0B88C;
	sub_822C0890(ctx, base);
	// 82A0B88C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A0B890: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0B894: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A0B898: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A0B89C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A0B8A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0B8A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A0B8A8 size=708
    let mut pc: u32 = 0x82A0B8A8;
    'dispatch: loop {
        match pc {
            0x82A0B8A8 => {
    //   block [0x82A0B8A8..0x82A0BB6C)
	// 82A0B8A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0B8AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A0B8B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A0B8B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A0B8B8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0B8BC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A0B8C0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A0B8C4: 897E0188  lbz r11, 0x188(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(392 as u32) ) } as u64;
	// 82A0B8C8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A0B8CC: 419A01A8  beq cr6, 0x82a0ba74
	if ctx.cr[6].eq {
	pc = 0x82A0BA74; continue 'dispatch;
	}
	// 82A0B8D0: 897E0211  lbz r11, 0x211(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(529 as u32) ) } as u64;
	// 82A0B8D4: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82A0B8D8: 419800D4  blt cr6, 0x82a0b9ac
	if ctx.cr[6].lt {
	pc = 0x82A0B9AC; continue 'dispatch;
	}
	// 82A0B8DC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A0B8E0: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A0B8E4: 997E0211  stb r11, 0x211(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(529 as u32), ctx.r[11].u8 ) };
	// 82A0B8E8: 38A00287  li r5, 0x287
	ctx.r[5].s64 = 647;
	// 82A0B8EC: 388A8548  addi r4, r10, -0x7ab8
	ctx.r[4].s64 = ctx.r[10].s64 + -31416;
	// 82A0B8F0: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 82A0B8F4: 483E6AF5  bl 0x82df23e8
	ctx.lr = 0x82A0B8F8;
	sub_82DF23E8(ctx, base);
	// 82A0B8F8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A0B8FC: 4182001C  beq 0x82a0b918
	if ctx.cr[0].eq {
	pc = 0x82A0B918; continue 'dispatch;
	}
	// 82A0B900: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0B904: 48451025  bl 0x82e5c928
	ctx.lr = 0x82A0B908;
	sub_82E5C928(ctx, base);
	// 82A0B908: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A0B90C: 396B8424  addi r11, r11, -0x7bdc
	ctx.r[11].s64 = ctx.r[11].s64 + -31708;
	// 82A0B910: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A0B914: 48000008  b 0x82a0b91c
	pc = 0x82A0B91C; continue 'dispatch;
	// 82A0B918: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A0B91C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82A0B920: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0B924: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A0B928: 4BFFF819  bl 0x82a0b140
	ctx.lr = 0x82A0B92C;
	sub_82A0B140(ctx, base);
	// 82A0B92C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A0B930: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0B934: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A0B938: 4B8B46C9  bl 0x822c0000
	ctx.lr = 0x82A0B93C;
	sub_822C0000(ctx, base);
	// 82A0B93C: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A0B940: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A0B944: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A0B948: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82A0B94C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A0B950: 419A0024  beq cr6, 0x82a0b974
	if ctx.cr[6].eq {
	pc = 0x82A0B974; continue 'dispatch;
	}
	// 82A0B954: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82A0B958: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A0B95C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A0B960: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A0B964: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A0B968: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A0B96C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A0B970: 4082FFE8  bne 0x82a0b958
	if !ctx.cr[0].eq {
	pc = 0x82A0B958; continue 'dispatch;
	}
	// 82A0B974: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A0B978: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A0B97C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A0B980: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82A0B984: 389E00E4  addi r4, r30, 0xe4
	ctx.r[4].s64 = ctx.r[30].s64 + 228;
	// 82A0B988: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A0B98C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A0B990: 48452D19  bl 0x82e5e6a8
	ctx.lr = 0x82A0B994;
	sub_82E5E6A8(ctx, base);
	// 82A0B994: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A0B998: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0B99C: 419A0008  beq cr6, 0x82a0b9a4
	if ctx.cr[6].eq {
	pc = 0x82A0B9A4; continue 'dispatch;
	}
	// 82A0B9A0: 4B8B4EF1  bl 0x822c0890
	ctx.lr = 0x82A0B9A4;
	sub_822C0890(ctx, base);
	// 82A0B9A4: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A0B9A8: 48000190  b 0x82a0bb38
	pc = 0x82A0BB38; continue 'dispatch;
	// 82A0B9AC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A0B9B0: 38A00289  li r5, 0x289
	ctx.r[5].s64 = 649;
	// 82A0B9B4: 388B8548  addi r4, r11, -0x7ab8
	ctx.r[4].s64 = ctx.r[11].s64 + -31416;
	// 82A0B9B8: 3860006C  li r3, 0x6c
	ctx.r[3].s64 = 108;
	// 82A0B9BC: 483E6A2D  bl 0x82df23e8
	ctx.lr = 0x82A0B9C0;
	sub_82DF23E8(ctx, base);
	// 82A0B9C0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A0B9C4: 4182001C  beq 0x82a0b9e0
	if ctx.cr[0].eq {
	pc = 0x82A0B9E0; continue 'dispatch;
	}
	// 82A0B9C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0B9CC: 48450F5D  bl 0x82e5c928
	ctx.lr = 0x82A0B9D0;
	sub_82E5C928(ctx, base);
	// 82A0B9D0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A0B9D4: 396B844C  addi r11, r11, -0x7bb4
	ctx.r[11].s64 = ctx.r[11].s64 + -31668;
	// 82A0B9D8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A0B9DC: 48000008  b 0x82a0b9e4
	pc = 0x82A0B9E4; continue 'dispatch;
	// 82A0B9E0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A0B9E4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82A0B9E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0B9EC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A0B9F0: 4BFFF819  bl 0x82a0b208
	ctx.lr = 0x82A0B9F4;
	sub_82A0B208(ctx, base);
	// 82A0B9F4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A0B9F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0B9FC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A0BA00: 4B8B4601  bl 0x822c0000
	ctx.lr = 0x82A0BA04;
	sub_822C0000(ctx, base);
	// 82A0BA04: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A0BA08: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A0BA0C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A0BA10: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 82A0BA14: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A0BA18: 419A0024  beq cr6, 0x82a0ba3c
	if ctx.cr[6].eq {
	pc = 0x82A0BA3C; continue 'dispatch;
	}
	// 82A0BA1C: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82A0BA20: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A0BA24: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A0BA28: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A0BA2C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A0BA30: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A0BA34: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A0BA38: 4082FFE8  bne 0x82a0ba20
	if !ctx.cr[0].eq {
	pc = 0x82A0BA20; continue 'dispatch;
	}
	// 82A0BA3C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A0BA40: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A0BA44: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A0BA48: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82A0BA4C: 389E00E4  addi r4, r30, 0xe4
	ctx.r[4].s64 = ctx.r[30].s64 + 228;
	// 82A0BA50: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A0BA54: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A0BA58: 48452C51  bl 0x82e5e6a8
	ctx.lr = 0x82A0BA5C;
	sub_82E5E6A8(ctx, base);
	// 82A0BA5C: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82A0BA60: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0BA64: 419A0008  beq cr6, 0x82a0ba6c
	if ctx.cr[6].eq {
	pc = 0x82A0BA6C; continue 'dispatch;
	}
	// 82A0BA68: 4B8B4E29  bl 0x822c0890
	ctx.lr = 0x82A0BA6C;
	sub_822C0890(ctx, base);
	// 82A0BA6C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A0BA70: 480000C8  b 0x82a0bb38
	pc = 0x82A0BB38; continue 'dispatch;
	// 82A0BA74: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A0BA78: 38A0028D  li r5, 0x28d
	ctx.r[5].s64 = 653;
	// 82A0BA7C: 388B8548  addi r4, r11, -0x7ab8
	ctx.r[4].s64 = ctx.r[11].s64 + -31416;
	// 82A0BA80: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 82A0BA84: 483E6965  bl 0x82df23e8
	ctx.lr = 0x82A0BA88;
	sub_82DF23E8(ctx, base);
	// 82A0BA88: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A0BA8C: 4182001C  beq 0x82a0baa8
	if ctx.cr[0].eq {
	pc = 0x82A0BAA8; continue 'dispatch;
	}
	// 82A0BA90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0BA94: 48450E95  bl 0x82e5c928
	ctx.lr = 0x82A0BA98;
	sub_82E5C928(ctx, base);
	// 82A0BA98: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A0BA9C: 396B8474  addi r11, r11, -0x7b8c
	ctx.r[11].s64 = ctx.r[11].s64 + -31628;
	// 82A0BAA0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A0BAA4: 48000008  b 0x82a0baac
	pc = 0x82A0BAAC; continue 'dispatch;
	// 82A0BAA8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A0BAAC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82A0BAB0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0BAB4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A0BAB8: 4BFFF819  bl 0x82a0b2d0
	ctx.lr = 0x82A0BABC;
	sub_82A0B2D0(ctx, base);
	// 82A0BABC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A0BAC0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0BAC4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A0BAC8: 4B8B4539  bl 0x822c0000
	ctx.lr = 0x82A0BACC;
	sub_822C0000(ctx, base);
	// 82A0BACC: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A0BAD0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A0BAD4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A0BAD8: 93E1006C  stw r31, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[31].u32 ) };
	// 82A0BADC: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82A0BAE0: 419A0024  beq cr6, 0x82a0bb04
	if ctx.cr[6].eq {
	pc = 0x82A0BB04; continue 'dispatch;
	}
	// 82A0BAE4: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82A0BAE8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A0BAEC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A0BAF0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A0BAF4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A0BAF8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A0BAFC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A0BB00: 4082FFE8  bne 0x82a0bae8
	if !ctx.cr[0].eq {
	pc = 0x82A0BAE8; continue 'dispatch;
	}
	// 82A0BB04: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A0BB08: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A0BB0C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A0BB10: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 82A0BB14: 389E00E4  addi r4, r30, 0xe4
	ctx.r[4].s64 = ctx.r[30].s64 + 228;
	// 82A0BB18: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A0BB1C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A0BB20: 48452B89  bl 0x82e5e6a8
	ctx.lr = 0x82A0BB24;
	sub_82E5E6A8(ctx, base);
	// 82A0BB24: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82A0BB28: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0BB2C: 419A0008  beq cr6, 0x82a0bb34
	if ctx.cr[6].eq {
	pc = 0x82A0BB34; continue 'dispatch;
	}
	// 82A0BB30: 4B8B4D61  bl 0x822c0890
	ctx.lr = 0x82A0BB34;
	sub_822C0890(ctx, base);
	// 82A0BB34: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A0BB38: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0BB3C: 419A0008  beq cr6, 0x82a0bb44
	if ctx.cr[6].eq {
	pc = 0x82A0BB44; continue 'dispatch;
	}
	// 82A0BB40: 4B8B4D51  bl 0x822c0890
	ctx.lr = 0x82A0BB44;
	sub_822C0890(ctx, base);
	// 82A0BB44: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A0BB48: 419A000C  beq cr6, 0x82a0bb54
	if ctx.cr[6].eq {
	pc = 0x82A0BB54; continue 'dispatch;
	}
	// 82A0BB4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0BB50: 4B8B4D41  bl 0x822c0890
	ctx.lr = 0x82A0BB54;
	sub_822C0890(ctx, base);
	// 82A0BB54: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A0BB58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0BB5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A0BB60: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A0BB64: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A0BB68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0BB70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A0BB70 size=288
    let mut pc: u32 = 0x82A0BB70;
    'dispatch: loop {
        match pc {
            0x82A0BB70 => {
    //   block [0x82A0BB70..0x82A0BC90)
	// 82A0BB70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0BB74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A0BB78: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A0BB7C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A0BB80: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0BB84: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A0BB88: 897E01F4  lbz r11, 0x1f4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(500 as u32) ) } as u64;
	// 82A0BB8C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A0BB90: 408200E8  bne 0x82a0bc78
	if !ctx.cr[0].eq {
	pc = 0x82A0BC78; continue 'dispatch;
	}
	// 82A0BB94: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A0BB98: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A0BB9C: 388B8548  addi r4, r11, -0x7ab8
	ctx.r[4].s64 = ctx.r[11].s64 + -31416;
	// 82A0BBA0: 38A002DA  li r5, 0x2da
	ctx.r[5].s64 = 730;
	// 82A0BBA4: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 82A0BBA8: 483E6841  bl 0x82df23e8
	ctx.lr = 0x82A0BBAC;
	sub_82DF23E8(ctx, base);
	// 82A0BBAC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A0BBB0: 4182001C  beq 0x82a0bbcc
	if ctx.cr[0].eq {
	pc = 0x82A0BBCC; continue 'dispatch;
	}
	// 82A0BBB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0BBB8: 48450D71  bl 0x82e5c928
	ctx.lr = 0x82A0BBBC;
	sub_82E5C928(ctx, base);
	// 82A0BBBC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A0BBC0: 396B84A0  addi r11, r11, -0x7b60
	ctx.r[11].s64 = ctx.r[11].s64 + -31584;
	// 82A0BBC4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A0BBC8: 48000008  b 0x82a0bbd0
	pc = 0x82A0BBD0; continue 'dispatch;
	// 82A0BBCC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A0BBD0: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82A0BBD4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0BBD8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A0BBDC: 4BFFF7BD  bl 0x82a0b398
	ctx.lr = 0x82A0BBE0;
	sub_82A0B398(ctx, base);
	// 82A0BBE0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A0BBE4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0BBE8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A0BBEC: 4B8B4415  bl 0x822c0000
	ctx.lr = 0x82A0BBF0;
	sub_822C0000(ctx, base);
	// 82A0BBF0: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A0BBF4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A0BBF8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A0BBFC: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82A0BC00: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A0BC04: 419A0024  beq cr6, 0x82a0bc28
	if ctx.cr[6].eq {
	pc = 0x82A0BC28; continue 'dispatch;
	}
	// 82A0BC08: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82A0BC0C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A0BC10: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A0BC14: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A0BC18: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A0BC1C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A0BC20: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A0BC24: 4082FFE8  bne 0x82a0bc0c
	if !ctx.cr[0].eq {
	pc = 0x82A0BC0C; continue 'dispatch;
	}
	// 82A0BC28: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A0BC2C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A0BC30: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A0BC34: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82A0BC38: 389E00E4  addi r4, r30, 0xe4
	ctx.r[4].s64 = ctx.r[30].s64 + 228;
	// 82A0BC3C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A0BC40: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A0BC44: 48452A65  bl 0x82e5e6a8
	ctx.lr = 0x82A0BC48;
	sub_82E5E6A8(ctx, base);
	// 82A0BC48: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A0BC4C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0BC50: 419A0008  beq cr6, 0x82a0bc58
	if ctx.cr[6].eq {
	pc = 0x82A0BC58; continue 'dispatch;
	}
	// 82A0BC54: 4B8B4C3D  bl 0x822c0890
	ctx.lr = 0x82A0BC58;
	sub_822C0890(ctx, base);
	// 82A0BC58: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A0BC5C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0BC60: 419A0008  beq cr6, 0x82a0bc68
	if ctx.cr[6].eq {
	pc = 0x82A0BC68; continue 'dispatch;
	}
	// 82A0BC64: 4B8B4C2D  bl 0x822c0890
	ctx.lr = 0x82A0BC68;
	sub_822C0890(ctx, base);
	// 82A0BC68: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A0BC6C: 419A000C  beq cr6, 0x82a0bc78
	if ctx.cr[6].eq {
	pc = 0x82A0BC78; continue 'dispatch;
	}
	// 82A0BC70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0BC74: 4B8B4C1D  bl 0x822c0890
	ctx.lr = 0x82A0BC78;
	sub_822C0890(ctx, base);
	// 82A0BC78: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A0BC7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0BC80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A0BC84: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A0BC88: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A0BC8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0BC90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A0BC90 size=76
    let mut pc: u32 = 0x82A0BC90;
    'dispatch: loop {
        match pc {
            0x82A0BC90 => {
    //   block [0x82A0BC90..0x82A0BCDC)
	// 82A0BC90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0BC94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A0BC98: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A0BC9C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A0BCA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0BCA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A0BCA8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A0BCAC: 4BFFFA15  bl 0x82a0b6c0
	ctx.lr = 0x82A0BCB0;
	sub_82A0B6C0(ctx, base);
	// 82A0BCB0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A0BCB4: 4182000C  beq 0x82a0bcc0
	if ctx.cr[0].eq {
	pc = 0x82A0BCC0; continue 'dispatch;
	}
	// 82A0BCB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0BCBC: 483E671D  bl 0x82df23d8
	ctx.lr = 0x82A0BCC0;
	sub_82DF23D8(ctx, base);
	// 82A0BCC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0BCC4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A0BCC8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0BCCC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A0BCD0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A0BCD4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A0BCD8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0BCE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A0BCE0 size=252
    let mut pc: u32 = 0x82A0BCE0;
    'dispatch: loop {
        match pc {
            0x82A0BCE0 => {
    //   block [0x82A0BCE0..0x82A0BDDC)
	// 82A0BCE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0BCE4: 4879C485  bl 0x831a8168
	ctx.lr = 0x82A0BCE8;
	sub_831A8130(ctx, base);
	// 82A0BCE8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0BCEC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A0BCF0: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82A0BCF4: 3BBF0160  addi r29, r31, 0x160
	ctx.r[29].s64 = ctx.r[31].s64 + 352;
	// 82A0BCF8: 3BC00005  li r30, 5
	ctx.r[30].s64 = 5;
	// 82A0BCFC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A0BD00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0BD04: 4BB049A5  bl 0x825106a8
	ctx.lr = 0x82A0BD08;
	sub_825106A8(ctx, base);
	// 82A0BD08: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82A0BD0C: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 82A0BD10: 4082FFEC  bne 0x82a0bcfc
	if !ctx.cr[0].eq {
	pc = 0x82A0BCFC; continue 'dispatch;
	}
	// 82A0BD14: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82A0BD18: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A0BD1C: 4BAFC965  bl 0x82508680
	ctx.lr = 0x82A0BD20;
	sub_82508680(ctx, base);
	// 82A0BD20: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A0BD24: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A0BD28: 4BF01E69  bl 0x8290db90
	ctx.lr = 0x82A0BD2C;
	sub_8290DB90(ctx, base);
	// 82A0BD2C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0BD30: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A0BD34: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0BD38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0BD3C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A0BD40: 419A0024  beq cr6, 0x82a0bd64
	if ctx.cr[6].eq {
	pc = 0x82A0BD64; continue 'dispatch;
	}
	// 82A0BD44: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A0BD48: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A0BD4C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A0BD50: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A0BD54: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A0BD58: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A0BD5C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A0BD60: 4082FFE8  bne 0x82a0bd48
	if !ctx.cr[0].eq {
	pc = 0x82A0BD48; continue 'dispatch;
	}
	// 82A0BD64: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A0BD68: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A0BD6C: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82A0BD70: 388A8548  addi r4, r10, -0x7ab8
	ctx.r[4].s64 = ctx.r[10].s64 + -31416;
	// 82A0BD74: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82A0BD78: 38A00232  li r5, 0x232
	ctx.r[5].s64 = 562;
	// 82A0BD7C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A0BD80: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82A0BD84: 4844CCBD  bl 0x82e58a40
	ctx.lr = 0x82A0BD88;
	sub_82E58A40(ctx, base);
	// 82A0BD88: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A0BD8C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0BD90: 419A0008  beq cr6, 0x82a0bd98
	if ctx.cr[6].eq {
	pc = 0x82A0BD98; continue 'dispatch;
	}
	// 82A0BD94: 4B8B4AFD  bl 0x822c0890
	ctx.lr = 0x82A0BD98;
	sub_822C0890(ctx, base);
	// 82A0BD98: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A0BD9C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0BDA0: 419A0008  beq cr6, 0x82a0bda8
	if ctx.cr[6].eq {
	pc = 0x82A0BDA8; continue 'dispatch;
	}
	// 82A0BDA4: 4B8B4AED  bl 0x822c0890
	ctx.lr = 0x82A0BDA8;
	sub_822C0890(ctx, base);
	// 82A0BDA8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A0BDAC: 807F0214  lwz r3, 0x214(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(532 as u32) ) } as u64;
	// 82A0BDB0: 3BDF0214  addi r30, r31, 0x214
	ctx.r[30].s64 = ctx.r[31].s64 + 532;
	// 82A0BDB4: 4BDC408D  bl 0x827cfe40
	ctx.lr = 0x82A0BDB8;
	sub_827CFE40(ctx, base);
	// 82A0BDB8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A0BDBC: 917F0214  stw r11, 0x214(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(532 as u32), ctx.r[11].u32 ) };
	// 82A0BDC0: 807F0218  lwz r3, 0x218(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(536 as u32) ) } as u64;
	// 82A0BDC4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0BDC8: 917F0218  stw r11, 0x218(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(536 as u32), ctx.r[11].u32 ) };
	// 82A0BDCC: 419A0008  beq cr6, 0x82a0bdd4
	if ctx.cr[6].eq {
	pc = 0x82A0BDD4; continue 'dispatch;
	}
	// 82A0BDD0: 4B8B4AC1  bl 0x822c0890
	ctx.lr = 0x82A0BDD4;
	sub_822C0890(ctx, base);
	// 82A0BDD4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A0BDD8: 4879C3E0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0BDE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A0BDE0 size=304
    let mut pc: u32 = 0x82A0BDE0;
    'dispatch: loop {
        match pc {
            0x82A0BDE0 => {
    //   block [0x82A0BDE0..0x82A0BF10)
	// 82A0BDE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0BDE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A0BDE8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A0BDEC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A0BDF0: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82A0BDF4: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0BDF8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A0BDFC: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82A0BE00: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A0BE04: 397F0200  addi r11, r31, 0x200
	ctx.r[11].s64 = ctx.r[31].s64 + 512;
	// 82A0BE08: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A0BE0C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A0BE10: 4B9113C1  bl 0x8231d1d0
	ctx.lr = 0x82A0BE14;
	sub_8231D1D0(ctx, base);
	// 82A0BE14: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0BE18: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A0BE1C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0BE20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0BE24: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A0BE28: 419A0024  beq cr6, 0x82a0be4c
	if ctx.cr[6].eq {
	pc = 0x82A0BE4C; continue 'dispatch;
	}
	// 82A0BE2C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A0BE30: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A0BE34: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A0BE38: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A0BE3C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A0BE40: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A0BE44: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A0BE48: 4082FFE8  bne 0x82a0be30
	if !ctx.cr[0].eq {
	pc = 0x82A0BE30; continue 'dispatch;
	}
	// 82A0BE4C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0BE50: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A0BE54: 4BB03675  bl 0x8250f4c8
	ctx.lr = 0x82A0BE58;
	sub_8250F4C8(ctx, base);
	// 82A0BE58: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0BE5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0BE60: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A0BE64: 409A0008  bne cr6, 0x82a0be6c
	if !ctx.cr[6].eq {
	pc = 0x82A0BE6C; continue 'dispatch;
	}
	// 82A0BE68: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A0BE6C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A0BE70: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 82A0BE74: 4BAFCBA5  bl 0x82508a18
	ctx.lr = 0x82A0BE78;
	sub_82508A18(ctx, base);
	// 82A0BE78: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A0BE7C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A0BE80: 388B8548  addi r4, r11, -0x7ab8
	ctx.r[4].s64 = ctx.r[11].s64 + -31416;
	// 82A0BE84: 38A00261  li r5, 0x261
	ctx.r[5].s64 = 609;
	// 82A0BE88: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82A0BE8C: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82A0BE90: 4844B159  bl 0x82e56fe8
	ctx.lr = 0x82A0BE94;
	sub_82E56FE8(ctx, base);
	// 82A0BE94: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A0BE98: 483E5DF9  bl 0x82df1c90
	ctx.lr = 0x82A0BE9C;
	sub_82DF1C90(ctx, base);
	// 82A0BE9C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A0BEA0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0BEA4: 419A0008  beq cr6, 0x82a0beac
	if ctx.cr[6].eq {
	pc = 0x82A0BEAC; continue 'dispatch;
	}
	// 82A0BEA8: 4B8B49E9  bl 0x822c0890
	ctx.lr = 0x82A0BEAC;
	sub_822C0890(ctx, base);
	// 82A0BEAC: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A0BEB0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0BEB4: 419A0008  beq cr6, 0x82a0bebc
	if ctx.cr[6].eq {
	pc = 0x82A0BEBC; continue 'dispatch;
	}
	// 82A0BEB8: 4B8B49D9  bl 0x822c0890
	ctx.lr = 0x82A0BEBC;
	sub_822C0890(ctx, base);
	// 82A0BEBC: 897F0212  lbz r11, 0x212(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(530 as u32) ) } as u64;
	// 82A0BEC0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A0BEC4: 40820030  bne 0x82a0bef4
	if !ctx.cr[0].eq {
	pc = 0x82A0BEF4; continue 'dispatch;
	}
	// 82A0BEC8: 817F0148  lwz r11, 0x148(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(328 as u32) ) } as u64;
	// 82A0BECC: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A0BED0: 483F2911  bl 0x82dfe7e0
	ctx.lr = 0x82A0BED4;
	sub_82DFE7E0(ctx, base);
	// 82A0BED4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A0BED8: 4182001C  beq 0x82a0bef4
	if ctx.cr[0].eq {
	pc = 0x82A0BEF4; continue 'dispatch;
	}
	// 82A0BEDC: 807F0150  lwz r3, 0x150(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) } as u64;
	// 82A0BEE0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A0BEE4: 481A95B5  bl 0x82bb5498
	ctx.lr = 0x82A0BEE8;
	sub_82BB5498(ctx, base);
	// 82A0BEE8: 807F0150  lwz r3, 0x150(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) } as u64;
	// 82A0BEEC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A0BEF0: 481A36F1  bl 0x82baf5e0
	ctx.lr = 0x82A0BEF4;
	sub_82BAF5E0(ctx, base);
	// 82A0BEF4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A0BEF8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0BEFC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A0BF00: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82A0BF04: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A0BF08: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A0BF0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0BF10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A0BF10 size=224
    let mut pc: u32 = 0x82A0BF10;
    'dispatch: loop {
        match pc {
            0x82A0BF10 => {
    //   block [0x82A0BF10..0x82A0BFF0)
	// 82A0BF10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0BF14: 4879C259  bl 0x831a816c
	ctx.lr = 0x82A0BF18;
	sub_831A8130(ctx, base);
	// 82A0BF18: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0BF1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A0BF20: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A0BF24: 897F0210  lbz r11, 0x210(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(528 as u32) ) } as u64;
	// 82A0BF28: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A0BF2C: 418200BC  beq 0x82a0bfe8
	if ctx.cr[0].eq {
	pc = 0x82A0BFE8; continue 'dispatch;
	}
	// 82A0BF30: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A0BF34: 39400064  li r10, 0x64
	ctx.r[10].s64 = 100;
	// 82A0BF38: 3BAB6910  addi r29, r11, 0x6910
	ctx.r[29].s64 = ctx.r[11].s64 + 26896;
	// 82A0BF3C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A0BF40: 4BB05BA9  bl 0x82511ae8
	ctx.lr = 0x82A0BF44;
	sub_82511AE8(ctx, base);
	// 82A0BF44: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82A0BF48: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A0BF4C: 388B8614  addi r4, r11, -0x79ec
	ctx.r[4].s64 = ctx.r[11].s64 + -31212;
	// 82A0BF50: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A0BF54: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A0BF58: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82A0BF5C: 4BA0B465  bl 0x824173c0
	ctx.lr = 0x82A0BF60;
	sub_824173C0(ctx, base);
	// 82A0BF60: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0BF64: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A0BF68: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0BF6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0BF70: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A0BF74: 419A0024  beq cr6, 0x82a0bf98
	if ctx.cr[6].eq {
	pc = 0x82A0BF98; continue 'dispatch;
	}
	// 82A0BF78: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A0BF7C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A0BF80: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A0BF84: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A0BF88: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A0BF8C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A0BF90: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A0BF94: 4082FFE8  bne 0x82a0bf7c
	if !ctx.cr[0].eq {
	pc = 0x82A0BF7C; continue 'dispatch;
	}
	// 82A0BF98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A0BF9C: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 82A0BFA0: 485FC189  bl 0x83008128
	ctx.lr = 0x82A0BFA4;
	sub_83008128(ctx, base);
	// 82A0BFA4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A0BFA8: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A0BFAC: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A0BFB0: 388A8548  addi r4, r10, -0x7ab8
	ctx.r[4].s64 = ctx.r[10].s64 + -31416;
	// 82A0BFB4: 38A002C9  li r5, 0x2c9
	ctx.r[5].s64 = 713;
	// 82A0BFB8: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82A0BFBC: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A0BFC0: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82A0BFC4: 4844CA7D  bl 0x82e58a40
	ctx.lr = 0x82A0BFC8;
	sub_82E58A40(ctx, base);
	// 82A0BFC8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A0BFCC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0BFD0: 419A0008  beq cr6, 0x82a0bfd8
	if ctx.cr[6].eq {
	pc = 0x82A0BFD8; continue 'dispatch;
	}
	// 82A0BFD4: 4B8B48BD  bl 0x822c0890
	ctx.lr = 0x82A0BFD8;
	sub_822C0890(ctx, base);
	// 82A0BFD8: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A0BFDC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0BFE0: 419A0008  beq cr6, 0x82a0bfe8
	if ctx.cr[6].eq {
	pc = 0x82A0BFE8; continue 'dispatch;
	}
	// 82A0BFE4: 4B8B48AD  bl 0x822c0890
	ctx.lr = 0x82A0BFE8;
	sub_822C0890(ctx, base);
	// 82A0BFE8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A0BFEC: 4879C1D0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0BFF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A0BFF0 size=748
    let mut pc: u32 = 0x82A0BFF0;
    'dispatch: loop {
        match pc {
            0x82A0BFF0 => {
    //   block [0x82A0BFF0..0x82A0C2DC)
	// 82A0BFF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0BFF4: 4879C179  bl 0x831a816c
	ctx.lr = 0x82A0BFF8;
	sub_831A8130(ctx, base);
	// 82A0BFF8: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0BFFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A0C000: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82A0C004: 897F0212  lbz r11, 0x212(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(530 as u32) ) } as u64;
	// 82A0C008: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A0C00C: 817D001C  lwz r11, 0x1c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A0C010: 4182002C  beq 0x82a0c03c
	if ctx.cr[0].eq {
	pc = 0x82A0C03C; continue 'dispatch;
	}
	// 82A0C014: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 82A0C018: C8010058  lfd f0, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A0C01C: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 82A0C020: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 82A0C024: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82A0C028: C00A2784  lfs f0, 0x2784(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(10116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A0C02C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A0C030: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82A0C034: D8010058  stfd f0, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[0].u64 ) };
	// 82A0C038: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A0C03C: 815F01E4  lwz r10, 0x1e4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(484 as u32) ) } as u64;
	// 82A0C040: 7D6B5051  subf. r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A0C044: 917F01E4  stw r11, 0x1e4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(484 as u32), ctx.r[11].u32 ) };
	// 82A0C048: 4080000C  bge 0x82a0c054
	if !ctx.cr[0].lt {
	pc = 0x82A0C054; continue 'dispatch;
	}
	// 82A0C04C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A0C050: 917F01E4  stw r11, 0x1e4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(484 as u32), ctx.r[11].u32 ) };
	// 82A0C054: 3BDD0040  addi r30, r29, 0x40
	ctx.r[30].s64 = ctx.r[29].s64 + 64;
	// 82A0C058: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82A0C05C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A0C060: 4846FF79  bl 0x82e7bfd8
	ctx.lr = 0x82A0C064;
	sub_82E7BFD8(ctx, base);
	// 82A0C064: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82A0C068: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0C06C: 388B0454  addi r4, r11, 0x454
	ctx.r[4].s64 = ctx.r[11].s64 + 1108;
	// 82A0C070: 483E7999  bl 0x82df3a08
	ctx.lr = 0x82A0C074;
	sub_82DF3A08(ctx, base);
	// 82A0C074: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0C078: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82A0C07C: 4BB0344D  bl 0x8250f4c8
	ctx.lr = 0x82A0C080;
	sub_8250F4C8(ctx, base);
	// 82A0C080: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0C084: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0C088: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82A0C08C: 409A0008  bne cr6, 0x82a0c094
	if !ctx.cr[6].eq {
	pc = 0x82A0C094; continue 'dispatch;
	}
	// 82A0C090: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A0C094: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82A0C098: 4BAFE8B9  bl 0x8250a950
	ctx.lr = 0x82A0C09C;
	sub_8250A950(ctx, base);
	// 82A0C09C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0C0A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0C0A4: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 82A0C0A8: 409A0008  bne cr6, 0x82a0c0b0
	if !ctx.cr[6].eq {
	pc = 0x82A0C0B0; continue 'dispatch;
	}
	// 82A0C0AC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A0C0B0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A0C0B4: 38C0000A  li r6, 0xa
	ctx.r[6].s64 = 10;
	// 82A0C0B8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A0C0BC: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 82A0C0C0: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A0C0C4: 4BDC8A8D  bl 0x827d4b50
	ctx.lr = 0x82A0C0C8;
	sub_827D4B50(ctx, base);
	// 82A0C0C8: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82A0C0CC: 483E5BC5  bl 0x82df1c90
	ctx.lr = 0x82A0C0D0;
	sub_82DF1C90(ctx, base);
	// 82A0C0D0: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82A0C0D4: 483E5BBD  bl 0x82df1c90
	ctx.lr = 0x82A0C0D8;
	sub_82DF1C90(ctx, base);
	// 82A0C0D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0C0DC: 483E734D  bl 0x82df3428
	ctx.lr = 0x82A0C0E0;
	sub_82DF3428(ctx, base);
	// 82A0C0E0: 817F01E4  lwz r11, 0x1e4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(484 as u32) ) } as u64;
	// 82A0C0E4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A0C0E8: 41990030  bgt cr6, 0x82a0c118
	if ctx.cr[6].gt {
	pc = 0x82A0C118; continue 'dispatch;
	}
	// 82A0C0EC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0C0F0: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 82A0C0F4: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82A0C0F8: 38AA5804  addi r5, r10, 0x5804
	ctx.r[5].s64 = ctx.r[10].s64 + 22532;
	// 82A0C0FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0C100: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A0C104: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82A0C108: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A0C10C: 4E800421  bctrl
	ctx.lr = 0x82A0C110;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A0C110: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82A0C114: 480000E4  b 0x82a0c1f8
	pc = 0x82A0C1F8; continue 'dispatch;
	// 82A0C118: 897F0212  lbz r11, 0x212(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(530 as u32) ) } as u64;
	// 82A0C11C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A0C120: 418200B0  beq 0x82a0c1d0
	if ctx.cr[0].eq {
	pc = 0x82A0C1D0; continue 'dispatch;
	}
	// 82A0C124: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82A0C128: 817D0018  lwz r11, 0x18(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A0C12C: 814A85F8  lwz r10, -0x7a08(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-31240 as u32) ) } as u64;
	// 82A0C130: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A0C134: 419A0070  beq cr6, 0x82a0c1a4
	if ctx.cr[6].eq {
	pc = 0x82A0C1A4; continue 'dispatch;
	}
	// 82A0C138: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82A0C13C: 814A85F4  lwz r10, -0x7a0c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-31244 as u32) ) } as u64;
	// 82A0C140: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A0C144: 419A0060  beq cr6, 0x82a0c1a4
	if ctx.cr[6].eq {
	pc = 0x82A0C1A4; continue 'dispatch;
	}
	// 82A0C148: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82A0C14C: 814A85CC  lwz r10, -0x7a34(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-31284 as u32) ) } as u64;
	// 82A0C150: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A0C154: 419A0050  beq cr6, 0x82a0c1a4
	if ctx.cr[6].eq {
	pc = 0x82A0C1A4; continue 'dispatch;
	}
	// 82A0C158: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82A0C15C: 814A85C8  lwz r10, -0x7a38(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-31288 as u32) ) } as u64;
	// 82A0C160: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A0C164: 419A0040  beq cr6, 0x82a0c1a4
	if ctx.cr[6].eq {
	pc = 0x82A0C1A4; continue 'dispatch;
	}
	// 82A0C168: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82A0C16C: 814A85C4  lwz r10, -0x7a3c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-31292 as u32) ) } as u64;
	// 82A0C170: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A0C174: 419A0030  beq cr6, 0x82a0c1a4
	if ctx.cr[6].eq {
	pc = 0x82A0C1A4; continue 'dispatch;
	}
	// 82A0C178: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0C17C: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 82A0C180: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82A0C184: 38AA57EC  addi r5, r10, 0x57ec
	ctx.r[5].s64 = ctx.r[10].s64 + 22508;
	// 82A0C188: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0C18C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A0C190: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82A0C194: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A0C198: 4E800421  bctrl
	ctx.lr = 0x82A0C19C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A0C19C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A0C1A0: 48000058  b 0x82a0c1f8
	pc = 0x82A0C1F8; continue 'dispatch;
	// 82A0C1A4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0C1A8: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 82A0C1AC: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82A0C1B0: 38AA57D4  addi r5, r10, 0x57d4
	ctx.r[5].s64 = ctx.r[10].s64 + 22484;
	// 82A0C1B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0C1B8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A0C1BC: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82A0C1C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A0C1C4: 4E800421  bctrl
	ctx.lr = 0x82A0C1C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A0C1C8: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A0C1CC: 4800002C  b 0x82a0c1f8
	pc = 0x82A0C1F8; continue 'dispatch;
	// 82A0C1D0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0C1D4: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 82A0C1D8: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82A0C1DC: 38AA5814  addi r5, r10, 0x5814
	ctx.r[5].s64 = ctx.r[10].s64 + 22548;
	// 82A0C1E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0C1E4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A0C1E8: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82A0C1EC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A0C1F0: 4E800421  bctrl
	ctx.lr = 0x82A0C1F4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A0C1F4: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A0C1F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0C1FC: 419A0008  beq cr6, 0x82a0c204
	if ctx.cr[6].eq {
	pc = 0x82A0C204; continue 'dispatch;
	}
	// 82A0C200: 4B8B4691  bl 0x822c0890
	ctx.lr = 0x82A0C204;
	sub_822C0890(ctx, base);
	// 82A0C204: 897F0212  lbz r11, 0x212(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(530 as u32) ) } as u64;
	// 82A0C208: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A0C20C: 41820034  beq 0x82a0c240
	if ctx.cr[0].eq {
	pc = 0x82A0C240; continue 'dispatch;
	}
	// 82A0C210: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0C214: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A0C218: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0C21C: 38AA6748  addi r5, r10, 0x6748
	ctx.r[5].s64 = ctx.r[10].s64 + 26440;
	// 82A0C220: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A0C224: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82A0C228: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A0C22C: 4E800421  bctrl
	ctx.lr = 0x82A0C230;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A0C230: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82A0C234: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0C238: 419A0008  beq cr6, 0x82a0c240
	if ctx.cr[6].eq {
	pc = 0x82A0C240; continue 'dispatch;
	}
	// 82A0C23C: 4B8B4655  bl 0x822c0890
	ctx.lr = 0x82A0C240;
	sub_822C0890(ctx, base);
	// 82A0C240: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A0C244: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A0C248: 997F0213  stb r11, 0x213(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(531 as u32), ctx.r[11].u8 ) };
	// 82A0C24C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82A0C250: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A0C254: 4BFBDAFD  bl 0x829c9d50
	ctx.lr = 0x82A0C258;
	sub_829C9D50(ctx, base);
	// 82A0C258: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0C25C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A0C260: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0C264: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0C268: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A0C26C: 419A0024  beq cr6, 0x82a0c290
	if ctx.cr[6].eq {
	pc = 0x82A0C290; continue 'dispatch;
	}
	// 82A0C270: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A0C274: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A0C278: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A0C27C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A0C280: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A0C284: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A0C288: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A0C28C: 4082FFE8  bne 0x82a0c274
	if !ctx.cr[0].eq {
	pc = 0x82A0C274; continue 'dispatch;
	}
	// 82A0C290: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A0C294: 80DF021C  lwz r6, 0x21c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(540 as u32) ) } as u64;
	// 82A0C298: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A0C29C: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 82A0C2A0: 388A8548  addi r4, r10, -0x7ab8
	ctx.r[4].s64 = ctx.r[10].s64 + -31416;
	// 82A0C2A4: 38A00323  li r5, 0x323
	ctx.r[5].s64 = 803;
	// 82A0C2A8: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82A0C2AC: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A0C2B0: 4844C791  bl 0x82e58a40
	ctx.lr = 0x82A0C2B4;
	sub_82E58A40(ctx, base);
	// 82A0C2B4: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A0C2B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0C2BC: 419A0008  beq cr6, 0x82a0c2c4
	if ctx.cr[6].eq {
	pc = 0x82A0C2C4; continue 'dispatch;
	}
	// 82A0C2C0: 4B8B45D1  bl 0x822c0890
	ctx.lr = 0x82A0C2C4;
	sub_822C0890(ctx, base);
	// 82A0C2C4: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82A0C2C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0C2CC: 419A0008  beq cr6, 0x82a0c2d4
	if ctx.cr[6].eq {
	pc = 0x82A0C2D4; continue 'dispatch;
	}
	// 82A0C2D0: 4B8B45C1  bl 0x822c0890
	ctx.lr = 0x82A0C2D4;
	sub_822C0890(ctx, base);
	// 82A0C2D4: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 82A0C2D8: 4879BEE4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0C2E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A0C2E0 size=444
    let mut pc: u32 = 0x82A0C2E0;
    'dispatch: loop {
        match pc {
            0x82A0C2E0 => {
    //   block [0x82A0C2E0..0x82A0C49C)
	// 82A0C2E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0C2E4: 4879BE85  bl 0x831a8168
	ctx.lr = 0x82A0C2E8;
	sub_831A8130(ctx, base);
	// 82A0C2E8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0C2EC: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82A0C2F0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A0C2F4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A0C2F8: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82A0C2FC: 41820038  beq 0x82a0c334
	if ctx.cr[0].eq {
	pc = 0x82A0C334; continue 'dispatch;
	}
	// 82A0C300: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0C304: 4879D685  bl 0x831a9988
	ctx.lr = 0x82A0C308;
	sub_831A9988(ctx, base);
	// 82A0C308: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 82A0C30C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A0C310: 386B2380  addi r3, r11, 0x2380
	ctx.r[3].s64 = ctx.r[11].s64 + 9088;
	// 82A0C314: 4879BDE5  bl 0x831a80f8
	ctx.lr = 0x82A0C318;
	sub_831A80F8(ctx, base);
	// 82A0C318: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A0C31C: 41820018  beq 0x82a0c334
	if ctx.cr[0].eq {
	pc = 0x82A0C334; continue 'dispatch;
	}
	// 82A0C320: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0C324: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A0C328: 4BFFF139  bl 0x82a0b460
	ctx.lr = 0x82A0C32C;
	sub_82A0B460(ctx, base);
	// 82A0C32C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A0C330: 48000164  b 0x82a0c494
	pc = 0x82A0C494; continue 'dispatch;
	// 82A0C334: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A0C338: 419A014C  beq cr6, 0x82a0c484
	if ctx.cr[6].eq {
	pc = 0x82A0C484; continue 'dispatch;
	}
	// 82A0C33C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0C340: 4879D649  bl 0x831a9988
	ctx.lr = 0x82A0C344;
	sub_831A9988(ctx, base);
	// 82A0C344: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 82A0C348: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A0C34C: 386BE300  addi r3, r11, -0x1d00
	ctx.r[3].s64 = ctx.r[11].s64 + -7424;
	// 82A0C350: 4879BDA9  bl 0x831a80f8
	ctx.lr = 0x82A0C354;
	sub_831A80F8(ctx, base);
	// 82A0C354: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A0C358: 41820014  beq 0x82a0c36c
	if ctx.cr[0].eq {
	pc = 0x82A0C36C; continue 'dispatch;
	}
	// 82A0C35C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0C360: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A0C364: 4BFFEB7D  bl 0x82a0aee0
	ctx.lr = 0x82A0C368;
	sub_82A0AEE0(ctx, base);
	// 82A0C368: 4BFFFFC4  b 0x82a0c32c
	pc = 0x82A0C32C; continue 'dispatch;
	// 82A0C36C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A0C370: 419A0114  beq cr6, 0x82a0c484
	if ctx.cr[6].eq {
	pc = 0x82A0C484; continue 'dispatch;
	}
	// 82A0C374: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0C378: 4879D611  bl 0x831a9988
	ctx.lr = 0x82A0C37C;
	sub_831A9988(ctx, base);
	// 82A0C37C: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 82A0C380: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A0C384: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 82A0C388: 4879BD71  bl 0x831a80f8
	ctx.lr = 0x82A0C38C;
	sub_831A80F8(ctx, base);
	// 82A0C38C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A0C390: 41820014  beq 0x82a0c3a4
	if ctx.cr[0].eq {
	pc = 0x82A0C3A4; continue 'dispatch;
	}
	// 82A0C394: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0C398: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A0C39C: 4BFFFB75  bl 0x82a0bf10
	ctx.lr = 0x82A0C3A0;
	sub_82A0BF10(ctx, base);
	// 82A0C3A0: 4BFFFF8C  b 0x82a0c32c
	pc = 0x82A0C32C; continue 'dispatch;
	// 82A0C3A4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A0C3A8: 419A00DC  beq cr6, 0x82a0c484
	if ctx.cr[6].eq {
	pc = 0x82A0C484; continue 'dispatch;
	}
	// 82A0C3AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0C3B0: 4879D5D9  bl 0x831a9988
	ctx.lr = 0x82A0C3B4;
	sub_831A9988(ctx, base);
	// 82A0C3B4: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82A0C3B8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A0C3BC: 386BC8E4  addi r3, r11, -0x371c
	ctx.r[3].s64 = ctx.r[11].s64 + -14108;
	// 82A0C3C0: 4879BD39  bl 0x831a80f8
	ctx.lr = 0x82A0C3C4;
	sub_831A80F8(ctx, base);
	// 82A0C3C4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A0C3C8: 41820014  beq 0x82a0c3dc
	if ctx.cr[0].eq {
	pc = 0x82A0C3DC; continue 'dispatch;
	}
	// 82A0C3CC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0C3D0: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A0C3D4: 4BC5E91D  bl 0x8266acf0
	ctx.lr = 0x82A0C3D8;
	sub_8266ACF0(ctx, base);
	// 82A0C3D8: 4BFFFF54  b 0x82a0c32c
	pc = 0x82A0C32C; continue 'dispatch;
	// 82A0C3DC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A0C3E0: 419A00A4  beq cr6, 0x82a0c484
	if ctx.cr[6].eq {
	pc = 0x82A0C484; continue 'dispatch;
	}
	// 82A0C3E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0C3E8: 4879D5A1  bl 0x831a9988
	ctx.lr = 0x82A0C3EC;
	sub_831A9988(ctx, base);
	// 82A0C3EC: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 82A0C3F0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A0C3F4: 386BF1DC  addi r3, r11, -0xe24
	ctx.r[3].s64 = ctx.r[11].s64 + -3620;
	// 82A0C3F8: 4879BD01  bl 0x831a80f8
	ctx.lr = 0x82A0C3FC;
	sub_831A80F8(ctx, base);
	// 82A0C3FC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A0C400: 41820014  beq 0x82a0c414
	if ctx.cr[0].eq {
	pc = 0x82A0C414; continue 'dispatch;
	}
	// 82A0C404: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0C408: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A0C40C: 4BFFF765  bl 0x82a0bb70
	ctx.lr = 0x82A0C410;
	sub_82A0BB70(ctx, base);
	// 82A0C410: 4BFFFF1C  b 0x82a0c32c
	pc = 0x82A0C32C; continue 'dispatch;
	// 82A0C414: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A0C418: 419A006C  beq cr6, 0x82a0c484
	if ctx.cr[6].eq {
	pc = 0x82A0C484; continue 'dispatch;
	}
	// 82A0C41C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0C420: 4879D569  bl 0x831a9988
	ctx.lr = 0x82A0C424;
	sub_831A9988(ctx, base);
	// 82A0C424: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82A0C428: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A0C42C: 386B3984  addi r3, r11, 0x3984
	ctx.r[3].s64 = ctx.r[11].s64 + 14724;
	// 82A0C430: 4879BCC9  bl 0x831a80f8
	ctx.lr = 0x82A0C434;
	sub_831A80F8(ctx, base);
	// 82A0C434: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A0C438: 41820014  beq 0x82a0c44c
	if ctx.cr[0].eq {
	pc = 0x82A0C44C; continue 'dispatch;
	}
	// 82A0C43C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0C440: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A0C444: 4BFFFBAD  bl 0x82a0bff0
	ctx.lr = 0x82A0C448;
	sub_82A0BFF0(ctx, base);
	// 82A0C448: 4BFFFEE4  b 0x82a0c32c
	pc = 0x82A0C32C; continue 'dispatch;
	// 82A0C44C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A0C450: 419A0034  beq cr6, 0x82a0c484
	if ctx.cr[6].eq {
	pc = 0x82A0C484; continue 'dispatch;
	}
	// 82A0C454: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0C458: 4879D531  bl 0x831a9988
	ctx.lr = 0x82A0C45C;
	sub_831A9988(ctx, base);
	// 82A0C45C: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82A0C460: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A0C464: 386B31EC  addi r3, r11, 0x31ec
	ctx.r[3].s64 = ctx.r[11].s64 + 12780;
	// 82A0C468: 4879BC91  bl 0x831a80f8
	ctx.lr = 0x82A0C46C;
	sub_831A80F8(ctx, base);
	// 82A0C46C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A0C470: 41820014  beq 0x82a0c484
	if ctx.cr[0].eq {
	pc = 0x82A0C484; continue 'dispatch;
	}
	// 82A0C474: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0C478: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A0C47C: 4BFFEAC5  bl 0x82a0af40
	ctx.lr = 0x82A0C480;
	sub_82A0AF40(ctx, base);
	// 82A0C480: 4BFFFEAC  b 0x82a0c32c
	pc = 0x82A0C32C; continue 'dispatch;
	// 82A0C484: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82A0C488: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0C48C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A0C490: 4BB06189  bl 0x82512618
	ctx.lr = 0x82A0C494;
	sub_82512618(ctx, base);
	// 82A0C494: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A0C498: 4879BD20  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0C4A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A0C4A0 size=88
    let mut pc: u32 = 0x82A0C4A0;
    'dispatch: loop {
        match pc {
            0x82A0C4A0 => {
    //   block [0x82A0C4A0..0x82A0C4F8)
	// 82A0C4A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0C4A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A0C4A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A0C4AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A0C4B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0C4B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A0C4B8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A0C4BC: 4BB0424D  bl 0x82510708
	ctx.lr = 0x82A0C4C0;
	sub_82510708(ctx, base);
	// 82A0C4C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0C4C4: C03E0000  lfs f1, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A0C4C8: 4BFFF919  bl 0x82a0bde0
	ctx.lr = 0x82A0C4CC;
	sub_82A0BDE0(ctx, base);
	// 82A0C4CC: 387F00E4  addi r3, r31, 0xe4
	ctx.r[3].s64 = ctx.r[31].s64 + 228;
	// 82A0C4D0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A0C4D4: 484509A5  bl 0x82e5ce78
	ctx.lr = 0x82A0C4D8;
	sub_82E5CE78(ctx, base);
	// 82A0C4D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0C4DC: 4BFFF295  bl 0x82a0b770
	ctx.lr = 0x82A0C4E0;
	sub_82A0B770(ctx, base);
	// 82A0C4E0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A0C4E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0C4E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A0C4EC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A0C4F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A0C4F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0C4F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A0C4F8 size=5324
    let mut pc: u32 = 0x82A0C4F8;
    'dispatch: loop {
        match pc {
            0x82A0C4F8 => {
    //   block [0x82A0C4F8..0x82A0D9C4)
	// 82A0C4F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0C4FC: 4879BC35  bl 0x831a8130
	ctx.lr = 0x82A0C500;
	sub_831A8130(ctx, base);
	// 82A0C500: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 82A0C504: 4879C571  bl 0x831a8a74
	ctx.lr = 0x82A0C508;
	sub_831A8A40(ctx, base);
	// 82A0C508: 9421F7D0  stwu r1, -0x830(r1)
	ea = ctx.r[1].u32.wrapping_add(-2096 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0C50C: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 82A0C510: 9081084C  stw r4, 0x84c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(2124 as u32), ctx.r[4].u32 ) };
	// 82A0C514: 7CB02B78  mr r16, r5
	ctx.r[16].u64 = ctx.r[5].u64;
	// 82A0C518: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82A0C51C: 92C10844  stw r22, 0x844(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(2116 as u32), ctx.r[22].u32 ) };
	// 82A0C520: 92010854  stw r16, 0x854(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(2132 as u32), ctx.r[16].u32 ) };
	// 82A0C524: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82A0C528: 93A10078  stw r29, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[29].u32 ) };
	// 82A0C52C: 4BB054AD  bl 0x825119d8
	ctx.lr = 0x82A0C530;
	sub_825119D8(ctx, base);
	// 82A0C530: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82A0C534: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 82A0C538: 4BB02E39  bl 0x8250f370
	ctx.lr = 0x82A0C53C;
	sub_8250F370(ctx, base);
	// 82A0C53C: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82A0C540: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A0C544: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 82A0C548: 483E74C1  bl 0x82df3a08
	ctx.lr = 0x82A0C54C;
	sub_82DF3A08(ctx, base);
	// 82A0C54C: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 82A0C550: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82A0C554: 7E038378  mr r3, r16
	ctx.r[3].u64 = ctx.r[16].u64;
	// 82A0C558: 4BAFC229  bl 0x82508780
	ctx.lr = 0x82A0C55C;
	sub_82508780(ctx, base);
	// 82A0C55C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A0C560: 483E6EC9  bl 0x82df3428
	ctx.lr = 0x82A0C564;
	sub_82DF3428(ctx, base);
	// 82A0C564: 2B160000  cmplwi cr6, r22, 0
	ctx.cr[6].compare_u32(ctx.r[22].u32, 0 as u32, &mut ctx.xer);
	// 82A0C568: 38960028  addi r4, r22, 0x28
	ctx.r[4].s64 = ctx.r[22].s64 + 40;
	// 82A0C56C: 409A0008  bne cr6, 0x82a0c574
	if !ctx.cr[6].eq {
	pc = 0x82A0C574; continue 'dispatch;
	}
	// 82A0C570: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A0C574: 7E038378  mr r3, r16
	ctx.r[3].u64 = ctx.r[16].u64;
	// 82A0C578: 4BAFC229  bl 0x825087a0
	ctx.lr = 0x82A0C57C;
	sub_825087A0(ctx, base);
	// 82A0C57C: 39760200  addi r11, r22, 0x200
	ctx.r[11].s64 = ctx.r[22].s64 + 512;
	// 82A0C580: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A0C584: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A0C588: 38610230  addi r3, r1, 0x230
	ctx.r[3].s64 = ctx.r[1].s64 + 560;
	// 82A0C58C: 4B910C45  bl 0x8231d1d0
	ctx.lr = 0x82A0C590;
	sub_8231D1D0(ctx, base);
	// 82A0C590: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0C594: 916100C0  stw r11, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 82A0C598: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0C59C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0C5A0: 916100C4  stw r11, 0xc4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 82A0C5A4: 419A0024  beq cr6, 0x82a0c5c8
	if ctx.cr[6].eq {
	pc = 0x82A0C5C8; continue 'dispatch;
	}
	// 82A0C5A8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A0C5AC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A0C5B0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A0C5B4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A0C5B8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A0C5BC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A0C5C0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A0C5C4: 4082FFE8  bne 0x82a0c5ac
	if !ctx.cr[0].eq {
	pc = 0x82A0C5AC; continue 'dispatch;
	}
	// 82A0C5C8: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 82A0C5CC: 38610200  addi r3, r1, 0x200
	ctx.r[3].s64 = ctx.r[1].s64 + 512;
	// 82A0C5D0: 4BB02EF9  bl 0x8250f4c8
	ctx.lr = 0x82A0C5D4;
	sub_8250F4C8(ctx, base);
	// 82A0C5D4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0C5D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0C5DC: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A0C5E0: 409A0008  bne cr6, 0x82a0c5e8
	if !ctx.cr[6].eq {
	pc = 0x82A0C5E8; continue 'dispatch;
	}
	// 82A0C5E4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A0C5E8: 39F60028  addi r15, r22, 0x28
	ctx.r[15].s64 = ctx.r[22].s64 + 40;
	// 82A0C5EC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A0C5F0: 91E10058  stw r15, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[15].u32 ) };
	// 82A0C5F4: 3BE100C0  addi r31, r1, 0xc0
	ctx.r[31].s64 = ctx.r[1].s64 + 192;
	// 82A0C5F8: 4BAFC421  bl 0x82508a18
	ctx.lr = 0x82A0C5FC;
	sub_82508A18(ctx, base);
	// 82A0C5FC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A0C600: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A0C604: 39CB8548  addi r14, r11, -0x7ab8
	ctx.r[14].s64 = ctx.r[11].s64 + -31416;
	// 82A0C608: 38A000BB  li r5, 0xbb
	ctx.r[5].s64 = 187;
	// 82A0C60C: 7DC47378  mr r4, r14
	ctx.r[4].u64 = ctx.r[14].u64;
	// 82A0C610: 91C10088  stw r14, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[14].u32 ) };
	// 82A0C614: 7DE37B78  mr r3, r15
	ctx.r[3].u64 = ctx.r[15].u64;
	// 82A0C618: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82A0C61C: 4844A9CD  bl 0x82e56fe8
	ctx.lr = 0x82A0C620;
	sub_82E56FE8(ctx, base);
	// 82A0C620: 38610200  addi r3, r1, 0x200
	ctx.r[3].s64 = ctx.r[1].s64 + 512;
	// 82A0C624: 483E566D  bl 0x82df1c90
	ctx.lr = 0x82A0C628;
	sub_82DF1C90(ctx, base);
	// 82A0C628: 806100C4  lwz r3, 0xc4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82A0C62C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0C630: 419A0008  beq cr6, 0x82a0c638
	if ctx.cr[6].eq {
	pc = 0x82A0C638; continue 'dispatch;
	}
	// 82A0C634: 4B8B425D  bl 0x822c0890
	ctx.lr = 0x82A0C638;
	sub_822C0890(ctx, base);
	// 82A0C638: 80610234  lwz r3, 0x234(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(564 as u32) ) } as u64;
	// 82A0C63C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0C640: 419A0008  beq cr6, 0x82a0c648
	if ctx.cr[6].eq {
	pc = 0x82A0C648; continue 'dispatch;
	}
	// 82A0C644: 4B8B424D  bl 0x822c0890
	ctx.lr = 0x82A0C648;
	sub_822C0890(ctx, base);
	// 82A0C648: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A0C64C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A0C650: 7DC47378  mr r4, r14
	ctx.r[4].u64 = ctx.r[14].u64;
	// 82A0C654: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A0C658: 38A000BF  li r5, 0xbf
	ctx.r[5].s64 = 191;
	// 82A0C65C: C3CB08A4  lfs f30, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82A0C660: 38600100  li r3, 0x100
	ctx.r[3].s64 = 256;
	// 82A0C664: C00A2818  lfs f0, 0x2818(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(10264 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A0C668: D3C100F0  stfs f30, 0xf0(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 82A0C66C: D3C100F4  stfs f30, 0xf4(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 82A0C670: D00100F8  stfs f0, 0xf8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 82A0C674: D3C100FC  stfs f30, 0xfc(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 82A0C678: 483E5D71  bl 0x82df23e8
	ctx.lr = 0x82A0C67C;
	sub_82DF23E8(ctx, base);
	// 82A0C67C: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82A0C680: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A0C684: 38ABBA80  addi r5, r11, -0x4580
	ctx.r[5].s64 = ctx.r[11].s64 + -17792;
	// 82A0C688: 90A10060  stw r5, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[5].u32 ) };
	// 82A0C68C: 41820014  beq 0x82a0c6a0
	if ctx.cr[0].eq {
	pc = 0x82A0C6A0; continue 'dispatch;
	}
	// 82A0C690: 388100F0  addi r4, r1, 0xf0
	ctx.r[4].s64 = ctx.r[1].s64 + 240;
	// 82A0C694: 4BB7E68D  bl 0x8258ad20
	ctx.lr = 0x82A0C698;
	sub_8258AD20(ctx, base);
	// 82A0C698: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A0C69C: 48000008  b 0x82a0c6a4
	pc = 0x82A0C6A4; continue 'dispatch;
	// 82A0C6A0: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 82A0C6A4: 93E10070  stw r31, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u32 ) };
	// 82A0C6A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0C6AC: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 82A0C6B0: 4B8FA2E1  bl 0x82306990
	ctx.lr = 0x82A0C6B4;
	sub_82306990(ctx, base);
	// 82A0C6B4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A0C6B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0C6BC: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 82A0C6C0: 4B8B3941  bl 0x822c0000
	ctx.lr = 0x82A0C6C4;
	sub_822C0000(ctx, base);
	// 82A0C6C4: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82A0C6C8: 3BF60158  addi r31, r22, 0x158
	ctx.r[31].s64 = ctx.r[22].s64 + 344;
	// 82A0C6CC: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82A0C6D0: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82A0C6D4: 91760158  stw r11, 0x158(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(344 as u32), ctx.r[11].u32 ) };
	// 82A0C6D8: 4B8B7D89  bl 0x822c4460
	ctx.lr = 0x82A0C6DC;
	sub_822C4460(ctx, base);
	// 82A0C6DC: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A0C6E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0C6E4: 419A0008  beq cr6, 0x82a0c6ec
	if ctx.cr[6].eq {
	pc = 0x82A0C6EC; continue 'dispatch;
	}
	// 82A0C6E8: 4B8B41A9  bl 0x822c0890
	ctx.lr = 0x82A0C6EC;
	sub_822C0890(ctx, base);
	// 82A0C6EC: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 82A0C6F0: 839F0000  lwz r28, 0(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0C6F4: 386101F0  addi r3, r1, 0x1f0
	ctx.r[3].s64 = ctx.r[1].s64 + 496;
	// 82A0C6F8: 4BB05A21  bl 0x82512118
	ctx.lr = 0x82A0C6FC;
	sub_82512118(ctx, base);
	// 82A0C6FC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A0C700: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0C704: 4840672D  bl 0x82e12e30
	ctx.lr = 0x82A0C708;
	sub_82E12E30(ctx, base);
	// 82A0C708: 806101F4  lwz r3, 0x1f4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(500 as u32) ) } as u64;
	// 82A0C70C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0C710: 419A0008  beq cr6, 0x82a0c718
	if ctx.cr[6].eq {
	pc = 0x82A0C718; continue 'dispatch;
	}
	// 82A0C714: 4B8B417D  bl 0x822c0890
	ctx.lr = 0x82A0C718;
	sub_822C0890(ctx, base);
	// 82A0C718: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 82A0C71C: 7E038378  mr r3, r16
	ctx.r[3].u64 = ctx.r[16].u64;
	// 82A0C720: 4BAFBF61  bl 0x82508680
	ctx.lr = 0x82A0C724;
	sub_82508680(ctx, base);
	// 82A0C724: 9076021C  stw r3, 0x21c(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(540 as u32), ctx.r[3].u32 ) };
	// 82A0C728: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82A0C72C: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0C730: 4841E3B9  bl 0x82e2aae8
	ctx.lr = 0x82A0C734;
	sub_82E2AAE8(ctx, base);
	// 82A0C734: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A0C738: 388B87D0  addi r4, r11, -0x7830
	ctx.r[4].s64 = ctx.r[11].s64 + -30768;
	// 82A0C73C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A0C740: 90810070  stw r4, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[4].u32 ) };
	// 82A0C744: 483E72C5  bl 0x82df3a08
	ctx.lr = 0x82A0C748;
	sub_82DF3A08(ctx, base);
	// 82A0C748: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A0C74C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82A0C750: 388100E0  addi r4, r1, 0xe0
	ctx.r[4].s64 = ctx.r[1].s64 + 224;
	// 82A0C754: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82A0C758: 48422719  bl 0x82e2ee70
	ctx.lr = 0x82A0C75C;
	sub_82E2EE70(ctx, base);
	// 82A0C75C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A0C760: 483E6CC9  bl 0x82df3428
	ctx.lr = 0x82A0C764;
	sub_82DF3428(ctx, base);
	// 82A0C764: 816100B0  lwz r11, 0xb0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 82A0C768: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0C76C: 419A009C  beq cr6, 0x82a0c808
	if ctx.cr[6].eq {
	pc = 0x82A0C808; continue 'dispatch;
	}
	// 82A0C770: 7DC47378  mr r4, r14
	ctx.r[4].u64 = ctx.r[14].u64;
	// 82A0C774: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A0C778: 38A000D1  li r5, 0xd1
	ctx.r[5].s64 = 209;
	// 82A0C77C: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 82A0C780: 483E5C69  bl 0x82df23e8
	ctx.lr = 0x82A0C784;
	sub_82DF23E8(ctx, base);
	// 82A0C784: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A0C788: 41820010  beq 0x82a0c798
	if ctx.cr[0].eq {
	pc = 0x82A0C798; continue 'dispatch;
	}
	// 82A0C78C: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 82A0C790: 4840A101  bl 0x82e16890
	ctx.lr = 0x82A0C794;
	sub_82E16890(ctx, base);
	// 82A0C794: 48000008  b 0x82a0c79c
	pc = 0x82A0C79C; continue 'dispatch;
	// 82A0C798: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A0C79C: 3BD60148  addi r30, r22, 0x148
	ctx.r[30].s64 = ctx.r[22].s64 + 328;
	// 82A0C7A0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A0C7A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A0C7A8: 4B950BC9  bl 0x8235d370
	ctx.lr = 0x82A0C7AC;
	sub_8235D370(ctx, base);
	// 82A0C7AC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0C7B0: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0C7B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0C7B8: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82A0C7BC: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 82A0C7C0: 419A0024  beq cr6, 0x82a0c7e4
	if ctx.cr[6].eq {
	pc = 0x82A0C7E4; continue 'dispatch;
	}
	// 82A0C7C4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A0C7C8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A0C7CC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A0C7D0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A0C7D4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A0C7D8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A0C7DC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A0C7E0: 4082FFE8  bne 0x82a0c7c8
	if !ctx.cr[0].eq {
	pc = 0x82A0C7C8; continue 'dispatch;
	}
	// 82A0C7E4: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82A0C7E8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0C7EC: 484088C5  bl 0x82e150b0
	ctx.lr = 0x82A0C7F0;
	sub_82E150B0(ctx, base);
	// 82A0C7F0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82A0C7F4: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82A0C7F8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A0C7FC: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 82A0C800: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 82A0C804: 4BB04355  bl 0x82510b58
	ctx.lr = 0x82A0C808;
	sub_82510B58(ctx, base);
	// 82A0C808: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82A0C80C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0C810: 419A0008  beq cr6, 0x82a0c818
	if ctx.cr[6].eq {
	pc = 0x82A0C818; continue 'dispatch;
	}
	// 82A0C814: 4B8B407D  bl 0x822c0890
	ctx.lr = 0x82A0C818;
	sub_822C0890(ctx, base);
	// 82A0C818: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A0C81C: 81560148  lwz r10, 0x148(r22)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(328 as u32) ) } as u64;
	// 82A0C820: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82A0C824: C3AB08A8  lfs f29, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82A0C828: 419A08E0  beq cr6, 0x82a0d108
	if ctx.cr[6].eq {
	pc = 0x82A0D108; continue 'dispatch;
	}
	// 82A0C82C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A0C830: 9BA1028C  stb r29, 0x28c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(652 as u32), ctx.r[29].u8 ) };
	// 82A0C834: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A0C838: D3A10278  stfs f29, 0x278(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(632 as u32), tmp.u32 ) };
	// 82A0C83C: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82A0C840: D3C10280  stfs f30, 0x280(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(640 as u32), tmp.u32 ) };
	// 82A0C844: 394A1CEC  addi r10, r10, 0x1cec
	ctx.r[10].s64 = ctx.r[10].s64 + 7404;
	// 82A0C848: 392987C0  addi r9, r9, -0x7840
	ctx.r[9].s64 = ctx.r[9].s64 + -30784;
	// 82A0C84C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82A0C850: C3EB9534  lfs f31, -0x6acc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A0C854: 91410270  stw r10, 0x270(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(624 as u32), ctx.r[10].u32 ) };
	// 82A0C858: D3E10284  stfs f31, 0x284(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(644 as u32), tmp.u32 ) };
	// 82A0C85C: 91210274  stw r9, 0x274(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(628 as u32), ctx.r[9].u32 ) };
	// 82A0C860: D3E10288  stfs f31, 0x288(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(648 as u32), tmp.u32 ) };
	// 82A0C864: 9101027C  stw r8, 0x27c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(636 as u32), ctx.r[8].u32 ) };
	// 82A0C868: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A0C86C: 91210068  stw r9, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[9].u32 ) };
	// 82A0C870: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 82A0C874: 914101A0  stw r10, 0x1a0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(416 as u32), ctx.r[10].u32 ) };
	// 82A0C878: 396B87B4  addi r11, r11, -0x784c
	ctx.r[11].s64 = ctx.r[11].s64 + -30796;
	// 82A0C87C: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A0C880: 3D008208  lis r8, -0x7df8
	ctx.r[8].s64 = -2113404928;
	// 82A0C884: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A0C888: 3CE08207  lis r7, -0x7df9
	ctx.r[7].s64 = -2113470464;
	// 82A0C88C: 916101AC  stw r11, 0x1ac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(428 as u32), ctx.r[11].u32 ) };
	// 82A0C890: 3CC0820B  lis r6, -0x7df5
	ctx.r[6].s64 = -2113208320;
	// 82A0C894: 3CA0820B  lis r5, -0x7df5
	ctx.r[5].s64 = -2113208320;
	// 82A0C898: 3C80820B  lis r4, -0x7df5
	ctx.r[4].s64 = -2113208320;
	// 82A0C89C: 3C60820B  lis r3, -0x7df5
	ctx.r[3].s64 = -2113208320;
	// 82A0C8A0: 3FE0820B  lis r31, -0x7df5
	ctx.r[31].s64 = -2113208320;
	// 82A0C8A4: 3FC08208  lis r30, -0x7df8
	ctx.r[30].s64 = -2113404928;
	// 82A0C8A8: 3FA0820B  lis r29, -0x7df5
	ctx.r[29].s64 = -2113208320;
	// 82A0C8AC: 3F80820B  lis r28, -0x7df5
	ctx.r[28].s64 = -2113208320;
	// 82A0C8B0: 3F60820B  lis r27, -0x7df5
	ctx.r[27].s64 = -2113208320;
	// 82A0C8B4: 3F40820B  lis r26, -0x7df5
	ctx.r[26].s64 = -2113208320;
	// 82A0C8B8: 3F20820B  lis r25, -0x7df5
	ctx.r[25].s64 = -2113208320;
	// 82A0C8BC: 3F008203  lis r24, -0x7dfd
	ctx.r[24].s64 = -2113732608;
	// 82A0C8C0: 3EE08206  lis r23, -0x7dfa
	ctx.r[23].s64 = -2113536000;
	// 82A0C8C4: 3EC0820B  lis r22, -0x7df5
	ctx.r[22].s64 = -2113208320;
	// 82A0C8C8: 3A6A87A8  addi r19, r10, -0x7858
	ctx.r[19].s64 = ctx.r[10].s64 + -30808;
	// 82A0C8CC: 3A4948D0  addi r18, r9, 0x48d0
	ctx.r[18].s64 = ctx.r[9].s64 + 18640;
	// 82A0C8D0: 39C38774  addi r14, r3, -0x788c
	ctx.r[14].s64 = ctx.r[3].s64 + -30860;
	// 82A0C8D4: 926101B0  stw r19, 0x1b0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(432 as u32), ctx.r[19].u32 ) };
	// 82A0C8D8: 397F8764  addi r11, r31, -0x789c
	ctx.r[11].s64 = ctx.r[31].s64 + -30876;
	// 82A0C8DC: 924101B4  stw r18, 0x1b4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(436 as u32), ctx.r[18].u32 ) };
	// 82A0C8E0: 395D8754  addi r10, r29, -0x78ac
	ctx.r[10].s64 = ctx.r[29].s64 + -30892;
	// 82A0C8E4: 91C101C4  stw r14, 0x1c4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(452 as u32), ctx.r[14].u32 ) };
	// 82A0C8E8: 393A872C  addi r9, r26, -0x78d4
	ctx.r[9].s64 = ctx.r[26].s64 + -30932;
	// 82A0C8EC: 916101C8  stw r11, 0x1c8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(456 as u32), ctx.r[11].u32 ) };
	// 82A0C8F0: 3AA8E814  addi r21, r8, -0x17ec
	ctx.r[21].s64 = ctx.r[8].s64 + -6124;
	// 82A0C8F4: 914101D0  stw r10, 0x1d0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(464 as u32), ctx.r[10].u32 ) };
	// 82A0C8F8: 3A87D748  addi r20, r7, -0x28b8
	ctx.r[20].s64 = ctx.r[7].s64 + -10424;
	// 82A0C8FC: 912101DC  stw r9, 0x1dc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(476 as u32), ctx.r[9].u32 ) };
	// 82A0C900: 3A26879C  addi r17, r6, -0x7864
	ctx.r[17].s64 = ctx.r[6].s64 + -30820;
	// 82A0C904: 92A101A4  stw r21, 0x1a4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(420 as u32), ctx.r[21].u32 ) };
	// 82A0C908: 3A058790  addi r16, r5, -0x7870
	ctx.r[16].s64 = ctx.r[5].s64 + -30832;
	// 82A0C90C: 928101A8  stw r20, 0x1a8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(424 as u32), ctx.r[20].u32 ) };
	// 82A0C910: 39E48780  addi r15, r4, -0x7880
	ctx.r[15].s64 = ctx.r[4].s64 + -30848;
	// 82A0C914: 922101B8  stw r17, 0x1b8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(440 as u32), ctx.r[17].u32 ) };
	// 82A0C918: 3BDEE340  addi r30, r30, -0x1cc0
	ctx.r[30].s64 = ctx.r[30].s64 + -7360;
	// 82A0C91C: 920101BC  stw r16, 0x1bc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(444 as u32), ctx.r[16].u32 ) };
	// 82A0C920: 3B9C8744  addi r28, r28, -0x78bc
	ctx.r[28].s64 = ctx.r[28].s64 + -30908;
	// 82A0C924: 91E101C0  stw r15, 0x1c0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(448 as u32), ctx.r[15].u32 ) };
	// 82A0C928: 3B7B8734  addi r27, r27, -0x78cc
	ctx.r[27].s64 = ctx.r[27].s64 + -30924;
	// 82A0C92C: 93C101CC  stw r30, 0x1cc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(460 as u32), ctx.r[30].u32 ) };
	// 82A0C930: 3B398720  addi r25, r25, -0x78e0
	ctx.r[25].s64 = ctx.r[25].s64 + -30944;
	// 82A0C934: 938101D4  stw r28, 0x1d4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(468 as u32), ctx.r[28].u32 ) };
	// 82A0C938: 3B182D6C  addi r24, r24, 0x2d6c
	ctx.r[24].s64 = ctx.r[24].s64 + 11628;
	// 82A0C93C: 936101D8  stw r27, 0x1d8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(472 as u32), ctx.r[27].u32 ) };
	// 82A0C940: 3AF7D0C8  addi r23, r23, -0x2f38
	ctx.r[23].s64 = ctx.r[23].s64 + -12088;
	// 82A0C944: 932101E0  stw r25, 0x1e0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(480 as u32), ctx.r[25].u32 ) };
	// 82A0C948: 3AD68718  addi r22, r22, -0x78e8
	ctx.r[22].s64 = ctx.r[22].s64 + -30952;
	// 82A0C94C: 930101E4  stw r24, 0x1e4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(484 as u32), ctx.r[24].u32 ) };
	// 82A0C950: 38610290  addi r3, r1, 0x290
	ctx.r[3].s64 = ctx.r[1].s64 + 656;
	// 82A0C954: 92E101E8  stw r23, 0x1e8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(488 as u32), ctx.r[23].u32 ) };
	// 82A0C958: 92C101EC  stw r22, 0x1ec(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(492 as u32), ctx.r[22].u32 ) };
	// 82A0C95C: 91210098  stw r9, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[9].u32 ) };
	// 82A0C960: 914100A8  stw r10, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[10].u32 ) };
	// 82A0C964: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A0C968: 483F1F61  bl 0x82dfe8c8
	ctx.lr = 0x82A0C96C;
	sub_82DFE8C8(ctx, base);
	// 82A0C96C: 38610298  addi r3, r1, 0x298
	ctx.r[3].s64 = ctx.r[1].s64 + 664;
	// 82A0C970: 483F1F59  bl 0x82dfe8c8
	ctx.lr = 0x82A0C974;
	sub_82DFE8C8(ctx, base);
	// 82A0C974: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A0C978: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A0C97C: D3A102A8  stfs f29, 0x2a8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(680 as u32), tmp.u32 ) };
	// 82A0C980: 396B8708  addi r11, r11, -0x78f8
	ctx.r[11].s64 = ctx.r[11].s64 + -30968;
	// 82A0C984: D3C102B0  stfs f30, 0x2b0(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(688 as u32), tmp.u32 ) };
	// 82A0C988: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A0C98C: D3E102B4  stfs f31, 0x2b4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(692 as u32), tmp.u32 ) };
	// 82A0C990: D3E102B8  stfs f31, 0x2b8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(696 as u32), tmp.u32 ) };
	// 82A0C994: 92A102A0  stw r21, 0x2a0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(672 as u32), ctx.r[21].u32 ) };
	// 82A0C998: 916102A4  stw r11, 0x2a4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(676 as u32), ctx.r[11].u32 ) };
	// 82A0C99C: 386102C0  addi r3, r1, 0x2c0
	ctx.r[3].s64 = ctx.r[1].s64 + 704;
	// 82A0C9A0: 914102AC  stw r10, 0x2ac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(684 as u32), ctx.r[10].u32 ) };
	// 82A0C9A4: 992102BC  stb r9, 0x2bc(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(700 as u32), ctx.r[9].u8 ) };
	// 82A0C9A8: 483F1F21  bl 0x82dfe8c8
	ctx.lr = 0x82A0C9AC;
	sub_82DFE8C8(ctx, base);
	// 82A0C9AC: 386102C8  addi r3, r1, 0x2c8
	ctx.r[3].s64 = ctx.r[1].s64 + 712;
	// 82A0C9B0: 483F1F19  bl 0x82dfe8c8
	ctx.lr = 0x82A0C9B4;
	sub_82DFE8C8(ctx, base);
	// 82A0C9B4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A0C9B8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82A0C9BC: D3A102D8  stfs f29, 0x2d8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(728 as u32), tmp.u32 ) };
	// 82A0C9C0: 396B86F8  addi r11, r11, -0x7908
	ctx.r[11].s64 = ctx.r[11].s64 + -30984;
	// 82A0C9C4: D3C102E0  stfs f30, 0x2e0(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(736 as u32), tmp.u32 ) };
	// 82A0C9C8: D3E102E4  stfs f31, 0x2e4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(740 as u32), tmp.u32 ) };
	// 82A0C9CC: 928102D0  stw r20, 0x2d0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(720 as u32), ctx.r[20].u32 ) };
	// 82A0C9D0: D3E102E8  stfs f31, 0x2e8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(744 as u32), tmp.u32 ) };
	// 82A0C9D4: 916102D4  stw r11, 0x2d4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(724 as u32), ctx.r[11].u32 ) };
	// 82A0C9D8: 93A102DC  stw r29, 0x2dc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(732 as u32), ctx.r[29].u32 ) };
	// 82A0C9DC: 386102F0  addi r3, r1, 0x2f0
	ctx.r[3].s64 = ctx.r[1].s64 + 752;
	// 82A0C9E0: 9BA102EC  stb r29, 0x2ec(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(748 as u32), ctx.r[29].u8 ) };
	// 82A0C9E4: 483F1EE5  bl 0x82dfe8c8
	ctx.lr = 0x82A0C9E8;
	sub_82DFE8C8(ctx, base);
	// 82A0C9E8: 386102F8  addi r3, r1, 0x2f8
	ctx.r[3].s64 = ctx.r[1].s64 + 760;
	// 82A0C9EC: 483F1EDD  bl 0x82dfe8c8
	ctx.lr = 0x82A0C9F0;
	sub_82DFE8C8(ctx, base);
	// 82A0C9F0: 83410050  lwz r26, 0x50(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A0C9F4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A0C9F8: D3A10308  stfs f29, 0x308(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(776 as u32), tmp.u32 ) };
	// 82A0C9FC: D3C10310  stfs f30, 0x310(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(784 as u32), tmp.u32 ) };
	// 82A0CA00: 93A1030C  stw r29, 0x30c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(780 as u32), ctx.r[29].u32 ) };
	// 82A0CA04: 396B86E4  addi r11, r11, -0x791c
	ctx.r[11].s64 = ctx.r[11].s64 + -31004;
	// 82A0CA08: D3E10314  stfs f31, 0x314(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(788 as u32), tmp.u32 ) };
	// 82A0CA0C: D3E10318  stfs f31, 0x318(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(792 as u32), tmp.u32 ) };
	// 82A0CA10: 9BA1031C  stb r29, 0x31c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(796 as u32), ctx.r[29].u8 ) };
	// 82A0CA14: 93410300  stw r26, 0x300(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(768 as u32), ctx.r[26].u32 ) };
	// 82A0CA18: 38610320  addi r3, r1, 0x320
	ctx.r[3].s64 = ctx.r[1].s64 + 800;
	// 82A0CA1C: 91610304  stw r11, 0x304(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(772 as u32), ctx.r[11].u32 ) };
	// 82A0CA20: 483F1EA9  bl 0x82dfe8c8
	ctx.lr = 0x82A0CA24;
	sub_82DFE8C8(ctx, base);
	// 82A0CA24: 38610328  addi r3, r1, 0x328
	ctx.r[3].s64 = ctx.r[1].s64 + 808;
	// 82A0CA28: 483F1EA1  bl 0x82dfe8c8
	ctx.lr = 0x82A0CA2C;
	sub_82DFE8C8(ctx, base);
	// 82A0CA2C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A0CA30: D3A10338  stfs f29, 0x338(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(824 as u32), tmp.u32 ) };
	// 82A0CA34: 92610330  stw r19, 0x330(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(816 as u32), ctx.r[19].u32 ) };
	// 82A0CA38: 396B86D0  addi r11, r11, -0x7930
	ctx.r[11].s64 = ctx.r[11].s64 + -31024;
	// 82A0CA3C: D3C10340  stfs f30, 0x340(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(832 as u32), tmp.u32 ) };
	// 82A0CA40: D3E10344  stfs f31, 0x344(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(836 as u32), tmp.u32 ) };
	// 82A0CA44: 93A1033C  stw r29, 0x33c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(828 as u32), ctx.r[29].u32 ) };
	// 82A0CA48: D3E10348  stfs f31, 0x348(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(840 as u32), tmp.u32 ) };
	// 82A0CA4C: 91610334  stw r11, 0x334(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(820 as u32), ctx.r[11].u32 ) };
	// 82A0CA50: 9BA1034C  stb r29, 0x34c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(844 as u32), ctx.r[29].u8 ) };
	// 82A0CA54: 38610350  addi r3, r1, 0x350
	ctx.r[3].s64 = ctx.r[1].s64 + 848;
	// 82A0CA58: 483F1E71  bl 0x82dfe8c8
	ctx.lr = 0x82A0CA5C;
	sub_82DFE8C8(ctx, base);
	// 82A0CA5C: 38610358  addi r3, r1, 0x358
	ctx.r[3].s64 = ctx.r[1].s64 + 856;
	// 82A0CA60: 483F1E69  bl 0x82dfe8c8
	ctx.lr = 0x82A0CA64;
	sub_82DFE8C8(ctx, base);
	// 82A0CA64: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A0CA68: D3A10368  stfs f29, 0x368(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(872 as u32), tmp.u32 ) };
	// 82A0CA6C: 92410360  stw r18, 0x360(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(864 as u32), ctx.r[18].u32 ) };
	// 82A0CA70: 396B86BC  addi r11, r11, -0x7944
	ctx.r[11].s64 = ctx.r[11].s64 + -31044;
	// 82A0CA74: D3C10370  stfs f30, 0x370(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(880 as u32), tmp.u32 ) };
	// 82A0CA78: D3E10374  stfs f31, 0x374(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(884 as u32), tmp.u32 ) };
	// 82A0CA7C: 93A1036C  stw r29, 0x36c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(876 as u32), ctx.r[29].u32 ) };
	// 82A0CA80: D3E10378  stfs f31, 0x378(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(888 as u32), tmp.u32 ) };
	// 82A0CA84: 91610364  stw r11, 0x364(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(868 as u32), ctx.r[11].u32 ) };
	// 82A0CA88: 9BA1037C  stb r29, 0x37c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(892 as u32), ctx.r[29].u8 ) };
	// 82A0CA8C: 38610380  addi r3, r1, 0x380
	ctx.r[3].s64 = ctx.r[1].s64 + 896;
	// 82A0CA90: 483F1E39  bl 0x82dfe8c8
	ctx.lr = 0x82A0CA94;
	sub_82DFE8C8(ctx, base);
	// 82A0CA94: 38610388  addi r3, r1, 0x388
	ctx.r[3].s64 = ctx.r[1].s64 + 904;
	// 82A0CA98: 483F1E31  bl 0x82dfe8c8
	ctx.lr = 0x82A0CA9C;
	sub_82DFE8C8(ctx, base);
	// 82A0CA9C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A0CAA0: D3A10398  stfs f29, 0x398(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(920 as u32), tmp.u32 ) };
	// 82A0CAA4: 92210390  stw r17, 0x390(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(912 as u32), ctx.r[17].u32 ) };
	// 82A0CAA8: D3C103A0  stfs f30, 0x3a0(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(928 as u32), tmp.u32 ) };
	// 82A0CAAC: 396B86A8  addi r11, r11, -0x7958
	ctx.r[11].s64 = ctx.r[11].s64 + -31064;
	// 82A0CAB0: D3E103A4  stfs f31, 0x3a4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(932 as u32), tmp.u32 ) };
	// 82A0CAB4: D3E103A8  stfs f31, 0x3a8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(936 as u32), tmp.u32 ) };
	// 82A0CAB8: 91610394  stw r11, 0x394(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(916 as u32), ctx.r[11].u32 ) };
	// 82A0CABC: 93A1039C  stw r29, 0x39c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(924 as u32), ctx.r[29].u32 ) };
	// 82A0CAC0: 386103B0  addi r3, r1, 0x3b0
	ctx.r[3].s64 = ctx.r[1].s64 + 944;
	// 82A0CAC4: 9BA103AC  stb r29, 0x3ac(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(940 as u32), ctx.r[29].u8 ) };
	// 82A0CAC8: 483F1E01  bl 0x82dfe8c8
	ctx.lr = 0x82A0CACC;
	sub_82DFE8C8(ctx, base);
	// 82A0CACC: 386103B8  addi r3, r1, 0x3b8
	ctx.r[3].s64 = ctx.r[1].s64 + 952;
	// 82A0CAD0: 483F1DF9  bl 0x82dfe8c8
	ctx.lr = 0x82A0CAD4;
	sub_82DFE8C8(ctx, base);
	// 82A0CAD4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A0CAD8: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 82A0CADC: D3A103C8  stfs f29, 0x3c8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(968 as u32), tmp.u32 ) };
	// 82A0CAE0: 396B8698  addi r11, r11, -0x7968
	ctx.r[11].s64 = ctx.r[11].s64 + -31080;
	// 82A0CAE4: D3C103D0  stfs f30, 0x3d0(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(976 as u32), tmp.u32 ) };
	// 82A0CAE8: D3E103D4  stfs f31, 0x3d4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(980 as u32), tmp.u32 ) };
	// 82A0CAEC: 920103C0  stw r16, 0x3c0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(960 as u32), ctx.r[16].u32 ) };
	// 82A0CAF0: D3E103D8  stfs f31, 0x3d8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(984 as u32), tmp.u32 ) };
	// 82A0CAF4: 916103C4  stw r11, 0x3c4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(964 as u32), ctx.r[11].u32 ) };
	// 82A0CAF8: 93E103CC  stw r31, 0x3cc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(972 as u32), ctx.r[31].u32 ) };
	// 82A0CAFC: 386103E0  addi r3, r1, 0x3e0
	ctx.r[3].s64 = ctx.r[1].s64 + 992;
	// 82A0CB00: 9BA103DC  stb r29, 0x3dc(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(988 as u32), ctx.r[29].u8 ) };
	// 82A0CB04: 483F1DC5  bl 0x82dfe8c8
	ctx.lr = 0x82A0CB08;
	sub_82DFE8C8(ctx, base);
	// 82A0CB08: 386103E8  addi r3, r1, 0x3e8
	ctx.r[3].s64 = ctx.r[1].s64 + 1000;
	// 82A0CB0C: 483F1DBD  bl 0x82dfe8c8
	ctx.lr = 0x82A0CB10;
	sub_82DFE8C8(ctx, base);
	// 82A0CB10: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A0CB14: D3A103F8  stfs f29, 0x3f8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1016 as u32), tmp.u32 ) };
	// 82A0CB18: 91E103F0  stw r15, 0x3f0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1008 as u32), ctx.r[15].u32 ) };
	// 82A0CB1C: 396B8684  addi r11, r11, -0x797c
	ctx.r[11].s64 = ctx.r[11].s64 + -31100;
	// 82A0CB20: D3C10400  stfs f30, 0x400(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1024 as u32), tmp.u32 ) };
	// 82A0CB24: D3E10404  stfs f31, 0x404(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1028 as u32), tmp.u32 ) };
	// 82A0CB28: 93E103FC  stw r31, 0x3fc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1020 as u32), ctx.r[31].u32 ) };
	// 82A0CB2C: D3E10408  stfs f31, 0x408(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1032 as u32), tmp.u32 ) };
	// 82A0CB30: 916103F4  stw r11, 0x3f4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1012 as u32), ctx.r[11].u32 ) };
	// 82A0CB34: 9BA1040C  stb r29, 0x40c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(1036 as u32), ctx.r[29].u8 ) };
	// 82A0CB38: 38610410  addi r3, r1, 0x410
	ctx.r[3].s64 = ctx.r[1].s64 + 1040;
	// 82A0CB3C: 483F1D8D  bl 0x82dfe8c8
	ctx.lr = 0x82A0CB40;
	sub_82DFE8C8(ctx, base);
	// 82A0CB40: 38610418  addi r3, r1, 0x418
	ctx.r[3].s64 = ctx.r[1].s64 + 1048;
	// 82A0CB44: 483F1D85  bl 0x82dfe8c8
	ctx.lr = 0x82A0CB48;
	sub_82DFE8C8(ctx, base);
	// 82A0CB48: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A0CB4C: D3A10428  stfs f29, 0x428(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1064 as u32), tmp.u32 ) };
	// 82A0CB50: 91C10420  stw r14, 0x420(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1056 as u32), ctx.r[14].u32 ) };
	// 82A0CB54: 396B8670  addi r11, r11, -0x7990
	ctx.r[11].s64 = ctx.r[11].s64 + -31120;
	// 82A0CB58: D3C10430  stfs f30, 0x430(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1072 as u32), tmp.u32 ) };
	// 82A0CB5C: D3E10434  stfs f31, 0x434(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1076 as u32), tmp.u32 ) };
	// 82A0CB60: 93E1042C  stw r31, 0x42c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1068 as u32), ctx.r[31].u32 ) };
	// 82A0CB64: D3E10438  stfs f31, 0x438(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1080 as u32), tmp.u32 ) };
	// 82A0CB68: 91610424  stw r11, 0x424(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1060 as u32), ctx.r[11].u32 ) };
	// 82A0CB6C: 9BA1043C  stb r29, 0x43c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(1084 as u32), ctx.r[29].u8 ) };
	// 82A0CB70: 38610440  addi r3, r1, 0x440
	ctx.r[3].s64 = ctx.r[1].s64 + 1088;
	// 82A0CB74: 483F1D55  bl 0x82dfe8c8
	ctx.lr = 0x82A0CB78;
	sub_82DFE8C8(ctx, base);
	// 82A0CB78: 38610448  addi r3, r1, 0x448
	ctx.r[3].s64 = ctx.r[1].s64 + 1096;
	// 82A0CB7C: 483F1D4D  bl 0x82dfe8c8
	ctx.lr = 0x82A0CB80;
	sub_82DFE8C8(ctx, base);
	// 82A0CB80: 82A10054  lwz r21, 0x54(r1)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A0CB84: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A0CB88: D3A10458  stfs f29, 0x458(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1112 as u32), tmp.u32 ) };
	// 82A0CB8C: D3C10460  stfs f30, 0x460(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1120 as u32), tmp.u32 ) };
	// 82A0CB90: 93E1045C  stw r31, 0x45c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1116 as u32), ctx.r[31].u32 ) };
	// 82A0CB94: 396B865C  addi r11, r11, -0x79a4
	ctx.r[11].s64 = ctx.r[11].s64 + -31140;
	// 82A0CB98: D3E10464  stfs f31, 0x464(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1124 as u32), tmp.u32 ) };
	// 82A0CB9C: D3E10468  stfs f31, 0x468(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1128 as u32), tmp.u32 ) };
	// 82A0CBA0: 9BA1046C  stb r29, 0x46c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(1132 as u32), ctx.r[29].u8 ) };
	// 82A0CBA4: 92A10450  stw r21, 0x450(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1104 as u32), ctx.r[21].u32 ) };
	// 82A0CBA8: 38610470  addi r3, r1, 0x470
	ctx.r[3].s64 = ctx.r[1].s64 + 1136;
	// 82A0CBAC: 91610454  stw r11, 0x454(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1108 as u32), ctx.r[11].u32 ) };
	// 82A0CBB0: 483F1D19  bl 0x82dfe8c8
	ctx.lr = 0x82A0CBB4;
	sub_82DFE8C8(ctx, base);
	// 82A0CBB4: 38610478  addi r3, r1, 0x478
	ctx.r[3].s64 = ctx.r[1].s64 + 1144;
	// 82A0CBB8: 483F1D11  bl 0x82dfe8c8
	ctx.lr = 0x82A0CBBC;
	sub_82DFE8C8(ctx, base);
	// 82A0CBBC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A0CBC0: D3A10488  stfs f29, 0x488(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1160 as u32), tmp.u32 ) };
	// 82A0CBC4: 93C10480  stw r30, 0x480(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1152 as u32), ctx.r[30].u32 ) };
	// 82A0CBC8: 396B8648  addi r11, r11, -0x79b8
	ctx.r[11].s64 = ctx.r[11].s64 + -31160;
	// 82A0CBCC: D3C10490  stfs f30, 0x490(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1168 as u32), tmp.u32 ) };
	// 82A0CBD0: D3E10494  stfs f31, 0x494(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1172 as u32), tmp.u32 ) };
	// 82A0CBD4: 93E1048C  stw r31, 0x48c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1164 as u32), ctx.r[31].u32 ) };
	// 82A0CBD8: D3E10498  stfs f31, 0x498(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1176 as u32), tmp.u32 ) };
	// 82A0CBDC: 91610484  stw r11, 0x484(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1156 as u32), ctx.r[11].u32 ) };
	// 82A0CBE0: 9BA1049C  stb r29, 0x49c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(1180 as u32), ctx.r[29].u8 ) };
	// 82A0CBE4: 386104A0  addi r3, r1, 0x4a0
	ctx.r[3].s64 = ctx.r[1].s64 + 1184;
	// 82A0CBE8: 483F1CE1  bl 0x82dfe8c8
	ctx.lr = 0x82A0CBEC;
	sub_82DFE8C8(ctx, base);
	// 82A0CBEC: 386104A8  addi r3, r1, 0x4a8
	ctx.r[3].s64 = ctx.r[1].s64 + 1192;
	// 82A0CBF0: 483F1CD9  bl 0x82dfe8c8
	ctx.lr = 0x82A0CBF4;
	sub_82DFE8C8(ctx, base);
	// 82A0CBF4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A0CBF8: 83C100A8  lwz r30, 0xa8(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) } as u64;
	// 82A0CBFC: 396B8634  addi r11, r11, -0x79cc
	ctx.r[11].s64 = ctx.r[11].s64 + -31180;
	// 82A0CC00: D3A104B8  stfs f29, 0x4b8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1208 as u32), tmp.u32 ) };
	// 82A0CC04: 93E104BC  stw r31, 0x4bc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1212 as u32), ctx.r[31].u32 ) };
	// 82A0CC08: D3C104C0  stfs f30, 0x4c0(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1216 as u32), tmp.u32 ) };
	// 82A0CC0C: 916104B4  stw r11, 0x4b4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1204 as u32), ctx.r[11].u32 ) };
	// 82A0CC10: D3E104C4  stfs f31, 0x4c4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1220 as u32), tmp.u32 ) };
	// 82A0CC14: 9BA104CC  stb r29, 0x4cc(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(1228 as u32), ctx.r[29].u8 ) };
	// 82A0CC18: D3E104C8  stfs f31, 0x4c8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1224 as u32), tmp.u32 ) };
	// 82A0CC1C: 386104D0  addi r3, r1, 0x4d0
	ctx.r[3].s64 = ctx.r[1].s64 + 1232;
	// 82A0CC20: 93C104B0  stw r30, 0x4b0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1200 as u32), ctx.r[30].u32 ) };
	// 82A0CC24: 483F1CA5  bl 0x82dfe8c8
	ctx.lr = 0x82A0CC28;
	sub_82DFE8C8(ctx, base);
	// 82A0CC28: 386104D8  addi r3, r1, 0x4d8
	ctx.r[3].s64 = ctx.r[1].s64 + 1240;
	// 82A0CC2C: 483F1C9D  bl 0x82dfe8c8
	ctx.lr = 0x82A0CC30;
	sub_82DFE8C8(ctx, base);
	// 82A0CC30: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A0CC34: D3A104E8  stfs f29, 0x4e8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1256 as u32), tmp.u32 ) };
	// 82A0CC38: 938104E0  stw r28, 0x4e0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1248 as u32), ctx.r[28].u32 ) };
	// 82A0CC3C: 396B861C  addi r11, r11, -0x79e4
	ctx.r[11].s64 = ctx.r[11].s64 + -31204;
	// 82A0CC40: D3C104F0  stfs f30, 0x4f0(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1264 as u32), tmp.u32 ) };
	// 82A0CC44: D3E104F4  stfs f31, 0x4f4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1268 as u32), tmp.u32 ) };
	// 82A0CC48: 93E104EC  stw r31, 0x4ec(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1260 as u32), ctx.r[31].u32 ) };
	// 82A0CC4C: D3E104F8  stfs f31, 0x4f8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1272 as u32), tmp.u32 ) };
	// 82A0CC50: 916104E4  stw r11, 0x4e4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1252 as u32), ctx.r[11].u32 ) };
	// 82A0CC54: 9BA104FC  stb r29, 0x4fc(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(1276 as u32), ctx.r[29].u8 ) };
	// 82A0CC58: 38610500  addi r3, r1, 0x500
	ctx.r[3].s64 = ctx.r[1].s64 + 1280;
	// 82A0CC5C: 483F1C6D  bl 0x82dfe8c8
	ctx.lr = 0x82A0CC60;
	sub_82DFE8C8(ctx, base);
	// 82A0CC60: 38610508  addi r3, r1, 0x508
	ctx.r[3].s64 = ctx.r[1].s64 + 1288;
	// 82A0CC64: 483F1C65  bl 0x82dfe8c8
	ctx.lr = 0x82A0CC68;
	sub_82DFE8C8(ctx, base);
	// 82A0CC68: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A0CC6C: D3A10518  stfs f29, 0x518(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1304 as u32), tmp.u32 ) };
	// 82A0CC70: 93610510  stw r27, 0x510(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1296 as u32), ctx.r[27].u32 ) };
	// 82A0CC74: 396B8608  addi r11, r11, -0x79f8
	ctx.r[11].s64 = ctx.r[11].s64 + -31224;
	// 82A0CC78: D3C10520  stfs f30, 0x520(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1312 as u32), tmp.u32 ) };
	// 82A0CC7C: D3E10524  stfs f31, 0x524(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1316 as u32), tmp.u32 ) };
	// 82A0CC80: 93E1051C  stw r31, 0x51c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1308 as u32), ctx.r[31].u32 ) };
	// 82A0CC84: D3E10528  stfs f31, 0x528(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1320 as u32), tmp.u32 ) };
	// 82A0CC88: 91610514  stw r11, 0x514(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1300 as u32), ctx.r[11].u32 ) };
	// 82A0CC8C: 9BA1052C  stb r29, 0x52c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(1324 as u32), ctx.r[29].u8 ) };
	// 82A0CC90: 38610530  addi r3, r1, 0x530
	ctx.r[3].s64 = ctx.r[1].s64 + 1328;
	// 82A0CC94: 483F1C35  bl 0x82dfe8c8
	ctx.lr = 0x82A0CC98;
	sub_82DFE8C8(ctx, base);
	// 82A0CC98: 38610538  addi r3, r1, 0x538
	ctx.r[3].s64 = ctx.r[1].s64 + 1336;
	// 82A0CC9C: 483F1C2D  bl 0x82dfe8c8
	ctx.lr = 0x82A0CCA0;
	sub_82DFE8C8(ctx, base);
	// 82A0CCA0: 83C10098  lwz r30, 0x98(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 82A0CCA4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A0CCA8: D3A10548  stfs f29, 0x548(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1352 as u32), tmp.u32 ) };
	// 82A0CCAC: D3C10550  stfs f30, 0x550(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1360 as u32), tmp.u32 ) };
	// 82A0CCB0: 93E1054C  stw r31, 0x54c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1356 as u32), ctx.r[31].u32 ) };
	// 82A0CCB4: 396B85F8  addi r11, r11, -0x7a08
	ctx.r[11].s64 = ctx.r[11].s64 + -31240;
	// 82A0CCB8: D3E10554  stfs f31, 0x554(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1364 as u32), tmp.u32 ) };
	// 82A0CCBC: D3E10558  stfs f31, 0x558(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1368 as u32), tmp.u32 ) };
	// 82A0CCC0: 9BA1055C  stb r29, 0x55c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(1372 as u32), ctx.r[29].u8 ) };
	// 82A0CCC4: 93C10540  stw r30, 0x540(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1344 as u32), ctx.r[30].u32 ) };
	// 82A0CCC8: 38610560  addi r3, r1, 0x560
	ctx.r[3].s64 = ctx.r[1].s64 + 1376;
	// 82A0CCCC: 91610544  stw r11, 0x544(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1348 as u32), ctx.r[11].u32 ) };
	// 82A0CCD0: 483F1BF9  bl 0x82dfe8c8
	ctx.lr = 0x82A0CCD4;
	sub_82DFE8C8(ctx, base);
	// 82A0CCD4: 38610568  addi r3, r1, 0x568
	ctx.r[3].s64 = ctx.r[1].s64 + 1384;
	// 82A0CCD8: 483F1BF1  bl 0x82dfe8c8
	ctx.lr = 0x82A0CCDC;
	sub_82DFE8C8(ctx, base);
	// 82A0CCDC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A0CCE0: D3A10578  stfs f29, 0x578(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1400 as u32), tmp.u32 ) };
	// 82A0CCE4: 93210570  stw r25, 0x570(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1392 as u32), ctx.r[25].u32 ) };
	// 82A0CCE8: 396B85E4  addi r11, r11, -0x7a1c
	ctx.r[11].s64 = ctx.r[11].s64 + -31260;
	// 82A0CCEC: D3C10580  stfs f30, 0x580(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1408 as u32), tmp.u32 ) };
	// 82A0CCF0: D3E10584  stfs f31, 0x584(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1412 as u32), tmp.u32 ) };
	// 82A0CCF4: 93E1057C  stw r31, 0x57c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1404 as u32), ctx.r[31].u32 ) };
	// 82A0CCF8: D3E10588  stfs f31, 0x588(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1416 as u32), tmp.u32 ) };
	// 82A0CCFC: 91610574  stw r11, 0x574(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1396 as u32), ctx.r[11].u32 ) };
	// 82A0CD00: 9BA1058C  stb r29, 0x58c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(1420 as u32), ctx.r[29].u8 ) };
	// 82A0CD04: 38610590  addi r3, r1, 0x590
	ctx.r[3].s64 = ctx.r[1].s64 + 1424;
	// 82A0CD08: 483F1BC1  bl 0x82dfe8c8
	ctx.lr = 0x82A0CD0C;
	sub_82DFE8C8(ctx, base);
	// 82A0CD0C: 38610598  addi r3, r1, 0x598
	ctx.r[3].s64 = ctx.r[1].s64 + 1432;
	// 82A0CD10: 483F1BB9  bl 0x82dfe8c8
	ctx.lr = 0x82A0CD14;
	sub_82DFE8C8(ctx, base);
	// 82A0CD14: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A0CD18: D3A105A8  stfs f29, 0x5a8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1448 as u32), tmp.u32 ) };
	// 82A0CD1C: 930105A0  stw r24, 0x5a0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1440 as u32), ctx.r[24].u32 ) };
	// 82A0CD20: 396B85D4  addi r11, r11, -0x7a2c
	ctx.r[11].s64 = ctx.r[11].s64 + -31276;
	// 82A0CD24: D3C105B0  stfs f30, 0x5b0(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1456 as u32), tmp.u32 ) };
	// 82A0CD28: D3E105B4  stfs f31, 0x5b4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1460 as u32), tmp.u32 ) };
	// 82A0CD2C: 93E105AC  stw r31, 0x5ac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1452 as u32), ctx.r[31].u32 ) };
	// 82A0CD30: D3E105B8  stfs f31, 0x5b8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1464 as u32), tmp.u32 ) };
	// 82A0CD34: 916105A4  stw r11, 0x5a4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1444 as u32), ctx.r[11].u32 ) };
	// 82A0CD38: 9BA105BC  stb r29, 0x5bc(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(1468 as u32), ctx.r[29].u8 ) };
	// 82A0CD3C: 386105C0  addi r3, r1, 0x5c0
	ctx.r[3].s64 = ctx.r[1].s64 + 1472;
	// 82A0CD40: 483F1B89  bl 0x82dfe8c8
	ctx.lr = 0x82A0CD44;
	sub_82DFE8C8(ctx, base);
	// 82A0CD44: 386105C8  addi r3, r1, 0x5c8
	ctx.r[3].s64 = ctx.r[1].s64 + 1480;
	// 82A0CD48: 483F1B81  bl 0x82dfe8c8
	ctx.lr = 0x82A0CD4C;
	sub_82DFE8C8(ctx, base);
	// 82A0CD4C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A0CD50: D3A105D8  stfs f29, 0x5d8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1496 as u32), tmp.u32 ) };
	// 82A0CD54: 92E105D0  stw r23, 0x5d0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1488 as u32), ctx.r[23].u32 ) };
	// 82A0CD58: 396B85C4  addi r11, r11, -0x7a3c
	ctx.r[11].s64 = ctx.r[11].s64 + -31292;
	// 82A0CD5C: D3C105E0  stfs f30, 0x5e0(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1504 as u32), tmp.u32 ) };
	// 82A0CD60: D3E105E4  stfs f31, 0x5e4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1508 as u32), tmp.u32 ) };
	// 82A0CD64: 93E105DC  stw r31, 0x5dc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1500 as u32), ctx.r[31].u32 ) };
	// 82A0CD68: D3E105E8  stfs f31, 0x5e8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1512 as u32), tmp.u32 ) };
	// 82A0CD6C: 916105D4  stw r11, 0x5d4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1492 as u32), ctx.r[11].u32 ) };
	// 82A0CD70: 9BA105EC  stb r29, 0x5ec(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(1516 as u32), ctx.r[29].u8 ) };
	// 82A0CD74: 386105F0  addi r3, r1, 0x5f0
	ctx.r[3].s64 = ctx.r[1].s64 + 1520;
	// 82A0CD78: 483F1B51  bl 0x82dfe8c8
	ctx.lr = 0x82A0CD7C;
	sub_82DFE8C8(ctx, base);
	// 82A0CD7C: 386105F8  addi r3, r1, 0x5f8
	ctx.r[3].s64 = ctx.r[1].s64 + 1528;
	// 82A0CD80: 483F1B49  bl 0x82dfe8c8
	ctx.lr = 0x82A0CD84;
	sub_82DFE8C8(ctx, base);
	// 82A0CD84: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A0CD88: D3A10608  stfs f29, 0x608(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1544 as u32), tmp.u32 ) };
	// 82A0CD8C: 92C10600  stw r22, 0x600(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1536 as u32), ctx.r[22].u32 ) };
	// 82A0CD90: 396B85B4  addi r11, r11, -0x7a4c
	ctx.r[11].s64 = ctx.r[11].s64 + -31308;
	// 82A0CD94: D3C10610  stfs f30, 0x610(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1552 as u32), tmp.u32 ) };
	// 82A0CD98: D3E10614  stfs f31, 0x614(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1556 as u32), tmp.u32 ) };
	// 82A0CD9C: 93E1060C  stw r31, 0x60c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1548 as u32), ctx.r[31].u32 ) };
	// 82A0CDA0: D3E10618  stfs f31, 0x618(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1560 as u32), tmp.u32 ) };
	// 82A0CDA4: 91610604  stw r11, 0x604(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1540 as u32), ctx.r[11].u32 ) };
	// 82A0CDA8: 9BA1061C  stb r29, 0x61c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(1564 as u32), ctx.r[29].u8 ) };
	// 82A0CDAC: 38610620  addi r3, r1, 0x620
	ctx.r[3].s64 = ctx.r[1].s64 + 1568;
	// 82A0CDB0: 483F1B19  bl 0x82dfe8c8
	ctx.lr = 0x82A0CDB4;
	sub_82DFE8C8(ctx, base);
	// 82A0CDB4: 38610628  addi r3, r1, 0x628
	ctx.r[3].s64 = ctx.r[1].s64 + 1576;
	// 82A0CDB8: 483F1B11  bl 0x82dfe8c8
	ctx.lr = 0x82A0CDBC;
	sub_82DFE8C8(ctx, base);
	// 82A0CDBC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A0CDC0: 83C10068  lwz r30, 0x68(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A0CDC4: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A0CDC8: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	// 82A0CDCC: D3E10638  stfs f31, 0x638(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1592 as u32), tmp.u32 ) };
	// 82A0CDD0: 394A85AC  addi r10, r10, -0x7a54
	ctx.r[10].s64 = ctx.r[10].s64 + -31316;
	// 82A0CDD4: D3C10640  stfs f30, 0x640(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1600 as u32), tmp.u32 ) };
	// 82A0CDD8: D3E10648  stfs f31, 0x648(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1608 as u32), tmp.u32 ) };
	// 82A0CDDC: 9121063C  stw r9, 0x63c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1596 as u32), ctx.r[9].u32 ) };
	// 82A0CDE0: C00B9590  lfs f0, -0x6a70(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27248 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A0CDE4: 91410630  stw r10, 0x630(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1584 as u32), ctx.r[10].u32 ) };
	// 82A0CDE8: D0010644  stfs f0, 0x644(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1604 as u32), tmp.u32 ) };
	// 82A0CDEC: 93C10634  stw r30, 0x634(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1588 as u32), ctx.r[30].u32 ) };
	// 82A0CDF0: 9BA1064C  stb r29, 0x64c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(1612 as u32), ctx.r[29].u8 ) };
	// 82A0CDF4: 38610650  addi r3, r1, 0x650
	ctx.r[3].s64 = ctx.r[1].s64 + 1616;
	// 82A0CDF8: 483F1AD1  bl 0x82dfe8c8
	ctx.lr = 0x82A0CDFC;
	sub_82DFE8C8(ctx, base);
	// 82A0CDFC: 38610658  addi r3, r1, 0x658
	ctx.r[3].s64 = ctx.r[1].s64 + 1624;
	// 82A0CE00: 483F1AC9  bl 0x82dfe8c8
	ctx.lr = 0x82A0CE04;
	sub_82DFE8C8(ctx, base);
	// 82A0CE04: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A0CE08: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A0CE0C: D3A10668  stfs f29, 0x668(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1640 as u32), tmp.u32 ) };
	// 82A0CE10: D3C10670  stfs f30, 0x670(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1648 as u32), tmp.u32 ) };
	// 82A0CE14: 93C10664  stw r30, 0x664(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1636 as u32), ctx.r[30].u32 ) };
	// 82A0CE18: 394A85A0  addi r10, r10, -0x7a60
	ctx.r[10].s64 = ctx.r[10].s64 + -31328;
	// 82A0CE1C: D3E10678  stfs f31, 0x678(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1656 as u32), tmp.u32 ) };
	// 82A0CE20: 93E1066C  stw r31, 0x66c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1644 as u32), ctx.r[31].u32 ) };
	// 82A0CE24: 38610680  addi r3, r1, 0x680
	ctx.r[3].s64 = ctx.r[1].s64 + 1664;
	// 82A0CE28: C00B0A98  lfs f0, 0xa98(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2712 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A0CE2C: 91410660  stw r10, 0x660(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1632 as u32), ctx.r[10].u32 ) };
	// 82A0CE30: D0010674  stfs f0, 0x674(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1652 as u32), tmp.u32 ) };
	// 82A0CE34: 9BA1067C  stb r29, 0x67c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(1660 as u32), ctx.r[29].u8 ) };
	// 82A0CE38: 483F1A91  bl 0x82dfe8c8
	ctx.lr = 0x82A0CE3C;
	sub_82DFE8C8(ctx, base);
	// 82A0CE3C: 38610688  addi r3, r1, 0x688
	ctx.r[3].s64 = ctx.r[1].s64 + 1672;
	// 82A0CE40: 483F1A89  bl 0x82dfe8c8
	ctx.lr = 0x82A0CE44;
	sub_82DFE8C8(ctx, base);
	// 82A0CE44: 81C10088  lwz r14, 0x88(r1)
	ctx.r[14].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 82A0CE48: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A0CE4C: 7DC47378  mr r4, r14
	ctx.r[4].u64 = ctx.r[14].u64;
	// 82A0CE50: 38A00176  li r5, 0x176
	ctx.r[5].s64 = 374;
	// 82A0CE54: 38600140  li r3, 0x140
	ctx.r[3].s64 = 320;
	// 82A0CE58: 483E5591  bl 0x82df23e8
	ctx.lr = 0x82A0CE5C;
	sub_82DF23E8(ctx, base);
	// 82A0CE5C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A0CE60: 4182003C  beq 0x82a0ce9c
	if ctx.cr[0].eq {
	pc = 0x82A0CE9C; continue 'dispatch;
	}
	// 82A0CE64: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A0CE68: 80810070  lwz r4, 0x70(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82A0CE6C: 483E6B9D  bl 0x82df3a08
	ctx.lr = 0x82A0CE70;
	sub_82DF3A08(ctx, base);
	// 82A0CE70: 82C10844  lwz r22, 0x844(r1)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(2116 as u32) ) } as u64;
	// 82A0CE74: 386101F8  addi r3, r1, 0x1f8
	ctx.r[3].s64 = ctx.r[1].s64 + 504;
	// 82A0CE78: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 82A0CE7C: 3BC00003  li r30, 3
	ctx.r[30].s64 = 3;
	// 82A0CE80: 3B810054  addi r28, r1, 0x54
	ctx.r[28].s64 = ctx.r[1].s64 + 84;
	// 82A0CE84: 4BB02645  bl 0x8250f4c8
	ctx.lr = 0x82A0CE88;
	sub_8250F4C8(ctx, base);
	// 82A0CE88: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A0CE8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0CE90: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82A0CE94: 481A6D6D  bl 0x82bb3c00
	ctx.lr = 0x82A0CE98;
	sub_82BB3C00(ctx, base);
	// 82A0CE98: 48000010  b 0x82a0cea8
	pc = 0x82A0CEA8; continue 'dispatch;
	// 82A0CE9C: 82C10844  lwz r22, 0x844(r1)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(2116 as u32) ) } as u64;
	// 82A0CEA0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A0CEA4: 83C10078  lwz r30, 0x78(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 82A0CEA8: 3BF60150  addi r31, r22, 0x150
	ctx.r[31].s64 = ctx.r[22].s64 + 336;
	// 82A0CEAC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A0CEB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0CEB4: 4B95052D  bl 0x8235d3e0
	ctx.lr = 0x82A0CEB8;
	sub_8235D3E0(ctx, base);
	// 82A0CEB8: 57CB07BD  rlwinm. r11, r30, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A0CEBC: 41820010  beq 0x82a0cecc
	if ctx.cr[0].eq {
	pc = 0x82A0CECC; continue 'dispatch;
	}
	// 82A0CEC0: 386101F8  addi r3, r1, 0x1f8
	ctx.r[3].s64 = ctx.r[1].s64 + 504;
	// 82A0CEC4: 57DE07FA  rlwinm r30, r30, 0, 0x1f, 0x1d
	ctx.r[30].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 82A0CEC8: 483E4DC9  bl 0x82df1c90
	ctx.lr = 0x82A0CECC;
	sub_82DF1C90(ctx, base);
	// 82A0CECC: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A0CED0: 4182000C  beq 0x82a0cedc
	if ctx.cr[0].eq {
	pc = 0x82A0CEDC; continue 'dispatch;
	}
	// 82A0CED4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A0CED8: 483E6551  bl 0x82df3428
	ctx.lr = 0x82A0CEDC;
	sub_82DF3428(ctx, base);
	// 82A0CEDC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0CEE0: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82A0CEE4: 419A021C  beq cr6, 0x82a0d100
	if ctx.cr[6].eq {
	pc = 0x82A0D100; continue 'dispatch;
	}
	// 82A0CEE8: 38A00016  li r5, 0x16
	ctx.r[5].s64 = 22;
	// 82A0CEEC: 38810270  addi r4, r1, 0x270
	ctx.r[4].s64 = ctx.r[1].s64 + 624;
	// 82A0CEF0: 481A8071  bl 0x82bb4f60
	ctx.lr = 0x82A0CEF4;
	sub_82BB4F60(ctx, base);
	// 82A0CEF4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0CEF8: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0CEFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0CF00: 916100BC  stw r11, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[11].u32 ) };
	// 82A0CF04: 914100B8  stw r10, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[10].u32 ) };
	// 82A0CF08: 419A0024  beq cr6, 0x82a0cf2c
	if ctx.cr[6].eq {
	pc = 0x82A0CF2C; continue 'dispatch;
	}
	// 82A0CF0C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A0CF10: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A0CF14: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A0CF18: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A0CF1C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A0CF20: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A0CF24: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A0CF28: 4082FFE8  bne 0x82a0cf10
	if !ctx.cr[0].eq {
	pc = 0x82A0CF10; continue 'dispatch;
	}
	// 82A0CF2C: 388100B8  addi r4, r1, 0xb8
	ctx.r[4].s64 = ctx.r[1].s64 + 184;
	// 82A0CF30: 80760148  lwz r3, 0x148(r22)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(328 as u32) ) } as u64;
	// 82A0CF34: 4840803D  bl 0x82e14f70
	ctx.lr = 0x82A0CF38;
	sub_82E14F70(ctx, base);
	// 82A0CF38: 806100BC  lwz r3, 0xbc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82A0CF3C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0CF40: 419A0008  beq cr6, 0x82a0cf48
	if ctx.cr[6].eq {
	pc = 0x82A0CF48; continue 'dispatch;
	}
	// 82A0CF44: 4B8B394D  bl 0x822c0890
	ctx.lr = 0x82A0CF48;
	sub_822C0890(ctx, base);
	// 82A0CF48: 3B8101A0  addi r28, r1, 0x1a0
	ctx.r[28].s64 = ctx.r[1].s64 + 416;
	// 82A0CF4C: 3B600014  li r27, 0x14
	ctx.r[27].s64 = 20;
	// 82A0CF50: 83DC0000  lwz r30, 0(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0CF54: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A0CF58: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A0CF5C: 483E6AAD  bl 0x82df3a08
	ctx.lr = 0x82A0CF60;
	sub_82DF3A08(ctx, base);
	// 82A0CF60: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82A0CF64: 38610228  addi r3, r1, 0x228
	ctx.r[3].s64 = ctx.r[1].s64 + 552;
	// 82A0CF68: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0CF6C: 481A5C5D  bl 0x82bb2bc8
	ctx.lr = 0x82A0CF70;
	sub_82BB2BC8(ctx, base);
	// 82A0CF70: 3880000B  li r4, 0xb
	ctx.r[4].s64 = 11;
	// 82A0CF74: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0CF78: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82A0CF7C: 481AC77D  bl 0x82bb96f8
	ctx.lr = 0x82A0CF80;
	sub_82BB96F8(ctx, base);
	// 82A0CF80: 8061022C  lwz r3, 0x22c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(556 as u32) ) } as u64;
	// 82A0CF84: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0CF88: 419A0008  beq cr6, 0x82a0cf90
	if ctx.cr[6].eq {
	pc = 0x82A0CF90; continue 'dispatch;
	}
	// 82A0CF8C: 4B8B3905  bl 0x822c0890
	ctx.lr = 0x82A0CF90;
	sub_822C0890(ctx, base);
	// 82A0CF90: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A0CF94: 483E6495  bl 0x82df3428
	ctx.lr = 0x82A0CF98;
	sub_82DF3428(ctx, base);
	// 82A0CF98: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A0CF9C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0CFA0: 483E6A69  bl 0x82df3a08
	ctx.lr = 0x82A0CFA4;
	sub_82DF3A08(ctx, base);
	// 82A0CFA4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A0CFA8: 38610238  addi r3, r1, 0x238
	ctx.r[3].s64 = ctx.r[1].s64 + 568;
	// 82A0CFAC: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0CFB0: 481A5C19  bl 0x82bb2bc8
	ctx.lr = 0x82A0CFB4;
	sub_82BB2BC8(ctx, base);
	// 82A0CFB4: 3880000C  li r4, 0xc
	ctx.r[4].s64 = 12;
	// 82A0CFB8: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0CFBC: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82A0CFC0: 481AC739  bl 0x82bb96f8
	ctx.lr = 0x82A0CFC4;
	sub_82BB96F8(ctx, base);
	// 82A0CFC4: 8061023C  lwz r3, 0x23c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(572 as u32) ) } as u64;
	// 82A0CFC8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0CFCC: 419A0008  beq cr6, 0x82a0cfd4
	if ctx.cr[6].eq {
	pc = 0x82A0CFD4; continue 'dispatch;
	}
	// 82A0CFD0: 4B8B38C1  bl 0x822c0890
	ctx.lr = 0x82A0CFD4;
	sub_822C0890(ctx, base);
	// 82A0CFD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0CFD8: 483E6451  bl 0x82df3428
	ctx.lr = 0x82A0CFDC;
	sub_82DF3428(ctx, base);
	// 82A0CFDC: 377BFFFF  addic. r27, r27, -1
	ctx.xer.ca = (ctx.r[27].u32 > (!(-1 as u32)));
	ctx.r[27].s64 = ctx.r[27].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 82A0CFE0: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 82A0CFE4: 4082FF6C  bne 0x82a0cf50
	if !ctx.cr[0].eq {
	pc = 0x82A0CF50; continue 'dispatch;
	}
	// 82A0CFE8: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 82A0CFEC: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82A0CFF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0CFF4: 483E6A15  bl 0x82df3a08
	ctx.lr = 0x82A0CFF8;
	sub_82DF3A08(ctx, base);
	// 82A0CFF8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A0CFFC: 38610248  addi r3, r1, 0x248
	ctx.r[3].s64 = ctx.r[1].s64 + 584;
	// 82A0D000: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0D004: 481A5BC5  bl 0x82bb2bc8
	ctx.lr = 0x82A0D008;
	sub_82BB2BC8(ctx, base);
	// 82A0D008: 7FC40734  extsh r4, r30
	ctx.r[4].s64 = ctx.r[30].s16 as i64;
	// 82A0D00C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0D010: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82A0D014: 481AC6E5  bl 0x82bb96f8
	ctx.lr = 0x82A0D018;
	sub_82BB96F8(ctx, base);
	// 82A0D018: 8061024C  lwz r3, 0x24c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(588 as u32) ) } as u64;
	// 82A0D01C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0D020: 419A0008  beq cr6, 0x82a0d028
	if ctx.cr[6].eq {
	pc = 0x82A0D028; continue 'dispatch;
	}
	// 82A0D024: 4B8B386D  bl 0x822c0890
	ctx.lr = 0x82A0D028;
	sub_822C0890(ctx, base);
	// 82A0D028: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0D02C: 483E63FD  bl 0x82df3428
	ctx.lr = 0x82A0D030;
	sub_82DF3428(ctx, base);
	// 82A0D030: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82A0D034: 2F1E000E  cmpwi cr6, r30, 0xe
	ctx.cr[6].compare_i32(ctx.r[30].s32, 14, &mut ctx.xer);
	// 82A0D038: 4198FFB4  blt cr6, 0x82a0cfec
	if ctx.cr[6].lt {
	pc = 0x82A0CFEC; continue 'dispatch;
	}
	// 82A0D03C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82A0D040: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0D044: 483E69C5  bl 0x82df3a08
	ctx.lr = 0x82A0D048;
	sub_82DF3A08(ctx, base);
	// 82A0D048: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A0D04C: 38610260  addi r3, r1, 0x260
	ctx.r[3].s64 = ctx.r[1].s64 + 608;
	// 82A0D050: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0D054: 481A5B75  bl 0x82bb2bc8
	ctx.lr = 0x82A0D058;
	sub_82BB2BC8(ctx, base);
	// 82A0D058: 3880000B  li r4, 0xb
	ctx.r[4].s64 = 11;
	// 82A0D05C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0D060: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 82A0D064: 481AC695  bl 0x82bb96f8
	ctx.lr = 0x82A0D068;
	sub_82BB96F8(ctx, base);
	// 82A0D068: 80610264  lwz r3, 0x264(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(612 as u32) ) } as u64;
	// 82A0D06C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0D070: 419A0008  beq cr6, 0x82a0d078
	if ctx.cr[6].eq {
	pc = 0x82A0D078; continue 'dispatch;
	}
	// 82A0D074: 4B8B381D  bl 0x822c0890
	ctx.lr = 0x82A0D078;
	sub_822C0890(ctx, base);
	// 82A0D078: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0D07C: 483E63AD  bl 0x82df3428
	ctx.lr = 0x82A0D080;
	sub_82DF3428(ctx, base);
	// 82A0D080: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82A0D084: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0D088: 483E6981  bl 0x82df3a08
	ctx.lr = 0x82A0D08C;
	sub_82DF3A08(ctx, base);
	// 82A0D08C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A0D090: 38610258  addi r3, r1, 0x258
	ctx.r[3].s64 = ctx.r[1].s64 + 600;
	// 82A0D094: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0D098: 481A5B31  bl 0x82bb2bc8
	ctx.lr = 0x82A0D09C;
	sub_82BB2BC8(ctx, base);
	// 82A0D09C: 3880000C  li r4, 0xc
	ctx.r[4].s64 = 12;
	// 82A0D0A0: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0D0A4: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 82A0D0A8: 481AC651  bl 0x82bb96f8
	ctx.lr = 0x82A0D0AC;
	sub_82BB96F8(ctx, base);
	// 82A0D0AC: 8061025C  lwz r3, 0x25c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(604 as u32) ) } as u64;
	// 82A0D0B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0D0B4: 419A0008  beq cr6, 0x82a0d0bc
	if ctx.cr[6].eq {
	pc = 0x82A0D0BC; continue 'dispatch;
	}
	// 82A0D0B8: 4B8B37D9  bl 0x822c0890
	ctx.lr = 0x82A0D0BC;
	sub_822C0890(ctx, base);
	// 82A0D0BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0D0C0: 483E6369  bl 0x82df3428
	ctx.lr = 0x82A0D0C4;
	sub_82DF3428(ctx, base);
	// 82A0D0C4: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82A0D0C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0D0CC: 483E693D  bl 0x82df3a08
	ctx.lr = 0x82A0D0D0;
	sub_82DF3A08(ctx, base);
	// 82A0D0D0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82A0D0D4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A0D0D8: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0D0DC: 38610208  addi r3, r1, 0x208
	ctx.r[3].s64 = ctx.r[1].s64 + 520;
	// 82A0D0E0: C02B6150  lfs f1, 0x6150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A0D0E4: 481A5C75  bl 0x82bb2d58
	ctx.lr = 0x82A0D0E8;
	sub_82BB2D58(ctx, base);
	// 82A0D0E8: 8061020C  lwz r3, 0x20c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(524 as u32) ) } as u64;
	// 82A0D0EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0D0F0: 419A0008  beq cr6, 0x82a0d0f8
	if ctx.cr[6].eq {
	pc = 0x82A0D0F8; continue 'dispatch;
	}
	// 82A0D0F4: 4B8B379D  bl 0x822c0890
	ctx.lr = 0x82A0D0F8;
	sub_822C0890(ctx, base);
	// 82A0D0F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0D0FC: 483E632D  bl 0x82df3428
	ctx.lr = 0x82A0D100;
	sub_82DF3428(ctx, base);
	// 82A0D100: 81E10058  lwz r15, 0x58(r1)
	ctx.r[15].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A0D104: 82010854  lwz r16, 0x854(r1)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(2132 as u32) ) } as u64;
	// 82A0D108: 81760148  lwz r11, 0x148(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(328 as u32) ) } as u64;
	// 82A0D10C: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A0D110: 483F16D1  bl 0x82dfe7e0
	ctx.lr = 0x82A0D114;
	sub_82DFE7E0(ctx, base);
	// 82A0D114: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A0D118: 41820010  beq 0x82a0d128
	if ctx.cr[0].eq {
	pc = 0x82A0D128; continue 'dispatch;
	}
	// 82A0D11C: 80760150  lwz r3, 0x150(r22)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(336 as u32) ) } as u64;
	// 82A0D120: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82A0D124: 481A83CD  bl 0x82bb54f0
	ctx.lr = 0x82A0D128;
	sub_82BB54F0(ctx, base);
	// 82A0D128: 3FE08335  lis r31, -0x7ccb
	ctx.r[31].s64 = -2093678592;
	// 82A0D12C: 3FC08335  lis r30, -0x7ccb
	ctx.r[30].s64 = -2093678592;
	// 82A0D130: 3F808335  lis r28, -0x7ccb
	ctx.r[28].s64 = -2093678592;
	// 82A0D134: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A0D138: 80DF6838  lwz r6, 0x6838(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(26680 as u32) ) } as u64;
	// 82A0D13C: 80BE6840  lwz r5, 0x6840(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(26688 as u32) ) } as u64;
	// 82A0D140: 809C6784  lwz r4, 0x6784(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(26500 as u32) ) } as u64;
	// 82A0D144: 4B8EA6D5  bl 0x822f7818
	ctx.lr = 0x82A0D148;
	sub_822F7818(ctx, base);
	// 82A0D148: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82A0D14C: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82A0D150: 3F608335  lis r27, -0x7ccb
	ctx.r[27].s64 = -2093678592;
	// 82A0D154: 3F408335  lis r26, -0x7ccb
	ctx.r[26].s64 = -2093678592;
	// 82A0D158: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82A0D15C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A0D160: 80EB6890  lwz r7, 0x6890(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26768 as u32) ) } as u64;
	// 82A0D164: 808A6874  lwz r4, 0x6874(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(26740 as u32) ) } as u64;
	// 82A0D168: 80DB67C0  lwz r6, 0x67c0(r27)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(26560 as u32) ) } as u64;
	// 82A0D16C: 80BA67D4  lwz r5, 0x67d4(r26)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(26580 as u32) ) } as u64;
	// 82A0D170: 4B8E1C59  bl 0x822eedc8
	ctx.lr = 0x82A0D174;
	sub_822EEDC8(ctx, base);
	// 82A0D174: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82A0D178: E8990000  ld r4, 0(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) };
	// 82A0D17C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A0D180: E8630000  ld r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 82A0D184: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A0D188: 4BA7F101  bl 0x8248c288
	ctx.lr = 0x82A0D18C;
	sub_8248C288(ctx, base);
	// 82A0D18C: 7C741B78  mr r20, r3
	ctx.r[20].u64 = ctx.r[3].u64;
	// 82A0D190: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A0D194: 80DF6838  lwz r6, 0x6838(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(26680 as u32) ) } as u64;
	// 82A0D198: 80BE6840  lwz r5, 0x6840(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(26688 as u32) ) } as u64;
	// 82A0D19C: 809C6784  lwz r4, 0x6784(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(26500 as u32) ) } as u64;
	// 82A0D1A0: 4B8EA679  bl 0x822f7818
	ctx.lr = 0x82A0D1A4;
	sub_822F7818(ctx, base);
	// 82A0D1A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A0D1A8: 80BB67C0  lwz r5, 0x67c0(r27)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(26560 as u32) ) } as u64;
	// 82A0D1AC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A0D1B0: 809A67D4  lwz r4, 0x67d4(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(26580 as u32) ) } as u64;
	// 82A0D1B4: 4B8EA5ED  bl 0x822f77a0
	ctx.lr = 0x82A0D1B8;
	sub_822F77A0(ctx, base);
	// 82A0D1B8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82A0D1BC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A0D1C0: E89F0000  ld r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	// 82A0D1C4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A0D1C8: E8630000  ld r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 82A0D1CC: 4BA7F0BD  bl 0x8248c288
	ctx.lr = 0x82A0D1D0;
	sub_8248C288(ctx, base);
	// 82A0D1D0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82A0D1D4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82A0D1D8: 834D0000  lwz r26, 0(r13)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0D1DC: 3D00820B  lis r8, -0x7df5
	ctx.r[8].s64 = -2113208320;
	// 82A0D1E0: D3A10180  stfs f29, 0x180(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(384 as u32), tmp.u32 ) };
	// 82A0D1E4: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 82A0D1E8: D3A1018C  stfs f29, 0x18c(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(396 as u32), tmp.u32 ) };
	// 82A0D1EC: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82A0D1F0: D3C10114  stfs f30, 0x114(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 82A0D1F4: C00BACFC  lfs f0, -0x5304(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-21252 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A0D1F8: 39688598  addi r11, r8, -0x7a68
	ctx.r[11].s64 = ctx.r[8].s64 + -31336;
	// 82A0D1FC: C1AAC664  lfs f13, -0x399c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-14748 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A0D200: 3CC08202  lis r6, -0x7dfe
	ctx.r[6].s64 = -2113798144;
	// 82A0D204: 91610124  stw r11, 0x124(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(292 as u32), ctx.r[11].u32 ) };
	// 82A0D208: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82A0D20C: 3D008209  lis r8, -0x7df7
	ctx.r[8].s64 = -2113339392;
	// 82A0D210: C1879524  lfs f12, -0x6adc(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A0D214: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A0D218: D1810148  stfs f12, 0x148(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(328 as u32), tmp.u32 ) };
	// 82A0D21C: 39298590  addi r9, r9, -0x7a70
	ctx.r[9].s64 = ctx.r[9].s64 + -31344;
	// 82A0D220: D181014C  stfs f12, 0x14c(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(332 as u32), tmp.u32 ) };
	// 82A0D224: 38E659C4  addi r7, r6, 0x59c4
	ctx.r[7].s64 = ctx.r[6].s64 + 22980;
	// 82A0D228: D0010184  stfs f0, 0x184(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 82A0D22C: 394A7868  addi r10, r10, 0x7868
	ctx.r[10].s64 = ctx.r[10].s64 + 30824;
	// 82A0D230: 91210120  stw r9, 0x120(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(288 as u32), ctx.r[9].u32 ) };
	// 82A0D234: 39088F7C  addi r8, r8, -0x7084
	ctx.r[8].s64 = ctx.r[8].s64 + -28804;
	// 82A0D238: D0010188  stfs f0, 0x188(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 82A0D23C: C18BD1B8  lfs f12, -0x2e48(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11848 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A0D240: 3B200014  li r25, 0x14
	ctx.r[25].s64 = 20;
	// 82A0D244: D1A10190  stfs f13, 0x190(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(400 as u32), tmp.u32 ) };
	// 82A0D248: 3D208202  lis r9, -0x7dfe
	ctx.r[9].s64 = -2113798144;
	// 82A0D24C: D0010140  stfs f0, 0x140(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(320 as u32), tmp.u32 ) };
	// 82A0D250: 3CC08201  lis r6, -0x7dff
	ctx.r[6].s64 = -2113863680;
	// 82A0D254: D0010144  stfs f0, 0x144(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(324 as u32), tmp.u32 ) };
	// 82A0D258: 91410128  stw r10, 0x128(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(296 as u32), ctx.r[10].u32 ) };
	// 82A0D25C: D1A1016C  stfs f13, 0x16c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(364 as u32), tmp.u32 ) };
	// 82A0D260: 9101012C  stw r8, 0x12c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(300 as u32), ctx.r[8].u32 ) };
	// 82A0D264: D3C10118  stfs f30, 0x118(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(280 as u32), tmp.u32 ) };
	// 82A0D268: 90E10130  stw r7, 0x130(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(304 as u32), ctx.r[7].u32 ) };
	// 82A0D26C: C00929EC  lfs f0, 0x29ec(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(10732 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A0D270: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 82A0D274: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82A0D278: C1A60A90  lfs f13, 0xa90(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(2704 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A0D27C: 3CE08203  lis r7, -0x7dfd
	ctx.r[7].s64 = -2113732608;
	// 82A0D280: D1810150  stfs f12, 0x150(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(336 as u32), tmp.u32 ) };
	// 82A0D284: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82A0D288: D0010160  stfs f0, 0x160(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(352 as u32), tmp.u32 ) };
	// 82A0D28C: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82A0D290: D0010164  stfs f0, 0x164(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(356 as u32), tmp.u32 ) };
	// 82A0D294: C36989AC  lfs f27, -0x7654(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82A0D298: 3B160160  addi r24, r22, 0x160
	ctx.r[24].s64 = ctx.r[22].s64 + 352;
	// 82A0D29C: C3889528  lfs f28, -0x6ad8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82A0D2A0: 7FBBEB78  mr r27, r29
	ctx.r[27].u64 = ctx.r[29].u64;
	// 82A0D2A4: C3A77BC4  lfs f29, 0x7bc4(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(31684 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82A0D2A8: 3AA00040  li r21, 0x40
	ctx.r[21].s64 = 64;
	// 82A0D2AC: D1A10168  stfs f13, 0x168(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(360 as u32), tmp.u32 ) };
	// 82A0D2B0: 3E408335  lis r18, -0x7ccb
	ctx.r[18].s64 = -2093678592;
	// 82A0D2B4: D1A10170  stfs f13, 0x170(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(368 as u32), tmp.u32 ) };
	// 82A0D2B8: 3A2BB334  addi r17, r11, -0x4ccc
	ctx.r[17].s64 = ctx.r[11].s64 + -19660;
	// 82A0D2BC: D3C1011C  stfs f30, 0x11c(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(284 as u32), tmp.u32 ) };
	// 82A0D2C0: 3A6A6910  addi r19, r10, 0x6910
	ctx.r[19].s64 = ctx.r[10].s64 + 26896;
	// 82A0D2C4: D3C10104  stfs f30, 0x104(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 82A0D2C8: D3C10108  stfs f30, 0x108(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 82A0D2CC: D3C1010C  stfs f30, 0x10c(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 82A0D2D0: 39610160  addi r11, r1, 0x160
	ctx.r[11].s64 = ctx.r[1].s64 + 352;
	// 82A0D2D4: 7C79D02E  lwzx r3, r25, r26
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 82A0D2D8: 39210140  addi r9, r1, 0x140
	ctx.r[9].s64 = ctx.r[1].s64 + 320;
	// 82A0D2DC: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 82A0D2E0: 39010100  addi r8, r1, 0x100
	ctx.r[8].s64 = ctx.r[1].s64 + 256;
	// 82A0D2E4: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82A0D2E8: 39410110  addi r10, r1, 0x110
	ctx.r[10].s64 = ctx.r[1].s64 + 272;
	// 82A0D2EC: 38E106A0  addi r7, r1, 0x6a0
	ctx.r[7].s64 = ctx.r[1].s64 + 1696;
	// 82A0D2F0: 7C1B5C2E  lfsx f0, r27, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A0D2F4: 39610690  addi r11, r1, 0x690
	ctx.r[11].s64 = ctx.r[1].s64 + 1680;
	// 82A0D2F8: 7DBB4C2E  lfsx f13, r27, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A0D2FC: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 82A0D300: D0010110  stfs f0, 0x110(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 82A0D304: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82A0D308: D0010100  stfs f0, 0x100(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 82A0D30C: 38800040  li r4, 0x40
	ctx.r[4].s64 = 64;
	// 82A0D310: 13C040C7  vcmpequd (lvx128) v30, v0, v8
	tmp.u32 = ctx.r[8].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A0D314: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0D9C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A0D9C8 size=76
    let mut pc: u32 = 0x82A0D9C8;
    'dispatch: loop {
        match pc {
            0x82A0D9C8 => {
    //   block [0x82A0D9C8..0x82A0DA14)
	// 82A0D9C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0D9CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A0D9D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A0D9D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A0D9D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0D9DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A0D9E0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A0D9E4: 4844EF45  bl 0x82e5c928
	ctx.lr = 0x82A0D9E8;
	sub_82E5C928(ctx, base);
	// 82A0D9E8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A0D9EC: 9BDF0060  stb r30, 0x60(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[30].u8 ) };
	// 82A0D9F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0D9F4: 396B87E4  addi r11, r11, -0x781c
	ctx.r[11].s64 = ctx.r[11].s64 + -30748;
	// 82A0D9F8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A0D9FC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A0DA00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0DA04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A0DA08: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A0DA0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A0DA10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0DA18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A0DA18 size=116
    let mut pc: u32 = 0x82A0DA18;
    'dispatch: loop {
        match pc {
            0x82A0DA18 => {
    //   block [0x82A0DA18..0x82A0DA8C)
	// 82A0DA18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0DA1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A0DA20: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A0DA24: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0DA28: 48746BD9  bl 0x83154600
	ctx.lr = 0x82A0DA2C;
	sub_83154600(ctx, base);
	// 82A0DA2C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A0DA30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A0DA34: 388B1CEC  addi r4, r11, 0x1cec
	ctx.r[4].s64 = ctx.r[11].s64 + 7404;
	// 82A0DA38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0DA3C: 483E5FCD  bl 0x82df3a08
	ctx.lr = 0x82A0DA40;
	sub_82DF3A08(ctx, base);
	// 82A0DA40: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A0DA44: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A0DA48: 809F0150  lwz r4, 0x150(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) } as u64;
	// 82A0DA4C: 481A517D  bl 0x82bb2bc8
	ctx.lr = 0x82A0DA50;
	sub_82BB2BC8(ctx, base);
	// 82A0DA50: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A0DA54: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0DA58: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A0DA5C: 481AB015  bl 0x82bb8a70
	ctx.lr = 0x82A0DA60;
	sub_82BB8A70(ctx, base);
	// 82A0DA60: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A0DA64: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0DA68: 419A0008  beq cr6, 0x82a0da70
	if ctx.cr[6].eq {
	pc = 0x82A0DA70; continue 'dispatch;
	}
	// 82A0DA6C: 4B8B2E25  bl 0x822c0890
	ctx.lr = 0x82A0DA70;
	sub_822C0890(ctx, base);
	// 82A0DA70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0DA74: 483E59B5  bl 0x82df3428
	ctx.lr = 0x82A0DA78;
	sub_82DF3428(ctx, base);
	// 82A0DA78: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A0DA7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0DA80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A0DA84: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A0DA88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0DA90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A0DA90 size=408
    let mut pc: u32 = 0x82A0DA90;
    'dispatch: loop {
        match pc {
            0x82A0DA90 => {
    //   block [0x82A0DA90..0x82A0DC28)
	// 82A0DA90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0DA94: 4879A6D9  bl 0x831a816c
	ctx.lr = 0x82A0DA98;
	sub_831A8130(ctx, base);
	// 82A0DA98: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82A0DA9C: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0DAA0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A0DAA4: 48746B5D  bl 0x83154600
	ctx.lr = 0x82A0DAA8;
	sub_83154600(ctx, base);
	// 82A0DAA8: 897D0060  lbz r11, 0x60(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(96 as u32) ) } as u64;
	// 82A0DAAC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A0DAB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0DAB4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A0DAB8: 4182007C  beq 0x82a0db34
	if ctx.cr[0].eq {
	pc = 0x82A0DB34; continue 'dispatch;
	}
	// 82A0DABC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A0DAC0: 3BCB1CEC  addi r30, r11, 0x1cec
	ctx.r[30].s64 = ctx.r[11].s64 + 7404;
	// 82A0DAC4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A0DAC8: 483E5F41  bl 0x82df3a08
	ctx.lr = 0x82A0DACC;
	sub_82DF3A08(ctx, base);
	// 82A0DACC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A0DAD0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A0DAD4: 809F0150  lwz r4, 0x150(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) } as u64;
	// 82A0DAD8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A0DADC: C04B08A4  lfs f2, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82A0DAE0: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 82A0DAE4: 481A5895  bl 0x82bb3378
	ctx.lr = 0x82A0DAE8;
	sub_82BB3378(ctx, base);
	// 82A0DAE8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A0DAEC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0DAF0: 419A0008  beq cr6, 0x82a0daf8
	if ctx.cr[6].eq {
	pc = 0x82A0DAF8; continue 'dispatch;
	}
	// 82A0DAF4: 4B8B2D9D  bl 0x822c0890
	ctx.lr = 0x82A0DAF8;
	sub_822C0890(ctx, base);
	// 82A0DAF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0DAFC: 483E592D  bl 0x82df3428
	ctx.lr = 0x82A0DB00;
	sub_82DF3428(ctx, base);
	// 82A0DB00: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A0DB04: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0DB08: 483E5F01  bl 0x82df3a08
	ctx.lr = 0x82A0DB0C;
	sub_82DF3A08(ctx, base);
	// 82A0DB0C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A0DB10: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A0DB14: 809F0150  lwz r4, 0x150(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) } as u64;
	// 82A0DB18: 481A50B1  bl 0x82bb2bc8
	ctx.lr = 0x82A0DB1C;
	sub_82BB2BC8(ctx, base);
	// 82A0DB1C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A0DB20: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0DB24: C02B9528  lfs f1, -0x6ad8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A0DB28: 481AAF49  bl 0x82bb8a70
	ctx.lr = 0x82A0DB2C;
	sub_82BB8A70(ctx, base);
	// 82A0DB2C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A0DB30: 48000078  b 0x82a0dba8
	pc = 0x82A0DBA8; continue 'dispatch;
	// 82A0DB34: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A0DB38: 3BCB85A0  addi r30, r11, -0x7a60
	ctx.r[30].s64 = ctx.r[11].s64 + -31328;
	// 82A0DB3C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A0DB40: 483E5EC9  bl 0x82df3a08
	ctx.lr = 0x82A0DB44;
	sub_82DF3A08(ctx, base);
	// 82A0DB44: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A0DB48: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A0DB4C: 809F0150  lwz r4, 0x150(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) } as u64;
	// 82A0DB50: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A0DB54: C04B08A4  lfs f2, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82A0DB58: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 82A0DB5C: 481A581D  bl 0x82bb3378
	ctx.lr = 0x82A0DB60;
	sub_82BB3378(ctx, base);
	// 82A0DB60: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A0DB64: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0DB68: 419A0008  beq cr6, 0x82a0db70
	if ctx.cr[6].eq {
	pc = 0x82A0DB70; continue 'dispatch;
	}
	// 82A0DB6C: 4B8B2D25  bl 0x822c0890
	ctx.lr = 0x82A0DB70;
	sub_822C0890(ctx, base);
	// 82A0DB70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0DB74: 483E58B5  bl 0x82df3428
	ctx.lr = 0x82A0DB78;
	sub_82DF3428(ctx, base);
	// 82A0DB78: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A0DB7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0DB80: 483E5E89  bl 0x82df3a08
	ctx.lr = 0x82A0DB84;
	sub_82DF3A08(ctx, base);
	// 82A0DB84: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A0DB88: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A0DB8C: 809F0150  lwz r4, 0x150(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) } as u64;
	// 82A0DB90: 481A5039  bl 0x82bb2bc8
	ctx.lr = 0x82A0DB94;
	sub_82BB2BC8(ctx, base);
	// 82A0DB94: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A0DB98: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0DB9C: C02B9528  lfs f1, -0x6ad8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A0DBA0: 481AAED1  bl 0x82bb8a70
	ctx.lr = 0x82A0DBA4;
	sub_82BB8A70(ctx, base);
	// 82A0DBA4: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A0DBA8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0DBAC: 419A0008  beq cr6, 0x82a0dbb4
	if ctx.cr[6].eq {
	pc = 0x82A0DBB4; continue 'dispatch;
	}
	// 82A0DBB0: 4B8B2CE1  bl 0x822c0890
	ctx.lr = 0x82A0DBB4;
	sub_822C0890(ctx, base);
	// 82A0DBB4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0DBB8: 483E5871  bl 0x82df3428
	ctx.lr = 0x82A0DBBC;
	sub_82DF3428(ctx, base);
	// 82A0DBBC: 897D0060  lbz r11, 0x60(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(96 as u32) ) } as u64;
	// 82A0DBC0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A0DBC4: 4182004C  beq 0x82a0dc10
	if ctx.cr[0].eq {
	pc = 0x82A0DC10; continue 'dispatch;
	}
	// 82A0DBC8: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A0DBCC: 4BADCEBD  bl 0x824eaa88
	ctx.lr = 0x82A0DBD0;
	sub_824EAA88(ctx, base);
	// 82A0DBD0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A0DBD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0DBD8: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0DBDC: 4BB017ED  bl 0x8250f3c8
	ctx.lr = 0x82A0DBE0;
	sub_8250F3C8(ctx, base);
	// 82A0DBE0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A0DBE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0DBE8: 4BADD429  bl 0x824eb010
	ctx.lr = 0x82A0DBEC;
	sub_824EB010(ctx, base);
	// 82A0DBEC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A0DBF0: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82A0DBF4: 483E409D  bl 0x82df1c90
	ctx.lr = 0x82A0DBF8;
	sub_82DF1C90(ctx, base);
	// 82A0DBF8: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 82A0DBFC: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82A0DC00: C00B7BC4  lfs f0, 0x7bc4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31684 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A0DC04: C1AA9450  lfs f13, -0x6bb0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A0DC08: EC1F683A  fmadds f0, f31, f0, f13
	ctx.f[0].f64 = (((ctx.f[31].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82A0DC0C: 4800000C  b 0x82a0dc18
	pc = 0x82A0DC18; continue 'dispatch;
	// 82A0DC10: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A0DC14: C00B08A8  lfs f0, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A0DC18: D01D0064  stfs f0, 0x64(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82A0DC1C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A0DC20: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82A0DC24: 4879A598  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0DC28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A0DC28 size=496
    let mut pc: u32 = 0x82A0DC28;
    'dispatch: loop {
        match pc {
            0x82A0DC28 => {
    //   block [0x82A0DC28..0x82A0DE18)
	// 82A0DC28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0DC2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A0DC30: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A0DC34: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A0DC38: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82A0DC3C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0DC40: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A0DC44: 487469BD  bl 0x83154600
	ctx.lr = 0x82A0DC48;
	sub_83154600(ctx, base);
	// 82A0DC48: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A0DC4C: C01F0064  lfs f0, 0x64(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A0DC50: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A0DC54: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A0DC58: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82A0DC5C: 409900A8  ble cr6, 0x82a0dd04
	if !ctx.cr[6].gt {
	pc = 0x82A0DD04; continue 'dispatch;
	}
	// 82A0DC60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0DC64: 4844BB15  bl 0x82e59778
	ctx.lr = 0x82A0DC68;
	sub_82E59778(ctx, base);
	// 82A0DC68: C01F0064  lfs f0, 0x64(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A0DC6C: EC000828  fsubs f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 82A0DC70: D01F0064  stfs f0, 0x64(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82A0DC74: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82A0DC78: 4199008C  bgt cr6, 0x82a0dd04
	if ctx.cr[6].gt {
	pc = 0x82A0DD04; continue 'dispatch;
	}
	// 82A0DC7C: 897F0060  lbz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82A0DC80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0DC84: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A0DC88: 41820038  beq 0x82a0dcc0
	if ctx.cr[0].eq {
	pc = 0x82A0DCC0; continue 'dispatch;
	}
	// 82A0DC8C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A0DC90: 388B1CEC  addi r4, r11, 0x1cec
	ctx.r[4].s64 = ctx.r[11].s64 + 7404;
	// 82A0DC94: 483E5D75  bl 0x82df3a08
	ctx.lr = 0x82A0DC98;
	sub_82DF3A08(ctx, base);
	// 82A0DC98: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A0DC9C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A0DCA0: 809E0150  lwz r4, 0x150(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(336 as u32) ) } as u64;
	// 82A0DCA4: 481A4F25  bl 0x82bb2bc8
	ctx.lr = 0x82A0DCA8;
	sub_82BB2BC8(ctx, base);
	// 82A0DCA8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A0DCAC: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0DCB0: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A0DCB4: 481AADBD  bl 0x82bb8a70
	ctx.lr = 0x82A0DCB8;
	sub_82BB8A70(ctx, base);
	// 82A0DCB8: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A0DCBC: 48000034  b 0x82a0dcf0
	pc = 0x82A0DCF0; continue 'dispatch;
	// 82A0DCC0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A0DCC4: 388B85A0  addi r4, r11, -0x7a60
	ctx.r[4].s64 = ctx.r[11].s64 + -31328;
	// 82A0DCC8: 483E5D41  bl 0x82df3a08
	ctx.lr = 0x82A0DCCC;
	sub_82DF3A08(ctx, base);
	// 82A0DCCC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A0DCD0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A0DCD4: 809E0150  lwz r4, 0x150(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(336 as u32) ) } as u64;
	// 82A0DCD8: 481A4EF1  bl 0x82bb2bc8
	ctx.lr = 0x82A0DCDC;
	sub_82BB2BC8(ctx, base);
	// 82A0DCDC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A0DCE0: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0DCE4: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A0DCE8: 481AAD89  bl 0x82bb8a70
	ctx.lr = 0x82A0DCEC;
	sub_82BB8A70(ctx, base);
	// 82A0DCEC: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A0DCF0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0DCF4: 419A0008  beq cr6, 0x82a0dcfc
	if ctx.cr[6].eq {
	pc = 0x82A0DCFC; continue 'dispatch;
	}
	// 82A0DCF8: 4B8B2B99  bl 0x822c0890
	ctx.lr = 0x82A0DCFC;
	sub_822C0890(ctx, base);
	// 82A0DCFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0DD00: 483E5729  bl 0x82df3428
	ctx.lr = 0x82A0DD04;
	sub_82DF3428(ctx, base);
	// 82A0DD04: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82A0DD08: 807E0150  lwz r3, 0x150(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(336 as u32) ) } as u64;
	// 82A0DD0C: C02B6150  lfs f1, 0x6150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A0DD10: 4819FEE9  bl 0x82badbf8
	ctx.lr = 0x82A0DD14;
	sub_82BADBF8(ctx, base);
	// 82A0DD14: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A0DD18: 418200E4  beq 0x82a0ddfc
	if ctx.cr[0].eq {
	pc = 0x82A0DDFC; continue 'dispatch;
	}
	// 82A0DD1C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A0DD20: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A0DD24: 388B8808  addi r4, r11, -0x77f8
	ctx.r[4].s64 = ctx.r[11].s64 + -30712;
	// 82A0DD28: 38A00057  li r5, 0x57
	ctx.r[5].s64 = 87;
	// 82A0DD2C: 3860006C  li r3, 0x6c
	ctx.r[3].s64 = 108;
	// 82A0DD30: 483E46B9  bl 0x82df23e8
	ctx.lr = 0x82A0DD34;
	sub_82DF23E8(ctx, base);
	// 82A0DD34: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A0DD38: 4182001C  beq 0x82a0dd54
	if ctx.cr[0].eq {
	pc = 0x82A0DD54; continue 'dispatch;
	}
	// 82A0DD3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0DD40: 4844EBE9  bl 0x82e5c928
	ctx.lr = 0x82A0DD44;
	sub_82E5C928(ctx, base);
	// 82A0DD44: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A0DD48: 396B844C  addi r11, r11, -0x7bb4
	ctx.r[11].s64 = ctx.r[11].s64 + -31668;
	// 82A0DD4C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A0DD50: 48000008  b 0x82a0dd58
	pc = 0x82A0DD58; continue 'dispatch;
	// 82A0DD54: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A0DD58: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82A0DD5C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0DD60: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A0DD64: 4BFFD4A5  bl 0x82a0b208
	ctx.lr = 0x82A0DD68;
	sub_82A0B208(ctx, base);
	// 82A0DD68: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A0DD6C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0DD70: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A0DD74: 4B8B228D  bl 0x822c0000
	ctx.lr = 0x82A0DD78;
	sub_822C0000(ctx, base);
	// 82A0DD78: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A0DD7C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A0DD80: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A0DD84: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82A0DD88: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A0DD8C: 419A0024  beq cr6, 0x82a0ddb0
	if ctx.cr[6].eq {
	pc = 0x82A0DDB0; continue 'dispatch;
	}
	// 82A0DD90: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82A0DD94: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A0DD98: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A0DD9C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A0DDA0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A0DDA4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A0DDA8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A0DDAC: 4082FFE8  bne 0x82a0dd94
	if !ctx.cr[0].eq {
	pc = 0x82A0DD94; continue 'dispatch;
	}
	// 82A0DDB0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A0DDB4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A0DDB8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A0DDBC: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82A0DDC0: 389E00E4  addi r4, r30, 0xe4
	ctx.r[4].s64 = ctx.r[30].s64 + 228;
	// 82A0DDC4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A0DDC8: 484508E1  bl 0x82e5e6a8
	ctx.lr = 0x82A0DDCC;
	sub_82E5E6A8(ctx, base);
	// 82A0DDCC: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A0DDD0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0DDD4: 419A0008  beq cr6, 0x82a0dddc
	if ctx.cr[6].eq {
	pc = 0x82A0DDDC; continue 'dispatch;
	}
	// 82A0DDD8: 4B8B2AB9  bl 0x822c0890
	ctx.lr = 0x82A0DDDC;
	sub_822C0890(ctx, base);
	// 82A0DDDC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A0DDE0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0DDE4: 419A0008  beq cr6, 0x82a0ddec
	if ctx.cr[6].eq {
	pc = 0x82A0DDEC; continue 'dispatch;
	}
	// 82A0DDE8: 4B8B2AA9  bl 0x822c0890
	ctx.lr = 0x82A0DDEC;
	sub_822C0890(ctx, base);
	// 82A0DDEC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A0DDF0: 419A000C  beq cr6, 0x82a0ddfc
	if ctx.cr[6].eq {
	pc = 0x82A0DDFC; continue 'dispatch;
	}
	// 82A0DDF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0DDF8: 4B8B2A99  bl 0x822c0890
	ctx.lr = 0x82A0DDFC;
	sub_822C0890(ctx, base);
	// 82A0DDFC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A0DE00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0DE04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A0DE08: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82A0DE0C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A0DE10: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A0DE14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0DE18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A0DE18 size=4
    let mut pc: u32 = 0x82A0DE18;
    'dispatch: loop {
        match pc {
            0x82A0DE18 => {
    //   block [0x82A0DE18..0x82A0DE1C)
	// 82A0DE18: 4BFFFE10  b 0x82a0dc28
	sub_82A0DC28(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0DE20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A0DE20 size=40
    let mut pc: u32 = 0x82A0DE20;
    'dispatch: loop {
        match pc {
            0x82A0DE20 => {
    //   block [0x82A0DE20..0x82A0DE48)
	// 82A0DE20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0DE24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A0DE28: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0DE2C: 487467D5  bl 0x83154600
	ctx.lr = 0x82A0DE30;
	sub_83154600(ctx, base);
	// 82A0DE30: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A0DE34: 99630210  stb r11, 0x210(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(528 as u32), ctx.r[11].u8 ) };
	// 82A0DE38: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A0DE3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0DE40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A0DE44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0DE48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A0DE48 size=1012
    let mut pc: u32 = 0x82A0DE48;
    'dispatch: loop {
        match pc {
            0x82A0DE48 => {
    //   block [0x82A0DE48..0x82A0E23C)
	// 82A0DE48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0DE4C: 4879A321  bl 0x831a816c
	ctx.lr = 0x82A0DE50;
	sub_831A8130(ctx, base);
	// 82A0DE50: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82A0DE54: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0DE58: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A0DE5C: 487467A5  bl 0x83154600
	ctx.lr = 0x82A0DE60;
	sub_83154600(ctx, base);
	// 82A0DE60: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A0DE64: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A0DE68: 997D0060  stb r11, 0x60(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(96 as u32), ctx.r[11].u8 ) };
	// 82A0DE6C: 4BB03C7D  bl 0x82511ae8
	ctx.lr = 0x82A0DE70;
	sub_82511AE8(ctx, base);
	// 82A0DE70: 39600200  li r11, 0x200
	ctx.r[11].s64 = 512;
	// 82A0DE74: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0E240(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A0E240 size=728
    let mut pc: u32 = 0x82A0E240;
    'dispatch: loop {
        match pc {
            0x82A0E240 => {
    //   block [0x82A0E240..0x82A0E518)
	// 82A0E240: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0E244: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A0E248: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A0E24C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A0E250: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82A0E254: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0E258: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A0E25C: 487463A5  bl 0x83154600
	ctx.lr = 0x82A0E260;
	sub_83154600(ctx, base);
	// 82A0E260: 897E0060  lbz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82A0E264: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A0E268: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82A0E26C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A0E270: 41980144  blt cr6, 0x82a0e3b4
	if ctx.cr[6].lt {
	pc = 0x82A0E3B4; continue 'dispatch;
	}
	// 82A0E274: 419A0030  beq cr6, 0x82a0e2a4
	if ctx.cr[6].eq {
	pc = 0x82A0E2A4; continue 'dispatch;
	}
	// 82A0E278: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82A0E27C: 40980280  bge cr6, 0x82a0e4fc
	if !ctx.cr[6].lt {
	pc = 0x82A0E4FC; continue 'dispatch;
	}
	// 82A0E280: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82A0E284: 807F0150  lwz r3, 0x150(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) } as u64;
	// 82A0E288: C02B6150  lfs f1, 0x6150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A0E28C: 4819F96D  bl 0x82badbf8
	ctx.lr = 0x82A0E290;
	sub_82BADBF8(ctx, base);
	// 82A0E290: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A0E294: 41820268  beq 0x82a0e4fc
	if ctx.cr[0].eq {
	pc = 0x82A0E4FC; continue 'dispatch;
	}
	// 82A0E298: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0E29C: 4BFFD60D  bl 0x82a0b8a8
	ctx.lr = 0x82A0E2A0;
	sub_82A0B8A8(ctx, base);
	// 82A0E2A0: 4800025C  b 0x82a0e4fc
	pc = 0x82A0E4FC; continue 'dispatch;
	// 82A0E2A4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A0E2A8: 807F0150  lwz r3, 0x150(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) } as u64;
	// 82A0E2AC: C3EB9528  lfs f31, -0x6ad8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A0E2B0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A0E2B4: 4819F945  bl 0x82badbf8
	ctx.lr = 0x82A0E2B8;
	sub_82BADBF8(ctx, base);
	// 82A0E2B8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A0E2BC: 41820240  beq 0x82a0e4fc
	if ctx.cr[0].eq {
	pc = 0x82A0E4FC; continue 'dispatch;
	}
	// 82A0E2C0: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82A0E2C4: 897E0060  lbz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82A0E2C8: C01E0064  lfs f0, 0x64(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A0E2CC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A0E2D0: 997E0060  stb r11, 0x60(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(96 as u32), ctx.r[11].u8 ) };
	// 82A0E2D4: C1AA6150  lfs f13, 0x6150(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24912 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A0E2D8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A0E2DC: 41980044  blt cr6, 0x82a0e320
	if ctx.cr[6].lt {
	pc = 0x82A0E320; continue 'dispatch;
	}
	// 82A0E2E0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A0E2E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0E2E8: 388B8754  addi r4, r11, -0x78ac
	ctx.r[4].s64 = ctx.r[11].s64 + -30892;
	// 82A0E2EC: 483E571D  bl 0x82df3a08
	ctx.lr = 0x82A0E2F0;
	sub_82DF3A08(ctx, base);
	// 82A0E2F0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A0E2F4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A0E2F8: 809F0150  lwz r4, 0x150(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) } as u64;
	// 82A0E2FC: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82A0E300: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A0E304: 481A5075  bl 0x82bb3378
	ctx.lr = 0x82A0E308;
	sub_82BB3378(ctx, base);
	// 82A0E308: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A0E30C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0E310: 419A0008  beq cr6, 0x82a0e318
	if ctx.cr[6].eq {
	pc = 0x82A0E318; continue 'dispatch;
	}
	// 82A0E314: 4B8B257D  bl 0x822c0890
	ctx.lr = 0x82A0E318;
	sub_822C0890(ctx, base);
	// 82A0E318: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0E31C: 48000090  b 0x82a0e3ac
	pc = 0x82A0E3AC; continue 'dispatch;
	// 82A0E320: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82A0E324: C1AB2534  lfs f13, 0x2534(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9524 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A0E328: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A0E32C: 41990044  bgt cr6, 0x82a0e370
	if ctx.cr[6].gt {
	pc = 0x82A0E370; continue 'dispatch;
	}
	// 82A0E330: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A0E334: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A0E338: 388B8764  addi r4, r11, -0x789c
	ctx.r[4].s64 = ctx.r[11].s64 + -30876;
	// 82A0E33C: 483E56CD  bl 0x82df3a08
	ctx.lr = 0x82A0E340;
	sub_82DF3A08(ctx, base);
	// 82A0E340: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82A0E344: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A0E348: 809F0150  lwz r4, 0x150(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) } as u64;
	// 82A0E34C: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82A0E350: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A0E354: 481A5025  bl 0x82bb3378
	ctx.lr = 0x82A0E358;
	sub_82BB3378(ctx, base);
	// 82A0E358: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A0E35C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0E360: 419A0008  beq cr6, 0x82a0e368
	if ctx.cr[6].eq {
	pc = 0x82A0E368; continue 'dispatch;
	}
	// 82A0E364: 4B8B252D  bl 0x822c0890
	ctx.lr = 0x82A0E368;
	sub_822C0890(ctx, base);
	// 82A0E368: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A0E36C: 48000040  b 0x82a0e3ac
	pc = 0x82A0E3AC; continue 'dispatch;
	// 82A0E370: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A0E374: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A0E378: 388B8780  addi r4, r11, -0x7880
	ctx.r[4].s64 = ctx.r[11].s64 + -30848;
	// 82A0E37C: 483E568D  bl 0x82df3a08
	ctx.lr = 0x82A0E380;
	sub_82DF3A08(ctx, base);
	// 82A0E380: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82A0E384: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A0E388: 809F0150  lwz r4, 0x150(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) } as u64;
	// 82A0E38C: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82A0E390: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A0E394: 481A4FE5  bl 0x82bb3378
	ctx.lr = 0x82A0E398;
	sub_82BB3378(ctx, base);
	// 82A0E398: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82A0E39C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0E3A0: 419A0008  beq cr6, 0x82a0e3a8
	if ctx.cr[6].eq {
	pc = 0x82A0E3A8; continue 'dispatch;
	}
	// 82A0E3A4: 4B8B24ED  bl 0x822c0890
	ctx.lr = 0x82A0E3A8;
	sub_822C0890(ctx, base);
	// 82A0E3A8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A0E3AC: 483E507D  bl 0x82df3428
	ctx.lr = 0x82A0E3B0;
	sub_82DF3428(ctx, base);
	// 82A0E3B0: 4800014C  b 0x82a0e4fc
	pc = 0x82A0E4FC; continue 'dispatch;
	// 82A0E3B4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A0E3B8: 807F0150  lwz r3, 0x150(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) } as u64;
	// 82A0E3BC: C3EB9528  lfs f31, -0x6ad8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A0E3C0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A0E3C4: 4819F835  bl 0x82badbf8
	ctx.lr = 0x82A0E3C8;
	sub_82BADBF8(ctx, base);
	// 82A0E3C8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A0E3CC: 41820130  beq 0x82a0e4fc
	if ctx.cr[0].eq {
	pc = 0x82A0E4FC; continue 'dispatch;
	}
	// 82A0E3D0: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82A0E3D4: 897E0060  lbz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82A0E3D8: C01E0064  lfs f0, 0x64(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A0E3DC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A0E3E0: 997E0060  stb r11, 0x60(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(96 as u32), ctx.r[11].u8 ) };
	// 82A0E3E4: C1AA6150  lfs f13, 0x6150(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24912 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A0E3E8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A0E3EC: 41980044  blt cr6, 0x82a0e430
	if ctx.cr[6].lt {
	pc = 0x82A0E430; continue 'dispatch;
	}
	// 82A0E3F0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82A0E3F4: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82A0E3F8: 388BE340  addi r4, r11, -0x1cc0
	ctx.r[4].s64 = ctx.r[11].s64 + -7360;
	// 82A0E3FC: 483E560D  bl 0x82df3a08
	ctx.lr = 0x82A0E400;
	sub_82DF3A08(ctx, base);
	// 82A0E400: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 82A0E404: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A0E408: 809F0150  lwz r4, 0x150(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) } as u64;
	// 82A0E40C: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82A0E410: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A0E414: 481A4F65  bl 0x82bb3378
	ctx.lr = 0x82A0E418;
	sub_82BB3378(ctx, base);
	// 82A0E418: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82A0E41C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0E420: 419A0008  beq cr6, 0x82a0e428
	if ctx.cr[6].eq {
	pc = 0x82A0E428; continue 'dispatch;
	}
	// 82A0E424: 4B8B246D  bl 0x822c0890
	ctx.lr = 0x82A0E428;
	sub_822C0890(ctx, base);
	// 82A0E428: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82A0E42C: 48000090  b 0x82a0e4bc
	pc = 0x82A0E4BC; continue 'dispatch;
	// 82A0E430: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82A0E434: C1AB2534  lfs f13, 0x2534(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9524 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A0E438: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A0E43C: 41990044  bgt cr6, 0x82a0e480
	if ctx.cr[6].gt {
	pc = 0x82A0E480; continue 'dispatch;
	}
	// 82A0E440: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A0E444: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A0E448: 388B8774  addi r4, r11, -0x788c
	ctx.r[4].s64 = ctx.r[11].s64 + -30860;
	// 82A0E44C: 483E55BD  bl 0x82df3a08
	ctx.lr = 0x82A0E450;
	sub_82DF3A08(ctx, base);
	// 82A0E450: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82A0E454: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82A0E458: 809F0150  lwz r4, 0x150(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) } as u64;
	// 82A0E45C: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82A0E460: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A0E464: 481A4F15  bl 0x82bb3378
	ctx.lr = 0x82A0E468;
	sub_82BB3378(ctx, base);
	// 82A0E468: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82A0E46C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0E470: 419A0008  beq cr6, 0x82a0e478
	if ctx.cr[6].eq {
	pc = 0x82A0E478; continue 'dispatch;
	}
	// 82A0E474: 4B8B241D  bl 0x822c0890
	ctx.lr = 0x82A0E478;
	sub_822C0890(ctx, base);
	// 82A0E478: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A0E47C: 48000040  b 0x82a0e4bc
	pc = 0x82A0E4BC; continue 'dispatch;
	// 82A0E480: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A0E484: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82A0E488: 388B8790  addi r4, r11, -0x7870
	ctx.r[4].s64 = ctx.r[11].s64 + -30832;
	// 82A0E48C: 483E557D  bl 0x82df3a08
	ctx.lr = 0x82A0E490;
	sub_82DF3A08(ctx, base);
	// 82A0E490: 38A10064  addi r5, r1, 0x64
	ctx.r[5].s64 = ctx.r[1].s64 + 100;
	// 82A0E494: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82A0E498: 809F0150  lwz r4, 0x150(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) } as u64;
	// 82A0E49C: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82A0E4A0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A0E4A4: 481A4ED5  bl 0x82bb3378
	ctx.lr = 0x82A0E4A8;
	sub_82BB3378(ctx, base);
	// 82A0E4A8: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82A0E4AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0E4B0: 419A0008  beq cr6, 0x82a0e4b8
	if ctx.cr[6].eq {
	pc = 0x82A0E4B8; continue 'dispatch;
	}
	// 82A0E4B4: 4B8B23DD  bl 0x822c0890
	ctx.lr = 0x82A0E4B8;
	sub_822C0890(ctx, base);
	// 82A0E4B8: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82A0E4BC: 483E4F6D  bl 0x82df3428
	ctx.lr = 0x82A0E4C0;
	sub_82DF3428(ctx, base);
	// 82A0E4C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0E4C4: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0E4C8: 4BB03621  bl 0x82511ae8
	ctx.lr = 0x82A0E4CC;
	sub_82511AE8(ctx, base);
	// 82A0E4CC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A0E4D0: 815E002C  lwz r10, 0x2c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 82A0E4D4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A0E4D8: 38AB887C  addi r5, r11, -0x7784
	ctx.r[5].s64 = ctx.r[11].s64 + -30596;
	// 82A0E4DC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0E4E0: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82A0E4E4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A0E4E8: 4E800421  bctrl
	ctx.lr = 0x82A0E4EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A0E4EC: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82A0E4F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0E4F4: 419A0008  beq cr6, 0x82a0e4fc
	if ctx.cr[6].eq {
	pc = 0x82A0E4FC; continue 'dispatch;
	}
	// 82A0E4F8: 4B8B2399  bl 0x822c0890
	ctx.lr = 0x82A0E4FC;
	sub_822C0890(ctx, base);
	// 82A0E4FC: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82A0E500: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0E504: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A0E508: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82A0E50C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A0E510: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A0E514: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


