pub fn sub_830B8350(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830B8350 size=12
    let mut pc: u32 = 0x830B8350;
    'dispatch: loop {
        match pc {
            0x830B8350 => {
    //   block [0x830B8350..0x830B835C)
	// 830B8350: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 830B8354: C02B4420  lfs f1, 0x4420(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(17440 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830B8358: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830B8360(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830B8360 size=12
    let mut pc: u32 = 0x830B8360;
    'dispatch: loop {
        match pc {
            0x830B8360 => {
    //   block [0x830B8360..0x830B836C)
	// 830B8360: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 830B8364: C02B4424  lfs f1, 0x4424(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(17444 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830B8368: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830B8370(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830B8370 size=80
    let mut pc: u32 = 0x830B8370;
    'dispatch: loop {
        match pc {
            0x830B8370 => {
    //   block [0x830B8370..0x830B83C0)
	// 830B8370: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830B8374: 3D408339  lis r10, -0x7cc7
	ctx.r[10].s64 = -2093416448;
	// 830B8378: 3D208339  lis r9, -0x7cc7
	ctx.r[9].s64 = -2093416448;
	// 830B837C: 390ABCA0  addi r8, r10, -0x4360
	ctx.r[8].s64 = ctx.r[10].s64 + -17248;
	// 830B8380: 38E9BCBC  addi r7, r9, -0x4344
	ctx.r[7].s64 = ctx.r[9].s64 + -17220;
	// 830B8384: C1AB08A8  lfs f13, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830B8388: EC0D1024  fdivs f0, f13, f2
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[2].f64) as f32) as f64;
	// 830B838C: D02ABCA0  stfs f1, -0x4360(r10)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-17248 as u32), tmp.u32 ) };
	// 830B8390: EDAD0824  fdivs f13, f13, f1
	ctx.f[13].f64 = ((ctx.f[13].f64 / ctx.f[1].f64) as f32) as f64;
	// 830B8394: D029BCBC  stfs f1, -0x4344(r9)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(-17220 as u32), tmp.u32 ) };
	// 830B8398: D0480004  stfs f2, 4(r8)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830B839C: D0470004  stfs f2, 4(r7)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830B83A0: D1A80008  stfs f13, 8(r8)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 830B83A4: D008000C  stfs f0, 0xc(r8)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830B83A8: D1A70008  stfs f13, 8(r7)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 830B83AC: D007000C  stfs f0, 0xc(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830B83B0: ED800072  fmuls f12, f0, f1
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 830B83B4: D1880018  stfs f12, 0x18(r8)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 830B83B8: D1870018  stfs f12, 0x18(r7)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 830B83BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830B83C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830B83C0 size=36
    let mut pc: u32 = 0x830B83C0;
    'dispatch: loop {
        match pc {
            0x830B83C0 => {
    //   block [0x830B83C0..0x830B83E4)
	// 830B83C0: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830B83C4: 396BBCA0  addi r11, r11, -0x4360
	ctx.r[11].s64 = ctx.r[11].s64 + -17248;
	// 830B83C8: C00B0008  lfs f0, 8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830B83CC: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830B83D0: EC000072  fmuls f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 830B83D4: EDAD00B2  fmuls f13, f13, f2
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[2].f64) as f32) as f64);
	// 830B83D8: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 830B83DC: D1AB0014  stfs f13, 0x14(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 830B83E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830B83E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830B83E8 size=60
    let mut pc: u32 = 0x830B83E8;
    'dispatch: loop {
        match pc {
            0x830B83E8 => {
    //   block [0x830B83E8..0x830B8424)
	// 830B83E8: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830B83EC: 394BBCA0  addi r10, r11, -0x4360
	ctx.r[10].s64 = ctx.r[11].s64 + -17248;
	// 830B83F0: C00A0010  lfs f0, 0x10(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830B83F4: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830B83F8: C00A0014  lfs f0, 0x14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830B83FC: D0040000  stfs f0, 0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830B8400: C1A30000  lfs f13, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830B8404: C00BBCA0  lfs f0, -0x4360(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17248 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830B8408: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 830B840C: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830B8410: C00A0004  lfs f0, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830B8414: C1A40000  lfs f13, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830B8418: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 830B841C: D0040000  stfs f0, 0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830B8420: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830B8428(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830B8428 size=56
    let mut pc: u32 = 0x830B8428;
    'dispatch: loop {
        match pc {
            0x830B8428 => {
    //   block [0x830B8428..0x830B8460)
	// 830B8428: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830B842C: C1630000  lfs f11, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830B8430: 394BBCA0  addi r10, r11, -0x4360
	ctx.r[10].s64 = ctx.r[11].s64 + -17248;
	// 830B8434: C18BBCA0  lfs f12, -0x4360(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17248 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830B8438: C00A0004  lfs f0, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830B843C: C1AA0014  lfs f13, 0x14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830B8440: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 830B8444: C00A0010  lfs f0, 0x10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830B8448: EC005B3A  fmadds f0, f0, f12, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64 + ctx.f[11].f64) as f32) as f64);
	// 830B844C: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830B8450: C0040000  lfs f0, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830B8454: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 830B8458: D0040000  stfs f0, 0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830B845C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830B8460(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830B8460 size=36
    let mut pc: u32 = 0x830B8460;
    'dispatch: loop {
        match pc {
            0x830B8460 => {
    //   block [0x830B8460..0x830B8484)
	// 830B8460: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830B8464: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830B8468: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830B846C: 4800711D  bl 0x830bf588
	ctx.lr = 0x830B8470;
	sub_830BF588(ctx, base);
	// 830B8470: 48000629  bl 0x830b8a98
	ctx.lr = 0x830B8474;
	sub_830B8A98(ctx, base);
	// 830B8474: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830B8478: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830B847C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830B8480: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830B8488(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830B8488 size=4
    let mut pc: u32 = 0x830B8488;
    'dispatch: loop {
        match pc {
            0x830B8488 => {
    //   block [0x830B8488..0x830B848C)
	// 830B8488: 48007100  b 0x830bf588
	sub_830BF588(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830B8490(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830B8490 size=4
    let mut pc: u32 = 0x830B8490;
    'dispatch: loop {
        match pc {
            0x830B8490 => {
    //   block [0x830B8490..0x830B8494)
	// 830B8490: 48006BC8  b 0x830bf058
	sub_830BF058(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830B8498(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830B8498 size=120
    let mut pc: u32 = 0x830B8498;
    'dispatch: loop {
        match pc {
            0x830B8498 => {
    //   block [0x830B8498..0x830B8510)
	// 830B8498: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830B849C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830B84A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830B84A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830B84A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830B84AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830B84B0: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 830B84B4: 396B4EE0  addi r11, r11, 0x4ee0
	ctx.r[11].s64 = ctx.r[11].s64 + 20192;
	// 830B84B8: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830B84BC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830B84C0: 83EA0000  lwz r31, 0(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830B84C4: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830B84C8: 419A0028  beq cr6, 0x830b84f0
	if ctx.cr[6].eq {
	pc = 0x830B84F0; continue 'dispatch;
	}
	// 830B84CC: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 830B84D0: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830B84D4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830B84D8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830B84DC: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 830B84E0: 4BFFB229  bl 0x830b3708
	ctx.lr = 0x830B84E4;
	sub_830B3708(ctx, base);
	// 830B84E4: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830B84E8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830B84EC: 409AFFE0  bne cr6, 0x830b84cc
	if !ctx.cr[6].eq {
	pc = 0x830B84CC; continue 'dispatch;
	}
	// 830B84F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830B84F4: 4B48D295  bl 0x82545788
	ctx.lr = 0x830B84F8;
	sub_82545788(ctx, base);
	// 830B84F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830B84FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830B8500: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830B8504: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830B8508: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830B850C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830B8510(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830B8510 size=24
    let mut pc: u32 = 0x830B8510;
    'dispatch: loop {
        match pc {
            0x830B8510 => {
    //   block [0x830B8510..0x830B8528)
	// 830B8510: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 830B8514: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 830B8518: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 830B851C: 394AEE4C  addi r10, r10, -0x11b4
	ctx.r[10].s64 = ctx.r[10].s64 + -4532;
	// 830B8520: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830B8524: 4BFF99B4  b 0x830b1ed8
	sub_830B1ED8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830B8528(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830B8528 size=100
    let mut pc: u32 = 0x830B8528;
    'dispatch: loop {
        match pc {
            0x830B8528 => {
    //   block [0x830B8528..0x830B858C)
	// 830B8528: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830B852C: 480EFC39  bl 0x831a8164
	ctx.lr = 0x830B8530;
	sub_831A8130(ctx, base);
	// 830B8530: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830B8534: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830B8538: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830B853C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830B8540: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 830B8544: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 830B8548: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 830B854C: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 830B8550: 4B7B2A41  bl 0x8286af90
	ctx.lr = 0x830B8554;
	sub_8286AF90(ctx, base);
	// 830B8554: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830B8558: 4182002C  beq 0x830b8584
	if ctx.cr[0].eq {
	pc = 0x830B8584; continue 'dispatch;
	}
	// 830B855C: 93C30000  stw r30, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 830B8560: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830B8564: 93A30004  stw r29, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 830B8568: 93830008  stw r28, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 830B856C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830B8570: 9143000C  stw r10, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 830B8574: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830B8578: 91430010  stw r10, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 830B857C: 9B630014  stb r27, 0x14(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[27].u8 ) };
	// 830B8580: 99630015  stb r11, 0x15(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(21 as u32), ctx.r[11].u8 ) };
	// 830B8584: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830B8588: 480EFC2C  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830B8590(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830B8590 size=132
    let mut pc: u32 = 0x830B8590;
    'dispatch: loop {
        match pc {
            0x830B8590 => {
    //   block [0x830B8590..0x830B8614)
	// 830B8590: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830B8594: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830B8598: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830B859C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830B85A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830B85A4: 9081008C  stw r4, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[4].u32 ) };
	// 830B85A8: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830B85AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830B85B0: 38A1008C  addi r5, r1, 0x8c
	ctx.r[5].s64 = ctx.r[1].s64 + 140;
	// 830B85B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830B85B8: 83CBBCD8  lwz r30, -0x4328(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17192 as u32) ) } as u64;
	// 830B85BC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830B85C0: 4B463BE9  bl 0x8251c1a8
	ctx.lr = 0x830B85C4;
	sub_8251C1A8(ctx, base);
	// 830B85C4: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830B85C8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830B85CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830B85D0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830B85D4: 409A0010  bne cr6, 0x830b85e4
	if !ctx.cr[6].eq {
	pc = 0x830B85E4; continue 'dispatch;
	}
	// 830B85D8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830B85DC: 4B526565  bl 0x825deb40
	ctx.lr = 0x830B85E0;
	sub_825DEB40(ctx, base);
	// 830B85E0: 48000018  b 0x830b85f8
	pc = 0x830B85F8; continue 'dispatch;
	// 830B85E4: 808B0010  lwz r4, 0x10(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830B85E8: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830B85EC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830B85F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830B85F4: 4E800421  bctrl
	ctx.lr = 0x830B85F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830B85F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830B85FC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830B8600: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830B8604: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830B8608: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830B860C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830B8610: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830B8618(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830B8618 size=1008
    let mut pc: u32 = 0x830B8618;
    'dispatch: loop {
        match pc {
            0x830B8618 => {
    //   block [0x830B8618..0x830B8A08)
	// 830B8618: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830B861C: 480EFB3D  bl 0x831a8158
	ctx.lr = 0x830B8620;
	sub_831A8130(ctx, base);
	// 830B8620: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830B8624: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 830B8628: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 830B862C: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 830B8630: 93E10104  stw r31, 0x104(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(260 as u32), ctx.r[31].u32 ) };
	// 830B8634: 897F0015  lbz r11, 0x15(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(21 as u32) ) } as u64;
	// 830B8638: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830B863C: 419A0048  beq cr6, 0x830b8684
	if ctx.cr[6].eq {
	pc = 0x830B8684; continue 'dispatch;
	}
	// 830B8640: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 830B8644: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830B8648: 388B9620  addi r4, r11, -0x69e0
	ctx.r[4].s64 = ctx.r[11].s64 + -27104;
	// 830B864C: 4B20D27D  bl 0x822c58c8
	ctx.lr = 0x830B8650;
	sub_822C58C8(ctx, base);
	// 830B8650: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830B8654: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830B8658: 4B211859  bl 0x822c9eb0
	ctx.lr = 0x830B865C;
	sub_822C9EB0(ctx, base);
	// 830B865C: 4B20BC55  bl 0x822c42b0
	ctx.lr = 0x830B8660;
	sub_822C42B0(ctx, base);
	// 830B8660: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 830B8664: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830B8668: 396B9600  addi r11, r11, -0x6a00
	ctx.r[11].s64 = ctx.r[11].s64 + -27136;
	// 830B866C: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 830B8670: 4B20CE01  bl 0x822c5470
	ctx.lr = 0x830B8674;
	sub_822C5470(ctx, base);
	// 830B8674: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830B8678: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830B867C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830B8680: 4B20C661  bl 0x822c4ce0
	ctx.lr = 0x830B8684;
	sub_822C4CE0(ctx, base);
	// 830B8684: 38610104  addi r3, r1, 0x104
	ctx.r[3].s64 = ctx.r[1].s64 + 260;
	// 830B8688: 7FFAFB78  mr r26, r31
	ctx.r[26].u64 = ctx.r[31].u64;
	// 830B868C: 4B430A05  bl 0x824e9090
	ctx.lr = 0x830B8690;
	sub_824E9090(ctx, base);
	// 830B8690: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 830B8694: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 830B8698: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830B869C: 83210104  lwz r25, 0x104(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 830B86A0: 419A000C  beq cr6, 0x830b86ac
	if ctx.cr[6].eq {
	pc = 0x830B86AC; continue 'dispatch;
	}
	// 830B86A4: 839A0008  lwz r28, 8(r26)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 830B86A8: 48000028  b 0x830b86d0
	pc = 0x830B86D0; continue 'dispatch;
	// 830B86AC: 815A0008  lwz r10, 8(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 830B86B0: 894A0015  lbz r10, 0x15(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(21 as u32) ) } as u64;
	// 830B86B4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830B86B8: 419A000C  beq cr6, 0x830b86c4
	if ctx.cr[6].eq {
	pc = 0x830B86C4; continue 'dispatch;
	}
	// 830B86BC: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 830B86C0: 48000010  b 0x830b86d0
	pc = 0x830B86D0; continue 'dispatch;
	// 830B86C4: 83990008  lwz r28, 8(r25)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 830B86C8: 7F19D040  cmplw cr6, r25, r26
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[26].u32, &mut ctx.xer);
	// 830B86CC: 409A00DC  bne cr6, 0x830b87a8
	if !ctx.cr[6].eq {
	pc = 0x830B87A8; continue 'dispatch;
	}
	// 830B86D0: 897C0015  lbz r11, 0x15(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(21 as u32) ) } as u64;
	// 830B86D4: 83FA0004  lwz r31, 4(r26)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 830B86D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830B86DC: 409A0008  bne cr6, 0x830b86e4
	if !ctx.cr[6].eq {
	pc = 0x830B86E4; continue 'dispatch;
	}
	// 830B86E0: 93FC0004  stw r31, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 830B86E4: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 830B86E8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830B86EC: 7F0AD040  cmplw cr6, r10, r26
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[26].u32, &mut ctx.xer);
	// 830B86F0: 409A000C  bne cr6, 0x830b86fc
	if !ctx.cr[6].eq {
	pc = 0x830B86FC; continue 'dispatch;
	}
	// 830B86F4: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 830B86F8: 4800001C  b 0x830b8714
	pc = 0x830B8714; continue 'dispatch;
	// 830B86FC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830B8700: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 830B8704: 409A000C  bne cr6, 0x830b8710
	if !ctx.cr[6].eq {
	pc = 0x830B8710; continue 'dispatch;
	}
	// 830B8708: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 830B870C: 48000008  b 0x830b8714
	pc = 0x830B8714; continue 'dispatch;
	// 830B8710: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 830B8714: 813B0004  lwz r9, 4(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 830B8718: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 830B871C: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 830B8720: 409A003C  bne cr6, 0x830b875c
	if !ctx.cr[6].eq {
	pc = 0x830B875C; continue 'dispatch;
	}
	// 830B8724: 897C0015  lbz r11, 0x15(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(21 as u32) ) } as u64;
	// 830B8728: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830B872C: 419A000C  beq cr6, 0x830b8738
	if ctx.cr[6].eq {
	pc = 0x830B8738; continue 'dispatch;
	}
	// 830B8730: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 830B8734: 48000024  b 0x830b8758
	pc = 0x830B8758; continue 'dispatch;
	// 830B8738: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830B873C: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 830B8740: 4800000C  b 0x830b874c
	pc = 0x830B874C; continue 'dispatch;
	// 830B8744: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 830B8748: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830B874C: 890B0015  lbz r8, 0x15(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 830B8750: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 830B8754: 419AFFF0  beq cr6, 0x830b8744
	if ctx.cr[6].eq {
	pc = 0x830B8744; continue 'dispatch;
	}
	// 830B8758: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830B875C: 813B0004  lwz r9, 4(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 830B8760: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 830B8764: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 830B8768: 409A00D4  bne cr6, 0x830b883c
	if !ctx.cr[6].eq {
	pc = 0x830B883C; continue 'dispatch;
	}
	// 830B876C: 897C0015  lbz r11, 0x15(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(21 as u32) ) } as u64;
	// 830B8770: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830B8774: 419A000C  beq cr6, 0x830b8780
	if ctx.cr[6].eq {
	pc = 0x830B8780; continue 'dispatch;
	}
	// 830B8778: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 830B877C: 48000024  b 0x830b87a0
	pc = 0x830B87A0; continue 'dispatch;
	// 830B8780: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 830B8784: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 830B8788: 4800000C  b 0x830b8794
	pc = 0x830B8794; continue 'dispatch;
	// 830B878C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 830B8790: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830B8794: 890B0015  lbz r8, 0x15(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 830B8798: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 830B879C: 419AFFF0  beq cr6, 0x830b878c
	if ctx.cr[6].eq {
	pc = 0x830B878C; continue 'dispatch;
	}
	// 830B87A0: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830B87A4: 48000098  b 0x830b883c
	pc = 0x830B883C; continue 'dispatch;
	// 830B87A8: 932B0004  stw r25, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 830B87AC: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 830B87B0: 91790000  stw r11, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830B87B4: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 830B87B8: 7F195840  cmplw cr6, r25, r11
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830B87BC: 409A000C  bne cr6, 0x830b87c8
	if !ctx.cr[6].eq {
	pc = 0x830B87C8; continue 'dispatch;
	}
	// 830B87C0: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 830B87C4: 4800002C  b 0x830b87f0
	pc = 0x830B87F0; continue 'dispatch;
	// 830B87C8: 897C0015  lbz r11, 0x15(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(21 as u32) ) } as u64;
	// 830B87CC: 83F90004  lwz r31, 4(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 830B87D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830B87D4: 409A0008  bne cr6, 0x830b87dc
	if !ctx.cr[6].eq {
	pc = 0x830B87DC; continue 'dispatch;
	}
	// 830B87D8: 93FC0004  stw r31, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 830B87DC: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 830B87E0: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 830B87E4: 91790008  stw r11, 8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830B87E8: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 830B87EC: 932B0004  stw r25, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 830B87F0: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 830B87F4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830B87F8: 7F0AD040  cmplw cr6, r10, r26
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[26].u32, &mut ctx.xer);
	// 830B87FC: 409A000C  bne cr6, 0x830b8808
	if !ctx.cr[6].eq {
	pc = 0x830B8808; continue 'dispatch;
	}
	// 830B8800: 932B0004  stw r25, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 830B8804: 48000020  b 0x830b8824
	pc = 0x830B8824; continue 'dispatch;
	// 830B8808: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 830B880C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830B8810: 7F0AD040  cmplw cr6, r10, r26
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[26].u32, &mut ctx.xer);
	// 830B8814: 409A000C  bne cr6, 0x830b8820
	if !ctx.cr[6].eq {
	pc = 0x830B8820; continue 'dispatch;
	}
	// 830B8818: 932B0000  stw r25, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 830B881C: 48000008  b 0x830b8824
	pc = 0x830B8824; continue 'dispatch;
	// 830B8820: 932B0008  stw r25, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[25].u32 ) };
	// 830B8824: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 830B8828: 91790004  stw r11, 4(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830B882C: 897A0014  lbz r11, 0x14(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(20 as u32) ) } as u64;
	// 830B8830: 89590014  lbz r10, 0x14(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(20 as u32) ) } as u64;
	// 830B8834: 99790014  stb r11, 0x14(r25)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[25].u32.wrapping_add(20 as u32), ctx.r[11].u8 ) };
	// 830B8838: 995A0014  stb r10, 0x14(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(20 as u32), ctx.r[10].u8 ) };
	// 830B883C: 897A0014  lbz r11, 0x14(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(20 as u32) ) } as u64;
	// 830B8840: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830B8844: 409A0198  bne cr6, 0x830b89dc
	if !ctx.cr[6].eq {
	pc = 0x830B89DC; continue 'dispatch;
	}
	// 830B8848: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 830B884C: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 830B8850: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830B8854: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830B8858: 419A0180  beq cr6, 0x830b89d8
	if ctx.cr[6].eq {
	pc = 0x830B89D8; continue 'dispatch;
	}
	// 830B885C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830B8860: 897C0014  lbz r11, 0x14(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 830B8864: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830B8868: 409A0170  bne cr6, 0x830b89d8
	if !ctx.cr[6].eq {
	pc = 0x830B89D8; continue 'dispatch;
	}
	// 830B886C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830B8870: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830B8874: 409A00A8  bne cr6, 0x830b891c
	if !ctx.cr[6].eq {
	pc = 0x830B891C; continue 'dispatch;
	}
	// 830B8878: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830B887C: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 830B8880: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830B8884: 409A001C  bne cr6, 0x830b88a0
	if !ctx.cr[6].eq {
	pc = 0x830B88A0; continue 'dispatch;
	}
	// 830B8888: 9BCB0014  stb r30, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[30].u8 ) };
	// 830B888C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830B8890: 9BBF0014  stb r29, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 830B8894: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830B8898: 4BAFE339  bl 0x82bb6bd0
	ctx.lr = 0x830B889C;
	sub_82BB6BD0(ctx, base);
	// 830B889C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830B88A0: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 830B88A4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830B88A8: 409A00C8  bne cr6, 0x830b8970
	if !ctx.cr[6].eq {
	pc = 0x830B8970; continue 'dispatch;
	}
	// 830B88AC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830B88B0: 894A0014  lbz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 830B88B4: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 830B88B8: 409A0014  bne cr6, 0x830b88cc
	if !ctx.cr[6].eq {
	pc = 0x830B88CC; continue 'dispatch;
	}
	// 830B88BC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830B88C0: 894A0014  lbz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 830B88C4: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 830B88C8: 419A00A4  beq cr6, 0x830b896c
	if ctx.cr[6].eq {
	pc = 0x830B896C; continue 'dispatch;
	}
	// 830B88CC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830B88D0: 894A0014  lbz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 830B88D4: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 830B88D8: 409A0020  bne cr6, 0x830b88f8
	if !ctx.cr[6].eq {
	pc = 0x830B88F8; continue 'dispatch;
	}
	// 830B88DC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830B88E0: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 830B88E4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830B88E8: 9BCA0014  stb r30, 0x14(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[30].u8 ) };
	// 830B88EC: 9BAB0014  stb r29, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 830B88F0: 4B235C21  bl 0x822ee510
	ctx.lr = 0x830B88F4;
	sub_822EE510(ctx, base);
	// 830B88F4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830B88F8: 895F0014  lbz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830B88FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830B8900: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830B8904: 994B0014  stb r10, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u8 ) };
	// 830B8908: 9BDF0014  stb r30, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u8 ) };
	// 830B890C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830B8910: 9BCB0014  stb r30, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[30].u8 ) };
	// 830B8914: 4BAFE2BD  bl 0x82bb6bd0
	ctx.lr = 0x830B8918;
	sub_82BB6BD0(ctx, base);
	// 830B8918: 480000C0  b 0x830b89d8
	pc = 0x830B89D8; continue 'dispatch;
	// 830B891C: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 830B8920: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830B8924: 409A001C  bne cr6, 0x830b8940
	if !ctx.cr[6].eq {
	pc = 0x830B8940; continue 'dispatch;
	}
	// 830B8928: 9BCB0014  stb r30, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[30].u8 ) };
	// 830B892C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830B8930: 9BBF0014  stb r29, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 830B8934: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830B8938: 4B235BD9  bl 0x822ee510
	ctx.lr = 0x830B893C;
	sub_822EE510(ctx, base);
	// 830B893C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830B8940: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 830B8944: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830B8948: 409A0028  bne cr6, 0x830b8970
	if !ctx.cr[6].eq {
	pc = 0x830B8970; continue 'dispatch;
	}
	// 830B894C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830B8950: 894A0014  lbz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 830B8954: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 830B8958: 409A0034  bne cr6, 0x830b898c
	if !ctx.cr[6].eq {
	pc = 0x830B898C; continue 'dispatch;
	}
	// 830B895C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830B8960: 894A0014  lbz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 830B8964: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 830B8968: 409A0024  bne cr6, 0x830b898c
	if !ctx.cr[6].eq {
	pc = 0x830B898C; continue 'dispatch;
	}
	// 830B896C: 9BAB0014  stb r29, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 830B8970: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 830B8974: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 830B8978: 83FF0004  lwz r31, 4(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830B897C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830B8980: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830B8984: 409AFEDC  bne cr6, 0x830b8860
	if !ctx.cr[6].eq {
	pc = 0x830B8860; continue 'dispatch;
	}
	// 830B8988: 48000050  b 0x830b89d8
	pc = 0x830B89D8; continue 'dispatch;
	// 830B898C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830B8990: 894A0014  lbz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 830B8994: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 830B8998: 409A0020  bne cr6, 0x830b89b8
	if !ctx.cr[6].eq {
	pc = 0x830B89B8; continue 'dispatch;
	}
	// 830B899C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830B89A0: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 830B89A4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830B89A8: 9BCA0014  stb r30, 0x14(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[30].u8 ) };
	// 830B89AC: 9BAB0014  stb r29, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 830B89B0: 4BAFE221  bl 0x82bb6bd0
	ctx.lr = 0x830B89B4;
	sub_82BB6BD0(ctx, base);
	// 830B89B4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830B89B8: 895F0014  lbz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830B89BC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830B89C0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830B89C4: 994B0014  stb r10, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u8 ) };
	// 830B89C8: 9BDF0014  stb r30, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u8 ) };
	// 830B89CC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830B89D0: 9BCB0014  stb r30, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[30].u8 ) };
	// 830B89D4: 4B235B3D  bl 0x822ee510
	ctx.lr = 0x830B89D8;
	sub_822EE510(ctx, base);
	// 830B89D8: 9BDC0014  stb r30, 0x14(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(20 as u32), ctx.r[30].u8 ) };
	// 830B89DC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830B89E0: 4B207889  bl 0x822c0268
	ctx.lr = 0x830B89E4;
	sub_822C0268(ctx, base);
	// 830B89E4: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 830B89E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830B89EC: 419A000C  beq cr6, 0x830b89f8
	if ctx.cr[6].eq {
	pc = 0x830B89F8; continue 'dispatch;
	}
	// 830B89F0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830B89F4: 917B0008  stw r11, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830B89F8: 93380000  stw r25, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 830B89FC: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 830B8A00: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 830B8A04: 480EF7A4  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830B8A08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830B8A08 size=140
    let mut pc: u32 = 0x830B8A08;
    'dispatch: loop {
        match pc {
            0x830B8A08 => {
    //   block [0x830B8A08..0x830B8A94)
	// 830B8A08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830B8A0C: 480EF761  bl 0x831a816c
	ctx.lr = 0x830B8A10;
	sub_831A8130(ctx, base);
	// 830B8A10: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830B8A14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830B8A18: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830B8A1C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830B8A20: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830B8A24: 4E800421  bctrl
	ctx.lr = 0x830B8A28;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830B8A28: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 830B8A2C: 3FA08339  lis r29, -0x7cc7
	ctx.r[29].s64 = -2093416448;
	// 830B8A30: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830B8A34: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 830B8A38: 83DDBCD8  lwz r30, -0x4328(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-17192 as u32) ) } as u64;
	// 830B8A3C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830B8A40: 4B463769  bl 0x8251c1a8
	ctx.lr = 0x830B8A44;
	sub_8251C1A8(ctx, base);
	// 830B8A44: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830B8A48: 80A10058  lwz r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830B8A4C: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830B8A50: 419A0010  beq cr6, 0x830b8a60
	if ctx.cr[6].eq {
	pc = 0x830B8A60; continue 'dispatch;
	}
	// 830B8A54: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830B8A58: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 830B8A5C: 4BFFFBBD  bl 0x830b8618
	ctx.lr = 0x830B8A60;
	sub_830B8618(ctx, base);
	// 830B8A60: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830B8A64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830B8A68: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830B8A6C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830B8A70: 4E800421  bctrl
	ctx.lr = 0x830B8A74;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830B8A74: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 830B8A78: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 830B8A7C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 830B8A80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830B8A84: 809DBCD8  lwz r4, -0x4328(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-17192 as u32) ) } as u64;
	// 830B8A88: 4B869839  bl 0x829222c0
	ctx.lr = 0x830B8A8C;
	sub_829222C0(ctx, base);
	// 830B8A8C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830B8A90: 480EF72C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830B8A98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830B8A98 size=84
    let mut pc: u32 = 0x830B8A98;
    'dispatch: loop {
        match pc {
            0x830B8A98 => {
    //   block [0x830B8A98..0x830B8AEC)
	// 830B8A98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830B8A9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830B8AA0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830B8AA4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830B8AA8: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 830B8AAC: 4B207E8D  bl 0x822c0938
	ctx.lr = 0x830B8AB0;
	sub_822C0938(ctx, base);
	// 830B8AB0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830B8AB4: 41820018  beq 0x830b8acc
	if ctx.cr[0].eq {
	pc = 0x830B8ACC; continue 'dispatch;
	}
	// 830B8AB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830B8ABC: 4B85C6ED  bl 0x829151a8
	ctx.lr = 0x830B8AC0;
	sub_829151A8(ctx, base);
	// 830B8AC0: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830B8AC4: 93EBBCD8  stw r31, -0x4328(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-17192 as u32), ctx.r[31].u32 ) };
	// 830B8AC8: 48000010  b 0x830b8ad8
	pc = 0x830B8AD8; continue 'dispatch;
	// 830B8ACC: 3D408339  lis r10, -0x7cc7
	ctx.r[10].s64 = -2093416448;
	// 830B8AD0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830B8AD4: 916ABCD8  stw r11, -0x4328(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-17192 as u32), ctx.r[11].u32 ) };
	// 830B8AD8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830B8ADC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830B8AE0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830B8AE4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830B8AE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830B8AF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830B8AF0 size=12
    let mut pc: u32 = 0x830B8AF0;
    'dispatch: loop {
        match pc {
            0x830B8AF0 => {
    //   block [0x830B8AF0..0x830B8AFC)
	// 830B8AF0: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830B8AF4: 906BBD14  stw r3, -0x42ec(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-17132 as u32), ctx.r[3].u32 ) };
	// 830B8AF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830B8B00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830B8B00 size=12
    let mut pc: u32 = 0x830B8B00;
    'dispatch: loop {
        match pc {
            0x830B8B00 => {
    //   block [0x830B8B00..0x830B8B0C)
	// 830B8B00: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830B8B04: 806BBD14  lwz r3, -0x42ec(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17132 as u32) ) } as u64;
	// 830B8B08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830B8B10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830B8B10 size=80
    let mut pc: u32 = 0x830B8B10;
    'dispatch: loop {
        match pc {
            0x830B8B10 => {
    //   block [0x830B8B10..0x830B8B60)
	// 830B8B10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830B8B14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830B8B18: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830B8B1C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830B8B20: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830B8B24: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830B8B28: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830B8B2C: 409A0014  bne cr6, 0x830b8b40
	if !ctx.cr[6].eq {
	pc = 0x830B8B40; continue 'dispatch;
	}
	// 830B8B30: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830B8B34: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 830B8B38: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830B8B3C: 4E800421  bctrl
	ctx.lr = 0x830B8B40;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830B8B40: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830B8B44: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830B8B48: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830B8B4C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830B8B50: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830B8B54: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830B8B58: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830B8B5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830B8B60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830B8B60 size=16
    let mut pc: u32 = 0x830B8B60;
    'dispatch: loop {
        match pc {
            0x830B8B60 => {
    //   block [0x830B8B60..0x830B8B70)
	// 830B8B60: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830B8B64: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830B8B68: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830B8B6C: 4C820020  bnelr
	if !ctx.cr[0].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830B8B70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830B8B70 size=16
    let mut pc: u32 = 0x830B8B70;
    'dispatch: loop {
        match pc {
            0x830B8B70 => {
    //   block [0x830B8B70..0x830B8B80)
	// 830B8B70: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830B8B74: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 830B8B78: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830B8B7C: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830B8B80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830B8B80 size=4
    let mut pc: u32 = 0x830B8B80;
    'dispatch: loop {
        match pc {
            0x830B8B80 => {
    //   block [0x830B8B80..0x830B8B84)
	// 830B8B80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830B8B88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830B8B88 size=116
    let mut pc: u32 = 0x830B8B88;
    'dispatch: loop {
        match pc {
            0x830B8B88 => {
    //   block [0x830B8B88..0x830B8BFC)
	// 830B8B88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830B8B8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830B8B90: F8810018  std r4, 0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(24 as u32), ctx.r[4].u64 ) };
	// 830B8B94: F8A10020  std r5, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.r[5].u64 ) };
	// 830B8B98: F8C10028  std r6, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.r[6].u64 ) };
	// 830B8B9C: F8E10030  std r7, 0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(48 as u32), ctx.r[7].u64 ) };
	// 830B8BA0: F9010038  std r8, 0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(56 as u32), ctx.r[8].u64 ) };
	// 830B8BA4: F9210040  std r9, 0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(64 as u32), ctx.r[9].u64 ) };
	// 830B8BA8: F9410048  std r10, 0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(72 as u32), ctx.r[10].u64 ) };
	// 830B8BAC: 9421FE90  stwu r1, -0x170(r1)
	ea = ctx.r[1].u32.wrapping_add(-368 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830B8BB0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 830B8BB4: 39410188  addi r10, r1, 0x188
	ctx.r[10].s64 = ctx.r[1].s64 + 392;
	// 830B8BB8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 830B8BBC: 38800100  li r4, 0x100
	ctx.r[4].s64 = 256;
	// 830B8BC0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830B8BC4: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830B8BC8: 80C10050  lwz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830B8BCC: 480F50FD  bl 0x831adcc8
	ctx.lr = 0x830B8BD0;
	sub_831ADCC8(ctx, base);
	// 830B8BD0: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830B8BD4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830B8BD8: 806BBD14  lwz r3, -0x42ec(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17132 as u32) ) } as u64;
	// 830B8BDC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830B8BE0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830B8BE4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830B8BE8: 4E800421  bctrl
	ctx.lr = 0x830B8BEC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830B8BEC: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 830B8BF0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830B8BF4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830B8BF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830B8C00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830B8C00 size=104
    let mut pc: u32 = 0x830B8C00;
    'dispatch: loop {
        match pc {
            0x830B8C00 => {
    //   block [0x830B8C00..0x830B8C68)
	// 830B8C00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830B8C04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830B8C08: F8810018  std r4, 0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(24 as u32), ctx.r[4].u64 ) };
	// 830B8C0C: F8A10020  std r5, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.r[5].u64 ) };
	// 830B8C10: F8C10028  std r6, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.r[6].u64 ) };
	// 830B8C14: F8E10030  std r7, 0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(48 as u32), ctx.r[7].u64 ) };
	// 830B8C18: F9010038  std r8, 0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(56 as u32), ctx.r[8].u64 ) };
	// 830B8C1C: F9210040  std r9, 0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(64 as u32), ctx.r[9].u64 ) };
	// 830B8C20: F9410048  std r10, 0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(72 as u32), ctx.r[10].u64 ) };
	// 830B8C24: 9421FE90  stwu r1, -0x170(r1)
	ea = ctx.r[1].u32.wrapping_add(-368 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830B8C28: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 830B8C2C: 39410188  addi r10, r1, 0x188
	ctx.r[10].s64 = ctx.r[1].s64 + 392;
	// 830B8C30: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 830B8C34: 38800100  li r4, 0x100
	ctx.r[4].s64 = 256;
	// 830B8C38: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830B8C3C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830B8C40: 80C10050  lwz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830B8C44: 480F5085  bl 0x831adcc8
	ctx.lr = 0x830B8C48;
	sub_831ADCC8(ctx, base);
	// 830B8C48: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830B8C4C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830B8C50: 806BBD14  lwz r3, -0x42ec(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17132 as u32) ) } as u64;
	// 830B8C54: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830B8C58: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830B8C5C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830B8C60: 4E800421  bctrl
	ctx.lr = 0x830B8C64;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830B8C64: 48000000  b 0x830b8c64
	pc = 0x830B8C64; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830B8C68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830B8C68 size=28
    let mut pc: u32 = 0x830B8C68;
    'dispatch: loop {
        match pc {
            0x830B8C68 => {
    //   block [0x830B8C68..0x830B8C84)
	// 830B8C68: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 830B8C6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830B8C70: 419A0014  beq cr6, 0x830b8c84
	if ctx.cr[6].eq {
		sub_830B8C84(ctx, base);
		return;
	}
	// 830B8C74: 3D408339  lis r10, -0x7cc7
	ctx.r[10].s64 = -2093416448;
	// 830B8C78: 806ABD18  lwz r3, -0x42e8(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17128 as u32) ) } as u64;
	// 830B8C7C: 916ABD18  stw r11, -0x42e8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-17128 as u32), ctx.r[11].u32 ) };
	// 830B8C80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830B8C84(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830B8C84 size=12
    let mut pc: u32 = 0x830B8C84;
    'dispatch: loop {
        match pc {
            0x830B8C84 => {
    //   block [0x830B8C84..0x830B8C90)
	// 830B8C84: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830B8C88: 806BBD18  lwz r3, -0x42e8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17128 as u32) ) } as u64;
	// 830B8C8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830B8C90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830B8C90 size=36
    let mut pc: u32 = 0x830B8C90;
    'dispatch: loop {
        match pc {
            0x830B8C90 => {
    //   block [0x830B8C90..0x830B8CB4)
	// 830B8C90: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830B8C94: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 830B8C98: 816BBD18  lwz r11, -0x42e8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17128 as u32) ) } as u64;
	// 830B8C9C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 830B8CA0: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 830B8CA4: 2B0A0010  cmplwi cr6, r10, 0x10
	ctx.cr[6].compare_u32(ctx.r[10].u32, 16 as u32, &mut ctx.xer);
	// 830B8CA8: 4198000C  blt cr6, 0x830b8cb4
	if ctx.cr[6].lt {
		sub_830B8CB4(ctx, base);
		return;
	}
	// 830B8CAC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830B8CB0: 48000008  b 0x830b8cb8
	sub_830B8CB4(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830B8CB4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830B8CB4 size=12
    let mut pc: u32 = 0x830B8CB4;
    'dispatch: loop {
        match pc {
            0x830B8CB4 => {
    //   block [0x830B8CB4..0x830B8CC0)
	// 830B8CB4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 830B8CB8: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 830B8CBC: 480F3834  b 0x831ac4f0
	sub_831AC4F0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830B8CC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830B8CC0 size=264
    let mut pc: u32 = 0x830B8CC0;
    'dispatch: loop {
        match pc {
            0x830B8CC0 => {
    //   block [0x830B8CC0..0x830B8DC8)
	// 830B8CC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830B8CC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830B8CC8: 9421FDA0  stwu r1, -0x260(r1)
	ea = ctx.r[1].u32.wrapping_add(-608 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830B8CCC: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 830B8CD0: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 830B8CD4: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 830B8CD8: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830B8CDC: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830B8CE0: 7D2A59AE  stbx r9, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u8) };
	// 830B8CE4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830B8CE8: 4082FFF0  bne 0x830b8cd8
	if !ctx.cr[0].eq {
	pc = 0x830B8CD8; continue 'dispatch;
	}
	// 830B8CEC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 830B8CF0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 830B8CF4: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830B8CF8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830B8CFC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 830B8D00: 409AFFF4  bne cr6, 0x830b8cf4
	if !ctx.cr[6].eq {
	pc = 0x830B8CF4; continue 'dispatch;
	}
	// 830B8D04: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 830B8D08: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830B8D0C: 556B003F  rotlwi. r11, r11, 0
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(0)) as u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830B8D10: 41820078  beq 0x830b8d88
	if ctx.cr[0].eq {
	pc = 0x830B8D88; continue 'dispatch;
	}
	// 830B8D14: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 830B8D18: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 830B8D1C: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830B8D20: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830B8D24: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 830B8D28: 409AFFF4  bne cr6, 0x830b8d1c
	if !ctx.cr[6].eq {
	pc = 0x830B8D1C; continue 'dispatch;
	}
	// 830B8D2C: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 830B8D30: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 830B8D34: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830B8D38: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830B8D3C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830B8D40: 896BFFFF  lbz r11, -1(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-1 as u32) ) } as u64;
	// 830B8D44: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 830B8D48: 2F0B002F  cmpwi cr6, r11, 0x2f
	ctx.cr[6].compare_i32(ctx.r[11].s32, 47, &mut ctx.xer);
	// 830B8D4C: 419A000C  beq cr6, 0x830b8d58
	if ctx.cr[6].eq {
	pc = 0x830B8D58; continue 'dispatch;
	}
	// 830B8D50: 2F0B005C  cmpwi cr6, r11, 0x5c
	ctx.cr[6].compare_i32(ctx.r[11].s32, 92, &mut ctx.xer);
	// 830B8D54: 409A0034  bne cr6, 0x830b8d88
	if !ctx.cr[6].eq {
	pc = 0x830B8D88; continue 'dispatch;
	}
	// 830B8D58: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 830B8D5C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 830B8D60: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830B8D64: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830B8D68: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 830B8D6C: 409AFFF4  bne cr6, 0x830b8d60
	if !ctx.cr[6].eq {
	pc = 0x830B8D60; continue 'dispatch;
	}
	// 830B8D70: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 830B8D74: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 830B8D78: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830B8D7C: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830B8D80: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830B8D84: 992BFFFF  stb r9, -1(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(-1 as u32), ctx.r[9].u8 ) };
	// 830B8D88: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 830B8D8C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 830B8D90: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830B8D94: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830B8D98: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 830B8D9C: 409AFFF4  bne cr6, 0x830b8d90
	if !ctx.cr[6].eq {
	pc = 0x830B8D90; continue 'dispatch;
	}
	// 830B8DA0: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 830B8DA4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830B8DA8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830B8DAC: 38630004  addi r3, r3, 4
	ctx.r[3].s64 = ctx.r[3].s64 + 4;
	// 830B8DB0: 5565003E  slwi r5, r11, 0
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 830B8DB4: 4B20C8B5  bl 0x822c5668
	ctx.lr = 0x830B8DB8;
	sub_822C5668(ctx, base);
	// 830B8DB8: 38210260  addi r1, r1, 0x260
	ctx.r[1].s64 = ctx.r[1].s64 + 608;
	// 830B8DBC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830B8DC0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830B8DC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830B8DC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830B8DC8 size=16
    let mut pc: u32 = 0x830B8DC8;
    'dispatch: loop {
        match pc {
            0x830B8DC8 => {
    //   block [0x830B8DC8..0x830B8DD8)
	// 830B8DC8: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830B8DCC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830B8DD0: 806BBD18  lwz r3, -0x42e8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17128 as u32) ) } as u64;
	// 830B8DD4: 4BFFFEEC  b 0x830b8cc0
	sub_830B8CC0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830B8DD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830B8DD8 size=16
    let mut pc: u32 = 0x830B8DD8;
    'dispatch: loop {
        match pc {
            0x830B8DD8 => {
    //   block [0x830B8DD8..0x830B8DE8)
	// 830B8DD8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830B8DDC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 830B8DE0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830B8DE4: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830B8DE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830B8DE8 size=88
    let mut pc: u32 = 0x830B8DE8;
    'dispatch: loop {
        match pc {
            0x830B8DE8 => {
    //   block [0x830B8DE8..0x830B8E40)
	// 830B8DE8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 830B8DEC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830B8DF0: 7D69582E  lwzx r11, r9, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830B8DF4: 814B0034  lwz r10, 0x34(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 830B8DF8: 7147D000  andi. r7, r10, 0xd000
	ctx.r[7].u64 = ctx.r[10].u64 & 53248;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 830B8DFC: 28070000  cmplwi r7, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830B8E00: 40820028  bne 0x830b8e28
	if !ctx.cr[0].eq {
	pc = 0x830B8E28; continue 'dispatch;
	}
	// 830B8E04: 554707FF  clrlwi. r7, r10, 0x1f
	ctx.r[7].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 830B8E08: 4182000C  beq 0x830b8e14
	if ctx.cr[0].eq {
	pc = 0x830B8E14; continue 'dispatch;
	}
	// 830B8E0C: 614A0300  ori r10, r10, 0x300
	ctx.r[10].u64 = ctx.r[10].u64 | 768;
	// 830B8E10: 914B0034  stw r10, 0x34(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(52 as u32), ctx.r[10].u32 ) };
	// 830B8E14: 814B0034  lwz r10, 0x34(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 830B8E18: 5547077B  rlwinm. r7, r10, 0, 0x1d, 0x1d
	ctx.r[7].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 830B8E1C: 4182000C  beq 0x830b8e28
	if ctx.cr[0].eq {
	pc = 0x830B8E28; continue 'dispatch;
	}
	// 830B8E20: 614A0C00  ori r10, r10, 0xc00
	ctx.r[10].u64 = ctx.r[10].u64 | 3072;
	// 830B8E24: 914B0034  stw r10, 0x34(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(52 as u32), ctx.r[10].u32 ) };
	// 830B8E28: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830B8E2C: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 830B8E30: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 830B8E34: 7F085800  cmpw cr6, r8, r11
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830B8E38: 4198FFB4  blt cr6, 0x830b8dec
	if ctx.cr[6].lt {
	pc = 0x830B8DEC; continue 'dispatch;
	}
	// 830B8E3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830B8E40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830B8E40 size=400
    let mut pc: u32 = 0x830B8E40;
    'dispatch: loop {
        match pc {
            0x830B8E40 => {
    //   block [0x830B8E40..0x830B8FD0)
	// 830B8E40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830B8E44: 480EF315  bl 0x831a8158
	ctx.lr = 0x830B8E48;
	sub_831A8130(ctx, base);
	// 830B8E48: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830B8E4C: 7D1E4378  mr r30, r8
	ctx.r[30].u64 = ctx.r[8].u64;
	// 830B8E50: 3D404350  lis r10, 0x4350
	ctx.r[10].s64 = 1129316352;
	// 830B8E54: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830B8E58: 614A4146  ori r10, r10, 0x4146
	ctx.r[10].u64 = ctx.r[10].u64 | 16710;
	// 830B8E5C: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 830B8E60: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830B8E64: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 830B8E68: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 830B8E6C: 7CF93B78  mr r25, r7
	ctx.r[25].u64 = ctx.r[7].u64;
	// 830B8E70: 7D3C4B78  mr r28, r9
	ctx.r[28].u64 = ctx.r[9].u64;
	// 830B8E74: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830B8E78: 409A0068  bne cr6, 0x830b8ee0
	if !ctx.cr[6].eq {
	pc = 0x830B8EE0; continue 'dispatch;
	}
	// 830B8E7C: 3D408218  lis r10, -0x7de8
	ctx.r[10].s64 = -2112356352;
	// 830B8E80: 839E0004  lwz r28, 4(r30)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830B8E84: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 830B8E88: 3B0A7670  addi r24, r10, 0x7670
	ctx.r[24].s64 = ctx.r[10].s64 + 30320;
	// 830B8E8C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830B8E90: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 830B8E94: 38A001FE  li r5, 0x1fe
	ctx.r[5].s64 = 510;
	// 830B8E98: 3BCB0004  addi r30, r11, 4
	ctx.r[30].s64 = ctx.r[11].s64 + 4;
	// 830B8E9C: 4BFFBDBD  bl 0x830b4c58
	ctx.lr = 0x830B8EA0;
	sub_830B4C58(ctx, base);
	// 830B8EA0: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 830B8EA4: 939B0000  stw r28, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 830B8EA8: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 830B8EAC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830B8EB0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830B8EB4: 480EF65D  bl 0x831a8510
	ctx.lr = 0x830B8EB8;
	sub_831A8510(ctx, base);
	// 830B8EB8: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 830B8EBC: 7F7CF02E  lwzx r27, r28, r30
	ctx.r[27].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 830B8EC0: 38A00207  li r5, 0x207
	ctx.r[5].s64 = 519;
	// 830B8EC4: 7FFCF214  add r31, r28, r30
	ctx.r[31].u64 = ctx.r[28].u64 + ctx.r[30].u64;
	// 830B8EC8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830B8ECC: 4BFFBD8D  bl 0x830b4c58
	ctx.lr = 0x830B8ED0;
	sub_830B4C58(ctx, base);
	// 830B8ED0: 907D0000  stw r3, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 830B8ED4: 937A0000  stw r27, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 830B8ED8: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 830B8EDC: 48000098  b 0x830b8f74
	pc = 0x830B8F74; continue 'dispatch;
	// 830B8EE0: 3D404641  lis r10, 0x4641
	ctx.r[10].s64 = 1178664960;
	// 830B8EE4: 614A5043  ori r10, r10, 0x5043
	ctx.r[10].u64 = ctx.r[10].u64 | 20547;
	// 830B8EE8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830B8EEC: 409A00A0  bne cr6, 0x830b8f8c
	if !ctx.cr[6].eq {
	pc = 0x830B8F8C; continue 'dispatch;
	}
	// 830B8EF0: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830B8EF4: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 830B8EF8: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 830B8EFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830B8F00: 3BCB0004  addi r30, r11, 4
	ctx.r[30].s64 = ctx.r[11].s64 + 4;
	// 830B8F04: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 830B8F08: 480067C9  bl 0x830bf6d0
	ctx.lr = 0x830B8F0C;
	sub_830BF6D0(ctx, base);
	// 830B8F0C: 3D608218  lis r11, -0x7de8
	ctx.r[11].s64 = -2112356352;
	// 830B8F10: 38A00217  li r5, 0x217
	ctx.r[5].s64 = 535;
	// 830B8F14: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830B8F18: 3B8B7670  addi r28, r11, 0x7670
	ctx.r[28].s64 = ctx.r[11].s64 + 30320;
	// 830B8F1C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830B8F20: 4BFFBD39  bl 0x830b4c58
	ctx.lr = 0x830B8F24;
	sub_830B4C58(ctx, base);
	// 830B8F24: 80A10050  lwz r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830B8F28: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 830B8F2C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830B8F30: 90BB0000  stw r5, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 830B8F34: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830B8F38: 480EF5D9  bl 0x831a8510
	ctx.lr = 0x830B8F3C;
	sub_831A8510(ctx, base);
	// 830B8F3C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830B8F40: 7D4BF02E  lwzx r10, r11, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 830B8F44: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 830B8F48: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830B8F4C: 7FEBF214  add r31, r11, r30
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 830B8F50: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 830B8F54: 4800677D  bl 0x830bf6d0
	ctx.lr = 0x830B8F58;
	sub_830BF6D0(ctx, base);
	// 830B8F58: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830B8F5C: 38A00221  li r5, 0x221
	ctx.r[5].s64 = 545;
	// 830B8F60: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830B8F64: 4BFFBCF5  bl 0x830b4c58
	ctx.lr = 0x830B8F68;
	sub_830B4C58(ctx, base);
	// 830B8F68: 80A10050  lwz r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830B8F6C: 907D0000  stw r3, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 830B8F70: 90BA0000  stw r5, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 830B8F74: 389F0004  addi r4, r31, 4
	ctx.r[4].s64 = ctx.r[31].s64 + 4;
	// 830B8F78: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830B8F7C: 480EF595  bl 0x831a8510
	ctx.lr = 0x830B8F80;
	sub_831A8510(ctx, base);
	// 830B8F80: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830B8F84: 91790000  stw r11, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830B8F88: 48000040  b 0x830b8fc8
	pc = 0x830B8FC8; continue 'dispatch;
	// 830B8F8C: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 830B8F90: 3D608218  lis r11, -0x7de8
	ctx.r[11].s64 = -2112356352;
	// 830B8F94: 931D0000  stw r24, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 830B8F98: 38A0022B  li r5, 0x22b
	ctx.r[5].s64 = 555;
	// 830B8F9C: 388B7670  addi r4, r11, 0x7670
	ctx.r[4].s64 = ctx.r[11].s64 + 30320;
	// 830B8FA0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830B8FA4: 4BFFBCB5  bl 0x830b4c58
	ctx.lr = 0x830B8FA8;
	sub_830B4C58(ctx, base);
	// 830B8FA8: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 830B8FAC: 939B0000  stw r28, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 830B8FB0: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 830B8FB4: 931A0000  stw r24, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 830B8FB8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830B8FBC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830B8FC0: 480EF551  bl 0x831a8510
	ctx.lr = 0x830B8FC4;
	sub_831A8510(ctx, base);
	// 830B8FC4: 93190000  stw r24, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 830B8FC8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830B8FCC: 480EF1DC  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830B8FD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830B8FD0 size=16
    let mut pc: u32 = 0x830B8FD0;
    'dispatch: loop {
        match pc {
            0x830B8FD0 => {
    //   block [0x830B8FD0..0x830B8FE0)
	// 830B8FD0: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 830B8FD4: 39440010  addi r10, r4, 0x10
	ctx.r[10].s64 = ctx.r[4].s64 + 16;
	// 830B8FD8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830B8FDC: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830B8FE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830B8FE0 size=36
    let mut pc: u32 = 0x830B8FE0;
    'dispatch: loop {
        match pc {
            0x830B8FE0 => {
    //   block [0x830B8FE0..0x830B9004)
	// 830B8FE0: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830B8FE4: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830B8FE8: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 830B8FEC: 5529003A  rlwinm r9, r9, 0, 0, 0x1d
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 830B8FF0: 7D09182E  lwzx r8, r9, r3
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 830B8FF4: 7D081A14  add r8, r8, r3
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[3].u64;
	// 830B8FF8: 7D09192E  stwx r8, r9, r3
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[3].u32), ctx.r[8].u32) };
	// 830B8FFC: 4082FFE4  bne 0x830b8fe0
	if !ctx.cr[0].eq {
	pc = 0x830B8FE0; continue 'dispatch;
	}
	// 830B9000: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830B9008(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830B9008 size=84
    let mut pc: u32 = 0x830B9008;
    'dispatch: loop {
        match pc {
            0x830B9008 => {
    //   block [0x830B9008..0x830B905C)
	// 830B9008: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830B900C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830B9010: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830B9014: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830B9018: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830B901C: 81640024  lwz r11, 0x24(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(36 as u32) ) } as u64;
	// 830B9020: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830B9024: 40990028  ble cr6, 0x830b904c
	if !ctx.cr[6].gt {
	pc = 0x830B904C; continue 'dispatch;
	}
	// 830B9028: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830B902C: 81640028  lwz r11, 0x28(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(40 as u32) ) } as u64;
	// 830B9030: 7C665A14  add r3, r6, r11
	ctx.r[3].u64 = ctx.r[6].u64 + ctx.r[11].u64;
	// 830B9034: 4BFFFDA5  bl 0x830b8dd8
	ctx.lr = 0x830B9038;
	sub_830B8DD8(ctx, base);
	// 830B9038: 81640024  lwz r11, 0x24(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(36 as u32) ) } as u64;
	// 830B903C: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 830B9040: 38C60010  addi r6, r6, 0x10
	ctx.r[6].s64 = ctx.r[6].s64 + 16;
	// 830B9044: 7F055800  cmpw cr6, r5, r11
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830B9048: 4198FFE4  blt cr6, 0x830b902c
	if ctx.cr[6].lt {
	pc = 0x830B902C; continue 'dispatch;
	}
	// 830B904C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830B9050: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830B9054: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830B9058: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830B9060(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830B9060 size=272
    let mut pc: u32 = 0x830B9060;
    'dispatch: loop {
        match pc {
            0x830B9060 => {
    //   block [0x830B9060..0x830B9170)
	// 830B9060: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830B9064: 480EF0FD  bl 0x831a8160
	ctx.lr = 0x830B9068;
	sub_831A8130(ctx, base);
	// 830B9068: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830B906C: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 830B9070: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 830B9074: 419A00F4  beq cr6, 0x830b9168
	if ctx.cr[6].eq {
	pc = 0x830B9168; continue 'dispatch;
	}
	// 830B9078: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830B907C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830B9080: 93DA0000  stw r30, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 830B9084: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830B9088: 816BBD00  lwz r11, -0x4300(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17152 as u32) ) } as u64;
	// 830B908C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830B9090: 409A00D8  bne cr6, 0x830b9168
	if !ctx.cr[6].eq {
	pc = 0x830B9168; continue 'dispatch;
	}
	// 830B9094: 81640014  lwz r11, 0x14(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 830B9098: 8144000C  lwz r10, 0xc(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 830B909C: 7D6B2214  add r11, r11, r4
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 830B90A0: 83A40008  lwz r29, 8(r4)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 830B90A4: 7FEA2214  add r31, r10, r4
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[4].u64;
	// 830B90A8: 394B0010  addi r10, r11, 0x10
	ctx.r[10].s64 = ctx.r[11].s64 + 16;
	// 830B90AC: 7FFBFB78  mr r27, r31
	ctx.r[27].u64 = ctx.r[31].u64;
	// 830B90B0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830B90B4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830B90B8: 40990024  ble cr6, 0x830b90dc
	if !ctx.cr[6].gt {
	pc = 0x830B90DC; continue 'dispatch;
	}
	// 830B90BC: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830B90C0: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830B90C4: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 830B90C8: 5529003A  rlwinm r9, r9, 0, 0, 0x1d
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 830B90CC: 7D09F82E  lwzx r8, r9, r31
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 830B90D0: 7D08FA14  add r8, r8, r31
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[31].u64;
	// 830B90D4: 7D09F92E  stwx r8, r9, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[31].u32), ctx.r[8].u32) };
	// 830B90D8: 4082FFE4  bne 0x830b90bc
	if !ctx.cr[0].eq {
	pc = 0x830B90BC; continue 'dispatch;
	}
	// 830B90DC: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830B90E0: 40990088  ble cr6, 0x830b9168
	if !ctx.cr[6].gt {
	pc = 0x830B9168; continue 'dispatch;
	}
	// 830B90E4: 3F808339  lis r28, -0x7cc7
	ctx.r[28].s64 = -2093416448;
	// 830B90E8: 3D406E43  lis r10, 0x6e43
	ctx.r[10].s64 = 1849884672;
	// 830B90EC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830B90F0: 614A504A  ori r10, r10, 0x504a
	ctx.r[10].u64 = ctx.r[10].u64 | 20554;
	// 830B90F4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830B90F8: 409A0014  bne cr6, 0x830b910c
	if !ctx.cr[6].eq {
	pc = 0x830B910C; continue 'dispatch;
	}
	// 830B90FC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830B9100: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 830B9104: 917A0000  stw r11, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830B9108: 48000010  b 0x830b9118
	pc = 0x830B9118; continue 'dispatch;
	// 830B910C: 815CBD08  lwz r10, -0x42f8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-17144 as u32) ) } as u64;
	// 830B9110: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830B9114: 419A0054  beq cr6, 0x830b9168
	if ctx.cr[6].eq {
	pc = 0x830B9168; continue 'dispatch;
	}
	// 830B9118: 4BFFF9E9  bl 0x830b8b00
	ctx.lr = 0x830B911C;
	sub_830B8B00(ctx, base);
	// 830B911C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830B9120: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830B9124: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830B9128: 4E800421  bctrl
	ctx.lr = 0x830B912C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830B912C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830B9130: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830B9134: 41820020  beq 0x830b9154
	if ctx.cr[0].eq {
	pc = 0x830B9154; continue 'dispatch;
	}
	// 830B9138: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 830B913C: 895F0004  lbz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830B9140: 7D684670  srawi r8, r11, 8
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 8) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[11].s32 >> 8) as i64;
	// 830B9144: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 830B9148: 5128401E  rlwimi r8, r9, 8, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[9].u32).rotate_left(8) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 830B914C: 550B002E  rlwinm r11, r8, 0, 0, 0x17
	ctx.r[11].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	// 830B9150: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 830B9154: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 830B9158: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 830B915C: 3BEB0008  addi r31, r11, 8
	ctx.r[31].s64 = ctx.r[11].s64 + 8;
	// 830B9160: 7F1EE800  cmpw cr6, r30, r29
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[29].s32, &mut ctx.xer);
	// 830B9164: 4198FF84  blt cr6, 0x830b90e8
	if ctx.cr[6].lt {
	pc = 0x830B90E8; continue 'dispatch;
	}
	// 830B9168: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830B916C: 480EF044  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830B9170(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830B9170 size=128
    let mut pc: u32 = 0x830B9170;
    'dispatch: loop {
        match pc {
            0x830B9170 => {
    //   block [0x830B9170..0x830B91F0)
	// 830B9170: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830B9174: 480EEFF9  bl 0x831a816c
	ctx.lr = 0x830B9178;
	sub_831A8130(ctx, base);
	// 830B9178: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830B917C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830B9180: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830B9184: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830B9188: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830B918C: 40990028  ble cr6, 0x830b91b4
	if !ctx.cr[6].gt {
	pc = 0x830B91B4; continue 'dispatch;
	}
	// 830B9190: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830B9194: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830B9198: 7C7E582E  lwzx r3, r30, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830B919C: 4BFFFE6D  bl 0x830b9008
	ctx.lr = 0x830B91A0;
	sub_830B9008(ctx, base);
	// 830B91A0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830B91A4: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 830B91A8: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 830B91AC: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830B91B0: 4198FFE4  blt cr6, 0x830b9194
	if ctx.cr[6].lt {
	pc = 0x830B9194; continue 'dispatch;
	}
	// 830B91B4: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830B91B8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830B91BC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830B91C0: 40990028  ble cr6, 0x830b91e8
	if !ctx.cr[6].gt {
	pc = 0x830B91E8; continue 'dispatch;
	}
	// 830B91C4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830B91C8: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830B91CC: 7C6BF214  add r3, r11, r30
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 830B91D0: 4BFFFFA1  bl 0x830b9170
	ctx.lr = 0x830B91D4;
	sub_830B9170(ctx, base);
	// 830B91D4: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830B91D8: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 830B91DC: 3BDE0018  addi r30, r30, 0x18
	ctx.r[30].s64 = ctx.r[30].s64 + 24;
	// 830B91E0: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830B91E4: 4198FFE4  blt cr6, 0x830b91c8
	if ctx.cr[6].lt {
	pc = 0x830B91C8; continue 'dispatch;
	}
	// 830B91E8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830B91EC: 480EEFD0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830B91F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830B91F0 size=8
    let mut pc: u32 = 0x830B91F0;
    'dispatch: loop {
        match pc {
            0x830B91F0 => {
    //   block [0x830B91F0..0x830B91F8)
	// 830B91F0: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830B91F4: 4BFFFF7C  b 0x830b9170
	sub_830B9170(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830B91F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830B91F8 size=56
    let mut pc: u32 = 0x830B91F8;
    'dispatch: loop {
        match pc {
            0x830B91F8 => {
    //   block [0x830B91F8..0x830B9230)
	// 830B91F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830B91FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830B9200: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830B9204: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830B9208: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830B920C: 4BFFFE55  bl 0x830b9060
	ctx.lr = 0x830B9210;
	sub_830B9060(ctx, base);
	// 830B9210: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830B9214: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830B9218: 4BFFFF59  bl 0x830b9170
	ctx.lr = 0x830B921C;
	sub_830B9170(ctx, base);
	// 830B921C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830B9220: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830B9224: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830B9228: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830B922C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830B9230(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830B9230 size=60
    let mut pc: u32 = 0x830B9230;
    'dispatch: loop {
        match pc {
            0x830B9230 => {
    //   block [0x830B9230..0x830B926C)
	// 830B9230: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830B9234: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830B9238: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830B923C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830B9240: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830B9244: 480043C5  bl 0x830bd608
	ctx.lr = 0x830B9248;
	sub_830BD608(ctx, base);
	// 830B9248: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830B924C: 419A000C  beq cr6, 0x830b9258
	if ctx.cr[6].eq {
	pc = 0x830B9258; continue 'dispatch;
	}
	// 830B9250: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830B9254: 4BFFBA2D  bl 0x830b4c80
	ctx.lr = 0x830B9258;
	sub_830B4C80(ctx, base);
	// 830B9258: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830B925C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830B9260: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830B9264: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830B9268: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830B9270(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830B9270 size=84
    let mut pc: u32 = 0x830B9270;
    'dispatch: loop {
        match pc {
            0x830B9270 => {
    //   block [0x830B9270..0x830B92C4)
	// 830B9270: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830B9274: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830B9278: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830B927C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830B9280: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830B9284: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830B9288: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 830B928C: 4BFF8D0D  bl 0x830b1f98
	ctx.lr = 0x830B9290;
	sub_830B1F98(ctx, base);
	// 830B9290: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830B9294: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830B9298: 419A0014  beq cr6, 0x830b92ac
	if ctx.cr[6].eq {
	pc = 0x830B92AC; continue 'dispatch;
	}
	// 830B929C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830B92A0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830B92A4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830B92A8: 4BFF8C01  bl 0x830b1ea8
	ctx.lr = 0x830B92AC;
	sub_830B1EA8(ctx, base);
	// 830B92AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830B92B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830B92B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830B92B8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830B92BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830B92C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830B92C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830B92C8 size=132
    let mut pc: u32 = 0x830B92C8;
    'dispatch: loop {
        match pc {
            0x830B92C8 => {
    //   block [0x830B92C8..0x830B934C)
	// 830B92C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830B92CC: 480EEE9D  bl 0x831a8168
	ctx.lr = 0x830B92D0;
	sub_831A8130(ctx, base);
	// 830B92D0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830B92D4: 83E3000C  lwz r31, 0xc(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 830B92D8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830B92DC: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 830B92E0: 807F0044  lwz r3, 0x44(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 830B92E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830B92E8: 419A0010  beq cr6, 0x830b92f8
	if ctx.cr[6].eq {
	pc = 0x830B92F8; continue 'dispatch;
	}
	// 830B92EC: 4BFFB995  bl 0x830b4c80
	ctx.lr = 0x830B92F0;
	sub_830B4C80(ctx, base);
	// 830B92F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830B92F4: 917F0044  stw r11, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[11].u32 ) };
	// 830B92F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830B92FC: 809D000C  lwz r4, 0xc(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 830B9300: 480044C9  bl 0x830bd7c8
	ctx.lr = 0x830B9304;
	sub_830BD7C8(ctx, base);
	// 830B9304: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830B9308: 4081001C  ble 0x830b9324
	if !ctx.cr[0].gt {
	pc = 0x830B9324; continue 'dispatch;
	}
	// 830B930C: 3D608218  lis r11, -0x7de8
	ctx.r[11].s64 = -2112356352;
	// 830B9310: 38A00064  li r5, 0x64
	ctx.r[5].s64 = 100;
	// 830B9314: 388B7694  addi r4, r11, 0x7694
	ctx.r[4].s64 = ctx.r[11].s64 + 30356;
	// 830B9318: 1C7E0018  mulli r3, r30, 0x18
	ctx.r[3].s64 = ctx.r[30].s64 * 24;
	// 830B931C: 4BFFB93D  bl 0x830b4c58
	ctx.lr = 0x830B9320;
	sub_830B4C58(ctx, base);
	// 830B9320: 907F0044  stw r3, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[3].u32 ) };
	// 830B9324: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830B9328: 807F0044  lwz r3, 0x44(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 830B932C: 48004235  bl 0x830bd560
	ctx.lr = 0x830B9330;
	sub_830BD560(ctx, base);
	// 830B9330: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830B9334: 80BC000C  lwz r5, 0xc(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 830B9338: 809D000C  lwz r4, 0xc(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 830B933C: 4800464D  bl 0x830bd988
	ctx.lr = 0x830B9340;
	sub_830BD988(ctx, base);
	// 830B9340: 48004241  bl 0x830bd580
	ctx.lr = 0x830B9344;
	sub_830BD580(ctx, base);
	// 830B9344: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830B9348: 480EEE70  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830B9350(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830B9350 size=128
    let mut pc: u32 = 0x830B9350;
    'dispatch: loop {
        match pc {
            0x830B9350 => {
    //   block [0x830B9350..0x830B93D0)
	// 830B9350: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830B9354: 480EEE15  bl 0x831a8168
	ctx.lr = 0x830B9358;
	sub_831A8130(ctx, base);
	// 830B9358: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830B935C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830B9360: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830B9364: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 830B9368: 4BFF9621  bl 0x830b2988
	ctx.lr = 0x830B936C;
	sub_830B2988(ctx, base);
	// 830B936C: 3D608218  lis r11, -0x7de8
	ctx.r[11].s64 = -2112356352;
	// 830B9370: 3BDF001C  addi r30, r31, 0x1c
	ctx.r[30].s64 = ctx.r[31].s64 + 28;
	// 830B9374: 396B7540  addi r11, r11, 0x7540
	ctx.r[11].s64 = ctx.r[11].s64 + 30016;
	// 830B9378: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830B937C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830B9380: 4BFF8B41  bl 0x830b1ec0
	ctx.lr = 0x830B9384;
	sub_830B1EC0(ctx, base);
	// 830B9384: 3D608218  lis r11, -0x7de8
	ctx.r[11].s64 = -2112356352;
	// 830B9388: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830B938C: 396B74C0  addi r11, r11, 0x74c0
	ctx.r[11].s64 = ctx.r[11].s64 + 29888;
	// 830B9390: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830B9394: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 830B9398: 4BFF8C01  bl 0x830b1f98
	ctx.lr = 0x830B939C;
	sub_830B1F98(ctx, base);
	// 830B939C: 3BDF0004  addi r30, r31, 4
	ctx.r[30].s64 = ctx.r[31].s64 + 4;
	// 830B93A0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830B93A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830B93A8: 4BFF8D09  bl 0x830b20b0
	ctx.lr = 0x830B93AC;
	sub_830B20B0(ctx, base);
	// 830B93AC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830B93B0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830B93B4: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 830B93B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830B93BC: 4BFF8C6D  bl 0x830b2028
	ctx.lr = 0x830B93C0;
	sub_830B2028(ctx, base);
	// 830B93C0: 93BF000C  stw r29, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 830B93C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830B93C8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830B93CC: 480EEDEC  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830B93D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830B93D0 size=128
    let mut pc: u32 = 0x830B93D0;
    'dispatch: loop {
        match pc {
            0x830B93D0 => {
    //   block [0x830B93D0..0x830B9450)
	// 830B93D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830B93D4: 480EED99  bl 0x831a816c
	ctx.lr = 0x830B93D8;
	sub_831A8130(ctx, base);
	// 830B93D8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830B93DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830B93E0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830B93E4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 830B93E8: 4BFF95A1  bl 0x830b2988
	ctx.lr = 0x830B93EC;
	sub_830B2988(ctx, base);
	// 830B93EC: 3D608218  lis r11, -0x7de8
	ctx.r[11].s64 = -2112356352;
	// 830B93F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830B93F4: 396B7548  addi r11, r11, 0x7548
	ctx.r[11].s64 = ctx.r[11].s64 + 30024;
	// 830B93F8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830B93FC: 48003925  bl 0x830bcd20
	ctx.lr = 0x830B9400;
	sub_830BCD20(ctx, base);
	// 830B9400: 3D608218  lis r11, -0x7de8
	ctx.r[11].s64 = -2112356352;
	// 830B9404: 38A00037  li r5, 0x37
	ctx.r[5].s64 = 55;
	// 830B9408: 388B7694  addi r4, r11, 0x7694
	ctx.r[4].s64 = ctx.r[11].s64 + 30356;
	// 830B940C: 4BFFB84D  bl 0x830b4c58
	ctx.lr = 0x830B9410;
	sub_830B4C58(ctx, base);
	// 830B9410: 3D60830C  lis r11, -0x7cf4
	ctx.r[11].s64 = -2096365568;
	// 830B9414: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 830B9418: 396B9230  addi r11, r11, -0x6dd0
	ctx.r[11].s64 = ctx.r[11].s64 + -28112;
	// 830B941C: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 830B9420: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 830B9424: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830B9428: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830B942C: 7D445378  mr r4, r10
	ctx.r[4].u64 = ctx.r[10].u64;
	// 830B9430: 4BFFFE41  bl 0x830b9270
	ctx.lr = 0x830B9434;
	sub_830B9270(ctx, base);
	// 830B9434: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830B9438: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830B943C: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830B9440: 48004611  bl 0x830bda50
	ctx.lr = 0x830B9444;
	sub_830BDA50(ctx, base);
	// 830B9444: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830B9448: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830B944C: 480EED70  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830B9450(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830B9450 size=60
    let mut pc: u32 = 0x830B9450;
    'dispatch: loop {
        match pc {
            0x830B9450 => {
    //   block [0x830B9450..0x830B948C)
	// 830B9450: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 830B9454: 81450004  lwz r10, 4(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 830B9458: 81250008  lwz r9, 8(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 830B945C: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 830B9460: 554A2036  slwi r10, r10, 4
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830B9464: 1D290144  mulli r9, r9, 0x144
	ctx.r[9].s64 = ctx.r[9].s64 * 324;
	// 830B9468: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830B946C: 81080004  lwz r8, 4(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 830B9470: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830B9474: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 830B9478: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 830B947C: 7C8A4A14  add r4, r10, r9
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 830B9480: 419A000C  beq cr6, 0x830b948c
	if ctx.cr[6].eq {
		sub_830B948C(ctx, base);
		return;
	}
	// 830B9484: 38AB0004  addi r5, r11, 4
	ctx.r[5].s64 = ctx.r[11].s64 + 4;
	// 830B9488: 4BFFFEC8  b 0x830b9350
	sub_830B9350(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830B948C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830B948C size=8
    let mut pc: u32 = 0x830B948C;
    'dispatch: loop {
        match pc {
            0x830B948C => {
    //   block [0x830B948C..0x830B9494)
	// 830B948C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830B9490: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830B9498(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830B9498 size=80
    let mut pc: u32 = 0x830B9498;
    'dispatch: loop {
        match pc {
            0x830B9498 => {
    //   block [0x830B9498..0x830B94E8)
	// 830B9498: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830B949C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830B94A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830B94A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830B94A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830B94AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830B94B0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830B94B4: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 830B94B8: 389F0004  addi r4, r31, 4
	ctx.r[4].s64 = ctx.r[31].s64 + 4;
	// 830B94BC: 4BFF8B6D  bl 0x830b2028
	ctx.lr = 0x830B94C0;
	sub_830B2028(ctx, base);
	// 830B94C0: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830B94C4: 917E000C  stw r11, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 830B94C8: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830B94CC: 917E0014  stw r11, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 830B94D0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830B94D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830B94D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830B94DC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830B94E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830B94E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830B94E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830B94E8 size=100
    let mut pc: u32 = 0x830B94E8;
    'dispatch: loop {
        match pc {
            0x830B94E8 => {
    //   block [0x830B94E8..0x830B954C)
	// 830B94E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830B94EC: 480EEC79  bl 0x831a8164
	ctx.lr = 0x830B94F0;
	sub_831A8130(ctx, base);
	// 830B94F0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830B94F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830B94F8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830B94FC: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 830B9500: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 830B9504: 4BFF9485  bl 0x830b2988
	ctx.lr = 0x830B9508;
	sub_830B2988(ctx, base);
	// 830B9508: 3D608218  lis r11, -0x7de8
	ctx.r[11].s64 = -2112356352;
	// 830B950C: 3BDF0004  addi r30, r31, 4
	ctx.r[30].s64 = ctx.r[31].s64 + 4;
	// 830B9510: 396B7538  addi r11, r11, 0x7538
	ctx.r[11].s64 = ctx.r[11].s64 + 30008;
	// 830B9514: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830B9518: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830B951C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830B9520: 4BFF8B91  bl 0x830b20b0
	ctx.lr = 0x830B9524;
	sub_830B20B0(ctx, base);
	// 830B9524: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830B9528: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830B952C: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 830B9530: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830B9534: 4BFF8AF5  bl 0x830b2028
	ctx.lr = 0x830B9538;
	sub_830B2028(ctx, base);
	// 830B9538: 93BF000C  stw r29, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 830B953C: 939F0014  stw r28, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[28].u32 ) };
	// 830B9540: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830B9544: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830B9548: 480EEC6C  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830B9550(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830B9550 size=88
    let mut pc: u32 = 0x830B9550;
    'dispatch: loop {
        match pc {
            0x830B9550 => {
    //   block [0x830B9550..0x830B95A8)
	// 830B9550: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830B9554: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830B9558: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830B955C: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 830B9560: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 830B9564: 3D40830C  lis r10, -0x7cf4
	ctx.r[10].s64 = -2096365568;
	// 830B9568: 80A30034  lwz r5, 0x34(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) } as u64;
	// 830B956C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 830B9570: 38C00008  li r6, 8
	ctx.r[6].s64 = 8;
	// 830B9574: 8083003C  lwz r4, 0x3c(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) } as u64;
	// 830B9578: 38EAB6F8  addi r7, r10, -0x4908
	ctx.r[7].s64 = ctx.r[10].s64 + -18696;
	// 830B957C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830B9580: 480F6B21  bl 0x831b00a0
	ctx.lr = 0x830B9584;
	sub_831B00A0(ctx, base);
	// 830B9584: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830B9588: 4182000C  beq 0x830b9594
	if ctx.cr[0].eq {
	pc = 0x830B9594; continue 'dispatch;
	}
	// 830B958C: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830B9590: 48000008  b 0x830b9598
	pc = 0x830B9598; continue 'dispatch;
	// 830B9594: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 830B9598: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830B959C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830B95A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830B95A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830B95A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830B95A8 size=28
    let mut pc: u32 = 0x830B95A8;
    'dispatch: loop {
        match pc {
            0x830B95A8 => {
    //   block [0x830B95A8..0x830B95C4)
	// 830B95A8: 81630094  lwz r11, 0x94(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(148 as u32) ) } as u64;
	// 830B95AC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830B95B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830B95B4: 81630088  lwz r11, 0x88(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(136 as u32) ) } as u64;
	// 830B95B8: 419A0050  beq cr6, 0x830b9608
	if ctx.cr[6].eq {
		sub_830B9608(ctx, base);
		return;
	}
	// 830B95BC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830B95C0: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830B95C4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830B95C4 size=68
    let mut pc: u32 = 0x830B95C4;
    'dispatch: loop {
        match pc {
            0x830B95C4 => {
    //   block [0x830B95C4..0x830B9608)
	// 830B95C4: 38E30048  addi r7, r3, 0x48
	ctx.r[7].s64 = ctx.r[3].s64 + 72;
	// 830B95C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830B95CC: 7CE93B78  mr r9, r7
	ctx.r[9].u64 = ctx.r[7].u64;
	// 830B95D0: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 830B95D4: 8103008C  lwz r8, 0x8c(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 830B95D8: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830B95DC: 80A90000  lwz r5, 0(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 830B95E0: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 830B95E4: 7D085A14  add r8, r8, r11
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 830B95E8: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 830B95EC: 90A80008  stw r5, 8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	// 830B95F0: 4082FFE4  bne 0x830b95d4
	if !ctx.cr[0].eq {
	pc = 0x830B95D4; continue 'dispatch;
	}
	// 830B95F4: 81430088  lwz r10, 0x88(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(136 as u32) ) } as u64;
	// 830B95F8: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 830B95FC: 7F065000  cmpw cr6, r6, r10
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830B9600: 4198FFCC  blt cr6, 0x830b95cc
	if ctx.cr[6].lt {
	pc = 0x830B95CC; continue 'dispatch;
	}
	// 830B9604: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830B9608(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830B9608 size=8
    let mut pc: u32 = 0x830B9608;
    'dispatch: loop {
        match pc {
            0x830B9608 => {
    //   block [0x830B9608..0x830B9610)
	// 830B9608: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830B960C: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830B9610(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830B9610 size=68
    let mut pc: u32 = 0x830B9610;
    'dispatch: loop {
        match pc {
            0x830B9610 => {
    //   block [0x830B9610..0x830B9654)
	// 830B9610: 38E30048  addi r7, r3, 0x48
	ctx.r[7].s64 = ctx.r[3].s64 + 72;
	// 830B9614: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830B9618: 7CE93B78  mr r9, r7
	ctx.r[9].u64 = ctx.r[7].u64;
	// 830B961C: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 830B9620: 8103008C  lwz r8, 0x8c(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 830B9624: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830B9628: 80A90000  lwz r5, 0(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 830B962C: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 830B9630: 7D0B4214  add r8, r11, r8
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 830B9634: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 830B9638: 90A80008  stw r5, 8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	// 830B963C: 4082FFE4  bne 0x830b9620
	if !ctx.cr[0].eq {
	pc = 0x830B9620; continue 'dispatch;
	}
	// 830B9640: 81430088  lwz r10, 0x88(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(136 as u32) ) } as u64;
	// 830B9644: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 830B9648: 7F065000  cmpw cr6, r6, r10
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830B964C: 4198FFCC  blt cr6, 0x830b9618
	if ctx.cr[6].lt {
	pc = 0x830B9618; continue 'dispatch;
	}
	// 830B9650: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830B9658(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830B9658 size=308
    let mut pc: u32 = 0x830B9658;
    'dispatch: loop {
        match pc {
            0x830B9658 => {
    //   block [0x830B9658..0x830B978C)
	// 830B9658: FBC1FFF0  std r30, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[30].u64 ) };
	// 830B965C: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 830B9660: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 830B9664: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830B9668: 81430094  lwz r10, 0x94(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(148 as u32) ) } as u64;
	// 830B966C: 81230088  lwz r9, 0x88(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(136 as u32) ) } as u64;
	// 830B9670: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830B9674: 8143008C  lwz r10, 0x8c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 830B9678: 9161FFE4  stw r11, -0x1c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-28 as u32), ctx.r[11].u32 ) };
	// 830B967C: 81630090  lwz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 830B9680: 419A0084  beq cr6, 0x830b9704
	if ctx.cr[6].eq {
	pc = 0x830B9704; continue 'dispatch;
	}
	// 830B9684: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830B9688: 409900F8  ble cr6, 0x830b9780
	if !ctx.cr[6].gt {
	pc = 0x830B9780; continue 'dispatch;
	}
	// 830B968C: 7CCB5050  subf r6, r11, r10
	ctx.r[6].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 830B9690: 38EB0008  addi r7, r11, 8
	ctx.r[7].s64 = ctx.r[11].s64 + 8;
	// 830B9694: 7CE93B78  mr r9, r7
	ctx.r[9].u64 = ctx.r[7].u64;
	// 830B9698: 39000004  li r8, 4
	ctx.r[8].s64 = 4;
	// 830B969C: 38E70050  addi r7, r7, 0x50
	ctx.r[7].s64 = ctx.r[7].s64 + 80;
	// 830B96A0: 7D46482E  lwzx r10, r6, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 830B96A4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830B96A8: 9141FFE0  stw r10, -0x20(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[10].u32 ) };
	// 830B96AC: 3941FFE0  addi r10, r1, -0x20
	ctx.r[10].s64 = ctx.r[1].s64 + -32;
	// 830B96B0: 3881FFE4  addi r4, r1, -0x1c
	ctx.r[4].s64 = ctx.r[1].s64 + -28;
	// 830B96B4: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830B96B8: 3BE000FF  li r31, 0xff
	ctx.r[31].s64 = 255;
	// 830B96BC: 7C8B20AE  lbzx r4, r11, r4
	ctx.r[4].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 830B96C0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830B96C4: 8BCA0000  lbz r30, 0(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830B96C8: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 830B96CC: 7C84F1D6  mullw r4, r4, r30
	ctx.r[4].s64 = (ctx.r[4].s32 as i64) * (ctx.r[30].s32 as i64);
	// 830B96D0: 7C84FBD6  divw r4, r4, r31
	ctx.r[4].s32 = ctx.r[4].s32 / ctx.r[31].s32;
	// 830B96D4: 988A0000  stb r4, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[4].u8 ) };
	// 830B96D8: 4198FFD4  blt cr6, 0x830b96ac
	if ctx.cr[6].lt {
	pc = 0x830B96AC; continue 'dispatch;
	}
	// 830B96DC: 8161FFE0  lwz r11, -0x20(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) } as u64;
	// 830B96E0: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 830B96E4: 91690000  stw r11, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830B96E8: 39290014  addi r9, r9, 0x14
	ctx.r[9].s64 = ctx.r[9].s64 + 20;
	// 830B96EC: 4082FFB4  bne 0x830b96a0
	if !ctx.cr[0].eq {
	pc = 0x830B96A0; continue 'dispatch;
	}
	// 830B96F0: 81630088  lwz r11, 0x88(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(136 as u32) ) } as u64;
	// 830B96F4: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 830B96F8: 7F055800  cmpw cr6, r5, r11
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830B96FC: 4198FF98  blt cr6, 0x830b9694
	if ctx.cr[6].lt {
	pc = 0x830B9694; continue 'dispatch;
	}
	// 830B9700: 48000080  b 0x830b9780
	pc = 0x830B9780; continue 'dispatch;
	// 830B9704: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830B9708: 40990078  ble cr6, 0x830b9780
	if !ctx.cr[6].gt {
	pc = 0x830B9780; continue 'dispatch;
	}
	// 830B970C: 7CCB5050  subf r6, r11, r10
	ctx.r[6].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 830B9710: 38EB0008  addi r7, r11, 8
	ctx.r[7].s64 = ctx.r[11].s64 + 8;
	// 830B9714: 7CE93B78  mr r9, r7
	ctx.r[9].u64 = ctx.r[7].u64;
	// 830B9718: 39000004  li r8, 4
	ctx.r[8].s64 = 4;
	// 830B971C: 38E70030  addi r7, r7, 0x30
	ctx.r[7].s64 = ctx.r[7].s64 + 48;
	// 830B9720: 7D46482E  lwzx r10, r6, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 830B9724: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830B9728: 9141FFE0  stw r10, -0x20(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[10].u32 ) };
	// 830B972C: 3941FFE0  addi r10, r1, -0x20
	ctx.r[10].s64 = ctx.r[1].s64 + -32;
	// 830B9730: 3881FFE4  addi r4, r1, -0x1c
	ctx.r[4].s64 = ctx.r[1].s64 + -28;
	// 830B9734: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830B9738: 3BE000FF  li r31, 0xff
	ctx.r[31].s64 = 255;
	// 830B973C: 7C8B20AE  lbzx r4, r11, r4
	ctx.r[4].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 830B9740: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830B9744: 8BCA0000  lbz r30, 0(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830B9748: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 830B974C: 7C84F1D6  mullw r4, r4, r30
	ctx.r[4].s64 = (ctx.r[4].s32 as i64) * (ctx.r[30].s32 as i64);
	// 830B9750: 7C84FBD6  divw r4, r4, r31
	ctx.r[4].s32 = ctx.r[4].s32 / ctx.r[31].s32;
	// 830B9754: 988A0000  stb r4, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[4].u8 ) };
	// 830B9758: 4198FFD4  blt cr6, 0x830b972c
	if ctx.cr[6].lt {
	pc = 0x830B972C; continue 'dispatch;
	}
	// 830B975C: 8161FFE0  lwz r11, -0x20(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) } as u64;
	// 830B9760: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 830B9764: 91690000  stw r11, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830B9768: 3929000C  addi r9, r9, 0xc
	ctx.r[9].s64 = ctx.r[9].s64 + 12;
	// 830B976C: 4082FFB4  bne 0x830b9720
	if !ctx.cr[0].eq {
	pc = 0x830B9720; continue 'dispatch;
	}
	// 830B9770: 81630088  lwz r11, 0x88(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(136 as u32) ) } as u64;
	// 830B9774: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 830B9778: 7F055800  cmpw cr6, r5, r11
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830B977C: 4198FF98  blt cr6, 0x830b9714
	if ctx.cr[6].lt {
	pc = 0x830B9714; continue 'dispatch;
	}
	// 830B9780: EBC1FFF0  ld r30, -0x10(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830B9784: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 830B9788: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830B9790(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830B9790 size=44
    let mut pc: u32 = 0x830B9790;
    'dispatch: loop {
        match pc {
            0x830B9790 => {
    //   block [0x830B9790..0x830B97BC)
	// 830B9790: 81240004  lwz r9, 4(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 830B9794: 81050004  lwz r8, 4(r5)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 830B9798: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830B979C: 81450000  lwz r10, 0(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 830B97A0: 7D4B5051  subf. r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830B97A4: 9121FFD0  stw r9, -0x30(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[9].u32 ) };
	// 830B97A8: 9101FFD4  stw r8, -0x2c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-44 as u32), ctx.r[8].u32 ) };
	// 830B97AC: 41810010  bgt 0x830b97bc
	if ctx.cr[0].gt {
		sub_830B97BC(ctx, base);
		return;
	}
	// 830B97B0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830B97B4: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830B97B8: 48000034  b 0x830b97ec
	sub_830B97BC(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830B97BC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830B97BC size=164
    let mut pc: u32 = 0x830B97BC;
    'dispatch: loop {
        match pc {
            0x830B97BC => {
    //   block [0x830B97BC..0x830B9860)
	// 830B97BC: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 830B97C0: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 830B97C4: F941FFD8  std r10, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.r[10].u64 ) };
	// 830B97C8: C801FFD8  lfd f0, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 830B97CC: F961FFD8  std r11, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.r[11].u64 ) };
	// 830B97D0: C9A1FFD8  lfd f13, -0x28(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 830B97D4: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 830B97D8: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 830B97DC: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 830B97E0: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 830B97E4: EDA16828  fsubs f13, f1, f13
	ctx.f[13].f64 = (((ctx.f[1].f64 - ctx.f[13].f64) as f32) as f64);
	// 830B97E8: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 830B97EC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 830B97F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830B97F4: C1AA08A8  lfs f13, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830B97F8: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 830B97FC: 3941FFD0  addi r10, r1, -0x30
	ctx.r[10].s64 = ctx.r[1].s64 + -48;
	// 830B9800: 3921FFD4  addi r9, r1, -0x2c
	ctx.r[9].s64 = ctx.r[1].s64 + -44;
	// 830B9804: 3901FFD8  addi r8, r1, -0x28
	ctx.r[8].s64 = ctx.r[1].s64 + -40;
	// 830B9808: 7D4B50AE  lbzx r10, r11, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830B980C: 7D2B48AE  lbzx r9, r11, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 830B9810: F941FFE0  std r10, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[10].u64 ) };
	// 830B9814: C981FFE0  lfd f12, -0x20(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 830B9818: F921FFE8  std r9, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[9].u64 ) };
	// 830B981C: C961FFE8  lfd f11, -0x18(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830B9820: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 830B9824: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 830B9828: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 830B982C: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 830B9830: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 830B9834: ED8C5B7A  fmadds f12, f12, f13, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[13].f64 + ctx.f[11].f64) as f32) as f64);
	// 830B9838: FD80665E  fctidz f12, f12
	ctx.f[12].s64 = if ctx.f[12].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[12].f64.trunc() as i64 };
	// 830B983C: D981FFF0  stfd f12, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[12].u64 ) };
	// 830B9840: 8941FFF7  lbz r10, -9(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(-9 as u32) ) } as u64;
	// 830B9844: 7D4B41AE  stbx r10, r11, r8
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32), ctx.r[10].u8) };
	// 830B9848: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830B984C: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 830B9850: 4198FFAC  blt cr6, 0x830b97fc
	if ctx.cr[6].lt {
	pc = 0x830B97FC; continue 'dispatch;
	}
	// 830B9854: 8161FFD8  lwz r11, -0x28(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) } as u64;
	// 830B9858: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830B985C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830B9860(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830B9860 size=524
    let mut pc: u32 = 0x830B9860;
    'dispatch: loop {
        match pc {
            0x830B9860 => {
    //   block [0x830B9860..0x830B9A6C)
	// 830B9860: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830B9864: 480EE901  bl 0x831a8164
	ctx.lr = 0x830B9868;
	sub_831A8130(ctx, base);
	// 830B9868: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 830B986C: 480EF209  bl 0x831a8a74
	ctx.lr = 0x830B9870;
	sub_831A8A40(ctx, base);
	// 830B9870: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830B9874: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830B9878: FF600890  fmr f27, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[27].f64 = ctx.f[1].f64;
	// 830B987C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 830B9880: FFE01090  fmr f31, f2
	ctx.f[31].f64 = ctx.f[2].f64;
	// 830B9884: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830B9888: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 830B988C: 83FE0004  lwz r31, 4(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830B9890: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830B9894: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 830B9898: 4098000C  bge cr6, 0x830b98a4
	if !ctx.cr[6].lt {
	pc = 0x830B98A4; continue 'dispatch;
	}
	// 830B989C: D37B0000  stfs f27, 0(r27)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830B98A0: 480001B8  b 0x830b9a58
	pc = 0x830B9A58; continue 'dispatch;
	// 830B98A4: 2F1D0001  cmpwi cr6, r29, 1
	ctx.cr[6].compare_i32(ctx.r[29].s32, 1, &mut ctx.xer);
	// 830B98A8: 419A000C  beq cr6, 0x830b98b4
	if ctx.cr[6].eq {
	pc = 0x830B98B4; continue 'dispatch;
	}
	// 830B98AC: 2F1D0002  cmpwi cr6, r29, 2
	ctx.cr[6].compare_i32(ctx.r[29].s32, 2, &mut ctx.xer);
	// 830B98B0: 409AFFEC  bne cr6, 0x830b989c
	if !ctx.cr[6].eq {
	pc = 0x830B989C; continue 'dispatch;
	}
	// 830B98B4: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 830B98B8: 556B07BD  rlwinm. r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830B98BC: 4182016C  beq 0x830b9a28
	if ctx.cr[0].eq {
	pc = 0x830B9A28; continue 'dispatch;
	}
	// 830B98C0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 830B98C4: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 830B98C8: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 830B98CC: C38A08A8  lfs f28, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 830B98D0: FC00E090  fmr f0, f28
	ctx.f[0].f64 = ctx.f[28].f64;
	// 830B98D4: 409A0020  bne cr6, 0x830b98f4
	if !ctx.cr[6].eq {
	pc = 0x830B98F4; continue 'dispatch;
	}
	// 830B98D8: 2F1D0001  cmpwi cr6, r29, 1
	ctx.cr[6].compare_i32(ctx.r[29].s32, 1, &mut ctx.xer);
	// 830B98DC: 409A0010  bne cr6, 0x830b98ec
	if !ctx.cr[6].eq {
	pc = 0x830B98EC; continue 'dispatch;
	}
	// 830B98E0: C01C0000  lfs f0, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830B98E4: EC00D82A  fadds f0, f0, f27
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[27].f64) as f32) as f64;
	// 830B98E8: 48000164  b 0x830b9a4c
	pc = 0x830B9A4C; continue 'dispatch;
	// 830B98EC: C01C0004  lfs f0, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830B98F0: 4BFFFFF4  b 0x830b98e4
	pc = 0x830B98E4; continue 'dispatch;
	// 830B98F4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830B98F8: 409A00C8  bne cr6, 0x830b99c0
	if !ctx.cr[6].eq {
	pc = 0x830B99C0; continue 'dispatch;
	}
	// 830B98FC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830B9900: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 830B9904: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 830B9908: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830B990C: C00B001C  lfs f0, 0x1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830B9910: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 830B9914: C18A0018  lfs f12, 0x18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830B9918: C1AA0010  lfs f13, 0x10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830B991C: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 830B9920: FFE00210  fabs f31, f0
	ctx.f[31].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 830B9924: FFC06A10  fabs f30, f13
	ctx.f[30].u64 = ctx.f[13].u64 & !0x8000_0000_0000_0000u64;
	// 830B9928: 4BFFEA29  bl 0x830b8350
	ctx.lr = 0x830B992C;
	sub_830B8350(ctx, base);
	// 830B992C: FFA00890  fmr f29, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].f64 = ctx.f[1].f64;
	// 830B9930: 4BFFEA31  bl 0x830b8360
	ctx.lr = 0x830B9934;
	sub_830B8360(ctx, base);
	// 830B9934: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 830B9938: EC1E07F2  fmuls f0, f30, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[30].f64 * ctx.f[31].f64) as f32) as f64);
	// 830B993C: 815F0050  lwz r10, 0x50(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 830B9940: EDBD0072  fmuls f13, f29, f1
	ctx.f[13].f64 = (((ctx.f[29].f64 * ctx.f[1].f64) as f32) as f64);
	// 830B9944: 83FE0004  lwz r31, 4(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830B9948: 2F1D0001  cmpwi cr6, r29, 1
	ctx.cr[6].compare_i32(ctx.r[29].s32, 1, &mut ctx.xer);
	// 830B994C: 7D6B51D6  mullw r11, r11, r10
	ctx.r[11].s64 = (ctx.r[11].s32 as i64) * (ctx.r[10].s32 as i64);
	// 830B9950: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 830B9954: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 830B9958: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830B995C: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 830B9960: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 830B9964: EC0C0024  fdivs f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 / ctx.f[0].f64) as f32) as f64;
	// 830B9968: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 830B996C: EFA0002C  fsqrts f29, f0
	ctx.f[29].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 830B9970: 409A002C  bne cr6, 0x830b999c
	if !ctx.cr[6].eq {
	pc = 0x830B999C; continue 'dispatch;
	}
	// 830B9974: 4BFFE9DD  bl 0x830b8350
	ctx.lr = 0x830B9978;
	sub_830B8350(ctx, base);
	// 830B9978: E97F0052  lwa r11, 0x50(r31)
	ctx.r[11].s64 = (unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as i32) as i64;
	// 830B997C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 830B9980: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830B9984: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 830B9988: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 830B998C: EC00F824  fdivs f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[31].f64) as f32) as f64;
	// 830B9990: EC010024  fdivs f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 / ctx.f[0].f64) as f32) as f64;
	// 830B9994: EC1D0024  fdivs f0, f29, f0
	ctx.f[0].f64 = ((ctx.f[29].f64 / ctx.f[0].f64) as f32) as f64;
	// 830B9998: 48000030  b 0x830b99c8
	pc = 0x830B99C8; continue 'dispatch;
	// 830B999C: 4BFFE9C5  bl 0x830b8360
	ctx.lr = 0x830B99A0;
	sub_830B8360(ctx, base);
	// 830B99A0: E97F0056  lwa r11, 0x54(r31)
	ctx.r[11].s64 = (unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as i32) as i64;
	// 830B99A4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 830B99A8: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830B99AC: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 830B99B0: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 830B99B4: EC00F024  fdivs f0, f0, f30
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[30].f64) as f32) as f64;
	// 830B99B8: EC010024  fdivs f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 / ctx.f[0].f64) as f32) as f64;
	// 830B99BC: EC1D0024  fdivs f0, f29, f0
	ctx.f[0].f64 = ((ctx.f[29].f64 / ctx.f[0].f64) as f32) as f64;
	// 830B99C0: 2F1D0001  cmpwi cr6, r29, 1
	ctx.cr[6].compare_i32(ctx.r[29].s32, 1, &mut ctx.xer);
	// 830B99C4: 409A0034  bne cr6, 0x830b99f8
	if !ctx.cr[6].eq {
	pc = 0x830B99F8; continue 'dispatch;
	}
	// 830B99C8: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 830B99CC: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 830B99D0: 409A001C  bne cr6, 0x830b99ec
	if !ctx.cr[6].eq {
	pc = 0x830B99EC; continue 'dispatch;
	}
	// 830B99D4: 4BFFE98D  bl 0x830b8360
	ctx.lr = 0x830B99D8;
	sub_830B8360(ctx, base);
	// 830B99D8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830B99DC: C00B0040  lfs f0, 0x40(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830B99E0: EFE10032  fmuls f31, f1, f0
	ctx.f[31].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 830B99E4: 4BFFE96D  bl 0x830b8350
	ctx.lr = 0x830B99E8;
	sub_830B8350(ctx, base);
	// 830B99E8: EC1F0824  fdivs f0, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ((ctx.f[31].f64 / ctx.f[1].f64) as f32) as f64;
	// 830B99EC: C1BC0000  lfs f13, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830B99F0: EC006EFA  fmadds f0, f0, f27, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[27].f64 + ctx.f[13].f64) as f32) as f64);
	// 830B99F4: 48000058  b 0x830b9a4c
	pc = 0x830B9A4C; continue 'dispatch;
	// 830B99F8: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 830B99FC: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830B9A00: 409A0020  bne cr6, 0x830b9a20
	if !ctx.cr[6].eq {
	pc = 0x830B9A20; continue 'dispatch;
	}
	// 830B9A04: 4BFFE94D  bl 0x830b8350
	ctx.lr = 0x830B9A08;
	sub_830B8350(ctx, base);
	// 830B9A08: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830B9A0C: C00B0040  lfs f0, 0x40(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830B9A10: EC1C0024  fdivs f0, f28, f0
	ctx.f[0].f64 = ((ctx.f[28].f64 / ctx.f[0].f64) as f32) as f64;
	// 830B9A14: EFE10032  fmuls f31, f1, f0
	ctx.f[31].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 830B9A18: 4BFFE949  bl 0x830b8360
	ctx.lr = 0x830B9A1C;
	sub_830B8360(ctx, base);
	// 830B9A1C: EC1F0824  fdivs f0, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ((ctx.f[31].f64 / ctx.f[1].f64) as f32) as f64;
	// 830B9A20: C1BC0004  lfs f13, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830B9A24: 4BFFFFCC  b 0x830b99f0
	pc = 0x830B99F0; continue 'dispatch;
	// 830B9A28: 2F1D0001  cmpwi cr6, r29, 1
	ctx.cr[6].compare_i32(ctx.r[29].s32, 1, &mut ctx.xer);
	// 830B9A2C: 409A0010  bne cr6, 0x830b9a3c
	if !ctx.cr[6].eq {
	pc = 0x830B9A3C; continue 'dispatch;
	}
	// 830B9A30: 4BFFE921  bl 0x830b8350
	ctx.lr = 0x830B9A34;
	sub_830B8350(ctx, base);
	// 830B9A34: C1BC0000  lfs f13, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830B9A38: 4800000C  b 0x830b9a44
	pc = 0x830B9A44; continue 'dispatch;
	// 830B9A3C: 4BFFE925  bl 0x830b8360
	ctx.lr = 0x830B9A40;
	sub_830B8360(ctx, base);
	// 830B9A40: C1BC0004  lfs f13, 4(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830B9A44: EC1F0824  fdivs f0, f31, f1
	ctx.f[0].f64 = ((ctx.f[31].f64 / ctx.f[1].f64) as f32) as f64;
	// 830B9A48: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 830B9A4C: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 830B9A50: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830B9A54: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830B9A58: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830B9A5C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 830B9A60: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 830B9A64: 480EF05D  bl 0x831a8ac0
	ctx.lr = 0x830B9A68;
	sub_831A8A8C(ctx, base);
	// 830B9A68: 480EE74C  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830B9A70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830B9A70 size=96
    let mut pc: u32 = 0x830B9A70;
    'dispatch: loop {
        match pc {
            0x830B9A70 => {
    //   block [0x830B9A70..0x830B9AD0)
	// 830B9A70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830B9A74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830B9A78: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830B9A7C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830B9A80: 81660004  lwz r11, 4(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 830B9A84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830B9A88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830B9A8C: 409A0014  bne cr6, 0x830b9aa0
	if !ctx.cr[6].eq {
	pc = 0x830B9AA0; continue 'dispatch;
	}
	// 830B9A90: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 830B9A94: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830B9A98: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830B9A9C: 48000020  b 0x830b9abc
	pc = 0x830B9ABC; continue 'dispatch;
	// 830B9AA0: 81660004  lwz r11, 4(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 830B9AA4: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 830B9AA8: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 830B9AAC: C04B0008  lfs f2, 8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 830B9AB0: C02A0004  lfs f1, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830B9AB4: 4BFFFDAD  bl 0x830b9860
	ctx.lr = 0x830B9AB8;
	sub_830B9860(ctx, base);
	// 830B9AB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830B9ABC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830B9AC0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830B9AC4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830B9AC8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830B9ACC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830B9AD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830B9AD0 size=440
    let mut pc: u32 = 0x830B9AD0;
    'dispatch: loop {
        match pc {
            0x830B9AD0 => {
    //   block [0x830B9AD0..0x830B9C88)
	// 830B9AD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830B9AD4: 480EE695  bl 0x831a8168
	ctx.lr = 0x830B9AD8;
	sub_831A8130(ctx, base);
	// 830B9AD8: DBA1FFC0  stfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[29].u64 ) };
	// 830B9ADC: DBC1FFC8  stfd f30, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 830B9AE0: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 830B9AE4: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830B9AE8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830B9AEC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830B9AF0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830B9AF4: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 830B9AF8: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 830B9AFC: C3AB08A8  lfs f29, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 830B9B00: D3BD0000  stfs f29, 0(r29)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830B9B04: D3BE0000  stfs f29, 0(r30)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830B9B08: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830B9B0C: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 830B9B10: 41980164  blt cr6, 0x830b9c74
	if ctx.cr[6].lt {
	pc = 0x830B9C74; continue 'dispatch;
	}
	// 830B9B14: C1BF000C  lfs f13, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830B9B18: 815F0058  lwz r10, 0x58(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 830B9B1C: C01F001C  lfs f0, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830B9B20: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 830B9B24: C19F0018  lfs f12, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830B9B28: C1BF0010  lfs f13, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830B9B2C: 554A077B  rlwinm. r10, r10, 0, 0x1d, 0x1d
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830B9B30: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 830B9B34: FFE00210  fabs f31, f0
	ctx.f[31].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 830B9B38: FFC06A10  fabs f30, f13
	ctx.f[30].u64 = ctx.f[13].u64 & !0x8000_0000_0000_0000u64;
	// 830B9B3C: 418200F0  beq 0x830b9c2c
	if ctx.cr[0].eq {
	pc = 0x830B9C2C; continue 'dispatch;
	}
	// 830B9B40: 815F005C  lwz r10, 0x5c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 830B9B44: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 830B9B48: 41980008  blt cr6, 0x830b9b50
	if ctx.cr[6].lt {
	pc = 0x830B9B50; continue 'dispatch;
	}
	// 830B9B4C: 815F0070  lwz r10, 0x70(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 830B9B50: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 830B9B54: 41980048  blt cr6, 0x830b9b9c
	if ctx.cr[6].lt {
	pc = 0x830B9B9C; continue 'dispatch;
	}
	// 830B9B58: 419A0028  beq cr6, 0x830b9b80
	if ctx.cr[6].eq {
	pc = 0x830B9B80; continue 'dispatch;
	}
	// 830B9B5C: 2B0A0003  cmplwi cr6, r10, 3
	ctx.cr[6].compare_u32(ctx.r[10].u32, 3 as u32, &mut ctx.xer);
	// 830B9B60: 40980114  bge cr6, 0x830b9c74
	if !ctx.cr[6].lt {
	pc = 0x830B9C74; continue 'dispatch;
	}
	// 830B9B64: 4BFFE7FD  bl 0x830b8360
	ctx.lr = 0x830B9B68;
	sub_830B8360(ctx, base);
	// 830B9B68: C01C0040  lfs f0, 0x40(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(64 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830B9B6C: EFE10032  fmuls f31, f1, f0
	ctx.f[31].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 830B9B70: 4BFFE7E1  bl 0x830b8350
	ctx.lr = 0x830B9B74;
	sub_830B8350(ctx, base);
	// 830B9B74: EC1F0824  fdivs f0, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ((ctx.f[31].f64 / ctx.f[1].f64) as f32) as f64;
	// 830B9B78: D01D0000  stfs f0, 0(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830B9B7C: 480000F8  b 0x830b9c74
	pc = 0x830B9C74; continue 'dispatch;
	// 830B9B80: 4BFFE7D1  bl 0x830b8350
	ctx.lr = 0x830B9B84;
	sub_830B8350(ctx, base);
	// 830B9B84: C01C0040  lfs f0, 0x40(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(64 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830B9B88: EC1D0024  fdivs f0, f29, f0
	ctx.f[0].f64 = ((ctx.f[29].f64 / ctx.f[0].f64) as f32) as f64;
	// 830B9B8C: EFE10032  fmuls f31, f1, f0
	ctx.f[31].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 830B9B90: 4BFFE7D1  bl 0x830b8360
	ctx.lr = 0x830B9B94;
	sub_830B8360(ctx, base);
	// 830B9B94: EC1F0824  fdivs f0, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ((ctx.f[31].f64 / ctx.f[1].f64) as f32) as f64;
	// 830B9B98: 480000D8  b 0x830b9c70
	pc = 0x830B9C70; continue 'dispatch;
	// 830B9B9C: 4BFFE7B5  bl 0x830b8350
	ctx.lr = 0x830B9BA0;
	sub_830B8350(ctx, base);
	// 830B9BA0: FFA00890  fmr f29, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].f64 = ctx.f[1].f64;
	// 830B9BA4: 4BFFE7BD  bl 0x830b8360
	ctx.lr = 0x830B9BA8;
	sub_830B8360(ctx, base);
	// 830B9BA8: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 830B9BAC: 815F0050  lwz r10, 0x50(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 830B9BB0: EC1E07F2  fmuls f0, f30, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[30].f64 * ctx.f[31].f64) as f32) as f64);
	// 830B9BB4: EDBD0072  fmuls f13, f29, f1
	ctx.f[13].f64 = (((ctx.f[29].f64 * ctx.f[1].f64) as f32) as f64);
	// 830B9BB8: 7D6B51D6  mullw r11, r11, r10
	ctx.r[11].s64 = (ctx.r[11].s32 as i64) * (ctx.r[10].s32 as i64);
	// 830B9BBC: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 830B9BC0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 830B9BC4: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830B9BC8: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 830B9BCC: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 830B9BD0: EC0C0024  fdivs f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 / ctx.f[0].f64) as f32) as f64;
	// 830B9BD4: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 830B9BD8: EFA0002C  fsqrts f29, f0
	ctx.f[29].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 830B9BDC: 4BFFE775  bl 0x830b8350
	ctx.lr = 0x830B9BE0;
	sub_830B8350(ctx, base);
	// 830B9BE0: E97F0052  lwa r11, 0x50(r31)
	ctx.r[11].s64 = (unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as i32) as i64;
	// 830B9BE4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 830B9BE8: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830B9BEC: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 830B9BF0: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 830B9BF4: EC00F824  fdivs f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[31].f64) as f32) as f64;
	// 830B9BF8: EC010024  fdivs f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 / ctx.f[0].f64) as f32) as f64;
	// 830B9BFC: EC1D0024  fdivs f0, f29, f0
	ctx.f[0].f64 = ((ctx.f[29].f64 / ctx.f[0].f64) as f32) as f64;
	// 830B9C00: D01D0000  stfs f0, 0(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830B9C04: 4BFFE75D  bl 0x830b8360
	ctx.lr = 0x830B9C08;
	sub_830B8360(ctx, base);
	// 830B9C08: E97F0056  lwa r11, 0x54(r31)
	ctx.r[11].s64 = (unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as i32) as i64;
	// 830B9C0C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 830B9C10: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830B9C14: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 830B9C18: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 830B9C1C: EC00F024  fdivs f0, f0, f30
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[30].f64) as f32) as f64;
	// 830B9C20: EC010024  fdivs f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 / ctx.f[0].f64) as f32) as f64;
	// 830B9C24: EC1D0024  fdivs f0, f29, f0
	ctx.f[0].f64 = ((ctx.f[29].f64 / ctx.f[0].f64) as f32) as f64;
	// 830B9C28: 48000048  b 0x830b9c70
	pc = 0x830B9C70; continue 'dispatch;
	// 830B9C2C: E97F0052  lwa r11, 0x50(r31)
	ctx.r[11].s64 = (unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as i32) as i64;
	// 830B9C30: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 830B9C34: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830B9C38: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 830B9C3C: FFA00018  frsp f29, f0
	ctx.f[29].f64 = (ctx.f[0].f64 as f32) as f64;
	// 830B9C40: 4BFFE711  bl 0x830b8350
	ctx.lr = 0x830B9C44;
	sub_830B8350(ctx, base);
	// 830B9C44: EC1D0824  fdivs f0, f29, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ((ctx.f[29].f64 / ctx.f[1].f64) as f32) as f64;
	// 830B9C48: EC00F824  fdivs f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[31].f64) as f32) as f64;
	// 830B9C4C: D01D0000  stfs f0, 0(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830B9C50: E97F0056  lwa r11, 0x54(r31)
	ctx.r[11].s64 = (unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as i32) as i64;
	// 830B9C54: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 830B9C58: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830B9C5C: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 830B9C60: FFE00018  frsp f31, f0
	ctx.f[31].f64 = (ctx.f[0].f64 as f32) as f64;
	// 830B9C64: 4BFFE6FD  bl 0x830b8360
	ctx.lr = 0x830B9C68;
	sub_830B8360(ctx, base);
	// 830B9C68: EC1F0824  fdivs f0, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ((ctx.f[31].f64 / ctx.f[1].f64) as f32) as f64;
	// 830B9C6C: EC00F024  fdivs f0, f0, f30
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[30].f64) as f32) as f64;
	// 830B9C70: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830B9C74: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830B9C78: CBA1FFC0  lfd f29, -0x40(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 830B9C7C: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 830B9C80: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 830B9C84: 480EE534  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830B9C88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830B9C88 size=84
    let mut pc: u32 = 0x830B9C88;
    'dispatch: loop {
        match pc {
            0x830B9C88 => {
    //   block [0x830B9C88..0x830B9CDC)
	// 830B9C88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830B9C8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830B9C90: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830B9C94: 2F032710  cmpwi cr6, r3, 0x2710
	ctx.cr[6].compare_i32(ctx.r[3].s32, 10000, &mut ctx.xer);
	// 830B9C98: 40990014  ble cr6, 0x830b9cac
	if !ctx.cr[6].gt {
	pc = 0x830B9CAC; continue 'dispatch;
	}
	// 830B9C9C: 3D608218  lis r11, -0x7de8
	ctx.r[11].s64 = -2112356352;
	// 830B9CA0: 386B76C4  addi r3, r11, 0x76c4
	ctx.r[3].s64 = ctx.r[11].s64 + 30404;
	// 830B9CA4: 4BFFEEE5  bl 0x830b8b88
	ctx.lr = 0x830B9CA8;
	sub_830B8B88(ctx, base);
	// 830B9CA8: 48000000  b 0x830b9ca8
	pc = 0x830B9CA8; continue 'dispatch;
	// 830B9CAC: 1D642710  mulli r11, r4, 0x2710
	ctx.r[11].s64 = ctx.r[4].s64 * 10000;
	// 830B9CB0: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 830B9CB4: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 830B9CB8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 830B9CBC: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830B9CC0: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 830B9CC4: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 830B9CC8: EC20082A  fadds f1, f0, f1
	ctx.f[1].f64 = ((ctx.f[0].f64 + ctx.f[1].f64) as f32) as f64;
	// 830B9CCC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830B9CD0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830B9CD4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830B9CD8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830B9CE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830B9CE0 size=96
    let mut pc: u32 = 0x830B9CE0;
    'dispatch: loop {
        match pc {
            0x830B9CE0 => {
    //   block [0x830B9CE0..0x830B9D40)
	// 830B9CE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830B9CE4: 480EE489  bl 0x831a816c
	ctx.lr = 0x830B9CE8;
	sub_831A8130(ctx, base);
	// 830B9CE8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830B9CEC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830B9CF0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830B9CF4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830B9CF8: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 830B9CFC: 480F2345  bl 0x831ac040
	ctx.lr = 0x830B9D00;
	sub_831AC040(ctx, base);
	// 830B9D00: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830B9D04: 39602710  li r11, 0x2710
	ctx.r[11].s64 = 10000;
	// 830B9D08: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 830B9D0C: FDA00818  frsp f13, f1
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 830B9D10: D1BD0000  stfs f13, 0(r29)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830B9D14: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 830B9D18: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 830B9D1C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830B9D20: 7D2A5BD6  divw r9, r10, r11
	ctx.r[9].s32 = ctx.r[10].s32 / ctx.r[11].s32;
	// 830B9D24: 1D292710  mulli r9, r9, 0x2710
	ctx.r[9].s64 = ctx.r[9].s64 * 10000;
	// 830B9D28: 7D6A5BD6  divw r11, r10, r11
	ctx.r[11].s32 = ctx.r[10].s32 / ctx.r[11].s32;
	// 830B9D2C: 7D495050  subf r10, r9, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 830B9D30: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830B9D34: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830B9D38: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830B9D3C: 480EE480  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830B9D40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830B9D40 size=544
    let mut pc: u32 = 0x830B9D40;
    'dispatch: loop {
        match pc {
            0x830B9D40 => {
    //   block [0x830B9D40..0x830B9F60)
	// 830B9D40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830B9D44: 480EE415  bl 0x831a8158
	ctx.lr = 0x830B9D48;
	sub_831A8130(ctx, base);
	// 830B9D48: 3981FFB8  addi r12, r1, -0x48
	ctx.r[12].s64 = ctx.r[1].s64 + -72;
	// 830B9D4C: 480EED2D  bl 0x831a8a78
	ctx.lr = 0x830B9D50;
	sub_831A8A40(ctx, base);
	// 830B9D50: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830B9D54: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830B9D58: 3D608218  lis r11, -0x7de8
	ctx.r[11].s64 = -2112356352;
	// 830B9D5C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830B9D60: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 830B9D64: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830B9D68: C3EB750C  lfs f31, 0x750c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(29964 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 830B9D6C: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 830B9D70: 41980008  blt cr6, 0x830b9d78
	if ctx.cr[6].lt {
	pc = 0x830B9D78; continue 'dispatch;
	}
	// 830B9D74: C3FF0040  lfs f31, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 830B9D78: 4BFFE5B1  bl 0x830b8328
	ctx.lr = 0x830B9D7C;
	sub_830B8328(ctx, base);
	// 830B9D7C: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 830B9D80: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 830B9D84: EFFF0824  fdivs f31, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ((ctx.f[31].f64 / ctx.f[1].f64) as f32) as f64;
	// 830B9D88: 4BFFE661  bl 0x830b83e8
	ctx.lr = 0x830B9D8C;
	sub_830B83E8(ctx, base);
	// 830B9D8C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830B9D90: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 830B9D94: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830B9D98: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830B9D9C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 830B9DA0: C3CB08A8  lfs f30, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 830B9DA4: D3C10054  stfs f30, 0x54(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 830B9DA8: D3C10050  stfs f30, 0x50(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 830B9DAC: 4BFFFD25  bl 0x830b9ad0
	ctx.lr = 0x830B9DB0;
	sub_830B9AD0(ctx, base);
	// 830B9DB0: 817E0094  lwz r11, 0x94(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(148 as u32) ) } as u64;
	// 830B9DB4: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 830B9DB8: 815E0088  lwz r10, 0x88(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(136 as u32) ) } as u64;
	// 830B9DBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830B9DC0: C3BE0008  lfs f29, 8(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 830B9DC4: 835E008C  lwz r26, 0x8c(r30)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) } as u64;
	// 830B9DC8: C39E0014  lfs f28, 0x14(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 830B9DCC: 817E0090  lwz r11, 0x90(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(144 as u32) ) } as u64;
	// 830B9DD0: 419A00C4  beq cr6, 0x830b9e94
	if ctx.cr[6].eq {
	pc = 0x830B9E94; continue 'dispatch;
	}
	// 830B9DD4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830B9DD8: 40990178  ble cr6, 0x830b9f50
	if !ctx.cr[6].gt {
	pc = 0x830B9F50; continue 'dispatch;
	}
	// 830B9DDC: 7F6BD050  subf r27, r11, r26
	ctx.r[27].s64 = ctx.r[26].s64 - ctx.r[11].s64;
	// 830B9DE0: EFDEF824  fdivs f30, f30, f31
	ctx.f[30].f64 = ((ctx.f[30].f64 / ctx.f[31].f64) as f32) as f64;
	// 830B9DE4: 3B2B0004  addi r25, r11, 4
	ctx.r[25].s64 = ctx.r[11].s64 + 4;
	// 830B9DE8: 7F5CD378  mr r28, r26
	ctx.r[28].u64 = ctx.r[26].u64;
	// 830B9DEC: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 830B9DF0: 3BA00004  li r29, 4
	ctx.r[29].s64 = 4;
	// 830B9DF4: 3B5A0050  addi r26, r26, 0x50
	ctx.r[26].s64 = ctx.r[26].s64 + 80;
	// 830B9DF8: 3B390050  addi r25, r25, 0x50
	ctx.r[25].s64 = ctx.r[25].s64 + 80;
	// 830B9DFC: 7C1BFC2E  lfsx f0, r27, r31
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830B9E00: 387FFFFC  addi r3, r31, -4
	ctx.r[3].s64 = ctx.r[31].s64 + -4;
	// 830B9E04: EC1E0032  fmuls f0, f30, f0
	ctx.f[0].f64 = (((ctx.f[30].f64 * ctx.f[0].f64) as f32) as f64);
	// 830B9E08: 7C1BFD2E  stfsx f0, r27, r31
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[27].u32.wrapping_add(ctx.r[31].u32), tmp.u32) };
	// 830B9E0C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 830B9E10: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830B9E14: 48003F45  bl 0x830bdd58
	ctx.lr = 0x830B9E18;
	sub_830BDD58(ctx, base);
	// 830B9E18: C19F0000  lfs f12, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830B9E1C: ED8CE028  fsubs f12, f12, f28
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[28].f64) as f32) as f64);
	// 830B9E20: C17FFFFC  lfs f11, -4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830B9E24: C0010050  lfs f0, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830B9E28: ED6BE828  fsubs f11, f11, f29
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[29].f64) as f32) as f64);
	// 830B9E2C: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830B9E30: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830B9E34: 3B9C0014  addi r28, r28, 0x14
	ctx.r[28].s64 = ctx.r[28].s64 + 20;
	// 830B9E38: EC0CE03A  fmadds f0, f12, f0, f28
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[28].f64) as f32) as f64);
	// 830B9E3C: EDABEB7A  fmadds f13, f11, f13, f29
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[13].f64 + ctx.f[29].f64) as f32) as f64);
	// 830B9E40: D1BFFFFC  stfs f13, -4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 830B9E44: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 830B9E48: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830B9E4C: 7C1BFC2E  lfsx f0, r27, r31
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830B9E50: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 830B9E54: 7C1BFD2E  stfsx f0, r27, r31
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[27].u32.wrapping_add(ctx.r[31].u32), tmp.u32) };
	// 830B9E58: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830B9E5C: C1BFFFFC  lfs f13, -4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830B9E60: C1810058  lfs f12, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830B9E64: EDAD602A  fadds f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 830B9E68: D1BFFFFC  stfs f13, -4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 830B9E6C: C1A1005C  lfs f13, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830B9E70: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 830B9E74: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830B9E78: 3BFF0014  addi r31, r31, 0x14
	ctx.r[31].s64 = ctx.r[31].s64 + 20;
	// 830B9E7C: 4082FF80  bne 0x830b9dfc
	if !ctx.cr[0].eq {
	pc = 0x830B9DFC; continue 'dispatch;
	}
	// 830B9E80: 817E0088  lwz r11, 0x88(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(136 as u32) ) } as u64;
	// 830B9E84: 3B180001  addi r24, r24, 1
	ctx.r[24].s64 = ctx.r[24].s64 + 1;
	// 830B9E88: 7F185800  cmpw cr6, r24, r11
	ctx.cr[6].compare_i32(ctx.r[24].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830B9E8C: 4198FF5C  blt cr6, 0x830b9de8
	if ctx.cr[6].lt {
	pc = 0x830B9DE8; continue 'dispatch;
	}
	// 830B9E90: 480000C0  b 0x830b9f50
	pc = 0x830B9F50; continue 'dispatch;
	// 830B9E94: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830B9E98: 409900B8  ble cr6, 0x830b9f50
	if !ctx.cr[6].gt {
	pc = 0x830B9F50; continue 'dispatch;
	}
	// 830B9E9C: 7F6BD050  subf r27, r11, r26
	ctx.r[27].s64 = ctx.r[26].s64 - ctx.r[11].s64;
	// 830B9EA0: EFDEF824  fdivs f30, f30, f31
	ctx.f[30].f64 = ((ctx.f[30].f64 / ctx.f[31].f64) as f32) as f64;
	// 830B9EA4: 3B2B0004  addi r25, r11, 4
	ctx.r[25].s64 = ctx.r[11].s64 + 4;
	// 830B9EA8: 7F5CD378  mr r28, r26
	ctx.r[28].u64 = ctx.r[26].u64;
	// 830B9EAC: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 830B9EB0: 3BA00004  li r29, 4
	ctx.r[29].s64 = 4;
	// 830B9EB4: 3B5A0030  addi r26, r26, 0x30
	ctx.r[26].s64 = ctx.r[26].s64 + 48;
	// 830B9EB8: 3B390030  addi r25, r25, 0x30
	ctx.r[25].s64 = ctx.r[25].s64 + 48;
	// 830B9EBC: 7C1BFC2E  lfsx f0, r27, r31
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830B9EC0: 387FFFFC  addi r3, r31, -4
	ctx.r[3].s64 = ctx.r[31].s64 + -4;
	// 830B9EC4: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 830B9EC8: 7C1BFD2E  stfsx f0, r27, r31
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[27].u32.wrapping_add(ctx.r[31].u32), tmp.u32) };
	// 830B9ECC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 830B9ED0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830B9ED4: 48003E85  bl 0x830bdd58
	ctx.lr = 0x830B9ED8;
	sub_830BDD58(ctx, base);
	// 830B9ED8: C19F0000  lfs f12, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830B9EDC: ED8CE028  fsubs f12, f12, f28
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[28].f64) as f32) as f64);
	// 830B9EE0: C17FFFFC  lfs f11, -4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830B9EE4: C0010050  lfs f0, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830B9EE8: ED6BE828  fsubs f11, f11, f29
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[29].f64) as f32) as f64);
	// 830B9EEC: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830B9EF0: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830B9EF4: 3B9C000C  addi r28, r28, 0xc
	ctx.r[28].s64 = ctx.r[28].s64 + 12;
	// 830B9EF8: EC0CE03A  fmadds f0, f12, f0, f28
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[28].f64) as f32) as f64);
	// 830B9EFC: EDABEB7A  fmadds f13, f11, f13, f29
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[13].f64 + ctx.f[29].f64) as f32) as f64);
	// 830B9F00: D1BFFFFC  stfs f13, -4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 830B9F04: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 830B9F08: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830B9F0C: 7C1BFC2E  lfsx f0, r27, r31
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830B9F10: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 830B9F14: 7C1BFD2E  stfsx f0, r27, r31
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[27].u32.wrapping_add(ctx.r[31].u32), tmp.u32) };
	// 830B9F18: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830B9F1C: C1BFFFFC  lfs f13, -4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830B9F20: C1810058  lfs f12, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830B9F24: EDAD602A  fadds f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 830B9F28: D1BFFFFC  stfs f13, -4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 830B9F2C: C1A1005C  lfs f13, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830B9F30: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 830B9F34: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830B9F38: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 830B9F3C: 4082FF80  bne 0x830b9ebc
	if !ctx.cr[0].eq {
	pc = 0x830B9EBC; continue 'dispatch;
	}
	// 830B9F40: 817E0088  lwz r11, 0x88(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(136 as u32) ) } as u64;
	// 830B9F44: 3B180001  addi r24, r24, 1
	ctx.r[24].s64 = ctx.r[24].s64 + 1;
	// 830B9F48: 7F185800  cmpw cr6, r24, r11
	ctx.cr[6].compare_i32(ctx.r[24].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830B9F4C: 4198FF5C  blt cr6, 0x830b9ea8
	if ctx.cr[6].lt {
	pc = 0x830B9EA8; continue 'dispatch;
	}
	// 830B9F50: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 830B9F54: 3981FFB8  addi r12, r1, -0x48
	ctx.r[12].s64 = ctx.r[1].s64 + -72;
	// 830B9F58: 480EEB6D  bl 0x831a8ac4
	ctx.lr = 0x830B9F5C;
	sub_831A8A8C(ctx, base);
	// 830B9F5C: 480EE24C  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830B9F60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830B9F60 size=1152
    let mut pc: u32 = 0x830B9F60;
    'dispatch: loop {
        match pc {
            0x830B9F60 => {
    //   block [0x830B9F60..0x830BA3E0)
	// 830B9F60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830B9F64: 480EE201  bl 0x831a8164
	ctx.lr = 0x830B9F68;
	sub_831A8130(ctx, base);
	// 830B9F68: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 830B9F6C: 480EEB0D  bl 0x831a8a78
	ctx.lr = 0x830B9F70;
	sub_831A8A40(ctx, base);
	// 830B9F70: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830B9F74: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830B9F78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830B9F7C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830B9F80: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830B9F84: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830B9F88: 409A0448  bne cr6, 0x830ba3d0
	if !ctx.cr[6].eq {
	pc = 0x830BA3D0; continue 'dispatch;
	}
	// 830B9F8C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 830B9F90: C03F0040  lfs f1, 0x40(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830B9F94: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830B9F98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830B9F9C: 4BFFFD45  bl 0x830b9ce0
	ctx.lr = 0x830B9FA0;
	sub_830B9CE0(ctx, base);
	// 830B9FA0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830B9FA4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830B9FA8: 419802E0  blt cr6, 0x830ba288
	if ctx.cr[6].lt {
	pc = 0x830BA288; continue 'dispatch;
	}
	// 830B9FAC: 80FD003C  lwz r7, 0x3c(r29)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(60 as u32) ) } as u64;
	// 830B9FB0: 7F0B3800  cmpw cr6, r11, r7
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[7].s32, &mut ctx.xer);
	// 830B9FB4: 409802D4  bge cr6, 0x830ba288
	if !ctx.cr[6].lt {
	pc = 0x830BA288; continue 'dispatch;
	}
	// 830B9FB8: 813D0040  lwz r9, 0x40(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(64 as u32) ) } as u64;
	// 830B9FBC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830B9FC0: 7D6B482E  lwzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 830B9FC4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830B9FC8: 419802C0  blt cr6, 0x830ba288
	if ctx.cr[6].lt {
	pc = 0x830BA288; continue 'dispatch;
	}
	// 830B9FCC: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 830B9FD0: 815E0020  lwz r10, 0x20(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 830B9FD4: 1D0B0014  mulli r8, r11, 0x14
	ctx.r[8].s64 = ctx.r[11].s64 * 20;
	// 830B9FD8: C0010054  lfs f0, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830B9FDC: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830B9FE0: C1A608A4  lfs f13, 0x8a4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830B9FE4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830B9FE8: 7FC85214  add r30, r8, r10
	ctx.r[30].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 830B9FEC: 409A0020  bne cr6, 0x830ba00c
	if !ctx.cr[6].eq {
	pc = 0x830BA00C; continue 'dispatch;
	}
	// 830B9FF0: 7F0B3800  cmpw cr6, r11, r7
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[7].s32, &mut ctx.xer);
	// 830B9FF4: 41980018  blt cr6, 0x830ba00c
	if ctx.cr[6].lt {
	pc = 0x830BA00C; continue 'dispatch;
	}
	// 830B9FF8: E97E0004  ld r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	// 830B9FFC: E95E000C  ld r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	// 830BA000: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 830BA004: F9410068  std r10, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u64 ) };
	// 830BA008: 48000078  b 0x830ba080
	pc = 0x830BA080; continue 'dispatch;
	// 830BA00C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830BA010: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 830BA014: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 830BA018: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 830BA01C: 391E0008  addi r8, r30, 8
	ctx.r[8].s64 = ctx.r[30].s64 + 8;
	// 830BA020: 7D6B482E  lwzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 830BA024: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	// 830BA028: C1A608A8  lfs f13, 0x8a8(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830BA02C: 1D6B0014  mulli r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 * 20;
	// 830BA030: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 830BA034: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830BA038: 396A0004  addi r11, r10, 4
	ctx.r[11].s64 = ctx.r[10].s64 + 4;
	// 830BA03C: 7CCAF050  subf r6, r10, r30
	ctx.r[6].s64 = ctx.r[30].s64 - ctx.r[10].s64;
	// 830BA040: 7D4A2850  subf r10, r10, r5
	ctx.r[10].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 830BA044: C18B0000  lfs f12, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830BA048: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830BA04C: C1680000  lfs f11, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830BA050: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 830BA054: ED6B0372  fmuls f11, f11, f13
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 830BA058: 7D465C2E  lfsx f10, r6, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 830BA05C: C12B0004  lfs f9, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 830BA060: 39080008  addi r8, r8, 8
	ctx.r[8].s64 = ctx.r[8].s64 + 8;
	// 830BA064: ED8A637A  fmadds f12, f10, f13, f12
	ctx.f[12].f64 = (((ctx.f[10].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 830BA068: D1870000  stfs f12, 0(r7)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830BA06C: ED89583A  fmadds f12, f9, f0, f11
	ctx.f[12].f64 = (((ctx.f[9].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 830BA070: 7D8A5D2E  stfsx f12, r10, r11
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 830BA074: 38E70008  addi r7, r7, 8
	ctx.r[7].s64 = ctx.r[7].s64 + 8;
	// 830BA078: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 830BA07C: 4082FFC8  bne 0x830ba044
	if !ctx.cr[0].eq {
	pc = 0x830BA044; continue 'dispatch;
	}
	// 830BA080: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830BA084: 419A0204  beq cr6, 0x830ba288
	if ctx.cr[6].eq {
	pc = 0x830BA288; continue 'dispatch;
	}
	// 830BA088: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830BA08C: 480047B5  bl 0x830be840
	ctx.lr = 0x830BA090;
	sub_830BE840(ctx, base);
	// 830BA090: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830BA094: 41820010  beq 0x830ba0a4
	if ctx.cr[0].eq {
	pc = 0x830BA0A4; continue 'dispatch;
	}
	// 830BA098: C3A10060  lfs f29, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 830BA09C: C3810068  lfs f28, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 830BA0A0: 4800000C  b 0x830ba0ac
	pc = 0x830BA0AC; continue 'dispatch;
	// 830BA0A4: C3A10068  lfs f29, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 830BA0A8: C3810060  lfs f28, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 830BA0AC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830BA0B0: 480047A1  bl 0x830be850
	ctx.lr = 0x830BA0B4;
	sub_830BE850(ctx, base);
	// 830BA0B4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830BA0B8: 41820010  beq 0x830ba0c8
	if ctx.cr[0].eq {
	pc = 0x830BA0C8; continue 'dispatch;
	}
	// 830BA0BC: C3E10064  lfs f31, 0x64(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 830BA0C0: C3C1006C  lfs f30, 0x6c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 830BA0C4: 4800000C  b 0x830ba0d0
	pc = 0x830BA0D0; continue 'dispatch;
	// 830BA0C8: C3E1006C  lfs f31, 0x6c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 830BA0CC: C3C10064  lfs f30, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 830BA0D0: 807F008C  lwz r3, 0x8c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 830BA0D4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830BA0D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830BA0DC: 409A0028  bne cr6, 0x830ba104
	if !ctx.cr[6].eq {
	pc = 0x830BA104; continue 'dispatch;
	}
	// 830BA0E0: 397F0098  addi r11, r31, 0x98
	ctx.r[11].s64 = ctx.r[31].s64 + 152;
	// 830BA0E4: 395F00E8  addi r10, r31, 0xe8
	ctx.r[10].s64 = ctx.r[31].s64 + 232;
	// 830BA0E8: 917F008C  stw r11, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 830BA0EC: 393F0138  addi r9, r31, 0x138
	ctx.r[9].s64 = ctx.r[31].s64 + 312;
	// 830BA0F0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830BA0F4: 915F0090  stw r10, 0x90(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[10].u32 ) };
	// 830BA0F8: 913F0094  stw r9, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[9].u32 ) };
	// 830BA0FC: 917F0088  stw r11, 0x88(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 830BA100: 48000104  b 0x830ba204
	pc = 0x830BA204; continue 'dispatch;
	// 830BA104: 817F0094  lwz r11, 0x94(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 830BA108: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830BA10C: 409A00FC  bne cr6, 0x830ba208
	if !ctx.cr[6].eq {
	pc = 0x830BA208; continue 'dispatch;
	}
	// 830BA110: 817F0090  lwz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 830BA114: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 830BA118: 3920000C  li r9, 0xc
	ctx.r[9].s64 = 12;
	// 830BA11C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 830BA120: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BA124: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 830BA128: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 830BA12C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 830BA130: 4200FFF0  bdnz 0x830ba120
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x830BA120; continue 'dispatch;
	}
	// 830BA134: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 830BA138: 394100C0  addi r10, r1, 0xc0
	ctx.r[10].s64 = ctx.r[1].s64 + 192;
	// 830BA13C: 3920000C  li r9, 0xc
	ctx.r[9].s64 = 12;
	// 830BA140: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 830BA144: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BA148: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 830BA14C: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 830BA150: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 830BA154: 4200FFF0  bdnz 0x830ba144
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x830BA144; continue 'dispatch;
	}
	// 830BA158: 817F013C  lwz r11, 0x13c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 830BA15C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BA160: 419A0010  beq cr6, 0x830ba170
	if ctx.cr[6].eq {
	pc = 0x830BA170; continue 'dispatch;
	}
	// 830BA164: 4BFFAB1D  bl 0x830b4c80
	ctx.lr = 0x830BA168;
	sub_830B4C80(ctx, base);
	// 830BA168: 807F0090  lwz r3, 0x90(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 830BA16C: 4BFFAB15  bl 0x830b4c80
	ctx.lr = 0x830BA170;
	sub_830B4C80(ctx, base);
	// 830BA170: 397F0098  addi r11, r31, 0x98
	ctx.r[11].s64 = ctx.r[31].s64 + 152;
	// 830BA174: 395F00E8  addi r10, r31, 0xe8
	ctx.r[10].s64 = ctx.r[31].s64 + 232;
	// 830BA178: 393F0138  addi r9, r31, 0x138
	ctx.r[9].s64 = ctx.r[31].s64 + 312;
	// 830BA17C: 917F008C  stw r11, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 830BA180: 915F0090  stw r10, 0x90(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[10].u32 ) };
	// 830BA184: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 830BA188: 913F0094  stw r9, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[9].u32 ) };
	// 830BA18C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 830BA190: 392100C8  addi r9, r1, 0xc8
	ctx.r[9].s64 = ctx.r[1].s64 + 200;
	// 830BA194: 80FF008C  lwz r7, 0x8c(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 830BA198: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 830BA19C: 7D2B4A14  add r9, r11, r9
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 830BA1A0: 7CCA3A14  add r6, r10, r7
	ctx.r[6].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 830BA1A4: 7CAB4214  add r5, r11, r8
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 830BA1A8: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 830BA1AC: 7D0B402E  lwzx r8, r11, r8
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 830BA1B0: 8069FFF8  lwz r3, -8(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830BA1B4: 8389FFFC  lwz r28, -4(r9)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-4 as u32) ) } as u64;
	// 830BA1B8: 83690000  lwz r27, 0(r9)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BA1BC: 80A50004  lwz r5, 4(r5)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BA1C0: 7C8B202E  lwzx r4, r11, r4
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 830BA1C4: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 830BA1C8: 7C6A392E  stwx r3, r10, r7
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[7].u32), ctx.r[3].u32) };
	// 830BA1CC: 93860004  stw r28, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 830BA1D0: 2F0B0030  cmpwi cr6, r11, 0x30
	ctx.cr[6].compare_i32(ctx.r[11].s32, 48, &mut ctx.xer);
	// 830BA1D4: 813F008C  lwz r9, 0x8c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 830BA1D8: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 830BA1DC: 93690008  stw r27, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 830BA1E0: 813F0090  lwz r9, 0x90(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 830BA1E4: 7CEA4A14  add r7, r10, r9
	ctx.r[7].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 830BA1E8: 7D0A492E  stwx r8, r10, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), ctx.r[8].u32) };
	// 830BA1EC: 90A70004  stw r5, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 830BA1F0: 813F0090  lwz r9, 0x90(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 830BA1F4: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 830BA1F8: 394A0014  addi r10, r10, 0x14
	ctx.r[10].s64 = ctx.r[10].s64 + 20;
	// 830BA1FC: 90890008  stw r4, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 830BA200: 4198FF90  blt cr6, 0x830ba190
	if ctx.cr[6].lt {
	pc = 0x830BA190; continue 'dispatch;
	}
	// 830BA204: 93BF013C  stw r29, 0x13c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(316 as u32), ctx.r[29].u32 ) };
	// 830BA208: 815F0094  lwz r10, 0x94(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 830BA20C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 830BA210: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BA214: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 830BA218: 815F008C  lwz r10, 0x8c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 830BA21C: D38A000C  stfs f28, 0xc(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830BA220: 815F008C  lwz r10, 0x8c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 830BA224: D3CA0010  stfs f30, 0x10(r10)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 830BA228: 815F008C  lwz r10, 0x8c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 830BA22C: D38A0020  stfs f28, 0x20(r10)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 830BA230: 815F008C  lwz r10, 0x8c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 830BA234: D3EA0024  stfs f31, 0x24(r10)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 830BA238: 815F008C  lwz r10, 0x8c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 830BA23C: D3AA0034  stfs f29, 0x34(r10)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 830BA240: 815F008C  lwz r10, 0x8c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 830BA244: D3CA0038  stfs f30, 0x38(r10)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 830BA248: 815F008C  lwz r10, 0x8c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 830BA24C: D3AA0048  stfs f29, 0x48(r10)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 830BA250: 815F008C  lwz r10, 0x8c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 830BA254: D3EA004C  stfs f31, 0x4c(r10)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 830BA258: 813F008C  lwz r9, 0x8c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 830BA25C: 815F0090  lwz r10, 0x90(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 830BA260: 7D2B4A14  add r9, r11, r9
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 830BA264: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830BA268: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 830BA26C: 2F0B0050  cmpwi cr6, r11, 0x50
	ctx.cr[6].compare_i32(ctx.r[11].s32, 80, &mut ctx.xer);
	// 830BA270: 8109000C  lwz r8, 0xc(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 830BA274: 910A000C  stw r8, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 830BA278: 81290010  lwz r9, 0x10(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 830BA27C: 912A0010  stw r9, 0x10(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 830BA280: 4198FFD8  blt cr6, 0x830ba258
	if ctx.cr[6].lt {
	pc = 0x830BA258; continue 'dispatch;
	}
	// 830BA284: 4800014C  b 0x830ba3d0
	pc = 0x830BA3D0; continue 'dispatch;
	// 830BA288: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 830BA28C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830BA290: 409A0028  bne cr6, 0x830ba2b8
	if !ctx.cr[6].eq {
	pc = 0x830BA2B8; continue 'dispatch;
	}
	// 830BA294: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830BA298: 397F0098  addi r11, r31, 0x98
	ctx.r[11].s64 = ctx.r[31].s64 + 152;
	// 830BA29C: 395F00E8  addi r10, r31, 0xe8
	ctx.r[10].s64 = ctx.r[31].s64 + 232;
	// 830BA2A0: 93BF0094  stw r29, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[29].u32 ) };
	// 830BA2A4: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 830BA2A8: 917F008C  stw r11, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 830BA2AC: 915F0090  stw r10, 0x90(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[10].u32 ) };
	// 830BA2B0: 913F0088  stw r9, 0x88(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[9].u32 ) };
	// 830BA2B4: 48000118  b 0x830ba3cc
	pc = 0x830BA3CC; continue 'dispatch;
	// 830BA2B8: 807F0094  lwz r3, 0x94(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 830BA2BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830BA2C0: 419A0110  beq cr6, 0x830ba3d0
	if ctx.cr[6].eq {
	pc = 0x830BA3D0; continue 'dispatch;
	}
	// 830BA2C4: 817F013C  lwz r11, 0x13c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 830BA2C8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BA2CC: 419A0008  beq cr6, 0x830ba2d4
	if ctx.cr[6].eq {
	pc = 0x830BA2D4; continue 'dispatch;
	}
	// 830BA2D0: 4BFFA9B1  bl 0x830b4c80
	ctx.lr = 0x830BA2D4;
	sub_830B4C80(ctx, base);
	// 830BA2D4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830BA2D8: 807F008C  lwz r3, 0x8c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 830BA2DC: 815F0090  lwz r10, 0x90(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 830BA2E0: 392100C0  addi r9, r1, 0xc0
	ctx.r[9].s64 = ctx.r[1].s64 + 192;
	// 830BA2E4: 93BF0094  stw r29, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[29].u32 ) };
	// 830BA2E8: 39600014  li r11, 0x14
	ctx.r[11].s64 = 20;
	// 830BA2EC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830BA2F0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BA2F4: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 830BA2F8: 91690000  stw r11, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830BA2FC: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 830BA300: 4200FFF0  bdnz 0x830ba2f0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x830BA2F0; continue 'dispatch;
	}
	// 830BA304: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 830BA308: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 830BA30C: 39200014  li r9, 0x14
	ctx.r[9].s64 = 20;
	// 830BA310: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 830BA314: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BA318: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 830BA31C: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 830BA320: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 830BA324: 4200FFF0  bdnz 0x830ba314
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x830BA314; continue 'dispatch;
	}
	// 830BA328: 817F013C  lwz r11, 0x13c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 830BA32C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BA330: 419A0010  beq cr6, 0x830ba340
	if ctx.cr[6].eq {
	pc = 0x830BA340; continue 'dispatch;
	}
	// 830BA334: 4BFFA94D  bl 0x830b4c80
	ctx.lr = 0x830BA338;
	sub_830B4C80(ctx, base);
	// 830BA338: 807F0090  lwz r3, 0x90(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 830BA33C: 4BFFA945  bl 0x830b4c80
	ctx.lr = 0x830BA340;
	sub_830B4C80(ctx, base);
	// 830BA340: 397F0098  addi r11, r31, 0x98
	ctx.r[11].s64 = ctx.r[31].s64 + 152;
	// 830BA344: 393F00E8  addi r9, r31, 0xe8
	ctx.r[9].s64 = ctx.r[31].s64 + 232;
	// 830BA348: 917F008C  stw r11, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 830BA34C: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 830BA350: 913F0090  stw r9, 0x90(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[9].u32 ) };
	// 830BA354: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 830BA358: 39210078  addi r9, r1, 0x78
	ctx.r[9].s64 = ctx.r[1].s64 + 120;
	// 830BA35C: 80FF008C  lwz r7, 0x8c(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 830BA360: 390100C0  addi r8, r1, 0xc0
	ctx.r[8].s64 = ctx.r[1].s64 + 192;
	// 830BA364: 7D2B4A14  add r9, r11, r9
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 830BA368: 7CC75214  add r6, r7, r10
	ctx.r[6].u64 = ctx.r[7].u64 + ctx.r[10].u64;
	// 830BA36C: 7CAB4214  add r5, r11, r8
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 830BA370: 388100C8  addi r4, r1, 0xc8
	ctx.r[4].s64 = ctx.r[1].s64 + 200;
	// 830BA374: 7D0B402E  lwzx r8, r11, r8
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 830BA378: 8069FFF8  lwz r3, -8(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830BA37C: 83C9FFFC  lwz r30, -4(r9)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-4 as u32) ) } as u64;
	// 830BA380: 83890000  lwz r28, 0(r9)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BA384: 80A50004  lwz r5, 4(r5)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BA388: 7C8B202E  lwzx r4, r11, r4
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 830BA38C: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 830BA390: 7C67512E  stwx r3, r7, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[10].u32), ctx.r[3].u32) };
	// 830BA394: 93C60004  stw r30, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 830BA398: 2F0B0050  cmpwi cr6, r11, 0x50
	ctx.cr[6].compare_i32(ctx.r[11].s32, 80, &mut ctx.xer);
	// 830BA39C: 813F008C  lwz r9, 0x8c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 830BA3A0: 7D295214  add r9, r9, r10
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 830BA3A4: 93890008  stw r28, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 830BA3A8: 813F0090  lwz r9, 0x90(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 830BA3AC: 7CEA4A14  add r7, r10, r9
	ctx.r[7].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 830BA3B0: 7D0A492E  stwx r8, r10, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), ctx.r[8].u32) };
	// 830BA3B4: 90A70004  stw r5, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 830BA3B8: 813F0090  lwz r9, 0x90(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 830BA3BC: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 830BA3C0: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	// 830BA3C4: 90890008  stw r4, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 830BA3C8: 4198FF90  blt cr6, 0x830ba358
	if ctx.cr[6].lt {
	pc = 0x830BA358; continue 'dispatch;
	}
	// 830BA3CC: 93BF013C  stw r29, 0x13c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(316 as u32), ctx.r[29].u32 ) };
	// 830BA3D0: 38210160  addi r1, r1, 0x160
	ctx.r[1].s64 = ctx.r[1].s64 + 352;
	// 830BA3D4: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 830BA3D8: 480EE6ED  bl 0x831a8ac4
	ctx.lr = 0x830BA3DC;
	sub_831A8A8C(ctx, base);
	// 830BA3DC: 480EDDD8  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BA3E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830BA3E0 size=212
    let mut pc: u32 = 0x830BA3E0;
    'dispatch: loop {
        match pc {
            0x830BA3E0 => {
    //   block [0x830BA3E0..0x830BA4B4)
	// 830BA3E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BA3E4: 480EDD81  bl 0x831a8164
	ctx.lr = 0x830BA3E8;
	sub_831A8130(ctx, base);
	// 830BA3E8: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 830BA3EC: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BA3F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830BA3F4: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 830BA3F8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 830BA3FC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830BA400: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 830BA404: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 830BA408: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 830BA40C: 4BFFF665  bl 0x830b9a70
	ctx.lr = 0x830BA410;
	sub_830B9A70(ctx, base);
	// 830BA410: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 830BA414: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830BA418: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830BA41C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830BA420: 4BFFF651  bl 0x830b9a70
	ctx.lr = 0x830BA424;
	sub_830B9A70(ctx, base);
	// 830BA424: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BA428: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BA42C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BA430: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BA434: 7D295051  subf. r9, r9, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830BA438: 41810010  bgt 0x830ba448
	if ctx.cr[0].gt {
	pc = 0x830BA448; continue 'dispatch;
	}
	// 830BA43C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830BA440: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BA444: 4800003C  b 0x830ba480
	pc = 0x830BA480; continue 'dispatch;
	// 830BA448: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BA44C: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 830BA450: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 830BA454: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 830BA458: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 830BA45C: C8010058  lfd f0, 0x58(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 830BA460: F9410058  std r10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u64 ) };
	// 830BA464: C9A10058  lfd f13, 0x58(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 830BA468: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 830BA46C: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 830BA470: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 830BA474: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 830BA478: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 830BA47C: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 830BA480: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830BA484: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830BA488: ED8D0032  fmuls f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 830BA48C: C1610054  lfs f11, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830BA490: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830BA494: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BA498: C1AB08A8  lfs f13, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830BA49C: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 830BA4A0: EC0062FA  fmadds f0, f0, f11, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64 + ctx.f[12].f64) as f32) as f64);
	// 830BA4A4: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830BA4A8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830BA4AC: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 830BA4B0: 480EDD04  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BA4B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830BA4B8 size=292
    let mut pc: u32 = 0x830BA4B8;
    'dispatch: loop {
        match pc {
            0x830BA4B8 => {
    //   block [0x830BA4B8..0x830BA5DC)
	// 830BA4B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BA4BC: 480EDCA9  bl 0x831a8164
	ctx.lr = 0x830BA4C0;
	sub_831A8130(ctx, base);
	// 830BA4C0: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 830BA4C4: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BA4C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830BA4CC: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 830BA4D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830BA4D4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830BA4D8: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 830BA4DC: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 830BA4E0: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 830BA4E4: 4BFFF58D  bl 0x830b9a70
	ctx.lr = 0x830BA4E8;
	sub_830B9A70(ctx, base);
	// 830BA4E8: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 830BA4EC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830BA4F0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830BA4F4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 830BA4F8: 4BFFF579  bl 0x830b9a70
	ctx.lr = 0x830BA4FC;
	sub_830B9A70(ctx, base);
	// 830BA4FC: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BA500: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BA504: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BA508: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BA50C: 7D295051  subf. r9, r9, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830BA510: 41810010  bgt 0x830ba520
	if ctx.cr[0].gt {
	pc = 0x830BA520; continue 'dispatch;
	}
	// 830BA514: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 830BA518: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BA51C: 4800003C  b 0x830ba558
	pc = 0x830BA558; continue 'dispatch;
	// 830BA520: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BA524: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 830BA528: 7D0807B4  extsw r8, r8
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 830BA52C: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 830BA530: F9010058  std r8, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u64 ) };
	// 830BA534: C8010058  lfd f0, 0x58(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 830BA538: F9410058  std r10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u64 ) };
	// 830BA53C: C9A10058  lfd f13, 0x58(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 830BA540: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 830BA544: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 830BA548: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 830BA54C: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 830BA550: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 830BA554: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 830BA558: 7D2A07B4  extsw r10, r9
	ctx.r[10].s64 = ctx.r[9].s32 as i64;
	// 830BA55C: C14B000C  lfs f10, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 830BA560: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 830BA564: C16B0010  lfs f11, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830BA568: F9410058  std r10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u64 ) };
	// 830BA56C: C9A10058  lfd f13, 0x58(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 830BA570: FD206E9C  fcfid f9, f13
	ctx.f[9].f64 = (ctx.f[13].s64 as f64);
	// 830BA574: C1810050  lfs f12, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830BA578: C1A99524  lfs f13, -0x6adc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830BA57C: FD204818  frsp f9, f9
	ctx.f[9].f64 = (ctx.f[9].f64 as f32) as f64;
	// 830BA580: ED0A5B7A  fmadds f8, f10, f13, f11
	ctx.f[8].f64 = (((ctx.f[10].f64 * ctx.f[13].f64 + ctx.f[11].f64) as f32) as f64);
	// 830BA584: C0E10054  lfs f7, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 830BA588: ECE76028  fsubs f7, f7, f12
	ctx.f[7].f64 = (((ctx.f[7].f64 - ctx.f[12].f64) as f32) as f64);
	// 830BA58C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 830BA590: ECAB502A  fadds f5, f11, f10
	ctx.f[5].f64 = ((ctx.f[11].f64 + ctx.f[10].f64) as f32) as f64;
	// 830BA594: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830BA598: ECC00032  fmuls f6, f0, f0
	ctx.f[6].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 830BA59C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BA5A0: C16BA1C4  lfs f11, -0x5e3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830BA5A4: ED4902B2  fmuls f10, f9, f10
	ctx.f[10].f64 = (((ctx.f[9].f64 * ctx.f[10].f64) as f32) as f64);
	// 830BA5A8: ED080272  fmuls f8, f8, f9
	ctx.f[8].f64 = (((ctx.f[8].f64 * ctx.f[9].f64) as f32) as f64);
	// 830BA5AC: EDA70372  fmuls f13, f7, f13
	ctx.f[13].f64 = (((ctx.f[7].f64 * ctx.f[13].f64) as f32) as f64);
	// 830BA5B0: EC860032  fmuls f4, f6, f0
	ctx.f[4].f64 = (((ctx.f[6].f64 * ctx.f[0].f64) as f32) as f64);
	// 830BA5B4: ED6742F8  fmsubs f11, f7, f11, f8
	ctx.f[11].f64 = (((ctx.f[7].f64 * ctx.f[11].f64 - ctx.f[8].f64) as f32) as f64);
	// 830BA5B8: EDA56A78  fmsubs f13, f5, f9, f13
	ctx.f[13].f64 = (((ctx.f[5].f64 * ctx.f[9].f64 - ctx.f[13].f64) as f32) as f64);
	// 830BA5BC: ED6B01B2  fmuls f11, f11, f6
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[6].f64) as f32) as f64);
	// 830BA5C0: EDAD593A  fmadds f13, f13, f4, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[4].f64 + ctx.f[11].f64) as f32) as f64);
	// 830BA5C4: EC0A683A  fmadds f0, f10, f0, f13
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 830BA5C8: EC00602A  fadds f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 830BA5CC: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830BA5D0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830BA5D4: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 830BA5D8: 480EDBDC  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BA5E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830BA5E0 size=868
    let mut pc: u32 = 0x830BA5E0;
    'dispatch: loop {
        match pc {
            0x830BA5E0 => {
    //   block [0x830BA5E0..0x830BA944)
	// 830BA5E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BA5E4: 480EDB79  bl 0x831a815c
	ctx.lr = 0x830BA5E8;
	sub_831A8130(ctx, base);
	// 830BA5E8: DBC1FFB0  stfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 830BA5EC: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 830BA5F0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BA5F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830BA5F8: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 830BA5FC: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 830BA600: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 830BA604: 817E007C  lwz r11, 0x7c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(124 as u32) ) } as u64;
	// 830BA608: 833B0034  lwz r25, 0x34(r27)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(52 as u32) ) } as u64;
	// 830BA60C: 556B03DF  rlwinm. r11, r11, 0, 0xf, 0xf
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BA610: 41820284  beq 0x830ba894
	if ctx.cr[0].eq {
	pc = 0x830BA894; continue 'dispatch;
	}
	// 830BA614: 480049F5  bl 0x830bf008
	ctx.lr = 0x830BA618;
	sub_830BF008(ctx, base);
	// 830BA618: C01E002C  lfs f0, 0x2c(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BA61C: C1BE0030  lfs f13, 0x30(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830BA620: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830BA624: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 830BA628: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 830BA62C: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 830BA630: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830BA634: 4BFFDCC5  bl 0x830b82f8
	ctx.lr = 0x830BA638;
	sub_830B82F8(ctx, base);
	// 830BA638: 3D608218  lis r11, -0x7de8
	ctx.r[11].s64 = -2112356352;
	// 830BA63C: C3EB750C  lfs f31, 0x750c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(29964 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 830BA640: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BA644: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830BA648: 41980008  blt cr6, 0x830ba650
	if ctx.cr[6].lt {
	pc = 0x830BA650; continue 'dispatch;
	}
	// 830BA64C: C3FC0040  lfs f31, 0x40(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(64 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 830BA650: 4BFFDCD9  bl 0x830b8328
	ctx.lr = 0x830BA654;
	sub_830B8328(ctx, base);
	// 830BA654: EC01F824  fdivs f0, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ((ctx.f[1].f64 / ctx.f[31].f64) as f32) as f64;
	// 830BA658: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830BA65C: 572B05AF  rlwinm. r11, r25, 0, 0x16, 0x17
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BA660: EC400372  fmuls f2, f0, f13
	ctx.f[2].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 830BA664: D0410054  stfs f2, 0x54(r1)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 830BA668: 41820040  beq 0x830ba6a8
	if ctx.cr[0].eq {
	pc = 0x830BA6A8; continue 'dispatch;
	}
	// 830BA66C: 2B0B0100  cmplwi cr6, r11, 0x100
	ctx.cr[6].compare_u32(ctx.r[11].u32, 256 as u32, &mut ctx.xer);
	// 830BA670: 419A002C  beq cr6, 0x830ba69c
	if ctx.cr[6].eq {
	pc = 0x830BA69C; continue 'dispatch;
	}
	// 830BA674: 2B0B0200  cmplwi cr6, r11, 0x200
	ctx.cr[6].compare_u32(ctx.r[11].u32, 512 as u32, &mut ctx.xer);
	// 830BA678: 419A0018  beq cr6, 0x830ba690
	if ctx.cr[6].eq {
	pc = 0x830BA690; continue 'dispatch;
	}
	// 830BA67C: 2B0B0300  cmplwi cr6, r11, 0x300
	ctx.cr[6].compare_u32(ctx.r[11].u32, 768 as u32, &mut ctx.xer);
	// 830BA680: 409A0030  bne cr6, 0x830ba6b0
	if !ctx.cr[6].eq {
	pc = 0x830BA6B0; continue 'dispatch;
	}
	// 830BA684: C0210050  lfs f1, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830BA688: 480042B1  bl 0x830be938
	ctx.lr = 0x830BA68C;
	sub_830BE938(ctx, base);
	// 830BA68C: 48000024  b 0x830ba6b0
	pc = 0x830BA6B0; continue 'dispatch;
	// 830BA690: C0210050  lfs f1, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830BA694: 4800444D  bl 0x830beae0
	ctx.lr = 0x830BA698;
	sub_830BEAE0(ctx, base);
	// 830BA698: 48000018  b 0x830ba6b0
	pc = 0x830BA6B0; continue 'dispatch;
	// 830BA69C: C0210050  lfs f1, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830BA6A0: 48004529  bl 0x830bebc8
	ctx.lr = 0x830BA6A4;
	sub_830BEBC8(ctx, base);
	// 830BA6A4: 4800000C  b 0x830ba6b0
	pc = 0x830BA6B0; continue 'dispatch;
	// 830BA6A8: C0210050  lfs f1, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830BA6AC: 4800435D  bl 0x830bea08
	ctx.lr = 0x830BA6B0;
	sub_830BEA08(ctx, base);
	// 830BA6B0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830BA6B4: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 830BA6B8: 572A07BD  rlwinm. r10, r25, 0, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[25].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830BA6BC: C1AB08A4  lfs f13, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830BA6C0: C00908A8  lfs f0, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BA6C4: 40820048  bne 0x830ba70c
	if !ctx.cr[0].eq {
	pc = 0x830BA70C; continue 'dispatch;
	}
	// 830BA6C8: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830BA6CC: 813F001C  lwz r9, 0x1c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 830BA6D0: C18B0000  lfs f12, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830BA6D4: D19F0000  stfs f12, 0(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830BA6D8: C18B0004  lfs f12, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830BA6DC: D19F0004  stfs f12, 4(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830BA6E0: C18B000C  lfs f12, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830BA6E4: D19F000C  stfs f12, 0xc(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830BA6E8: C18B0010  lfs f12, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830BA6EC: D19F0010  stfs f12, 0x10(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 830BA6F0: D0090000  stfs f0, 0(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830BA6F4: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 830BA6F8: D1AB0004  stfs f13, 4(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830BA6FC: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 830BA700: D1AB000C  stfs f13, 0xc(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830BA704: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 830BA708: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 830BA70C: 572B052B  rlwinm. r11, r25, 0, 0x14, 0x15
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BA710: FFE00090  fmr f31, f0
	ctx.f[31].f64 = ctx.f[0].f64;
	// 830BA714: FFC00090  fmr f30, f0
	ctx.f[30].f64 = ctx.f[0].f64;
	// 830BA718: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830BA71C: 418200D4  beq 0x830ba7f0
	if ctx.cr[0].eq {
	pc = 0x830BA7F0; continue 'dispatch;
	}
	// 830BA720: 2B0B0400  cmplwi cr6, r11, 0x400
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1024 as u32, &mut ctx.xer);
	// 830BA724: 419A0078  beq cr6, 0x830ba79c
	if ctx.cr[6].eq {
	pc = 0x830BA79C; continue 'dispatch;
	}
	// 830BA728: 2B0B0800  cmplwi cr6, r11, 0x800
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2048 as u32, &mut ctx.xer);
	// 830BA72C: 409A012C  bne cr6, 0x830ba858
	if !ctx.cr[6].eq {
	pc = 0x830BA858; continue 'dispatch;
	}
	// 830BA730: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830BA734: 409A002C  bne cr6, 0x830ba760
	if !ctx.cr[6].eq {
	pc = 0x830BA760; continue 'dispatch;
	}
	// 830BA738: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830BA73C: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830BA740: D1BF0004  stfs f13, 4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830BA744: D1BF000C  stfs f13, 0xc(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830BA748: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830BA74C: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830BA750: D1AB0004  stfs f13, 4(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830BA754: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830BA758: D1AB000C  stfs f13, 0xc(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830BA75C: 480000FC  b 0x830ba858
	pc = 0x830BA858; continue 'dispatch;
	// 830BA760: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 830BA764: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 830BA768: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830BA76C: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830BA770: D1BF0000  stfs f13, 0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830BA774: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830BA778: D1BF0004  stfs f13, 4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830BA77C: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830BA780: D1BF000C  stfs f13, 0xc(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830BA784: C1AB0010  lfs f13, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830BA788: D1BF0010  stfs f13, 0x10(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 830BA78C: D00A0000  stfs f0, 0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830BA790: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830BA794: C3CB0010  lfs f30, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 830BA798: 480000C0  b 0x830ba858
	pc = 0x830BA858; continue 'dispatch;
	// 830BA79C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830BA7A0: 409A0014  bne cr6, 0x830ba7b4
	if !ctx.cr[6].eq {
	pc = 0x830BA7B4; continue 'dispatch;
	}
	// 830BA7A4: D1BF0004  stfs f13, 4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830BA7A8: D1BF000C  stfs f13, 0xc(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830BA7AC: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 830BA7B0: 48000090  b 0x830ba840
	pc = 0x830BA840; continue 'dispatch;
	// 830BA7B4: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 830BA7B8: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 830BA7BC: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830BA7C0: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830BA7C4: D1BF0000  stfs f13, 0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830BA7C8: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830BA7CC: D1BF0004  stfs f13, 4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830BA7D0: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830BA7D4: D1BF000C  stfs f13, 0xc(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830BA7D8: C1AB0010  lfs f13, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830BA7DC: D1BF0010  stfs f13, 0x10(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 830BA7E0: D00A0010  stfs f0, 0x10(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 830BA7E4: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830BA7E8: C3EB0000  lfs f31, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 830BA7EC: 4800006C  b 0x830ba858
	pc = 0x830BA858; continue 'dispatch;
	// 830BA7F0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830BA7F4: 409A0020  bne cr6, 0x830ba814
	if !ctx.cr[6].eq {
	pc = 0x830BA814; continue 'dispatch;
	}
	// 830BA7F8: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830BA7FC: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830BA800: D1BF0004  stfs f13, 4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830BA804: D1BF000C  stfs f13, 0xc(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830BA808: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 830BA80C: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830BA810: 48000030  b 0x830ba840
	pc = 0x830BA840; continue 'dispatch;
	// 830BA814: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 830BA818: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830BA81C: C18B0000  lfs f12, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830BA820: D19F0000  stfs f12, 0(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830BA824: C18B0004  lfs f12, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830BA828: D19F0004  stfs f12, 4(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830BA82C: C18B000C  lfs f12, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830BA830: D19F000C  stfs f12, 0xc(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830BA834: C18B0010  lfs f12, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830BA838: D19F0010  stfs f12, 0x10(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 830BA83C: D00A0000  stfs f0, 0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830BA840: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830BA844: D1AB0004  stfs f13, 4(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830BA848: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830BA84C: D1AB000C  stfs f13, 0xc(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830BA850: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830BA854: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 830BA858: 48004759  bl 0x830befb0
	ctx.lr = 0x830BA85C;
	sub_830BEFB0(ctx, base);
	// 830BA85C: C03E0034  lfs f1, 0x34(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830BA860: 48004451  bl 0x830becb0
	ctx.lr = 0x830BA864;
	sub_830BECB0(ctx, base);
	// 830BA864: C05E003C  lfs f2, 0x3c(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 830BA868: C03E0038  lfs f1, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830BA86C: 480045A5  bl 0x830bee10
	ctx.lr = 0x830BA870;
	sub_830BEE10(ctx, base);
	// 830BA870: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830BA874: 419A0010  beq cr6, 0x830ba884
	if ctx.cr[6].eq {
	pc = 0x830BA884; continue 'dispatch;
	}
	// 830BA878: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 830BA87C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 830BA880: 48004591  bl 0x830bee10
	ctx.lr = 0x830BA884;
	sub_830BEE10(ctx, base);
	// 830BA884: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 830BA888: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830BA88C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830BA890: 4BFFF4B1  bl 0x830b9d40
	ctx.lr = 0x830BA894;
	sub_830B9D40(ctx, base);
	// 830BA894: 815E007C  lwz r10, 0x7c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(124 as u32) ) } as u64;
	// 830BA898: 554B039D  rlwinm. r11, r10, 0, 0xe, 0xe
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BA89C: 41820028  beq 0x830ba8c4
	if ctx.cr[0].eq {
	pc = 0x830BA8C4; continue 'dispatch;
	}
	// 830BA8A0: 817E0028  lwz r11, 0x28(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 830BA8A4: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 830BA8A8: 917E0020  stw r11, 0x20(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 830BA8AC: 419A0018  beq cr6, 0x830ba8c4
	if ctx.cr[6].eq {
	pc = 0x830BA8C4; continue 'dispatch;
	}
	// 830BA8B0: 572906F7  rlwinm. r9, r25, 0, 0x1b, 0x1b
	ctx.r[9].u64 = ctx.r[25].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830BA8B4: 41820010  beq 0x830ba8c4
	if ctx.cr[0].eq {
	pc = 0x830BA8C4; continue 'dispatch;
	}
	// 830BA8B8: 813A0020  lwz r9, 0x20(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(32 as u32) ) } as u64;
	// 830BA8BC: 7D2B5B78  or r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 | ctx.r[11].u64;
	// 830BA8C0: 917E0020  stw r11, 0x20(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 830BA8C4: 554B035B  rlwinm. r11, r10, 0, 0xd, 0xd
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BA8C8: 4182006C  beq 0x830ba934
	if ctx.cr[0].eq {
	pc = 0x830BA934; continue 'dispatch;
	}
	// 830BA8CC: 815E0044  lwz r10, 0x44(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(68 as u32) ) } as u64;
	// 830BA8D0: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 830BA8D4: 915E0024  stw r10, 0x24(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(36 as u32), ctx.r[10].u32 ) };
	// 830BA8D8: 419A0054  beq cr6, 0x830ba92c
	if ctx.cr[6].eq {
	pc = 0x830BA92C; continue 'dispatch;
	}
	// 830BA8DC: 572B0739  rlwinm. r11, r25, 0, 0x1c, 0x1c
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BA8E0: 4182004C  beq 0x830ba92c
	if ctx.cr[0].eq {
	pc = 0x830BA92C; continue 'dispatch;
	}
	// 830BA8E4: 813A0024  lwz r9, 0x24(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(36 as u32) ) } as u64;
	// 830BA8E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830BA8EC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 830BA8F0: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 830BA8F4: 39410054  addi r10, r1, 0x54
	ctx.r[10].s64 = ctx.r[1].s64 + 84;
	// 830BA8F8: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 830BA8FC: 390000FF  li r8, 0xff
	ctx.r[8].s64 = 255;
	// 830BA900: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 830BA904: 7D4B50AE  lbzx r10, r11, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830BA908: 7D2B48AE  lbzx r9, r11, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 830BA90C: 7D4A49D6  mullw r10, r10, r9
	ctx.r[10].s64 = (ctx.r[10].s32 as i64) * (ctx.r[9].s32 as i64);
	// 830BA910: 7D4A43D6  divw r10, r10, r8
	ctx.r[10].s32 = ctx.r[10].s32 / ctx.r[8].s32;
	// 830BA914: 7D4B39AE  stbx r10, r11, r7
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[7].u32), ctx.r[10].u8) };
	// 830BA918: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830BA91C: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 830BA920: 4198FFD4  blt cr6, 0x830ba8f4
	if ctx.cr[6].lt {
	pc = 0x830BA8F4; continue 'dispatch;
	}
	// 830BA924: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830BA928: 917E0024  stw r11, 0x24(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 830BA92C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830BA930: 4BFFED29  bl 0x830b9658
	ctx.lr = 0x830BA934;
	sub_830B9658(ctx, base);
	// 830BA934: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 830BA938: CBC1FFB0  lfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 830BA93C: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 830BA940: 480ED86C  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BA948(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830BA948 size=92
    let mut pc: u32 = 0x830BA948;
    'dispatch: loop {
        match pc {
            0x830BA948 => {
    //   block [0x830BA948..0x830BA9A4)
	// 830BA948: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BA94C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830BA950: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830BA954: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BA958: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BA95C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830BA960: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830BA964: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830BA968: 41980020  blt cr6, 0x830ba988
	if ctx.cr[6].lt {
	pc = 0x830BA988; continue 'dispatch;
	}
	// 830BA96C: 419A0014  beq cr6, 0x830ba980
	if ctx.cr[6].eq {
	pc = 0x830BA980; continue 'dispatch;
	}
	// 830BA970: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 830BA974: 40980014  bge cr6, 0x830ba988
	if !ctx.cr[6].lt {
	pc = 0x830BA988; continue 'dispatch;
	}
	// 830BA978: 4BFFFB41  bl 0x830ba4b8
	ctx.lr = 0x830BA97C;
	sub_830BA4B8(ctx, base);
	// 830BA97C: 48000010  b 0x830ba98c
	pc = 0x830BA98C; continue 'dispatch;
	// 830BA980: 4BFFFA61  bl 0x830ba3e0
	ctx.lr = 0x830BA984;
	sub_830BA3E0(ctx, base);
	// 830BA984: 48000008  b 0x830ba98c
	pc = 0x830BA98C; continue 'dispatch;
	// 830BA988: 4BFFF0E9  bl 0x830b9a70
	ctx.lr = 0x830BA98C;
	sub_830B9A70(ctx, base);
	// 830BA98C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BA990: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830BA994: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830BA998: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830BA99C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830BA9A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BA9A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830BA9A8 size=728
    let mut pc: u32 = 0x830BA9A8;
    'dispatch: loop {
        match pc {
            0x830BA9A8 => {
    //   block [0x830BA9A8..0x830BAC80)
	// 830BA9A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BA9AC: 480ED7B1  bl 0x831a815c
	ctx.lr = 0x830BA9B0;
	sub_831A8130(ctx, base);
	// 830BA9B0: DBC1FFB0  stfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 830BA9B4: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 830BA9B8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BA9BC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830BA9C0: FFE01090  fmr f31, f2
	ctx.f[31].f64 = ctx.f[2].f64;
	// 830BA9C4: 7D595378  mr r25, r10
	ctx.r[25].u64 = ctx.r[10].u64;
	// 830BA9C8: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 830BA9CC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 830BA9D0: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 830BA9D4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BA9D8: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 830BA9DC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830BA9E0: 7D1E4378  mr r30, r8
	ctx.r[30].u64 = ctx.r[8].u64;
	// 830BA9E4: 1D4A0018  mulli r10, r10, 0x18
	ctx.r[10].s64 = ctx.r[10].s64 * 24;
	// 830BA9E8: C3C908A4  lfs f30, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 830BA9EC: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 830BA9F0: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 830BA9F4: 816BFFE8  lwz r11, -0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24 as u32) ) } as u64;
	// 830BA9F8: 7D6A07B4  extsw r10, r11
	ctx.r[10].s64 = ctx.r[11].s32 as i64;
	// 830BA9FC: F9410060  std r10, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u64 ) };
	// 830BAA00: C8010060  lfd f0, 0x60(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 830BAA04: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 830BAA08: FC400018  frsp f2, f0
	ctx.f[2].f64 = (ctx.f[0].f64 as f32) as f64;
	// 830BAA0C: FF020800  fcmpu cr6, f2, f1
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[1].f64);
	// 830BAA10: 41990028  bgt cr6, 0x830baa38
	if ctx.cr[6].gt {
	pc = 0x830BAA38; continue 'dispatch;
	}
	// 830BAA14: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BAA18: 2F0A0002  cmpwi cr6, r10, 2
	ctx.cr[6].compare_i32(ctx.r[10].s32, 2, &mut ctx.xer);
	// 830BAA1C: 409A0068  bne cr6, 0x830baa84
	if !ctx.cr[6].eq {
	pc = 0x830BAA84; continue 'dispatch;
	}
	// 830BAA20: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BAA24: 409A0054  bne cr6, 0x830baa78
	if !ctx.cr[6].eq {
	pc = 0x830BAA78; continue 'dispatch;
	}
	// 830BAA28: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 830BAA2C: FF1FF000  fcmpu cr6, f31, f30
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[30].f64);
	// 830BAA30: 40990008  ble cr6, 0x830baa38
	if !ctx.cr[6].gt {
	pc = 0x830BAA38; continue 'dispatch;
	}
	// 830BAA34: 937E0000  stw r27, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 830BAA38: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830BAA3C: E94B0002  lwa r10, 0(r11)
	ctx.r[10].s64 = (unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as i32) as i64;
	// 830BAA40: F9410060  std r10, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u64 ) };
	// 830BAA44: C8010060  lfd f0, 0x60(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 830BAA48: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 830BAA4C: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 830BAA50: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 830BAA54: 409900A8  ble cr6, 0x830baafc
	if !ctx.cr[6].gt {
	pc = 0x830BAAFC; continue 'dispatch;
	}
	// 830BAA58: FF1FF000  fcmpu cr6, f31, f30
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[30].f64);
	// 830BAA5C: 40980008  bge cr6, 0x830baa64
	if !ctx.cr[6].lt {
	pc = 0x830BAA64; continue 'dispatch;
	}
	// 830BAA60: 937E0000  stw r27, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 830BAA64: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 830BAA68: 419A007C  beq cr6, 0x830baae4
	if ctx.cr[6].eq {
	pc = 0x830BAAE4; continue 'dispatch;
	}
	// 830BAA6C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BAA70: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BAA74: 48000074  b 0x830baae8
	pc = 0x830BAAE8; continue 'dispatch;
	// 830BAA78: 480EFD99  bl 0x831aa810
	ctx.lr = 0x830BAA7C;
	sub_831AA810(ctx, base);
	// 830BAA7C: FC200818  frsp f1, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = (ctx.f[1].f64 as f32) as f64;
	// 830BAA80: 4BFFFFB8  b 0x830baa38
	pc = 0x830BAA38; continue 'dispatch;
	// 830BAA84: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830BAA88: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 830BAA8C: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BAA90: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 830BAA94: 40990008  ble cr6, 0x830baa9c
	if !ctx.cr[6].gt {
	pc = 0x830BAA9C; continue 'dispatch;
	}
	// 830BAA98: 937E0000  stw r27, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 830BAA9C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 830BAAA0: 419A001C  beq cr6, 0x830baabc
	if ctx.cr[6].eq {
	pc = 0x830BAABC; continue 'dispatch;
	}
	// 830BAAA4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BAAA8: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BAAAC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830BAAB0: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830BAAB4: 812BFFFC  lwz r9, -4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 830BAAB8: 48000008  b 0x830baac0
	pc = 0x830BAAC0; continue 'dispatch;
	// 830BAABC: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 830BAAC0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BAAC4: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 830BAAC8: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830BAACC: 1D6B0018  mulli r11, r11, 0x18
	ctx.r[11].s64 = ctx.r[11].s64 * 24;
	// 830BAAD0: 91210064  stw r9, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 830BAAD4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830BAAD8: 396BFFE8  addi r11, r11, -0x18
	ctx.r[11].s64 = ctx.r[11].s64 + -24;
	// 830BAADC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 830BAAE0: 4800017C  b 0x830bac5c
	pc = 0x830BAC5C; continue 'dispatch;
	// 830BAAE4: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 830BAAE8: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830BAAEC: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 830BAAF0: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 830BAAF4: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 830BAAF8: 48000164  b 0x830bac5c
	pc = 0x830BAC5C; continue 'dispatch;
	// 830BAAFC: 80FF0004  lwz r7, 4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BAB00: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 830BAB04: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 830BAB08: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 830BAB0C: 7F68DB78  mr r8, r27
	ctx.r[8].u64 = ctx.r[27].u64;
	// 830BAB10: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 830BAB14: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 830BAB18: 40990070  ble cr6, 0x830bab88
	if !ctx.cr[6].gt {
	pc = 0x830BAB88; continue 'dispatch;
	}
	// 830BAB1C: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 830BAB20: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 830BAB24: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 830BAB28: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 830BAB2C: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 830BAB30: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 830BAB34: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 830BAB38: 419A0010  beq cr6, 0x830bab48
	if ctx.cr[6].eq {
	pc = 0x830BAB48; continue 'dispatch;
	}
	// 830BAB3C: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BAB40: 7D4A482E  lwzx r10, r10, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 830BAB44: 48000008  b 0x830bab4c
	pc = 0x830BAB4C; continue 'dispatch;
	// 830BAB48: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 830BAB4C: E8CB0002  lwa r6, 0(r11)
	ctx.r[6].s64 = (unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as i32) as i64;
	// 830BAB50: F8C10050  std r6, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[6].u64 ) };
	// 830BAB54: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830BAB58: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 830BAB5C: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 830BAB60: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 830BAB64: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 830BAB68: 41990018  bgt cr6, 0x830bab80
	if ctx.cr[6].gt {
	pc = 0x830BAB80; continue 'dispatch;
	}
	// 830BAB6C: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 830BAB70: 396B0018  addi r11, r11, 0x18
	ctx.r[11].s64 = ctx.r[11].s64 + 24;
	// 830BAB74: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 830BAB78: 7F083800  cmpw cr6, r8, r7
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[7].s32, &mut ctx.xer);
	// 830BAB7C: 4198FFA4  blt cr6, 0x830bab20
	if ctx.cr[6].lt {
	pc = 0x830BAB20; continue 'dispatch;
	}
	// 830BAB80: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830BAB84: 409A0010  bne cr6, 0x830bab94
	if !ctx.cr[6].eq {
	pc = 0x830BAB94; continue 'dispatch;
	}
	// 830BAB88: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 830BAB8C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 830BAB90: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 830BAB94: 2F1A0006  cmpwi cr6, r26, 6
	ctx.cr[6].compare_i32(ctx.r[26].s32, 6, &mut ctx.xer);
	// 830BAB98: 4199009C  bgt cr6, 0x830bac34
	if ctx.cr[6].gt {
	pc = 0x830BAC34; continue 'dispatch;
	}
	// 830BAB9C: 419A0030  beq cr6, 0x830babcc
	if ctx.cr[6].eq {
	pc = 0x830BABCC; continue 'dispatch;
	}
	// 830BABA0: 2B1A0001  cmplwi cr6, r26, 1
	ctx.cr[6].compare_u32(ctx.r[26].u32, 1 as u32, &mut ctx.xer);
	// 830BABA4: 419800B4  blt cr6, 0x830bac58
	if ctx.cr[6].lt {
	pc = 0x830BAC58; continue 'dispatch;
	}
	// 830BABA8: 2B1A0006  cmplwi cr6, r26, 6
	ctx.cr[6].compare_u32(ctx.r[26].u32, 6 as u32, &mut ctx.xer);
	// 830BABAC: 409800AC  bge cr6, 0x830bac58
	if !ctx.cr[6].lt {
	pc = 0x830BAC58; continue 'dispatch;
	}
	// 830BABB0: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 830BABB4: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 830BABB8: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 830BABBC: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 830BABC0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830BABC4: 4BFFFD85  bl 0x830ba948
	ctx.lr = 0x830BABC8;
	sub_830BA948(ctx, base);
	// 830BABC8: 480000A4  b 0x830bac6c
	pc = 0x830BAC6C; continue 'dispatch;
	// 830BABCC: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 830BABD0: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 830BABD4: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 830BABD8: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 830BABDC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830BABE0: 4BFFFD69  bl 0x830ba948
	ctx.lr = 0x830BABE4;
	sub_830BA948(ctx, base);
	// 830BABE4: C01F0004  lfs f0, 4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BABE8: C1BE0004  lfs f13, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830BABEC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830BABF0: 409A000C  bne cr6, 0x830babfc
	if !ctx.cr[6].eq {
	pc = 0x830BABFC; continue 'dispatch;
	}
	// 830BABF4: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 830BABF8: 48000018  b 0x830bac10
	pc = 0x830BAC10; continue 'dispatch;
	// 830BABFC: C19E0004  lfs f12, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830BAC00: C1610050  lfs f11, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830BAC04: ED406028  fsubs f10, f0, f12
	ctx.f[10].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 830BAC08: ED8B6028  fsubs f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 830BAC0C: EC2C5024  fdivs f1, f12, f10
	ctx.f[1].f64 = ((ctx.f[12].f64 / ctx.f[10].f64) as f32) as f64;
	// 830BAC10: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 830BAC14: D8010060  stfd f0, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.f[0].u64 ) };
	// 830BAC18: FC00681E  fctiwz f0, f13
	ctx.f[0].s64 = if ctx.f[13].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[13].f64.trunc() as i32 as i64 };
	// 830BAC1C: D8010058  stfd f0, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[0].u64 ) };
	// 830BAC20: 80810064  lwz r4, 0x64(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 830BAC24: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 830BAC28: 4BFFF061  bl 0x830b9c88
	ctx.lr = 0x830BAC2C;
	sub_830B9C88(ctx, base);
	// 830BAC2C: D03C0000  stfs f1, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830BAC30: 4800003C  b 0x830bac6c
	pc = 0x830BAC6C; continue 'dispatch;
	// 830BAC34: 2F1A0007  cmpwi cr6, r26, 7
	ctx.cr[6].compare_i32(ctx.r[26].s32, 7, &mut ctx.xer);
	// 830BAC38: 41980020  blt cr6, 0x830bac58
	if ctx.cr[6].lt {
	pc = 0x830BAC58; continue 'dispatch;
	}
	// 830BAC3C: 2F1A000B  cmpwi cr6, r26, 0xb
	ctx.cr[6].compare_i32(ctx.r[26].s32, 11, &mut ctx.xer);
	// 830BAC40: 41990018  bgt cr6, 0x830bac58
	if ctx.cr[6].gt {
	pc = 0x830BAC58; continue 'dispatch;
	}
	// 830BAC44: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830BAC48: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830BAC4C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830BAC50: 4BFFEB41  bl 0x830b9790
	ctx.lr = 0x830BAC54;
	sub_830B9790(ctx, base);
	// 830BAC54: 48000018  b 0x830bac6c
	pc = 0x830BAC6C; continue 'dispatch;
	// 830BAC58: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 830BAC5C: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 830BAC60: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 830BAC64: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830BAC68: 4BFFEE09  bl 0x830b9a70
	ctx.lr = 0x830BAC6C;
	sub_830B9A70(ctx, base);
	// 830BAC6C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830BAC70: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 830BAC74: CBC1FFB0  lfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 830BAC78: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 830BAC7C: 480ED530  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BAC80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830BAC80 size=408
    let mut pc: u32 = 0x830BAC80;
    'dispatch: loop {
        match pc {
            0x830BAC80 => {
    //   block [0x830BAC80..0x830BAE18)
	// 830BAC80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BAC84: 480ED4C9  bl 0x831a814c
	ctx.lr = 0x830BAC88;
	sub_831A8130(ctx, base);
	// 830BAC88: DBC1FF90  stfd f30, -0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.f[30].u64 ) };
	// 830BAC8C: DBE1FF98  stfd f31, -0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[31].u64 ) };
	// 830BAC90: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BAC94: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830BAC98: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 830BAC9C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 830BACA0: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 830BACA4: 7CD63378  mr r22, r6
	ctx.r[22].u64 = ctx.r[6].u64;
	// 830BACA8: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 830BACAC: 9081005C  stw r4, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[4].u32 ) };
	// 830BACB0: 3B3F0028  addi r25, r31, 0x28
	ctx.r[25].s64 = ctx.r[31].s64 + 40;
	// 830BACB4: 3AE07FFF  li r23, 0x7fff
	ctx.r[23].s64 = 32767;
	// 830BACB8: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 830BACBC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830BACC0: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 830BACC4: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 830BACC8: 3AA00001  li r21, 1
	ctx.r[21].s64 = 1;
	// 830BACCC: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 830BACD0: 7EBED830  slw r30, r21, r27
	if (ctx.r[27].u8 & 0x20) != 0 {
		ctx.r[30].u64 = 0;
	} else {
		ctx.r[30].u64 = ((ctx.r[21].u32) << ((ctx.r[27].u8 & 0x1F) as u32)) as u64;
	}
	// 830BACD4: 7D6BF039  and. r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[30].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BACD8: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 830BACDC: 41820030  beq 0x830bad0c
	if ctx.cr[0].eq {
	pc = 0x830BAD0C; continue 'dispatch;
	}
	// 830BACE0: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830BACE4: 7D6BE82E  lwzx r11, r11, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 830BACE8: 7D7DC92E  stwx r11, r29, r25
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[29].u32.wrapping_add(ctx.r[25].u32), ctx.r[11].u32) };
	// 830BACEC: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 830BACF0: 7D6BF378  or r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[30].u64;
	// 830BACF4: 917F007C  stw r11, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 830BACF8: 419A00B0  beq cr6, 0x830bada8
	if ctx.cr[6].eq {
	pc = 0x830BADA8; continue 'dispatch;
	}
	// 830BACFC: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BAD00: 7D6BF039  and. r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[30].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BAD04: 418200A4  beq 0x830bada8
	if ctx.cr[0].eq {
	pc = 0x830BADA8; continue 'dispatch;
	}
	// 830BAD08: 48000080  b 0x830bad88
	pc = 0x830BAD88; continue 'dispatch;
	// 830BAD0C: 419A0088  beq cr6, 0x830bad94
	if ctx.cr[6].eq {
	pc = 0x830BAD94; continue 'dispatch;
	}
	// 830BAD10: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BAD14: 7D6BF039  and. r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[30].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BAD18: 4182007C  beq 0x830bad94
	if ctx.cr[0].eq {
	pc = 0x830BAD94; continue 'dispatch;
	}
	// 830BAD1C: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 830BAD20: 7D6BF039  and. r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[30].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BAD24: 40820064  bne 0x830bad88
	if !ctx.cr[0].eq {
	pc = 0x830BAD88; continue 'dispatch;
	}
	// 830BAD28: 2B160000  cmplwi cr6, r22, 0
	ctx.cr[6].compare_u32(ctx.r[22].u32, 0 as u32, &mut ctx.xer);
	// 830BAD2C: 92A10050  stw r21, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[21].u32 ) };
	// 830BAD30: 419A0010  beq cr6, 0x830bad40
	if ctx.cr[6].eq {
	pc = 0x830BAD40; continue 'dispatch;
	}
	// 830BAD34: 81760000  lwz r11, 0(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BAD38: 7CABC02E  lwzx r5, r11, r24
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[24].u32)) } as u64;
	// 830BAD3C: 48000008  b 0x830bad44
	pc = 0x830BAD44; continue 'dispatch;
	// 830BAD40: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830BAD44: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BAD48: 39410058  addi r10, r1, 0x58
	ctx.r[10].s64 = ctx.r[1].s64 + 88;
	// 830BAD4C: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 830BAD50: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 830BAD54: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 830BAD58: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 830BAD5C: 7C8BD214  add r4, r11, r26
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 830BAD60: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 830BAD64: 4BFFFC45  bl 0x830ba9a8
	ctx.lr = 0x830BAD68;
	sub_830BA9A8(ctx, base);
	// 830BAD68: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BAD6C: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830BAD70: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830BAD74: 7D7DC92E  stwx r11, r29, r25
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[29].u32.wrapping_add(ctx.r[25].u32), ctx.r[11].u32) };
	// 830BAD78: 409A0010  bne cr6, 0x830bad88
	if !ctx.cr[6].eq {
	pc = 0x830BAD88; continue 'dispatch;
	}
	// 830BAD7C: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 830BAD80: 7D6BF378  or r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[30].u64;
	// 830BAD84: 917F007C  stw r11, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 830BAD88: 3B180004  addi r24, r24, 4
	ctx.r[24].s64 = ctx.r[24].s64 + 4;
	// 830BAD8C: 3B5A000C  addi r26, r26, 0xc
	ctx.r[26].s64 = ctx.r[26].s64 + 12;
	// 830BAD90: 48000018  b 0x830bada8
	pc = 0x830BADA8; continue 'dispatch;
	// 830BAD94: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 830BAD98: 7D6AF039  and. r10, r11, r30
	ctx.r[10].u64 = ctx.r[11].u64 & ctx.r[30].u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830BAD9C: 4082000C  bne 0x830bada8
	if !ctx.cr[0].eq {
	pc = 0x830BADA8; continue 'dispatch;
	}
	// 830BADA0: 7D6BF378  or r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[30].u64;
	// 830BADA4: 917F007C  stw r11, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 830BADA8: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 830BADAC: 7EF7F078  andc r23, r23, r30
	ctx.r[23].u64 = ctx.r[23].u64 & !ctx.r[30].u64;
	// 830BADB0: 7D6BB838  and r11, r11, r23
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[23].u64;
	// 830BADB4: 556B047E  clrlwi r11, r11, 0x11
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00007FFFu64;
	// 830BADB8: 7F0BB800  cmpw cr6, r11, r23
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[23].s32, &mut ctx.xer);
	// 830BADBC: 419A0014  beq cr6, 0x830badd0
	if ctx.cr[6].eq {
	pc = 0x830BADD0; continue 'dispatch;
	}
	// 830BADC0: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 830BADC4: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 830BADC8: 2F1D003C  cmpwi cr6, r29, 0x3c
	ctx.cr[6].compare_i32(ctx.r[29].s32, 60, &mut ctx.xer);
	// 830BADCC: 4198FF00  blt cr6, 0x830baccc
	if ctx.cr[6].lt {
	pc = 0x830BACCC; continue 'dispatch;
	}
	// 830BADD0: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 830BADD4: 556A0295  rlwinm. r10, r11, 0, 0xa, 0xa
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830BADD8: 40820018  bne 0x830badf0
	if !ctx.cr[0].eq {
	pc = 0x830BADF0; continue 'dispatch;
	}
	// 830BADDC: 556A06BC  rlwinm r10, r11, 0, 0x1a, 0x1e
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830BADE0: 2F0A003E  cmpwi cr6, r10, 0x3e
	ctx.cr[6].compare_i32(ctx.r[10].s32, 62, &mut ctx.xer);
	// 830BADE4: 409A000C  bne cr6, 0x830badf0
	if !ctx.cr[6].eq {
	pc = 0x830BADF0; continue 'dispatch;
	}
	// 830BADE8: 656B0020  oris r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 | 2097152;
	// 830BADEC: 917F007C  stw r11, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 830BADF0: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 830BADF4: 556A047E  clrlwi r10, r11, 0x11
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00007FFFu64;
	// 830BADF8: 2F0A7FFF  cmpwi cr6, r10, 0x7fff
	ctx.cr[6].compare_i32(ctx.r[10].s32, 32767, &mut ctx.xer);
	// 830BADFC: 409A000C  bne cr6, 0x830bae08
	if !ctx.cr[6].eq {
	pc = 0x830BAE08; continue 'dispatch;
	}
	// 830BAE00: 656B0008  oris r11, r11, 8
	ctx.r[11].u64 = ctx.r[11].u64 | 524288;
	// 830BAE04: 917F007C  stw r11, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 830BAE08: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 830BAE0C: CBC1FF90  lfd f30, -0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-112 as u32) ) };
	// 830BAE10: CBE1FF98  lfd f31, -0x68(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-104 as u32) ) };
	// 830BAE14: 480ED388  b 0x831a819c
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BAE18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830BAE18 size=284
    let mut pc: u32 = 0x830BAE18;
    'dispatch: loop {
        match pc {
            0x830BAE18 => {
    //   block [0x830BAE18..0x830BAF34)
	// 830BAE18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BAE1C: 480ED339  bl 0x831a8154
	ctx.lr = 0x830BAE20;
	sub_831A8130(ctx, base);
	// 830BAE20: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BAE24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830BAE28: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 830BAE2C: 7D184378  mr r24, r8
	ctx.r[24].u64 = ctx.r[8].u64;
	// 830BAE30: 7D3B4B78  mr r27, r9
	ctx.r[27].u64 = ctx.r[9].u64;
	// 830BAE34: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 830BAE38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830BAE3C: 419A00F0  beq cr6, 0x830baf2c
	if ctx.cr[6].eq {
	pc = 0x830BAF2C; continue 'dispatch;
	}
	// 830BAE40: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 830BAE44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830BAE48: 419A00E4  beq cr6, 0x830baf2c
	if ctx.cr[6].eq {
	pc = 0x830BAF2C; continue 'dispatch;
	}
	// 830BAE4C: 554B07FF  clrlwi. r11, r10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BAE50: 408200BC  bne 0x830baf0c
	if !ctx.cr[0].eq {
	pc = 0x830BAF0C; continue 'dispatch;
	}
	// 830BAE54: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 830BAE58: 556A0319  rlwinm. r10, r11, 0, 0xc, 0xc
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830BAE5C: 408200B0  bne 0x830baf0c
	if !ctx.cr[0].eq {
	pc = 0x830BAF0C; continue 'dispatch;
	}
	// 830BAE60: 556A052E  rlwinm r10, r11, 0, 0x14, 0x17
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830BAE64: 83DF0028  lwz r30, 0x28(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 830BAE68: 83BF0044  lwz r29, 0x44(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 830BAE6C: 55770294  rlwinm r23, r11, 0, 0xa, 0xa
	ctx.r[23].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830BAE70: 394AF100  addi r10, r10, -0xf00
	ctx.r[10].s64 = ctx.r[10].s64 + -3840;
	// 830BAE74: 557A0672  rlwinm r26, r11, 0, 0x19, 0x19
	ctx.r[26].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830BAE78: 7D4A0034  cntlzw r10, r10
	ctx.r[10].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 830BAE7C: 5559DFFE  rlwinm r25, r10, 0x1b, 0x1f, 0x1f
	ctx.r[25].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 830BAE80: 4BFFFE01  bl 0x830bac80
	ctx.lr = 0x830BAE84;
	sub_830BAC80(ctx, base);
	// 830BAE84: 2F170000  cmpwi cr6, r23, 0
	ctx.cr[6].compare_i32(ctx.r[23].s32, 0, &mut ctx.xer);
	// 830BAE88: 409A0014  bne cr6, 0x830bae9c
	if !ctx.cr[6].eq {
	pc = 0x830BAE9C; continue 'dispatch;
	}
	// 830BAE8C: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 830BAE90: 656B0001  oris r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 65536;
	// 830BAE94: 616B8000  ori r11, r11, 0x8000
	ctx.r[11].u64 = ctx.r[11].u64 | 32768;
	// 830BAE98: 917F007C  stw r11, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 830BAE9C: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 830BAEA0: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830BAEA4: 419A0014  beq cr6, 0x830baeb8
	if ctx.cr[6].eq {
	pc = 0x830BAEB8; continue 'dispatch;
	}
	// 830BAEA8: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 830BAEAC: 656B0002  oris r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u64 | 131072;
	// 830BAEB0: 616B8000  ori r11, r11, 0x8000
	ctx.r[11].u64 = ctx.r[11].u64 | 32768;
	// 830BAEB4: 917F007C  stw r11, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 830BAEB8: 817F0044  lwz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 830BAEBC: 3D400004  lis r10, 4
	ctx.r[10].s64 = 262144;
	// 830BAEC0: 615E8000  ori r30, r10, 0x8000
	ctx.r[30].u64 = ctx.r[10].u64 | 32768;
	// 830BAEC4: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830BAEC8: 419A0010  beq cr6, 0x830baed8
	if ctx.cr[6].eq {
	pc = 0x830BAED8; continue 'dispatch;
	}
	// 830BAECC: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 830BAED0: 7D6BF378  or r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[30].u64;
	// 830BAED4: 917F007C  stw r11, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 830BAED8: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 830BAEDC: 409A0014  bne cr6, 0x830baef0
	if !ctx.cr[6].eq {
	pc = 0x830BAEF0; continue 'dispatch;
	}
	// 830BAEE0: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 830BAEE4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830BAEE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BAEEC: 4BFFF075  bl 0x830b9f60
	ctx.lr = 0x830BAEF0;
	sub_830B9F60(ctx, base);
	// 830BAEF0: 2F190000  cmpwi cr6, r25, 0
	ctx.cr[6].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 830BAEF4: 409A0018  bne cr6, 0x830baf0c
	if !ctx.cr[6].eq {
	pc = 0x830BAF0C; continue 'dispatch;
	}
	// 830BAEF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BAEFC: 4BFFE6AD  bl 0x830b95a8
	ctx.lr = 0x830BAF00;
	sub_830B95A8(ctx, base);
	// 830BAF00: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 830BAF04: 7D6BF378  or r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[30].u64;
	// 830BAF08: 917F007C  stw r11, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 830BAF0C: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 830BAF10: 556B0421  rlwinm. r11, r11, 0, 0x10, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BAF14: 41820018  beq 0x830baf2c
	if ctx.cr[0].eq {
	pc = 0x830BAF2C; continue 'dispatch;
	}
	// 830BAF18: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 830BAF1C: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 830BAF20: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830BAF24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BAF28: 4BFFF6B9  bl 0x830ba5e0
	ctx.lr = 0x830BAF2C;
	sub_830BA5E0(ctx, base);
	// 830BAF2C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830BAF30: 480ED274  b 0x831a81a4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BAF38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830BAF38 size=624
    let mut pc: u32 = 0x830BAF38;
    'dispatch: loop {
        match pc {
            0x830BAF38 => {
    //   block [0x830BAF38..0x830BB1A8)
	// 830BAF38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BAF3C: 480ED209  bl 0x831a8144
	ctx.lr = 0x830BAF40;
	sub_831A8130(ctx, base);
	// 830BAF40: DBC1FF80  stfd f30, -0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), ctx.f[30].u64 ) };
	// 830BAF44: DBE1FF88  stfd f31, -0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.f[31].u64 ) };
	// 830BAF48: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BAF4C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830BAF50: 8281015C  lwz r20, 0x15c(r1)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(348 as u32) ) } as u64;
	// 830BAF54: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830BAF58: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 830BAF5C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 830BAF60: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 830BAF64: 1FDD0144  mulli r30, r29, 0x144
	ctx.r[30].s64 = ctx.r[29].s64 * 324;
	// 830BAF68: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BAF6C: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 830BAF70: 7CF53B78  mr r21, r7
	ctx.r[21].u64 = ctx.r[7].u64;
	// 830BAF74: 7D164378  mr r22, r8
	ctx.r[22].u64 = ctx.r[8].u64;
	// 830BAF78: 7D5A5378  mr r26, r10
	ctx.r[26].u64 = ctx.r[10].u64;
	// 830BAF7C: 3A600000  li r19, 0
	ctx.r[19].s64 = 0;
	// 830BAF80: 7EFE5A14  add r23, r30, r11
	ctx.r[23].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 830BAF84: 2F140000  cmpwi cr6, r20, 0
	ctx.cr[6].compare_i32(ctx.r[20].s32, 0, &mut ctx.xer);
	// 830BAF88: 4099000C  ble cr6, 0x830baf94
	if !ctx.cr[6].gt {
	pc = 0x830BAF94; continue 'dispatch;
	}
	// 830BAF8C: 93570080  stw r26, 0x80(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(128 as u32), ctx.r[26].u32 ) };
	// 830BAF90: 48000008  b 0x830baf98
	pc = 0x830BAF98; continue 'dispatch;
	// 830BAF94: 92770080  stw r19, 0x80(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(128 as u32), ctx.r[19].u32 ) };
	// 830BAF98: 8321014C  lwz r25, 0x14c(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(332 as u32) ) } as u64;
	// 830BAF9C: 83610144  lwz r27, 0x144(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(324 as u32) ) } as u64;
	// 830BAFA0: 572B0739  rlwinm. r11, r25, 0, 0x1c, 0x1c
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BAFA4: 41820030  beq 0x830bafd4
	if ctx.cr[0].eq {
	pc = 0x830BAFD4; continue 'dispatch;
	}
	// 830BAFA8: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BAFAC: 57A9103A  slwi r9, r29, 2
	ctx.r[9].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 830BAFB0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BAFB4: 7EC6B378  mr r6, r22
	ctx.r[6].u64 = ctx.r[22].u64;
	// 830BAFB8: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 830BAFBC: 7C7E5A14  add r3, r30, r11
	ctx.r[3].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 830BAFC0: 7C89502E  lwzx r4, r9, r10
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830BAFC4: 480025CD  bl 0x830bd590
	ctx.lr = 0x830BAFC8;
	sub_830BD590(ctx, base);
	// 830BAFC8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BAFCC: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 830BAFD0: 926B007C  stw r19, 0x7c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(124 as u32), ctx.r[19].u32 ) };
	// 830BAFD4: 572B07BD  rlwinm. r11, r25, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BAFD8: 41820010  beq 0x830bafe8
	if ctx.cr[0].eq {
	pc = 0x830BAFE8; continue 'dispatch;
	}
	// 830BAFDC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BAFE0: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 830BAFE4: 926B007C  stw r19, 0x7c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(124 as u32), ctx.r[19].u32 ) };
	// 830BAFE8: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 830BAFEC: 419A002C  beq cr6, 0x830bb018
	if ctx.cr[6].eq {
	pc = 0x830BB018; continue 'dispatch;
	}
	// 830BAFF0: 817A007C  lwz r11, 0x7c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(124 as u32) ) } as u64;
	// 830BAFF4: 556B0421  rlwinm. r11, r11, 0, 0x10, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BAFF8: 41820020  beq 0x830bb018
	if ctx.cr[0].eq {
	pc = 0x830BB018; continue 'dispatch;
	}
	// 830BAFFC: 8177007C  lwz r11, 0x7c(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(124 as u32) ) } as u64;
	// 830BB000: 556B0458  rlwinm r11, r11, 0, 0x11, 0xc
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830BB004: 9177007C  stw r11, 0x7c(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 830BB008: 815A007C  lwz r10, 0x7c(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(124 as u32) ) } as u64;
	// 830BB00C: 554A0360  rlwinm r10, r10, 0, 0xd, 0x10
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 830BB010: 7D4B5B78  or r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 | ctx.r[11].u64;
	// 830BB014: 48000014  b 0x830bb028
	pc = 0x830BB028; continue 'dispatch;
	// 830BB018: 8177007C  lwz r11, 0x7c(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(124 as u32) ) } as u64;
	// 830BB01C: 556A02D7  rlwinm. r10, r11, 0, 0xb, 0xb
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830BB020: 40820128  bne 0x830bb148
	if !ctx.cr[0].eq {
	pc = 0x830BB148; continue 'dispatch;
	}
	// 830BB024: 556B0458  rlwinm r11, r11, 0, 0x11, 0xc
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830BB028: 9177007C  stw r11, 0x7c(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 830BB02C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BB030: 7C7E5A14  add r3, r30, r11
	ctx.r[3].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 830BB034: 48004615  bl 0x830bf648
	ctx.lr = 0x830BB038;
	sub_830BF648(ctx, base);
	// 830BB038: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 830BB03C: 419A003C  beq cr6, 0x830bb078
	if ctx.cr[6].eq {
	pc = 0x830BB078; continue 'dispatch;
	}
	// 830BB040: 2B150000  cmplwi cr6, r21, 0
	ctx.cr[6].compare_u32(ctx.r[21].u32, 0 as u32, &mut ctx.xer);
	// 830BB044: 419A0014  beq cr6, 0x830bb058
	if ctx.cr[6].eq {
	pc = 0x830BB058; continue 'dispatch;
	}
	// 830BB048: 81750000  lwz r11, 0(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BB04C: 57AA103A  slwi r10, r29, 2
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830BB050: 7CCA582E  lwzx r6, r10, r11
	ctx.r[6].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830BB054: 48000008  b 0x830bb05c
	pc = 0x830BB05C; continue 'dispatch;
	// 830BB058: 7E669B78  mr r6, r19
	ctx.r[6].u64 = ctx.r[19].u64;
	// 830BB05C: 809C0004  lwz r4, 4(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BB060: 57A3103A  slwi r3, r29, 2
	ctx.r[3].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 830BB064: 80B80004  lwz r5, 4(r24)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BB068: 57A71838  slwi r7, r29, 3
	ctx.r[7].u32 = ctx.r[29].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 830BB06C: 7CA72A14  add r5, r7, r5
	ctx.r[5].u64 = ctx.r[7].u64 + ctx.r[5].u64;
	// 830BB070: 7C83202E  lwzx r4, r3, r4
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 830BB074: 48000018  b 0x830bb08c
	pc = 0x830BB08C; continue 'dispatch;
	// 830BB078: 80FC0004  lwz r7, 4(r28)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BB07C: 57A4103A  slwi r4, r29, 2
	ctx.r[4].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 830BB080: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830BB084: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830BB088: 7C84382E  lwzx r4, r4, r7
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 830BB08C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BB090: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	// 830BB094: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 830BB098: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 830BB09C: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 830BB0A0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 830BB0A4: 7C7E5A14  add r3, r30, r11
	ctx.r[3].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 830BB0A8: 4BFFFD71  bl 0x830bae18
	ctx.lr = 0x830BB0AC;
	sub_830BAE18(ctx, base);
	// 830BB0AC: 8177007C  lwz r11, 0x7c(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(124 as u32) ) } as u64;
	// 830BB0B0: 556A0319  rlwinm. r10, r11, 0, 0xc, 0xc
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830BB0B4: 4182000C  beq 0x830bb0c0
	if ctx.cr[0].eq {
	pc = 0x830BB0C0; continue 'dispatch;
	}
	// 830BB0B8: 656B0010  oris r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u64 | 1048576;
	// 830BB0BC: 48000018  b 0x830bb0d4
	pc = 0x830BB0D4; continue 'dispatch;
	// 830BB0C0: 556B0314  rlwinm r11, r11, 0, 0xc, 0xa
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830BB0C4: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 830BB0C8: 9177007C  stw r11, 0x7c(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 830BB0CC: 419A000C  beq cr6, 0x830bb0d8
	if ctx.cr[6].eq {
	pc = 0x830BB0D8; continue 'dispatch;
	}
	// 830BB0D0: 556B0314  rlwinm r11, r11, 0, 0xc, 0xa
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830BB0D4: 9177007C  stw r11, 0x7c(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 830BB0D8: 817C000C  lwz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 830BB0DC: 57AA1838  slwi r10, r29, 3
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830BB0E0: 7C8A582E  lwzx r4, r10, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830BB0E4: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 830BB0E8: 41980038  blt cr6, 0x830bb120
	if ctx.cr[6].lt {
	pc = 0x830BB120; continue 'dispatch;
	}
	// 830BB0EC: 39740001  addi r11, r20, 1
	ctx.r[11].s64 = ctx.r[20].s64 + 1;
	// 830BB0F0: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 830BB0F4: 7EEABB78  mr r10, r23
	ctx.r[10].u64 = ctx.r[23].u64;
	// 830BB0F8: 9321005C  stw r25, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[25].u32 ) };
	// 830BB0FC: 7EC8B378  mr r8, r22
	ctx.r[8].u64 = ctx.r[22].u64;
	// 830BB100: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 830BB104: 7EA7AB78  mr r7, r21
	ctx.r[7].u64 = ctx.r[21].u64;
	// 830BB108: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 830BB10C: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 830BB110: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 830BB114: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 830BB118: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BB11C: 4BFFFE1D  bl 0x830baf38
	ctx.lr = 0x830BB120;
	sub_830BAF38(ctx, base);
	// 830BB120: 8177007C  lwz r11, 0x7c(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(124 as u32) ) } as u64;
	// 830BB124: 556B02D7  rlwinm. r11, r11, 0, 0xb, 0xb
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BB128: 4082001C  bne 0x830bb144
	if !ctx.cr[0].eq {
	pc = 0x830BB144; continue 'dispatch;
	}
	// 830BB12C: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 830BB130: 419A0010  beq cr6, 0x830bb140
	if ctx.cr[6].eq {
	pc = 0x830BB140; continue 'dispatch;
	}
	// 830BB134: 817A007C  lwz r11, 0x7c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(124 as u32) ) } as u64;
	// 830BB138: 556B0314  rlwinm r11, r11, 0, 0xc, 0xa
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830BB13C: 917A007C  stw r11, 0x7c(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 830BB140: 927F0008  stw r19, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[19].u32 ) };
	// 830BB144: 48003E05  bl 0x830bef48
	ctx.lr = 0x830BB148;
	sub_830BEF48(ctx, base);
	// 830BB148: 815C000C  lwz r10, 0xc(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 830BB14C: 57AB1838  slwi r11, r29, 3
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830BB150: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830BB154: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BB158: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 830BB15C: 41980034  blt cr6, 0x830bb190
	if ctx.cr[6].lt {
	pc = 0x830BB190; continue 'dispatch;
	}
	// 830BB160: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 830BB164: 9281006C  stw r20, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[20].u32 ) };
	// 830BB168: 7EC8B378  mr r8, r22
	ctx.r[8].u64 = ctx.r[22].u64;
	// 830BB16C: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 830BB170: 7EA7AB78  mr r7, r21
	ctx.r[7].u64 = ctx.r[21].u64;
	// 830BB174: 9321005C  stw r25, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[25].u32 ) };
	// 830BB178: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 830BB17C: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 830BB180: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 830BB184: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 830BB188: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BB18C: 4BFFFDAD  bl 0x830baf38
	ctx.lr = 0x830BB190;
	sub_830BAF38(ctx, base);
	// 830BB190: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830BB194: 91770140  stw r11, 0x140(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(320 as u32), ctx.r[11].u32 ) };
	// 830BB198: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 830BB19C: CBC1FF80  lfd f30, -0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-128 as u32) ) };
	// 830BB1A0: CBE1FF88  lfd f31, -0x78(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-120 as u32) ) };
	// 830BB1A4: 480ECFF0  b 0x831a8194
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BB1A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830BB1A8 size=140
    let mut pc: u32 = 0x830BB1A8;
    'dispatch: loop {
        match pc {
            0x830BB1A8 => {
    //   block [0x830BB1A8..0x830BB234)
	// 830BB1A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BB1AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830BB1B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830BB1B4: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BB1B8: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 830BB1BC: 7CC73378  mr r7, r6
	ctx.r[7].u64 = ctx.r[6].u64;
	// 830BB1C0: 7D465378  mr r6, r10
	ctx.r[6].u64 = ctx.r[10].u64;
	// 830BB1C4: 808B0008  lwz r4, 8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830BB1C8: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 830BB1CC: 41980054  blt cr6, 0x830bb220
	if ctx.cr[6].lt {
	pc = 0x830BB220; continue 'dispatch;
	}
	// 830BB1D0: 814100DC  lwz r10, 0xdc(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) } as u64;
	// 830BB1D4: 555F077B  rlwinm. r31, r10, 0, 0x1d, 0x1d
	ctx.r[31].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830BB1D8: 40820020  bne 0x830bb1f8
	if !ctx.cr[0].eq {
	pc = 0x830BB1F8; continue 'dispatch;
	}
	// 830BB1DC: 555F07BD  rlwinm. r31, r10, 0, 0x1e, 0x1e
	ctx.r[31].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830BB1E0: 40820018  bne 0x830bb1f8
	if !ctx.cr[0].eq {
	pc = 0x830BB1F8; continue 'dispatch;
	}
	// 830BB1E4: 555F07FF  clrlwi. r31, r10, 0x1f
	ctx.r[31].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830BB1E8: 40820038  bne 0x830bb220
	if !ctx.cr[0].eq {
	pc = 0x830BB220; continue 'dispatch;
	}
	// 830BB1EC: 83E30008  lwz r31, 8(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 830BB1F0: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830BB1F4: 409A002C  bne cr6, 0x830bb220
	if !ctx.cr[6].eq {
	pc = 0x830BB220; continue 'dispatch;
	}
	// 830BB1F8: 90C10054  stw r6, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[6].u32 ) };
	// 830BB1FC: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 830BB200: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830BB204: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 830BB208: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 830BB20C: 90A1006C  stw r5, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[5].u32 ) };
	// 830BB210: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 830BB214: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 830BB218: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 830BB21C: 4BFFFD1D  bl 0x830baf38
	ctx.lr = 0x830BB220;
	sub_830BAF38(ctx, base);
	// 830BB220: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830BB224: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830BB228: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830BB22C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830BB230: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BB238(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830BB238 size=872
    let mut pc: u32 = 0x830BB238;
    'dispatch: loop {
        match pc {
            0x830BB238 => {
    //   block [0x830BB238..0x830BB5A0)
	// 830BB238: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BB23C: 480ECF09  bl 0x831a8144
	ctx.lr = 0x830BB240;
	sub_831A8130(ctx, base);
	// 830BB240: DBA1FF78  stfd f29, -0x88(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.f[29].u64 ) };
	// 830BB244: DBC1FF80  stfd f30, -0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), ctx.f[30].u64 ) };
	// 830BB248: DBE1FF88  stfd f31, -0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.f[31].u64 ) };
	// 830BB24C: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BB250: FFA00890  fmr f29, f1
	ctx.f[29].f64 = ctx.f[1].f64;
	// 830BB254: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830BB258: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830BB25C: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 830BB260: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 830BB264: 7CD33378  mr r19, r6
	ctx.r[19].u64 = ctx.r[6].u64;
	// 830BB268: C3CB08A4  lfs f30, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 830BB26C: 7CF63B78  mr r22, r7
	ctx.r[22].u64 = ctx.r[7].u64;
	// 830BB270: 7D384B78  mr r24, r9
	ctx.r[24].u64 = ctx.r[9].u64;
	// 830BB274: FF1DF000  fcmpu cr6, f29, f30
	ctx.cr[6].compare_f64(ctx.f[29].f64, ctx.f[30].f64);
	// 830BB278: 40980008  bge cr6, 0x830bb280
	if !ctx.cr[6].lt {
	pc = 0x830BB280; continue 'dispatch;
	}
	// 830BB27C: FFA0F090  fmr f29, f30
	ctx.f[29].f64 = ctx.f[30].f64;
	// 830BB280: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 830BB284: 3A800000  li r20, 0
	ctx.r[20].s64 = 0;
	// 830BB288: C01F000C  lfs f0, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BB28C: 7E9BA378  mr r27, r20
	ctx.r[27].u64 = ctx.r[20].u64;
	// 830BB290: EFFD0028  fsubs f31, f29, f0
	ctx.f[31].f64 = (((ctx.f[29].f64 - ctx.f[0].f64) as f32) as f64);
	// 830BB294: 7F0BB840  cmplw cr6, r11, r23
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[23].u32, &mut ctx.xer);
	// 830BB298: 409A002C  bne cr6, 0x830bb2c4
	if !ctx.cr[6].eq {
	pc = 0x830BB2C4; continue 'dispatch;
	}
	// 830BB29C: 817F0040  lwz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 830BB2A0: 7F0BB040  cmplw cr6, r11, r22
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[22].u32, &mut ctx.xer);
	// 830BB2A4: 409A0020  bne cr6, 0x830bb2c4
	if !ctx.cr[6].eq {
	pc = 0x830BB2C4; continue 'dispatch;
	}
	// 830BB2A8: FF1FF000  fcmpu cr6, f31, f30
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[30].f64);
	// 830BB2AC: 409A001C  bne cr6, 0x830bb2c8
	if !ctx.cr[6].eq {
	pc = 0x830BB2C8; continue 'dispatch;
	}
	// 830BB2B0: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 830BB2B4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BB2B8: 409A0010  bne cr6, 0x830bb2c8
	if !ctx.cr[6].eq {
	pc = 0x830BB2C8; continue 'dispatch;
	}
	// 830BB2BC: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 830BB2C0: 48000008  b 0x830bb2c8
	pc = 0x830BB2C8; continue 'dispatch;
	// 830BB2C4: 3B600002  li r27, 2
	ctx.r[27].s64 = 2;
	// 830BB2C8: 929F0038  stw r20, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[20].u32 ) };
	// 830BB2CC: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 830BB2D0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830BB2D4: 4BFFCFC5  bl 0x830b8298
	ctx.lr = 0x830BB2D8;
	sub_830B8298(ctx, base);
	// 830BB2D8: C0010060  lfs f0, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BB2DC: C19F0018  lfs f12, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830BB2E0: C1A10064  lfs f13, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830BB2E4: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 830BB2E8: 409A0010  bne cr6, 0x830bb2f8
	if !ctx.cr[6].eq {
	pc = 0x830BB2F8; continue 'dispatch;
	}
	// 830BB2EC: C19F001C  lfs f12, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830BB2F0: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 830BB2F4: 419A0014  beq cr6, 0x830bb308
	if ctx.cr[6].eq {
	pc = 0x830BB308; continue 'dispatch;
	}
	// 830BB2F8: 576B003C  rlwinm r11, r27, 0, 0, 0x1e
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0xFFFFFFFFu64;
	// 830BB2FC: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 830BB300: D1BF001C  stfs f13, 0x1c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 830BB304: 617B000A  ori r27, r11, 0xa
	ctx.r[27].u64 = ctx.r[11].u64 | 10;
	// 830BB308: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 830BB30C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830BB310: 4BFFCFA9  bl 0x830b82b8
	ctx.lr = 0x830BB314;
	sub_830B82B8(ctx, base);
	// 830BB314: C0010060  lfs f0, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BB318: C19F0020  lfs f12, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830BB31C: C1A10064  lfs f13, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830BB320: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 830BB324: 409A0010  bne cr6, 0x830bb334
	if !ctx.cr[6].eq {
	pc = 0x830BB334; continue 'dispatch;
	}
	// 830BB328: C19F0024  lfs f12, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830BB32C: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 830BB330: 419A0014  beq cr6, 0x830bb344
	if ctx.cr[6].eq {
	pc = 0x830BB344; continue 'dispatch;
	}
	// 830BB334: 576B003C  rlwinm r11, r27, 0, 0, 0x1e
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0xFFFFFFFFu64;
	// 830BB338: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 830BB33C: D1BF0024  stfs f13, 0x24(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 830BB340: 617B000A  ori r27, r11, 0xa
	ctx.r[27].u64 = ctx.r[11].u64 | 10;
	// 830BB344: 4BFFD00D  bl 0x830b8350
	ctx.lr = 0x830BB348;
	sub_830B8350(ctx, base);
	// 830BB348: D0210060  stfs f1, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 830BB34C: 4BFFD015  bl 0x830b8360
	ctx.lr = 0x830BB350;
	sub_830B8360(ctx, base);
	// 830BB350: C0010060  lfs f0, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BB354: C1BF0030  lfs f13, 0x30(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830BB358: D0210064  stfs f1, 0x64(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 830BB35C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830BB360: 409A0010  bne cr6, 0x830bb370
	if !ctx.cr[6].eq {
	pc = 0x830BB370; continue 'dispatch;
	}
	// 830BB364: C1BF0034  lfs f13, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830BB368: FF016800  fcmpu cr6, f1, f13
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[13].f64);
	// 830BB36C: 419A0024  beq cr6, 0x830bb390
	if ctx.cr[6].eq {
	pc = 0x830BB390; continue 'dispatch;
	}
	// 830BB370: D01F0030  stfs f0, 0x30(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 830BB374: 576B003C  rlwinm r11, r27, 0, 0, 0x1e
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0xFFFFFFFFu64;
	// 830BB378: D03F0034  stfs f1, 0x34(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 830BB37C: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 830BB380: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 830BB384: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BB388: 617B000A  ori r27, r11, 0xa
	ctx.r[27].u64 = ctx.r[11].u64 | 10;
	// 830BB38C: 480025FD  bl 0x830bd988
	ctx.lr = 0x830BB390;
	sub_830BD988(ctx, base);
	// 830BB390: 3881006C  addi r4, r1, 0x6c
	ctx.r[4].s64 = ctx.r[1].s64 + 108;
	// 830BB394: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 830BB398: 4BFFD051  bl 0x830b83e8
	ctx.lr = 0x830BB39C;
	sub_830B83E8(ctx, base);
	// 830BB39C: C0010068  lfs f0, 0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BB3A0: C19F0028  lfs f12, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830BB3A4: C1A1006C  lfs f13, 0x6c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830BB3A8: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 830BB3AC: 409A0010  bne cr6, 0x830bb3bc
	if !ctx.cr[6].eq {
	pc = 0x830BB3BC; continue 'dispatch;
	}
	// 830BB3B0: C19F002C  lfs f12, 0x2c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830BB3B4: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 830BB3B8: 419A0014  beq cr6, 0x830bb3cc
	if ctx.cr[6].eq {
	pc = 0x830BB3CC; continue 'dispatch;
	}
	// 830BB3BC: 576B003C  rlwinm r11, r27, 0, 0, 0x1e
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0xFFFFFFFFu64;
	// 830BB3C0: D01F0028  stfs f0, 0x28(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 830BB3C4: D1BF002C  stfs f13, 0x2c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 830BB3C8: 617B000A  ori r27, r11, 0xa
	ctx.r[27].u64 = ctx.r[11].u64 | 10;
	// 830BB3CC: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830BB3D0: 7F0BC040  cmplw cr6, r11, r24
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[24].u32, &mut ctx.xer);
	// 830BB3D4: 409A0018  bne cr6, 0x830bb3ec
	if !ctx.cr[6].eq {
	pc = 0x830BB3EC; continue 'dispatch;
	}
	// 830BB3D8: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 830BB3DC: 419A0014  beq cr6, 0x830bb3f0
	if ctx.cr[6].eq {
	pc = 0x830BB3F0; continue 'dispatch;
	}
	// 830BB3E0: 8178007C  lwz r11, 0x7c(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(124 as u32) ) } as u64;
	// 830BB3E4: 556B0421  rlwinm. r11, r11, 0, 0x10, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BB3E8: 41820008  beq 0x830bb3f0
	if ctx.cr[0].eq {
	pc = 0x830BB3F0; continue 'dispatch;
	}
	// 830BB3EC: 637B0004  ori r27, r27, 4
	ctx.r[27].u64 = ctx.r[27].u64 | 4;
	// 830BB3F0: C01F0010  lfs f0, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BB3F4: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 830BB3F8: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 830BB3FC: 40980008  bge cr6, 0x830bb404
	if !ctx.cr[6].lt {
	pc = 0x830BB404; continue 'dispatch;
	}
	// 830BB400: 637B0002  ori r27, r27, 2
	ctx.r[27].u64 = ctx.r[27].u64 | 2;
	// 830BB404: D3BF000C  stfs f29, 0xc(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830BB408: 92FF003C  stw r23, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[23].u32 ) };
	// 830BB40C: 92DF0040  stw r22, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[22].u32 ) };
	// 830BB410: FF1FF000  fcmpu cr6, f31, f30
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[30].f64);
	// 830BB414: 419A0008  beq cr6, 0x830bb41c
	if ctx.cr[6].eq {
	pc = 0x830BB41C; continue 'dispatch;
	}
	// 830BB418: D3FF0010  stfs f31, 0x10(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 830BB41C: 576B077B  rlwinm. r11, r27, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BB420: 931F0014  stw r24, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[24].u32 ) };
	// 830BB424: 40820020  bne 0x830bb444
	if !ctx.cr[0].eq {
	pc = 0x830BB444; continue 'dispatch;
	}
	// 830BB428: 576B07FF  clrlwi. r11, r27, 0x1f
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BB42C: 40820160  bne 0x830bb58c
	if !ctx.cr[0].eq {
	pc = 0x830BB58C; continue 'dispatch;
	}
	// 830BB430: 576B07BD  rlwinm. r11, r27, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BB434: 40820010  bne 0x830bb444
	if !ctx.cr[0].eq {
	pc = 0x830BB444; continue 'dispatch;
	}
	// 830BB438: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830BB43C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BB440: 409A014C  bne cr6, 0x830bb58c
	if !ctx.cr[6].eq {
	pc = 0x830BB58C; continue 'dispatch;
	}
	// 830BB444: 7E95A378  mr r21, r20
	ctx.r[21].u64 = ctx.r[20].u64;
	// 830BB448: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 830BB44C: 419A0010  beq cr6, 0x830bb45c
	if ctx.cr[6].eq {
	pc = 0x830BB45C; continue 'dispatch;
	}
	// 830BB450: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 830BB454: 82B8007C  lwz r21, 0x7c(r24)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(124 as u32) ) } as u64;
	// 830BB458: 480041F1  bl 0x830bf648
	ctx.lr = 0x830BB45C;
	sub_830BF648(ctx, base);
	// 830BB45C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830BB460: 2B170000  cmplwi cr6, r23, 0
	ctx.cr[6].compare_u32(ctx.r[23].u32, 0 as u32, &mut ctx.xer);
	// 830BB464: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830BB468: 817A0024  lwz r11, 0x24(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(36 as u32) ) } as u64;
	// 830BB46C: 419A00A0  beq cr6, 0x830bb50c
	if ctx.cr[6].eq {
	pc = 0x830BB50C; continue 'dispatch;
	}
	// 830BB470: 7E99A378  mr r25, r20
	ctx.r[25].u64 = ctx.r[20].u64;
	// 830BB474: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BB478: 40990104  ble cr6, 0x830bb57c
	if !ctx.cr[6].gt {
	pc = 0x830BB57C; continue 'dispatch;
	}
	// 830BB47C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BB480: 7E9EA378  mr r30, r20
	ctx.r[30].u64 = ctx.r[20].u64;
	// 830BB484: 7E9DA378  mr r29, r20
	ctx.r[29].u64 = ctx.r[20].u64;
	// 830BB488: 7E9CA378  mr r28, r20
	ctx.r[28].u64 = ctx.r[20].u64;
	// 830BB48C: 2B130000  cmplwi cr6, r19, 0
	ctx.cr[6].compare_u32(ctx.r[19].u32, 0 as u32, &mut ctx.xer);
	// 830BB490: 419A0010  beq cr6, 0x830bb4a0
	if ctx.cr[6].eq {
	pc = 0x830BB4A0; continue 'dispatch;
	}
	// 830BB494: 81530004  lwz r10, 4(r19)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BB498: 7CCAE02E  lwzx r6, r10, r28
	ctx.r[6].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 830BB49C: 48000008  b 0x830bb4a4
	pc = 0x830BB4A4; continue 'dispatch;
	// 830BB4A0: 7E86A378  mr r6, r20
	ctx.r[6].u64 = ctx.r[20].u64;
	// 830BB4A4: 80B70004  lwz r5, 4(r23)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BB4A8: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 830BB4AC: 80FA0028  lwz r7, 0x28(r26)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(40 as u32) ) } as u64;
	// 830BB4B0: 7F09C378  mr r9, r24
	ctx.r[9].u64 = ctx.r[24].u64;
	// 830BB4B4: 7EC8B378  mr r8, r22
	ctx.r[8].u64 = ctx.r[22].u64;
	// 830BB4B8: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 830BB4BC: 7CBD2A14  add r5, r29, r5
	ctx.r[5].u64 = ctx.r[29].u64 + ctx.r[5].u64;
	// 830BB4C0: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 830BB4C4: 7C9E3A14  add r4, r30, r7
	ctx.r[4].u64 = ctx.r[30].u64 + ctx.r[7].u64;
	// 830BB4C8: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 830BB4CC: 7C7E5A14  add r3, r30, r11
	ctx.r[3].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 830BB4D0: 4BFFFCD9  bl 0x830bb1a8
	ctx.lr = 0x830BB4D4;
	sub_830BB1A8(ctx, base);
	// 830BB4D4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BB4D8: 7D5E5A14  add r10, r30, r11
	ctx.r[10].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 830BB4DC: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 830BB4E0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830BB4E4: 409A0008  bne cr6, 0x830bb4ec
	if !ctx.cr[6].eq {
	pc = 0x830BB4EC; continue 'dispatch;
	}
	// 830BB4E8: 929F0008  stw r20, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[20].u32 ) };
	// 830BB4EC: 815A0024  lwz r10, 0x24(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(36 as u32) ) } as u64;
	// 830BB4F0: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 830BB4F4: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 830BB4F8: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 830BB4FC: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 830BB500: 7F195000  cmpw cr6, r25, r10
	ctx.cr[6].compare_i32(ctx.r[25].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830BB504: 4198FF88  blt cr6, 0x830bb48c
	if ctx.cr[6].lt {
	pc = 0x830BB48C; continue 'dispatch;
	}
	// 830BB508: 48000074  b 0x830bb57c
	pc = 0x830BB57C; continue 'dispatch;
	// 830BB50C: 7E9DA378  mr r29, r20
	ctx.r[29].u64 = ctx.r[20].u64;
	// 830BB510: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BB514: 40990068  ble cr6, 0x830bb57c
	if !ctx.cr[6].gt {
	pc = 0x830BB57C; continue 'dispatch;
	}
	// 830BB518: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BB51C: 7E9EA378  mr r30, r20
	ctx.r[30].u64 = ctx.r[20].u64;
	// 830BB520: 80FA0028  lwz r7, 0x28(r26)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(40 as u32) ) } as u64;
	// 830BB524: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 830BB528: 7F09C378  mr r9, r24
	ctx.r[9].u64 = ctx.r[24].u64;
	// 830BB52C: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 830BB530: 7EC8B378  mr r8, r22
	ctx.r[8].u64 = ctx.r[22].u64;
	// 830BB534: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 830BB538: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830BB53C: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 830BB540: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830BB544: 7C9E3A14  add r4, r30, r7
	ctx.r[4].u64 = ctx.r[30].u64 + ctx.r[7].u64;
	// 830BB548: 7C7E5A14  add r3, r30, r11
	ctx.r[3].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 830BB54C: 4BFFFC5D  bl 0x830bb1a8
	ctx.lr = 0x830BB550;
	sub_830BB1A8(ctx, base);
	// 830BB550: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BB554: 7D5E5A14  add r10, r30, r11
	ctx.r[10].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 830BB558: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 830BB55C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830BB560: 409A0008  bne cr6, 0x830bb568
	if !ctx.cr[6].eq {
	pc = 0x830BB568; continue 'dispatch;
	}
	// 830BB564: 929F0008  stw r20, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[20].u32 ) };
	// 830BB568: 815A0024  lwz r10, 0x24(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(36 as u32) ) } as u64;
	// 830BB56C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 830BB570: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 830BB574: 7F1D5000  cmpw cr6, r29, r10
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830BB578: 4198FFA8  blt cr6, 0x830bb520
	if ctx.cr[6].lt {
	pc = 0x830BB520; continue 'dispatch;
	}
	// 830BB57C: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 830BB580: 419A000C  beq cr6, 0x830bb58c
	if ctx.cr[6].eq {
	pc = 0x830BB58C; continue 'dispatch;
	}
	// 830BB584: 92B8007C  stw r21, 0x7c(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(124 as u32), ctx.r[21].u32 ) };
	// 830BB588: 480039C1  bl 0x830bef48
	ctx.lr = 0x830BB58C;
	sub_830BEF48(ctx, base);
	// 830BB58C: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 830BB590: CBA1FF78  lfd f29, -0x88(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-136 as u32) ) };
	// 830BB594: CBC1FF80  lfd f30, -0x80(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-128 as u32) ) };
	// 830BB598: CBE1FF88  lfd f31, -0x78(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-120 as u32) ) };
	// 830BB59C: 480ECBF8  b 0x831a8194
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BB5A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BB5A0 size=12
    let mut pc: u32 = 0x830BB5A0;
    'dispatch: loop {
        match pc {
            0x830BB5A0 => {
    //   block [0x830BB5A0..0x830BB5AC)
	// 830BB5A0: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830BB5A4: 806BBD2C  lwz r3, -0x42d4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17108 as u32) ) } as u64;
	// 830BB5A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BB5B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BB5B0 size=120
    let mut pc: u32 = 0x830BB5B0;
    'dispatch: loop {
        match pc {
            0x830BB5B0 => {
    //   block [0x830BB5B0..0x830BB628)
	// 830BB5B0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830BB5B4: 419A006C  beq cr6, 0x830bb620
	if ctx.cr[6].eq {
	pc = 0x830BB620; continue 'dispatch;
	}
	// 830BB5B8: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830BB5BC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 830BB5C0: 396BBD1C  addi r11, r11, -0x42e4
	ctx.r[11].s64 = ctx.r[11].s64 + -17124;
	// 830BB5C4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830BB5C8: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830BB5CC: 7F092040  cmplw cr6, r9, r4
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[4].u32, &mut ctx.xer);
	// 830BB5D0: 409A0020  bne cr6, 0x830bb5f0
	if !ctx.cr[6].eq {
	pc = 0x830BB5F0; continue 'dispatch;
	}
	// 830BB5D4: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BB5D8: 7F091800  cmpw cr6, r9, r3
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[3].s32, &mut ctx.xer);
	// 830BB5DC: 41990014  bgt cr6, 0x830bb5f0
	if ctx.cr[6].gt {
	pc = 0x830BB5F0; continue 'dispatch;
	}
	// 830BB5E0: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BB5E4: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 830BB5E8: 2F09000F  cmpwi cr6, r9, 0xf
	ctx.cr[6].compare_i32(ctx.r[9].s32, 15, &mut ctx.xer);
	// 830BB5EC: 4098002C  bge cr6, 0x830bb618
	if !ctx.cr[6].lt {
	pc = 0x830BB618; continue 'dispatch;
	}
	// 830BB5F0: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 830BB5F4: 7F0A1800  cmpw cr6, r10, r3
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[3].s32, &mut ctx.xer);
	// 830BB5F8: 419A0030  beq cr6, 0x830bb628
	if ctx.cr[6].eq {
		sub_830BB628(ctx, base);
		return;
	}
	// 830BB5FC: 7D275030  slw r7, r9, r10
	if (ctx.r[10].u8 & 0x20) != 0 {
		ctx.r[7].u64 = 0;
	} else {
		ctx.r[7].u64 = ((ctx.r[9].u32) << ((ctx.r[10].u8 & 0x1F) as u32)) as u64;
	}
	// 830BB600: 7CE72039  and. r7, r7, r4
	ctx.r[7].u64 = ctx.r[7].u64 & ctx.r[4].u64;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 830BB604: 41820008  beq 0x830bb60c
	if ctx.cr[0].eq {
	pc = 0x830BB60C; continue 'dispatch;
	}
	// 830BB608: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 830BB60C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830BB610: 2F0A000F  cmpwi cr6, r10, 0xf
	ctx.cr[6].compare_i32(ctx.r[10].s32, 15, &mut ctx.xer);
	// 830BB614: 4198FFE0  blt cr6, 0x830bb5f4
	if ctx.cr[6].lt {
	pc = 0x830BB5F4; continue 'dispatch;
	}
	// 830BB618: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830BB61C: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 830BB620: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 830BB624: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BB628(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BB628 size=32
    let mut pc: u32 = 0x830BB628;
    'dispatch: loop {
        match pc {
            0x830BB628 => {
    //   block [0x830BB628..0x830BB648)
	// 830BB628: 7D2A5030  slw r10, r9, r10
	if (ctx.r[10].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[9].u32) << ((ctx.r[10].u8 & 0x1F) as u32)) as u64;
	}
	// 830BB62C: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 830BB630: 7D4A2039  and. r10, r10, r4
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[4].u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830BB634: 906B0004  stw r3, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 830BB638: 908B000C  stw r4, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[4].u32 ) };
	// 830BB63C: 4182FFE4  beq 0x830bb620
	if ctx.cr[0].eq {
		sub_830BB5B0(ctx, base);
		return;
	}
	// 830BB640: 7D034378  mr r3, r8
	ctx.r[3].u64 = ctx.r[8].u64;
	// 830BB644: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BB648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830BB648 size=176
    let mut pc: u32 = 0x830BB648;
    'dispatch: loop {
        match pc {
            0x830BB648 => {
    //   block [0x830BB648..0x830BB6F8)
	// 830BB648: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BB64C: 480ECB21  bl 0x831a816c
	ctx.lr = 0x830BB650;
	sub_831A8130(ctx, base);
	// 830BB650: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 830BB654: 3C808339  lis r4, -0x7cc7
	ctx.r[4].s64 = -2093416448;
	// 830BB658: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 830BB65C: 3D408339  lis r10, -0x7cc7
	ctx.r[10].s64 = -2093416448;
	// 830BB660: 3BA4BD30  addi r29, r4, -0x42d0
	ctx.r[29].s64 = ctx.r[4].s64 + -17104;
	// 830BB664: C00908A4  lfs f0, 0x8a4(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BB668: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 830BB66C: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 830BB670: 394ABD2C  addi r10, r10, -0x42d4
	ctx.r[10].s64 = ctx.r[10].s64 + -17108;
	// 830BB674: C1A608A8  lfs f13, 0x8a8(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830BB678: 9124BD30  stw r9, -0x42d0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(-17104 as u32), ctx.r[9].u32 ) };
	// 830BB67C: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 830BB680: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 830BB684: 917D002C  stw r11, 0x2c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 830BB688: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 830BB68C: D01D0004  stfs f0, 4(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830BB690: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 830BB694: D01D0008  stfs f0, 8(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 830BB698: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 830BB69C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BB6A0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830BB6A4: D01D000C  stfs f0, 0xc(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830BB6A8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830BB6AC: D1BD0010  stfs f13, 0x10(r29)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 830BB6B0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 830BB6B4: D1BD0014  stfs f13, 0x14(r29)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 830BB6B8: D01D0018  stfs f0, 0x18(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 830BB6BC: 911D001C  stw r8, 0x1c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(28 as u32), ctx.r[8].u32 ) };
	// 830BB6C0: 90FD0020  stw r7, 0x20(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(32 as u32), ctx.r[7].u32 ) };
	// 830BB6C4: 90DD0024  stw r6, 0x24(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), ctx.r[6].u32 ) };
	// 830BB6C8: 90BD0028  stw r5, 0x28(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(40 as u32), ctx.r[5].u32 ) };
	// 830BB6CC: 909D0030  stw r4, 0x30(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(48 as u32), ctx.r[4].u32 ) };
	// 830BB6D0: 907D0034  stw r3, 0x34(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(52 as u32), ctx.r[3].u32 ) };
	// 830BB6D4: 93FD0038  stw r31, 0x38(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(56 as u32), ctx.r[31].u32 ) };
	// 830BB6D8: 93CAFFF8  stw r30, -8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-8 as u32), ctx.r[30].u32 ) };
	// 830BB6DC: 7FC84830  slw r8, r30, r9
	if (ctx.r[9].u8 & 0x20) != 0 {
		ctx.r[8].u64 = 0;
	} else {
		ctx.r[8].u64 = ((ctx.r[30].u32) << ((ctx.r[9].u8 & 0x1F) as u32)) as u64;
	}
	// 830BB6E0: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 830BB6E4: 7D0B5B78  or r11, r8, r11
	ctx.r[11].u64 = ctx.r[8].u64 | ctx.r[11].u64;
	// 830BB6E8: 2F09000F  cmpwi cr6, r9, 0xf
	ctx.cr[6].compare_i32(ctx.r[9].s32, 15, &mut ctx.xer);
	// 830BB6EC: 4198FFF0  blt cr6, 0x830bb6dc
	if ctx.cr[6].lt {
	pc = 0x830BB6DC; continue 'dispatch;
	}
	// 830BB6F0: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830BB6F4: 480ECAC8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BB6F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BB6F8 size=28
    let mut pc: u32 = 0x830BB6F8;
    'dispatch: loop {
        match pc {
            0x830BB6F8 => {
    //   block [0x830BB6F8..0x830BB714)
	// 830BB6F8: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BB6FC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BB700: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BB704: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BB708: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830BB70C: 7C684850  subf r3, r8, r9
	ctx.r[3].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 830BB710: 4D820020  beqlr
	if ctx.cr[0].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BB714(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BB714 size=20
    let mut pc: u32 = 0x830BB714;
    'dispatch: loop {
        match pc {
            0x830BB714 => {
    //   block [0x830BB714..0x830BB728)
	// 830BB714: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830BB718: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830BB71C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830BB720: 419AFFE0  beq cr6, 0x830bb700
	if ctx.cr[6].eq {
		sub_830BB6F8(ctx, base);
		return;
	}
	// 830BB724: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BB728(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830BB728 size=164
    let mut pc: u32 = 0x830BB728;
    'dispatch: loop {
        match pc {
            0x830BB728 => {
    //   block [0x830BB728..0x830BB7CC)
	// 830BB728: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BB72C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830BB730: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830BB734: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BB738: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830BB73C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830BB740: 816BBD24  lwz r11, -0x42dc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17116 as u32) ) } as u64;
	// 830BB744: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BB748: 409A0008  bne cr6, 0x830bb750
	if !ctx.cr[6].eq {
	pc = 0x830BB750; continue 'dispatch;
	}
	// 830BB74C: 4BFFFEFD  bl 0x830bb648
	ctx.lr = 0x830BB750;
	sub_830BB648(ctx, base);
	// 830BB750: 38A00144  li r5, 0x144
	ctx.r[5].s64 = 324;
	// 830BB754: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830BB758: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BB75C: 480ECA85  bl 0x831a81e0
	ctx.lr = 0x830BB760;
	sub_831A81E0(ctx, base);
	// 830BB760: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BB764: 4800311D  bl 0x830be880
	ctx.lr = 0x830BB768;
	sub_830BE880(ctx, base);
	// 830BB768: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 830BB76C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 830BB770: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 830BB774: 3CE08213  lis r7, -0x7ded
	ctx.r[7].s64 = -2112684032;
	// 830BB778: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 830BB77C: C00A08A8  lfs f0, 0x8a8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BB780: C1A908A4  lfs f13, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830BB784: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 830BB788: C1889534  lfs f12, -0x6acc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830BB78C: 917F0044  stw r11, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[11].u32 ) };
	// 830BB790: C167B7B4  lfs f11, -0x484c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-18508 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830BB794: 917F0054  stw r11, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 830BB798: D01F0038  stfs f0, 0x38(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 830BB79C: 917F0050  stw r11, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830BB7A0: D01F003C  stfs f0, 0x3c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 830BB7A4: 917F004C  stw r11, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[11].u32 ) };
	// 830BB7A8: D1BF0040  stfs f13, 0x40(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 830BB7AC: 917F0048  stw r11, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 830BB7B0: D19F006C  stfs f12, 0x6c(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 830BB7B4: D17F0070  stfs f11, 0x70(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 830BB7B8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830BB7BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830BB7C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830BB7C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830BB7C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BB7D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830BB7D0 size=188
    let mut pc: u32 = 0x830BB7D0;
    'dispatch: loop {
        match pc {
            0x830BB7D0 => {
    //   block [0x830BB7D0..0x830BB88C)
	// 830BB7D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BB7D4: 480EC991  bl 0x831a8164
	ctx.lr = 0x830BB7D8;
	sub_831A8130(ctx, base);
	// 830BB7D8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BB7DC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830BB7E0: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 830BB7E4: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 830BB7E8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830BB7EC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 830BB7F0: 3D40830C  lis r10, -0x7cf4
	ctx.r[10].s64 = -2096365568;
	// 830BB7F4: 38C00008  li r6, 8
	ctx.r[6].s64 = 8;
	// 830BB7F8: 38EAB6F8  addi r7, r10, -0x4908
	ctx.r[7].s64 = ctx.r[10].s64 + -18696;
	// 830BB7FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830BB800: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 830BB804: 80BF0000  lwz r5, 0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BB808: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830BB80C: 480F4895  bl 0x831b00a0
	ctx.lr = 0x830BB810;
	sub_831B00A0(ctx, base);
	// 830BB810: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830BB814: 41820028  beq 0x830bb83c
	if ctx.cr[0].eq {
	pc = 0x830BB83C; continue 'dispatch;
	}
	// 830BB818: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 830BB81C: 419A000C  beq cr6, 0x830bb828
	if ctx.cr[6].eq {
	pc = 0x830BB828; continue 'dispatch;
	}
	// 830BB820: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BB824: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830BB828: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BB82C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BB830: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830BB834: 7C6B502E  lwzx r3, r11, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830BB838: 4800004C  b 0x830bb884
	pc = 0x830BB884; continue 'dispatch;
	// 830BB83C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830BB840: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 830BB844: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BB848: 40990038  ble cr6, 0x830bb880
	if !ctx.cr[6].gt {
	pc = 0x830BB880; continue 'dispatch;
	}
	// 830BB84C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830BB850: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830BB854: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 830BB858: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830BB85C: 7C8BF214  add r4, r11, r30
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 830BB860: 4BFFFF71  bl 0x830bb7d0
	ctx.lr = 0x830BB864;
	sub_830BB7D0(ctx, base);
	// 830BB864: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830BB868: 4082001C  bne 0x830bb884
	if !ctx.cr[0].eq {
	pc = 0x830BB884; continue 'dispatch;
	}
	// 830BB86C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830BB870: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 830BB874: 3BDE0018  addi r30, r30, 0x18
	ctx.r[30].s64 = ctx.r[30].s64 + 24;
	// 830BB878: 7F1B5800  cmpw cr6, r27, r11
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830BB87C: 4198FFD4  blt cr6, 0x830bb850
	if ctx.cr[6].lt {
	pc = 0x830BB850; continue 'dispatch;
	}
	// 830BB880: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830BB884: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830BB888: 480EC92C  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BB890(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830BB890 size=72
    let mut pc: u32 = 0x830BB890;
    'dispatch: loop {
        match pc {
            0x830BB890 => {
    //   block [0x830BB890..0x830BB8D8)
	// 830BB890: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BB894: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830BB898: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BB89C: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 830BB8A0: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 830BB8A4: 3D40830C  lis r10, -0x7cf4
	ctx.r[10].s64 = -2096365568;
	// 830BB8A8: 80A4002C  lwz r5, 0x2c(r4)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(44 as u32) ) } as u64;
	// 830BB8AC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 830BB8B0: 38C0000C  li r6, 0xc
	ctx.r[6].s64 = 12;
	// 830BB8B4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 830BB8B8: 38EAB6F8  addi r7, r10, -0x4908
	ctx.r[7].s64 = ctx.r[10].s64 + -18696;
	// 830BB8BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830BB8C0: 80840030  lwz r4, 0x30(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(48 as u32) ) } as u64;
	// 830BB8C4: 480F47DD  bl 0x831b00a0
	ctx.lr = 0x830BB8C8;
	sub_831B00A0(ctx, base);
	// 830BB8C8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830BB8CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830BB8D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830BB8D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BB8D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830BB8D8 size=196
    let mut pc: u32 = 0x830BB8D8;
    'dispatch: loop {
        match pc {
            0x830BB8D8 => {
    //   block [0x830BB8D8..0x830BB99C)
	// 830BB8D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BB8DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830BB8E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830BB8E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830BB8E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BB8EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830BB8F0: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 830BB8F4: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BB8F8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830BB8FC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830BB900: 409AFFF4  bne cr6, 0x830bb8f4
	if !ctx.cr[6].eq {
	pc = 0x830BB8F4; continue 'dispatch;
	}
	// 830BB904: 7D7F5850  subf r11, r31, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[31].s64;
	// 830BB908: 3D408218  lis r10, -0x7de8
	ctx.r[10].s64 = -2112356352;
	// 830BB90C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830BB910: 388A76E0  addi r4, r10, 0x76e0
	ctx.r[4].s64 = ctx.r[10].s64 + 30432;
	// 830BB914: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830BB918: 38A002D3  li r5, 0x2d3
	ctx.r[5].s64 = 723;
	// 830BB91C: 386B0001  addi r3, r11, 1
	ctx.r[3].s64 = ctx.r[11].s64 + 1;
	// 830BB920: 4BFF9339  bl 0x830b4c58
	ctx.lr = 0x830BB924;
	sub_830B4C58(ctx, base);
	// 830BB924: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830BB928: 40820010  bne 0x830bb938
	if !ctx.cr[0].eq {
	pc = 0x830BB938; continue 'dispatch;
	}
	// 830BB92C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830BB930: 997F0000  stb r11, 0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 830BB934: 48000050  b 0x830bb984
	pc = 0x830BB984; continue 'dispatch;
	// 830BB938: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 830BB93C: 7D5FF050  subf r10, r31, r30
	ctx.r[10].s64 = ctx.r[30].s64 - ctx.r[31].s64;
	// 830BB940: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BB944: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830BB948: 7D2A59AE  stbx r9, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u8) };
	// 830BB94C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830BB950: 4082FFF0  bne 0x830bb940
	if !ctx.cr[0].eq {
	pc = 0x830BB940; continue 'dispatch;
	}
	// 830BB954: 3880002F  li r4, 0x2f
	ctx.r[4].s64 = 47;
	// 830BB958: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BB95C: 480F14C5  bl 0x831ace20
	ctx.lr = 0x830BB960;
	sub_831ACE20(ctx, base);
	// 830BB960: 39630001  addi r11, r3, 1
	ctx.r[11].s64 = ctx.r[3].s64 + 1;
	// 830BB964: 7D4BF850  subf r10, r11, r31
	ctx.r[10].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 830BB968: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BB96C: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830BB970: 7D2A59AE  stbx r9, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u8) };
	// 830BB974: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830BB978: 4082FFF0  bne 0x830bb968
	if !ctx.cr[0].eq {
	pc = 0x830BB968; continue 'dispatch;
	}
	// 830BB97C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830BB980: 4BFF9301  bl 0x830b4c80
	ctx.lr = 0x830BB984;
	sub_830B4C80(ctx, base);
	// 830BB984: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830BB988: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830BB98C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830BB990: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830BB994: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830BB998: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BB9A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830BB9A0 size=348
    let mut pc: u32 = 0x830BB9A0;
    'dispatch: loop {
        match pc {
            0x830BB9A0 => {
    //   block [0x830BB9A0..0x830BBAFC)
	// 830BB9A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BB9A4: 480EC7C1  bl 0x831a8164
	ctx.lr = 0x830BB9A8;
	sub_831A8130(ctx, base);
	// 830BB9A8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BB9AC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830BB9B0: 3880002F  li r4, 0x2f
	ctx.r[4].s64 = 47;
	// 830BB9B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830BB9B8: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 830BB9BC: 480F1465  bl 0x831ace20
	ctx.lr = 0x830BB9C0;
	sub_831ACE20(ctx, base);
	// 830BB9C0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830BB9C4: 418200CC  beq 0x830bba90
	if ctx.cr[0].eq {
	pc = 0x830BBA90; continue 'dispatch;
	}
	// 830BB9C8: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 830BB9CC: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BB9D0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830BB9D4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830BB9D8: 409AFFF4  bne cr6, 0x830bb9cc
	if !ctx.cr[6].eq {
	pc = 0x830BB9CC; continue 'dispatch;
	}
	// 830BB9DC: 7D7F5850  subf r11, r31, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[31].s64;
	// 830BB9E0: 3D408218  lis r10, -0x7de8
	ctx.r[10].s64 = -2112356352;
	// 830BB9E4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830BB9E8: 388A76E0  addi r4, r10, 0x76e0
	ctx.r[4].s64 = ctx.r[10].s64 + 30432;
	// 830BB9EC: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830BB9F0: 38A00305  li r5, 0x305
	ctx.r[5].s64 = 773;
	// 830BB9F4: 386B0001  addi r3, r11, 1
	ctx.r[3].s64 = ctx.r[11].s64 + 1;
	// 830BB9F8: 4BFF9261  bl 0x830b4c58
	ctx.lr = 0x830BB9FC;
	sub_830B4C58(ctx, base);
	// 830BB9FC: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830BBA00: 418200F0  beq 0x830bbaf0
	if ctx.cr[0].eq {
	pc = 0x830BBAF0; continue 'dispatch;
	}
	// 830BBA04: 3880002F  li r4, 0x2f
	ctx.r[4].s64 = 47;
	// 830BBA08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BBA0C: 480F1415  bl 0x831ace20
	ctx.lr = 0x830BBA10;
	sub_831ACE20(ctx, base);
	// 830BBA10: 7F9F1850  subf r28, r31, r3
	ctx.r[28].s64 = ctx.r[3].s64 - ctx.r[31].s64;
	// 830BBA14: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830BBA18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830BBA1C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 830BBA20: 480F0AD1  bl 0x831ac4f0
	ctx.lr = 0x830BBA24;
	sub_831AC4F0(ctx, base);
	// 830BBA24: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830BBA28: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 830BBA2C: 7D7CF1AE  stbx r11, r28, r30
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[28].u32.wrapping_add(ctx.r[30].u32), ctx.r[11].u8) };
	// 830BBA30: 3D60830C  lis r11, -0x7cf4
	ctx.r[11].s64 = -2096365568;
	// 830BBA34: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 830BBA38: 38C00008  li r6, 8
	ctx.r[6].s64 = 8;
	// 830BBA3C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 830BBA40: 38EBB6F8  addi r7, r11, -0x4908
	ctx.r[7].s64 = ctx.r[11].s64 + -18696;
	// 830BBA44: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830BBA48: 80BD000C  lwz r5, 0xc(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 830BBA4C: 809D0014  lwz r4, 0x14(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 830BBA50: 480F4651  bl 0x831b00a0
	ctx.lr = 0x830BBA54;
	sub_831B00A0(ctx, base);
	// 830BBA54: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 830BBA58: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830BBA5C: 4BFF9225  bl 0x830b4c80
	ctx.lr = 0x830BBA60;
	sub_830B4C80(ctx, base);
	// 830BBA60: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 830BBA64: 419A008C  beq cr6, 0x830bbaf0
	if ctx.cr[6].eq {
	pc = 0x830BBAF0; continue 'dispatch;
	}
	// 830BBA68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BBA6C: 4BFFFE6D  bl 0x830bb8d8
	ctx.lr = 0x830BBA70;
	sub_830BB8D8(ctx, base);
	// 830BBA70: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BBA74: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 830BBA78: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 830BBA7C: 1D4A0018  mulli r10, r10, 0x18
	ctx.r[10].s64 = ctx.r[10].s64 * 24;
	// 830BBA80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BBA84: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 830BBA88: 4BFFFF19  bl 0x830bb9a0
	ctx.lr = 0x830BBA8C;
	sub_830BB9A0(ctx, base);
	// 830BBA8C: 48000068  b 0x830bbaf4
	pc = 0x830BBAF4; continue 'dispatch;
	// 830BBA90: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 830BBA94: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 830BBA98: 3D40830C  lis r10, -0x7cf4
	ctx.r[10].s64 = -2096365568;
	// 830BBA9C: 80BD0000  lwz r5, 0(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BBAA0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 830BBAA4: 38C00008  li r6, 8
	ctx.r[6].s64 = 8;
	// 830BBAA8: 38EAB6F8  addi r7, r10, -0x4908
	ctx.r[7].s64 = ctx.r[10].s64 + -18696;
	// 830BBAAC: 809D0008  lwz r4, 8(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 830BBAB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830BBAB4: 480F45ED  bl 0x831b00a0
	ctx.lr = 0x830BBAB8;
	sub_831B00A0(ctx, base);
	// 830BBAB8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830BBABC: 41820034  beq 0x830bbaf0
	if ctx.cr[0].eq {
	pc = 0x830BBAF0; continue 'dispatch;
	}
	// 830BBAC0: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 830BBAC4: 419A0018  beq cr6, 0x830bbadc
	if ctx.cr[6].eq {
	pc = 0x830BBADC; continue 'dispatch;
	}
	// 830BBAC8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BBACC: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 830BBAD0: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830BBAD4: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830BBAD8: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830BBADC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BBAE0: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BBAE4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830BBAE8: 7C6B502E  lwzx r3, r11, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830BBAEC: 48000008  b 0x830bbaf4
	pc = 0x830BBAF4; continue 'dispatch;
	// 830BBAF0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830BBAF4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830BBAF8: 480EC6BC  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BBB00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830BBB00 size=88
    let mut pc: u32 = 0x830BBB00;
    'dispatch: loop {
        match pc {
            0x830BBB00 => {
    //   block [0x830BBB00..0x830BBB58)
	// 830BBB00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BBB04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830BBB08: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BBB0C: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 830BBB10: 90A10050  stw r5, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[5].u32 ) };
	// 830BBB14: 3D40830C  lis r10, -0x7cf4
	ctx.r[10].s64 = -2096365568;
	// 830BBB18: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 830BBB1C: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 830BBB20: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830BBB24: 38C00008  li r6, 8
	ctx.r[6].s64 = 8;
	// 830BBB28: 38EAB6F8  addi r7, r10, -0x4908
	ctx.r[7].s64 = ctx.r[10].s64 + -18696;
	// 830BBB2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830BBB30: 480F4571  bl 0x831b00a0
	ctx.lr = 0x830BBB34;
	sub_831B00A0(ctx, base);
	// 830BBB34: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830BBB38: 4182000C  beq 0x830bbb44
	if ctx.cr[0].eq {
	pc = 0x830BBB44; continue 'dispatch;
	}
	// 830BBB3C: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BBB40: 48000008  b 0x830bbb48
	pc = 0x830BBB48; continue 'dispatch;
	// 830BBB44: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 830BBB48: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830BBB4C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830BBB50: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830BBB54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BBB58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830BBB58 size=128
    let mut pc: u32 = 0x830BBB58;
    'dispatch: loop {
        match pc {
            0x830BBB58 => {
    //   block [0x830BBB58..0x830BBBD8)
	// 830BBB58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BBB5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830BBB60: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830BBB64: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830BBB68: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BBB6C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830BBB70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830BBB74: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 830BBB78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830BBB7C: 4BFFFA35  bl 0x830bb5b0
	ctx.lr = 0x830BBB80;
	sub_830BB5B0(ctx, base);
	// 830BBB80: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830BBB84: 4080002C  bge 0x830bbbb0
	if !ctx.cr[0].lt {
	pc = 0x830BBBB0; continue 'dispatch;
	}
	// 830BBB88: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830BBB8C: 816BBD24  lwz r11, -0x42dc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17116 as u32) ) } as u64;
	// 830BBB90: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BBB94: 409A0008  bne cr6, 0x830bbb9c
	if !ctx.cr[6].eq {
	pc = 0x830BBB9C; continue 'dispatch;
	}
	// 830BBB98: 4BFFFAB1  bl 0x830bb648
	ctx.lr = 0x830BBB9C;
	sub_830BB648(ctx, base);
	// 830BBB9C: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830BBBA0: 57CA103A  slwi r10, r30, 2
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830BBBA4: 396BBD30  addi r11, r11, -0x42d0
	ctx.r[11].s64 = ctx.r[11].s64 + -17104;
	// 830BBBA8: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830BBBAC: 4800000C  b 0x830bbbb8
	pc = 0x830BBBB8; continue 'dispatch;
	// 830BBBB0: 546B103A  slwi r11, r3, 2
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830BBBB4: 7D6B302E  lwzx r11, r11, r6
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 830BBBB8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830BBBBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BBBC0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830BBBC4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830BBBC8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830BBBCC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830BBBD0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830BBBD4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BBBD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BBBD8 size=24
    let mut pc: u32 = 0x830BBBD8;
    'dispatch: loop {
        match pc {
            0x830BBBD8 => {
    //   block [0x830BBBD8..0x830BBBF0)
	// 830BBBD8: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 830BBBDC: 419A000C  beq cr6, 0x830bbbe8
	if ctx.cr[6].eq {
	pc = 0x830BBBE8; continue 'dispatch;
	}
	// 830BBBE0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830BBBE4: 91650000  stw r11, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830BBBE8: 80840000  lwz r4, 0(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BBBEC: 4BFFFBE4  b 0x830bb7d0
	sub_830BB7D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BBBF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830BBBF0 size=216
    let mut pc: u32 = 0x830BBBF0;
    'dispatch: loop {
        match pc {
            0x830BBBF0 => {
    //   block [0x830BBBF0..0x830BBCC8)
	// 830BBBF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BBBF4: 480EC575  bl 0x831a8168
	ctx.lr = 0x830BBBF8;
	sub_831A8130(ctx, base);
	// 830BBBF8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BBBFC: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 830BBC00: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830BBC04: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 830BBC08: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 830BBC0C: 419A000C  beq cr6, 0x830bbc18
	if ctx.cr[6].eq {
	pc = 0x830BBC18; continue 'dispatch;
	}
	// 830BBC10: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830BBC14: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830BBC18: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 830BBC1C: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BBC20: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830BBC24: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830BBC28: 409AFFF4  bne cr6, 0x830bbc1c
	if !ctx.cr[6].eq {
	pc = 0x830BBC1C; continue 'dispatch;
	}
	// 830BBC2C: 7D7E5850  subf r11, r30, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 830BBC30: 3D408218  lis r10, -0x7de8
	ctx.r[10].s64 = -2112356352;
	// 830BBC34: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830BBC38: 388A76E0  addi r4, r10, 0x76e0
	ctx.r[4].s64 = ctx.r[10].s64 + 30432;
	// 830BBC3C: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830BBC40: 38A0029B  li r5, 0x29b
	ctx.r[5].s64 = 667;
	// 830BBC44: 386B0001  addi r3, r11, 1
	ctx.r[3].s64 = ctx.r[11].s64 + 1;
	// 830BBC48: 4BFF9011  bl 0x830b4c58
	ctx.lr = 0x830BBC4C;
	sub_830B4C58(ctx, base);
	// 830BBC4C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830BBC50: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 830BBC54: 7D5EF850  subf r10, r30, r31
	ctx.r[10].s64 = ctx.r[31].s64 - ctx.r[30].s64;
	// 830BBC58: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BBC5C: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830BBC60: 7D2A59AE  stbx r9, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u8) };
	// 830BBC64: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830BBC68: 4082FFF0  bne 0x830bbc58
	if !ctx.cr[0].eq {
	pc = 0x830BBC58; continue 'dispatch;
	}
	// 830BBC6C: 3880002F  li r4, 0x2f
	ctx.r[4].s64 = 47;
	// 830BBC70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BBC74: 480F11AD  bl 0x831ace20
	ctx.lr = 0x830BBC78;
	sub_831ACE20(ctx, base);
	// 830BBC78: 7CBF1850  subf r5, r31, r3
	ctx.r[5].s64 = ctx.r[3].s64 - ctx.r[31].s64;
	// 830BBC7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BBC80: 809C0004  lwz r4, 4(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BBC84: 480F114D  bl 0x831acdd0
	ctx.lr = 0x830BBC88;
	sub_831ACDD0(ctx, base);
	// 830BBC88: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830BBC8C: 4182000C  beq 0x830bbc98
	if ctx.cr[0].eq {
	pc = 0x830BBC98; continue 'dispatch;
	}
	// 830BBC90: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830BBC94: 4800002C  b 0x830bbcc0
	pc = 0x830BBCC0; continue 'dispatch;
	// 830BBC98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BBC9C: 4BFFFC3D  bl 0x830bb8d8
	ctx.lr = 0x830BBCA0;
	sub_830BB8D8(ctx, base);
	// 830BBCA0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830BBCA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BBCA8: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BBCAC: 4BFFFCF5  bl 0x830bb9a0
	ctx.lr = 0x830BBCB0;
	sub_830BB9A0(ctx, base);
	// 830BBCB0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830BBCB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BBCB8: 4BFF8FC9  bl 0x830b4c80
	ctx.lr = 0x830BBCBC;
	sub_830B4C80(ctx, base);
	// 830BBCBC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830BBCC0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830BBCC4: 480EC4F4  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BBCC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830BBCC8 size=60
    let mut pc: u32 = 0x830BBCC8;
    'dispatch: loop {
        match pc {
            0x830BBCC8 => {
    //   block [0x830BBCC8..0x830BBD04)
	// 830BBCC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BBCCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830BBCD0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830BBCD4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BBCD8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830BBCDC: 4800170D  bl 0x830bd3e8
	ctx.lr = 0x830BBCE0;
	sub_830BD3E8(ctx, base);
	// 830BBCE0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830BBCE4: 419A000C  beq cr6, 0x830bbcf0
	if ctx.cr[6].eq {
	pc = 0x830BBCF0; continue 'dispatch;
	}
	// 830BBCE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BBCEC: 4BFF8F95  bl 0x830b4c80
	ctx.lr = 0x830BBCF0;
	sub_830B4C80(ctx, base);
	// 830BBCF0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830BBCF4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830BBCF8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830BBCFC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830BBD00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BBD08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830BBD08 size=100
    let mut pc: u32 = 0x830BBD08;
    'dispatch: loop {
        match pc {
            0x830BBD08 => {
    //   block [0x830BBD08..0x830BBD6C)
	// 830BBD08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BBD0C: 480EC461  bl 0x831a816c
	ctx.lr = 0x830BBD10;
	sub_831A8130(ctx, base);
	// 830BBD10: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BBD14: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830BBD18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830BBD1C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830BBD20: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830BBD24: 3BDF0004  addi r30, r31, 4
	ctx.r[30].s64 = ctx.r[31].s64 + 4;
	// 830BBD28: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BBD2C: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830BBD30: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830BBD34: 809D000C  lwz r4, 0xc(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 830BBD38: 48002021  bl 0x830bdd58
	ctx.lr = 0x830BBD3C;
	sub_830BDD58(ctx, base);
	// 830BBD3C: 4BFFC5ED  bl 0x830b8328
	ctx.lr = 0x830BBD40;
	sub_830B8328(ctx, base);
	// 830BBD40: C01D0018  lfs f0, 0x18(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BBD44: EC000824  fdivs f0, f0, f1
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[1].f64) as f32) as f64;
	// 830BBD48: C1BF0004  lfs f13, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830BBD4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BBD50: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830BBD54: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 830BBD58: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830BBD5C: 4BFFC6CD  bl 0x830b8428
	ctx.lr = 0x830BBD60;
	sub_830B8428(ctx, base);
	// 830BBD60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BBD64: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830BBD68: 480EC454  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BBD70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830BBD70 size=168
    let mut pc: u32 = 0x830BBD70;
    'dispatch: loop {
        match pc {
            0x830BBD70 => {
    //   block [0x830BBD70..0x830BBE18)
	// 830BBD70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BBD74: 480EC3F9  bl 0x831a816c
	ctx.lr = 0x830BBD78;
	sub_831A8130(ctx, base);
	// 830BBD78: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BBD7C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830BBD80: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830BBD84: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 830BBD88: 814B0074  lwz r10, 0x74(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(116 as u32) ) } as u64;
	// 830BBD8C: 554A07BD  rlwinm. r10, r10, 0, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830BBD90: 41820024  beq 0x830bbdb4
	if ctx.cr[0].eq {
	pc = 0x830BBDB4; continue 'dispatch;
	}
	// 830BBD94: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830BBD98: 816B0078  lwz r11, 0x78(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(120 as u32) ) } as u64;
	// 830BBD9C: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BBDA0: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830BBDA4: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 830BBDA8: D1A1005C  stfs f13, 0x5c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 830BBDAC: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 830BBDB0: 48000058  b 0x830bbe08
	pc = 0x830BBE08; continue 'dispatch;
	// 830BBDB4: 814B0140  lwz r10, 0x140(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(320 as u32) ) } as u64;
	// 830BBDB8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830BBDBC: 419A0018  beq cr6, 0x830bbdd4
	if ctx.cr[6].eq {
	pc = 0x830BBDD4; continue 'dispatch;
	}
	// 830BBDC0: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 830BBDC4: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 830BBDC8: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830BBDCC: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830BBDD0: 4800003C  b 0x830bbe0c
	pc = 0x830BBE0C; continue 'dispatch;
	// 830BBDD4: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 830BBDD8: 809E0014  lwz r4, 0x14(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 830BBDDC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830BBDE0: 4BFFB201  bl 0x830b6fe0
	ctx.lr = 0x830BBDE4;
	sub_830B6FE0(ctx, base);
	// 830BBDE4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830BBDE8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830BBDEC: 809E0014  lwz r4, 0x14(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 830BBDF0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 830BBDF4: 4BFFB1ED  bl 0x830b6fe0
	ctx.lr = 0x830BBDF8;
	sub_830B6FE0(ctx, base);
	// 830BBDF8: C05D0000  lfs f2, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 830BBDFC: C0230000  lfs f1, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830BBE00: 48003921  bl 0x830bf720
	ctx.lr = 0x830BBE04;
	sub_830BF720(ctx, base);
	// 830BBE04: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 830BBE08: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 830BBE0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BBE10: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830BBE14: 480EC3A8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BBE18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830BBE18 size=200
    let mut pc: u32 = 0x830BBE18;
    'dispatch: loop {
        match pc {
            0x830BBE18 => {
    //   block [0x830BBE18..0x830BBEE0)
	// 830BBE18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BBE1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830BBE20: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830BBE24: DBC1FFE0  stfd f30, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[30].u64 ) };
	// 830BBE28: DBE1FFE8  stfd f31, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 830BBE2C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BBE30: 83E3000C  lwz r31, 0xc(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 830BBE34: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 830BBE38: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 830BBE3C: 815F0074  lwz r10, 0x74(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 830BBE40: 554B07BD  rlwinm. r11, r10, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BBE44: 41820028  beq 0x830bbe6c
	if ctx.cr[0].eq {
	pc = 0x830BBE6C; continue 'dispatch;
	}
	// 830BBE48: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830BBE4C: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BBE50: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 830BBE54: 409A0018  bne cr6, 0x830bbe6c
	if !ctx.cr[6].eq {
	pc = 0x830BBE6C; continue 'dispatch;
	}
	// 830BBE58: 5549077B  rlwinm. r9, r10, 0, 0x1d, 0x1d
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830BBE5C: 41820010  beq 0x830bbe6c
	if ctx.cr[0].eq {
	pc = 0x830BBE6C; continue 'dispatch;
	}
	// 830BBE60: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BBE64: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 830BBE68: 419A005C  beq cr6, 0x830bbec4
	if ctx.cr[6].eq {
	pc = 0x830BBEC4; continue 'dispatch;
	}
	// 830BBE6C: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830BBE70: 614A0006  ori r10, r10, 6
	ctx.r[10].u64 = ctx.r[10].u64 | 6;
	// 830BBE74: 915F0074  stw r10, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 830BBE78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830BBE7C: 409A001C  bne cr6, 0x830bbe98
	if !ctx.cr[6].eq {
	pc = 0x830BBE98; continue 'dispatch;
	}
	// 830BBE80: 3D608218  lis r11, -0x7de8
	ctx.r[11].s64 = -2112356352;
	// 830BBE84: 38A00153  li r5, 0x153
	ctx.r[5].s64 = 339;
	// 830BBE88: 388B7704  addi r4, r11, 0x7704
	ctx.r[4].s64 = ctx.r[11].s64 + 30468;
	// 830BBE8C: 3860003C  li r3, 0x3c
	ctx.r[3].s64 = 60;
	// 830BBE90: 4BFF8DC9  bl 0x830b4c58
	ctx.lr = 0x830BBE94;
	sub_830B4C58(ctx, base);
	// 830BBE94: 907F0078  stw r3, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[3].u32 ) };
	// 830BBE98: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830BBE9C: 3D80FFD7  lis r12, -0x29
	ctx.r[12].s64 = -2686976;
	// 830BBEA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BBEA4: 618CFFF9  ori r12, r12, 0xfff9
	ctx.r[12].u64 = ctx.r[12].u64 | 65529;
	// 830BBEA8: D3EB0004  stfs f31, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830BBEAC: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830BBEB0: D3CB0008  stfs f30, 8(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 830BBEB4: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 830BBEB8: 7D6B6038  and r11, r11, r12
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[12].u64;
	// 830BBEBC: 917F007C  stw r11, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 830BBEC0: 48001599  bl 0x830bd458
	ctx.lr = 0x830BBEC4;
	sub_830BD458(ctx, base);
	// 830BBEC4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830BBEC8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830BBECC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830BBED0: CBC1FFE0  lfd f30, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 830BBED4: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830BBED8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830BBEDC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BBEE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830BBEE0 size=156
    let mut pc: u32 = 0x830BBEE0;
    'dispatch: loop {
        match pc {
            0x830BBEE0 => {
    //   block [0x830BBEE0..0x830BBF7C)
	// 830BBEE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BBEE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830BBEE8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830BBEEC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830BBEF0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BBEF4: 83E3000C  lwz r31, 0xc(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 830BBEF8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830BBEFC: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 830BBF00: 556A07FF  clrlwi. r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830BBF04: 41820014  beq 0x830bbf18
	if ctx.cr[0].eq {
	pc = 0x830BBF18; continue 'dispatch;
	}
	// 830BBF08: 815F0078  lwz r10, 0x78(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830BBF0C: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BBF10: 7F0AF000  cmpw cr6, r10, r30
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[30].s32, &mut ctx.xer);
	// 830BBF14: 419A0050  beq cr6, 0x830bbf64
	if ctx.cr[6].eq {
	pc = 0x830BBF64; continue 'dispatch;
	}
	// 830BBF18: 815F0078  lwz r10, 0x78(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830BBF1C: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 830BBF20: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 830BBF24: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830BBF28: 409A001C  bne cr6, 0x830bbf44
	if !ctx.cr[6].eq {
	pc = 0x830BBF44; continue 'dispatch;
	}
	// 830BBF2C: 3D608218  lis r11, -0x7de8
	ctx.r[11].s64 = -2112356352;
	// 830BBF30: 38A0018F  li r5, 0x18f
	ctx.r[5].s64 = 399;
	// 830BBF34: 388B7704  addi r4, r11, 0x7704
	ctx.r[4].s64 = ctx.r[11].s64 + 30468;
	// 830BBF38: 3860003C  li r3, 0x3c
	ctx.r[3].s64 = 60;
	// 830BBF3C: 4BFF8D1D  bl 0x830b4c58
	ctx.lr = 0x830BBF40;
	sub_830B4C58(ctx, base);
	// 830BBF40: 907F0078  stw r3, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[3].u32 ) };
	// 830BBF44: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830BBF48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BBF4C: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 830BBF50: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 830BBF54: 556B003C  rlwinm r11, r11, 0, 0, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830BBF58: 556B0356  rlwinm r11, r11, 0, 0xd, 0xb
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830BBF5C: 917F007C  stw r11, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 830BBF60: 480014F9  bl 0x830bd458
	ctx.lr = 0x830BBF64;
	sub_830BD458(ctx, base);
	// 830BBF64: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830BBF68: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830BBF6C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830BBF70: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830BBF74: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830BBF78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BBF80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830BBF80 size=96
    let mut pc: u32 = 0x830BBF80;
    'dispatch: loop {
        match pc {
            0x830BBF80 => {
    //   block [0x830BBF80..0x830BBFE0)
	// 830BBF80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BBF84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830BBF88: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BBF8C: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 830BBF90: 814B0074  lwz r10, 0x74(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(116 as u32) ) } as u64;
	// 830BBF94: 554A07FF  clrlwi. r10, r10, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830BBF98: 41820010  beq 0x830bbfa8
	if ctx.cr[0].eq {
	pc = 0x830BBFA8; continue 'dispatch;
	}
	// 830BBF9C: 816B0078  lwz r11, 0x78(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(120 as u32) ) } as u64;
	// 830BBFA0: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BBFA4: 4800002C  b 0x830bbfd0
	pc = 0x830BBFD0; continue 'dispatch;
	// 830BBFA8: 814B0140  lwz r10, 0x140(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(320 as u32) ) } as u64;
	// 830BBFAC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830BBFB0: 419A000C  beq cr6, 0x830bbfbc
	if ctx.cr[6].eq {
	pc = 0x830BBFBC; continue 'dispatch;
	}
	// 830BBFB4: 806B0028  lwz r3, 0x28(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 830BBFB8: 48000018  b 0x830bbfd0
	pc = 0x830BBFD0; continue 'dispatch;
	// 830BBFBC: 80830014  lwz r4, 0x14(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 830BBFC0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830BBFC4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830BBFC8: 4BFFB019  bl 0x830b6fe0
	ctx.lr = 0x830BBFCC;
	sub_830B6FE0(ctx, base);
	// 830BBFCC: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BBFD0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830BBFD4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830BBFD8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830BBFDC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BBFE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830BBFE0 size=96
    let mut pc: u32 = 0x830BBFE0;
    'dispatch: loop {
        match pc {
            0x830BBFE0 => {
    //   block [0x830BBFE0..0x830BC040)
	// 830BBFE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BBFE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830BBFE8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BBFEC: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 830BBFF0: 814B0074  lwz r10, 0x74(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(116 as u32) ) } as u64;
	// 830BBFF4: 554A0739  rlwinm. r10, r10, 0, 0x1c, 0x1c
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830BBFF8: 41820010  beq 0x830bc008
	if ctx.cr[0].eq {
	pc = 0x830BC008; continue 'dispatch;
	}
	// 830BBFFC: 816B0078  lwz r11, 0x78(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(120 as u32) ) } as u64;
	// 830BC000: C02B000C  lfs f1, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830BC004: 4800002C  b 0x830bc030
	pc = 0x830BC030; continue 'dispatch;
	// 830BC008: 814B0140  lwz r10, 0x140(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(320 as u32) ) } as u64;
	// 830BC00C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830BC010: 419A000C  beq cr6, 0x830bc01c
	if ctx.cr[6].eq {
	pc = 0x830BC01C; continue 'dispatch;
	}
	// 830BC014: C02B0034  lfs f1, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830BC018: 48000018  b 0x830bc030
	pc = 0x830BC030; continue 'dispatch;
	// 830BC01C: 80830014  lwz r4, 0x14(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 830BC020: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 830BC024: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830BC028: 4BFFAFB9  bl 0x830b6fe0
	ctx.lr = 0x830BC02C;
	sub_830B6FE0(ctx, base);
	// 830BC02C: C0230000  lfs f1, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830BC030: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830BC034: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830BC038: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830BC03C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BC040(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830BC040 size=160
    let mut pc: u32 = 0x830BC040;
    'dispatch: loop {
        match pc {
            0x830BC040 => {
    //   block [0x830BC040..0x830BC0E0)
	// 830BC040: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BC044: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830BC048: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830BC04C: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 830BC050: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BC054: 83E3000C  lwz r31, 0xc(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 830BC058: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 830BC05C: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 830BC060: 556A0739  rlwinm. r10, r11, 0, 0x1c, 0x1c
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830BC064: 41820014  beq 0x830bc078
	if ctx.cr[0].eq {
	pc = 0x830BC078; continue 'dispatch;
	}
	// 830BC068: 815F0078  lwz r10, 0x78(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830BC06C: C00A000C  lfs f0, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BC070: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 830BC074: 419A0054  beq cr6, 0x830bc0c8
	if ctx.cr[6].eq {
	pc = 0x830BC0C8; continue 'dispatch;
	}
	// 830BC078: 815F0078  lwz r10, 0x78(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830BC07C: 616B0008  ori r11, r11, 8
	ctx.r[11].u64 = ctx.r[11].u64 | 8;
	// 830BC080: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 830BC084: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830BC088: 409A001C  bne cr6, 0x830bc0a4
	if !ctx.cr[6].eq {
	pc = 0x830BC0A4; continue 'dispatch;
	}
	// 830BC08C: 3D608218  lis r11, -0x7de8
	ctx.r[11].s64 = -2112356352;
	// 830BC090: 38A001EF  li r5, 0x1ef
	ctx.r[5].s64 = 495;
	// 830BC094: 388B7704  addi r4, r11, 0x7704
	ctx.r[4].s64 = ctx.r[11].s64 + 30468;
	// 830BC098: 3860003C  li r3, 0x3c
	ctx.r[3].s64 = 60;
	// 830BC09C: 4BFF8BBD  bl 0x830b4c58
	ctx.lr = 0x830BC0A0;
	sub_830B4C58(ctx, base);
	// 830BC0A0: 907F0078  stw r3, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[3].u32 ) };
	// 830BC0A4: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830BC0A8: 3D80FFD7  lis r12, -0x29
	ctx.r[12].s64 = -2686976;
	// 830BC0AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BC0B0: 618CFFF7  ori r12, r12, 0xfff7
	ctx.r[12].u64 = ctx.r[12].u64 | 65527;
	// 830BC0B4: D3EB000C  stfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830BC0B8: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 830BC0BC: 7D6B6038  and r11, r11, r12
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[12].u64;
	// 830BC0C0: 917F007C  stw r11, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 830BC0C4: 48001395  bl 0x830bd458
	ctx.lr = 0x830BC0C8;
	sub_830BD458(ctx, base);
	// 830BC0C8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830BC0CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830BC0D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830BC0D4: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830BC0D8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830BC0DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BC0E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830BC0E0 size=168
    let mut pc: u32 = 0x830BC0E0;
    'dispatch: loop {
        match pc {
            0x830BC0E0 => {
    //   block [0x830BC0E0..0x830BC188)
	// 830BC0E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BC0E4: 480EC089  bl 0x831a816c
	ctx.lr = 0x830BC0E8;
	sub_831A8130(ctx, base);
	// 830BC0E8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BC0EC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830BC0F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830BC0F4: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 830BC0F8: 814B0074  lwz r10, 0x74(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(116 as u32) ) } as u64;
	// 830BC0FC: 554A06F7  rlwinm. r10, r10, 0, 0x1b, 0x1b
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830BC100: 41820024  beq 0x830bc124
	if ctx.cr[0].eq {
	pc = 0x830BC124; continue 'dispatch;
	}
	// 830BC104: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830BC108: 816B0078  lwz r11, 0x78(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(120 as u32) ) } as u64;
	// 830BC10C: C00B0010  lfs f0, 0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BC110: C1AB0014  lfs f13, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830BC114: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 830BC118: D1A1005C  stfs f13, 0x5c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 830BC11C: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 830BC120: 48000058  b 0x830bc178
	pc = 0x830BC178; continue 'dispatch;
	// 830BC124: 814B0140  lwz r10, 0x140(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(320 as u32) ) } as u64;
	// 830BC128: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830BC12C: 419A0018  beq cr6, 0x830bc144
	if ctx.cr[6].eq {
	pc = 0x830BC144; continue 'dispatch;
	}
	// 830BC130: 814B0038  lwz r10, 0x38(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 830BC134: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 830BC138: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830BC13C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830BC140: 4800003C  b 0x830bc17c
	pc = 0x830BC17C; continue 'dispatch;
	// 830BC144: 38A00005  li r5, 5
	ctx.r[5].s64 = 5;
	// 830BC148: 809E0014  lwz r4, 0x14(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 830BC14C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830BC150: 4BFFAE91  bl 0x830b6fe0
	ctx.lr = 0x830BC154;
	sub_830B6FE0(ctx, base);
	// 830BC154: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830BC158: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 830BC15C: 809E0014  lwz r4, 0x14(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 830BC160: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 830BC164: 4BFFAE7D  bl 0x830b6fe0
	ctx.lr = 0x830BC168;
	sub_830B6FE0(ctx, base);
	// 830BC168: C05D0000  lfs f2, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 830BC16C: C0230000  lfs f1, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830BC170: 480035B1  bl 0x830bf720
	ctx.lr = 0x830BC174;
	sub_830BF720(ctx, base);
	// 830BC174: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 830BC178: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 830BC17C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BC180: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830BC184: 480EC038  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BC188(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830BC188 size=200
    let mut pc: u32 = 0x830BC188;
    'dispatch: loop {
        match pc {
            0x830BC188 => {
    //   block [0x830BC188..0x830BC250)
	// 830BC188: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BC18C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830BC190: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830BC194: DBC1FFE0  stfd f30, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[30].u64 ) };
	// 830BC198: DBE1FFE8  stfd f31, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 830BC19C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BC1A0: 83E3000C  lwz r31, 0xc(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 830BC1A4: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 830BC1A8: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 830BC1AC: 815F0074  lwz r10, 0x74(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 830BC1B0: 554B06F7  rlwinm. r11, r10, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BC1B4: 41820028  beq 0x830bc1dc
	if ctx.cr[0].eq {
	pc = 0x830BC1DC; continue 'dispatch;
	}
	// 830BC1B8: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830BC1BC: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BC1C0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 830BC1C4: 409A0018  bne cr6, 0x830bc1dc
	if !ctx.cr[6].eq {
	pc = 0x830BC1DC; continue 'dispatch;
	}
	// 830BC1C8: 554906B5  rlwinm. r9, r10, 0, 0x1a, 0x1a
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830BC1CC: 41820010  beq 0x830bc1dc
	if ctx.cr[0].eq {
	pc = 0x830BC1DC; continue 'dispatch;
	}
	// 830BC1D0: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BC1D4: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 830BC1D8: 419A005C  beq cr6, 0x830bc234
	if ctx.cr[6].eq {
	pc = 0x830BC234; continue 'dispatch;
	}
	// 830BC1DC: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830BC1E0: 614A0030  ori r10, r10, 0x30
	ctx.r[10].u64 = ctx.r[10].u64 | 48;
	// 830BC1E4: 915F0074  stw r10, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 830BC1E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830BC1EC: 409A001C  bne cr6, 0x830bc208
	if !ctx.cr[6].eq {
	pc = 0x830BC208; continue 'dispatch;
	}
	// 830BC1F0: 3D608218  lis r11, -0x7de8
	ctx.r[11].s64 = -2112356352;
	// 830BC1F4: 38A00243  li r5, 0x243
	ctx.r[5].s64 = 579;
	// 830BC1F8: 388B7704  addi r4, r11, 0x7704
	ctx.r[4].s64 = ctx.r[11].s64 + 30468;
	// 830BC1FC: 3860003C  li r3, 0x3c
	ctx.r[3].s64 = 60;
	// 830BC200: 4BFF8A59  bl 0x830b4c58
	ctx.lr = 0x830BC204;
	sub_830B4C58(ctx, base);
	// 830BC204: 907F0078  stw r3, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[3].u32 ) };
	// 830BC208: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830BC20C: 3D80FFD7  lis r12, -0x29
	ctx.r[12].s64 = -2686976;
	// 830BC210: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BC214: 618CFFCF  ori r12, r12, 0xffcf
	ctx.r[12].u64 = ctx.r[12].u64 | 65487;
	// 830BC218: D3EB0010  stfs f31, 0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 830BC21C: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830BC220: D3CB0014  stfs f30, 0x14(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 830BC224: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 830BC228: 7D6B6038  and r11, r11, r12
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[12].u64;
	// 830BC22C: 917F007C  stw r11, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 830BC230: 48001229  bl 0x830bd458
	ctx.lr = 0x830BC234;
	sub_830BD458(ctx, base);
	// 830BC234: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830BC238: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830BC23C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830BC240: CBC1FFE0  lfd f30, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 830BC244: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830BC248: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830BC24C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BC250(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830BC250 size=96
    let mut pc: u32 = 0x830BC250;
    'dispatch: loop {
        match pc {
            0x830BC250 => {
    //   block [0x830BC250..0x830BC2B0)
	// 830BC250: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BC254: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830BC258: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BC25C: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 830BC260: 814B0074  lwz r10, 0x74(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(116 as u32) ) } as u64;
	// 830BC264: 554A0631  rlwinm. r10, r10, 0, 0x18, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830BC268: 41820010  beq 0x830bc278
	if ctx.cr[0].eq {
	pc = 0x830BC278; continue 'dispatch;
	}
	// 830BC26C: 816B0078  lwz r11, 0x78(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(120 as u32) ) } as u64;
	// 830BC270: 806B001C  lwz r3, 0x1c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 830BC274: 4800002C  b 0x830bc2a0
	pc = 0x830BC2A0; continue 'dispatch;
	// 830BC278: 814B0140  lwz r10, 0x140(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(320 as u32) ) } as u64;
	// 830BC27C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830BC280: 419A000C  beq cr6, 0x830bc28c
	if ctx.cr[6].eq {
	pc = 0x830BC28C; continue 'dispatch;
	}
	// 830BC284: 806B0044  lwz r3, 0x44(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 830BC288: 48000018  b 0x830bc2a0
	pc = 0x830BC2A0; continue 'dispatch;
	// 830BC28C: 80830014  lwz r4, 0x14(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 830BC290: 38A00007  li r5, 7
	ctx.r[5].s64 = 7;
	// 830BC294: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830BC298: 4BFFAD49  bl 0x830b6fe0
	ctx.lr = 0x830BC29C;
	sub_830B6FE0(ctx, base);
	// 830BC29C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BC2A0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830BC2A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830BC2A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830BC2AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BC2B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830BC2B0 size=164
    let mut pc: u32 = 0x830BC2B0;
    'dispatch: loop {
        match pc {
            0x830BC2B0 => {
    //   block [0x830BC2B0..0x830BC354)
	// 830BC2B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BC2B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830BC2B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830BC2BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830BC2C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BC2C4: 83E3000C  lwz r31, 0xc(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 830BC2C8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830BC2CC: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 830BC2D0: 556A0631  rlwinm. r10, r11, 0, 0x18, 0x18
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830BC2D4: 41820018  beq 0x830bc2ec
	if ctx.cr[0].eq {
	pc = 0x830BC2EC; continue 'dispatch;
	}
	// 830BC2D8: 815F0078  lwz r10, 0x78(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830BC2DC: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BC2E0: 814A001C  lwz r10, 0x1c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 830BC2E4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 830BC2E8: 419A0054  beq cr6, 0x830bc33c
	if ctx.cr[6].eq {
	pc = 0x830BC33C; continue 'dispatch;
	}
	// 830BC2EC: 815F0078  lwz r10, 0x78(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830BC2F0: 616B0080  ori r11, r11, 0x80
	ctx.r[11].u64 = ctx.r[11].u64 | 128;
	// 830BC2F4: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 830BC2F8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830BC2FC: 409A001C  bne cr6, 0x830bc318
	if !ctx.cr[6].eq {
	pc = 0x830BC318; continue 'dispatch;
	}
	// 830BC300: 3D608218  lis r11, -0x7de8
	ctx.r[11].s64 = -2112356352;
	// 830BC304: 38A00293  li r5, 0x293
	ctx.r[5].s64 = 659;
	// 830BC308: 388B7704  addi r4, r11, 0x7704
	ctx.r[4].s64 = ctx.r[11].s64 + 30468;
	// 830BC30C: 3860003C  li r3, 0x3c
	ctx.r[3].s64 = 60;
	// 830BC310: 4BFF8949  bl 0x830b4c58
	ctx.lr = 0x830BC314;
	sub_830B4C58(ctx, base);
	// 830BC314: 907F0078  stw r3, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[3].u32 ) };
	// 830BC318: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BC31C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BC320: 815F0078  lwz r10, 0x78(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830BC324: 916A001C  stw r11, 0x1c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 830BC328: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 830BC32C: 556B066E  rlwinm r11, r11, 0, 0x19, 0x17
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830BC330: 556B0356  rlwinm r11, r11, 0, 0xd, 0xb
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830BC334: 917F007C  stw r11, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 830BC338: 48001121  bl 0x830bd458
	ctx.lr = 0x830BC33C;
	sub_830BD458(ctx, base);
	// 830BC33C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830BC340: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830BC344: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830BC348: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830BC34C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830BC350: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BC358(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830BC358 size=96
    let mut pc: u32 = 0x830BC358;
    'dispatch: loop {
        match pc {
            0x830BC358 => {
    //   block [0x830BC358..0x830BC3B8)
	// 830BC358: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BC35C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830BC360: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BC364: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 830BC368: 814B0074  lwz r10, 0x74(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(116 as u32) ) } as u64;
	// 830BC36C: 554A0673  rlwinm. r10, r10, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830BC370: 41820010  beq 0x830bc380
	if ctx.cr[0].eq {
	pc = 0x830BC380; continue 'dispatch;
	}
	// 830BC374: 816B0078  lwz r11, 0x78(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(120 as u32) ) } as u64;
	// 830BC378: C02B0018  lfs f1, 0x18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830BC37C: 4800002C  b 0x830bc3a8
	pc = 0x830BC3A8; continue 'dispatch;
	// 830BC380: 814B0140  lwz r10, 0x140(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(320 as u32) ) } as u64;
	// 830BC384: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830BC388: 419A000C  beq cr6, 0x830bc394
	if ctx.cr[6].eq {
	pc = 0x830BC394; continue 'dispatch;
	}
	// 830BC38C: C02B0040  lfs f1, 0x40(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830BC390: 48000018  b 0x830bc3a8
	pc = 0x830BC3A8; continue 'dispatch;
	// 830BC394: 80830014  lwz r4, 0x14(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 830BC398: 38A00006  li r5, 6
	ctx.r[5].s64 = 6;
	// 830BC39C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830BC3A0: 4BFFAC41  bl 0x830b6fe0
	ctx.lr = 0x830BC3A4;
	sub_830B6FE0(ctx, base);
	// 830BC3A4: C0230000  lfs f1, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830BC3A8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830BC3AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830BC3B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830BC3B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BC3B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830BC3B8 size=212
    let mut pc: u32 = 0x830BC3B8;
    'dispatch: loop {
        match pc {
            0x830BC3B8 => {
    //   block [0x830BC3B8..0x830BC48C)
	// 830BC3B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BC3BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830BC3C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830BC3C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830BC3C8: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 830BC3CC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BC3D0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830BC3D4: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 830BC3D8: 83FE000C  lwz r31, 0xc(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 830BC3DC: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 830BC3E0: 556A0673  rlwinm. r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830BC3E4: 41820014  beq 0x830bc3f8
	if ctx.cr[0].eq {
	pc = 0x830BC3F8; continue 'dispatch;
	}
	// 830BC3E8: 815F0078  lwz r10, 0x78(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830BC3EC: C00A0018  lfs f0, 0x18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BC3F0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 830BC3F4: 419A007C  beq cr6, 0x830bc470
	if ctx.cr[6].eq {
	pc = 0x830BC470; continue 'dispatch;
	}
	// 830BC3F8: 815F0078  lwz r10, 0x78(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830BC3FC: 616B0040  ori r11, r11, 0x40
	ctx.r[11].u64 = ctx.r[11].u64 | 64;
	// 830BC400: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 830BC404: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830BC408: 409A001C  bne cr6, 0x830bc424
	if !ctx.cr[6].eq {
	pc = 0x830BC424; continue 'dispatch;
	}
	// 830BC40C: 3D608218  lis r11, -0x7de8
	ctx.r[11].s64 = -2112356352;
	// 830BC410: 38A002DF  li r5, 0x2df
	ctx.r[5].s64 = 735;
	// 830BC414: 388B7704  addi r4, r11, 0x7704
	ctx.r[4].s64 = ctx.r[11].s64 + 30468;
	// 830BC418: 3860003C  li r3, 0x3c
	ctx.r[3].s64 = 60;
	// 830BC41C: 4BFF883D  bl 0x830b4c58
	ctx.lr = 0x830BC420;
	sub_830B4C58(ctx, base);
	// 830BC420: 907F0078  stw r3, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[3].u32 ) };
	// 830BC424: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830BC428: D3EB0018  stfs f31, 0x18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 830BC42C: D3FF0040  stfs f31, 0x40(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 830BC430: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 830BC434: 816B0040  lwz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 830BC438: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BC43C: 419A001C  beq cr6, 0x830bc458
	if ctx.cr[6].eq {
	pc = 0x830BC458; continue 'dispatch;
	}
	// 830BC440: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 830BC444: 807E000C  lwz r3, 0xc(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 830BC448: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 830BC44C: 808B000C  lwz r4, 0xc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830BC450: 80AA000C  lwz r5, 0xc(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 830BC454: 4BFFDB0D  bl 0x830b9f60
	ctx.lr = 0x830BC458;
	sub_830B9F60(ctx, base);
	// 830BC458: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 830BC45C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BC460: 556B06B0  rlwinm r11, r11, 0, 0x1a, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830BC464: 556B0356  rlwinm r11, r11, 0, 0xd, 0xb
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830BC468: 917F007C  stw r11, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 830BC46C: 48000FED  bl 0x830bd458
	ctx.lr = 0x830BC470;
	sub_830BD458(ctx, base);
	// 830BC470: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830BC474: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830BC478: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830BC47C: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 830BC480: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830BC484: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830BC488: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BC490(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830BC490 size=112
    let mut pc: u32 = 0x830BC490;
    'dispatch: loop {
        match pc {
            0x830BC490 => {
    //   block [0x830BC490..0x830BC500)
	// 830BC490: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BC494: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830BC498: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BC49C: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 830BC4A0: 39400100  li r10, 0x100
	ctx.r[10].s64 = 256;
	// 830BC4A4: 7D4A2030  slw r10, r10, r4
	if (ctx.r[4].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[10].u32) << ((ctx.r[4].u8 & 0x1F) as u32)) as u64;
	}
	// 830BC4A8: 812B0074  lwz r9, 0x74(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(116 as u32) ) } as u64;
	// 830BC4AC: 7D2A5039  and. r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 & ctx.r[10].u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830BC4B0: 41820018  beq 0x830bc4c8
	if ctx.cr[0].eq {
	pc = 0x830BC4C8; continue 'dispatch;
	}
	// 830BC4B4: 816B0078  lwz r11, 0x78(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(120 as u32) ) } as u64;
	// 830BC4B8: 39440008  addi r10, r4, 8
	ctx.r[10].s64 = ctx.r[4].s64 + 8;
	// 830BC4BC: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830BC4C0: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830BC4C4: 4800002C  b 0x830bc4f0
	pc = 0x830BC4F0; continue 'dispatch;
	// 830BC4C8: 814B0140  lwz r10, 0x140(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(320 as u32) ) } as u64;
	// 830BC4CC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830BC4D0: 419A000C  beq cr6, 0x830bc4dc
	if ctx.cr[6].eq {
	pc = 0x830BC4DC; continue 'dispatch;
	}
	// 830BC4D4: 39440012  addi r10, r4, 0x12
	ctx.r[10].s64 = ctx.r[4].s64 + 18;
	// 830BC4D8: 4BFFFFE4  b 0x830bc4bc
	pc = 0x830BC4BC; continue 'dispatch;
	// 830BC4DC: 38A40008  addi r5, r4, 8
	ctx.r[5].s64 = ctx.r[4].s64 + 8;
	// 830BC4E0: 80830014  lwz r4, 0x14(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 830BC4E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830BC4E8: 4BFFAAF9  bl 0x830b6fe0
	ctx.lr = 0x830BC4EC;
	sub_830B6FE0(ctx, base);
	// 830BC4EC: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BC4F0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830BC4F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830BC4F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830BC4FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BC500(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830BC500 size=192
    let mut pc: u32 = 0x830BC500;
    'dispatch: loop {
        match pc {
            0x830BC500 => {
    //   block [0x830BC500..0x830BC5C0)
	// 830BC500: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BC504: 480EBC61  bl 0x831a8164
	ctx.lr = 0x830BC508;
	sub_831A8130(ctx, base);
	// 830BC508: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BC50C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 830BC510: 39600100  li r11, 0x100
	ctx.r[11].s64 = 256;
	// 830BC514: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830BC518: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 830BC51C: 7D7DF030  slw r29, r11, r30
	if (ctx.r[30].u8 & 0x20) != 0 {
		ctx.r[29].u64 = 0;
	} else {
		ctx.r[29].u64 = ((ctx.r[11].u32) << ((ctx.r[30].u8 & 0x1F) as u32)) as u64;
	}
	// 830BC520: 83FB000C  lwz r31, 0xc(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 830BC524: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 830BC528: 7D6AE839  and. r10, r11, r29
	ctx.r[10].u64 = ctx.r[11].u64 & ctx.r[29].u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830BC52C: 41820020  beq 0x830bc54c
	if ctx.cr[0].eq {
	pc = 0x830BC54C; continue 'dispatch;
	}
	// 830BC530: 395E0008  addi r10, r30, 8
	ctx.r[10].s64 = ctx.r[30].s64 + 8;
	// 830BC534: 813F0078  lwz r9, 0x78(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830BC538: 811C0000  lwz r8, 0(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BC53C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830BC540: 7D4A482E  lwzx r10, r10, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 830BC544: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 830BC548: 419A0070  beq cr6, 0x830bc5b8
	if ctx.cr[6].eq {
	pc = 0x830BC5B8; continue 'dispatch;
	}
	// 830BC54C: 815F0078  lwz r10, 0x78(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830BC550: 7D6BEB78  or r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[29].u64;
	// 830BC554: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 830BC558: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830BC55C: 409A001C  bne cr6, 0x830bc578
	if !ctx.cr[6].eq {
	pc = 0x830BC578; continue 'dispatch;
	}
	// 830BC560: 3D608218  lis r11, -0x7de8
	ctx.r[11].s64 = -2112356352;
	// 830BC564: 38A00330  li r5, 0x330
	ctx.r[5].s64 = 816;
	// 830BC568: 388B7704  addi r4, r11, 0x7704
	ctx.r[4].s64 = ctx.r[11].s64 + 30468;
	// 830BC56C: 3860003C  li r3, 0x3c
	ctx.r[3].s64 = 60;
	// 830BC570: 4BFF86E9  bl 0x830b4c58
	ctx.lr = 0x830BC574;
	sub_830B4C58(ctx, base);
	// 830BC574: 907F0078  stw r3, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[3].u32 ) };
	// 830BC578: 397E0008  addi r11, r30, 8
	ctx.r[11].s64 = ctx.r[30].s64 + 8;
	// 830BC57C: 815F0078  lwz r10, 0x78(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830BC580: 393E0012  addi r9, r30, 0x12
	ctx.r[9].s64 = ctx.r[30].s64 + 18;
	// 830BC584: 811C0000  lwz r8, 0(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BC588: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830BC58C: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 830BC590: 7D0B512E  stwx r8, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[8].u32) };
	// 830BC594: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BC598: 7D69F92E  stwx r11, r9, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[31].u32), ctx.r[11].u32) };
	// 830BC59C: 807B000C  lwz r3, 0xc(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 830BC5A0: 4BFFD009  bl 0x830b95a8
	ctx.lr = 0x830BC5A4;
	sub_830B95A8(ctx, base);
	// 830BC5A4: 807B000C  lwz r3, 0xc(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 830BC5A8: 4BFFD0B1  bl 0x830b9658
	ctx.lr = 0x830BC5AC;
	sub_830B9658(ctx, base);
	// 830BC5AC: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 830BC5B0: 7D6BEB78  or r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[29].u64;
	// 830BC5B4: 917F007C  stw r11, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 830BC5B8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830BC5BC: 480EBBF8  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BC5C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830BC5C0 size=112
    let mut pc: u32 = 0x830BC5C0;
    'dispatch: loop {
        match pc {
            0x830BC5C0 => {
    //   block [0x830BC5C0..0x830BC630)
	// 830BC5C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BC5C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830BC5C8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BC5CC: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 830BC5D0: 39401000  li r10, 0x1000
	ctx.r[10].s64 = 4096;
	// 830BC5D4: 7D4A2030  slw r10, r10, r4
	if (ctx.r[4].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[10].u32) << ((ctx.r[4].u8 & 0x1F) as u32)) as u64;
	}
	// 830BC5D8: 812B0074  lwz r9, 0x74(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(116 as u32) ) } as u64;
	// 830BC5DC: 7D2A5039  and. r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 & ctx.r[10].u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830BC5E0: 41820018  beq 0x830bc5f8
	if ctx.cr[0].eq {
	pc = 0x830BC5F8; continue 'dispatch;
	}
	// 830BC5E4: 816B0078  lwz r11, 0x78(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(120 as u32) ) } as u64;
	// 830BC5E8: 3944000C  addi r10, r4, 0xc
	ctx.r[10].s64 = ctx.r[4].s64 + 12;
	// 830BC5EC: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830BC5F0: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830BC5F4: 4800002C  b 0x830bc620
	pc = 0x830BC620; continue 'dispatch;
	// 830BC5F8: 814B0140  lwz r10, 0x140(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(320 as u32) ) } as u64;
	// 830BC5FC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830BC600: 419A000C  beq cr6, 0x830bc60c
	if ctx.cr[6].eq {
	pc = 0x830BC60C; continue 'dispatch;
	}
	// 830BC604: 39440016  addi r10, r4, 0x16
	ctx.r[10].s64 = ctx.r[4].s64 + 22;
	// 830BC608: 4BFFFFE4  b 0x830bc5ec
	pc = 0x830BC5EC; continue 'dispatch;
	// 830BC60C: 38A4000C  addi r5, r4, 0xc
	ctx.r[5].s64 = ctx.r[4].s64 + 12;
	// 830BC610: 80830014  lwz r4, 0x14(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 830BC614: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830BC618: 4BFFA9C9  bl 0x830b6fe0
	ctx.lr = 0x830BC61C;
	sub_830B6FE0(ctx, base);
	// 830BC61C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BC620: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830BC624: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830BC628: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830BC62C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BC630(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830BC630 size=160
    let mut pc: u32 = 0x830BC630;
    'dispatch: loop {
        match pc {
            0x830BC630 => {
    //   block [0x830BC630..0x830BC6D0)
	// 830BC630: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BC634: 480EBB35  bl 0x831a8168
	ctx.lr = 0x830BC638;
	sub_831A8130(ctx, base);
	// 830BC638: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BC63C: 83E3000C  lwz r31, 0xc(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 830BC640: 39601000  li r11, 0x1000
	ctx.r[11].s64 = 4096;
	// 830BC644: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830BC648: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 830BC64C: 7D7DF030  slw r29, r11, r30
	if (ctx.r[30].u8 & 0x20) != 0 {
		ctx.r[29].u64 = 0;
	} else {
		ctx.r[29].u64 = ((ctx.r[11].u32) << ((ctx.r[30].u8 & 0x1F) as u32)) as u64;
	}
	// 830BC650: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 830BC654: 7D6AE839  and. r10, r11, r29
	ctx.r[10].u64 = ctx.r[11].u64 & ctx.r[29].u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830BC658: 4182001C  beq 0x830bc674
	if ctx.cr[0].eq {
	pc = 0x830BC674; continue 'dispatch;
	}
	// 830BC65C: 395E000C  addi r10, r30, 0xc
	ctx.r[10].s64 = ctx.r[30].s64 + 12;
	// 830BC660: 813F0078  lwz r9, 0x78(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830BC664: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830BC668: 7D4A482E  lwzx r10, r10, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 830BC66C: 7F0AE000  cmpw cr6, r10, r28
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[28].s32, &mut ctx.xer);
	// 830BC670: 419A0058  beq cr6, 0x830bc6c8
	if ctx.cr[6].eq {
	pc = 0x830BC6C8; continue 'dispatch;
	}
	// 830BC674: 815F0078  lwz r10, 0x78(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830BC678: 7D6BEB78  or r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[29].u64;
	// 830BC67C: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 830BC680: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830BC684: 409A001C  bne cr6, 0x830bc6a0
	if !ctx.cr[6].eq {
	pc = 0x830BC6A0; continue 'dispatch;
	}
	// 830BC688: 3D608218  lis r11, -0x7de8
	ctx.r[11].s64 = -2112356352;
	// 830BC68C: 38A0037E  li r5, 0x37e
	ctx.r[5].s64 = 894;
	// 830BC690: 388B7704  addi r4, r11, 0x7704
	ctx.r[4].s64 = ctx.r[11].s64 + 30468;
	// 830BC694: 3860003C  li r3, 0x3c
	ctx.r[3].s64 = 60;
	// 830BC698: 4BFF85C1  bl 0x830b4c58
	ctx.lr = 0x830BC69C;
	sub_830B4C58(ctx, base);
	// 830BC69C: 907F0078  stw r3, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[3].u32 ) };
	// 830BC6A0: 397E000C  addi r11, r30, 0xc
	ctx.r[11].s64 = ctx.r[30].s64 + 12;
	// 830BC6A4: 815F0078  lwz r10, 0x78(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830BC6A8: 393E0016  addi r9, r30, 0x16
	ctx.r[9].s64 = ctx.r[30].s64 + 22;
	// 830BC6AC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830BC6B0: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 830BC6B4: 7F8B512E  stwx r28, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[28].u32) };
	// 830BC6B8: 7F89F92E  stwx r28, r9, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[31].u32), ctx.r[28].u32) };
	// 830BC6BC: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 830BC6C0: 7FAB5B78  or r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 | ctx.r[11].u64;
	// 830BC6C4: 917F007C  stw r11, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 830BC6C8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830BC6CC: 480EBAEC  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BC6D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830BC6D0 size=160
    let mut pc: u32 = 0x830BC6D0;
    'dispatch: loop {
        match pc {
            0x830BC6D0 => {
    //   block [0x830BC6D0..0x830BC770)
	// 830BC6D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BC6D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830BC6D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830BC6DC: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 830BC6E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BC6E4: 83E3000C  lwz r31, 0xc(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 830BC6E8: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 830BC6EC: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 830BC6F0: 556A07BD  rlwinm. r10, r11, 0, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830BC6F4: 41820014  beq 0x830bc708
	if ctx.cr[0].eq {
	pc = 0x830BC708; continue 'dispatch;
	}
	// 830BC6F8: 815F0078  lwz r10, 0x78(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830BC6FC: C00A0004  lfs f0, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BC700: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 830BC704: 419A0054  beq cr6, 0x830bc758
	if ctx.cr[6].eq {
	pc = 0x830BC758; continue 'dispatch;
	}
	// 830BC708: 815F0078  lwz r10, 0x78(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830BC70C: 616B0002  ori r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u64 | 2;
	// 830BC710: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 830BC714: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830BC718: 409A001C  bne cr6, 0x830bc734
	if !ctx.cr[6].eq {
	pc = 0x830BC734; continue 'dispatch;
	}
	// 830BC71C: 3D608218  lis r11, -0x7de8
	ctx.r[11].s64 = -2112356352;
	// 830BC720: 38A003A6  li r5, 0x3a6
	ctx.r[5].s64 = 934;
	// 830BC724: 388B7704  addi r4, r11, 0x7704
	ctx.r[4].s64 = ctx.r[11].s64 + 30468;
	// 830BC728: 3860003C  li r3, 0x3c
	ctx.r[3].s64 = 60;
	// 830BC72C: 4BFF852D  bl 0x830b4c58
	ctx.lr = 0x830BC730;
	sub_830B4C58(ctx, base);
	// 830BC730: 907F0078  stw r3, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[3].u32 ) };
	// 830BC734: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830BC738: 3D80FFD7  lis r12, -0x29
	ctx.r[12].s64 = -2686976;
	// 830BC73C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BC740: 618CFFFD  ori r12, r12, 0xfffd
	ctx.r[12].u64 = ctx.r[12].u64 | 65533;
	// 830BC744: D3EB0004  stfs f31, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830BC748: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 830BC74C: 7D6B6038  and r11, r11, r12
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[12].u64;
	// 830BC750: 917F007C  stw r11, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 830BC754: 48000D05  bl 0x830bd458
	ctx.lr = 0x830BC758;
	sub_830BD458(ctx, base);
	// 830BC758: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830BC75C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830BC760: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830BC764: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830BC768: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830BC76C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BC770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830BC770 size=160
    let mut pc: u32 = 0x830BC770;
    'dispatch: loop {
        match pc {
            0x830BC770 => {
    //   block [0x830BC770..0x830BC810)
	// 830BC770: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BC774: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830BC778: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830BC77C: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 830BC780: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BC784: 83E3000C  lwz r31, 0xc(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 830BC788: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 830BC78C: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 830BC790: 556A077B  rlwinm. r10, r11, 0, 0x1d, 0x1d
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830BC794: 41820014  beq 0x830bc7a8
	if ctx.cr[0].eq {
	pc = 0x830BC7A8; continue 'dispatch;
	}
	// 830BC798: 815F0078  lwz r10, 0x78(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830BC79C: C00A0008  lfs f0, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BC7A0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 830BC7A4: 419A0054  beq cr6, 0x830bc7f8
	if ctx.cr[6].eq {
	pc = 0x830BC7F8; continue 'dispatch;
	}
	// 830BC7A8: 815F0078  lwz r10, 0x78(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830BC7AC: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 830BC7B0: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 830BC7B4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830BC7B8: 409A001C  bne cr6, 0x830bc7d4
	if !ctx.cr[6].eq {
	pc = 0x830BC7D4; continue 'dispatch;
	}
	// 830BC7BC: 3D608218  lis r11, -0x7de8
	ctx.r[11].s64 = -2112356352;
	// 830BC7C0: 38A003C0  li r5, 0x3c0
	ctx.r[5].s64 = 960;
	// 830BC7C4: 388B7704  addi r4, r11, 0x7704
	ctx.r[4].s64 = ctx.r[11].s64 + 30468;
	// 830BC7C8: 3860003C  li r3, 0x3c
	ctx.r[3].s64 = 60;
	// 830BC7CC: 4BFF848D  bl 0x830b4c58
	ctx.lr = 0x830BC7D0;
	sub_830B4C58(ctx, base);
	// 830BC7D0: 907F0078  stw r3, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[3].u32 ) };
	// 830BC7D4: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830BC7D8: 3D80FFD7  lis r12, -0x29
	ctx.r[12].s64 = -2686976;
	// 830BC7DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BC7E0: 618CFFFB  ori r12, r12, 0xfffb
	ctx.r[12].u64 = ctx.r[12].u64 | 65531;
	// 830BC7E4: D3EB0008  stfs f31, 8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 830BC7E8: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 830BC7EC: 7D6B6038  and r11, r11, r12
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[12].u64;
	// 830BC7F0: 917F007C  stw r11, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 830BC7F4: 48000C65  bl 0x830bd458
	ctx.lr = 0x830BC7F8;
	sub_830BD458(ctx, base);
	// 830BC7F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830BC7FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830BC800: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830BC804: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830BC808: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830BC80C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BC810(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830BC810 size=160
    let mut pc: u32 = 0x830BC810;
    'dispatch: loop {
        match pc {
            0x830BC810 => {
    //   block [0x830BC810..0x830BC8B0)
	// 830BC810: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BC814: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830BC818: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830BC81C: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 830BC820: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BC824: 83E3000C  lwz r31, 0xc(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 830BC828: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 830BC82C: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 830BC830: 556A06F7  rlwinm. r10, r11, 0, 0x1b, 0x1b
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830BC834: 41820014  beq 0x830bc848
	if ctx.cr[0].eq {
	pc = 0x830BC848; continue 'dispatch;
	}
	// 830BC838: 815F0078  lwz r10, 0x78(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830BC83C: C00A0010  lfs f0, 0x10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BC840: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 830BC844: 419A0054  beq cr6, 0x830bc898
	if ctx.cr[6].eq {
	pc = 0x830BC898; continue 'dispatch;
	}
	// 830BC848: 815F0078  lwz r10, 0x78(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830BC84C: 616B0010  ori r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u64 | 16;
	// 830BC850: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 830BC854: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830BC858: 409A001C  bne cr6, 0x830bc874
	if !ctx.cr[6].eq {
	pc = 0x830BC874; continue 'dispatch;
	}
	// 830BC85C: 3D608218  lis r11, -0x7de8
	ctx.r[11].s64 = -2112356352;
	// 830BC860: 38A003FF  li r5, 0x3ff
	ctx.r[5].s64 = 1023;
	// 830BC864: 388B7704  addi r4, r11, 0x7704
	ctx.r[4].s64 = ctx.r[11].s64 + 30468;
	// 830BC868: 3860003C  li r3, 0x3c
	ctx.r[3].s64 = 60;
	// 830BC86C: 4BFF83ED  bl 0x830b4c58
	ctx.lr = 0x830BC870;
	sub_830B4C58(ctx, base);
	// 830BC870: 907F0078  stw r3, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[3].u32 ) };
	// 830BC874: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830BC878: 3D80FFD7  lis r12, -0x29
	ctx.r[12].s64 = -2686976;
	// 830BC87C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BC880: 618CFFEF  ori r12, r12, 0xffef
	ctx.r[12].u64 = ctx.r[12].u64 | 65519;
	// 830BC884: D3EB0010  stfs f31, 0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 830BC888: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 830BC88C: 7D6B6038  and r11, r11, r12
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[12].u64;
	// 830BC890: 917F007C  stw r11, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 830BC894: 48000BC5  bl 0x830bd458
	ctx.lr = 0x830BC898;
	sub_830BD458(ctx, base);
	// 830BC898: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830BC89C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830BC8A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830BC8A4: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830BC8A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830BC8AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BC8B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830BC8B0 size=160
    let mut pc: u32 = 0x830BC8B0;
    'dispatch: loop {
        match pc {
            0x830BC8B0 => {
    //   block [0x830BC8B0..0x830BC950)
	// 830BC8B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BC8B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830BC8B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830BC8BC: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 830BC8C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BC8C4: 83E3000C  lwz r31, 0xc(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 830BC8C8: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 830BC8CC: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 830BC8D0: 556A06B5  rlwinm. r10, r11, 0, 0x1a, 0x1a
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830BC8D4: 41820014  beq 0x830bc8e8
	if ctx.cr[0].eq {
	pc = 0x830BC8E8; continue 'dispatch;
	}
	// 830BC8D8: 815F0078  lwz r10, 0x78(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830BC8DC: C00A0014  lfs f0, 0x14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BC8E0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 830BC8E4: 419A0054  beq cr6, 0x830bc938
	if ctx.cr[6].eq {
	pc = 0x830BC938; continue 'dispatch;
	}
	// 830BC8E8: 815F0078  lwz r10, 0x78(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830BC8EC: 616B0020  ori r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 | 32;
	// 830BC8F0: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 830BC8F4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830BC8F8: 409A001C  bne cr6, 0x830bc914
	if !ctx.cr[6].eq {
	pc = 0x830BC914; continue 'dispatch;
	}
	// 830BC8FC: 3D608218  lis r11, -0x7de8
	ctx.r[11].s64 = -2112356352;
	// 830BC900: 38A0042B  li r5, 0x42b
	ctx.r[5].s64 = 1067;
	// 830BC904: 388B7704  addi r4, r11, 0x7704
	ctx.r[4].s64 = ctx.r[11].s64 + 30468;
	// 830BC908: 3860003C  li r3, 0x3c
	ctx.r[3].s64 = 60;
	// 830BC90C: 4BFF834D  bl 0x830b4c58
	ctx.lr = 0x830BC910;
	sub_830B4C58(ctx, base);
	// 830BC910: 907F0078  stw r3, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[3].u32 ) };
	// 830BC914: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830BC918: 3D80FFD7  lis r12, -0x29
	ctx.r[12].s64 = -2686976;
	// 830BC91C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BC920: 618CFFDF  ori r12, r12, 0xffdf
	ctx.r[12].u64 = ctx.r[12].u64 | 65503;
	// 830BC924: D3EB0014  stfs f31, 0x14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 830BC928: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 830BC92C: 7D6B6038  and r11, r11, r12
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[12].u64;
	// 830BC930: 917F007C  stw r11, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 830BC934: 48000B25  bl 0x830bd458
	ctx.lr = 0x830BC938;
	sub_830BD458(ctx, base);
	// 830BC938: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830BC93C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830BC940: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830BC944: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830BC948: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830BC94C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BC950(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830BC950 size=88
    let mut pc: u32 = 0x830BC950;
    'dispatch: loop {
        match pc {
            0x830BC950 => {
    //   block [0x830BC950..0x830BC9A8)
	// 830BC950: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BC954: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830BC958: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830BC95C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830BC960: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BC964: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830BC968: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830BC96C: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 830BC970: 389F0004  addi r4, r31, 4
	ctx.r[4].s64 = ctx.r[31].s64 + 4;
	// 830BC974: 4BFF56B5  bl 0x830b2028
	ctx.lr = 0x830BC978;
	sub_830B2028(ctx, base);
	// 830BC978: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830BC97C: 917E000C  stw r11, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 830BC980: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830BC984: 917E0014  stw r11, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 830BC988: C01F0018  lfs f0, 0x18(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BC98C: D01E0018  stfs f0, 0x18(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 830BC990: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830BC994: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830BC998: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830BC99C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830BC9A0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830BC9A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BC9A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830BC9A8 size=624
    let mut pc: u32 = 0x830BC9A8;
    'dispatch: loop {
        match pc {
            0x830BC9A8 => {
    //   block [0x830BC9A8..0x830BCC18)
	// 830BC9A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BC9AC: 480EB7B9  bl 0x831a8164
	ctx.lr = 0x830BC9B0;
	sub_831A8130(ctx, base);
	// 830BC9B0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BC9B4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 830BC9B8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830BC9BC: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 830BC9C0: 83FB000C  lwz r31, 0xc(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 830BC9C4: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 830BC9C8: 556B0458  rlwinm r11, r11, 0, 0x11, 0xc
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830BC9CC: 917F007C  stw r11, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 830BC9D0: 4BFFB8C9  bl 0x830b8298
	ctx.lr = 0x830BC9D4;
	sub_830B8298(ctx, base);
	// 830BC9D4: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 830BC9D8: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 830BC9DC: 4BFFB8DD  bl 0x830b82b8
	ctx.lr = 0x830BC9E0;
	sub_830B82B8(ctx, base);
	// 830BC9E0: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 830BC9E4: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 830BC9E8: 4BFFBA01  bl 0x830b83e8
	ctx.lr = 0x830BC9EC;
	sub_830B83E8(ctx, base);
	// 830BC9EC: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 830BC9F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830BC9F4: 409A008C  bne cr6, 0x830bca80
	if !ctx.cr[6].eq {
	pc = 0x830BCA80; continue 'dispatch;
	}
	// 830BC9F8: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 830BC9FC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 830BCA00: 3D608218  lis r11, -0x7de8
	ctx.r[11].s64 = -2112356352;
	// 830BCA04: 38A000F0  li r5, 0xf0
	ctx.r[5].s64 = 240;
	// 830BCA08: 3BAB7704  addi r29, r11, 0x7704
	ctx.r[29].s64 = ctx.r[11].s64 + 30468;
	// 830BCA0C: 992A0000  stb r9, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	// 830BCA10: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 830BCA14: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830BCA18: 8B810050  lbz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830BCA1C: 4BFF823D  bl 0x830b4c58
	ctx.lr = 0x830BCA20;
	sub_830B4C58(ctx, base);
	// 830BCA20: 3BDB001C  addi r30, r27, 0x1c
	ctx.r[30].s64 = ctx.r[27].s64 + 28;
	// 830BCA24: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830BCA28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830BCA2C: 4BFF556D  bl 0x830b1f98
	ctx.lr = 0x830BCA30;
	sub_830B1F98(ctx, base);
	// 830BCA30: 807B0020  lwz r3, 0x20(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(32 as u32) ) } as u64;
	// 830BCA34: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830BCA38: 419A000C  beq cr6, 0x830bca44
	if ctx.cr[6].eq {
	pc = 0x830BCA44; continue 'dispatch;
	}
	// 830BCA3C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830BCA40: 4BFF5441  bl 0x830b1e80
	ctx.lr = 0x830BCA44;
	sub_830B1E80(ctx, base);
	// 830BCA44: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830BCA48: 4BFF54E1  bl 0x830b1f28
	ctx.lr = 0x830BCA4C;
	sub_830B1F28(ctx, base);
	// 830BCA4C: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 830BCA50: 48000B11  bl 0x830bd560
	ctx.lr = 0x830BCA54;
	sub_830BD560(ctx, base);
	// 830BCA54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BCA58: 48000B61  bl 0x830bd5b8
	ctx.lr = 0x830BCA5C;
	sub_830BD5B8(ctx, base);
	// 830BCA5C: 48000B25  bl 0x830bd580
	ctx.lr = 0x830BCA60;
	sub_830BD580(ctx, base);
	// 830BCA60: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830BCA64: 38A000F7  li r5, 0xf7
	ctx.r[5].s64 = 247;
	// 830BCA68: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 830BCA6C: 4BFF81ED  bl 0x830b4c58
	ctx.lr = 0x830BCA70;
	sub_830B4C58(ctx, base);
	// 830BCA70: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830BCA74: 907F008C  stw r3, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[3].u32 ) };
	// 830BCA78: 917F013C  stw r11, 0x13c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(316 as u32), ctx.r[11].u32 ) };
	// 830BCA7C: 48000074  b 0x830bcaf0
	pc = 0x830BCAF0; continue 'dispatch;
	// 830BCA80: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BCA84: C1A1005C  lfs f13, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830BCA88: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830BCA8C: 409A0054  bne cr6, 0x830bcae0
	if !ctx.cr[6].eq {
	pc = 0x830BCAE0; continue 'dispatch;
	}
	// 830BCA90: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BCA94: C1A10060  lfs f13, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830BCA98: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830BCA9C: 409A0044  bne cr6, 0x830bcae0
	if !ctx.cr[6].eq {
	pc = 0x830BCAE0; continue 'dispatch;
	}
	// 830BCAA0: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BCAA4: C1A10064  lfs f13, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830BCAA8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830BCAAC: 409A0034  bne cr6, 0x830bcae0
	if !ctx.cr[6].eq {
	pc = 0x830BCAE0; continue 'dispatch;
	}
	// 830BCAB0: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BCAB4: C1A10068  lfs f13, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830BCAB8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830BCABC: 409A0024  bne cr6, 0x830bcae0
	if !ctx.cr[6].eq {
	pc = 0x830BCAE0; continue 'dispatch;
	}
	// 830BCAC0: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BCAC4: C1A1006C  lfs f13, 0x6c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830BCAC8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830BCACC: 409A0014  bne cr6, 0x830bcae0
	if !ctx.cr[6].eq {
	pc = 0x830BCAE0; continue 'dispatch;
	}
	// 830BCAD0: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BCAD4: C1A10070  lfs f13, 0x70(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830BCAD8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830BCADC: 419A0014  beq cr6, 0x830bcaf0
	if ctx.cr[6].eq {
	pc = 0x830BCAF0; continue 'dispatch;
	}
	// 830BCAE0: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 830BCAE4: 556B07F8  rlwinm r11, r11, 0, 0x1f, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830BCAE8: 556B0356  rlwinm r11, r11, 0, 0xd, 0xb
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830BCAEC: 917F007C  stw r11, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 830BCAF0: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 830BCAF4: 556A0319  rlwinm. r10, r11, 0, 0xc, 0xc
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830BCAF8: 40820118  bne 0x830bcc10
	if !ctx.cr[0].eq {
	pc = 0x830BCC10; continue 'dispatch;
	}
	// 830BCAFC: 556A07FF  clrlwi. r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830BCB00: 40820018  bne 0x830bcb18
	if !ctx.cr[0].eq {
	pc = 0x830BCB18; continue 'dispatch;
	}
	// 830BCB04: 815F0028  lwz r10, 0x28(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 830BCB08: 656B0002  oris r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u64 | 131072;
	// 830BCB0C: 616B8001  ori r11, r11, 0x8001
	ctx.r[11].u64 = ctx.r[11].u64 | 32769;
	// 830BCB10: 917F007C  stw r11, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 830BCB14: 915F0020  stw r10, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 830BCB18: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 830BCB1C: 556A0631  rlwinm. r10, r11, 0, 0x18, 0x18
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830BCB20: 40820018  bne 0x830bcb38
	if !ctx.cr[0].eq {
	pc = 0x830BCB38; continue 'dispatch;
	}
	// 830BCB24: 815F0044  lwz r10, 0x44(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 830BCB28: 656B0004  oris r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 262144;
	// 830BCB2C: 616B8080  ori r11, r11, 0x8080
	ctx.r[11].u64 = ctx.r[11].u64 | 32896;
	// 830BCB30: 917F007C  stw r11, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 830BCB34: 915F0024  stw r10, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[10].u32 ) };
	// 830BCB38: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 830BCB3C: 556B06BC  rlwinm r11, r11, 0, 0x1a, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830BCB40: 2F0B003E  cmpwi cr6, r11, 0x3e
	ctx.cr[6].compare_i32(ctx.r[11].s32, 62, &mut ctx.xer);
	// 830BCB44: 419A0078  beq cr6, 0x830bcbbc
	if ctx.cr[6].eq {
	pc = 0x830BCBBC; continue 'dispatch;
	}
	// 830BCB48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BCB4C: 48002AFD  bl 0x830bf648
	ctx.lr = 0x830BCB50;
	sub_830BF648(ctx, base);
	// 830BCB50: C01F002C  lfs f0, 0x2c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BCB54: C1BF0030  lfs f13, 0x30(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830BCB58: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 830BCB5C: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 830BCB60: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 830BCB64: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 830BCB68: 4BFFB791  bl 0x830b82f8
	ctx.lr = 0x830BCB6C;
	sub_830B82F8(ctx, base);
	// 830BCB6C: 4BFFB7BD  bl 0x830b8328
	ctx.lr = 0x830BCB70;
	sub_830B8328(ctx, base);
	// 830BCB70: FC000890  fmr f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64;
	// 830BCB74: C1BB0018  lfs f13, 0x18(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830BCB78: C1810054  lfs f12, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830BCB7C: C0210058  lfs f1, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830BCB80: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 830BCB84: EC400332  fmuls f2, f0, f12
	ctx.f[2].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 830BCB88: D0410054  stfs f2, 0x54(r1)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 830BCB8C: 48001DAD  bl 0x830be938
	ctx.lr = 0x830BCB90;
	sub_830BE938(ctx, base);
	// 830BCB90: 48002421  bl 0x830befb0
	ctx.lr = 0x830BCB94;
	sub_830BEFB0(ctx, base);
	// 830BCB94: C03F0034  lfs f1, 0x34(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830BCB98: 48002119  bl 0x830becb0
	ctx.lr = 0x830BCB9C;
	sub_830BECB0(ctx, base);
	// 830BCB9C: C05F003C  lfs f2, 0x3c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 830BCBA0: C03F0038  lfs f1, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830BCBA4: 4800226D  bl 0x830bee10
	ctx.lr = 0x830BCBA8;
	sub_830BEE10(ctx, base);
	// 830BCBA8: 480023A1  bl 0x830bef48
	ctx.lr = 0x830BCBAC;
	sub_830BEF48(ctx, base);
	// 830BCBAC: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 830BCBB0: 656B0001  oris r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 65536;
	// 830BCBB4: 616B803E  ori r11, r11, 0x803e
	ctx.r[11].u64 = ctx.r[11].u64 | 32830;
	// 830BCBB8: 917F007C  stw r11, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 830BCBBC: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 830BCBC0: 815F008C  lwz r10, 0x8c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 830BCBC4: 656B0008  oris r11, r11, 8
	ctx.r[11].u64 = ctx.r[11].u64 | 524288;
	// 830BCBC8: 917F007C  stw r11, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 830BCBCC: C001005C  lfs f0, 0x5c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BCBD0: D00A0000  stfs f0, 0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830BCBD4: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 830BCBD8: C0010060  lfs f0, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BCBDC: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830BCBE0: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 830BCBE4: C0010064  lfs f0, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BCBE8: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 830BCBEC: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 830BCBF0: C0010068  lfs f0, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BCBF4: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830BCBF8: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 830BCBFC: C001006C  lfs f0, 0x6c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BCC00: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 830BCC04: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 830BCC08: C0010070  lfs f0, 0x70(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BCC0C: D00B0014  stfs f0, 0x14(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 830BCC10: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 830BCC14: 480EB5A0  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BCC18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830BCC18 size=220
    let mut pc: u32 = 0x830BCC18;
    'dispatch: loop {
        match pc {
            0x830BCC18 => {
    //   block [0x830BCC18..0x830BCCF4)
	// 830BCC18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BCC1C: 480EB551  bl 0x831a816c
	ctx.lr = 0x830BCC20;
	sub_831A8130(ctx, base);
	// 830BCC20: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 830BCC24: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BCC28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830BCC2C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 830BCC30: 4BFF5D59  bl 0x830b2988
	ctx.lr = 0x830BCC34;
	sub_830B2988(ctx, base);
	// 830BCC34: 3D608218  lis r11, -0x7de8
	ctx.r[11].s64 = -2112356352;
	// 830BCC38: D3FF0018  stfs f31, 0x18(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 830BCC3C: 3BDF001C  addi r30, r31, 0x1c
	ctx.r[30].s64 = ctx.r[31].s64 + 28;
	// 830BCC40: 396B7540  addi r11, r11, 0x7540
	ctx.r[11].s64 = ctx.r[11].s64 + 30016;
	// 830BCC44: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830BCC48: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830BCC4C: 4BFF5275  bl 0x830b1ec0
	ctx.lr = 0x830BCC50;
	sub_830B1EC0(ctx, base);
	// 830BCC50: 3D608218  lis r11, -0x7de8
	ctx.r[11].s64 = -2112356352;
	// 830BCC54: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830BCC58: 396B74C0  addi r11, r11, 0x74c0
	ctx.r[11].s64 = ctx.r[11].s64 + 29888;
	// 830BCC5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830BCC60: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 830BCC64: 4BFF5335  bl 0x830b1f98
	ctx.lr = 0x830BCC68;
	sub_830B1F98(ctx, base);
	// 830BCC68: 3D608218  lis r11, -0x7de8
	ctx.r[11].s64 = -2112356352;
	// 830BCC6C: 38A00036  li r5, 0x36
	ctx.r[5].s64 = 54;
	// 830BCC70: 388B7704  addi r4, r11, 0x7704
	ctx.r[4].s64 = ctx.r[11].s64 + 30468;
	// 830BCC74: 38600144  li r3, 0x144
	ctx.r[3].s64 = 324;
	// 830BCC78: 4BFF7FE1  bl 0x830b4c58
	ctx.lr = 0x830BCC7C;
	sub_830B4C58(ctx, base);
	// 830BCC7C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830BCC80: 4BFFEAA9  bl 0x830bb728
	ctx.lr = 0x830BCC84;
	sub_830BB728(ctx, base);
	// 830BCC84: 3D60830C  lis r11, -0x7cf4
	ctx.r[11].s64 = -2096365568;
	// 830BCC88: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 830BCC8C: 396BBCC8  addi r11, r11, -0x4338
	ctx.r[11].s64 = ctx.r[11].s64 + -17208;
	// 830BCC90: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830BCC94: 4BFF522D  bl 0x830b1ec0
	ctx.lr = 0x830BCC98;
	sub_830B1EC0(ctx, base);
	// 830BCC98: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 830BCC9C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830BCCA0: 396BEDD8  addi r11, r11, -0x1228
	ctx.r[11].s64 = ctx.r[11].s64 + -4648;
	// 830BCCA4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830BCCA8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 830BCCAC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 830BCCB0: 4BFFC5C1  bl 0x830b9270
	ctx.lr = 0x830BCCB4;
	sub_830B9270(ctx, base);
	// 830BCCB4: 3BDF0004  addi r30, r31, 4
	ctx.r[30].s64 = ctx.r[31].s64 + 4;
	// 830BCCB8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830BCCBC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830BCCC0: 4BFF53F1  bl 0x830b20b0
	ctx.lr = 0x830BCCC4;
	sub_830B20B0(ctx, base);
	// 830BCCC4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830BCCC8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830BCCCC: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 830BCCD0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830BCCD4: 4BFF5355  bl 0x830b2028
	ctx.lr = 0x830BCCD8;
	sub_830B2028(ctx, base);
	// 830BCCD8: 93BF000C  stw r29, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 830BCCDC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 830BCCE0: 4BFF51F9  bl 0x830b1ed8
	ctx.lr = 0x830BCCE4;
	sub_830B1ED8(ctx, base);
	// 830BCCE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BCCE8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830BCCEC: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 830BCCF0: 480EB4CC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BCCF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BCCF8 size=24
    let mut pc: u32 = 0x830BCCF8;
    'dispatch: loop {
        match pc {
            0x830BCCF8 => {
    //   block [0x830BCCF8..0x830BCD10)
	// 830BCCF8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BCCFC: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BCD00: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830BCD04: 4098000C  bge cr6, 0x830bcd10
	if !ctx.cr[6].lt {
		sub_830BCD10(ctx, base);
		return;
	}
	// 830BCD08: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 830BCD0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BCD10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BCD10 size=8
    let mut pc: u32 = 0x830BCD10;
    'dispatch: loop {
        match pc {
            0x830BCD10 => {
    //   block [0x830BCD10..0x830BCD18)
	// 830BCD10: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830BCD14: 4D990020  bgtlr cr6
	if ctx.cr[6].gt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BCD18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BCD18 size=8
    let mut pc: u32 = 0x830BCD18;
    'dispatch: loop {
        match pc {
            0x830BCD18 => {
    //   block [0x830BCD18..0x830BCD20)
	// 830BCD18: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830BCD1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BCD20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BCD20 size=64
    let mut pc: u32 = 0x830BCD20;
    'dispatch: loop {
        match pc {
            0x830BCD20 => {
    //   block [0x830BCD20..0x830BCD60)
	// 830BCD20: 81030024  lwz r8, 0x24(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 830BCD24: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 830BCD28: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 830BCD2C: 40990020  ble cr6, 0x830bcd4c
	if !ctx.cr[6].gt {
	pc = 0x830BCD4C; continue 'dispatch;
	}
	// 830BCD30: 81430028  lwz r10, 0x28(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 830BCD34: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 830BCD38: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BCD3C: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BCD40: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 830BCD44: 7D274A14  add r9, r7, r9
	ctx.r[9].u64 = ctx.r[7].u64 + ctx.r[9].u64;
	// 830BCD48: 4082FFF0  bne 0x830bcd38
	if !ctx.cr[0].eq {
	pc = 0x830BCD38; continue 'dispatch;
	}
	// 830BCD4C: 1D690144  mulli r11, r9, 0x144
	ctx.r[11].s64 = ctx.r[9].s64 * 324;
	// 830BCD50: 550A2036  slwi r10, r8, 4
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830BCD54: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830BCD58: 386B0048  addi r3, r11, 0x48
	ctx.r[3].s64 = ctx.r[11].s64 + 72;
	// 830BCD5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BCD60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830BCD60 size=220
    let mut pc: u32 = 0x830BCD60;
    'dispatch: loop {
        match pc {
            0x830BCD60 => {
    //   block [0x830BCD60..0x830BCE3C)
	// 830BCD60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BCD64: 480EB401  bl 0x831a8164
	ctx.lr = 0x830BCD68;
	sub_831A8130(ctx, base);
	// 830BCD68: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BCD6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830BCD70: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830BCD74: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 830BCD78: 817F0094  lwz r11, 0x94(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 830BCD7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830BCD80: 419A0028  beq cr6, 0x830bcda8
	if ctx.cr[6].eq {
	pc = 0x830BCDA8; continue 'dispatch;
	}
	// 830BCD84: 817F013C  lwz r11, 0x13c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 830BCD88: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BCD8C: 419A0010  beq cr6, 0x830bcd9c
	if ctx.cr[6].eq {
	pc = 0x830BCD9C; continue 'dispatch;
	}
	// 830BCD90: 807F008C  lwz r3, 0x8c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 830BCD94: 4BFF7EED  bl 0x830b4c80
	ctx.lr = 0x830BCD98;
	sub_830B4C80(ctx, base);
	// 830BCD98: 48000010  b 0x830bcda8
	pc = 0x830BCDA8; continue 'dispatch;
	// 830BCD9C: 937F008C  stw r27, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[27].u32 ) };
	// 830BCDA0: 937F0090  stw r27, 0x90(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[27].u32 ) };
	// 830BCDA4: 937F0094  stw r27, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[27].u32 ) };
	// 830BCDA8: 397F0098  addi r11, r31, 0x98
	ctx.r[11].s64 = ctx.r[31].s64 + 152;
	// 830BCDAC: 937F013C  stw r27, 0x13c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(316 as u32), ctx.r[27].u32 ) };
	// 830BCDB0: 395F00E8  addi r10, r31, 0xe8
	ctx.r[10].s64 = ctx.r[31].s64 + 232;
	// 830BCDB4: 393F0138  addi r9, r31, 0x138
	ctx.r[9].s64 = ctx.r[31].s64 + 312;
	// 830BCDB8: 917F008C  stw r11, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 830BCDBC: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 830BCDC0: 915F0090  stw r10, 0x90(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[10].u32 ) };
	// 830BCDC4: 913F0094  stw r9, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[9].u32 ) };
	// 830BCDC8: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 830BCDCC: 911F0088  stw r8, 0x88(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[8].u32 ) };
	// 830BCDD0: C01E000C  lfs f0, 0xc(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BCDD4: D01F0098  stfs f0, 0x98(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 830BCDD8: 3B800004  li r28, 4
	ctx.r[28].s64 = 4;
	// 830BCDDC: C01E0010  lfs f0, 0x10(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BCDE0: D01F009C  stfs f0, 0x9c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 830BCDE4: C01E0014  lfs f0, 0x14(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BCDE8: D01F00AC  stfs f0, 0xac(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 830BCDEC: C01E0018  lfs f0, 0x18(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BCDF0: D01F00B0  stfs f0, 0xb0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 830BCDF4: C01E001C  lfs f0, 0x1c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BCDF8: D01F00C0  stfs f0, 0xc0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 830BCDFC: C01E0020  lfs f0, 0x20(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BCE00: D01F00C4  stfs f0, 0xc4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 830BCE04: C01E0024  lfs f0, 0x24(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BCE08: D01F00D4  stfs f0, 0xd4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 830BCE0C: C01E0028  lfs f0, 0x28(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BCE10: D01F00D8  stfs f0, 0xd8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 830BCE14: 389D0004  addi r4, r29, 4
	ctx.r[4].s64 = ctx.r[29].s64 + 4;
	// 830BCE18: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830BCE1C: 4BFFB39D  bl 0x830b81b8
	ctx.lr = 0x830BCE20;
	sub_830B81B8(ctx, base);
	// 830BCE20: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 830BCE24: 3BBD0014  addi r29, r29, 0x14
	ctx.r[29].s64 = ctx.r[29].s64 + 20;
	// 830BCE28: 4082FFEC  bne 0x830bce14
	if !ctx.cr[0].eq {
	pc = 0x830BCE14; continue 'dispatch;
	}
	// 830BCE2C: 937F007C  stw r27, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[27].u32 ) };
	// 830BCE30: 937F0140  stw r27, 0x140(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(320 as u32), ctx.r[27].u32 ) };
	// 830BCE34: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830BCE38: 480EB37C  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BCE40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830BCE40 size=1248
    let mut pc: u32 = 0x830BCE40;
    'dispatch: loop {
        match pc {
            0x830BCE40 => {
    //   block [0x830BCE40..0x830BD320)
	// 830BCE40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BCE44: 480EB2F5  bl 0x831a8138
	ctx.lr = 0x830BCE48;
	sub_831A8130(ctx, base);
	// 830BCE48: 3981FF78  addi r12, r1, -0x88
	ctx.r[12].s64 = ctx.r[1].s64 + -136;
	// 830BCE4C: 480EBC19  bl 0x831a8a64
	ctx.lr = 0x830BCE50;
	sub_831A8A40(ctx, base);
	// 830BCE50: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BCE54: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 830BCE58: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830BCE5C: 7C972378  mr r23, r4
	ctx.r[23].u64 = ctx.r[4].u64;
	// 830BCE60: 7CB12B78  mr r17, r5
	ctx.r[17].u64 = ctx.r[5].u64;
	// 830BCE64: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 830BCE68: 419A04A8  beq cr6, 0x830bd310
	if ctx.cr[6].eq {
	pc = 0x830BD310; continue 'dispatch;
	}
	// 830BCE6C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BCE70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830BCE74: 419A049C  beq cr6, 0x830bd310
	if ctx.cr[6].eq {
	pc = 0x830BD310; continue 'dispatch;
	}
	// 830BCE78: 817E0094  lwz r11, 0x94(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(148 as u32) ) } as u64;
	// 830BCE7C: 3A000000  li r16, 0
	ctx.r[16].s64 = 0;
	// 830BCE80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830BCE84: 419A0030  beq cr6, 0x830bceb4
	if ctx.cr[6].eq {
	pc = 0x830BCEB4; continue 'dispatch;
	}
	// 830BCE88: 817E013C  lwz r11, 0x13c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(316 as u32) ) } as u64;
	// 830BCE8C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BCE90: 419A0018  beq cr6, 0x830bcea8
	if ctx.cr[6].eq {
	pc = 0x830BCEA8; continue 'dispatch;
	}
	// 830BCE94: 807E008C  lwz r3, 0x8c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) } as u64;
	// 830BCE98: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830BCE9C: 419A0018  beq cr6, 0x830bceb4
	if ctx.cr[6].eq {
	pc = 0x830BCEB4; continue 'dispatch;
	}
	// 830BCEA0: 4BFF7DE1  bl 0x830b4c80
	ctx.lr = 0x830BCEA4;
	sub_830B4C80(ctx, base);
	// 830BCEA4: 4800000C  b 0x830bceb0
	pc = 0x830BCEB0; continue 'dispatch;
	// 830BCEA8: 921E0090  stw r16, 0x90(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(144 as u32), ctx.r[16].u32 ) };
	// 830BCEAC: 921E0094  stw r16, 0x94(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(148 as u32), ctx.r[16].u32 ) };
	// 830BCEB0: 921E008C  stw r16, 0x8c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(140 as u32), ctx.r[16].u32 ) };
	// 830BCEB4: 817E0064  lwz r11, 0x64(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 830BCEB8: 83F70044  lwz r31, 0x44(r23)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(68 as u32) ) } as u64;
	// 830BCEBC: 80B70048  lwz r5, 0x48(r23)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(72 as u32) ) } as u64;
	// 830BCEC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830BCEC4: 419A0008  beq cr6, 0x830bcecc
	if ctx.cr[6].eq {
	pc = 0x830BCECC; continue 'dispatch;
	}
	// 830BCEC8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 830BCECC: 817E0068  lwz r11, 0x68(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(104 as u32) ) } as u64;
	// 830BCED0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830BCED4: 419A0008  beq cr6, 0x830bcedc
	if ctx.cr[6].eq {
	pc = 0x830BCEDC; continue 'dispatch;
	}
	// 830BCED8: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 830BCEDC: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BCEE0: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 830BCEE4: 4BFFEC1D  bl 0x830bbb00
	ctx.lr = 0x830BCEE8;
	sub_830BBB00(ctx, base);
	// 830BCEE8: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BCEEC: 54691838  slwi r9, r3, 3
	ctx.r[9].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 830BCEF0: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 830BCEF4: 7E495214  add r18, r9, r10
	ctx.r[18].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 830BCEF8: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BCEFC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830BCF00: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830BCF04: 409AFFF4  bne cr6, 0x830bcef8
	if !ctx.cr[6].eq {
	pc = 0x830BCEF8; continue 'dispatch;
	}
	// 830BCF08: 7D7F5850  subf r11, r31, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[31].s64;
	// 830BCF0C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830BCF10: 5575003F  rotlwi. r21, r11, 0
	ctx.r[21].u64 = ((ctx.r[11].u32).rotate_left(0)) as u64;
	ctx.cr[0].compare_i32(ctx.r[21].s32, 0, &mut ctx.xer);
	// 830BCF14: 408103FC  ble 0x830bd310
	if !ctx.cr[0].gt {
	pc = 0x830BD310; continue 'dispatch;
	}
	// 830BCF18: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830BCF1C: 81570000  lwz r10, 0(r23)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BCF20: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 830BCF24: C3CB08A4  lfs f30, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 830BCF28: FEE0F090  fmr f23, f30
	ctx.f[23].f64 = ctx.f[30].f64;
	// 830BCF2C: 4198001C  blt cr6, 0x830bcf48
	if ctx.cr[6].lt {
	pc = 0x830BCF48; continue 'dispatch;
	}
	// 830BCF30: 3D608213  lis r11, -0x7ded
	ctx.r[11].s64 = -2112684032;
	// 830BCF34: C2FE0070  lfs f23, 0x70(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(112 as u32) ) };
	ctx.f[23].f64 = (tmp.f32 as f64);
	// 830BCF38: C00BB7B4  lfs f0, -0x484c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-18508 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BCF3C: FF170000  fcmpu cr6, f23, f0
	ctx.cr[6].compare_f64(ctx.f[23].f64, ctx.f[0].f64);
	// 830BCF40: 41990008  bgt cr6, 0x830bcf48
	if ctx.cr[6].gt {
	pc = 0x830BCF48; continue 'dispatch;
	}
	// 830BCF44: C2F7004C  lfs f23, 0x4c(r23)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(76 as u32) ) };
	ctx.f[23].f64 = (tmp.f32 as f64);
	// 830BCF48: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 830BCF4C: C0170018  lfs f0, 0x18(r23)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BCF50: C1B70010  lfs f13, 0x10(r23)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830BCF54: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 830BCF58: EF006828  fsubs f24, f0, f13
	ctx.f[24].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 830BCF5C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830BCF60: FFE0F090  fmr f31, f30
	ctx.f[31].f64 = ctx.f[30].f64;
	// 830BCF64: 7FF6FB78  mr r22, r31
	ctx.r[22].u64 = ctx.r[31].u64;
	// 830BCF68: C00B9594  lfs f0, -0x6a6c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27244 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BCF6C: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 830BCF70: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 830BCF74: 4BFFB2D5  bl 0x830b8248
	ctx.lr = 0x830BCF78;
	sub_830B8248(ctx, base);
	// 830BCF78: 3D608218  lis r11, -0x7de8
	ctx.r[11].s64 = -2112356352;
	// 830BCF7C: 38A001C4  li r5, 0x1c4
	ctx.r[5].s64 = 452;
	// 830BCF80: 388B7734  addi r4, r11, 0x7734
	ctx.r[4].s64 = ctx.r[11].s64 + 30516;
	// 830BCF84: 1C7500A4  mulli r3, r21, 0xa4
	ctx.r[3].s64 = ctx.r[21].s64 * 164;
	// 830BCF88: 4BFF7CD1  bl 0x830b4c58
	ctx.lr = 0x830BCF8C;
	sub_830B4C58(ctx, base);
	// 830BCF8C: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 830BCF90: 1D750050  mulli r11, r21, 0x50
	ctx.r[11].s64 = ctx.r[21].s64 * 80;
	// 830BCF94: 931E008C  stw r24, 0x8c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(140 as u32), ctx.r[24].u32 ) };
	// 830BCF98: 1D5500A0  mulli r10, r21, 0xa0
	ctx.r[10].s64 = ctx.r[21].s64 * 160;
	// 830BCF9C: 7D6BC214  add r11, r11, r24
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[24].u64;
	// 830BCFA0: 7D4AC214  add r10, r10, r24
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[24].u64;
	// 830BCFA4: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 830BCFA8: 917E0090  stw r11, 0x90(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 830BCFAC: 915E0094  stw r10, 0x94(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(148 as u32), ctx.r[10].u32 ) };
	// 830BCFB0: 7E198378  mr r25, r16
	ctx.r[25].u64 = ctx.r[16].u64;
	// 830BCFB4: 913E013C  stw r9, 0x13c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(316 as u32), ctx.r[9].u32 ) };
	// 830BCFB8: 7E138378  mr r19, r16
	ctx.r[19].u64 = ctx.r[16].u64;
	// 830BCFBC: C3B7000C  lfs f29, 0xc(r23)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(12 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 830BCFC0: 2F150000  cmpwi cr6, r21, 0
	ctx.cr[6].compare_i32(ctx.r[21].s32, 0, &mut ctx.xer);
	// 830BCFC4: C3970010  lfs f28, 0x10(r23)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(16 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 830BCFC8: C3770018  lfs f27, 0x18(r23)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(24 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 830BCFCC: C3570020  lfs f26, 0x20(r23)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(32 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 830BCFD0: C3370028  lfs f25, 0x28(r23)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(40 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 830BCFD4: 40990270  ble cr6, 0x830bd244
	if !ctx.cr[6].gt {
	pc = 0x830BD244; continue 'dispatch;
	}
	// 830BCFD8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830BCFDC: 7E1C8378  mr r28, r16
	ctx.r[28].u64 = ctx.r[16].u64;
	// 830BCFE0: 7F1DC378  mr r29, r24
	ctx.r[29].u64 = ctx.r[24].u64;
	// 830BCFE4: 7F1FC378  mr r31, r24
	ctx.r[31].u64 = ctx.r[24].u64;
	// 830BCFE8: 3B58003C  addi r26, r24, 0x3c
	ctx.r[26].s64 = ctx.r[24].s64 + 60;
	// 830BCFEC: C00B08A8  lfs f0, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BCFF0: 3B780028  addi r27, r24, 0x28
	ctx.r[27].s64 = ctx.r[24].s64 + 40;
	// 830BCFF4: EF00C024  fdivs f24, f0, f24
	ctx.f[24].f64 = ((ctx.f[0].f64 / ctx.f[24].f64) as f32) as f64;
	// 830BCFF8: 3A80FFFF  li r20, -1
	ctx.r[20].s64 = -1;
	// 830BCFFC: 89760000  lbz r11, 0(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BD000: 696A0020  xori r10, r11, 0x20
	ctx.r[10].u64 = ctx.r[11].u64 ^ 32;
	// 830BD004: 2B0A00A1  cmplwi cr6, r10, 0xa1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 161 as u32, &mut ctx.xer);
	// 830BD008: 41980024  blt cr6, 0x830bd02c
	if ctx.cr[6].lt {
	pc = 0x830BD02C; continue 'dispatch;
	}
	// 830BD00C: 2B0A00D5  cmplwi cr6, r10, 0xd5
	ctx.cr[6].compare_u32(ctx.r[10].u32, 213 as u32, &mut ctx.xer);
	// 830BD010: 4199001C  bgt cr6, 0x830bd02c
	if ctx.cr[6].gt {
	pc = 0x830BD02C; continue 'dispatch;
	}
	// 830BD014: 89360001  lbz r9, 1(r22)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[22].u32.wrapping_add(1 as u32) ) } as u64;
	// 830BD018: 556B442E  rlwinm r11, r11, 8, 0x10, 0x17
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00FFFFFFu64;
	// 830BD01C: 3AD60001  addi r22, r22, 1
	ctx.r[22].s64 = ctx.r[22].s64 + 1;
	// 830BD020: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 830BD024: 3A730001  addi r19, r19, 1
	ctx.r[19].s64 = ctx.r[19].s64 + 1;
	// 830BD028: 48000008  b 0x830bd030
	pc = 0x830BD030; continue 'dispatch;
	// 830BD02C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 830BD030: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 830BD034: 3D60830C  lis r11, -0x7cf4
	ctx.r[11].s64 = -2096365568;
	// 830BD038: 9281005C  stw r20, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[20].u32 ) };
	// 830BD03C: 38C00008  li r6, 8
	ctx.r[6].s64 = 8;
	// 830BD040: 38EBCCF8  addi r7, r11, -0x3308
	ctx.r[7].s64 = ctx.r[11].s64 + -13064;
	// 830BD044: 80B20000  lwz r5, 0(r18)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BD048: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 830BD04C: 80920004  lwz r4, 4(r18)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BD050: 3AD60001  addi r22, r22, 1
	ctx.r[22].s64 = ctx.r[22].s64 + 1;
	// 830BD054: 480F304D  bl 0x831b00a0
	ctx.lr = 0x830BD058;
	sub_831B00A0(ctx, base);
	// 830BD058: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830BD05C: 4182000C  beq 0x830bd068
	if ctx.cr[0].eq {
	pc = 0x830BD068; continue 'dispatch;
	}
	// 830BD060: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BD064: 48000008  b 0x830bd06c
	pc = 0x830BD06C; continue 'dispatch;
	// 830BD068: 7E8AA378  mr r10, r20
	ctx.r[10].u64 = ctx.r[20].u64;
	// 830BD06C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830BD070: EC1DF82A  fadds f0, f29, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ((ctx.f[29].f64 + ctx.f[31].f64) as f32) as f64;
	// 830BD074: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 830BD078: 409800AC  bge cr6, 0x830bd124
	if !ctx.cr[6].lt {
	pc = 0x830BD124; continue 'dispatch;
	}
	// 830BD07C: 817E0094  lwz r11, 0x94(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(148 as u32) ) } as u64;
	// 830BD080: 3BBD0050  addi r29, r29, 0x50
	ctx.r[29].s64 = ctx.r[29].s64 + 80;
	// 830BD084: 7E8BE12E  stwx r20, r11, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32), ctx.r[20].u32) };
	// 830BD088: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830BD08C: EDB80372  fmuls f13, f24, f13
	ctx.f[13].f64 = (((ctx.f[24].f64 * ctx.f[13].f64) as f32) as f64);
	// 830BD090: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830BD094: ED8D0732  fmuls f12, f13, f28
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[28].f64) as f32) as f64);
	// 830BD098: D19F0004  stfs f12, 4(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830BD09C: 817E0048  lwz r11, 0x48(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 830BD0A0: ED8D06F2  fmuls f12, f13, f27
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[27].f64) as f32) as f64);
	// 830BD0A4: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830BD0A8: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 830BD0AC: D3DF000C  stfs f30, 0xc(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830BD0B0: EC0D0672  fmuls f0, f13, f25
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[25].f64) as f32) as f64);
	// 830BD0B4: D3DF0010  stfs f30, 0x10(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 830BD0B8: ED6D06B2  fmuls f11, f13, f26
	ctx.f[11].f64 = (((ctx.f[13].f64 * ctx.f[26].f64) as f32) as f64);
	// 830BD0BC: D19F0018  stfs f12, 0x18(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 830BD0C0: 817E004C  lwz r11, 0x4c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) } as u64;
	// 830BD0C4: D3DF0020  stfs f30, 0x20(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 830BD0C8: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 830BD0CC: D3DF0024  stfs f30, 0x24(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 830BD0D0: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 830BD0D4: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830BD0D8: EDBD682A  fadds f13, f29, f13
	ctx.f[13].f64 = ((ctx.f[29].f64 + ctx.f[13].f64) as f32) as f64;
	// 830BD0DC: EDADF82A  fadds f13, f13, f31
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[31].f64) as f32) as f64;
	// 830BD0E0: D1BB0000  stfs f13, 0(r27)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830BD0E4: D17F002C  stfs f11, 0x2c(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 830BD0E8: 817E0050  lwz r11, 0x50(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(80 as u32) ) } as u64;
	// 830BD0EC: 917F0030  stw r11, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 830BD0F0: D3DF0034  stfs f30, 0x34(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 830BD0F4: D3DF0038  stfs f30, 0x38(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 830BD0F8: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830BD0FC: EDBD682A  fadds f13, f29, f13
	ctx.f[13].f64 = ((ctx.f[29].f64 + ctx.f[13].f64) as f32) as f64;
	// 830BD100: EDADF82A  fadds f13, f13, f31
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[31].f64) as f32) as f64;
	// 830BD104: D01F0040  stfs f0, 0x40(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 830BD108: D1BA0000  stfs f13, 0(r26)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830BD10C: 817E0054  lwz r11, 0x54(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 830BD110: 917F0044  stw r11, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[11].u32 ) };
	// 830BD114: D3DF0048  stfs f30, 0x48(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 830BD118: D3DF004C  stfs f30, 0x4c(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 830BD11C: C0010050  lfs f0, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BD120: 48000104  b 0x830bd224
	pc = 0x830BD224; continue 'dispatch;
	// 830BD124: 81710020  lwz r11, 0x20(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(32 as u32) ) } as u64;
	// 830BD128: 1D4A0014  mulli r10, r10, 0x14
	ctx.r[10].s64 = ctx.r[10].s64 * 20;
	// 830BD12C: 813E0094  lwz r9, 0x94(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(148 as u32) ) } as u64;
	// 830BD130: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 830BD134: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BD138: 7D49E12E  stwx r10, r9, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[28].u32), ctx.r[10].u32) };
	// 830BD13C: C16B000C  lfs f11, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830BD140: C18B0008  lfs f12, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830BD144: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 830BD148: C1AB0010  lfs f13, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830BD14C: EDAD6028  fsubs f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 830BD150: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BD154: C18B0004  lfs f12, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830BD158: ED8B6028  fsubs f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 830BD15C: 55491838  slwi r9, r10, 3
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 830BD160: 81510018  lwz r10, 0x18(r17)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(24 as u32) ) } as u64;
	// 830BD164: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 830BD168: C14A0004  lfs f10, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 830BD16C: EDAD02B2  fmuls f13, f13, f10
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[10].f64) as f32) as f64);
	// 830BD170: EDAD0632  fmuls f13, f13, f24
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[24].f64) as f32) as f64);
	// 830BD174: C12A0000  lfs f9, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 830BD178: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830BD17C: ED8C0272  fmuls f12, f12, f9
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[9].f64) as f32) as f64);
	// 830BD180: ED6D0732  fmuls f11, f13, f28
	ctx.f[11].f64 = (((ctx.f[13].f64 * ctx.f[28].f64) as f32) as f64);
	// 830BD184: D17F0004  stfs f11, 4(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830BD188: 815E0048  lwz r10, 0x48(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 830BD18C: ED6D06F2  fmuls f11, f13, f27
	ctx.f[11].f64 = (((ctx.f[13].f64 * ctx.f[27].f64) as f32) as f64);
	// 830BD190: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830BD194: ED8CE82A  fadds f12, f12, f29
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[29].f64) as f32) as f64;
	// 830BD198: C12B0004  lfs f9, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 830BD19C: ED4D06B2  fmuls f10, f13, f26
	ctx.f[10].f64 = (((ctx.f[13].f64 * ctx.f[26].f64) as f32) as f64);
	// 830BD1A0: D13F000C  stfs f9, 0xc(r31)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830BD1A4: ED8CF82A  fadds f12, f12, f31
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[31].f64) as f32) as f64;
	// 830BD1A8: C12B0008  lfs f9, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 830BD1AC: EDAD0672  fmuls f13, f13, f25
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[25].f64) as f32) as f64);
	// 830BD1B0: D13F0010  stfs f9, 0x10(r31)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 830BD1B4: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 830BD1B8: D17F0018  stfs f11, 0x18(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 830BD1BC: 815E004C  lwz r10, 0x4c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) } as u64;
	// 830BD1C0: 915F001C  stw r10, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 830BD1C4: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BD1C8: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 830BD1CC: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BD1D0: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 830BD1D4: D19B0000  stfs f12, 0(r27)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830BD1D8: D15F002C  stfs f10, 0x2c(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 830BD1DC: 815E0050  lwz r10, 0x50(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(80 as u32) ) } as u64;
	// 830BD1E0: 915F0030  stw r10, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[10].u32 ) };
	// 830BD1E4: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BD1E8: D01F0034  stfs f0, 0x34(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 830BD1EC: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BD1F0: D01F0038  stfs f0, 0x38(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 830BD1F4: D19A0000  stfs f12, 0(r26)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830BD1F8: D1BF0040  stfs f13, 0x40(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 830BD1FC: 815E0054  lwz r10, 0x54(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 830BD200: 915F0044  stw r10, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[10].u32 ) };
	// 830BD204: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BD208: D01F0048  stfs f0, 0x48(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 830BD20C: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BD210: D01F004C  stfs f0, 0x4c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 830BD214: C01D0028  lfs f0, 0x28(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(40 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BD218: C1BD0000  lfs f13, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830BD21C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 830BD220: 3BBD0050  addi r29, r29, 0x50
	ctx.r[29].s64 = ctx.r[29].s64 + 80;
	// 830BD224: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 830BD228: 3A730001  addi r19, r19, 1
	ctx.r[19].s64 = ctx.r[19].s64 + 1;
	// 830BD22C: 3BFF0050  addi r31, r31, 0x50
	ctx.r[31].s64 = ctx.r[31].s64 + 80;
	// 830BD230: 3B5A0050  addi r26, r26, 0x50
	ctx.r[26].s64 = ctx.r[26].s64 + 80;
	// 830BD234: 3B7B0050  addi r27, r27, 0x50
	ctx.r[27].s64 = ctx.r[27].s64 + 80;
	// 830BD238: 7F13A800  cmpw cr6, r19, r21
	ctx.cr[6].compare_i32(ctx.r[19].s32, ctx.r[21].s32, &mut ctx.xer);
	// 830BD23C: EFE0B82A  fadds f31, f0, f23
	ctx.f[31].f64 = ((ctx.f[0].f64 + ctx.f[23].f64) as f32) as f64;
	// 830BD240: 4198FDBC  blt cr6, 0x830bcffc
	if ctx.cr[6].lt {
	pc = 0x830BCFFC; continue 'dispatch;
	}
	// 830BD244: 1D790050  mulli r11, r25, 0x50
	ctx.r[11].s64 = ctx.r[25].s64 * 80;
	// 830BD248: 933E0088  stw r25, 0x88(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(136 as u32), ctx.r[25].u32 ) };
	// 830BD24C: C0180000  lfs f0, 0(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BD250: C1B7000C  lfs f13, 0xc(r23)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830BD254: 7D6BC214  add r11, r11, r24
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[24].u64;
	// 830BD258: 3B60FFFF  li r27, -1
	ctx.r[27].s64 = -1;
	// 830BD25C: 2F190000  cmpwi cr6, r25, 0
	ctx.cr[6].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 830BD260: C16BFFD8  lfs f11, -0x28(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-40 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830BD264: C197001C  lfs f12, 0x1c(r23)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(28 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830BD268: ED8C6828  fsubs f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 830BD26C: EFEB0028  fsubs f31, f11, f0
	ctx.f[31].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 830BD270: ED9F6024  fdivs f12, f31, f12
	ctx.f[12].f64 = ((ctx.f[31].f64 / ctx.f[12].f64) as f32) as f64;
	// 830BD274: EFCC0378  fmsubs f30, f12, f13, f0
	ctx.f[30].f64 = (((ctx.f[12].f64 * ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 830BD278: 40990078  ble cr6, 0x830bd2f0
	if !ctx.cr[6].gt {
	pc = 0x830BD2F0; continue 'dispatch;
	}
	// 830BD27C: 7E1A8378  mr r26, r16
	ctx.r[26].u64 = ctx.r[16].u64;
	// 830BD280: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 830BD284: 7FFAC214  add r31, r26, r24
	ctx.r[31].u64 = ctx.r[26].u64 + ctx.r[24].u64;
	// 830BD288: 3B800004  li r28, 4
	ctx.r[28].s64 = 4;
	// 830BD28C: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BD290: 397F000C  addi r11, r31, 0xc
	ctx.r[11].s64 = ctx.r[31].s64 + 12;
	// 830BD294: EC00F02A  fadds f0, f0, f30
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64;
	// 830BD298: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830BD29C: 388BFFF8  addi r4, r11, -8
	ctx.r[4].s64 = ctx.r[11].s64 + -8;
	// 830BD2A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BD2A4: 4BFFAF15  bl 0x830b81b8
	ctx.lr = 0x830BD2A8;
	sub_830B81B8(ctx, base);
	// 830BD2A8: 817E0090  lwz r11, 0x90(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(144 as u32) ) } as u64;
	// 830BD2AC: C01F000C  lfs f0, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BD2B0: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 830BD2B4: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 830BD2B8: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830BD2BC: C01F0010  lfs f0, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BD2C0: 817E0090  lwz r11, 0x90(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(144 as u32) ) } as u64;
	// 830BD2C4: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 830BD2C8: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 830BD2CC: 817E0090  lwz r11, 0x90(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(144 as u32) ) } as u64;
	// 830BD2D0: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 830BD2D4: 3BFF0014  addi r31, r31, 0x14
	ctx.r[31].s64 = ctx.r[31].s64 + 20;
	// 830BD2D8: 936B0008  stw r27, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 830BD2DC: 3BBD0014  addi r29, r29, 0x14
	ctx.r[29].s64 = ctx.r[29].s64 + 20;
	// 830BD2E0: 4082FFAC  bne 0x830bd28c
	if !ctx.cr[0].eq {
	pc = 0x830BD28C; continue 'dispatch;
	}
	// 830BD2E4: 3739FFFF  addic. r25, r25, -1
	ctx.xer.ca = (ctx.r[25].u32 > (!(-1 as u32)));
	ctx.r[25].s64 = ctx.r[25].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 830BD2E8: 3B5A0050  addi r26, r26, 0x50
	ctx.r[26].s64 = ctx.r[26].s64 + 80;
	// 830BD2EC: 4082FF94  bne 0x830bd280
	if !ctx.cr[0].eq {
	pc = 0x830BD280; continue 'dispatch;
	}
	// 830BD2F0: 3D80FFD7  lis r12, -0x29
	ctx.r[12].s64 = -2686976;
	// 830BD2F4: 817E007C  lwz r11, 0x7c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(124 as u32) ) } as u64;
	// 830BD2F8: D3FE006C  stfs f31, 0x6c(r30)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 830BD2FC: 921E0140  stw r16, 0x140(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(320 as u32), ctx.r[16].u32 ) };
	// 830BD300: 618CF07F  ori r12, r12, 0xf07f
	ctx.r[12].u64 = ctx.r[12].u64 | 61567;
	// 830BD304: 937E0044  stw r27, 0x44(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(68 as u32), ctx.r[27].u32 ) };
	// 830BD308: 7D6B6038  and r11, r11, r12
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[12].u64;
	// 830BD30C: 917E007C  stw r11, 0x7c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 830BD310: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 830BD314: 3981FF78  addi r12, r1, -0x88
	ctx.r[12].s64 = ctx.r[1].s64 + -136;
	// 830BD318: 480EB799  bl 0x831a8ab0
	ctx.lr = 0x830BD31C;
	sub_831A8A8C(ctx, base);
	// 830BD31C: 480EAE6C  b 0x831a8188
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BD320(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830BD320 size=200
    let mut pc: u32 = 0x830BD320;
    'dispatch: loop {
        match pc {
            0x830BD320 => {
    //   block [0x830BD320..0x830BD3E8)
	// 830BD320: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BD324: 480EAE41  bl 0x831a8164
	ctx.lr = 0x830BD328;
	sub_831A8130(ctx, base);
	// 830BD328: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BD32C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830BD330: 90A10060  stw r5, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[5].u32 ) };
	// 830BD334: 3B830028  addi r28, r3, 0x28
	ctx.r[28].s64 = ctx.r[3].s64 + 40;
	// 830BD338: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 830BD33C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830BD340: 3B7F0060  addi r27, r31, 0x60
	ctx.r[27].s64 = ctx.r[31].s64 + 96;
	// 830BD344: 83DF002C  lwz r30, 0x2c(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 830BD348: 4BFFE259  bl 0x830bb5a0
	ctx.lr = 0x830BD34C;
	sub_830BB5A0(ctx, base);
	// 830BD34C: 7F1E1840  cmplw cr6, r30, r3
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[3].u32, &mut ctx.xer);
	// 830BD350: 409A0014  bne cr6, 0x830bd364
	if !ctx.cr[6].eq {
	pc = 0x830BD364; continue 'dispatch;
	}
	// 830BD354: 815F0030  lwz r10, 0x30(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 830BD358: 57AB103A  slwi r11, r29, 2
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830BD35C: 7D4A582E  lwzx r10, r10, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830BD360: 48000020  b 0x830bd380
	pc = 0x830BD380; continue 'dispatch;
	// 830BD364: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830BD368: 80DF0030  lwz r6, 0x30(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 830BD36C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830BD370: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830BD374: 4BFFE7E5  bl 0x830bbb58
	ctx.lr = 0x830BD378;
	sub_830BBB58(ctx, base);
	// 830BD378: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BD37C: 57AB103A  slwi r11, r29, 2
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830BD380: 7D4BE12E  stwx r10, r11, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32), ctx.r[10].u32) };
	// 830BD384: 7FCBE214  add r30, r11, r28
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 830BD388: 2F1D0001  cmpwi cr6, r29, 1
	ctx.cr[6].compare_i32(ctx.r[29].s32, 1, &mut ctx.xer);
	// 830BD38C: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 830BD390: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 830BD394: 409A0024  bne cr6, 0x830bd3b8
	if !ctx.cr[6].eq {
	pc = 0x830BD3B8; continue 'dispatch;
	}
	// 830BD398: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830BD39C: C05F0068  lfs f2, 0x68(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 830BD3A0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 830BD3A4: C03C0004  lfs f1, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830BD3A8: 4BFFC4B9  bl 0x830b9860
	ctx.lr = 0x830BD3AC;
	sub_830B9860(ctx, base);
	// 830BD3AC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BD3B0: 917C0004  stw r11, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830BD3B4: 48000020  b 0x830bd3d4
	pc = 0x830BD3D4; continue 'dispatch;
	// 830BD3B8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830BD3BC: C05F006C  lfs f2, 0x6c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 830BD3C0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 830BD3C4: C03E0000  lfs f1, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830BD3C8: 4BFFC499  bl 0x830b9860
	ctx.lr = 0x830BD3CC;
	sub_830B9860(ctx, base);
	// 830BD3CC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BD3D0: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830BD3D4: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 830BD3D8: 2F1D000F  cmpwi cr6, r29, 0xf
	ctx.cr[6].compare_i32(ctx.r[29].s32, 15, &mut ctx.xer);
	// 830BD3DC: 4198FF68  blt cr6, 0x830bd344
	if ctx.cr[6].lt {
	pc = 0x830BD344; continue 'dispatch;
	}
	// 830BD3E0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830BD3E4: 480EADD0  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BD3E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830BD3E8 size=112
    let mut pc: u32 = 0x830BD3E8;
    'dispatch: loop {
        match pc {
            0x830BD3E8 => {
    //   block [0x830BD3E8..0x830BD458)
	// 830BD3E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BD3EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830BD3F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830BD3F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830BD3F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BD3FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830BD400: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830BD404: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 830BD408: 93DF001C  stw r30, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 830BD40C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830BD410: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 830BD414: 419A000C  beq cr6, 0x830bd420
	if ctx.cr[6].eq {
	pc = 0x830BD420; continue 'dispatch;
	}
	// 830BD418: 4BFF7869  bl 0x830b4c80
	ctx.lr = 0x830BD41C;
	sub_830B4C80(ctx, base);
	// 830BD41C: 93DF0078  stw r30, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[30].u32 ) };
	// 830BD420: 817F013C  lwz r11, 0x13c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 830BD424: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BD428: 419A0018  beq cr6, 0x830bd440
	if ctx.cr[6].eq {
	pc = 0x830BD440; continue 'dispatch;
	}
	// 830BD42C: 807F008C  lwz r3, 0x8c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 830BD430: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830BD434: 419A000C  beq cr6, 0x830bd440
	if ctx.cr[6].eq {
	pc = 0x830BD440; continue 'dispatch;
	}
	// 830BD438: 4BFF7849  bl 0x830b4c80
	ctx.lr = 0x830BD43C;
	sub_830B4C80(ctx, base);
	// 830BD43C: 93DF008C  stw r30, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[30].u32 ) };
	// 830BD440: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830BD444: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830BD448: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830BD44C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830BD450: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830BD454: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BD458(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BD458 size=88
    let mut pc: u32 = 0x830BD458;
    'dispatch: loop {
        match pc {
            0x830BD458 => {
    //   block [0x830BD458..0x830BD4B0)
	// 830BD458: 8163007C  lwz r11, 0x7c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(124 as u32) ) } as u64;
	// 830BD45C: 81430080  lwz r10, 0x80(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) } as u64;
	// 830BD460: 556B0314  rlwinm r11, r11, 0, 0xc, 0xa
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830BD464: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830BD468: 9163007C  stw r11, 0x7c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 830BD46C: 419A0020  beq cr6, 0x830bd48c
	if ctx.cr[6].eq {
	pc = 0x830BD48C; continue 'dispatch;
	}
	// 830BD470: 80630080  lwz r3, 0x80(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) } as u64;
	// 830BD474: 8163007C  lwz r11, 0x7c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(124 as u32) ) } as u64;
	// 830BD478: 556B0314  rlwinm r11, r11, 0, 0xc, 0xa
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830BD47C: 9163007C  stw r11, 0x7c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 830BD480: 81630080  lwz r11, 0x80(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) } as u64;
	// 830BD484: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830BD488: 409AFFE8  bne cr6, 0x830bd470
	if !ctx.cr[6].eq {
	pc = 0x830BD470; continue 'dispatch;
	}
	// 830BD48C: 81430084  lwz r10, 0x84(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(132 as u32) ) } as u64;
	// 830BD490: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830BD494: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 830BD498: 810A000C  lwz r8, 0xc(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 830BD49C: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830BD4A0: 91680008  stw r11, 8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830BD4A4: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 830BD4A8: 912B0038  stw r9, 0x38(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), ctx.r[9].u32 ) };
	// 830BD4AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BD4B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830BD4B0 size=172
    let mut pc: u32 = 0x830BD4B0;
    'dispatch: loop {
        match pc {
            0x830BD4B0 => {
    //   block [0x830BD4B0..0x830BD55C)
	// 830BD4B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BD4B4: 480EACAD  bl 0x831a8160
	ctx.lr = 0x830BD4B8;
	sub_831A8130(ctx, base);
	// 830BD4B8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BD4BC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 830BD4C0: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 830BD4C4: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 830BD4C8: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 830BD4CC: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BD4D0: 5488103A  slwi r8, r4, 2
	ctx.r[8].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 830BD4D4: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BD4D8: 1D640144  mulli r11, r4, 0x144
	ctx.r[11].s64 = ctx.r[4].s64 * 324;
	// 830BD4DC: 7D28482E  lwzx r9, r8, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 830BD4E0: 7FCB5214  add r30, r11, r10
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830BD4E4: 81690034  lwz r11, 0x34(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(52 as u32) ) } as u64;
	// 830BD4E8: 556A056B  rlwinm. r10, r11, 0, 0x15, 0x15
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830BD4EC: 41820014  beq 0x830bd500
	if ctx.cr[0].eq {
	pc = 0x830BD500; continue 'dispatch;
	}
	// 830BD4F0: 556A0529  rlwinm. r10, r11, 0, 0x14, 0x14
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830BD4F4: 4182000C  beq 0x830bd500
	if ctx.cr[0].eq {
	pc = 0x830BD500; continue 'dispatch;
	}
	// 830BD4F8: 556B07BD  rlwinm. r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BD4FC: 40820008  bne 0x830bd504
	if !ctx.cr[0].eq {
	pc = 0x830BD504; continue 'dispatch;
	}
	// 830BD500: 935E0018  stw r26, 0x18(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), ctx.r[26].u32 ) };
	// 830BD504: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830BD508: 549D1838  slwi r29, r4, 3
	ctx.r[29].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 830BD50C: 7C9D582E  lwzx r4, r29, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830BD510: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 830BD514: 41980014  blt cr6, 0x830bd528
	if ctx.cr[6].lt {
	pc = 0x830BD528; continue 'dispatch;
	}
	// 830BD518: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 830BD51C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830BD520: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830BD524: 4BFFFF8D  bl 0x830bd4b0
	ctx.lr = 0x830BD528;
	sub_830BD4B0(ctx, base);
	// 830BD528: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 830BD52C: 419A0014  beq cr6, 0x830bd540
	if ctx.cr[6].eq {
	pc = 0x830BD540; continue 'dispatch;
	}
	// 830BD530: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 830BD534: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830BD538: 419A0008  beq cr6, 0x830bd540
	if ctx.cr[6].eq {
	pc = 0x830BD540; continue 'dispatch;
	}
	// 830BD53C: 935B0018  stw r26, 0x18(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(24 as u32), ctx.r[26].u32 ) };
	// 830BD540: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830BD544: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 830BD548: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BD54C: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 830BD550: 4098FF7C  bge cr6, 0x830bd4cc
	if !ctx.cr[6].lt {
	pc = 0x830BD4CC; continue 'dispatch;
	}
	// 830BD554: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830BD558: 480EAC58  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BD560(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BD560 size=28
    let mut pc: u32 = 0x830BD560;
    'dispatch: loop {
        match pc {
            0x830BD560 => {
    //   block [0x830BD560..0x830BD57C)
	// 830BD560: 3D408339  lis r10, -0x7cc7
	ctx.r[10].s64 = -2093416448;
	// 830BD564: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830BD568: 392ABD6C  addi r9, r10, -0x4294
	ctx.r[9].s64 = ctx.r[10].s64 + -17044;
	// 830BD56C: 906ABD6C  stw r3, -0x4294(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-17044 as u32), ctx.r[3].u32 ) };
	// 830BD570: 90890004  stw r4, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 830BD574: 91690008  stw r11, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830BD578: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BD580(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BD580 size=16
    let mut pc: u32 = 0x830BD580;
    'dispatch: loop {
        match pc {
            0x830BD580 => {
    //   block [0x830BD580..0x830BD590)
	// 830BD580: 3D408339  lis r10, -0x7cc7
	ctx.r[10].s64 = -2093416448;
	// 830BD584: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830BD588: 916ABD6C  stw r11, -0x4294(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-17044 as u32), ctx.r[11].u32 ) };
	// 830BD58C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BD590(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BD590 size=24
    let mut pc: u32 = 0x830BD590;
    'dispatch: loop {
        match pc {
            0x830BD590 => {
    //   block [0x830BD590..0x830BD5A8)
	// 830BD590: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BD594: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830BD598: 41980018  blt cr6, 0x830bd5b0
	if ctx.cr[6].lt {
		sub_830BD5B0(ctx, base);
		return;
	}
	// 830BD59C: 419A0010  beq cr6, 0x830bd5ac
	if ctx.cr[6].eq {
		sub_830BD5AC(ctx, base);
		return;
	}
	// 830BD5A0: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 830BD5A4: 4C980020  bgelr cr6
	if !ctx.cr[6].lt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BD5A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BD5A8 size=4
    let mut pc: u32 = 0x830BD5A8;
    'dispatch: loop {
        match pc {
            0x830BD5A8 => {
    //   block [0x830BD5A8..0x830BD5AC)
	// 830BD5A8: 4BFFF898  b 0x830bce40
	sub_830BCE40(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BD5AC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BD5AC size=4
    let mut pc: u32 = 0x830BD5AC;
    'dispatch: loop {
        match pc {
            0x830BD5AC => {
    //   block [0x830BD5AC..0x830BD5B0)
	// 830BD5AC: 4BFFF7B4  b 0x830bcd60
	sub_830BCD60(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BD5B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BD5B0 size=8
    let mut pc: u32 = 0x830BD5B0;
    'dispatch: loop {
        match pc {
            0x830BD5B0 => {
    //   block [0x830BD5B0..0x830BD5B8)
	// 830BD5B0: 4BFFF7B0  b 0x830bcd60
	sub_830BCD60(ctx, base);
	return;
	// 830BD5B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BD5B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BD5B8 size=24
    let mut pc: u32 = 0x830BD5B8;
    'dispatch: loop {
        match pc {
            0x830BD5B8 => {
    //   block [0x830BD5B8..0x830BD5D0)
	// 830BD5B8: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 830BD5BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830BD5C0: 419A0010  beq cr6, 0x830bd5d0
	if ctx.cr[6].eq {
		sub_830BD5D0(ctx, base);
		return;
	}
	// 830BD5C4: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 830BD5C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830BD5CC: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BD5D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BD5D0 size=56
    let mut pc: u32 = 0x830BD5D0;
    'dispatch: loop {
        match pc {
            0x830BD5D0 => {
    //   block [0x830BD5D0..0x830BD608)
	// 830BD5D0: 3D208339  lis r9, -0x7cc7
	ctx.r[9].s64 = -2093416448;
	// 830BD5D4: 3909BD6C  addi r8, r9, -0x4294
	ctx.r[8].s64 = ctx.r[9].s64 + -17044;
	// 830BD5D8: 8169BD6C  lwz r11, -0x4294(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-17044 as u32) ) } as u64;
	// 830BD5DC: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 830BD5E0: 81480008  lwz r10, 8(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 830BD5E4: 396B0018  addi r11, r11, 0x18
	ctx.r[11].s64 = ctx.r[11].s64 + 24;
	// 830BD5E8: 90E30018  stw r7, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[7].u32 ) };
	// 830BD5EC: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 830BD5F0: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 830BD5F4: 396B0018  addi r11, r11, 0x18
	ctx.r[11].s64 = ctx.r[11].s64 + 24;
	// 830BD5F8: 91480008  stw r10, 8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830BD5FC: 90E3001C  stw r7, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[7].u32 ) };
	// 830BD600: 9169BD6C  stw r11, -0x4294(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(-17044 as u32), ctx.r[11].u32 ) };
	// 830BD604: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BD608(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830BD608 size=156
    let mut pc: u32 = 0x830BD608;
    'dispatch: loop {
        match pc {
            0x830BD608 => {
    //   block [0x830BD608..0x830BD6A4)
	// 830BD608: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BD60C: 480EAB59  bl 0x831a8164
	ctx.lr = 0x830BD610;
	sub_831A8130(ctx, base);
	// 830BD610: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BD614: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830BD618: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 830BD61C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BD620: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BD624: 40990060  ble cr6, 0x830bd684
	if !ctx.cr[6].gt {
	pc = 0x830BD684; continue 'dispatch;
	}
	// 830BD628: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830BD62C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BD630: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830BD634: 7D7E582E  lwzx r11, r30, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830BD638: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BD63C: 40990034  ble cr6, 0x830bd670
	if !ctx.cr[6].gt {
	pc = 0x830BD670; continue 'dispatch;
	}
	// 830BD640: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 830BD644: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BD648: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 830BD64C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BD650: 7C6BE214  add r3, r11, r28
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 830BD654: 4BFFFD95  bl 0x830bd3e8
	ctx.lr = 0x830BD658;
	sub_830BD3E8(ctx, base);
	// 830BD658: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BD65C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 830BD660: 3B9C0144  addi r28, r28, 0x144
	ctx.r[28].s64 = ctx.r[28].s64 + 324;
	// 830BD664: 7D7E582E  lwzx r11, r30, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830BD668: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830BD66C: 4198FFD8  blt cr6, 0x830bd644
	if ctx.cr[6].lt {
	pc = 0x830BD644; continue 'dispatch;
	}
	// 830BD670: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BD674: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 830BD678: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 830BD67C: 7F1B5800  cmpw cr6, r27, r11
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830BD680: 4198FFAC  blt cr6, 0x830bd62c
	if ctx.cr[6].lt {
	pc = 0x830BD62C; continue 'dispatch;
	}
	// 830BD684: 807F0044  lwz r3, 0x44(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 830BD688: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830BD68C: 419A0010  beq cr6, 0x830bd69c
	if ctx.cr[6].eq {
	pc = 0x830BD69C; continue 'dispatch;
	}
	// 830BD690: 4BFF75F1  bl 0x830b4c80
	ctx.lr = 0x830BD694;
	sub_830B4C80(ctx, base);
	// 830BD694: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830BD698: 917F0044  stw r11, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[11].u32 ) };
	// 830BD69C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830BD6A0: 480EAB14  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BD6A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830BD6A8 size=284
    let mut pc: u32 = 0x830BD6A8;
    'dispatch: loop {
        match pc {
            0x830BD6A8 => {
    //   block [0x830BD6A8..0x830BD7C4)
	// 830BD6A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BD6AC: 480EAAAD  bl 0x831a8158
	ctx.lr = 0x830BD6B0;
	sub_831A8130(ctx, base);
	// 830BD6B0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BD6B4: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 830BD6B8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830BD6BC: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 830BD6C0: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 830BD6C4: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 830BD6C8: 7D194378  mr r25, r8
	ctx.r[25].u64 = ctx.r[8].u64;
	// 830BD6CC: 813C0004  lwz r9, 4(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BD6D0: 57A8103A  slwi r8, r29, 2
	ctx.r[8].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 830BD6D4: 815A0004  lwz r10, 4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BD6D8: 1D7D0144  mulli r11, r29, 0x144
	ctx.r[11].s64 = ctx.r[29].s64 * 324;
	// 830BD6DC: 7FE8482E  lwzx r31, r8, r9
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 830BD6E0: 7FCB5214  add r30, r11, r10
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830BD6E4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BD6E8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830BD6EC: 41980028  blt cr6, 0x830bd714
	if ctx.cr[6].lt {
	pc = 0x830BD714; continue 'dispatch;
	}
	// 830BD6F0: 419A0024  beq cr6, 0x830bd714
	if ctx.cr[6].eq {
	pc = 0x830BD714; continue 'dispatch;
	}
	// 830BD6F4: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 830BD6F8: 4098002C  bge cr6, 0x830bd724
	if !ctx.cr[6].lt {
	pc = 0x830BD724; continue 'dispatch;
	}
	// 830BD6FC: 7F26CB78  mr r6, r25
	ctx.r[6].u64 = ctx.r[25].u64;
	// 830BD700: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 830BD704: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830BD708: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830BD70C: 4BFFF735  bl 0x830bce40
	ctx.lr = 0x830BD710;
	sub_830BCE40(ctx, base);
	// 830BD710: 48000014  b 0x830bd724
	pc = 0x830BD724; continue 'dispatch;
	// 830BD714: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 830BD718: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830BD71C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830BD720: 4BFFF641  bl 0x830bcd60
	ctx.lr = 0x830BD724;
	sub_830BCD60(ctx, base);
	// 830BD724: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 830BD728: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830BD72C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830BD730: 4BFFFBF1  bl 0x830bd320
	ctx.lr = 0x830BD734;
	sub_830BD320(ctx, base);
	// 830BD734: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 830BD738: 556A056B  rlwinm. r10, r11, 0, 0x15, 0x15
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830BD73C: 41820014  beq 0x830bd750
	if ctx.cr[0].eq {
	pc = 0x830BD750; continue 'dispatch;
	}
	// 830BD740: 556A0529  rlwinm. r10, r11, 0, 0x14, 0x14
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830BD744: 4182000C  beq 0x830bd750
	if ctx.cr[0].eq {
	pc = 0x830BD750; continue 'dispatch;
	}
	// 830BD748: 556B07BD  rlwinm. r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BD74C: 4082000C  bne 0x830bd758
	if !ctx.cr[0].eq {
	pc = 0x830BD758; continue 'dispatch;
	}
	// 830BD750: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830BD754: 4BFFFE65  bl 0x830bd5b8
	ctx.lr = 0x830BD758;
	sub_830BD5B8(ctx, base);
	// 830BD758: 817C000C  lwz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 830BD75C: 57BF1838  slwi r31, r29, 3
	ctx.r[31].u32 = ctx.r[29].u32.wrapping_shl(3);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 830BD760: 7C8BF82E  lwzx r4, r11, r31
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 830BD764: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 830BD768: 4198001C  blt cr6, 0x830bd784
	if ctx.cr[6].lt {
	pc = 0x830BD784; continue 'dispatch;
	}
	// 830BD76C: 7F28CB78  mr r8, r25
	ctx.r[8].u64 = ctx.r[25].u64;
	// 830BD770: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 830BD774: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 830BD778: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 830BD77C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830BD780: 4BFFFF29  bl 0x830bd6a8
	ctx.lr = 0x830BD784;
	sub_830BD6A8(ctx, base);
	// 830BD784: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 830BD788: 419A0018  beq cr6, 0x830bd7a0
	if ctx.cr[6].eq {
	pc = 0x830BD7A0; continue 'dispatch;
	}
	// 830BD78C: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 830BD790: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830BD794: 419A000C  beq cr6, 0x830bd7a0
	if ctx.cr[6].eq {
	pc = 0x830BD7A0; continue 'dispatch;
	}
	// 830BD798: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 830BD79C: 4BFFFE1D  bl 0x830bd5b8
	ctx.lr = 0x830BD7A0;
	sub_830BD5B8(ctx, base);
	// 830BD7A0: 817C000C  lwz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 830BD7A4: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 830BD7A8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BD7AC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BD7B0: 4198000C  blt cr6, 0x830bd7bc
	if ctx.cr[6].lt {
	pc = 0x830BD7BC; continue 'dispatch;
	}
	// 830BD7B4: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 830BD7B8: 4BFFFF14  b 0x830bd6cc
	pc = 0x830BD6CC; continue 'dispatch;
	// 830BD7BC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830BD7C0: 480EA9E8  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BD7C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830BD7C8 size=444
    let mut pc: u32 = 0x830BD7C8;
    'dispatch: loop {
        match pc {
            0x830BD7C8 => {
    //   block [0x830BD7C8..0x830BD984)
	// 830BD7C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BD7CC: 480EA99D  bl 0x831a8168
	ctx.lr = 0x830BD7D0;
	sub_831A8130(ctx, base);
	// 830BD7D0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BD7D4: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 830BD7D8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830BD7DC: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 830BD7E0: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 830BD7E4: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BD7E8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BD7EC: 40990074  ble cr6, 0x830bd860
	if !ctx.cr[6].gt {
	pc = 0x830BD860; continue 'dispatch;
	}
	// 830BD7F0: 81070004  lwz r8, 4(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BD7F4: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 830BD7F8: 7D4B402E  lwzx r10, r11, r8
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 830BD7FC: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 830BD800: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830BD804: 40990048  ble cr6, 0x830bd84c
	if !ctx.cr[6].gt {
	pc = 0x830BD84C; continue 'dispatch;
	}
	// 830BD808: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 830BD80C: 81070004  lwz r8, 4(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BD810: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 830BD814: 7D0B4214  add r8, r11, r8
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 830BD818: 81080004  lwz r8, 4(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BD81C: 7D085214  add r8, r8, r10
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 830BD820: 93C8001C  stw r30, 0x1c(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 830BD824: 81070004  lwz r8, 4(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BD828: 7D0B4214  add r8, r11, r8
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 830BD82C: 81080004  lwz r8, 4(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BD830: 7D085214  add r8, r8, r10
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 830BD834: 93C80018  stw r30, 0x18(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 830BD838: 394A0144  addi r10, r10, 0x144
	ctx.r[10].s64 = ctx.r[10].s64 + 324;
	// 830BD83C: 81070004  lwz r8, 4(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BD840: 7CAB402E  lwzx r5, r11, r8
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 830BD844: 7F092800  cmpw cr6, r9, r5
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[5].s32, &mut ctx.xer);
	// 830BD848: 4198FFC4  blt cr6, 0x830bd80c
	if ctx.cr[6].lt {
	pc = 0x830BD80C; continue 'dispatch;
	}
	// 830BD84C: 81470000  lwz r10, 0(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BD850: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 830BD854: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 830BD858: 7F065000  cmpw cr6, r6, r10
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830BD85C: 4198FF9C  blt cr6, 0x830bd7f8
	if ctx.cr[6].lt {
	pc = 0x830BD7F8; continue 'dispatch;
	}
	// 830BD860: 817C0024  lwz r11, 0x24(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(36 as u32) ) } as u64;
	// 830BD864: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 830BD868: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BD86C: 40990040  ble cr6, 0x830bd8ac
	if !ctx.cr[6].gt {
	pc = 0x830BD8AC; continue 'dispatch;
	}
	// 830BD870: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 830BD874: 817C0028  lwz r11, 0x28(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(40 as u32) ) } as u64;
	// 830BD878: 7CBF5A14  add r5, r31, r11
	ctx.r[5].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 830BD87C: 80850008  lwz r4, 8(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 830BD880: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 830BD884: 41980014  blt cr6, 0x830bd898
	if ctx.cr[6].lt {
	pc = 0x830BD898; continue 'dispatch;
	}
	// 830BD888: 81670004  lwz r11, 4(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BD88C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830BD890: 7C6BFA14  add r3, r11, r31
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 830BD894: 4BFFFC1D  bl 0x830bd4b0
	ctx.lr = 0x830BD898;
	sub_830BD4B0(ctx, base);
	// 830BD898: 817C0024  lwz r11, 0x24(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(36 as u32) ) } as u64;
	// 830BD89C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 830BD8A0: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 830BD8A4: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830BD8A8: 4198FFCC  blt cr6, 0x830bd874
	if ctx.cr[6].lt {
	pc = 0x830BD874; continue 'dispatch;
	}
	// 830BD8AC: 81070000  lwz r8, 0(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BD8B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830BD8B4: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 830BD8B8: 40990048  ble cr6, 0x830bd900
	if !ctx.cr[6].gt {
	pc = 0x830BD900; continue 'dispatch;
	}
	// 830BD8BC: 81670004  lwz r11, 4(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BD8C0: 7D064378  mr r6, r8
	ctx.r[6].u64 = ctx.r[8].u64;
	// 830BD8C4: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BD8C8: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830BD8CC: 40990028  ble cr6, 0x830bd8f4
	if !ctx.cr[6].gt {
	pc = 0x830BD8F4; continue 'dispatch;
	}
	// 830BD8D0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BD8D4: 394A0018  addi r10, r10, 0x18
	ctx.r[10].s64 = ctx.r[10].s64 + 24;
	// 830BD8D8: 80AA0000  lwz r5, 0(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BD8DC: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 830BD8E0: 419A0008  beq cr6, 0x830bd8e8
	if ctx.cr[6].eq {
	pc = 0x830BD8E8; continue 'dispatch;
	}
	// 830BD8E4: 38630002  addi r3, r3, 2
	ctx.r[3].s64 = ctx.r[3].s64 + 2;
	// 830BD8E8: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830BD8EC: 394A0144  addi r10, r10, 0x144
	ctx.r[10].s64 = ctx.r[10].s64 + 324;
	// 830BD8F0: 4082FFE8  bne 0x830bd8d8
	if !ctx.cr[0].eq {
	pc = 0x830BD8D8; continue 'dispatch;
	}
	// 830BD8F4: 34C6FFFF  addic. r6, r6, -1
	ctx.xer.ca = (ctx.r[6].u32 > (!(-1 as u32)));
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 830BD8F8: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 830BD8FC: 4082FFC8  bne 0x830bd8c4
	if !ctx.cr[0].eq {
	pc = 0x830BD8C4; continue 'dispatch;
	}
	// 830BD900: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 830BD904: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 830BD908: 40990074  ble cr6, 0x830bd97c
	if !ctx.cr[6].gt {
	pc = 0x830BD97C; continue 'dispatch;
	}
	// 830BD90C: 81070004  lwz r8, 4(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BD910: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 830BD914: 7D4B402E  lwzx r10, r11, r8
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 830BD918: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 830BD91C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830BD920: 40990048  ble cr6, 0x830bd968
	if !ctx.cr[6].gt {
	pc = 0x830BD968; continue 'dispatch;
	}
	// 830BD924: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 830BD928: 81070004  lwz r8, 4(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BD92C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 830BD930: 7D0B4214  add r8, r11, r8
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 830BD934: 81080004  lwz r8, 4(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BD938: 7D085214  add r8, r8, r10
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 830BD93C: 93C8001C  stw r30, 0x1c(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 830BD940: 81070004  lwz r8, 4(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BD944: 7D0B4214  add r8, r11, r8
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 830BD948: 81080004  lwz r8, 4(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BD94C: 7D085214  add r8, r8, r10
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 830BD950: 93C80018  stw r30, 0x18(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 830BD954: 394A0144  addi r10, r10, 0x144
	ctx.r[10].s64 = ctx.r[10].s64 + 324;
	// 830BD958: 81070004  lwz r8, 4(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BD95C: 7CAB402E  lwzx r5, r11, r8
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 830BD960: 7F092800  cmpw cr6, r9, r5
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[5].s32, &mut ctx.xer);
	// 830BD964: 4198FFC4  blt cr6, 0x830bd928
	if ctx.cr[6].lt {
	pc = 0x830BD928; continue 'dispatch;
	}
	// 830BD968: 81470000  lwz r10, 0(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BD96C: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 830BD970: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 830BD974: 7F065000  cmpw cr6, r6, r10
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830BD978: 4198FF9C  blt cr6, 0x830bd914
	if ctx.cr[6].lt {
	pc = 0x830BD914; continue 'dispatch;
	}
	// 830BD97C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830BD980: 480EA838  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BD988(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830BD988 size=200
    let mut pc: u32 = 0x830BD988;
    'dispatch: loop {
        match pc {
            0x830BD988 => {
    //   block [0x830BD988..0x830BDA50)
	// 830BD988: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BD98C: 480EA7D9  bl 0x831a8164
	ctx.lr = 0x830BD990;
	sub_831A8130(ctx, base);
	// 830BD990: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BD994: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830BD998: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830BD99C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 830BD9A0: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 830BD9A4: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 830BD9A8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BD9AC: 40990048  ble cr6, 0x830bd9f4
	if !ctx.cr[6].gt {
	pc = 0x830BD9F4; continue 'dispatch;
	}
	// 830BD9B0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830BD9B4: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 830BD9B8: 7CABF214  add r5, r11, r30
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 830BD9BC: 80850008  lwz r4, 8(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 830BD9C0: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 830BD9C4: 4198001C  blt cr6, 0x830bd9e0
	if ctx.cr[6].lt {
	pc = 0x830BD9E0; continue 'dispatch;
	}
	// 830BD9C8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BD9CC: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 830BD9D0: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 830BD9D4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830BD9D8: 7C6BF214  add r3, r11, r30
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 830BD9DC: 4BFFFCCD  bl 0x830bd6a8
	ctx.lr = 0x830BD9E0;
	sub_830BD6A8(ctx, base);
	// 830BD9E0: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 830BD9E4: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 830BD9E8: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 830BD9EC: 7F1B5800  cmpw cr6, r27, r11
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830BD9F0: 4198FFC4  blt cr6, 0x830bd9b4
	if ctx.cr[6].lt {
	pc = 0x830BD9B4; continue 'dispatch;
	}
	// 830BD9F4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 830BD9F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830BD9FC: 4BFFA89D  bl 0x830b8298
	ctx.lr = 0x830BDA00;
	sub_830B8298(ctx, base);
	// 830BDA00: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BDA04: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830BDA08: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 830BDA0C: D01D0018  stfs f0, 0x18(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 830BDA10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830BDA14: D1BD001C  stfs f13, 0x1c(r29)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 830BDA18: 4BFFA8A1  bl 0x830b82b8
	ctx.lr = 0x830BDA1C;
	sub_830B82B8(ctx, base);
	// 830BDA1C: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BDA20: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830BDA24: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 830BDA28: D01D0020  stfs f0, 0x20(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 830BDA2C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 830BDA30: D1BD0024  stfs f13, 0x24(r29)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 830BDA34: 4BFFA9B5  bl 0x830b83e8
	ctx.lr = 0x830BDA38;
	sub_830B83E8(ctx, base);
	// 830BDA38: C0010058  lfs f0, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BDA3C: C1A1005C  lfs f13, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830BDA40: D01D0028  stfs f0, 0x28(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 830BDA44: D1BD002C  stfs f13, 0x2c(r29)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 830BDA48: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830BDA4C: 480EA768  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BDA50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830BDA50 size=408
    let mut pc: u32 = 0x830BDA50;
    'dispatch: loop {
        match pc {
            0x830BDA50 => {
    //   block [0x830BDA50..0x830BDBE8)
	// 830BDA50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BDA54: 480EA701  bl 0x831a8154
	ctx.lr = 0x830BDA58;
	sub_831A8130(ctx, base);
	// 830BDA58: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BDA5C: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 830BDA60: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830BDA64: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 830BDA68: 395F0048  addi r10, r31, 0x48
	ctx.r[10].s64 = ctx.r[31].s64 + 72;
	// 830BDA6C: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 830BDA70: 817B0024  lwz r11, 0x24(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(36 as u32) ) } as u64;
	// 830BDA74: 7F3ACB78  mr r26, r25
	ctx.r[26].u64 = ctx.r[25].u64;
	// 830BDA78: 7F38CB78  mr r24, r25
	ctx.r[24].u64 = ctx.r[25].u64;
	// 830BDA7C: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 830BDA80: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830BDA84: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830BDA88: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BDA8C: 409900CC  ble cr6, 0x830bdb58
	if !ctx.cr[6].gt {
	pc = 0x830BDB58; continue 'dispatch;
	}
	// 830BDA90: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 830BDA94: 815B0028  lwz r10, 0x28(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(40 as u32) ) } as u64;
	// 830BDA98: 1D7A0144  mulli r11, r26, 0x144
	ctx.r[11].s64 = ctx.r[26].s64 * 324;
	// 830BDA9C: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BDAA0: 7D4AF02E  lwzx r10, r10, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 830BDAA4: 7F3CCB78  mr r28, r25
	ctx.r[28].u64 = ctx.r[25].u64;
	// 830BDAA8: 7D5E492E  stwx r10, r30, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[30].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u32) };
	// 830BDAAC: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BDAB0: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BDAB4: 554A2036  slwi r10, r10, 4
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830BDAB8: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 830BDABC: 7D5E4A14  add r10, r30, r9
	ctx.r[10].u64 = ctx.r[30].u64 + ctx.r[9].u64;
	// 830BDAC0: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 830BDAC4: 396B0048  addi r11, r11, 0x48
	ctx.r[11].s64 = ctx.r[11].s64 + 72;
	// 830BDAC8: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830BDACC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BDAD0: 7D7E582E  lwzx r11, r30, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830BDAD4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BDAD8: 40990048  ble cr6, 0x830bdb20
	if !ctx.cr[6].gt {
	pc = 0x830BDB20; continue 'dispatch;
	}
	// 830BDADC: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 830BDAE0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BDAE4: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 830BDAE8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BDAEC: 7C6BEA14  add r3, r11, r29
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 830BDAF0: 4BFFDC39  bl 0x830bb728
	ctx.lr = 0x830BDAF4;
	sub_830BB728(ctx, base);
	// 830BDAF4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BDAF8: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 830BDAFC: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 830BDB00: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BDB04: 7D4AEA14  add r10, r10, r29
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[29].u64;
	// 830BDB08: 3BBD0144  addi r29, r29, 0x144
	ctx.r[29].s64 = ctx.r[29].s64 + 324;
	// 830BDB0C: 916A0084  stw r11, 0x84(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 830BDB10: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BDB14: 7D7E582E  lwzx r11, r30, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830BDB18: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830BDB1C: 4198FFC4  blt cr6, 0x830bdae0
	if ctx.cr[6].lt {
	pc = 0x830BDAE0; continue 'dispatch;
	}
	// 830BDB20: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BDB24: 3B180001  addi r24, r24, 1
	ctx.r[24].s64 = ctx.r[24].s64 + 1;
	// 830BDB28: 815B0028  lwz r10, 0x28(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(40 as u32) ) } as u64;
	// 830BDB2C: 7D3E5A14  add r9, r30, r11
	ctx.r[9].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 830BDB30: 7D6AF02E  lwzx r11, r10, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 830BDB34: 93290008  stw r25, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[25].u32 ) };
	// 830BDB38: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BDB3C: 7D5E5214  add r10, r30, r10
	ctx.r[10].u64 = ctx.r[30].u64 + ctx.r[10].u64;
	// 830BDB40: 93EA000C  stw r31, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 830BDB44: 7F4BD214  add r26, r11, r26
	ctx.r[26].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 830BDB48: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BDB4C: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 830BDB50: 7F185800  cmpw cr6, r24, r11
	ctx.cr[6].compare_i32(ctx.r[24].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830BDB54: 4198FF40  blt cr6, 0x830bda94
	if ctx.cr[6].lt {
	pc = 0x830BDA94; continue 'dispatch;
	}
	// 830BDB58: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 830BDB5C: 933F0008  stw r25, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[25].u32 ) };
	// 830BDB60: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 830BDB64: 933F0014  stw r25, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[25].u32 ) };
	// 830BDB68: 933F0038  stw r25, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[25].u32 ) };
	// 830BDB6C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830BDB70: 933F003C  stw r25, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[25].u32 ) };
	// 830BDB74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BDB78: 933F0044  stw r25, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[25].u32 ) };
	// 830BDB7C: C00B9534  lfs f0, -0x6acc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BDB80: C1AA08A8  lfs f13, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830BDB84: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830BDB88: D1BF0010  stfs f13, 0x10(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 830BDB8C: 4BFFFC3D  bl 0x830bd7c8
	ctx.lr = 0x830BDB90;
	sub_830BD7C8(ctx, base);
	// 830BDB90: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830BDB94: 4081001C  ble 0x830bdbb0
	if !ctx.cr[0].gt {
	pc = 0x830BDBB0; continue 'dispatch;
	}
	// 830BDB98: 3D608218  lis r11, -0x7de8
	ctx.r[11].s64 = -2112356352;
	// 830BDB9C: 38A000F1  li r5, 0xf1
	ctx.r[5].s64 = 241;
	// 830BDBA0: 388B7734  addi r4, r11, 0x7734
	ctx.r[4].s64 = ctx.r[11].s64 + 30516;
	// 830BDBA4: 1C7E0018  mulli r3, r30, 0x18
	ctx.r[3].s64 = ctx.r[30].s64 * 24;
	// 830BDBA8: 4BFF70B1  bl 0x830b4c58
	ctx.lr = 0x830BDBAC;
	sub_830B4C58(ctx, base);
	// 830BDBAC: 907F0044  stw r3, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[3].u32 ) };
	// 830BDBB0: 3FA08339  lis r29, -0x7cc7
	ctx.r[29].s64 = -2093416448;
	// 830BDBB4: 817F0044  lwz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 830BDBB8: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	// 830BDBBC: 393DBD6C  addi r9, r29, -0x4294
	ctx.r[9].s64 = ctx.r[29].s64 + -17044;
	// 830BDBC0: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 830BDBC4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830BDBC8: 917DBD6C  stw r11, -0x4294(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(-17044 as u32), ctx.r[11].u32 ) };
	// 830BDBCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BDBD0: 93C90004  stw r30, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 830BDBD4: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830BDBD8: 4BFFFDB1  bl 0x830bd988
	ctx.lr = 0x830BDBDC;
	sub_830BD988(ctx, base);
	// 830BDBDC: 933DBD6C  stw r25, -0x4294(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(-17044 as u32), ctx.r[25].u32 ) };
	// 830BDBE0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830BDBE4: 480EA5C0  b 0x831a81a4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BDBE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830BDBE8 size=176
    let mut pc: u32 = 0x830BDBE8;
    'dispatch: loop {
        match pc {
            0x830BDBE8 => {
    //   block [0x830BDBE8..0x830BDC98)
	// 830BDBE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BDBEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830BDBF0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830BDBF4: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 830BDBF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BDBFC: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 830BDC00: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830BDC04: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830BDC08: 41980070  blt cr6, 0x830bdc78
	if ctx.cr[6].lt {
	pc = 0x830BDC78; continue 'dispatch;
	}
	// 830BDC0C: 419A003C  beq cr6, 0x830bdc48
	if ctx.cr[6].eq {
	pc = 0x830BDC48; continue 'dispatch;
	}
	// 830BDC10: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 830BDC14: 41980014  blt cr6, 0x830bdc28
	if ctx.cr[6].lt {
	pc = 0x830BDC28; continue 'dispatch;
	}
	// 830BDC18: 409A0068  bne cr6, 0x830bdc80
	if !ctx.cr[6].eq {
	pc = 0x830BDC80; continue 'dispatch;
	}
	// 830BDC1C: 807F00D8  lwz r3, 0xd8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(216 as u32) ) } as u64;
	// 830BDC20: 4BFF8529  bl 0x830b6148
	ctx.lr = 0x830BDC24;
	sub_830B6148(ctx, base);
	// 830BDC24: 4800005C  b 0x830bdc80
	pc = 0x830BDC80; continue 'dispatch;
	// 830BDC28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BDC2C: 4BFF44E5  bl 0x830b2110
	ctx.lr = 0x830BDC30;
	sub_830B2110(ctx, base);
	// 830BDC30: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 830BDC34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BDC38: C00B9534  lfs f0, -0x6acc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BDC3C: EC210032  fmuls f1, f1, f0
	ctx.f[1].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 830BDC40: 4BFF44C9  bl 0x830b2108
	ctx.lr = 0x830BDC44;
	sub_830B2108(ctx, base);
	// 830BDC44: 4800003C  b 0x830bdc80
	pc = 0x830BDC80; continue 'dispatch;
	// 830BDC48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BDC4C: 4BFF44F5  bl 0x830b2140
	ctx.lr = 0x830BDC50;
	sub_830B2140(ctx, base);
	// 830BDC50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BDC54: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 830BDC58: 4BFF4509  bl 0x830b2160
	ctx.lr = 0x830BDC5C;
	sub_830B2160(ctx, base);
	// 830BDC5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BDC60: EFFF0828  fsubs f31, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = (((ctx.f[31].f64 - ctx.f[1].f64) as f32) as f64);
	// 830BDC64: 4BFF44ED  bl 0x830b2150
	ctx.lr = 0x830BDC68;
	sub_830B2150(ctx, base);
	// 830BDC68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BDC6C: EC21F82A  fadds f1, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ((ctx.f[1].f64 + ctx.f[31].f64) as f32) as f64;
	// 830BDC70: 4BFF44C1  bl 0x830b2130
	ctx.lr = 0x830BDC74;
	sub_830B2130(ctx, base);
	// 830BDC74: 4800000C  b 0x830bdc80
	pc = 0x830BDC80; continue 'dispatch;
	// 830BDC78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BDC7C: 4BFF44ED  bl 0x830b2168
	ctx.lr = 0x830BDC80;
	sub_830B2168(ctx, base);
	// 830BDC80: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830BDC84: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830BDC88: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830BDC8C: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830BDC90: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830BDC94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BDC98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830BDC98 size=188
    let mut pc: u32 = 0x830BDC98;
    'dispatch: loop {
        match pc {
            0x830BDC98 => {
    //   block [0x830BDC98..0x830BDD54)
	// 830BDC98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BDC9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830BDCA0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830BDCA4: DBC1FFE0  stfd f30, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[30].u64 ) };
	// 830BDCA8: DBE1FFE8  stfd f31, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 830BDCAC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BDCB0: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 830BDCB4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830BDCB8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830BDCBC: 41980074  blt cr6, 0x830bdd30
	if ctx.cr[6].lt {
	pc = 0x830BDD30; continue 'dispatch;
	}
	// 830BDCC0: 419A003C  beq cr6, 0x830bdcfc
	if ctx.cr[6].eq {
	pc = 0x830BDCFC; continue 'dispatch;
	}
	// 830BDCC4: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 830BDCC8: 41980014  blt cr6, 0x830bdcdc
	if ctx.cr[6].lt {
	pc = 0x830BDCDC; continue 'dispatch;
	}
	// 830BDCCC: 409A006C  bne cr6, 0x830bdd38
	if !ctx.cr[6].eq {
	pc = 0x830BDD38; continue 'dispatch;
	}
	// 830BDCD0: 807F00D8  lwz r3, 0xd8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(216 as u32) ) } as u64;
	// 830BDCD4: 4BFF8475  bl 0x830b6148
	ctx.lr = 0x830BDCD8;
	sub_830B6148(ctx, base);
	// 830BDCD8: 48000060  b 0x830bdd38
	pc = 0x830BDD38; continue 'dispatch;
	// 830BDCDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BDCE0: 4BFF4431  bl 0x830b2110
	ctx.lr = 0x830BDCE4;
	sub_830B2110(ctx, base);
	// 830BDCE4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 830BDCE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BDCEC: C00B9534  lfs f0, -0x6acc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BDCF0: EC210032  fmuls f1, f1, f0
	ctx.f[1].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 830BDCF4: 4BFF4415  bl 0x830b2108
	ctx.lr = 0x830BDCF8;
	sub_830B2108(ctx, base);
	// 830BDCF8: 48000040  b 0x830bdd38
	pc = 0x830BDD38; continue 'dispatch;
	// 830BDCFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BDD00: 4BFF4461  bl 0x830b2160
	ctx.lr = 0x830BDD04;
	sub_830B2160(ctx, base);
	// 830BDD04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BDD08: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 830BDD0C: 4BFF4445  bl 0x830b2150
	ctx.lr = 0x830BDD10;
	sub_830B2150(ctx, base);
	// 830BDD10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BDD14: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 830BDD18: 4BFF4429  bl 0x830b2140
	ctx.lr = 0x830BDD1C;
	sub_830B2140(ctx, base);
	// 830BDD1C: EC1E0828  fsubs f0, f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[30].f64 - ctx.f[1].f64) as f32) as f64);
	// 830BDD20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BDD24: EC3F0028  fsubs f1, f31, f0
	ctx.f[1].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 830BDD28: 4BFF4409  bl 0x830b2130
	ctx.lr = 0x830BDD2C;
	sub_830B2130(ctx, base);
	// 830BDD2C: 4800000C  b 0x830bdd38
	pc = 0x830BDD38; continue 'dispatch;
	// 830BDD30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BDD34: 4BFF4435  bl 0x830b2168
	ctx.lr = 0x830BDD38;
	sub_830B2168(ctx, base);
	// 830BDD38: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830BDD3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830BDD40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830BDD44: CBC1FFE0  lfd f30, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 830BDD48: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830BDD4C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830BDD50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BDD58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830BDD58 size=68
    let mut pc: u32 = 0x830BDD58;
    'dispatch: loop {
        match pc {
            0x830BDD58 => {
    //   block [0x830BDD58..0x830BDD9C)
	// 830BDD58: C1A50000  lfs f13, 0(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830BDD5C: C1840000  lfs f12, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830BDD60: C0050004  lfs f0, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BDD64: ED8C0372  fmuls f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 830BDD68: C1640010  lfs f11, 0x10(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830BDD6C: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 830BDD70: C1440004  lfs f10, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 830BDD74: C124000C  lfs f9, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 830BDD78: C1040008  lfs f8, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 830BDD7C: C0E40014  lfs f7, 0x14(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 830BDD80: EC0A603A  fmadds f0, f10, f0, f12
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 830BDD84: EDA95B7A  fmadds f13, f9, f13, f11
	ctx.f[13].f64 = (((ctx.f[9].f64 * ctx.f[13].f64 + ctx.f[11].f64) as f32) as f64);
	// 830BDD88: EC00402A  fadds f0, f0, f8
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[8].f64) as f32) as f64;
	// 830BDD8C: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830BDD90: EC0D382A  fadds f0, f13, f7
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[7].f64) as f32) as f64;
	// 830BDD94: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830BDD98: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BDDA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830BDDA0 size=220
    let mut pc: u32 = 0x830BDDA0;
    'dispatch: loop {
        match pc {
            0x830BDDA0 => {
    //   block [0x830BDDA0..0x830BDE7C)
	// 830BDDA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BDDA4: 480EA3C9  bl 0x831a816c
	ctx.lr = 0x830BDDA8;
	sub_831A8130(ctx, base);
	// 830BDDA8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BDDAC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830BDDB0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830BDDB4: 3BBE0058  addi r29, r30, 0x58
	ctx.r[29].s64 = ctx.r[30].s64 + 88;
	// 830BDDB8: 48000821  bl 0x830be5d8
	ctx.lr = 0x830BDDBC;
	sub_830BE5D8(ctx, base);
	// 830BDDBC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830BDDC0: 48000409  bl 0x830be1c8
	ctx.lr = 0x830BDDC4;
	sub_830BE1C8(ctx, base);
	// 830BDDC4: 817E0094  lwz r11, 0x94(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(148 as u32) ) } as u64;
	// 830BDDC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830BDDCC: 419A0044  beq cr6, 0x830bde10
	if ctx.cr[6].eq {
	pc = 0x830BDE10; continue 'dispatch;
	}
	// 830BDDD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BDDD4: 48000A5D  bl 0x830be830
	ctx.lr = 0x830BDDD8;
	sub_830BE830(ctx, base);
	// 830BDDD8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830BDDDC: 480007FD  bl 0x830be5d8
	ctx.lr = 0x830BDDE0;
	sub_830BE5D8(ctx, base);
	// 830BDDE0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830BDDE4: 48000535  bl 0x830be318
	ctx.lr = 0x830BDDE8;
	sub_830BE318(ctx, base);
	// 830BDDE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BDDEC: 48000A85  bl 0x830be870
	ctx.lr = 0x830BDDF0;
	sub_830BE870(ctx, base);
	// 830BDDF0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830BDDF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BDDF8: 48000A69  bl 0x830be860
	ctx.lr = 0x830BDDFC;
	sub_830BE860(ctx, base);
	// 830BDDFC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830BDE00: 480007D9  bl 0x830be5d8
	ctx.lr = 0x830BDE04;
	sub_830BE5D8(ctx, base);
	// 830BDE04: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830BDE08: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830BDE0C: 480004DD  bl 0x830be2e8
	ctx.lr = 0x830BDE10;
	sub_830BE2E8(ctx, base);
	// 830BDE10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BDE14: 48000A05  bl 0x830be818
	ctx.lr = 0x830BDE18;
	sub_830BE818(ctx, base);
	// 830BDE18: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 830BDE1C: 41980014  blt cr6, 0x830bde30
	if ctx.cr[6].lt {
	pc = 0x830BDE30; continue 'dispatch;
	}
	// 830BDE20: 409A001C  bne cr6, 0x830bde3c
	if !ctx.cr[6].eq {
	pc = 0x830BDE3C; continue 'dispatch;
	}
	// 830BDE24: 480007B5  bl 0x830be5d8
	ctx.lr = 0x830BDE28;
	sub_830BE5D8(ctx, base);
	// 830BDE28: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830BDE2C: 4800000C  b 0x830bde38
	pc = 0x830BDE38; continue 'dispatch;
	// 830BDE30: 480007A9  bl 0x830be5d8
	ctx.lr = 0x830BDE34;
	sub_830BE5D8(ctx, base);
	// 830BDE34: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830BDE38: 48000501  bl 0x830be338
	ctx.lr = 0x830BDE3C;
	sub_830BE338(ctx, base);
	// 830BDE3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BDE40: 480009E1  bl 0x830be820
	ctx.lr = 0x830BDE44;
	sub_830BE820(ctx, base);
	// 830BDE44: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 830BDE48: 4198001C  blt cr6, 0x830bde64
	if ctx.cr[6].lt {
	pc = 0x830BDE64; continue 'dispatch;
	}
	// 830BDE4C: 419A0010  beq cr6, 0x830bde5c
	if ctx.cr[6].eq {
	pc = 0x830BDE5C; continue 'dispatch;
	}
	// 830BDE50: 2B030003  cmplwi cr6, r3, 3
	ctx.cr[6].compare_u32(ctx.r[3].u32, 3 as u32, &mut ctx.xer);
	// 830BDE54: 41980010  blt cr6, 0x830bde64
	if ctx.cr[6].lt {
	pc = 0x830BDE64; continue 'dispatch;
	}
	// 830BDE58: 409A000C  bne cr6, 0x830bde64
	if !ctx.cr[6].eq {
	pc = 0x830BDE64; continue 'dispatch;
	}
	// 830BDE5C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 830BDE60: 48000008  b 0x830bde68
	pc = 0x830BDE68; continue 'dispatch;
	// 830BDE64: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 830BDE68: 48000771  bl 0x830be5d8
	ctx.lr = 0x830BDE6C;
	sub_830BE5D8(ctx, base);
	// 830BDE6C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830BDE70: 480004E9  bl 0x830be358
	ctx.lr = 0x830BDE74;
	sub_830BE358(ctx, base);
	// 830BDE74: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830BDE78: 480EA344  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BDE80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830BDE80 size=184
    let mut pc: u32 = 0x830BDE80;
    'dispatch: loop {
        match pc {
            0x830BDE80 => {
    //   block [0x830BDE80..0x830BDF38)
	// 830BDE80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BDE84: 480EA2E1  bl 0x831a8164
	ctx.lr = 0x830BDE88;
	sub_831A8130(ctx, base);
	// 830BDE88: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BDE8C: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 830BDE90: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830BDE94: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830BDE98: 3B9F0058  addi r28, r31, 0x58
	ctx.r[28].s64 = ctx.r[31].s64 + 88;
	// 830BDE9C: 817F0094  lwz r11, 0x94(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 830BDEA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830BDEA4: 419A0018  beq cr6, 0x830bdebc
	if ctx.cr[6].eq {
	pc = 0x830BDEBC; continue 'dispatch;
	}
	// 830BDEA8: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BDEAC: 4800072D  bl 0x830be5d8
	ctx.lr = 0x830BDEB0;
	sub_830BE5D8(ctx, base);
	// 830BDEB0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830BDEB4: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 830BDEB8: 480003D9  bl 0x830be290
	ctx.lr = 0x830BDEBC;
	sub_830BE290(ctx, base);
	// 830BDEBC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830BDEC0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830BDEC4: 4BFFFEDD  bl 0x830bdda0
	ctx.lr = 0x830BDEC8;
	sub_830BDDA0(ctx, base);
	// 830BDEC8: 817F0094  lwz r11, 0x94(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 830BDECC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830BDED0: 419A0028  beq cr6, 0x830bdef8
	if ctx.cr[6].eq {
	pc = 0x830BDEF8; continue 'dispatch;
	}
	// 830BDED4: 48000705  bl 0x830be5d8
	ctx.lr = 0x830BDED8;
	sub_830BE5D8(ctx, base);
	// 830BDED8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830BDEDC: 480002CD  bl 0x830be1a8
	ctx.lr = 0x830BDEE0;
	sub_830BE1A8(ctx, base);
	// 830BDEE0: 480006F9  bl 0x830be5d8
	ctx.lr = 0x830BDEE4;
	sub_830BE5D8(ctx, base);
	// 830BDEE4: 48000495  bl 0x830be378
	ctx.lr = 0x830BDEE8;
	sub_830BE378(ctx, base);
	// 830BDEE8: 4BFFAC19  bl 0x830b8b00
	ctx.lr = 0x830BDEEC;
	sub_830B8B00(ctx, base);
	// 830BDEEC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BDEF0: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 830BDEF4: 48000024  b 0x830bdf18
	pc = 0x830BDF18; continue 'dispatch;
	// 830BDEF8: 480006E1  bl 0x830be5d8
	ctx.lr = 0x830BDEFC;
	sub_830BE5D8(ctx, base);
	// 830BDEFC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830BDF00: 480002A9  bl 0x830be1a8
	ctx.lr = 0x830BDF04;
	sub_830BE1A8(ctx, base);
	// 830BDF04: 480006D5  bl 0x830be5d8
	ctx.lr = 0x830BDF08;
	sub_830BE5D8(ctx, base);
	// 830BDF08: 48000471  bl 0x830be378
	ctx.lr = 0x830BDF0C;
	sub_830BE378(ctx, base);
	// 830BDF0C: 4BFFABF5  bl 0x830b8b00
	ctx.lr = 0x830BDF10;
	sub_830B8B00(ctx, base);
	// 830BDF10: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BDF14: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 830BDF18: 809F0090  lwz r4, 0x90(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 830BDF1C: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 830BDF20: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 830BDF24: 38E00003  li r7, 3
	ctx.r[7].s64 = 3;
	// 830BDF28: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830BDF2C: 4E800421  bctrl
	ctx.lr = 0x830BDF30;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830BDF30: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830BDF34: 480EA280  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BDF38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830BDF38 size=348
    let mut pc: u32 = 0x830BDF38;
    'dispatch: loop {
        match pc {
            0x830BDF38 => {
    //   block [0x830BDF38..0x830BE094)
	// 830BDF38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BDF3C: 480EA221  bl 0x831a815c
	ctx.lr = 0x830BDF40;
	sub_831A8130(ctx, base);
	// 830BDF40: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BDF44: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 830BDF48: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 830BDF4C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 830BDF50: 817F0094  lwz r11, 0x94(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 830BDF54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830BDF58: 419A0134  beq cr6, 0x830be08c
	if ctx.cr[6].eq {
	pc = 0x830BE08C; continue 'dispatch;
	}
	// 830BDF5C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830BDF60: 3BBF0058  addi r29, r31, 0x58
	ctx.r[29].s64 = ctx.r[31].s64 + 88;
	// 830BDF64: 4BFFFE3D  bl 0x830bdda0
	ctx.lr = 0x830BDF68;
	sub_830BDDA0(ctx, base);
	// 830BDF68: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 830BDF6C: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 830BDF70: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BDF74: 40990118  ble cr6, 0x830be08c
	if !ctx.cr[6].gt {
	pc = 0x830BE08C; continue 'dispatch;
	}
	// 830BDF78: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830BDF7C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 830BDF80: 817F0094  lwz r11, 0x94(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 830BDF84: 7D7C582E  lwzx r11, r28, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830BDF88: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BDF8C: 41980048  blt cr6, 0x830bdfd4
	if ctx.cr[6].lt {
	pc = 0x830BDFD4; continue 'dispatch;
	}
	// 830BDF90: 48000649  bl 0x830be5d8
	ctx.lr = 0x830BDF94;
	sub_830BE5D8(ctx, base);
	// 830BDF94: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830BDF98: 48000211  bl 0x830be1a8
	ctx.lr = 0x830BDF9C;
	sub_830BE1A8(ctx, base);
	// 830BDF9C: 817F0094  lwz r11, 0x94(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 830BDFA0: 7F3C582E  lwzx r25, r28, r11
	ctx.r[25].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830BDFA4: 48000635  bl 0x830be5d8
	ctx.lr = 0x830BDFA8;
	sub_830BE5D8(ctx, base);
	// 830BDFA8: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 830BDFAC: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 830BDFB0: 480002E1  bl 0x830be290
	ctx.lr = 0x830BDFB4;
	sub_830BE290(ctx, base);
	// 830BDFB4: 48000625  bl 0x830be5d8
	ctx.lr = 0x830BDFB8;
	sub_830BE5D8(ctx, base);
	// 830BDFB8: 480003C1  bl 0x830be378
	ctx.lr = 0x830BDFBC;
	sub_830BE378(ctx, base);
	// 830BDFBC: 4BFFAB45  bl 0x830b8b00
	ctx.lr = 0x830BDFC0;
	sub_830B8B00(ctx, base);
	// 830BDFC0: 817F0090  lwz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 830BDFC4: 7C9E5A14  add r4, r30, r11
	ctx.r[4].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 830BDFC8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BDFCC: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 830BDFD0: 48000090  b 0x830be060
	pc = 0x830BE060; continue 'dispatch;
	// 830BDFD4: 815F0090  lwz r10, 0x90(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 830BDFD8: 397E003C  addi r11, r30, 0x3c
	ctx.r[11].s64 = ctx.r[30].s64 + 60;
	// 830BDFDC: 811F0090  lwz r8, 0x90(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 830BDFE0: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 830BDFE4: 7D5E5214  add r10, r30, r10
	ctx.r[10].u64 = ctx.r[30].u64 + ctx.r[10].u64;
	// 830BDFE8: 5527003E  slwi r7, r9, 0
	ctx.r[7].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 830BDFEC: 7D3E4A14  add r9, r30, r9
	ctx.r[9].u64 = ctx.r[30].u64 + ctx.r[9].u64;
	// 830BDFF0: 7CDE3A14  add r6, r30, r7
	ctx.r[6].u64 = ctx.r[30].u64 + ctx.r[7].u64;
	// 830BDFF4: 7CEB3A14  add r7, r11, r7
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 830BDFF8: E88A0000  ld r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 830BDFFC: 7CBE4214  add r5, r30, r8
	ctx.r[5].u64 = ctx.r[30].u64 + ctx.r[8].u64;
	// 830BE000: F8810050  std r4, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u64 ) };
	// 830BE004: 80890008  lwz r4, 8(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 830BE008: 90810058  stw r4, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[4].u32 ) };
	// 830BE00C: E9290014  ld r9, 0x14(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) };
	// 830BE010: F921005C  std r9, 0x5c(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u64 ) };
	// 830BE014: 8126001C  lwz r9, 0x1c(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(28 as u32) ) } as u64;
	// 830BE018: 91210064  stw r9, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 830BE01C: E927FFEC  ld r9, -0x14(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(-20 as u32) ) };
	// 830BE020: F9210068  std r9, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[9].u64 ) };
	// 830BE024: 81250030  lwz r9, 0x30(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(48 as u32) ) } as u64;
	// 830BE028: 91210070  stw r9, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[9].u32 ) };
	// 830BE02C: 7D6B402A  ldx r11, r11, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) };
	// 830BE030: F9610074  std r11, 0x74(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u64 ) };
	// 830BE034: 816A0044  lwz r11, 0x44(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(68 as u32) ) } as u64;
	// 830BE038: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 830BE03C: 4800059D  bl 0x830be5d8
	ctx.lr = 0x830BE040;
	sub_830BE5D8(ctx, base);
	// 830BE040: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830BE044: 48000165  bl 0x830be1a8
	ctx.lr = 0x830BE048;
	sub_830BE1A8(ctx, base);
	// 830BE048: 48000591  bl 0x830be5d8
	ctx.lr = 0x830BE04C;
	sub_830BE5D8(ctx, base);
	// 830BE04C: 4800032D  bl 0x830be378
	ctx.lr = 0x830BE050;
	sub_830BE378(ctx, base);
	// 830BE050: 4BFFAAB1  bl 0x830b8b00
	ctx.lr = 0x830BE054;
	sub_830B8B00(ctx, base);
	// 830BE054: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BE058: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830BE05C: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 830BE060: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 830BE064: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 830BE068: 38E00003  li r7, 3
	ctx.r[7].s64 = 3;
	// 830BE06C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830BE070: 4E800421  bctrl
	ctx.lr = 0x830BE074;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830BE074: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 830BE078: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 830BE07C: 3BDE0050  addi r30, r30, 0x50
	ctx.r[30].s64 = ctx.r[30].s64 + 80;
	// 830BE080: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 830BE084: 7F1B5800  cmpw cr6, r27, r11
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830BE088: 4198FEF8  blt cr6, 0x830bdf80
	if ctx.cr[6].lt {
	pc = 0x830BDF80; continue 'dispatch;
	}
	// 830BE08C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 830BE090: 480EA11C  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BE098(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830BE098 size=268
    let mut pc: u32 = 0x830BE098;
    'dispatch: loop {
        match pc {
            0x830BE098 => {
    //   block [0x830BE098..0x830BE1A4)
	// 830BE098: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BE09C: 480EA0B1  bl 0x831a814c
	ctx.lr = 0x830BE0A0;
	sub_831A8130(ctx, base);
	// 830BE0A0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BE0A4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830BE0A8: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 830BE0AC: 7CB52B78  mr r21, r5
	ctx.r[21].u64 = ctx.r[5].u64;
	// 830BE0B0: 7CD73378  mr r23, r6
	ctx.r[23].u64 = ctx.r[6].u64;
	// 830BE0B4: 48000525  bl 0x830be5d8
	ctx.lr = 0x830BE0B8;
	sub_830BE5D8(ctx, base);
	// 830BE0B8: 48000449  bl 0x830be500
	ctx.lr = 0x830BE0BC;
	sub_830BE500(ctx, base);
	// 830BE0BC: 817E0024  lwz r11, 0x24(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 830BE0C0: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 830BE0C4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BE0C8: 409900CC  ble cr6, 0x830be194
	if !ctx.cr[6].gt {
	pc = 0x830BE194; continue 'dispatch;
	}
	// 830BE0CC: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 830BE0D0: 815E0028  lwz r10, 0x28(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 830BE0D4: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 830BE0D8: 81770004  lwz r11, 4(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BE0DC: 7FFB5214  add r31, r27, r10
	ctx.r[31].u64 = ctx.r[27].u64 + ctx.r[10].u64;
	// 830BE0E0: 7F3B5A14  add r25, r27, r11
	ctx.r[25].u64 = ctx.r[27].u64 + ctx.r[11].u64;
	// 830BE0E4: 7D7B502E  lwzx r11, r27, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830BE0E8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BE0EC: 40990094  ble cr6, 0x830be180
	if !ctx.cr[6].gt {
	pc = 0x830BE180; continue 'dispatch;
	}
	// 830BE0F0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 830BE0F4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830BE0F8: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BE0FC: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BE100: 7CEBEA14  add r7, r11, r29
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 830BE104: 7C8AE02E  lwzx r4, r10, r28
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 830BE108: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 830BE10C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830BE110: 419A0058  beq cr6, 0x830be168
	if ctx.cr[6].eq {
	pc = 0x830BE168; continue 'dispatch;
	}
	// 830BE114: 81670020  lwz r11, 0x20(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(32 as u32) ) } as u64;
	// 830BE118: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BE11C: 409A004C  bne cr6, 0x830be168
	if !ctx.cr[6].eq {
	pc = 0x830BE168; continue 'dispatch;
	}
	// 830BE120: 81670140  lwz r11, 0x140(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(320 as u32) ) } as u64;
	// 830BE124: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BE128: 419A0040  beq cr6, 0x830be168
	if ctx.cr[6].eq {
	pc = 0x830BE168; continue 'dispatch;
	}
	// 830BE12C: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BE130: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830BE134: 41980034  blt cr6, 0x830be168
	if ctx.cr[6].lt {
	pc = 0x830BE168; continue 'dispatch;
	}
	// 830BE138: 419A0020  beq cr6, 0x830be158
	if ctx.cr[6].eq {
	pc = 0x830BE158; continue 'dispatch;
	}
	// 830BE13C: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 830BE140: 40980028  bge cr6, 0x830be168
	if !ctx.cr[6].lt {
	pc = 0x830BE168; continue 'dispatch;
	}
	// 830BE144: 7EA6AB78  mr r6, r21
	ctx.r[6].u64 = ctx.r[21].u64;
	// 830BE148: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 830BE14C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830BE150: 4BFFFDE9  bl 0x830bdf38
	ctx.lr = 0x830BE154;
	sub_830BDF38(ctx, base);
	// 830BE154: 48000014  b 0x830be168
	pc = 0x830BE168; continue 'dispatch;
	// 830BE158: 7CE63B78  mr r6, r7
	ctx.r[6].u64 = ctx.r[7].u64;
	// 830BE15C: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 830BE160: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830BE164: 4BFFFD1D  bl 0x830bde80
	ctx.lr = 0x830BE168;
	sub_830BDE80(ctx, base);
	// 830BE168: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BE16C: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 830BE170: 3BBD0144  addi r29, r29, 0x144
	ctx.r[29].s64 = ctx.r[29].s64 + 324;
	// 830BE174: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 830BE178: 7F1A5800  cmpw cr6, r26, r11
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830BE17C: 4198FF7C  blt cr6, 0x830be0f8
	if ctx.cr[6].lt {
	pc = 0x830BE0F8; continue 'dispatch;
	}
	// 830BE180: 817E0024  lwz r11, 0x24(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 830BE184: 3AD60001  addi r22, r22, 1
	ctx.r[22].s64 = ctx.r[22].s64 + 1;
	// 830BE188: 3B7B0010  addi r27, r27, 0x10
	ctx.r[27].s64 = ctx.r[27].s64 + 16;
	// 830BE18C: 7F165800  cmpw cr6, r22, r11
	ctx.cr[6].compare_i32(ctx.r[22].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830BE190: 4198FF40  blt cr6, 0x830be0d0
	if ctx.cr[6].lt {
	pc = 0x830BE0D0; continue 'dispatch;
	}
	// 830BE194: 48000445  bl 0x830be5d8
	ctx.lr = 0x830BE198;
	sub_830BE5D8(ctx, base);
	// 830BE198: 480004A1  bl 0x830be638
	ctx.lr = 0x830BE19C;
	sub_830BE638(ctx, base);
	// 830BE19C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 830BE1A0: 480E9FFC  b 0x831a819c
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BE1A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BE1A8 size=12
    let mut pc: u32 = 0x830BE1A8;
    'dispatch: loop {
        match pc {
            0x830BE1A8 => {
    //   block [0x830BE1A8..0x830BE1B4)
	// 830BE1A8: 8163002C  lwz r11, 0x2c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 830BE1AC: 7F0B2000  cmpw cr6, r11, r4
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[4].s32, &mut ctx.xer);
	// 830BE1B0: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BE1B4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BE1B4 size=16
    let mut pc: u32 = 0x830BE1B4;
    'dispatch: loop {
        match pc {
            0x830BE1B4 => {
    //   block [0x830BE1B4..0x830BE1C4)
	// 830BE1B4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830BE1B8: 9083002C  stw r4, 0x2c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), ctx.r[4].u32 ) };
	// 830BE1BC: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830BE1C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BE1C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BE1C8 size=56
    let mut pc: u32 = 0x830BE1C8;
    'dispatch: loop {
        match pc {
            0x830BE1C8 => {
    //   block [0x830BE1C8..0x830BE200)
	// 830BE1C8: 39630034  addi r11, r3, 0x34
	ctx.r[11].s64 = ctx.r[3].s64 + 52;
	// 830BE1CC: 39200003  li r9, 3
	ctx.r[9].s64 = 3;
	// 830BE1D0: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BE1D4: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BE1D8: 7F085000  cmpw cr6, r8, r10
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830BE1DC: 419A0010  beq cr6, 0x830be1ec
	if ctx.cr[6].eq {
	pc = 0x830BE1EC; continue 'dispatch;
	}
	// 830BE1E0: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 830BE1E4: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830BE1E8: 91030008  stw r8, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 830BE1EC: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830BE1F0: 38840004  addi r4, r4, 4
	ctx.r[4].s64 = ctx.r[4].s64 + 4;
	// 830BE1F4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 830BE1F8: 4082FFD8  bne 0x830be1d0
	if !ctx.cr[0].eq {
	pc = 0x830BE1D0; continue 'dispatch;
	}
	// 830BE1FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BE200(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830BE200 size=144
    let mut pc: u32 = 0x830BE200;
    'dispatch: loop {
        match pc {
            0x830BE200 => {
    //   block [0x830BE200..0x830BE290)
	// 830BE200: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BE204: 480E9F69  bl 0x831a816c
	ctx.lr = 0x830BE208;
	sub_831A8130(ctx, base);
	// 830BE208: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BE20C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830BE210: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830BE214: 3BBF000C  addi r29, r31, 0xc
	ctx.r[29].s64 = ctx.r[31].s64 + 12;
	// 830BE218: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830BE21C: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 830BE220: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 830BE224: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 830BE228: 4BFF3C99  bl 0x830b1ec0
	ctx.lr = 0x830BE22C;
	sub_830B1EC0(ctx, base);
	// 830BE22C: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 830BE230: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830BE234: 396BE544  addi r11, r11, -0x1abc
	ctx.r[11].s64 = ctx.r[11].s64 + -6844;
	// 830BE238: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830BE23C: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 830BE240: 4BFF3D59  bl 0x830b1f98
	ctx.lr = 0x830BE244;
	sub_830B1F98(ctx, base);
	// 830BE244: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 830BE248: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 830BE24C: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 830BE250: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 830BE254: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 830BE258: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 830BE25C: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 830BE260: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 830BE264: 397F0034  addi r11, r31, 0x34
	ctx.r[11].s64 = ctx.r[31].s64 + 52;
	// 830BE268: 93DF002C  stw r30, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[30].u32 ) };
	// 830BE26C: 93DF0030  stw r30, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[30].u32 ) };
	// 830BE270: 93CB000C  stw r30, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 830BE274: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830BE278: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 830BE27C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 830BE280: 4082FFF0  bne 0x830be270
	if !ctx.cr[0].eq {
	pc = 0x830BE270; continue 'dispatch;
	}
	// 830BE284: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BE288: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830BE28C: 480E9F30  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BE290(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830BE290 size=88
    let mut pc: u32 = 0x830BE290;
    'dispatch: loop {
        match pc {
            0x830BE290 => {
    //   block [0x830BE290..0x830BE2E8)
	// 830BE290: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BE294: 480E9ED5  bl 0x831a8168
	ctx.lr = 0x830BE298;
	sub_831A8130(ctx, base);
	// 830BE298: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BE29C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830BE2A0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830BE2A4: 3B9F000C  addi r28, r31, 0xc
	ctx.r[28].s64 = ctx.r[31].s64 + 12;
	// 830BE2A8: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 830BE2AC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830BE2B0: 4BFF3C99  bl 0x830b1f48
	ctx.lr = 0x830BE2B4;
	sub_830B1F48(ctx, base);
	// 830BE2B4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830BE2B8: 41820010  beq 0x830be2c8
	if ctx.cr[0].eq {
	pc = 0x830BE2C8; continue 'dispatch;
	}
	// 830BE2BC: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830BE2C0: 7F0BE800  cmpw cr6, r11, r29
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[29].s32, &mut ctx.xer);
	// 830BE2C4: 419A001C  beq cr6, 0x830be2e0
	if ctx.cr[6].eq {
	pc = 0x830BE2E0; continue 'dispatch;
	}
	// 830BE2C8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830BE2CC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830BE2D0: 4BFF3D59  bl 0x830b2028
	ctx.lr = 0x830BE2D4;
	sub_830B2028(ctx, base);
	// 830BE2D4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830BE2D8: 93BF0014  stw r29, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[29].u32 ) };
	// 830BE2DC: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830BE2E0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830BE2E4: 480E9ED4  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BE2E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BE2E8 size=24
    let mut pc: u32 = 0x830BE2E8;
    'dispatch: loop {
        match pc {
            0x830BE2E8 => {
    //   block [0x830BE2E8..0x830BE300)
	// 830BE2E8: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 830BE2EC: 7F0B2000  cmpw cr6, r11, r4
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[4].s32, &mut ctx.xer);
	// 830BE2F0: 409A0010  bne cr6, 0x830be300
	if !ctx.cr[6].eq {
		sub_830BE300(ctx, base);
		return;
	}
	// 830BE2F4: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 830BE2F8: 7F0B2800  cmpw cr6, r11, r5
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[5].s32, &mut ctx.xer);
	// 830BE2FC: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BE300(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BE300 size=20
    let mut pc: u32 = 0x830BE300;
    'dispatch: loop {
        match pc {
            0x830BE300 => {
    //   block [0x830BE300..0x830BE314)
	// 830BE300: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830BE304: 90830018  stw r4, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[4].u32 ) };
	// 830BE308: 90A3001C  stw r5, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[5].u32 ) };
	// 830BE30C: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830BE310: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BE318(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BE318 size=12
    let mut pc: u32 = 0x830BE318;
    'dispatch: loop {
        match pc {
            0x830BE318 => {
    //   block [0x830BE318..0x830BE324)
	// 830BE318: 81630020  lwz r11, 0x20(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 830BE31C: 7F0B2000  cmpw cr6, r11, r4
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[4].s32, &mut ctx.xer);
	// 830BE320: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BE324(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BE324 size=16
    let mut pc: u32 = 0x830BE324;
    'dispatch: loop {
        match pc {
            0x830BE324 => {
    //   block [0x830BE324..0x830BE334)
	// 830BE324: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830BE328: 90830020  stw r4, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[4].u32 ) };
	// 830BE32C: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830BE330: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BE338(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BE338 size=12
    let mut pc: u32 = 0x830BE338;
    'dispatch: loop {
        match pc {
            0x830BE338 => {
    //   block [0x830BE338..0x830BE344)
	// 830BE338: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 830BE33C: 7F0B2000  cmpw cr6, r11, r4
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[4].s32, &mut ctx.xer);
	// 830BE340: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BE344(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BE344 size=16
    let mut pc: u32 = 0x830BE344;
    'dispatch: loop {
        match pc {
            0x830BE344 => {
    //   block [0x830BE344..0x830BE354)
	// 830BE344: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830BE348: 90830024  stw r4, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[4].u32 ) };
	// 830BE34C: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830BE350: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BE358(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BE358 size=12
    let mut pc: u32 = 0x830BE358;
    'dispatch: loop {
        match pc {
            0x830BE358 => {
    //   block [0x830BE358..0x830BE364)
	// 830BE358: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 830BE35C: 7F0B2000  cmpw cr6, r11, r4
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[4].s32, &mut ctx.xer);
	// 830BE360: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BE364(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BE364 size=16
    let mut pc: u32 = 0x830BE364;
    'dispatch: loop {
        match pc {
            0x830BE364 => {
    //   block [0x830BE364..0x830BE374)
	// 830BE364: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830BE368: 90830028  stw r4, 0x28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[4].u32 ) };
	// 830BE36C: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830BE370: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BE378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830BE378 size=392
    let mut pc: u32 = 0x830BE378;
    'dispatch: loop {
        match pc {
            0x830BE378 => {
    //   block [0x830BE378..0x830BE500)
	// 830BE378: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BE37C: 480E9DF1  bl 0x831a816c
	ctx.lr = 0x830BE380;
	sub_831A8130(ctx, base);
	// 830BE380: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BE384: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830BE388: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830BE38C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BE390: 419A0168  beq cr6, 0x830be4f8
	if ctx.cr[6].eq {
	pc = 0x830BE4F8; continue 'dispatch;
	}
	// 830BE394: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BE398: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BE39C: 419A003C  beq cr6, 0x830be3d8
	if ctx.cr[6].eq {
	pc = 0x830BE3D8; continue 'dispatch;
	}
	// 830BE3A0: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 830BE3A4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BE3A8: 419A0014  beq cr6, 0x830be3bc
	if ctx.cr[6].eq {
	pc = 0x830BE3BC; continue 'dispatch;
	}
	// 830BE3AC: 4BFFA755  bl 0x830b8b00
	ctx.lr = 0x830BE3B0;
	sub_830B8B00(ctx, base);
	// 830BE3B0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BE3B4: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 830BE3B8: 48000010  b 0x830be3c8
	pc = 0x830BE3C8; continue 'dispatch;
	// 830BE3BC: 4BFFA745  bl 0x830b8b00
	ctx.lr = 0x830BE3C0;
	sub_830B8B00(ctx, base);
	// 830BE3C0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BE3C4: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 830BE3C8: 389F0040  addi r4, r31, 0x40
	ctx.r[4].s64 = ctx.r[31].s64 + 64;
	// 830BE3CC: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 830BE3D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830BE3D4: 4E800421  bctrl
	ctx.lr = 0x830BE3D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830BE3D8: 3BDF000C  addi r30, r31, 0xc
	ctx.r[30].s64 = ctx.r[31].s64 + 12;
	// 830BE3DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830BE3E0: 4BFF3BA1  bl 0x830b1f80
	ctx.lr = 0x830BE3E4;
	sub_830B1F80(ctx, base);
	// 830BE3E4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830BE3E8: 4182007C  beq 0x830be464
	if ctx.cr[0].eq {
	pc = 0x830BE464; continue 'dispatch;
	}
	// 830BE3EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830BE3F0: 4BFF3B39  bl 0x830b1f28
	ctx.lr = 0x830BE3F4;
	sub_830B1F28(ctx, base);
	// 830BE3F4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BE3F8: 3BBF0034  addi r29, r31, 0x34
	ctx.r[29].s64 = ctx.r[31].s64 + 52;
	// 830BE3FC: 809F0014  lwz r4, 0x14(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830BE400: 38C00003  li r6, 3
	ctx.r[6].s64 = 3;
	// 830BE404: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830BE408: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830BE40C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830BE410: 4E800421  bctrl
	ctx.lr = 0x830BE414;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830BE414: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830BE418: 4BFF3B11  bl 0x830b1f28
	ctx.lr = 0x830BE41C;
	sub_830B1F28(ctx, base);
	// 830BE41C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BE420: 80BF001C  lwz r5, 0x1c(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 830BE424: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 830BE428: 809F0018  lwz r4, 0x18(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830BE42C: 38E00003  li r7, 3
	ctx.r[7].s64 = 3;
	// 830BE430: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 830BE434: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830BE438: 4E800421  bctrl
	ctx.lr = 0x830BE43C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830BE43C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830BE440: 4BFF3AE9  bl 0x830b1f28
	ctx.lr = 0x830BE444;
	sub_830B1F28(ctx, base);
	// 830BE444: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BE448: 80BF0020  lwz r5, 0x20(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 830BE44C: 38E00003  li r7, 3
	ctx.r[7].s64 = 3;
	// 830BE450: 809F0014  lwz r4, 0x14(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830BE454: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 830BE458: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 830BE45C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830BE460: 4E800421  bctrl
	ctx.lr = 0x830BE464;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830BE464: 4BFFA69D  bl 0x830b8b00
	ctx.lr = 0x830BE468;
	sub_830B8B00(ctx, base);
	// 830BE468: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BE46C: 3BDF0034  addi r30, r31, 0x34
	ctx.r[30].s64 = ctx.r[31].s64 + 52;
	// 830BE470: 809F0024  lwz r4, 0x24(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 830BE474: 38C00003  li r6, 3
	ctx.r[6].s64 = 3;
	// 830BE478: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830BE47C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830BE480: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830BE484: 4E800421  bctrl
	ctx.lr = 0x830BE488;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830BE488: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 830BE48C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BE490: 419A0014  beq cr6, 0x830be4a4
	if ctx.cr[6].eq {
	pc = 0x830BE4A4; continue 'dispatch;
	}
	// 830BE494: 4BFFA66D  bl 0x830b8b00
	ctx.lr = 0x830BE498;
	sub_830B8B00(ctx, base);
	// 830BE498: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BE49C: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830BE4A0: 48000010  b 0x830be4b0
	pc = 0x830BE4B0; continue 'dispatch;
	// 830BE4A4: 4BFFA65D  bl 0x830b8b00
	ctx.lr = 0x830BE4A8;
	sub_830B8B00(ctx, base);
	// 830BE4A8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BE4AC: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 830BE4B0: 809F0028  lwz r4, 0x28(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 830BE4B4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830BE4B8: 38C00003  li r6, 3
	ctx.r[6].s64 = 3;
	// 830BE4BC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830BE4C0: 4E800421  bctrl
	ctx.lr = 0x830BE4C4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830BE4C4: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BE4C8: 811E0004  lwz r8, 4(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BE4CC: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 830BE4D0: 80DE0008  lwz r6, 8(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830BE4D4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 830BE4D8: 397F0040  addi r11, r31, 0x40
	ctx.r[11].s64 = ctx.r[31].s64 + 64;
	// 830BE4DC: 915F0040  stw r10, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[10].u32 ) };
	// 830BE4E0: 911F0044  stw r8, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[8].u32 ) };
	// 830BE4E4: 90DF0048  stw r6, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[6].u32 ) };
	// 830BE4E8: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 830BE4EC: 90FF0008  stw r7, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 830BE4F0: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 830BE4F4: 917F0030  stw r11, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 830BE4F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830BE4FC: 480E9CC0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BE500(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830BE500 size=88
    let mut pc: u32 = 0x830BE500;
    'dispatch: loop {
        match pc {
            0x830BE500 => {
    //   block [0x830BE500..0x830BE558)
	// 830BE500: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BE504: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830BE508: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830BE50C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BE510: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830BE514: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BE518: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BE51C: 409A001C  bne cr6, 0x830be538
	if !ctx.cr[6].eq {
	pc = 0x830BE538; continue 'dispatch;
	}
	// 830BE520: 4BFFA5E1  bl 0x830b8b00
	ctx.lr = 0x830BE524;
	sub_830B8B00(ctx, base);
	// 830BE524: 4BFFA5ED  bl 0x830b8b10
	ctx.lr = 0x830BE528;
	sub_830B8B10(ctx, base);
	// 830BE528: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830BE52C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830BE530: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830BE534: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830BE538: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BE53C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830BE540: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830BE544: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830BE548: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830BE54C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830BE550: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830BE554: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BE558(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830BE558 size=128
    let mut pc: u32 = 0x830BE558;
    'dispatch: loop {
        match pc {
            0x830BE558 => {
    //   block [0x830BE558..0x830BE5D8)
	// 830BE558: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BE55C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830BE560: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830BE564: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BE568: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830BE56C: 4BFFA595  bl 0x830b8b00
	ctx.lr = 0x830BE570;
	sub_830B8B00(ctx, base);
	// 830BE570: 4BFFA5F1  bl 0x830b8b60
	ctx.lr = 0x830BE574;
	sub_830B8B60(ctx, base);
	// 830BE574: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830BE578: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 830BE57C: 4BFF3B35  bl 0x830b20b0
	ctx.lr = 0x830BE580;
	sub_830B20B0(ctx, base);
	// 830BE580: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BE584: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BE588: 419A003C  beq cr6, 0x830be5c4
	if ctx.cr[6].eq {
	pc = 0x830BE5C4; continue 'dispatch;
	}
	// 830BE58C: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 830BE590: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BE594: 419A0014  beq cr6, 0x830be5a8
	if ctx.cr[6].eq {
	pc = 0x830BE5A8; continue 'dispatch;
	}
	// 830BE598: 4BFFA569  bl 0x830b8b00
	ctx.lr = 0x830BE59C;
	sub_830B8B00(ctx, base);
	// 830BE59C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BE5A0: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 830BE5A4: 48000010  b 0x830be5b4
	pc = 0x830BE5B4; continue 'dispatch;
	// 830BE5A8: 4BFFA559  bl 0x830b8b00
	ctx.lr = 0x830BE5AC;
	sub_830B8B00(ctx, base);
	// 830BE5AC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BE5B0: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 830BE5B4: 389F0034  addi r4, r31, 0x34
	ctx.r[4].s64 = ctx.r[31].s64 + 52;
	// 830BE5B8: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 830BE5BC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830BE5C0: 4E800421  bctrl
	ctx.lr = 0x830BE5C4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830BE5C4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830BE5C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830BE5CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830BE5D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830BE5D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BE5D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830BE5D8 size=92
    let mut pc: u32 = 0x830BE5D8;
    'dispatch: loop {
        match pc {
            0x830BE5D8 => {
    //   block [0x830BE5D8..0x830BE634)
	// 830BE5D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BE5DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830BE5E0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830BE5E4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BE5E8: 3D408339  lis r10, -0x7cc7
	ctx.r[10].s64 = -2093416448;
	// 830BE5EC: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 830BE5F0: 3BEBBD78  addi r31, r11, -0x4288
	ctx.r[31].s64 = ctx.r[11].s64 + -17032;
	// 830BE5F4: 816ABDC4  lwz r11, -0x423c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16956 as u32) ) } as u64;
	// 830BE5F8: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830BE5FC: 40820020  bne 0x830be61c
	if !ctx.cr[0].eq {
	pc = 0x830BE61C; continue 'dispatch;
	}
	// 830BE600: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 830BE604: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BE608: 916ABDC4  stw r11, -0x423c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-16956 as u32), ctx.r[11].u32 ) };
	// 830BE60C: 4BFFFBF5  bl 0x830be200
	ctx.lr = 0x830BE610;
	sub_830BE200(ctx, base);
	// 830BE610: 3D608324  lis r11, -0x7cdc
	ctx.r[11].s64 = -2094792704;
	// 830BE614: 386B2100  addi r3, r11, 0x2100
	ctx.r[3].s64 = ctx.r[11].s64 + 8448;
	// 830BE618: 480E9EC1  bl 0x831a84d8
	ctx.lr = 0x830BE61C;
	sub_831A84D8(ctx, base);
	// 830BE61C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BE620: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830BE624: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830BE628: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830BE62C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830BE630: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BE638(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BE638 size=16
    let mut pc: u32 = 0x830BE638;
    'dispatch: loop {
        match pc {
            0x830BE638 => {
    //   block [0x830BE638..0x830BE648)
	// 830BE638: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BE63C: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BE640: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830BE644: 4C820020  bnelr
	if !ctx.cr[0].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BE648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BE648 size=8
    let mut pc: u32 = 0x830BE648;
    'dispatch: loop {
        match pc {
            0x830BE648 => {
    //   block [0x830BE648..0x830BE650)
	// 830BE648: 4BFFFF10  b 0x830be558
	sub_830BE558(ctx, base);
	return;
	// 830BE64C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BE650(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830BE650 size=316
    let mut pc: u32 = 0x830BE650;
    'dispatch: loop {
        match pc {
            0x830BE650 => {
    //   block [0x830BE650..0x830BE78C)
	// 830BE650: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BE654: 480E9B0D  bl 0x831a8160
	ctx.lr = 0x830BE658;
	sub_831A8130(ctx, base);
	// 830BE658: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BE65C: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 830BE660: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 830BE664: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830BE668: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 830BE66C: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 830BE670: 83FB0004  lwz r31, 4(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BE674: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BE678: 894B0019  lbz r10, 0x19(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 830BE67C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830BE680: 409A0060  bne cr6, 0x830be6e0
	if !ctx.cr[6].eq {
	pc = 0x830BE6E0; continue 'dispatch;
	}
	// 830BE684: 80FC0000  lwz r7, 0(r28)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BE688: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830BE68C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 830BE690: 7CEA3B78  mr r10, r7
	ctx.r[10].u64 = ctx.r[7].u64;
	// 830BE694: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BE698: 88C90000  lbz r6, 0(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BE69C: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830BE6A0: 7D064050  subf r8, r6, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[6].s64;
	// 830BE6A4: 41820014  beq 0x830be6b8
	if ctx.cr[0].eq {
	pc = 0x830BE6B8; continue 'dispatch;
	}
	// 830BE6A8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830BE6AC: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 830BE6B0: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 830BE6B4: 419AFFE0  beq cr6, 0x830be694
	if ctx.cr[6].eq {
	pc = 0x830BE694; continue 'dispatch;
	}
	// 830BE6B8: 7D0A0034  cntlzw r10, r8
	ctx.r[10].u64 = if ctx.r[8].u32 == 0 { 32 } else { ctx.r[8].u32.leading_zeros() as u64 };
	// 830BE6BC: 7D4A0034  cntlzw r10, r10
	ctx.r[10].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 830BE6C0: 555DDFFF  rlwinm. r29, r10, 0x1b, 0x1f, 0x1f
	ctx.r[29].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830BE6C4: 4182000C  beq 0x830be6d0
	if ctx.cr[0].eq {
	pc = 0x830BE6D0; continue 'dispatch;
	}
	// 830BE6C8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BE6CC: 48000008  b 0x830be6d4
	pc = 0x830BE6D4; continue 'dispatch;
	// 830BE6D0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830BE6D4: 894B0019  lbz r10, 0x19(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 830BE6D8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830BE6DC: 419AFFAC  beq cr6, 0x830be688
	if ctx.cr[6].eq {
	pc = 0x830BE688; continue 'dispatch;
	}
	// 830BE6E0: 7FE8FB78  mr r8, r31
	ctx.r[8].u64 = ctx.r[31].u64;
	// 830BE6E4: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BE6E8: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 830BE6EC: 41820048  beq 0x830be734
	if ctx.cr[0].eq {
	pc = 0x830BE734; continue 'dispatch;
	}
	// 830BE6F0: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BE6F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830BE6F8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BE6FC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830BE700: 409A002C  bne cr6, 0x830be72c
	if !ctx.cr[6].eq {
	pc = 0x830BE72C; continue 'dispatch;
	}
	// 830BE704: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830BE708: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830BE70C: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 830BE710: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 830BE714: 4BFF7085  bl 0x830b5798
	ctx.lr = 0x830BE718;
	sub_830B5798(ctx, base);
	// 830BE718: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 830BE71C: 9B5E0004  stb r26, 4(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[26].u8 ) };
	// 830BE720: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BE724: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830BE728: 48000058  b 0x830be780
	pc = 0x830BE780; continue 'dispatch;
	// 830BE72C: 4B6EB6ED  bl 0x827a9e18
	ctx.lr = 0x830BE730;
	sub_827A9E18(ctx, base);
	// 830BE730: 81010050  lwz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830BE734: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BE738: 8168000C  lwz r11, 0xc(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) } as u64;
	// 830BE73C: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BE740: 88EA0000  lbz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BE744: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830BE748: 7D274850  subf r9, r7, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[7].s64;
	// 830BE74C: 41820014  beq 0x830be760
	if ctx.cr[0].eq {
	pc = 0x830BE760; continue 'dispatch;
	}
	// 830BE750: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830BE754: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830BE758: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830BE75C: 419AFFE0  beq cr6, 0x830be73c
	if ctx.cr[6].eq {
	pc = 0x830BE73C; continue 'dispatch;
	}
	// 830BE760: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 830BE764: 40800010  bge 0x830be774
	if !ctx.cr[0].lt {
	pc = 0x830BE774; continue 'dispatch;
	}
	// 830BE768: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830BE76C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830BE770: 4BFFFF98  b 0x830be708
	pc = 0x830BE708; continue 'dispatch;
	// 830BE774: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830BE778: 911E0000  stw r8, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 830BE77C: 997E0004  stb r11, 4(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u8 ) };
	// 830BE780: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830BE784: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830BE788: 480E9A28  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BE790(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830BE790 size=132
    let mut pc: u32 = 0x830BE790;
    'dispatch: loop {
        match pc {
            0x830BE790 => {
    //   block [0x830BE790..0x830BE814)
	// 830BE790: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BE794: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830BE798: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830BE79C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830BE7A0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BE7A4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830BE7A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830BE7AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830BE7B0: 4BFF3779  bl 0x830b1f28
	ctx.lr = 0x830BE7B4;
	sub_830B1F28(ctx, base);
	// 830BE7B4: 4BFF394D  bl 0x830b2100
	ctx.lr = 0x830BE7B8;
	sub_830B2100(ctx, base);
	// 830BE7B8: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 830BE7BC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830BE7C0: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 830BE7C4: 4B2715A5  bl 0x8232fd68
	ctx.lr = 0x830BE7C8;
	sub_8232FD68(ctx, base);
	// 830BE7C8: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830BE7CC: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 830BE7D0: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 830BE7D4: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 830BE7D8: 4B271591  bl 0x8232fd68
	ctx.lr = 0x830BE7DC;
	sub_8232FD68(ctx, base);
	// 830BE7DC: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 830BE7E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830BE7E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830BE7E8: 4BFFFE69  bl 0x830be650
	ctx.lr = 0x830BE7EC;
	sub_830BE650(ctx, base);
	// 830BE7EC: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 830BE7F0: 4BFF36E9  bl 0x830b1ed8
	ctx.lr = 0x830BE7F4;
	sub_830B1ED8(ctx, base);
	// 830BE7F4: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 830BE7F8: 4BFF36E1  bl 0x830b1ed8
	ctx.lr = 0x830BE7FC;
	sub_830B1ED8(ctx, base);
	// 830BE7FC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830BE800: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830BE804: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830BE808: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830BE80C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830BE810: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BE818(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BE818 size=8
    let mut pc: u32 = 0x830BE818;
    'dispatch: loop {
        match pc {
            0x830BE818 => {
    //   block [0x830BE818..0x830BE820)
	// 830BE818: 8863003B  lbz r3, 0x3b(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(59 as u32) ) } as u64;
	// 830BE81C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BE820(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BE820 size=12
    let mut pc: u32 = 0x830BE820;
    'dispatch: loop {
        match pc {
            0x830BE820 => {
    //   block [0x830BE820..0x830BE82C)
	// 830BE820: 81630038  lwz r11, 0x38(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) } as u64;
	// 830BE824: 5563C7BE  rlwinm r3, r11, 0x18, 0x1e, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 830BE828: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BE830(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BE830 size=12
    let mut pc: u32 = 0x830BE830;
    'dispatch: loop {
        match pc {
            0x830BE830 => {
    //   block [0x830BE830..0x830BE83C)
	// 830BE830: 81630038  lwz r11, 0x38(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) } as u64;
	// 830BE834: 5563A7BE  rlwinm r3, r11, 0x14, 0x1e, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x00000FFFu64;
	// 830BE838: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BE840(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BE840 size=12
    let mut pc: u32 = 0x830BE840;
    'dispatch: loop {
        match pc {
            0x830BE840 => {
    //   block [0x830BE840..0x830BE84C)
	// 830BE840: 81630038  lwz r11, 0x38(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) } as u64;
	// 830BE844: 5563B7FE  rlwinm r3, r11, 0x16, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000003FFu64;
	// 830BE848: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BE850(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BE850 size=12
    let mut pc: u32 = 0x830BE850;
    'dispatch: loop {
        match pc {
            0x830BE850 => {
    //   block [0x830BE850..0x830BE85C)
	// 830BE850: 81630038  lwz r11, 0x38(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) } as u64;
	// 830BE854: 5563AFFE  rlwinm r3, r11, 0x15, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000007FFu64;
	// 830BE858: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BE860(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BE860 size=12
    let mut pc: u32 = 0x830BE860;
    'dispatch: loop {
        match pc {
            0x830BE860 => {
    //   block [0x830BE860..0x830BE86C)
	// 830BE860: A1630038  lhz r11, 0x38(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) } as u64;
	// 830BE864: 556307BE  clrlwi r3, r11, 0x1e
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	// 830BE868: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BE870(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BE870 size=12
    let mut pc: u32 = 0x830BE870;
    'dispatch: loop {
        match pc {
            0x830BE870 => {
    //   block [0x830BE870..0x830BE87C)
	// 830BE870: 81630038  lwz r11, 0x38(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) } as u64;
	// 830BE874: 556377BE  rlwinm r3, r11, 0xe, 0x1e, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0003FFFFu64;
	// 830BE878: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BE880(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830BE880 size=180
    let mut pc: u32 = 0x830BE880;
    'dispatch: loop {
        match pc {
            0x830BE880 => {
    //   block [0x830BE880..0x830BE934)
	// 830BE880: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BE884: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830BE888: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BE88C: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BE890: 39400048  li r10, 0x48
	ctx.r[10].s64 = 72;
	// 830BE894: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830BE898: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830BE89C: 409A0018  bne cr6, 0x830be8b4
	if !ctx.cr[6].eq {
	pc = 0x830BE8B4; continue 'dispatch;
	}
	// 830BE8A0: 3D608218  lis r11, -0x7de8
	ctx.r[11].s64 = -2112356352;
	// 830BE8A4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830BE8A8: 386B74F8  addi r3, r11, 0x74f8
	ctx.r[3].s64 = ctx.r[11].s64 + 29944;
	// 830BE8AC: 4BFFA2DD  bl 0x830b8b88
	ctx.lr = 0x830BE8B0;
	sub_830B8B88(ctx, base);
	// 830BE8B0: 48000000  b 0x830be8b0
	pc = 0x830BE8B0; continue 'dispatch;
	// 830BE8B4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 830BE8B8: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 830BE8BC: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 830BE8C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830BE8C4: C1AA08A8  lfs f13, 0x8a8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830BE8C8: C00908A4  lfs f0, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BE8CC: D1A30000  stfs f13, 0(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830BE8D0: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830BE8D4: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 830BE8D8: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830BE8DC: D1A30010  stfs f13, 0x10(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 830BE8E0: D0030014  stfs f0, 0x14(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 830BE8E4: 419A001C  beq cr6, 0x830be900
	if ctx.cr[6].eq {
	pc = 0x830BE900; continue 'dispatch;
	}
	// 830BE8E8: D1AB0000  stfs f13, 0(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830BE8EC: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830BE8F0: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 830BE8F4: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830BE8F8: D1AB0010  stfs f13, 0x10(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 830BE8FC: D00B0014  stfs f0, 0x14(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 830BE900: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 830BE904: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830BE908: 419A001C  beq cr6, 0x830be924
	if ctx.cr[6].eq {
	pc = 0x830BE924; continue 'dispatch;
	}
	// 830BE90C: D1AB0000  stfs f13, 0(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830BE910: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830BE914: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 830BE918: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830BE91C: D1AB0010  stfs f13, 0x10(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 830BE920: D00B0014  stfs f0, 0x14(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 830BE924: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830BE928: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830BE92C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830BE930: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BE938(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830BE938 size=208
    let mut pc: u32 = 0x830BE938;
    'dispatch: loop {
        match pc {
            0x830BE938 => {
    //   block [0x830BE938..0x830BEA08)
	// 830BE938: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BE93C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830BE940: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830BE944: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830BE948: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BE94C: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BE950: 39400044  li r10, 0x44
	ctx.r[10].s64 = 68;
	// 830BE954: 39200040  li r9, 0x40
	ctx.r[9].s64 = 64;
	// 830BE958: 7FEB502E  lwzx r31, r11, r10
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830BE95C: 7FCB482E  lwzx r30, r11, r9
	ctx.r[30].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 830BE960: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 830BE964: C01F0004  lfs f0, 4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BE968: EC0000B2  fmuls f0, f0, f2
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[2].f64) as f32) as f64);
	// 830BE96C: C1BF0000  lfs f13, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830BE970: C19F0008  lfs f12, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830BE974: EC0D007A  fmadds f0, f13, f1, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64);
	// 830BE978: EC00602A  fadds f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 830BE97C: D01E0008  stfs f0, 8(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 830BE980: C01F000C  lfs f0, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BE984: C1BF0014  lfs f13, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830BE988: C19F0010  lfs f12, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830BE98C: ED8C00B2  fmuls f12, f12, f2
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[2].f64) as f32) as f64);
	// 830BE990: EC00607A  fmadds f0, f0, f1, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[1].f64 + ctx.f[12].f64) as f32) as f64);
	// 830BE994: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 830BE998: D01E0014  stfs f0, 0x14(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 830BE99C: 419A0054  beq cr6, 0x830be9f0
	if ctx.cr[6].eq {
	pc = 0x830BE9F0; continue 'dispatch;
	}
	// 830BE9A0: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BE9A4: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830BE9A8: C01F0004  lfs f0, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BE9AC: D01E0004  stfs f0, 4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830BE9B0: C01F000C  lfs f0, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BE9B4: D01E000C  stfs f0, 0xc(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830BE9B8: C01F0010  lfs f0, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BE9BC: D01E0010  stfs f0, 0x10(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 830BE9C0: 807E001C  lwz r3, 0x1c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 830BE9C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830BE9C8: 419A0010  beq cr6, 0x830be9d8
	if ctx.cr[6].eq {
	pc = 0x830BE9D8; continue 'dispatch;
	}
	// 830BE9CC: 38A00018  li r5, 0x18
	ctx.r[5].s64 = 24;
	// 830BE9D0: 809F001C  lwz r4, 0x1c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 830BE9D4: 480E9B3D  bl 0x831a8510
	ctx.lr = 0x830BE9D8;
	sub_831A8510(ctx, base);
	// 830BE9D8: 807E0018  lwz r3, 0x18(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 830BE9DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830BE9E0: 419A0010  beq cr6, 0x830be9f0
	if ctx.cr[6].eq {
	pc = 0x830BE9F0; continue 'dispatch;
	}
	// 830BE9E4: 38A00018  li r5, 0x18
	ctx.r[5].s64 = 24;
	// 830BE9E8: 809F0018  lwz r4, 0x18(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830BE9EC: 480E9B25  bl 0x831a8510
	ctx.lr = 0x830BE9F0;
	sub_831A8510(ctx, base);
	// 830BE9F0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830BE9F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830BE9F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830BE9FC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830BEA00: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830BEA04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BEA08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830BEA08 size=36
    let mut pc: u32 = 0x830BEA08;
    'dispatch: loop {
        match pc {
            0x830BEA08 => {
    //   block [0x830BEA08..0x830BEA2C)
	// 830BEA08: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BEA0C: 39600040  li r11, 0x40
	ctx.r[11].s64 = 64;
	// 830BEA10: 39200044  li r9, 0x44
	ctx.r[9].s64 = 68;
	// 830BEA14: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830BEA18: 7D4A482E  lwzx r10, r10, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 830BEA1C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830BEA20: D02B0008  stfs f1, 8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 830BEA24: D04B0014  stfs f2, 0x14(r11)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 830BEA28: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BEA2C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830BEA2C size=116
    let mut pc: u32 = 0x830BEA2C;
    'dispatch: loop {
        match pc {
            0x830BEA2C => {
    //   block [0x830BEA2C..0x830BEAA0)
	// 830BEA2C: C00A0000  lfs f0, 0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BEA30: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830BEA34: C00A0004  lfs f0, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BEA38: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830BEA3C: C00A000C  lfs f0, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BEA40: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830BEA44: C00A0010  lfs f0, 0x10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BEA48: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 830BEA4C: 812B001C  lwz r9, 0x1c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 830BEA50: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 830BEA54: 419A0040  beq cr6, 0x830bea94
	if ctx.cr[6].eq {
	pc = 0x830BEA94; continue 'dispatch;
	}
	// 830BEA58: 810A001C  lwz r8, 0x1c(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 830BEA5C: C0080000  lfs f0, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BEA60: D0090000  stfs f0, 0(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830BEA64: 812A001C  lwz r9, 0x1c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 830BEA68: C0090004  lfs f0, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BEA6C: 812B001C  lwz r9, 0x1c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 830BEA70: D0090004  stfs f0, 4(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830BEA74: 812A001C  lwz r9, 0x1c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 830BEA78: C009000C  lfs f0, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BEA7C: 812B001C  lwz r9, 0x1c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 830BEA80: D009000C  stfs f0, 0xc(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830BEA84: 812A001C  lwz r9, 0x1c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 830BEA88: C0090010  lfs f0, 0x10(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BEA8C: 812B001C  lwz r9, 0x1c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 830BEA90: D0090010  stfs f0, 0x10(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 830BEA94: 812B0018  lwz r9, 0x18(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 830BEA98: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 830BEA9C: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BEAA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830BEAA0 size=64
    let mut pc: u32 = 0x830BEAA0;
    'dispatch: loop {
        match pc {
            0x830BEAA0 => {
    //   block [0x830BEAA0..0x830BEAE0)
	// 830BEAA0: 810A0018  lwz r8, 0x18(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 830BEAA4: C0080000  lfs f0, 0(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BEAA8: D0090000  stfs f0, 0(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830BEAAC: 810B0018  lwz r8, 0x18(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 830BEAB0: 812A0018  lwz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 830BEAB4: C0090004  lfs f0, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BEAB8: D0080004  stfs f0, 4(r8)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830BEABC: 810A0018  lwz r8, 0x18(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 830BEAC0: C008000C  lfs f0, 0xc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BEAC4: 812B0018  lwz r9, 0x18(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 830BEAC8: D009000C  stfs f0, 0xc(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830BEACC: 814A0018  lwz r10, 0x18(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 830BEAD0: C00A0010  lfs f0, 0x10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BEAD4: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 830BEAD8: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 830BEADC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BEAE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830BEAE0 size=48
    let mut pc: u32 = 0x830BEAE0;
    'dispatch: loop {
        match pc {
            0x830BEAE0 => {
    //   block [0x830BEAE0..0x830BEB10)
	// 830BEAE0: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BEAE4: 39600040  li r11, 0x40
	ctx.r[11].s64 = 64;
	// 830BEAE8: 39200044  li r9, 0x44
	ctx.r[9].s64 = 68;
	// 830BEAEC: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830BEAF0: 7D4A482E  lwzx r10, r10, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 830BEAF4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830BEAF8: D02B0008  stfs f1, 8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 830BEAFC: C00A0010  lfs f0, 0x10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BEB00: C1AA0014  lfs f13, 0x14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830BEB04: EC0068BA  fmadds f0, f0, f2, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[2].f64 + ctx.f[13].f64) as f32) as f64);
	// 830BEB08: D00B0014  stfs f0, 0x14(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 830BEB0C: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BEB10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830BEB10 size=116
    let mut pc: u32 = 0x830BEB10;
    'dispatch: loop {
        match pc {
            0x830BEB10 => {
    //   block [0x830BEB10..0x830BEB84)
	// 830BEB10: C00A0000  lfs f0, 0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BEB14: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830BEB18: C00A0004  lfs f0, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BEB1C: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830BEB20: C00A000C  lfs f0, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BEB24: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830BEB28: C00A0010  lfs f0, 0x10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BEB2C: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 830BEB30: 812B001C  lwz r9, 0x1c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 830BEB34: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 830BEB38: 419A0040  beq cr6, 0x830beb78
	if ctx.cr[6].eq {
	pc = 0x830BEB78; continue 'dispatch;
	}
	// 830BEB3C: 810A001C  lwz r8, 0x1c(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 830BEB40: C0080000  lfs f0, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BEB44: D0090000  stfs f0, 0(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830BEB48: 812A001C  lwz r9, 0x1c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 830BEB4C: C0090004  lfs f0, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BEB50: 812B001C  lwz r9, 0x1c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 830BEB54: D0090004  stfs f0, 4(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830BEB58: 812A001C  lwz r9, 0x1c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 830BEB5C: C009000C  lfs f0, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BEB60: 812B001C  lwz r9, 0x1c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 830BEB64: D009000C  stfs f0, 0xc(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830BEB68: 812A001C  lwz r9, 0x1c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 830BEB6C: C0090010  lfs f0, 0x10(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BEB70: 812B001C  lwz r9, 0x1c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 830BEB74: D0090010  stfs f0, 0x10(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 830BEB78: 812B0018  lwz r9, 0x18(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 830BEB7C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 830BEB80: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BEB84(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830BEB84 size=64
    let mut pc: u32 = 0x830BEB84;
    'dispatch: loop {
        match pc {
            0x830BEB84 => {
    //   block [0x830BEB84..0x830BEBC4)
	// 830BEB84: 810A0018  lwz r8, 0x18(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 830BEB88: C0080000  lfs f0, 0(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BEB8C: D0090000  stfs f0, 0(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830BEB90: 810B0018  lwz r8, 0x18(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 830BEB94: 812A0018  lwz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 830BEB98: C0090004  lfs f0, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BEB9C: D0080004  stfs f0, 4(r8)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830BEBA0: 810A0018  lwz r8, 0x18(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 830BEBA4: C008000C  lfs f0, 0xc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BEBA8: 812B0018  lwz r9, 0x18(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 830BEBAC: D009000C  stfs f0, 0xc(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830BEBB0: 814A0018  lwz r10, 0x18(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 830BEBB4: C00A0010  lfs f0, 0x10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BEBB8: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 830BEBBC: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 830BEBC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BEBC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830BEBC8 size=48
    let mut pc: u32 = 0x830BEBC8;
    'dispatch: loop {
        match pc {
            0x830BEBC8 => {
    //   block [0x830BEBC8..0x830BEBF8)
	// 830BEBC8: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BEBCC: 39400044  li r10, 0x44
	ctx.r[10].s64 = 68;
	// 830BEBD0: 39200040  li r9, 0x40
	ctx.r[9].s64 = 64;
	// 830BEBD4: 7D4B502E  lwzx r10, r11, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830BEBD8: 7D6B482E  lwzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 830BEBDC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830BEBE0: C00A0000  lfs f0, 0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BEBE4: C1AA0008  lfs f13, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830BEBE8: EC00687A  fmadds f0, f0, f1, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[1].f64 + ctx.f[13].f64) as f32) as f64);
	// 830BEBEC: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 830BEBF0: D04B0014  stfs f2, 0x14(r11)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 830BEBF4: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BEBF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830BEBF8 size=116
    let mut pc: u32 = 0x830BEBF8;
    'dispatch: loop {
        match pc {
            0x830BEBF8 => {
    //   block [0x830BEBF8..0x830BEC6C)
	// 830BEBF8: C00A0000  lfs f0, 0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BEBFC: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830BEC00: C00A0004  lfs f0, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BEC04: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830BEC08: C00A000C  lfs f0, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BEC0C: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830BEC10: C00A0010  lfs f0, 0x10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BEC14: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 830BEC18: 812B001C  lwz r9, 0x1c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 830BEC1C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 830BEC20: 419A0040  beq cr6, 0x830bec60
	if ctx.cr[6].eq {
	pc = 0x830BEC60; continue 'dispatch;
	}
	// 830BEC24: 810A001C  lwz r8, 0x1c(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 830BEC28: C0080000  lfs f0, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BEC2C: D0090000  stfs f0, 0(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830BEC30: 812A001C  lwz r9, 0x1c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 830BEC34: C0090004  lfs f0, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BEC38: 812B001C  lwz r9, 0x1c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 830BEC3C: D0090004  stfs f0, 4(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830BEC40: 812A001C  lwz r9, 0x1c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 830BEC44: C009000C  lfs f0, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BEC48: 812B001C  lwz r9, 0x1c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 830BEC4C: D009000C  stfs f0, 0xc(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830BEC50: 812A001C  lwz r9, 0x1c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 830BEC54: C0090010  lfs f0, 0x10(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BEC58: 812B001C  lwz r9, 0x1c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 830BEC5C: D0090010  stfs f0, 0x10(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 830BEC60: 812B0018  lwz r9, 0x18(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 830BEC64: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 830BEC68: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BEC6C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830BEC6C size=64
    let mut pc: u32 = 0x830BEC6C;
    'dispatch: loop {
        match pc {
            0x830BEC6C => {
    //   block [0x830BEC6C..0x830BECAC)
	// 830BEC6C: 810A0018  lwz r8, 0x18(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 830BEC70: C0080000  lfs f0, 0(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BEC74: D0090000  stfs f0, 0(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830BEC78: 810B0018  lwz r8, 0x18(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 830BEC7C: 812A0018  lwz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 830BEC80: C0090004  lfs f0, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BEC84: D0080004  stfs f0, 4(r8)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830BEC88: 810A0018  lwz r8, 0x18(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 830BEC8C: C008000C  lfs f0, 0xc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BEC90: 812B0018  lwz r9, 0x18(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 830BEC94: D009000C  stfs f0, 0xc(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830BEC98: 814A0018  lwz r10, 0x18(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 830BEC9C: C00A0010  lfs f0, 0x10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BECA0: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 830BECA4: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 830BECA8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BECB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830BECB0 size=352
    let mut pc: u32 = 0x830BECB0;
    'dispatch: loop {
        match pc {
            0x830BECB0 => {
    //   block [0x830BECB0..0x830BEE10)
	// 830BECB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BECB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830BECB8: DBC1FFE8  stfd f30, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[30].u64 ) };
	// 830BECBC: DBE1FFF0  stfd f31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[31].u64 ) };
	// 830BECC0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BECC4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 830BECC8: C00BCEE4  lfs f0, -0x311c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12572 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BECCC: EFC10032  fmuls f30, f1, f0
	ctx.f[30].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 830BECD0: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 830BECD4: 480EA1D5  bl 0x831a8ea8
	ctx.lr = 0x830BECD8;
	sub_831A8EA8(ctx, base);
	// 830BECD8: FFE00818  frsp f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = (ctx.f[1].f64 as f32) as f64;
	// 830BECDC: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 830BECE0: 480EA0E9  bl 0x831a8dc8
	ctx.lr = 0x830BECE4;
	sub_831A8DC8(ctx, base);
	// 830BECE4: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 830BECE8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 830BECEC: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BECF0: 39200044  li r9, 0x44
	ctx.r[9].s64 = 68;
	// 830BECF4: 39000040  li r8, 0x40
	ctx.r[8].s64 = 64;
	// 830BECF8: C1AB9534  lfs f13, -0x6acc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830BECFC: 7D6A482E  lwzx r11, r10, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 830BED00: 7D4A402E  lwzx r10, r10, r8
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 830BED04: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 830BED08: C18B0004  lfs f12, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830BED0C: C16B0000  lfs f11, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830BED10: ED4B0032  fmuls f10, f11, f0
	ctx.f[10].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 830BED14: C12B000C  lfs f9, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 830BED18: ED290032  fmuls f9, f9, f0
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 830BED1C: ED8C0372  fmuls f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 830BED20: ED8B67FA  fmadds f12, f11, f31, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 * ctx.f[31].f64 + ctx.f[12].f64) as f32) as f64);
	// 830BED24: D18A0000  stfs f12, 0(r10)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830BED28: C18B0004  lfs f12, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830BED2C: ED8C57FA  fmadds f12, f12, f31, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[31].f64 + ctx.f[10].f64) as f32) as f64);
	// 830BED30: D18A0004  stfs f12, 4(r10)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830BED34: C18B0008  lfs f12, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830BED38: D18A0008  stfs f12, 8(r10)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 830BED3C: C18B000C  lfs f12, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830BED40: C16B0010  lfs f11, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830BED44: ED6B0372  fmuls f11, f11, f13
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 830BED48: ED8C5FFA  fmadds f12, f12, f31, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[31].f64 + ctx.f[11].f64) as f32) as f64);
	// 830BED4C: D18A000C  stfs f12, 0xc(r10)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830BED50: C18B0010  lfs f12, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830BED54: ED8C4FFA  fmadds f12, f12, f31, f9
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[31].f64 + ctx.f[9].f64) as f32) as f64);
	// 830BED58: D18A0010  stfs f12, 0x10(r10)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 830BED5C: C18B0014  lfs f12, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830BED60: D18A0014  stfs f12, 0x14(r10)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 830BED64: 812A001C  lwz r9, 0x1c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 830BED68: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 830BED6C: 419A006C  beq cr6, 0x830bedd8
	if ctx.cr[6].eq {
	pc = 0x830BEDD8; continue 'dispatch;
	}
	// 830BED70: 810B001C  lwz r8, 0x1c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 830BED74: C1880000  lfs f12, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830BED78: ED6C07F2  fmuls f11, f12, f31
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[31].f64) as f32) as f64);
	// 830BED7C: C1480004  lfs f10, 4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 830BED80: C128000C  lfs f9, 0xc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 830BED84: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 830BED88: EC090032  fmuls f0, f9, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 830BED8C: ED6A5B7A  fmadds f11, f10, f13, f11
	ctx.f[11].f64 = (((ctx.f[10].f64 * ctx.f[13].f64 + ctx.f[11].f64) as f32) as f64);
	// 830BED90: D1690000  stfs f11, 0(r9)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830BED94: 812B001C  lwz r9, 0x1c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 830BED98: 810A001C  lwz r8, 0x1c(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 830BED9C: C1690004  lfs f11, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830BEDA0: ED8B67FA  fmadds f12, f11, f31, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 * ctx.f[31].f64 + ctx.f[12].f64) as f32) as f64);
	// 830BEDA4: D1880004  stfs f12, 4(r8)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830BEDA8: 812B001C  lwz r9, 0x1c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 830BEDAC: 810A001C  lwz r8, 0x1c(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 830BEDB0: C1890010  lfs f12, 0x10(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830BEDB4: C169000C  lfs f11, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830BEDB8: ED6B07F2  fmuls f11, f11, f31
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[31].f64) as f32) as f64);
	// 830BEDBC: EDAC5B7A  fmadds f13, f12, f13, f11
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64 + ctx.f[11].f64) as f32) as f64);
	// 830BEDC0: D1A8000C  stfs f13, 0xc(r8)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830BEDC4: 812B001C  lwz r9, 0x1c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 830BEDC8: 810A001C  lwz r8, 0x1c(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 830BEDCC: C1A90010  lfs f13, 0x10(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830BEDD0: EC0D07FA  fmadds f0, f13, f31, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64);
	// 830BEDD4: D0080010  stfs f0, 0x10(r8)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 830BEDD8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830BEDDC: 419A001C  beq cr6, 0x830bedf8
	if ctx.cr[6].eq {
	pc = 0x830BEDF8; continue 'dispatch;
	}
	// 830BEDE0: 806A0018  lwz r3, 0x18(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 830BEDE4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830BEDE8: 419A0010  beq cr6, 0x830bedf8
	if ctx.cr[6].eq {
	pc = 0x830BEDF8; continue 'dispatch;
	}
	// 830BEDEC: 38A00018  li r5, 0x18
	ctx.r[5].s64 = 24;
	// 830BEDF0: 808B0018  lwz r4, 0x18(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 830BEDF4: 480E971D  bl 0x831a8510
	ctx.lr = 0x830BEDF8;
	sub_831A8510(ctx, base);
	// 830BEDF8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830BEDFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830BEE00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830BEE04: CBC1FFE8  lfd f30, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830BEE08: CBE1FFF0  lfd f31, -0x10(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830BEE0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BEE10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830BEE10 size=164
    let mut pc: u32 = 0x830BEE10;
    'dispatch: loop {
        match pc {
            0x830BEE10 => {
    //   block [0x830BEE10..0x830BEEB4)
	// 830BEE10: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BEE14: 39400044  li r10, 0x44
	ctx.r[10].s64 = 68;
	// 830BEE18: 39200040  li r9, 0x40
	ctx.r[9].s64 = 64;
	// 830BEE1C: 7D4B502E  lwzx r10, r11, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830BEE20: 7D6B482E  lwzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 830BEE24: C00A0000  lfs f0, 0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BEE28: EC000072  fmuls f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 830BEE2C: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830BEE30: C00A0004  lfs f0, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BEE34: EC0000B2  fmuls f0, f0, f2
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[2].f64) as f32) as f64);
	// 830BEE38: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830BEE3C: C00A000C  lfs f0, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BEE40: EC000072  fmuls f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 830BEE44: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830BEE48: C00A0010  lfs f0, 0x10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BEE4C: EC0000B2  fmuls f0, f0, f2
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[2].f64) as f32) as f64);
	// 830BEE50: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 830BEE54: 812B0018  lwz r9, 0x18(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 830BEE58: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 830BEE5C: 419A0050  beq cr6, 0x830beeac
	if ctx.cr[6].eq {
	pc = 0x830BEEAC; continue 'dispatch;
	}
	// 830BEE60: 810A0018  lwz r8, 0x18(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 830BEE64: C0080000  lfs f0, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BEE68: EC000072  fmuls f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 830BEE6C: D0090000  stfs f0, 0(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830BEE70: 812A0018  lwz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 830BEE74: 810B0018  lwz r8, 0x18(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 830BEE78: C0090004  lfs f0, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BEE7C: EC0000B2  fmuls f0, f0, f2
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[2].f64) as f32) as f64);
	// 830BEE80: D0080004  stfs f0, 4(r8)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830BEE84: 812A0018  lwz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 830BEE88: 810B0018  lwz r8, 0x18(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 830BEE8C: C009000C  lfs f0, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BEE90: EC000072  fmuls f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 830BEE94: D008000C  stfs f0, 0xc(r8)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830BEE98: 812A0018  lwz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 830BEE9C: C0090010  lfs f0, 0x10(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BEEA0: 812B0018  lwz r9, 0x18(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 830BEEA4: EC0000B2  fmuls f0, f0, f2
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[2].f64) as f32) as f64);
	// 830BEEA8: D0090010  stfs f0, 0x10(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 830BEEAC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830BEEB0: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BEEB4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830BEEB4 size=28
    let mut pc: u32 = 0x830BEEB4;
    'dispatch: loop {
        match pc {
            0x830BEEB4 => {
    //   block [0x830BEEB4..0x830BEED0)
	// 830BEEB4: C00A0008  lfs f0, 8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BEEB8: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 830BEEBC: C00A0014  lfs f0, 0x14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830BEEC0: D00B0014  stfs f0, 0x14(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 830BEEC4: 806B001C  lwz r3, 0x1c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 830BEEC8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830BEECC: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BEED0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BEED0 size=12
    let mut pc: u32 = 0x830BEED0;
    'dispatch: loop {
        match pc {
            0x830BEED0 => {
    //   block [0x830BEED0..0x830BEEDC)
	// 830BEED0: 808A001C  lwz r4, 0x1c(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 830BEED4: 38A00018  li r5, 0x18
	ctx.r[5].s64 = 24;
	// 830BEED8: 480E9638  b 0x831a8510
	sub_831A8510(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BEEDC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BEEDC size=4
    let mut pc: u32 = 0x830BEEDC;
    'dispatch: loop {
        match pc {
            0x830BEEDC => {
    //   block [0x830BEEDC..0x830BEEE0)
	// 830BEEDC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BEEE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830BEEE0 size=104
    let mut pc: u32 = 0x830BEEE0;
    'dispatch: loop {
        match pc {
            0x830BEEE0 => {
    //   block [0x830BEEE0..0x830BEF48)
	// 830BEEE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BEEE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830BEEE8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830BEEEC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830BEEF0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BEEF4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830BEEF8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830BEEFC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BEF00: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830BEF04: 419A0008  beq cr6, 0x830bef0c
	if ctx.cr[6].eq {
	pc = 0x830BEF0C; continue 'dispatch;
	}
	// 830BEF08: 4B201361  bl 0x822c0268
	ctx.lr = 0x830BEF0C;
	sub_822C0268(ctx, base);
	// 830BEF0C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830BEF10: 57CA07FF  clrlwi. r10, r30, 0x1f
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830BEF14: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830BEF18: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830BEF1C: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 830BEF20: 4182000C  beq 0x830bef2c
	if ctx.cr[0].eq {
	pc = 0x830BEF2C; continue 'dispatch;
	}
	// 830BEF24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BEF28: 4B201341  bl 0x822c0268
	ctx.lr = 0x830BEF2C;
	sub_822C0268(ctx, base);
	// 830BEF2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BEF30: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830BEF34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830BEF38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830BEF3C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830BEF40: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830BEF44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BEF48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830BEF48 size=104
    let mut pc: u32 = 0x830BEF48;
    'dispatch: loop {
        match pc {
            0x830BEF48 => {
    //   block [0x830BEF48..0x830BEFB0)
	// 830BEF48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BEF4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830BEF50: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BEF54: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BEF58: 39400048  li r10, 0x48
	ctx.r[10].s64 = 72;
	// 830BEF5C: 7D4A582E  lwzx r10, r10, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830BEF60: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830BEF64: 409A0018  bne cr6, 0x830bef7c
	if !ctx.cr[6].eq {
	pc = 0x830BEF7C; continue 'dispatch;
	}
	// 830BEF68: 3D608218  lis r11, -0x7de8
	ctx.r[11].s64 = -2112356352;
	// 830BEF6C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830BEF70: 386B74F8  addi r3, r11, 0x74f8
	ctx.r[3].s64 = ctx.r[11].s64 + 29944;
	// 830BEF74: 4BFF9C15  bl 0x830b8b88
	ctx.lr = 0x830BEF78;
	sub_830B8B88(ctx, base);
	// 830BEF78: 48000000  b 0x830bef78
	pc = 0x830BEF78; continue 'dispatch;
	// 830BEF7C: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BEF80: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 830BEF84: 419A001C  beq cr6, 0x830befa0
	if ctx.cr[6].eq {
	pc = 0x830BEFA0; continue 'dispatch;
	}
	// 830BEF88: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 830BEF8C: 7D295850  subf r9, r9, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 830BEF90: 7D291671  srawi. r9, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830BEF94: 4182000C  beq 0x830befa0
	if ctx.cr[0].eq {
	pc = 0x830BEFA0; continue 'dispatch;
	}
	// 830BEF98: 396BFFFC  addi r11, r11, -4
	ctx.r[11].s64 = ctx.r[11].s64 + -4;
	// 830BEF9C: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830BEFA0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830BEFA4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830BEFA8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830BEFAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BEFB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830BEFB0 size=84
    let mut pc: u32 = 0x830BEFB0;
    'dispatch: loop {
        match pc {
            0x830BEFB0 => {
    //   block [0x830BEFB0..0x830BF004)
	// 830BEFB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BEFB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830BEFB8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BEFBC: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BEFC0: 39400048  li r10, 0x48
	ctx.r[10].s64 = 72;
	// 830BEFC4: 7D4B502E  lwzx r10, r11, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830BEFC8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830BEFCC: 409A0018  bne cr6, 0x830befe4
	if !ctx.cr[6].eq {
	pc = 0x830BEFE4; continue 'dispatch;
	}
	// 830BEFD0: 3D608218  lis r11, -0x7de8
	ctx.r[11].s64 = -2112356352;
	// 830BEFD4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830BEFD8: 386B74F8  addi r3, r11, 0x74f8
	ctx.r[3].s64 = ctx.r[11].s64 + 29944;
	// 830BEFDC: 4BFF9BAD  bl 0x830b8b88
	ctx.lr = 0x830BEFE0;
	sub_830B8B88(ctx, base);
	// 830BEFE0: 48000000  b 0x830befe0
	pc = 0x830BEFE0; continue 'dispatch;
	// 830BEFE4: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 830BEFE8: 39200044  li r9, 0x44
	ctx.r[9].s64 = 68;
	// 830BEFEC: 814AFFFC  lwz r10, -4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-4 as u32) ) } as u64;
	// 830BEFF0: 7D4B492E  stwx r10, r11, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u32) };
	// 830BEFF4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830BEFF8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830BEFFC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830BF000: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BF008(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830BF008 size=76
    let mut pc: u32 = 0x830BF008;
    'dispatch: loop {
        match pc {
            0x830BF008 => {
    //   block [0x830BF008..0x830BF054)
	// 830BF008: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BF00C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830BF010: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BF014: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BF018: 39400048  li r10, 0x48
	ctx.r[10].s64 = 72;
	// 830BF01C: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830BF020: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830BF024: 409A0018  bne cr6, 0x830bf03c
	if !ctx.cr[6].eq {
	pc = 0x830BF03C; continue 'dispatch;
	}
	// 830BF028: 3D608218  lis r11, -0x7de8
	ctx.r[11].s64 = -2112356352;
	// 830BF02C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830BF030: 386B74F8  addi r3, r11, 0x74f8
	ctx.r[3].s64 = ctx.r[11].s64 + 29944;
	// 830BF034: 4BFF9B55  bl 0x830b8b88
	ctx.lr = 0x830BF038;
	sub_830B8B88(ctx, base);
	// 830BF038: 48000000  b 0x830bf038
	pc = 0x830BF038; continue 'dispatch;
	// 830BF03C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830BF040: 806BFFFC  lwz r3, -4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 830BF044: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830BF048: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830BF04C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830BF050: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BF058(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830BF058 size=112
    let mut pc: u32 = 0x830BF058;
    'dispatch: loop {
        match pc {
            0x830BF058 => {
    //   block [0x830BF058..0x830BF0C8)
	// 830BF058: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BF05C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830BF060: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830BF064: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830BF068: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BF06C: 83ED0000  lwz r31, 0(r13)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BF070: 3BC00048  li r30, 0x48
	ctx.r[30].s64 = 72;
	// 830BF074: 7C7FF02E  lwzx r3, r31, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 830BF078: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830BF07C: 419A0014  beq cr6, 0x830bf090
	if ctx.cr[6].eq {
	pc = 0x830BF090; continue 'dispatch;
	}
	// 830BF080: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830BF084: 4BFFFE5D  bl 0x830beee0
	ctx.lr = 0x830BF088;
	sub_830BEEE0(ctx, base);
	// 830BF088: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830BF08C: 7D7FF12E  stwx r11, r31, r30
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32), ctx.r[11].u32) };
	// 830BF090: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 830BF094: 396B0018  addi r11, r11, 0x18
	ctx.r[11].s64 = ctx.r[11].s64 + 24;
	// 830BF098: 7C7F582E  lwzx r3, r31, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830BF09C: 4BFF5BE5  bl 0x830b4c80
	ctx.lr = 0x830BF0A0;
	sub_830B4C80(ctx, base);
	// 830BF0A0: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 830BF0A4: 396B001C  addi r11, r11, 0x1c
	ctx.r[11].s64 = ctx.r[11].s64 + 28;
	// 830BF0A8: 7C7F582E  lwzx r3, r31, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830BF0AC: 4BFF5BD5  bl 0x830b4c80
	ctx.lr = 0x830BF0B0;
	sub_830B4C80(ctx, base);
	// 830BF0B0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830BF0B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830BF0B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830BF0BC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830BF0C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830BF0C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BF0C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830BF0C8 size=736
    let mut pc: u32 = 0x830BF0C8;
    'dispatch: loop {
        match pc {
            0x830BF0C8 => {
    //   block [0x830BF0C8..0x830BF3A8)
	// 830BF0C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BF0CC: 480E9091  bl 0x831a815c
	ctx.lr = 0x830BF0D0;
	sub_831A8130(ctx, base);
	// 830BF0D0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BF0D4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830BF0D8: 83260000  lwz r25, 0(r6)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BF0DC: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 830BF0E0: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 830BF0E4: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BF0E8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830BF0EC: 409A000C  bne cr6, 0x830bf0f8
	if !ctx.cr[6].eq {
	pc = 0x830BF0F8; continue 'dispatch;
	}
	// 830BF0F0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 830BF0F4: 48000010  b 0x830bf104
	pc = 0x830BF104; continue 'dispatch;
	// 830BF0F8: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 830BF0FC: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 830BF100: 7D681670  srawi r8, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 830BF104: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 830BF108: 419A0298  beq cr6, 0x830bf3a0
	if ctx.cr[6].eq {
	pc = 0x830BF3A0; continue 'dispatch;
	}
	// 830BF10C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830BF110: 409A000C  bne cr6, 0x830bf11c
	if !ctx.cr[6].eq {
	pc = 0x830BF11C; continue 'dispatch;
	}
	// 830BF114: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830BF118: 48000010  b 0x830bf128
	pc = 0x830BF128; continue 'dispatch;
	// 830BF11C: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 830BF120: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 830BF124: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 830BF128: 3D203FFF  lis r9, 0x3fff
	ctx.r[9].s64 = 1073676288;
	// 830BF12C: 6129FFFF  ori r9, r9, 0xffff
	ctx.r[9].u64 = ctx.r[9].u64 | 65535;
	// 830BF130: 7D6B4850  subf r11, r11, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 830BF134: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 830BF138: 4098000C  bge cr6, 0x830bf144
	if !ctx.cr[6].lt {
	pc = 0x830BF144; continue 'dispatch;
	}
	// 830BF13C: 4BAF8BE5  bl 0x82bb7d20
	ctx.lr = 0x830BF140;
	sub_82BB7D20(ctx, base);
	// 830BF140: 48000260  b 0x830bf3a0
	pc = 0x830BF3A0; continue 'dispatch;
	// 830BF144: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830BF148: 409A000C  bne cr6, 0x830bf154
	if !ctx.cr[6].eq {
	pc = 0x830BF154; continue 'dispatch;
	}
	// 830BF14C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830BF150: 48000010  b 0x830bf160
	pc = 0x830BF160; continue 'dispatch;
	// 830BF154: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 830BF158: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 830BF15C: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 830BF160: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 830BF164: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830BF168: 40980130  bge cr6, 0x830bf298
	if !ctx.cr[6].lt {
	pc = 0x830BF298; continue 'dispatch;
	}
	// 830BF16C: 550BF87E  srwi r11, r8, 1
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830BF170: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 830BF174: 7D2B4850  subf r9, r11, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 830BF178: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 830BF17C: 41980008  blt cr6, 0x830bf184
	if ctx.cr[6].lt {
	pc = 0x830BF184; continue 'dispatch;
	}
	// 830BF180: 7F6B4214  add r27, r11, r8
	ctx.r[27].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 830BF184: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830BF188: 409A000C  bne cr6, 0x830bf194
	if !ctx.cr[6].eq {
	pc = 0x830BF194; continue 'dispatch;
	}
	// 830BF18C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830BF190: 48000010  b 0x830bf1a0
	pc = 0x830BF1A0; continue 'dispatch;
	// 830BF194: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 830BF198: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 830BF19C: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 830BF1A0: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 830BF1A4: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830BF1A8: 40980024  bge cr6, 0x830bf1cc
	if !ctx.cr[6].lt {
	pc = 0x830BF1CC; continue 'dispatch;
	}
	// 830BF1AC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830BF1B0: 409A000C  bne cr6, 0x830bf1bc
	if !ctx.cr[6].eq {
	pc = 0x830BF1BC; continue 'dispatch;
	}
	// 830BF1B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830BF1B8: 48000010  b 0x830bf1c8
	pc = 0x830BF1C8; continue 'dispatch;
	// 830BF1BC: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 830BF1C0: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 830BF1C4: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 830BF1C8: 7F6BE214  add r27, r11, r28
	ctx.r[27].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 830BF1CC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830BF1D0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830BF1D4: 4B92EC95  bl 0x829ede68
	ctx.lr = 0x830BF1D8;
	sub_829EDE68(ctx, base);
	// 830BF1D8: 80BD0004  lwz r5, 4(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BF1DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830BF1E0: 7D65D050  subf r11, r5, r26
	ctx.r[11].s64 = ctx.r[26].s64 - ctx.r[5].s64;
	// 830BF1E4: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BF1E8: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 830BF1EC: 7FC6FA14  add r30, r6, r31
	ctx.r[30].u64 = ctx.r[6].u64 + ctx.r[31].u64;
	// 830BF1F0: 4182000C  beq 0x830bf1fc
	if ctx.cr[0].eq {
	pc = 0x830BF1FC; continue 'dispatch;
	}
	// 830BF1F4: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 830BF1F8: 480E9B11  bl 0x831a8d08
	ctx.lr = 0x830BF1FC;
	sub_831A8D08(ctx, base);
	// 830BF1FC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 830BF200: 419A0020  beq cr6, 0x830bf220
	if ctx.cr[6].eq {
	pc = 0x830BF220; continue 'dispatch;
	}
	// 830BF204: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 830BF208: 281C0000  cmplwi r28, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830BF20C: 41820014  beq 0x830bf220
	if ctx.cr[0].eq {
	pc = 0x830BF220; continue 'dispatch;
	}
	// 830BF210: 7F8903A6  mtctr r28
	ctx.ctr.u64 = ctx.r[28].u64;
	// 830BF214: 932B0000  stw r25, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 830BF218: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 830BF21C: 4200FFF8  bdnz 0x830bf214
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x830BF214; continue 'dispatch;
	}
	// 830BF220: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 830BF224: 7D7A5850  subf r11, r26, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[26].s64;
	// 830BF228: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BF22C: 4182001C  beq 0x830bf248
	if ctx.cr[0].eq {
	pc = 0x830BF248; continue 'dispatch;
	}
	// 830BF230: 5564103A  slwi r4, r11, 2
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 830BF234: 578B103A  slwi r11, r28, 2
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830BF238: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 830BF23C: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 830BF240: 7C6BF214  add r3, r11, r30
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 830BF244: 480E9AC5  bl 0x831a8d08
	ctx.lr = 0x830BF248;
	sub_831A8D08(ctx, base);
	// 830BF248: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BF24C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830BF250: 409A000C  bne cr6, 0x830bf25c
	if !ctx.cr[6].eq {
	pc = 0x830BF25C; continue 'dispatch;
	}
	// 830BF254: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830BF258: 48000010  b 0x830bf268
	pc = 0x830BF268; continue 'dispatch;
	// 830BF25C: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 830BF260: 7D635850  subf r11, r3, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 830BF264: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 830BF268: 7FCBE214  add r30, r11, r28
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 830BF26C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830BF270: 419A0008  beq cr6, 0x830bf278
	if ctx.cr[6].eq {
	pc = 0x830BF278; continue 'dispatch;
	}
	// 830BF274: 4B200FF5  bl 0x822c0268
	ctx.lr = 0x830BF278;
	sub_822C0268(ctx, base);
	// 830BF278: 576B103A  slwi r11, r27, 2
	ctx.r[11].u32 = ctx.r[27].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830BF27C: 93FD0004  stw r31, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 830BF280: 57CA103A  slwi r10, r30, 2
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830BF284: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 830BF288: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 830BF28C: 917D000C  stw r11, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 830BF290: 915D0008  stw r10, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830BF294: 4800010C  b 0x830bf3a0
	pc = 0x830BF3A0; continue 'dispatch;
	// 830BF298: 83FD0008  lwz r31, 8(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 830BF29C: 7D7AF850  subf r11, r26, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[26].s64;
	// 830BF2A0: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 830BF2A4: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 830BF2A8: 40980084  bge cr6, 0x830bf32c
	if !ctx.cr[6].lt {
	pc = 0x830BF32C; continue 'dispatch;
	}
	// 830BF2AC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830BF2B0: 4182001C  beq 0x830bf2cc
	if ctx.cr[0].eq {
	pc = 0x830BF2CC; continue 'dispatch;
	}
	// 830BF2B4: 5564103A  slwi r4, r11, 2
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 830BF2B8: 578B103A  slwi r11, r28, 2
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830BF2BC: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 830BF2C0: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 830BF2C4: 7C6BD214  add r3, r11, r26
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 830BF2C8: 480E9A41  bl 0x831a8d08
	ctx.lr = 0x830BF2CC;
	sub_831A8D08(ctx, base);
	// 830BF2CC: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 830BF2D0: 7D7A5050  subf r11, r26, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[26].s64;
	// 830BF2D4: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 830BF2D8: 7D6BE051  subf. r11, r11, r28
	ctx.r[11].s64 = ctx.r[28].s64 - ctx.r[11].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BF2DC: 4182001C  beq 0x830bf2f8
	if ctx.cr[0].eq {
	pc = 0x830BF2F8; continue 'dispatch;
	}
	// 830BF2E0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830BF2E4: 41820014  beq 0x830bf2f8
	if ctx.cr[0].eq {
	pc = 0x830BF2F8; continue 'dispatch;
	}
	// 830BF2E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830BF2EC: 932A0000  stw r25, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 830BF2F0: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 830BF2F4: 4200FFF8  bdnz 0x830bf2ec
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x830BF2EC; continue 'dispatch;
	}
	// 830BF2F8: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 830BF2FC: 578A103A  slwi r10, r28, 2
	ctx.r[10].u32 = ctx.r[28].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830BF300: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	// 830BF304: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 830BF308: 7D4A5850  subf r10, r10, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 830BF30C: 917D0008  stw r11, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830BF310: 7F1A5040  cmplw cr6, r26, r10
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830BF314: 419A008C  beq cr6, 0x830bf3a0
	if ctx.cr[6].eq {
	pc = 0x830BF3A0; continue 'dispatch;
	}
	// 830BF318: 93290000  stw r25, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 830BF31C: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 830BF320: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830BF324: 409AFFF4  bne cr6, 0x830bf318
	if !ctx.cr[6].eq {
	pc = 0x830BF318; continue 'dispatch;
	}
	// 830BF328: 48000078  b 0x830bf3a0
	pc = 0x830BF3A0; continue 'dispatch;
	// 830BF32C: 579B103A  slwi r27, r28, 2
	ctx.r[27].u32 = ctx.r[28].u32.wrapping_shl(2);
	ctx.r[27].u64 = ctx.r[27].u32 as u64;
	// 830BF330: 7FDBF850  subf r30, r27, r31
	ctx.r[30].s64 = ctx.r[31].s64 - ctx.r[27].s64;
	// 830BF334: 7D7EF850  subf r11, r30, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[30].s64;
	// 830BF338: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BF33C: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 830BF340: 7F86FA14  add r28, r6, r31
	ctx.r[28].u64 = ctx.r[6].u64 + ctx.r[31].u64;
	// 830BF344: 41820014  beq 0x830bf358
	if ctx.cr[0].eq {
	pc = 0x830BF358; continue 'dispatch;
	}
	// 830BF348: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830BF34C: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 830BF350: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BF354: 480E99B5  bl 0x831a8d08
	ctx.lr = 0x830BF358;
	sub_831A8D08(ctx, base);
	// 830BF358: 7D7AF050  subf r11, r26, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[26].s64;
	// 830BF35C: 939D0008  stw r28, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 830BF360: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BF364: 4081001C  ble 0x830bf380
	if !ctx.cr[0].gt {
	pc = 0x830BF380; continue 'dispatch;
	}
	// 830BF368: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830BF36C: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 830BF370: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 830BF374: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 830BF378: 7C6BF850  subf r3, r11, r31
	ctx.r[3].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 830BF37C: 480E998D  bl 0x831a8d08
	ctx.lr = 0x830BF380;
	sub_831A8D08(ctx, base);
	// 830BF380: 7D5BD214  add r10, r27, r26
	ctx.r[10].u64 = ctx.r[27].u64 + ctx.r[26].u64;
	// 830BF384: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 830BF388: 7F1A5040  cmplw cr6, r26, r10
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830BF38C: 419A0014  beq cr6, 0x830bf3a0
	if ctx.cr[6].eq {
	pc = 0x830BF3A0; continue 'dispatch;
	}
	// 830BF390: 932B0000  stw r25, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 830BF394: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 830BF398: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830BF39C: 409AFFF4  bne cr6, 0x830bf390
	if !ctx.cr[6].eq {
	pc = 0x830BF390; continue 'dispatch;
	}
	// 830BF3A0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830BF3A4: 480E8E08  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BF3A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830BF3A8 size=228
    let mut pc: u32 = 0x830BF3A8;
    'dispatch: loop {
        match pc {
            0x830BF3A8 => {
    //   block [0x830BF3A8..0x830BF48C)
	// 830BF3A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BF3AC: 480E8DBD  bl 0x831a8168
	ctx.lr = 0x830BF3B0;
	sub_831A8130(ctx, base);
	// 830BF3B0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BF3B4: 3D603FFF  lis r11, 0x3fff
	ctx.r[11].s64 = 1073676288;
	// 830BF3B8: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 830BF3BC: 616BFFFF  ori r11, r11, 0xffff
	ctx.r[11].u64 = ctx.r[11].u64 | 65535;
	// 830BF3C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830BF3C4: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830BF3C8: 4099000C  ble cr6, 0x830bf3d4
	if !ctx.cr[6].gt {
	pc = 0x830BF3D4; continue 'dispatch;
	}
	// 830BF3CC: 4BAF8955  bl 0x82bb7d20
	ctx.lr = 0x830BF3D0;
	sub_82BB7D20(ctx, base);
	// 830BF3D0: 480000B4  b 0x830bf484
	pc = 0x830BF484; continue 'dispatch;
	// 830BF3D4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BF3D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830BF3DC: 419A0010  beq cr6, 0x830bf3ec
	if ctx.cr[6].eq {
	pc = 0x830BF3EC; continue 'dispatch;
	}
	// 830BF3E0: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830BF3E4: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 830BF3E8: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 830BF3EC: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 830BF3F0: 40980094  bge cr6, 0x830bf484
	if !ctx.cr[6].lt {
	pc = 0x830BF484; continue 'dispatch;
	}
	// 830BF3F4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830BF3F8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830BF3FC: 4B92EA6D  bl 0x829ede68
	ctx.lr = 0x830BF400;
	sub_829EDE68(ctx, base);
	// 830BF400: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BF404: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830BF408: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830BF40C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 830BF410: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 830BF414: 419A0028  beq cr6, 0x830bf43c
	if ctx.cr[6].eq {
	pc = 0x830BF43C; continue 'dispatch;
	}
	// 830BF418: 7D5E5050  subf r10, r30, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[30].s64;
	// 830BF41C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830BF420: 419A000C  beq cr6, 0x830bf42c
	if ctx.cr[6].eq {
	pc = 0x830BF42C; continue 'dispatch;
	}
	// 830BF424: 7D0A582E  lwzx r8, r10, r11
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830BF428: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 830BF42C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 830BF430: 7D0A5A14  add r8, r10, r11
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 830BF434: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 830BF438: 409AFFE4  bne cr6, 0x830bf41c
	if !ctx.cr[6].eq {
	pc = 0x830BF41C; continue 'dispatch;
	}
	// 830BF43C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BF440: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830BF444: 409A000C  bne cr6, 0x830bf450
	if !ctx.cr[6].eq {
	pc = 0x830BF450; continue 'dispatch;
	}
	// 830BF448: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830BF44C: 48000010  b 0x830bf45c
	pc = 0x830BF45C; continue 'dispatch;
	// 830BF450: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830BF454: 7D635850  subf r11, r3, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 830BF458: 7D7D1670  srawi r29, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[29].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 830BF45C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830BF460: 419A0008  beq cr6, 0x830bf468
	if ctx.cr[6].eq {
	pc = 0x830BF468; continue 'dispatch;
	}
	// 830BF464: 4B200E05  bl 0x822c0268
	ctx.lr = 0x830BF468;
	sub_822C0268(ctx, base);
	// 830BF468: 578A103A  slwi r10, r28, 2
	ctx.r[10].u32 = ctx.r[28].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830BF46C: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 830BF470: 57AB103A  slwi r11, r29, 2
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830BF474: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 830BF478: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 830BF47C: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 830BF480: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830BF484: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830BF488: 480E8D30  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BF490(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830BF490 size=108
    let mut pc: u32 = 0x830BF490;
    'dispatch: loop {
        match pc {
            0x830BF490 => {
    //   block [0x830BF490..0x830BF4FC)
	// 830BF490: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BF494: 480E8CD9  bl 0x831a816c
	ctx.lr = 0x830BF498;
	sub_831A8130(ctx, base);
	// 830BF498: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BF49C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830BF4A0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830BF4A4: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 830BF4A8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BF4AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830BF4B0: 419A0014  beq cr6, 0x830bf4c4
	if ctx.cr[6].eq {
	pc = 0x830BF4C4; continue 'dispatch;
	}
	// 830BF4B4: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830BF4B8: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 830BF4BC: 7D4A1671  srawi. r10, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830BF4C0: 4082000C  bne 0x830bf4cc
	if !ctx.cr[0].eq {
	pc = 0x830BF4CC; continue 'dispatch;
	}
	// 830BF4C4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830BF4C8: 4800000C  b 0x830bf4d4
	pc = 0x830BF4D4; continue 'dispatch;
	// 830BF4CC: 7D6B2050  subf r11, r11, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[11].s64;
	// 830BF4D0: 7D7D1670  srawi r29, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[29].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 830BF4D4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830BF4D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BF4DC: 4BFFFBED  bl 0x830bf0c8
	ctx.lr = 0x830BF4E0;
	sub_830BF0C8(ctx, base);
	// 830BF4E0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BF4E4: 57AB103A  slwi r11, r29, 2
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830BF4E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830BF4EC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830BF4F0: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830BF4F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830BF4F8: 480E8CC4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BF500(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830BF500 size=132
    let mut pc: u32 = 0x830BF500;
    'dispatch: loop {
        match pc {
            0x830BF500 => {
    //   block [0x830BF500..0x830BF584)
	// 830BF500: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BF504: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830BF508: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BF50C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BF510: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 830BF514: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830BF518: 409A000C  bne cr6, 0x830bf524
	if !ctx.cr[6].eq {
	pc = 0x830BF524; continue 'dispatch;
	}
	// 830BF51C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830BF520: 48000010  b 0x830bf530
	pc = 0x830BF530; continue 'dispatch;
	// 830BF524: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 830BF528: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 830BF52C: 7D4A1670  srawi r10, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 2) as i64;
	// 830BF530: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830BF534: 419A0030  beq cr6, 0x830bf564
	if ctx.cr[6].eq {
	pc = 0x830BF564; continue 'dispatch;
	}
	// 830BF538: 8123000C  lwz r9, 0xc(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 830BF53C: 7D6B4850  subf r11, r11, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 830BF540: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 830BF544: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830BF548: 4098001C  bge cr6, 0x830bf564
	if !ctx.cr[6].lt {
	pc = 0x830BF564; continue 'dispatch;
	}
	// 830BF54C: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 830BF550: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BF554: 392B0004  addi r9, r11, 4
	ctx.r[9].s64 = ctx.r[11].s64 + 4;
	// 830BF558: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830BF55C: 91230008  stw r9, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 830BF560: 48000014  b 0x830bf574
	pc = 0x830BF574; continue 'dispatch;
	// 830BF564: 80A30008  lwz r5, 8(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 830BF568: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830BF56C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830BF570: 4BFFFF21  bl 0x830bf490
	ctx.lr = 0x830BF574;
	sub_830BF490(ctx, base);
	// 830BF574: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830BF578: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830BF57C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830BF580: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BF588(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830BF588 size=188
    let mut pc: u32 = 0x830BF588;
    'dispatch: loop {
        match pc {
            0x830BF588 => {
    //   block [0x830BF588..0x830BF644)
	// 830BF588: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BF58C: 480E8BE1  bl 0x831a816c
	ctx.lr = 0x830BF590;
	sub_831A8130(ctx, base);
	// 830BF590: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BF594: 83ED0000  lwz r31, 0(r13)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BF598: 3BA00048  li r29, 0x48
	ctx.r[29].s64 = 72;
	// 830BF59C: 7D7FE82E  lwzx r11, r31, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 830BF5A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830BF5A4: 409A0098  bne cr6, 0x830bf63c
	if !ctx.cr[6].eq {
	pc = 0x830BF63C; continue 'dispatch;
	}
	// 830BF5A8: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 830BF5AC: 4B20138D  bl 0x822c0938
	ctx.lr = 0x830BF5B0;
	sub_822C0938(ctx, base);
	// 830BF5B0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830BF5B4: 41820018  beq 0x830bf5cc
	if ctx.cr[0].eq {
	pc = 0x830BF5CC; continue 'dispatch;
	}
	// 830BF5B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830BF5BC: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830BF5C0: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830BF5C4: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 830BF5C8: 48000008  b 0x830bf5d0
	pc = 0x830BF5D0; continue 'dispatch;
	// 830BF5CC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830BF5D0: 7C7FE92E  stwx r3, r31, r29
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[29].u32), ctx.r[3].u32) };
	// 830BF5D4: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 830BF5D8: 4BFFFDD1  bl 0x830bf3a8
	ctx.lr = 0x830BF5DC;
	sub_830BF3A8(ctx, base);
	// 830BF5DC: 3D608218  lis r11, -0x7de8
	ctx.r[11].s64 = -2112356352;
	// 830BF5E0: 38A0003E  li r5, 0x3e
	ctx.r[5].s64 = 62;
	// 830BF5E4: 3BCB7760  addi r30, r11, 0x7760
	ctx.r[30].s64 = ctx.r[11].s64 + 30560;
	// 830BF5E8: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 830BF5EC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830BF5F0: 4BFF5669  bl 0x830b4c58
	ctx.lr = 0x830BF5F4;
	sub_830B4C58(ctx, base);
	// 830BF5F4: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 830BF5F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830BF5FC: 396B0018  addi r11, r11, 0x18
	ctx.r[11].s64 = ctx.r[11].s64 + 24;
	// 830BF600: 38A0003F  li r5, 0x3f
	ctx.r[5].s64 = 63;
	// 830BF604: 7C7F592E  stwx r3, r31, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32), ctx.r[3].u32) };
	// 830BF608: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 830BF60C: 4BFF564D  bl 0x830b4c58
	ctx.lr = 0x830BF610;
	sub_830B4C58(ctx, base);
	// 830BF610: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 830BF614: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 830BF618: 394A001C  addi r10, r10, 0x1c
	ctx.r[10].s64 = ctx.r[10].s64 + 28;
	// 830BF61C: 7FDF5A14  add r30, r31, r11
	ctx.r[30].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 830BF620: 7C7F512E  stwx r3, r31, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[10].u32), ctx.r[3].u32) };
	// 830BF624: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830BF628: 4BFFF259  bl 0x830be880
	ctx.lr = 0x830BF62C;
	sub_830BE880(ctx, base);
	// 830BF62C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 830BF630: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830BF634: 7C7FE82E  lwzx r3, r31, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 830BF638: 4BFFFEC9  bl 0x830bf500
	ctx.lr = 0x830BF63C;
	sub_830BF500(ctx, base);
	// 830BF63C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830BF640: 480E8B7C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BF648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830BF648 size=132
    let mut pc: u32 = 0x830BF648;
    'dispatch: loop {
        match pc {
            0x830BF648 => {
    //   block [0x830BF648..0x830BF6CC)
	// 830BF648: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BF64C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830BF650: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830BF654: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830BF658: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BF65C: 83ED0000  lwz r31, 0(r13)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BF660: 3BC00048  li r30, 0x48
	ctx.r[30].s64 = 72;
	// 830BF664: 90610084  stw r3, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 830BF668: 7C7FF02E  lwzx r3, r31, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 830BF66C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830BF670: 409A0018  bne cr6, 0x830bf688
	if !ctx.cr[6].eq {
	pc = 0x830BF688; continue 'dispatch;
	}
	// 830BF674: 3D608218  lis r11, -0x7de8
	ctx.r[11].s64 = -2112356352;
	// 830BF678: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830BF67C: 386B74F8  addi r3, r11, 0x74f8
	ctx.r[3].s64 = ctx.r[11].s64 + 29944;
	// 830BF680: 4BFF9509  bl 0x830b8b88
	ctx.lr = 0x830BF684;
	sub_830B8B88(ctx, base);
	// 830BF684: 48000000  b 0x830bf684
	pc = 0x830BF684; continue 'dispatch;
	// 830BF688: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 830BF68C: 39400044  li r10, 0x44
	ctx.r[10].s64 = 68;
	// 830BF690: 38810084  addi r4, r1, 0x84
	ctx.r[4].s64 = ctx.r[1].s64 + 132;
	// 830BF694: 816BFFFC  lwz r11, -4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 830BF698: 7D7F512E  stwx r11, r31, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 830BF69C: 4BFFFE65  bl 0x830bf500
	ctx.lr = 0x830BF6A0;
	sub_830BF500(ctx, base);
	// 830BF6A0: 7D5FF02E  lwzx r10, r31, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 830BF6A4: 39600040  li r11, 0x40
	ctx.r[11].s64 = 64;
	// 830BF6A8: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 830BF6AC: 814AFFFC  lwz r10, -4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-4 as u32) ) } as u64;
	// 830BF6B0: 7D5F592E  stwx r10, r31, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32), ctx.r[10].u32) };
	// 830BF6B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830BF6B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830BF6BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830BF6C0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830BF6C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830BF6C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BF6D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BF6D0 size=16
    let mut pc: u32 = 0x830BF6D0;
    'dispatch: loop {
        match pc {
            0x830BF6D0 => {
    //   block [0x830BF6D0..0x830BF6E0)
	// 830BF6D0: 2B040002  cmplwi cr6, r4, 2
	ctx.cr[6].compare_u32(ctx.r[4].u32, 2 as u32, &mut ctx.xer);
	// 830BF6D4: 419A0034  beq cr6, 0x830bf708
	if ctx.cr[6].eq {
		sub_830BF708(ctx, base);
		return;
	}
	// 830BF6D8: 2B040004  cmplwi cr6, r4, 4
	ctx.cr[6].compare_u32(ctx.r[4].u32, 4 as u32, &mut ctx.xer);
	// 830BF6DC: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BF6E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BF6E0 size=40
    let mut pc: u32 = 0x830BF6E0;
    'dispatch: loop {
        match pc {
            0x830BF6E0 => {
    //   block [0x830BF6E0..0x830BF708)
	// 830BF6E0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BF6E4: 89430000  lbz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BF6E8: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 830BF6EC: 5568C42E  rlwinm r8, r11, 0x18, 0x10, 0x17
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 830BF6F0: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 830BF6F4: 552B401E  rlwinm r11, r9, 8, 0, 0xf
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 830BF6F8: 7D6B4378  or r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[8].u64;
	// 830BF6FC: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 830BF700: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830BF704: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BF708(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BF708 size=24
    let mut pc: u32 = 0x830BF708;
    'dispatch: loop {
        match pc {
            0x830BF708 => {
    //   block [0x830BF708..0x830BF720)
	// 830BF708: A1630000  lhz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BF70C: 89430000  lbz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BF710: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 830BF714: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 830BF718: B1630000  sth r11, 0(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 830BF71C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BF720(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830BF720 size=16
    let mut pc: u32 = 0x830BF720;
    'dispatch: loop {
        match pc {
            0x830BF720 => {
    //   block [0x830BF720..0x830BF730)
	// 830BF720: D021FFF0  stfs f1, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 830BF724: D041FFF4  stfs f2, -0xc(r1)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 830BF728: E861FFF0  ld r3, -0x10(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830BF72C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BF730(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830BF730 size=136
    let mut pc: u32 = 0x830BF730;
    'dispatch: loop {
        match pc {
            0x830BF730 => {
    //   block [0x830BF730..0x830BF7B8)
	// 830BF730: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BF734: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830BF738: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830BF73C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830BF740: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BF744: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830BF748: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830BF74C: 897F0008  lbz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830BF750: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830BF754: 40820020  bne 0x830bf774
	if !ctx.cr[0].eq {
	pc = 0x830BF774; continue 'dispatch;
	}
	// 830BF758: 57CB063E  clrlwi r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 830BF75C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830BF760: 409A0014  bne cr6, 0x830bf774
	if !ctx.cr[6].eq {
	pc = 0x830BF774; continue 'dispatch;
	}
	// 830BF764: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BF768: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BF76C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830BF770: 4E800421  bctrl
	ctx.lr = 0x830BF774;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830BF774: 897F0008  lbz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830BF778: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830BF77C: 409A0020  bne cr6, 0x830bf79c
	if !ctx.cr[6].eq {
	pc = 0x830BF79C; continue 'dispatch;
	}
	// 830BF780: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BF784: 40820018  bne 0x830bf79c
	if !ctx.cr[0].eq {
	pc = 0x830BF79C; continue 'dispatch;
	}
	// 830BF788: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BF78C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BF790: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830BF794: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830BF798: 4E800421  bctrl
	ctx.lr = 0x830BF79C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830BF79C: 9BDF0008  stb r30, 8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u8 ) };
	// 830BF7A0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830BF7A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830BF7A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830BF7AC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830BF7B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830BF7B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BF7B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BF7B8 size=8
    let mut pc: u32 = 0x830BF7B8;
    'dispatch: loop {
        match pc {
            0x830BF7B8 => {
    //   block [0x830BF7B8..0x830BF7C0)
	// 830BF7B8: 98830009  stb r4, 9(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(9 as u32), ctx.r[4].u8 ) };
	// 830BF7BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BF7C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BF7C0 size=64
    let mut pc: u32 = 0x830BF7C0;
    'dispatch: loop {
        match pc {
            0x830BF7C0 => {
    //   block [0x830BF7C0..0x830BF800)
	// 830BF7C0: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BF7C4: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830BF7C8: 91440000  stw r10, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830BF7CC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830BF7D0: 892A0039  lbz r9, 0x39(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(57 as u32) ) } as u64;
	// 830BF7D4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 830BF7D8: 409A0008  bne cr6, 0x830bf7e0
	if !ctx.cr[6].eq {
	pc = 0x830BF7E0; continue 'dispatch;
	}
	// 830BF7DC: 908A0004  stw r4, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 830BF7E0: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BF7E4: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 830BF7E8: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BF7EC: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BF7F0: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 830BF7F4: 409A000C  bne cr6, 0x830bf800
	if !ctx.cr[6].eq {
		sub_830BF800(ctx, base);
		return;
	}
	// 830BF7F8: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830BF7FC: 48000020  b 0x830bf81c
	sub_830BF818(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BF800(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BF800 size=24
    let mut pc: u32 = 0x830BF800;
    'dispatch: loop {
        match pc {
            0x830BF800 => {
    //   block [0x830BF800..0x830BF818)
	// 830BF800: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BF804: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 830BF808: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 830BF80C: 409A000C  bne cr6, 0x830bf818
	if !ctx.cr[6].eq {
		sub_830BF818(ctx, base);
		return;
	}
	// 830BF810: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830BF814: 48000008  b 0x830bf81c
	sub_830BF818(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BF818(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BF818 size=16
    let mut pc: u32 = 0x830BF818;
    'dispatch: loop {
        match pc {
            0x830BF818 => {
    //   block [0x830BF818..0x830BF828)
	// 830BF818: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830BF81C: 908B0008  stw r4, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 830BF820: 91640004  stw r11, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830BF824: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BF828(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BF828 size=16
    let mut pc: u32 = 0x830BF828;
    'dispatch: loop {
        match pc {
            0x830BF828 => {
    //   block [0x830BF828..0x830BF838)
	// 830BF828: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BF82C: 894B0019  lbz r10, 0x19(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 830BF830: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830BF834: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BF838(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BF838 size=24
    let mut pc: u32 = 0x830BF838;
    'dispatch: loop {
        match pc {
            0x830BF838 => {
    //   block [0x830BF838..0x830BF850)
	// 830BF838: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830BF83C: 892A0019  lbz r9, 0x19(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(25 as u32) ) } as u64;
	// 830BF840: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 830BF844: 409A0040  bne cr6, 0x830bf884
	if !ctx.cr[6].eq {
		sub_830BF86C(ctx, base);
		return;
	}
	// 830BF848: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BF84C: 4800000C  b 0x830bf858
	sub_830BF850(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BF850(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BF850 size=28
    let mut pc: u32 = 0x830BF850;
    'dispatch: loop {
        match pc {
            0x830BF850 => {
    //   block [0x830BF850..0x830BF86C)
	// 830BF850: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 830BF854: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BF858: 892B0019  lbz r9, 0x19(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 830BF85C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 830BF860: 419AFFF0  beq cr6, 0x830bf850
	if ctx.cr[6].eq {
	pc = 0x830BF850; continue 'dispatch;
	}
	// 830BF864: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830BF868: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BF86C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BF86C size=48
    let mut pc: u32 = 0x830BF86C;
    'dispatch: loop {
        match pc {
            0x830BF86C => {
    //   block [0x830BF86C..0x830BF89C)
	// 830BF86C: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BF870: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830BF874: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 830BF878: 409A001C  bne cr6, 0x830bf894
	if !ctx.cr[6].eq {
	pc = 0x830BF894; continue 'dispatch;
	}
	// 830BF87C: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830BF880: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830BF884: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BF888: 894B0019  lbz r10, 0x19(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 830BF88C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830BF890: 419AFFDC  beq cr6, 0x830bf86c
	if ctx.cr[6].eq {
	pc = 0x830BF86C; continue 'dispatch;
	}
	// 830BF894: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830BF898: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BF8A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830BF8A0 size=116
    let mut pc: u32 = 0x830BF8A0;
    'dispatch: loop {
        match pc {
            0x830BF8A0 => {
    //   block [0x830BF8A0..0x830BF914)
	// 830BF8A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BF8A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830BF8A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830BF8AC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BF8B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830BF8B4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830BF8B8: 419A0040  beq cr6, 0x830bf8f8
	if ctx.cr[6].eq {
	pc = 0x830BF8F8; continue 'dispatch;
	}
	// 830BF8BC: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 830BF8C0: 0CDF0000  twi 6, r31, 0
	// 830BF8C4: 7D6BFB96  divwu r11, r11, r31
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[31].u32;
	// 830BF8C8: 2B0B001C  cmplwi cr6, r11, 0x1c
	ctx.cr[6].compare_u32(ctx.r[11].u32, 28 as u32, &mut ctx.xer);
	// 830BF8CC: 4098002C  bge cr6, 0x830bf8f8
	if !ctx.cr[6].lt {
	pc = 0x830BF8F8; continue 'dispatch;
	}
	// 830BF8D0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830BF8D4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830BF8D8: 396B0828  addi r11, r11, 0x828
	ctx.r[11].s64 = ctx.r[11].s64 + 2088;
	// 830BF8DC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 830BF8E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830BF8E4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830BF8E8: 4B2049C9  bl 0x822c42b0
	ctx.lr = 0x830BF8EC;
	sub_822C42B0(ctx, base);
	// 830BF8EC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830BF8F0: 396B0818  addi r11, r11, 0x818
	ctx.r[11].s64 = ctx.r[11].s64 + 2072;
	// 830BF8F4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830BF8F8: 1C7F001C  mulli r3, r31, 0x1c
	ctx.r[3].s64 = ctx.r[31].s64 * 28;
	// 830BF8FC: 4B20103D  bl 0x822c0938
	ctx.lr = 0x830BF900;
	sub_822C0938(ctx, base);
	// 830BF900: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830BF904: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830BF908: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830BF90C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830BF910: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BF918(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830BF918 size=116
    let mut pc: u32 = 0x830BF918;
    'dispatch: loop {
        match pc {
            0x830BF918 => {
    //   block [0x830BF918..0x830BF98C)
	// 830BF918: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BF91C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830BF920: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830BF924: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BF928: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830BF92C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830BF930: 419A0040  beq cr6, 0x830bf970
	if ctx.cr[6].eq {
	pc = 0x830BF970; continue 'dispatch;
	}
	// 830BF934: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 830BF938: 0CDF0000  twi 6, r31, 0
	// 830BF93C: 7D6BFB96  divwu r11, r11, r31
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[31].u32;
	// 830BF940: 2B0B0010  cmplwi cr6, r11, 0x10
	ctx.cr[6].compare_u32(ctx.r[11].u32, 16 as u32, &mut ctx.xer);
	// 830BF944: 4098002C  bge cr6, 0x830bf970
	if !ctx.cr[6].lt {
	pc = 0x830BF970; continue 'dispatch;
	}
	// 830BF948: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830BF94C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830BF950: 396B0828  addi r11, r11, 0x828
	ctx.r[11].s64 = ctx.r[11].s64 + 2088;
	// 830BF954: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 830BF958: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830BF95C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830BF960: 4B204951  bl 0x822c42b0
	ctx.lr = 0x830BF964;
	sub_822C42B0(ctx, base);
	// 830BF964: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830BF968: 396B0818  addi r11, r11, 0x818
	ctx.r[11].s64 = ctx.r[11].s64 + 2072;
	// 830BF96C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830BF970: 57E32036  slwi r3, r31, 4
	ctx.r[3].u32 = ctx.r[31].u32.wrapping_shl(4);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 830BF974: 4B200FC5  bl 0x822c0938
	ctx.lr = 0x830BF978;
	sub_822C0938(ctx, base);
	// 830BF978: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830BF97C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830BF980: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830BF984: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830BF988: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BF990(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830BF990 size=116
    let mut pc: u32 = 0x830BF990;
    'dispatch: loop {
        match pc {
            0x830BF990 => {
    //   block [0x830BF990..0x830BFA04)
	// 830BF990: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BF994: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830BF998: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830BF99C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BF9A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830BF9A4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830BF9A8: 419A0040  beq cr6, 0x830bf9e8
	if ctx.cr[6].eq {
	pc = 0x830BF9E8; continue 'dispatch;
	}
	// 830BF9AC: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 830BF9B0: 0CDF0000  twi 6, r31, 0
	// 830BF9B4: 7D6BFB96  divwu r11, r11, r31
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[31].u32;
	// 830BF9B8: 2B0B0040  cmplwi cr6, r11, 0x40
	ctx.cr[6].compare_u32(ctx.r[11].u32, 64 as u32, &mut ctx.xer);
	// 830BF9BC: 4098002C  bge cr6, 0x830bf9e8
	if !ctx.cr[6].lt {
	pc = 0x830BF9E8; continue 'dispatch;
	}
	// 830BF9C0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830BF9C4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830BF9C8: 396B0828  addi r11, r11, 0x828
	ctx.r[11].s64 = ctx.r[11].s64 + 2088;
	// 830BF9CC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 830BF9D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830BF9D4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830BF9D8: 4B2048D9  bl 0x822c42b0
	ctx.lr = 0x830BF9DC;
	sub_822C42B0(ctx, base);
	// 830BF9DC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830BF9E0: 396B0818  addi r11, r11, 0x818
	ctx.r[11].s64 = ctx.r[11].s64 + 2072;
	// 830BF9E4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830BF9E8: 57E33032  slwi r3, r31, 6
	ctx.r[3].u32 = ctx.r[31].u32.wrapping_shl(6);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 830BF9EC: 4B200F4D  bl 0x822c0938
	ctx.lr = 0x830BF9F0;
	sub_822C0938(ctx, base);
	// 830BF9F0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830BF9F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830BF9F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830BF9FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830BFA00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BFA08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BFA08 size=12
    let mut pc: u32 = 0x830BFA08;
    'dispatch: loop {
        match pc {
            0x830BFA08 => {
    //   block [0x830BFA08..0x830BFA14)
	// 830BFA08: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 830BFA0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830BFA10: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BFA14(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BFA14 size=8
    let mut pc: u32 = 0x830BFA14;
    'dispatch: loop {
        match pc {
            0x830BFA14 => {
    //   block [0x830BFA14..0x830BFA1C)
	// 830BFA14: 988B0050  stb r4, 0x50(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(80 as u32), ctx.r[4].u8 ) };
	// 830BFA18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BFA20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BFA20 size=12
    let mut pc: u32 = 0x830BFA20;
    'dispatch: loop {
        match pc {
            0x830BFA20 => {
    //   block [0x830BFA20..0x830BFA2C)
	// 830BFA20: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 830BFA24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830BFA28: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BFA2C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BFA2C size=8
    let mut pc: u32 = 0x830BFA2C;
    'dispatch: loop {
        match pc {
            0x830BFA2C => {
    //   block [0x830BFA2C..0x830BFA34)
	// 830BFA2C: 988B004F  stb r4, 0x4f(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(79 as u32), ctx.r[4].u8 ) };
	// 830BFA30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BFA38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830BFA38 size=72
    let mut pc: u32 = 0x830BFA38;
    'dispatch: loop {
        match pc {
            0x830BFA38 => {
    //   block [0x830BFA38..0x830BFA80)
	// 830BFA38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BFA3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830BFA40: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BFA44: 80630044  lwz r3, 0x44(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(68 as u32) ) } as u64;
	// 830BFA48: D0610044  stfs f3, 0x44(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 830BFA4C: D0410024  stfs f2, 0x24(r1)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 830BFA50: E9210044  ld r9, 0x44(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(68 as u32) ) };
	// 830BFA54: D021001C  stfs f1, 0x1c(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 830BFA58: E8A10024  ld r5, 0x24(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(36 as u32) ) };
	// 830BFA5C: E881001C  ld r4, 0x1c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) };
	// 830BFA60: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BFA64: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BFA68: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830BFA6C: 4E800421  bctrl
	ctx.lr = 0x830BFA70;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830BFA70: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830BFA74: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830BFA78: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830BFA7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BFA80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BFA80 size=16
    let mut pc: u32 = 0x830BFA80;
    'dispatch: loop {
        match pc {
            0x830BFA80 => {
    //   block [0x830BFA80..0x830BFA90)
	// 830BFA80: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 830BFA84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830BFA88: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 830BFA8C: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BFA90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BFA90 size=8
    let mut pc: u32 = 0x830BFA90;
    'dispatch: loop {
        match pc {
            0x830BFA90 => {
    //   block [0x830BFA90..0x830BFA98)
	// 830BFA90: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 830BFA94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BFA98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BFA98 size=12
    let mut pc: u32 = 0x830BFA98;
    'dispatch: loop {
        match pc {
            0x830BFA98 => {
    //   block [0x830BFA98..0x830BFAA4)
	// 830BFA98: 8063000C  lwz r3, 0xc(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 830BFA9C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830BFAA0: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BFAA4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BFAA4 size=8
    let mut pc: u32 = 0x830BFAA4;
    'dispatch: loop {
        match pc {
            0x830BFAA4 => {
    //   block [0x830BFAA4..0x830BFAAC)
	// 830BFAA4: 480087C4  b 0x830c8268
	sub_830C8268(ctx, base);
	return;
	// 830BFAA8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BFAB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BFAB0 size=32
    let mut pc: u32 = 0x830BFAB0;
    'dispatch: loop {
        match pc {
            0x830BFAB0 => {
    //   block [0x830BFAB0..0x830BFAD0)
	// 830BFAB0: 81630054  lwz r11, 0x54(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(84 as u32) ) } as u64;
	// 830BFAB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830BFAB8: 419A0018  beq cr6, 0x830bfad0
	if ctx.cr[6].eq {
		sub_830BFAD0(ctx, base);
		return;
	}
	// 830BFABC: 816B0064  lwz r11, 0x64(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 830BFAC0: 7D6B2050  subf r11, r11, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[11].s64;
	// 830BFAC4: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 830BFAC8: 5563DFFE  rlwinm r3, r11, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830BFACC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BFAD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BFAD0 size=8
    let mut pc: u32 = 0x830BFAD0;
    'dispatch: loop {
        match pc {
            0x830BFAD0 => {
    //   block [0x830BFAD0..0x830BFAD8)
	// 830BFAD0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830BFAD4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BFAD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BFAD8 size=20
    let mut pc: u32 = 0x830BFAD8;
    'dispatch: loop {
        match pc {
            0x830BFAD8 => {
    //   block [0x830BFAD8..0x830BFAEC)
	// 830BFAD8: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BFADC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BFAE0: 894B0039  lbz r10, 0x39(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(57 as u32) ) } as u64;
	// 830BFAE4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830BFAE8: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BFAEC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BFAEC size=40
    let mut pc: u32 = 0x830BFAEC;
    'dispatch: loop {
        match pc {
            0x830BFAEC => {
    //   block [0x830BFAEC..0x830BFB14)
	// 830BFAEC: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BFAF0: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830BFAF4: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 830BFAF8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830BFAFC: 41980008  blt cr6, 0x830bfb04
	if ctx.cr[6].lt {
	pc = 0x830BFB04; continue 'dispatch;
	}
	// 830BFB00: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830BFB04: 554A063F  clrlwi. r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830BFB08: 4182000C  beq 0x830bfb14
	if ctx.cr[0].eq {
		sub_830BFB14(ctx, base);
		return;
	}
	// 830BFB0C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830BFB10: 4800000C  b 0x830bfb1c
	sub_830BFB14(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BFB14(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BFB14 size=24
    let mut pc: u32 = 0x830BFB14;
    'dispatch: loop {
        match pc {
            0x830BFB14 => {
    //   block [0x830BFB14..0x830BFB2C)
	// 830BFB14: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 830BFB18: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BFB1C: 894B0039  lbz r10, 0x39(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(57 as u32) ) } as u64;
	// 830BFB20: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830BFB24: 419AFFCC  beq cr6, 0x830bfaf0
	if ctx.cr[6].eq {
		sub_830BFAEC(ctx, base);
		return;
	}
	// 830BFB28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BFB30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BFB30 size=64
    let mut pc: u32 = 0x830BFB30;
    'dispatch: loop {
        match pc {
            0x830BFB30 => {
    //   block [0x830BFB30..0x830BFB70)
	// 830BFB30: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 830BFB34: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BFB38: 91440008  stw r10, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830BFB3C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BFB40: 892A0039  lbz r9, 0x39(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(57 as u32) ) } as u64;
	// 830BFB44: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 830BFB48: 409A0008  bne cr6, 0x830bfb50
	if !ctx.cr[6].eq {
	pc = 0x830BFB50; continue 'dispatch;
	}
	// 830BFB4C: 908A0004  stw r4, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 830BFB50: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BFB54: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 830BFB58: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BFB5C: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BFB60: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 830BFB64: 409A000C  bne cr6, 0x830bfb70
	if !ctx.cr[6].eq {
		sub_830BFB70(ctx, base);
		return;
	}
	// 830BFB68: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830BFB6C: 48000020  b 0x830bfb8c
	sub_830BFB88(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BFB70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BFB70 size=24
    let mut pc: u32 = 0x830BFB70;
    'dispatch: loop {
        match pc {
            0x830BFB70 => {
    //   block [0x830BFB70..0x830BFB88)
	// 830BFB70: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BFB74: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BFB78: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 830BFB7C: 409A000C  bne cr6, 0x830bfb88
	if !ctx.cr[6].eq {
		sub_830BFB88(ctx, base);
		return;
	}
	// 830BFB80: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830BFB84: 48000008  b 0x830bfb8c
	sub_830BFB88(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BFB88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BFB88 size=16
    let mut pc: u32 = 0x830BFB88;
    'dispatch: loop {
        match pc {
            0x830BFB88 => {
    //   block [0x830BFB88..0x830BFB98)
	// 830BFB88: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830BFB8C: 908B0000  stw r4, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 830BFB90: 91640004  stw r11, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830BFB94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BFB98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BFB98 size=24
    let mut pc: u32 = 0x830BFB98;
    'dispatch: loop {
        match pc {
            0x830BFB98 => {
    //   block [0x830BFB98..0x830BFBB0)
	// 830BFB98: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BFB9C: 894B0039  lbz r10, 0x39(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(57 as u32) ) } as u64;
	// 830BFBA0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830BFBA4: 419A000C  beq cr6, 0x830bfbb0
	if ctx.cr[6].eq {
		sub_830BFBB0(ctx, base);
		return;
	}
	// 830BFBA8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830BFBAC: 48000070  b 0x830bfc1c
	sub_830BFC1C(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BFBB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BFBB0 size=24
    let mut pc: u32 = 0x830BFBB0;
    'dispatch: loop {
        match pc {
            0x830BFBB0 => {
    //   block [0x830BFBB0..0x830BFBC8)
	// 830BFBB0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BFBB4: 892A0039  lbz r9, 0x39(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(57 as u32) ) } as u64;
	// 830BFBB8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 830BFBBC: 409A0040  bne cr6, 0x830bfbfc
	if !ctx.cr[6].eq {
		sub_830BFBE4(ctx, base);
		return;
	}
	// 830BFBC0: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 830BFBC4: 4800000C  b 0x830bfbd0
	sub_830BFBC8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BFBC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BFBC8 size=28
    let mut pc: u32 = 0x830BFBC8;
    'dispatch: loop {
        match pc {
            0x830BFBC8 => {
    //   block [0x830BFBC8..0x830BFBE4)
	// 830BFBC8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 830BFBCC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830BFBD0: 892B0039  lbz r9, 0x39(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(57 as u32) ) } as u64;
	// 830BFBD4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 830BFBD8: 419AFFF0  beq cr6, 0x830bfbc8
	if ctx.cr[6].eq {
	pc = 0x830BFBC8; continue 'dispatch;
	}
	// 830BFBDC: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830BFBE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BFBE4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BFBE4 size=56
    let mut pc: u32 = 0x830BFBE4;
    'dispatch: loop {
        match pc {
            0x830BFBE4 => {
    //   block [0x830BFBE4..0x830BFC1C)
	// 830BFBE4: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BFBE8: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BFBEC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 830BFBF0: 409A001C  bne cr6, 0x830bfc0c
	if !ctx.cr[6].eq {
	pc = 0x830BFC0C; continue 'dispatch;
	}
	// 830BFBF4: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830BFBF8: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830BFBFC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BFC00: 894B0039  lbz r10, 0x39(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(57 as u32) ) } as u64;
	// 830BFC04: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830BFC08: 419AFFDC  beq cr6, 0x830bfbe4
	if ctx.cr[6].eq {
	pc = 0x830BFBE4; continue 'dispatch;
	}
	// 830BFC0C: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BFC10: 894A0039  lbz r10, 0x39(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(57 as u32) ) } as u64;
	// 830BFC14: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830BFC18: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BFC1C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830BFC1C size=8
    let mut pc: u32 = 0x830BFC1C;
    'dispatch: loop {
        match pc {
            0x830BFC1C => {
    //   block [0x830BFC1C..0x830BFC24)
	// 830BFC1C: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830BFC20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BFC28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830BFC28 size=120
    let mut pc: u32 = 0x830BFC28;
    'dispatch: loop {
        match pc {
            0x830BFC28 => {
    //   block [0x830BFC28..0x830BFCA0)
	// 830BFC28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BFC2C: 480E8541  bl 0x831a816c
	ctx.lr = 0x830BFC30;
	sub_831A8130(ctx, base);
	// 830BFC30: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BFC34: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830BFC38: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 830BFC3C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830BFC40: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830BFC44: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830BFC48: 4BFFFE91  bl 0x830bfad8
	ctx.lr = 0x830BFC4C;
	sub_830BFAD8(ctx, base);
	// 830BFC4C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BFC50: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 830BFC54: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830BFC58: 419A002C  beq cr6, 0x830bfc84
	if ctx.cr[6].eq {
	pc = 0x830BFC84; continue 'dispatch;
	}
	// 830BFC5C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BFC60: 81230010  lwz r9, 0x10(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 830BFC64: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 830BFC68: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830BFC6C: 41980008  blt cr6, 0x830bfc74
	if ctx.cr[6].lt {
	pc = 0x830BFC74; continue 'dispatch;
	}
	// 830BFC70: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830BFC74: 554A063F  clrlwi. r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830BFC78: 4082000C  bne 0x830bfc84
	if !ctx.cr[0].eq {
	pc = 0x830BFC84; continue 'dispatch;
	}
	// 830BFC7C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 830BFC80: 4800000C  b 0x830bfc8c
	pc = 0x830BFC8C; continue 'dispatch;
	// 830BFC84: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 830BFC88: 39610054  addi r11, r1, 0x54
	ctx.r[11].s64 = ctx.r[1].s64 + 84;
	// 830BFC8C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BFC90: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830BFC94: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830BFC98: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830BFC9C: 480E8520  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BFCA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830BFCA0 size=104
    let mut pc: u32 = 0x830BFCA0;
    'dispatch: loop {
        match pc {
            0x830BFCA0 => {
    //   block [0x830BFCA0..0x830BFD08)
	// 830BFCA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BFCA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830BFCA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830BFCAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830BFCB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BFCB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830BFCB8: 7D1E4378  mr r30, r8
	ctx.r[30].u64 = ctx.r[8].u64;
	// 830BFCBC: 397F0010  addi r11, r31, 0x10
	ctx.r[11].s64 = ctx.r[31].s64 + 16;
	// 830BFCC0: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 830BFCC4: 909F0000  stw r4, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 830BFCC8: 38870008  addi r4, r7, 8
	ctx.r[4].s64 = ctx.r[7].s64 + 8;
	// 830BFCCC: 90BF0004  stw r5, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 830BFCD0: 90DF0008  stw r6, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 830BFCD4: 81470000  lwz r10, 0(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BFCD8: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 830BFCDC: 4B4CC235  bl 0x8258bf10
	ctx.lr = 0x830BFCE0;
	sub_8258BF10(ctx, base);
	// 830BFCE0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830BFCE4: 9BDF0038  stb r30, 0x38(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[30].u8 ) };
	// 830BFCE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BFCEC: 997F0039  stb r11, 0x39(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(57 as u32), ctx.r[11].u8 ) };
	// 830BFCF0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830BFCF4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830BFCF8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830BFCFC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830BFD00: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830BFD04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BFD08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830BFD08 size=132
    let mut pc: u32 = 0x830BFD08;
    'dispatch: loop {
        match pc {
            0x830BFD08 => {
    //   block [0x830BFD08..0x830BFD8C)
	// 830BFD08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BFD0C: 480E8461  bl 0x831a816c
	ctx.lr = 0x830BFD10;
	sub_831A8130(ctx, base);
	// 830BFD10: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BFD14: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830BFD18: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830BFD1C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830BFD20: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830BFD24: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 830BFD28: 4BFFFBF1  bl 0x830bf918
	ctx.lr = 0x830BFD2C;
	sub_830BF918(ctx, base);
	// 830BFD2C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830BFD30: 41820008  beq 0x830bfd38
	if ctx.cr[0].eq {
	pc = 0x830BFD38; continue 'dispatch;
	}
	// 830BFD34: 93E30000  stw r31, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 830BFD38: 35630004  addic. r11, r3, 4
	ctx.xer.ca = (ctx.r[3].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BFD3C: 41820008  beq 0x830bfd44
	if ctx.cr[0].eq {
	pc = 0x830BFD44; continue 'dispatch;
	}
	// 830BFD40: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 830BFD44: 35630008  addic. r11, r3, 8
	ctx.xer.ca = (ctx.r[3].u32 > (!(8 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 8;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BFD48: 4182003C  beq 0x830bfd84
	if ctx.cr[0].eq {
	pc = 0x830BFD84; continue 'dispatch;
	}
	// 830BFD4C: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BFD50: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830BFD54: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BFD58: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830BFD5C: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 830BFD60: 419A0024  beq cr6, 0x830bfd84
	if ctx.cr[6].eq {
	pc = 0x830BFD84; continue 'dispatch;
	}
	// 830BFD64: 396A0004  addi r11, r10, 4
	ctx.r[11].s64 = ctx.r[10].s64 + 4;
	// 830BFD68: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 830BFD6C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 830BFD70: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 830BFD74: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830BFD78: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 830BFD7C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 830BFD80: 4082FFE8  bne 0x830bfd68
	if !ctx.cr[0].eq {
	pc = 0x830BFD68; continue 'dispatch;
	}
	// 830BFD84: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830BFD88: 480E8434  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BFD90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830BFD90 size=112
    let mut pc: u32 = 0x830BFD90;
    'dispatch: loop {
        match pc {
            0x830BFD90 => {
    //   block [0x830BFD90..0x830BFE00)
	// 830BFD90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BFD94: 480E83D5  bl 0x831a8168
	ctx.lr = 0x830BFD98;
	sub_831A8130(ctx, base);
	// 830BFD98: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BFD9C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830BFDA0: 83850000  lwz r28, 0(r5)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BFDA4: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 830BFDA8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830BFDAC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BFDB0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830BFDB4: 419A003C  beq cr6, 0x830bfdf0
	if ctx.cr[6].eq {
	pc = 0x830BFDF0; continue 'dispatch;
	}
	// 830BFDB8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BFDBC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830BFDC0: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BFDC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BFDC8: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830BFDCC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BFDD0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BFDD4: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 830BFDD8: 4BD3F3B9  bl 0x82dff190
	ctx.lr = 0x830BFDDC;
	sub_82DFF190(ctx, base);
	// 830BFDDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830BFDE0: 4B200489  bl 0x822c0268
	ctx.lr = 0x830BFDE4;
	sub_822C0268(ctx, base);
	// 830BFDE4: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830BFDE8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830BFDEC: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830BFDF0: 939D0000  stw r28, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 830BFDF4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830BFDF8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830BFDFC: 480E83BC  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830BFE00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830BFE00 size=568
    let mut pc: u32 = 0x830BFE00;
    'dispatch: loop {
        match pc {
            0x830BFE00 => {
    //   block [0x830BFE00..0x830C0038)
	// 830BFE00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830BFE04: 480E8359  bl 0x831a815c
	ctx.lr = 0x830BFE08;
	sub_831A8130(ctx, base);
	// 830BFE08: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830BFE0C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830BFE10: 3D601555  lis r11, 0x1555
	ctx.r[11].s64 = 357892096;
	// 830BFE14: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 830BFE18: 616B5554  ori r11, r11, 0x5554
	ctx.r[11].u64 = ctx.r[11].u64 | 21844;
	// 830BFE1C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 830BFE20: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830BFE24: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 830BFE28: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 830BFE2C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830BFE30: 41980048  blt cr6, 0x830bfe78
	if ctx.cr[6].lt {
	pc = 0x830BFE78; continue 'dispatch;
	}
	// 830BFE34: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 830BFE38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830BFE3C: 388B9BCC  addi r4, r11, -0x6434
	ctx.r[4].s64 = ctx.r[11].s64 + -25652;
	// 830BFE40: 4B205A89  bl 0x822c58c8
	ctx.lr = 0x830BFE44;
	sub_822C58C8(ctx, base);
	// 830BFE44: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830BFE48: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830BFE4C: 4B2059CD  bl 0x822c5818
	ctx.lr = 0x830BFE50;
	sub_822C5818(ctx, base);
	// 830BFE50: 4B204461  bl 0x822c42b0
	ctx.lr = 0x830BFE54;
	sub_822C42B0(ctx, base);
	// 830BFE54: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 830BFE58: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830BFE5C: 396B94A0  addi r11, r11, -0x6b60
	ctx.r[11].s64 = ctx.r[11].s64 + -27488;
	// 830BFE60: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 830BFE64: 4B20560D  bl 0x822c5470
	ctx.lr = 0x830BFE68;
	sub_822C5470(ctx, base);
	// 830BFE68: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830BFE6C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830BFE70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830BFE74: 4B204E6D  bl 0x822c4ce0
	ctx.lr = 0x830BFE78;
	sub_822C4CE0(ctx, base);
	// 830BFE78: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830BFE7C: 83BE0004  lwz r29, 4(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BFE80: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830BFE84: 4BFFFA1D  bl 0x830bf8a0
	ctx.lr = 0x830BFE88;
	sub_830BF8A0(ctx, base);
	// 830BFE88: 7C7C1B79  or. r28, r3, r3
	ctx.r[28].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 830BFE8C: 41820020  beq 0x830bfeac
	if ctx.cr[0].eq {
	pc = 0x830BFEAC; continue 'dispatch;
	}
	// 830BFE90: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 830BFE94: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 830BFE98: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 830BFE9C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830BFEA0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830BFEA4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830BFEA8: 4BD3F281  bl 0x82dff128
	ctx.lr = 0x830BFEAC;
	sub_82DFF128(ctx, base);
	// 830BFEAC: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830BFEB0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BFEB4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830BFEB8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830BFEBC: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830BFEC0: 409A0018  bne cr6, 0x830bfed8
	if !ctx.cr[6].eq {
	pc = 0x830BFED8; continue 'dispatch;
	}
	// 830BFEC4: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 830BFEC8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BFECC: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 830BFED0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BFED4: 4800003C  b 0x830bff10
	pc = 0x830BFF10; continue 'dispatch;
	// 830BFED8: 574B063F  clrlwi. r11, r26, 0x18
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830BFEDC: 41820020  beq 0x830bfefc
	if ctx.cr[0].eq {
	pc = 0x830BFEFC; continue 'dispatch;
	}
	// 830BFEE0: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 830BFEE4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BFEE8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BFEEC: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830BFEF0: 409A0024  bne cr6, 0x830bff14
	if !ctx.cr[6].eq {
	pc = 0x830BFF14; continue 'dispatch;
	}
	// 830BFEF4: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 830BFEF8: 4800001C  b 0x830bff14
	pc = 0x830BFF14; continue 'dispatch;
	// 830BFEFC: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 830BFF00: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BFF04: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830BFF08: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830BFF0C: 409A0008  bne cr6, 0x830bff14
	if !ctx.cr[6].eq {
	pc = 0x830BFF14; continue 'dispatch;
	}
	// 830BFF10: 938B0008  stw r28, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 830BFF14: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BFF18: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 830BFF1C: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 830BFF20: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 830BFF24: 894A0018  lbz r10, 0x18(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 830BFF28: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830BFF2C: 409A00F0  bne cr6, 0x830c001c
	if !ctx.cr[6].eq {
	pc = 0x830C001C; continue 'dispatch;
	}
	// 830BFF30: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 830BFF34: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BFF38: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BFF3C: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BFF40: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 830BFF44: 409A0054  bne cr6, 0x830bff98
	if !ctx.cr[6].eq {
	pc = 0x830BFF98; continue 'dispatch;
	}
	// 830BFF48: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 830BFF4C: 892A0018  lbz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 830BFF50: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 830BFF54: 419A0054  beq cr6, 0x830bffa8
	if ctx.cr[6].eq {
	pc = 0x830BFFA8; continue 'dispatch;
	}
	// 830BFF58: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 830BFF5C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830BFF60: 409A0010  bne cr6, 0x830bff70
	if !ctx.cr[6].eq {
	pc = 0x830BFF70; continue 'dispatch;
	}
	// 830BFF64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830BFF68: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830BFF6C: 4BD522CD  bl 0x82e12238
	ctx.lr = 0x830BFF70;
	sub_82E12238(ctx, base);
	// 830BFF70: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BFF74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830BFF78: 9BAB0018  stb r29, 0x18(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[29].u8 ) };
	// 830BFF7C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BFF80: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BFF84: 9B6B0018  stb r27, 0x18(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[27].u8 ) };
	// 830BFF88: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BFF8C: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BFF90: 4BD52311  bl 0x82e122a0
	ctx.lr = 0x830BFF94;
	sub_82E122A0(ctx, base);
	// 830BFF94: 48000074  b 0x830c0008
	pc = 0x830C0008; continue 'dispatch;
	// 830BFF98: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BFF9C: 892A0018  lbz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 830BFFA0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 830BFFA4: 409A0028  bne cr6, 0x830bffcc
	if !ctx.cr[6].eq {
	pc = 0x830BFFCC; continue 'dispatch;
	}
	// 830BFFA8: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BFFAC: 9BA90018  stb r29, 0x18(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), ctx.r[29].u8 ) };
	// 830BFFB0: 9BAA0018  stb r29, 0x18(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[29].u8 ) };
	// 830BFFB4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BFFB8: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BFFBC: 9B6A0018  stb r27, 0x18(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[27].u8 ) };
	// 830BFFC0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BFFC4: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BFFC8: 48000040  b 0x830c0008
	pc = 0x830C0008; continue 'dispatch;
	// 830BFFCC: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830BFFD0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830BFFD4: 409A0010  bne cr6, 0x830bffe4
	if !ctx.cr[6].eq {
	pc = 0x830BFFE4; continue 'dispatch;
	}
	// 830BFFD8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830BFFDC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830BFFE0: 4BD522C1  bl 0x82e122a0
	ctx.lr = 0x830BFFE4;
	sub_82E122A0(ctx, base);
	// 830BFFE4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BFFE8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830BFFEC: 9BAB0018  stb r29, 0x18(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[29].u8 ) };
	// 830BFFF0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BFFF4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830BFFF8: 9B6B0018  stb r27, 0x18(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[27].u8 ) };
	// 830BFFFC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C0000: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C0004: 4BD52235  bl 0x82e12238
	ctx.lr = 0x830C0008;
	sub_82E12238(ctx, base);
	// 830C0008: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C000C: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 830C0010: 894A0018  lbz r10, 0x18(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 830C0014: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830C0018: 419AFF1C  beq cr6, 0x830bff34
	if ctx.cr[6].eq {
	pc = 0x830BFF34; continue 'dispatch;
	}
	// 830C001C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C0020: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 830C0024: 93990000  stw r28, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 830C0028: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C002C: 9BAB0018  stb r29, 0x18(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[29].u8 ) };
	// 830C0030: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 830C0034: 480E8178  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C0038(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C0038 size=568
    let mut pc: u32 = 0x830C0038;
    'dispatch: loop {
        match pc {
            0x830C0038 => {
    //   block [0x830C0038..0x830C0270)
	// 830C0038: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C003C: 480E8121  bl 0x831a815c
	ctx.lr = 0x830C0040;
	sub_831A8130(ctx, base);
	// 830C0040: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C0044: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830C0048: 3D600666  lis r11, 0x666
	ctx.r[11].s64 = 107347968;
	// 830C004C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 830C0050: 616B6665  ori r11, r11, 0x6665
	ctx.r[11].u64 = ctx.r[11].u64 | 26213;
	// 830C0054: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 830C0058: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C005C: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 830C0060: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 830C0064: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830C0068: 41980048  blt cr6, 0x830c00b0
	if ctx.cr[6].lt {
	pc = 0x830C00B0; continue 'dispatch;
	}
	// 830C006C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 830C0070: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C0074: 388B9BCC  addi r4, r11, -0x6434
	ctx.r[4].s64 = ctx.r[11].s64 + -25652;
	// 830C0078: 4B205851  bl 0x822c58c8
	ctx.lr = 0x830C007C;
	sub_822C58C8(ctx, base);
	// 830C007C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830C0080: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830C0084: 4B205795  bl 0x822c5818
	ctx.lr = 0x830C0088;
	sub_822C5818(ctx, base);
	// 830C0088: 4B204229  bl 0x822c42b0
	ctx.lr = 0x830C008C;
	sub_822C42B0(ctx, base);
	// 830C008C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 830C0090: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830C0094: 396B94A0  addi r11, r11, -0x6b60
	ctx.r[11].s64 = ctx.r[11].s64 + -27488;
	// 830C0098: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 830C009C: 4B2053D5  bl 0x822c5470
	ctx.lr = 0x830C00A0;
	sub_822C5470(ctx, base);
	// 830C00A0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830C00A4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830C00A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C00AC: 4B204C35  bl 0x822c4ce0
	ctx.lr = 0x830C00B0;
	sub_822C4CE0(ctx, base);
	// 830C00B0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830C00B4: 83BE0004  lwz r29, 4(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C00B8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830C00BC: 4BFFF8D5  bl 0x830bf990
	ctx.lr = 0x830C00C0;
	sub_830BF990(ctx, base);
	// 830C00C0: 7C7C1B79  or. r28, r3, r3
	ctx.r[28].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 830C00C4: 41820020  beq 0x830c00e4
	if ctx.cr[0].eq {
	pc = 0x830C00E4; continue 'dispatch;
	}
	// 830C00C8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 830C00CC: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 830C00D0: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 830C00D4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830C00D8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830C00DC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830C00E0: 4BFFFBC1  bl 0x830bfca0
	ctx.lr = 0x830C00E4;
	sub_830BFCA0(ctx, base);
	// 830C00E4: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C00E8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C00EC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830C00F0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830C00F4: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830C00F8: 409A0018  bne cr6, 0x830c0110
	if !ctx.cr[6].eq {
	pc = 0x830C0110; continue 'dispatch;
	}
	// 830C00FC: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 830C0100: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C0104: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 830C0108: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C010C: 4800003C  b 0x830c0148
	pc = 0x830C0148; continue 'dispatch;
	// 830C0110: 574B063F  clrlwi. r11, r26, 0x18
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830C0114: 41820020  beq 0x830c0134
	if ctx.cr[0].eq {
	pc = 0x830C0134; continue 'dispatch;
	}
	// 830C0118: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 830C011C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C0120: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C0124: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830C0128: 409A0024  bne cr6, 0x830c014c
	if !ctx.cr[6].eq {
	pc = 0x830C014C; continue 'dispatch;
	}
	// 830C012C: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 830C0130: 4800001C  b 0x830c014c
	pc = 0x830C014C; continue 'dispatch;
	// 830C0134: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 830C0138: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C013C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C0140: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830C0144: 409A0008  bne cr6, 0x830c014c
	if !ctx.cr[6].eq {
	pc = 0x830C014C; continue 'dispatch;
	}
	// 830C0148: 938B0008  stw r28, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 830C014C: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C0150: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 830C0154: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 830C0158: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 830C015C: 894A0038  lbz r10, 0x38(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(56 as u32) ) } as u64;
	// 830C0160: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830C0164: 409A00F0  bne cr6, 0x830c0254
	if !ctx.cr[6].eq {
	pc = 0x830C0254; continue 'dispatch;
	}
	// 830C0168: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 830C016C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C0170: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C0174: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C0178: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 830C017C: 409A0054  bne cr6, 0x830c01d0
	if !ctx.cr[6].eq {
	pc = 0x830C01D0; continue 'dispatch;
	}
	// 830C0180: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C0184: 892A0038  lbz r9, 0x38(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(56 as u32) ) } as u64;
	// 830C0188: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 830C018C: 419A0054  beq cr6, 0x830c01e0
	if ctx.cr[6].eq {
	pc = 0x830C01E0; continue 'dispatch;
	}
	// 830C0190: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C0194: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830C0198: 409A0010  bne cr6, 0x830c01a8
	if !ctx.cr[6].eq {
	pc = 0x830C01A8; continue 'dispatch;
	}
	// 830C019C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830C01A0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830C01A4: 4BFFF98D  bl 0x830bfb30
	ctx.lr = 0x830C01A8;
	sub_830BFB30(ctx, base);
	// 830C01A8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C01AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830C01B0: 9BAB0038  stb r29, 0x38(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), ctx.r[29].u8 ) };
	// 830C01B4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C01B8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C01BC: 9B6B0038  stb r27, 0x38(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), ctx.r[27].u8 ) };
	// 830C01C0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C01C4: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C01C8: 4BFFF5F9  bl 0x830bf7c0
	ctx.lr = 0x830C01CC;
	sub_830BF7C0(ctx, base);
	// 830C01CC: 48000074  b 0x830c0240
	pc = 0x830C0240; continue 'dispatch;
	// 830C01D0: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C01D4: 892A0038  lbz r9, 0x38(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(56 as u32) ) } as u64;
	// 830C01D8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 830C01DC: 409A0028  bne cr6, 0x830c0204
	if !ctx.cr[6].eq {
	pc = 0x830C0204; continue 'dispatch;
	}
	// 830C01E0: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C01E4: 9BA90038  stb r29, 0x38(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(56 as u32), ctx.r[29].u8 ) };
	// 830C01E8: 9BAA0038  stb r29, 0x38(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(56 as u32), ctx.r[29].u8 ) };
	// 830C01EC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C01F0: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C01F4: 9B6A0038  stb r27, 0x38(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(56 as u32), ctx.r[27].u8 ) };
	// 830C01F8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C01FC: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C0200: 48000040  b 0x830c0240
	pc = 0x830C0240; continue 'dispatch;
	// 830C0204: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C0208: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830C020C: 409A0010  bne cr6, 0x830c021c
	if !ctx.cr[6].eq {
	pc = 0x830C021C; continue 'dispatch;
	}
	// 830C0210: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830C0214: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830C0218: 4BFFF5A9  bl 0x830bf7c0
	ctx.lr = 0x830C021C;
	sub_830BF7C0(ctx, base);
	// 830C021C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C0220: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830C0224: 9BAB0038  stb r29, 0x38(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), ctx.r[29].u8 ) };
	// 830C0228: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C022C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C0230: 9B6B0038  stb r27, 0x38(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), ctx.r[27].u8 ) };
	// 830C0234: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C0238: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C023C: 4BFFF8F5  bl 0x830bfb30
	ctx.lr = 0x830C0240;
	sub_830BFB30(ctx, base);
	// 830C0240: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C0244: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 830C0248: 894A0038  lbz r10, 0x38(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(56 as u32) ) } as u64;
	// 830C024C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830C0250: 419AFF1C  beq cr6, 0x830c016c
	if ctx.cr[6].eq {
	pc = 0x830C016C; continue 'dispatch;
	}
	// 830C0254: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C0258: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 830C025C: 93990000  stw r28, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 830C0260: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C0264: 9BAB0038  stb r29, 0x38(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), ctx.r[29].u8 ) };
	// 830C0268: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 830C026C: 480E7F40  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C0270(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C0270 size=244
    let mut pc: u32 = 0x830C0270;
    'dispatch: loop {
        match pc {
            0x830C0270 => {
    //   block [0x830C0270..0x830C0364)
	// 830C0270: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C0274: 480E7EF9  bl 0x831a816c
	ctx.lr = 0x830C0278;
	sub_831A8130(ctx, base);
	// 830C0278: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C027C: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 830C0280: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C0284: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830C0288: 3BBF001C  addi r29, r31, 0x1c
	ctx.r[29].s64 = ctx.r[31].s64 + 28;
	// 830C028C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 830C0290: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830C0294: 4BD550E5  bl 0x82e15378
	ctx.lr = 0x830C0298;
	sub_82E15378(ctx, base);
	// 830C0298: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 830C029C: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830C02A0: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830C02A4: 419A00B4  beq cr6, 0x830c0358
	if ctx.cr[6].eq {
	pc = 0x830C0358; continue 'dispatch;
	}
	// 830C02A8: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830C02AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C02B0: 419A00A8  beq cr6, 0x830c0358
	if ctx.cr[6].eq {
	pc = 0x830C0358; continue 'dispatch;
	}
	// 830C02B4: 807F0054  lwz r3, 0x54(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 830C02B8: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830C02BC: 7F0B1800  cmpw cr6, r11, r3
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[3].s32, &mut ctx.xer);
	// 830C02C0: 409A0030  bne cr6, 0x830c02f0
	if !ctx.cr[6].eq {
	pc = 0x830C02F0; continue 'dispatch;
	}
	// 830C02C4: 39600006  li r11, 6
	ctx.r[11].s64 = 6;
	// 830C02C8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830C02CC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 830C02D0: 48003641  bl 0x830c3910
	ctx.lr = 0x830C02D4;
	sub_830C3910(ctx, base);
	// 830C02D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830C02D8: 917F0054  stw r11, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 830C02DC: 807F0058  lwz r3, 0x58(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 830C02E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830C02E4: 917F0058  stw r11, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 830C02E8: 419A0008  beq cr6, 0x830c02f0
	if ctx.cr[6].eq {
	pc = 0x830C02F0; continue 'dispatch;
	}
	// 830C02EC: 4B2005A5  bl 0x822c0890
	ctx.lr = 0x830C02F0;
	sub_822C0890(ctx, base);
	// 830C02F0: 39600007  li r11, 7
	ctx.r[11].s64 = 7;
	// 830C02F4: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 830C02F8: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 830C02FC: 807E0010  lwz r3, 0x10(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830C0300: 48003611  bl 0x830c3910
	ctx.lr = 0x830C0304;
	sub_830C3910(ctx, base);
	// 830C0304: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 830C0308: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C030C: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830C0310: 419A0030  beq cr6, 0x830c0340
	if ctx.cr[6].eq {
	pc = 0x830C0340; continue 'dispatch;
	}
	// 830C0314: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830C0318: 81250008  lwz r9, 8(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C031C: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830C0320: 419A0014  beq cr6, 0x830c0334
	if ctx.cr[6].eq {
	pc = 0x830C0334; continue 'dispatch;
	}
	// 830C0324: 80A50000  lwz r5, 0(r5)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C0328: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830C032C: 409AFFEC  bne cr6, 0x830c0318
	if !ctx.cr[6].eq {
	pc = 0x830C0318; continue 'dispatch;
	}
	// 830C0330: 48000010  b 0x830c0340
	pc = 0x830C0340; continue 'dispatch;
	// 830C0334: 389F002C  addi r4, r31, 0x2c
	ctx.r[4].s64 = ctx.r[31].s64 + 44;
	// 830C0338: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 830C033C: 4BFFFA55  bl 0x830bfd90
	ctx.lr = 0x830C0340;
	sub_830BFD90(ctx, base);
	// 830C0340: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830C0344: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830C0348: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 830C034C: 4BD580AD  bl 0x82e183f8
	ctx.lr = 0x830C0350;
	sub_82E183F8(ctx, base);
	// 830C0350: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830C0354: 48000008  b 0x830c035c
	pc = 0x830C035C; continue 'dispatch;
	// 830C0358: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830C035C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830C0360: 480E7E5C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C0368(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830C0368 size=236
    let mut pc: u32 = 0x830C0368;
    'dispatch: loop {
        match pc {
            0x830C0368 => {
    //   block [0x830C0368..0x830C0454)
	// 830C0368: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C036C: 480E7DF5  bl 0x831a8160
	ctx.lr = 0x830C0370;
	sub_831A8130(ctx, base);
	// 830C0370: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C0374: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 830C0378: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 830C037C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C0380: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 830C0384: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 830C0388: 83DC0004  lwz r30, 4(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C038C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C0390: 894B0019  lbz r10, 0x19(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 830C0394: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830C0398: 409A0038  bne cr6, 0x830c03d0
	if !ctx.cr[6].eq {
	pc = 0x830C03D0; continue 'dispatch;
	}
	// 830C039C: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C03A0: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830C03A4: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 830C03A8: 7D295010  subfc r9, r9, r10
	ctx.xer.ca = ctx.r[10].u32 >= ctx.r[9].u32;
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 830C03AC: 7D294910  subfe r9, r9, r9
	let x = (!ctx.r[9].u32);
	let y = ctx.r[9].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[9].u32 = res;
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 830C03B0: 553D07FF  clrlwi. r29, r9, 0x1f
	ctx.r[29].u64 = ctx.r[9].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830C03B4: 4182000C  beq 0x830c03c0
	if ctx.cr[0].eq {
	pc = 0x830C03C0; continue 'dispatch;
	}
	// 830C03B8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C03BC: 48000008  b 0x830c03c4
	pc = 0x830C03C4; continue 'dispatch;
	// 830C03C0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C03C4: 892B0019  lbz r9, 0x19(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 830C03C8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 830C03CC: 419AFFD4  beq cr6, 0x830c03a0
	if ctx.cr[6].eq {
	pc = 0x830C03A0; continue 'dispatch;
	}
	// 830C03D0: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 830C03D4: 57AA063F  clrlwi. r10, r29, 0x18
	ctx.r[10].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830C03D8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C03DC: 41820044  beq 0x830c0420
	if ctx.cr[0].eq {
	pc = 0x830C0420; continue 'dispatch;
	}
	// 830C03E0: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C03E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C03E8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C03EC: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830C03F0: 409A0028  bne cr6, 0x830c0418
	if !ctx.cr[6].eq {
	pc = 0x830C0418; continue 'dispatch;
	}
	// 830C03F4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830C03F8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830C03FC: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 830C0400: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 830C0404: 4BFFF9FD  bl 0x830bfe00
	ctx.lr = 0x830C0408;
	sub_830BFE00(ctx, base);
	// 830C0408: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 830C040C: 9B5F0004  stb r26, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[26].u8 ) };
	// 830C0410: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C0414: 48000030  b 0x830c0444
	pc = 0x830C0444; continue 'dispatch;
	// 830C0418: 4BD5AE31  bl 0x82e1b248
	ctx.lr = 0x830C041C;
	sub_82E1B248(ctx, base);
	// 830C041C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830C0420: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830C0424: 813B0000  lwz r9, 0(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C0428: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 830C042C: 40980010  bge cr6, 0x830c043c
	if !ctx.cr[6].lt {
	pc = 0x830C043C; continue 'dispatch;
	}
	// 830C0430: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830C0434: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C0438: 4BFFFFC0  b 0x830c03f8
	pc = 0x830C03F8; continue 'dispatch;
	// 830C043C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830C0440: 995F0004  stb r10, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u8 ) };
	// 830C0444: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830C0448: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C044C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830C0450: 480E7D60  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C0458(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C0458 size=356
    let mut pc: u32 = 0x830C0458;
    'dispatch: loop {
        match pc {
            0x830C0458 => {
    //   block [0x830C0458..0x830C05BC)
	// 830C0458: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C045C: 480E7D01  bl 0x831a815c
	ctx.lr = 0x830C0460;
	sub_831A8130(ctx, base);
	// 830C0460: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C0464: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 830C0468: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C046C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830C0470: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 830C0474: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C0478: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C047C: 409A0020  bne cr6, 0x830c049c
	if !ctx.cr[6].eq {
	pc = 0x830C049C; continue 'dispatch;
	}
	// 830C0480: 80DC0004  lwz r6, 4(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C0484: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830C0488: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 830C048C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830C0490: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C0494: 4BFFF96D  bl 0x830bfe00
	ctx.lr = 0x830C0498;
	sub_830BFE00(ctx, base);
	// 830C0498: 48000118  b 0x830c05b0
	pc = 0x830C05B0; continue 'dispatch;
	// 830C049C: 833C0004  lwz r25, 4(r28)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C04A0: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C04A4: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830C04A8: 409A001C  bne cr6, 0x830c04c4
	if !ctx.cr[6].eq {
	pc = 0x830C04C4; continue 'dispatch;
	}
	// 830C04AC: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C04B0: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 830C04B4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830C04B8: 409800DC  bge cr6, 0x830c0594
	if !ctx.cr[6].lt {
	pc = 0x830C0594; continue 'dispatch;
	}
	// 830C04BC: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 830C04C0: 4BFFFFC4  b 0x830c0484
	pc = 0x830C0484; continue 'dispatch;
	// 830C04C4: 7F1EC840  cmplw cr6, r30, r25
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[25].u32, &mut ctx.xer);
	// 830C04C8: 409A0020  bne cr6, 0x830c04e8
	if !ctx.cr[6].eq {
	pc = 0x830C04E8; continue 'dispatch;
	}
	// 830C04CC: 80D90008  lwz r6, 8(r25)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C04D0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C04D4: 8146000C  lwz r10, 0xc(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 830C04D8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830C04DC: 409800B8  bge cr6, 0x830c0594
	if !ctx.cr[6].lt {
	pc = 0x830C0594; continue 'dispatch;
	}
	// 830C04E0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830C04E4: 4BFFFFA4  b 0x830c0488
	pc = 0x830C0488; continue 'dispatch;
	// 830C04E8: 837D0000  lwz r27, 0(r29)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C04EC: 835E000C  lwz r26, 0xc(r30)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 830C04F0: 7F1AD840  cmplw cr6, r26, r27
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[27].u32, &mut ctx.xer);
	// 830C04F4: 40990054  ble cr6, 0x830c0548
	if !ctx.cr[6].gt {
	pc = 0x830C0548; continue 'dispatch;
	}
	// 830C04F8: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 830C04FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C0500: 4BD5AD49  bl 0x82e1b248
	ctx.lr = 0x830C0504;
	sub_82E1B248(ctx, base);
	// 830C0504: 80C10050  lwz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830C0508: 8166000C  lwz r11, 0xc(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 830C050C: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 830C0510: 40980034  bge cr6, 0x830c0544
	if !ctx.cr[6].lt {
	pc = 0x830C0544; continue 'dispatch;
	}
	// 830C0514: 81660008  lwz r11, 8(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C0518: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 830C051C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830C0520: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C0524: 896B0019  lbz r11, 0x19(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 830C0528: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C052C: 419A000C  beq cr6, 0x830c0538
	if ctx.cr[6].eq {
	pc = 0x830C0538; continue 'dispatch;
	}
	// 830C0530: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830C0534: 4BFFFF60  b 0x830c0494
	pc = 0x830C0494; continue 'dispatch;
	// 830C0538: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 830C053C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830C0540: 4BFFFF54  b 0x830c0494
	pc = 0x830C0494; continue 'dispatch;
	// 830C0544: 7F1AD840  cmplw cr6, r26, r27
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[27].u32, &mut ctx.xer);
	// 830C0548: 4098004C  bge cr6, 0x830c0594
	if !ctx.cr[6].lt {
	pc = 0x830C0594; continue 'dispatch;
	}
	// 830C054C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 830C0550: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C0554: 4BFFF2D5  bl 0x830bf828
	ctx.lr = 0x830C0558;
	sub_830BF828(ctx, base);
	// 830C0558: 80C10050  lwz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830C055C: 7F06C840  cmplw cr6, r6, r25
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[25].u32, &mut ctx.xer);
	// 830C0560: 419A0010  beq cr6, 0x830c0570
	if ctx.cr[6].eq {
	pc = 0x830C0570; continue 'dispatch;
	}
	// 830C0564: 8166000C  lwz r11, 0xc(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 830C0568: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830C056C: 40980028  bge cr6, 0x830c0594
	if !ctx.cr[6].lt {
	pc = 0x830C0594; continue 'dispatch;
	}
	// 830C0570: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C0574: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 830C0578: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830C057C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C0580: 896B0019  lbz r11, 0x19(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 830C0584: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C0588: 419AFFB4  beq cr6, 0x830c053c
	if ctx.cr[6].eq {
	pc = 0x830C053C; continue 'dispatch;
	}
	// 830C058C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 830C0590: 4BFFFFA0  b 0x830c0530
	pc = 0x830C0530; continue 'dispatch;
	// 830C0594: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830C0598: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830C059C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C05A0: 4BFFFDC9  bl 0x830c0368
	ctx.lr = 0x830C05A4;
	sub_830C0368(ctx, base);
	// 830C05A4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 830C05A8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C05AC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830C05B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C05B4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830C05B8: 480E7BF4  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C05C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C05C0 size=264
    let mut pc: u32 = 0x830C05C0;
    'dispatch: loop {
        match pc {
            0x830C05C0 => {
    //   block [0x830C05C0..0x830C06C8)
	// 830C05C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C05C4: 480E7B9D  bl 0x831a8160
	ctx.lr = 0x830C05C8;
	sub_831A8130(ctx, base);
	// 830C05C8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C05CC: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 830C05D0: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 830C05D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C05D8: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 830C05DC: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 830C05E0: 83DC0004  lwz r30, 4(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C05E4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C05E8: 894B0039  lbz r10, 0x39(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(57 as u32) ) } as u64;
	// 830C05EC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830C05F0: 409A0040  bne cr6, 0x830c0630
	if !ctx.cr[6].eq {
	pc = 0x830C0630; continue 'dispatch;
	}
	// 830C05F4: 813B0000  lwz r9, 0(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C05F8: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830C05FC: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 830C0600: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830C0604: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 830C0608: 41980008  blt cr6, 0x830c0610
	if ctx.cr[6].lt {
	pc = 0x830C0610; continue 'dispatch;
	}
	// 830C060C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830C0610: 555D063F  clrlwi. r29, r10, 0x18
	ctx.r[29].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830C0614: 4182000C  beq 0x830c0620
	if ctx.cr[0].eq {
	pc = 0x830C0620; continue 'dispatch;
	}
	// 830C0618: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C061C: 48000008  b 0x830c0624
	pc = 0x830C0624; continue 'dispatch;
	// 830C0620: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C0624: 894B0039  lbz r10, 0x39(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(57 as u32) ) } as u64;
	// 830C0628: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830C062C: 419AFFCC  beq cr6, 0x830c05f8
	if ctx.cr[6].eq {
	pc = 0x830C05F8; continue 'dispatch;
	}
	// 830C0630: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 830C0634: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830C0638: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 830C063C: 41820048  beq 0x830c0684
	if ctx.cr[0].eq {
	pc = 0x830C0684; continue 'dispatch;
	}
	// 830C0640: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C0644: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C0648: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C064C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830C0650: 409A002C  bne cr6, 0x830c067c
	if !ctx.cr[6].eq {
	pc = 0x830C067C; continue 'dispatch;
	}
	// 830C0654: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830C0658: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830C065C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 830C0660: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 830C0664: 4BFFF9D5  bl 0x830c0038
	ctx.lr = 0x830C0668;
	sub_830C0038(ctx, base);
	// 830C0668: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 830C066C: 9B5F0004  stb r26, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[26].u8 ) };
	// 830C0670: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C0674: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830C0678: 48000044  b 0x830c06bc
	pc = 0x830C06BC; continue 'dispatch;
	// 830C067C: 4BFFF51D  bl 0x830bfb98
	ctx.lr = 0x830C0680;
	sub_830BFB98(ctx, base);
	// 830C0680: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830C0684: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 830C0688: 813B0000  lwz r9, 0(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C068C: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 830C0690: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 830C0694: 41980008  blt cr6, 0x830c069c
	if ctx.cr[6].lt {
	pc = 0x830C069C; continue 'dispatch;
	}
	// 830C0698: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830C069C: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830C06A0: 41820010  beq 0x830c06b0
	if ctx.cr[0].eq {
	pc = 0x830C06B0; continue 'dispatch;
	}
	// 830C06A4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830C06A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C06AC: 4BFFFFAC  b 0x830c0658
	pc = 0x830C0658; continue 'dispatch;
	// 830C06B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830C06B4: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830C06B8: 997F0004  stb r11, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u8 ) };
	// 830C06BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830C06C0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830C06C4: 480E7AEC  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C06C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C06C8 size=108
    let mut pc: u32 = 0x830C06C8;
    'dispatch: loop {
        match pc {
            0x830C06C8 => {
    //   block [0x830C06C8..0x830C0734)
	// 830C06C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C06CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C06D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830C06D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C06D8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C06DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830C06E0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830C06E4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C06E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C06EC: 409A0018  bne cr6, 0x830c0704
	if !ctx.cr[6].eq {
	pc = 0x830C0704; continue 'dispatch;
	}
	// 830C06F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C06F4: 4B212EE5  bl 0x822d35d8
	ctx.lr = 0x830C06F8;
	sub_822D35D8(ctx, base);
	// 830C06F8: 4B1FF909  bl 0x822c0000
	ctx.lr = 0x830C06FC;
	sub_822C0000(ctx, base);
	// 830C06FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C0700: 4B212111  bl 0x822d2810
	ctx.lr = 0x830C0704;
	sub_822D2810(ctx, base);
	// 830C0704: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C0708: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830C070C: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 830C0710: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C0714: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830C0718: 4E800421  bctrl
	ctx.lr = 0x830C071C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830C071C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830C0720: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C0724: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C0728: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830C072C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C0730: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C0738(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C0738 size=112
    let mut pc: u32 = 0x830C0738;
    'dispatch: loop {
        match pc {
            0x830C0738 => {
    //   block [0x830C0738..0x830C07A8)
	// 830C0738: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C073C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C0740: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830C0744: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C0748: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C074C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830C0750: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830C0754: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830C0758: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830C075C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 830C0760: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C0764: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830C0768: 4BFFF4C1  bl 0x830bfc28
	ctx.lr = 0x830C076C;
	sub_830BFC28(ctx, base);
	// 830C076C: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C0770: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830C0774: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830C0778: 419A0014  beq cr6, 0x830c078c
	if ctx.cr[6].eq {
	pc = 0x830C078C; continue 'dispatch;
	}
	// 830C077C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830C0780: 386B0018  addi r3, r11, 0x18
	ctx.r[3].s64 = ctx.r[11].s64 + 24;
	// 830C0784: 4BFFFF45  bl 0x830c06c8
	ctx.lr = 0x830C0788;
	sub_830C06C8(ctx, base);
	// 830C0788: 48000008  b 0x830c0790
	pc = 0x830C0790; continue 'dispatch;
	// 830C078C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830C0790: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830C0794: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C0798: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C079C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830C07A0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C07A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830C07A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830C07A8 size=200
    let mut pc: u32 = 0x830C07A8;
    'dispatch: loop {
        match pc {
            0x830C07A8 => {
    //   block [0x830C07A8..0x830C0870)
	// 830C07A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830C07AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830C07B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830C07B4: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830C07B8: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C07BC: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C07C0: 892B0019  lbz r9, 0x19(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 830C07C4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 830C07C8: 409A0030  bne cr6, 0x830c07f8
	if !ctx.cr[6].eq {
	pc = 0x830C07F8; continue 'dispatch;
	}
	// 830C07CC: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C07D0: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830C07D4: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 830C07D8: 4098000C  bge cr6, 0x830c07e4
	if !ctx.cr[6].lt {
	pc = 0x830C07E4; continue 'dispatch;
	}
	// 830C07DC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830C07E0: 4800000C  b 0x830c07ec
	pc = 0x830C07EC; continue 'dispatch;
	// 830C07E4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 830C07E8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C07EC: 890B0019  lbz r8, 0x19(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 830C07F0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 830C07F4: 419AFFDC  beq cr6, 0x830c07d0
	if ctx.cr[6].eq {
	pc = 0x830C07D0; continue 'dispatch;
	}
	// 830C07F8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830C07FC: 7D5F5378  mr r31, r10
	ctx.r[31].u64 = ctx.r[10].u64;
	// 830C0800: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830C0804: 419A0014  beq cr6, 0x830c0818
	if ctx.cr[6].eq {
	pc = 0x830C0818; continue 'dispatch;
	}
	// 830C0808: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C080C: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 830C0810: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830C0814: 40980044  bge cr6, 0x830c0858
	if !ctx.cr[6].lt {
	pc = 0x830C0858; continue 'dispatch;
	}
	// 830C0818: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C081C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830C0820: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830C0824: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 830C0828: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 830C082C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 830C0830: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830C0834: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830C0838: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 830C083C: 4BFFFC1D  bl 0x830c0458
	ctx.lr = 0x830C0840;
	sub_830C0458(ctx, base);
	// 830C0840: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830C0844: 83E30000  lwz r31, 0(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830C0848: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830C084C: 419A000C  beq cr6, 0x830c0858
	if ctx.cr[6].eq {
	pc = 0x830C0858; continue 'dispatch;
	}
	// 830C0850: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 830C0854: 4B20003D  bl 0x822c0890
	ctx.lr = 0x830C0858;
	sub_822C0890(ctx, base);
	// 830C0858: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 830C085C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830C0860: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830C0864: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830C0868: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830C086C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


